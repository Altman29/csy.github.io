---
title: 重拾设计模式（零）- 朝花夕拾
tags:
  - 设计模式相关
categories:
  - 设计模式
index_img: /img/design_pattern/designpattern.png
excerpt: 设计模式概述、UML、软件设计原则。
abbrlink: 77e3381c
date: 2019-02-13 11:25:02
keywords:
---
## 概述

设计模式是在软件设计中经常出现的问题的通用解决方案。这些解决方案是经过反复验证和证明的，并且被广泛接受和应用于软件开发中。设计模式提供了一种可重用的思想框架，可以帮助开发人员更有效地解决常见问题，并提高代码的可维护性、可读性和可扩展性。

编程是一门技术，更加是一门艺术，不能只满足于写完代码运行结果正确就完事，时常考虑如何让代码更加简练，更加容易维护，容易扩展和复用，只有这样才可以真正得到提高。

## 设计原则

设计模式的使用应该遵循一些基本的设计原则，这些原则有助于编写更清晰、灵活、可维护和可扩展的代码。以下是一些常见的设计原则：

1. **单一职责原则（Single Responsibility Principle - SRP）：** 一个类应该只有一个修改的理由。每个类都应该专注于一项任务，避免一个类担负过多的职责。
    
2. **开闭原则（Open-Closed Principle - OCP）：** 软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。可以通过接口和抽象类实现。
    
3. **里氏替换原则（Liskov Substitution Principle - LSP）：** 派生类应该能够替换其基类而不影响程序的正确性。即，子类应该能够替代父类并保持程序的行为一致性。
    
4. **依赖倒置原则（Dependency Inversion Principle - DIP）：** 高层模块不应该依赖于底层模块，二者都应该依赖于抽象。抽象不应该依赖于细节，而细节应该依赖于抽象。
    
5. **接口隔离原则（Interface Segregation Principle - ISP）：** 客户端不应该强制依赖于它们不使用的接口。一个类不应该被强制实现它用不到的接口。
    
6. **迪米特法则（Law of Demeter，LoD，又称最少知识原则）：** 一个对象应该对其他对象有最少的了解。避免在一个类中调用过多其他类的方法，减少耦合性。
    
7. **合成复用原则（Composition/Aggregation Reuse Principle - CARP）：** 首选使用组合/聚合而不是继承来实现复用。通过组合可以更灵活地实现对象间的关系。
    
8. **优先使用对象组合，而不是类继承（Favor Composition Over Inheritance）：** 对象组合通常比类继承更加灵活，能够减少耦合性并支持代码重用。
    

这些原则通常被认为是良好面向对象设计的基石，它们相互交织，协同工作，帮助设计出符合软件工程最佳实践的系统结构。在实践中，根据具体情况灵活运用这些原则，有助于构建更健壮和可维护的软件系统。

## UML

![](https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041803749.png)

UML（Unified Modeling Language）类图是一种用于描述系统中的类、对象及它们之间关系的图形化建模工具。它是一种强大的面向对象的建模语言，被广泛用于软件开发和系统设计。以下是类图的主要元素和介绍：

1. **类（Class）：** 类是对现实世界中一组相似对象的抽象，它定义了对象的属性和行为。在类图中，类通常用一个矩形框表示，矩形框分为三个部分：类名、属性（字段）和方法。
    
2. **关联（Association）：** 关联表示类之间的关系，描述一个类的实例和另一个类的实例之间的连接。关联可以是单向的或双向的，可以具有方向性，也可以是多重性的，表示一个类中的实例与另一个类中的实例之间的关系。
    
3. **聚合（Aggregation）：** 表示一种弱的拥有关系，整体对象可以包含部分对象，但部分对象并不是整体对象的一部分。聚合用一条带有空心菱形的直线表示。
    
4. **组合（Composition）：** 表示一种强的拥有关系，整体对象包含部分对象，部分对象是整体对象的一部分。组合用一条带有实心菱形的直线表示。
    
5. **泛化（Generalization）：** 表示类之间的继承关系，其中一个类是另一个类的子类。泛化用一条带有空心三角箭头的直线表示。
    
6. **接口（Interface）：** 表示一个类或一组类的契约，它规定了这些类应该实现的一组方法。接口用带有<<interface>>标记的小矩形表示。
    
7. **依赖（Dependency）：** 表示一个类使用了另一个类的服务，但是并不拥有对方的对象。依赖关系用一条带有箭头的虚线表示。
    
8. **多重性（Multiplicity）：** 表示关联、聚合或组合关系中每个端点的实例数目。例如，1..* 表示一个或多个实例。
    

UML类图是软件开发中非常有用的工具，它能够清晰地展示系统中的类、对象和它们之间的关系，帮助开发人员理解系统结构、设计和实现。通过类图，开发团队能够更好地沟通和协作，确保系统的正确性和可维护性。

## 先说结论

**创建型模式**

1. **工厂方法模式（Factory Method Pattern）** ：定义一个创建对象的接口，但是让子类决定实例化哪个类。工厂方法使得一个类的实例化延迟到其子类。
    
2. **抽象工厂模式（Abstract Factory Pattern）** ：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。
    
3. **单例模式（Singleton Pattern）** ：确保一个类只有一个实例，并提供一个全局访问点。
    
4. **建造者模式（Builder Pattern）** ：将一个复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示。
    
5. **原型模式（Prototype Pattern）** ：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
    

**结构型模式**

1. **适配器模式（Adapter Pattern）** ：将一个类的接口转换成客户希望的另一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的类可以一起工作。
    
2. **桥接模式（Bridge Pattern）** ：将抽象部分与它的实现部分分离，使它们可以独立变化。
    
3. **组合模式（Composite Pattern）** ：将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。
    
4. **装饰器模式（Decorator Pattern）** ：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。
    
5. **外观模式（Facade Pattern）** ：为子系统中的一组接口提供一个统一的接口。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。
    
6. **享元模式（Flyweight Pattern）** ：运用共享技术有效地支持大量细粒度的对象。
    
7. **代理模式（Proxy Pattern）** ：为其他对象提供一种代理以控制对这个对象的访问。
    

**行为型模式**

1. **责任链模式（Chain of Responsibility Pattern）** ：为请求创建一个接收者对象的链，使得多个对象都有机会处理该请求。在请求发送者和接收者之间解耦。
    
2. **命令模式（Command Pattern）** ：将一个请求封装成一个对象，从而使用户可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。
    
3. **解释器模式（Interpreter Pattern）** ：给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。
    
4. **迭代器模式（Iterator Pattern）** ：提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。
    
5. **中介者模式（Mediator Pattern）** ：用一个中介对象封装一系列对象的交互，中介者使各对象不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。
    
6. **备忘录模式（Memento Pattern）** ：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。
    
7. **观察者模式（Observer Pattern）** ：定义对象间的一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并自动更新。
    
8. **状态模式（State Pattern）** ：允许对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。
    
9. **策略模式（Strategy Pattern）** ：定义一系列的算法，把它们封装起来，并且使它们可以相互替换。策略模式使得算法可以独立于使用它的客户而变化。
    
10. **模板方法模式（Template Method Pattern）** ：定义一个操作中的算法的框架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
    
11. **访问者模式（Visitor Pattern）** ：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。