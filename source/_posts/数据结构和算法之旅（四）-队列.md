---
title: 数据结构和算法之旅（四）- 队列
excerpt: 队列按照先进先出（FIFO）原则管理元素，支持在队尾添加元素（入队）和从队头移除元素（出队），适用于任务调度、缓冲和广度优先搜索等场景。
abbrlink: 18ca4eee
date: 2018-09-29 22:09:18
tags:
  - 队列
  - 双端队列
  - 优先级队列
  - 阻塞队列
categories:
  - data&algorithm
keywords: 队列;双端队列;优先级队列;阻塞队列;
index_img: /img/data_math/index.png
---
## 定义

<p class="note note-primary">计算机科学中，queue是以顺序的方式维护一组数据集合，在一端添加数据，从另一个端移除数据。习惯来说，添加的一端称为尾，移除的一端称为头，就如同生活中排队购买商品。</p>

## 链表实现队列

<p class="note note-secondary">下面以单向环形含哨兵链表方式来实现队列。</p>

![](https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309202026177.png)

```java
//首先定义队列的接口
package org.example.datastructure;

/**
 * 队列
 */
public interface Queue<E> {
    /**
     * 向队列尾部添加一个元素
     * @param val 待插入值
     * @return 插入成功返回true，否则返回false
     */
    boolean offer(E val);

    /**
     * 从队列头部取出一个元素，并移除
     * @return 如果队列非空，返回队列头部元素，否则返回null
     */
    E poll();

    /**
     * 从队列头部取出一个元素，但不移除
     * @return 如果队列非空，返回队列头部元素，否则返回null
     */
    E peek();

    /**
     * 判断队列是否为空
     * @return 空返回true，否则返回false
     */
    boolean isEmpty();


    /**
     * 判断队列是否已满
     * @return 已满返回true，否则返回false
     */
    boolean isFull();
}
```


```java
package org.example.datastructure;

import java.util.Iterator;

/**
 * 基于单向环形链表实现的队列
 * <p>
 * 队列只需要操作头，尾部不需要操作，所以只需要一个指针即可
 *
 * @param <E>
 */

public class LinkedListQueue<E> implements Queue<E>, Iterable<E> {

    /**
     * 节点类
     */
    private static class Node<E> {
        E value;
        Node<E> next;

        public Node(E value, Node<E> next) {
            this.value = value;
            this.next = next;
        }
    }

    Node<E> head = new Node<>(null, null);
    Node<E> tail = head;
    private int size;// 节点数
    private int capacity = Integer.MAX_VALUE;// 队列容量

    {
	    //构成环
        tail.next = head;
    }

    public LinkedListQueue(int capacity) {
        this.capacity = capacity;
    }

    public LinkedListQueue() {
    }

    @Override
    public boolean offer(E val) {
        if (isFull()) return false;
        Node<E> added = new Node<>(val, head);
        tail.next = added;
        tail = added;//让新节点作为新的tail
        size++;
        return true;
    }

    @Override
    public E poll() {
        if (isEmpty()) return null;
        Node<E> first = head.next;
        head.next = first.next;
        if (first == tail) tail = head;
        size--;
        return first.value;
    }

    @Override
    public E peek() {
        if (isEmpty()) return null;
        return head.next.value;
    }

    @Override
    public boolean isEmpty() {
        return head == tail;
    }

    @Override
    public boolean isFull() {
        return size == capacity;
    }

    @Override
    public Iterator<E> iterator() {
        return new Iterator<E>() {
            Node<E> p = head.next;

            @Override
            public boolean hasNext() {
                return p != head;
            }

            @Override
            public E next() {
                E value = p.value;
                p = p.next;
                return value;
            }
        };
    }
}
```

## 环形数组实现队列

![](https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309202148425.png)

![](https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309202148648.png)

<p class="note note-secondary">
判断头指针和尾指针是否指向同一个就是判空。<br>
当尾指针+1等于头指针就是判断满，(tail+1)%5 == head。
</p>

```java
package org.example.datastructure;

import java.util.Iterator;

public class ArrayQueue1<E> implements Queue<E>, Iterable<E> {

    private E[] array;
    private int head;
    private int tail;
    private int size;
    private int capacity;

    @SuppressWarnings("all")
    public ArrayQueue1(int capacity) {
        array = (E[]) new Object[this.capacity + 1];
    }

    @Override
    public boolean offer(E val) {
        if (isFull()) return false;
        array[tail] = val;
        tail = (tail + 1) % array.length;
        return true;
    }

    @Override
    public E poll() {
        if (isEmpty()) return null;
        E val = array[head];
        head = (head + 1) % array.length;
        return val;
    }

    @Override
    public E peek() {
        if (isEmpty()) return null;
        return array[head];
    }

    @Override
    public boolean isEmpty() {
        return head == tail;
    }

    @Override
    public boolean isFull() {
        return (tail + 1) % array.length == head;
    }

    @Override
    public Iterator<E> iterator() {
        return new Iterator<E>() {
            int p = head;

            @Override
            public boolean hasNext() {
                return p != tail;
            }

            @Override
            public E next() {
                E e = array[p];
                p = (p + 1) % array.length;
                return e;
            }
        };
    }
}
```

## 双端队列

<p class="note note-primary">
双端队列特点：俩端都可以添加、删除
</p>

### 基于双向环形链表实现

![[Pasted image 20230920222416.png]]

```java
package org.example.datastructure;

/**
 * 双端队列
 * 两端都可以操作添加和删除
 * queue 普通队列
 * deque 双端队列   double-ended queue
 */
public interface Deque<E> {


    /**
     * 向头部添加元素
     *
     * @param e 待添加元素
     * @return 添加成功返回true
     */
    boolean offerFirst(E e);

    /**
     * 向尾部添加元素
     *
     * @param e 待添加元素
     * @return 添加成功返回true
     */
    boolean offerLast(E e);

    /**
     * 从队列头部删除元素
     *
     * @return 头部元素
     */
    E pollFirst();


    /**
     * 从尾部获取元素并删除
     *
     * @return 尾部元素
     */
    E pollLast();


    /**
     * 从头部获取元素但不删除
     *
     * @return 头部元素
     */
    E peekFirst();


    /**
     * 从尾部获取元素但不删除
     *
     * @return 尾部元素
     */
    E peekLast();


    /**
     * 队列是否为空
     *
     * @return 空返回true, 否则返回false
     */
    boolean isEmpty();

    /**
     * 队列是否已满
     *
     * @return 满返回true, 否则返回false
     */
    boolean isFull();
}
```


```java
package org.example.datastructure;

import java.util.Iterator;

/**
 * 基于双向环形链表实现的双端队列
 * <p>
 * 注：双向和双端是两个概念，
 * 双向是指链表节点有两个指针，一个指向前一个节点，一个指向后一个节点；
 * 双端是指队列两端都可以操作添加和删除。
 * <p>
 * 为什么要用双向链表？
 * 因为双端队列需要操作尾端，所以需要尾指针，而单向链表只有头指针，所以需要双向链表。
 * <p>
 * 为什么要用环形链表？
 * 因为环形链表可以用一个哨兵，即充当头指针又充当尾指针，这样就可以省去一个指针。
 */
public class LinkedListDeque<E> implements Deque<E>, Iterable<E> {

    static class Node<E> {
        Node<E> prev;
        E value;
        Node<E> next;

        public Node(Node<E> prev, E value, Node<E> next) {
            this.prev = prev;
            this.value = value;
            this.next = next;
        }
    }

    int capacity = Integer.MAX_VALUE;
    int size;
    Node<E> sentinel = new Node<>(null, null, null);//哨兵

    public LinkedListDeque(int capacity) {
        this.capacity = capacity;
        //初始化哨兵
        sentinel.prev = sentinel;
        sentinel.next = sentinel;
    }

    /**
     * a added b
     * 向头部添加
     * a就是哨兵，b就是哨兵的next
     */
    @Override
    public boolean offerFirst(E e) {
        if (isFull()) return false;
        Node<E> a = sentinel;
        Node<E> b = sentinel.next;
        Node<E> added = new Node<>(a, e, b);
        a.next = added;
        b.prev = added;
        size++;
        return true;
    }

    /**
     * a added b
     * 向尾部添加
     * b就是哨兵，a就是哨兵的prev
     */
    @Override
    public boolean offerLast(E e) {
        if (isFull()) return false;
        Node<E> a = sentinel.prev;
        Node<E> b = sentinel;
        Node<E> added = new Node<>(a, e, b);
        a.next = added;
        b.prev = added;
        size++;
        return true;
    }

    /**
     * a removed b
     * 移除头部
     * a就是哨兵，b就是哨兵的next
     */
    @Override
    public E pollFirst() {
        if (isEmpty()) return null;
        Node<E> a = sentinel;
        Node<E> removed = sentinel.next;
        Node<E> b = removed.next;
        a.next = b;
        b.prev = a;
        size--;
        return removed.value;
    }

    /**
     * a removed b
     * 移除尾部
     * b就是哨兵，a就是哨兵的prev
     */
    @Override
    public E pollLast() {
        if (isEmpty()) return null;
        Node<E> b = sentinel;
        Node<E> removed = sentinel.prev;
        Node<E> a = removed.prev;
        a.next = b;
        b.prev = a;
        size--;
        return removed.value;
    }

    @Override
    public E peekFirst() {
        if (isEmpty()) return null;
        return sentinel.next.value;
    }

    @Override
    public E peekLast() {
        if (isEmpty()) return null;
        return sentinel.prev.value;
    }

    @Override
    public boolean isEmpty() {
        return size == 0;
    }

    @Override
    public boolean isFull() {
        return size == capacity;
    }

    @Override
    public Iterator<E> iterator() {
        return new Iterator<E>() {
            Node<E> p = sentinel.next;

            @Override
            public boolean hasNext() {
                return p != sentinel;
            }

            @Override
            public E next() {
                E value = p.value;
                p = p.next;
                return value;
            }
        };
    }

}

```

### 基于数组实现

![[Pasted image 20230920222652.png]]

```java
package org.example.datastructure;

import java.util.Iterator;

/**
 * 基于循环数组实现的双端队列
 * 循环数组动的是头尾指针，不动的是数组元素
 * <p>
 * tail 停下来的位置不存储，会浪费一个位置
 * <p>
 * <p>
 * h - head
 * tail - tail
 * <p>
 * h
 * t
 * 0  1  2  3
 * a  b     c
 * offerLast(a)     先添加元素 tail++
 * offerLast(b)
 * offerFirst(c)    先head-- 再添加元素
 * <p>
 * pollFirst()      先取元素 head++
 * pollLast()       先tail-- 再取元素
 * <p>
 * head==tail 空
 * head~tail == 数组长度-1 满
 */
public class ArrayDeque1<E> implements Deque<E>, Iterable<E> {

    E[] array;
    int head;
    int tail;

    @SuppressWarnings("all")
    public ArrayDeque1(int capacity) {
        array = (E[]) new Object[capacity + 1];
    }

    static int inc(int i, int length) {
        if (i + 1 >= length)
            return 0;
        return i + 1;
    }

    static int dec(int i, int length) {
        if (i - 1 < 0)
            return length - 1;
        return i - 1;
    }

    @Override
    public boolean offerFirst(E e) {
        if (isFull()) return false;
        head = dec(head, array.length);
        array[head] = e;
        return true;
    }

    @Override
    public boolean offerLast(E e) {
        if (isFull()) return false;
        array[tail] = e;
        tail = inc(tail, array.length);
        return true;
    }

    @Override
    public E pollFirst() {
        if (isEmpty()) return null;
        E e = array[head];
        array[head] = null;//help gc
        head = inc(head, array.length);
        return e;
    }

    @Override
    public E pollLast() {
        if (isEmpty()) return null;
        tail = dec(tail, array.length);
        E e = array[tail];
        array[tail] = null;//help gc
        return e;
    }

    @Override
    public E peekFirst() {
        if (isEmpty())
            return null;
        return array[head];
    }

    @Override
    public E peekLast() {
        if (isEmpty())
            return null;
        return array[dec(tail, array.length)];
    }

    @Override
    public boolean isEmpty() {
        return head == tail;
    }

    @Override
    public boolean isFull() {
        if (tail > head) {
            return tail - head == array.length - 1;
        } else if (tail < head) {
            return head - tail == 1;
        } else {
            return false;
        }
    }

    @Override
    public Iterator<E> iterator() {
        return new Iterator<E>() {
            int p = head;

            @Override
            public boolean hasNext() {
                return p != tail;
            }

            @Override
            public E next() {
                E e = array[p];
                p = inc(p, array.length);
                return e;
            }
        };
    }
}
```


## 优先级队列

<p class="note note-primary">
优先级队列特点：一端进，另一端出，但出的时候按照优先级出！
</p>

### 基于无序数组实现

<p class="note note-success">
无序数组实现的优势：<br>
入队就直接加入对尾。<br>
出队就遍历找到最大值，并删除，然后把后续的往前顺延。
</p>



### 基于有序数组实现


## 阻塞队列