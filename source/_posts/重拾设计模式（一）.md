---
title: 重拾设计模式（一）
tags:
  - 创建者模式
categories:
  - 设计模式
keywords: 创建者模式;
index_img: /img/design_pattern/designpattern.png
excerpt: 大话设计模式读书笔记(上)
abbrlink: b138f59e
date: 2019-02-23 21:05:42
---

## 简单工厂模式

> 请用C++、Java、C#或VB.NET任意一种面向对象语言实现一个计算器控制台程序，要求输入两个数和运算符号，得到结果。

可以直接写，如下所示：
![](https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041828241.png)

“且先不说出题人的意思，单就你现在的代码，就有很多不足的地方需要改进。”
- A、B、C、D命名不规范；
- 判断分支全用if，意味着每个条件都要判断；
- 除数为0会产生错误；
- 等等；

最重要一点是，**没有体现出面向对象**的意思。

**考虑通过封装、继承、多态把程序的耦合度降低；
考虑用设计模式使得程序更加的灵活，容易修改，并且易于复用；**

试着以面向对象的形式改写例子：

![](https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402042113078.png)
![](https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402042113911.png)

首先是一个运算类，它有两个Number属性，主要用于计算器的前后数，然后有一个虚方法GetResult()，用于得到结果，然后我把加减乘除都写成了运算类的子类，继承它后，重写了GetResult()方法，这样如果要修改任何一个算法，就不需要提供其他算法的代码了。但问题来了，**我如何让计算器知道我是希望用哪一个算法呢**？

现在的问题其实就是如何去实例化对象的问题，教你一招‘简单工厂模式’，也就是说，到底要实例化谁，将来会不会增加实例化的对象，比如增加开根运算，这是很容易变化的地方，应该考虑用一个单独的类来做这个创造实例的过程，这就是工厂，来，我们看看这个类如何写。

![](https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402042117297.png)

只需要输入特定的符号，工厂就实例化出合适的对象，通过多态，返回父类的方式实现计算器的结果：

![](https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402042118942.png)

Q：如果有一天我们需要更改加法运算，我们只需要改哪里；

A：改OperationAdd就可以了。

Q：那么我们需要增加各种复杂运算，比如平方根，立方根，自然对数，正弦余弦等，如何做？

A：只要增加相应的运算子类，并且还需要去修改运算类工厂，在switch中增加分支。

![](https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402042121776.png)


## 工厂方法模式

再来看看工厂方法模式，与简单工厂模式还是有些差异。

![](https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402042125151.png)

![](https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402042126986.png)

![](https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402042126723.png)

![](https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402042126384.png)

**简单工厂VS工厂方法**

>如果我现在需要增加其他运算，比如求M数的N次方，或者求M数的N次方根，这些功能的增加，在简单工厂里，我是先去加‘求M数的N次方’功能类，然后去更改工厂方法，当中加‘Case’语句来做判断，现在用了工厂方法，加功能类没问题，再加相关的工厂类，这也没问题，但要我再去更改客户端，这不等于不但没有减化难度，反而增加了很多类和方法，把复杂性增加了吗？为什么要这样？

这其实就是工厂方法模式和简单工厂的区别所在。**简单工厂模式的最大优点在于工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，对于客户端来说，去除了与具体产品的依赖。**

但问题也就在这里，如你所说，如果要加一个‘求M数的N次方’的功能，我们是一定需要给运算工厂类的方法里加‘Case’的分支条件的，修改原有的类？这可不是好办法，这就等于说，我们不但对扩展开放了，对修改也开放了，**违背了开闭原则**。

而**工厂方法模式实现时，客户端需要决定实例化哪一个工厂来实现运算类，选择判断的问题还是存在的，也就是说，工厂方法把简单工厂的内部逻辑判断移到了客户端代码来进行。你想要加功
能，本来是改工厂类的，而现在是修改客户端**！

**工厂方法克服了简单工厂违背开放-封闭原则的缺点，又保持了封装对象创建过程的优点。**

## 策略模式





## 抽象工厂模式

## 单例模式
## 建造者模式
## 原型模式


## 适配器模式
## 装饰器模式
## 代理模式
## 桥接模式
## 组合模式
## 外观模式
## 享元模式

## 观察者模式

## 命令模式
## 模板方法模式
## 状态模式
## 责任链模式
## 解释器模式
## 中介者模式
## 访问者模式
## 备忘录模式