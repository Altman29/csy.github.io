---
title: 数据结构和算法之旅（十二）- 其他
excerpt: 算法图解图书笔记。
abbrlink: 98b3bf1e
date: 2019-01-25 15:23:29
tags:
  - 排序算法
categories:
  - data&algorithm
keywords: 排序算法
index_img: /img/data_math/index.png
---
> 最近看到一本很有趣的书，《算法图解》。对一些算法描述的非常清晰、直观、有趣。这里简单记录一些读书笔记。

## 选择排序

假设你的计算机存储了很多乐曲。对于每个乐队，你都记录了其作品被播放的次数。

![](https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041629883.png)

你要将这个列表按播放次数从多到少的顺序排列，从而将你喜欢的乐队排序。该如何做呢？一种办法是遍历这个列表，找出作品播放次数最多的乐队，并将该乐队添加到一个新列表中。

![](https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041630942.png)
继续这样做，找出播放次数第二多的乐队。

![](https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041631736.png)


继续这样做，将得到一个有序的列表。

![](https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041631559.png)

接下来，分析一下它时间复杂度。要找出播放次数最多的乐队，必须检查列表中的每个元素。正如你刚才看到的，这需要的时间为O(n)。因此对于这种时间为O(n)的操作，你需要执行n次。

![](https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041634338.png)
需要的总时间为O(n×n)，即O(n²)。

排序算法很有用。你现在可以对如下内容进行排序：
- 电话薄中的人名
- 旅行日期
- 电子邮件，从新到旧
- 等等

示例代码

将数组元素按从小到大的顺序排列。先编写一个用于找出数组中最小元素的函数。

![](https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041639433.png)

现在可以使用这个函数来编写选择排序算法了。

![](https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041640898.png)

选择排序是一种灵巧的算法，但是速度不是很快。快速排序是一种更快的排序算法，其运行时间为O(n log n)。

## 分而治之D&C

> 一种著名的递归式问题解决方法。
> 
> 分而治之的原理：
> 1.找出简单的基线条件；
> 2.确定如何缩小问题的规模，使其符合基线条件；
> D&C并非用于解决问题的算法，而是一种解决问题的思路。

一个简单的例子，给定一个数组，

![](https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041646083.png)
需要将这些数字相加，并返回结果。使用循环很容易完成这种任务。

```python
defsum(arr): 
	total=0 
	forx in arr: 
		total+= x 
		return total 
print sum([1,2,3,4])
```


但如何使用递归函数来完成这种任务呢？

**第一步**：找出基线条件。最简单的数组什么样呢？请想想这个问题，再接着往下读。如果数组不包含任何元素或只包含一个元素，计算总和将非常容易。

![](https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041649064.png)
因此，这就是基线条件。

**第二步**：每次递归调用都必须离空数组更近一步。如何缩小问题的规模呢？下面是一种办法。

![](https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041650285.png)

这两个版本的结果都为12，但在第二个版本中，给函数sum传递的数组更短。换言之，这缩小了问题的规模！

函数sum的工作原理类似于下面这样。

![](https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041651529.png)

这个函数的运行过程如下。

![](https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041651359.png)

## 快速排序

> 快速排序是一种常用的排序算法，比选择排序快得多。例如，C语言标准库中的函数qsort实现的就是快速排序。快速排序也使用了D&C。

下面来使用快速排序对数组进行排序。对排序算法来说，最简单的数组什么样呢？还记得前一节的“提示”吗？就是根本不需要排序的数组。

![](https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041657372.png)

```python
def quicksort(array): 
	if len(array)<2: 
		return array
```

因此，基线条件为数组为空或只包含**一**个元素。在这种情况下，只需原样返回数组——根本就不用排序。

我们来看看更长的数组。对包含**两**个元素的数组进行排序也很容易。

![](https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041659123.png)
包含三个元素的数组呢？

![](https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041700889.png)

别忘了，你要使用D&C，因此需要将数组分解，直到满足基线条件。下面介绍**快速排序的工作原理**。首先，从数组中**选择一个元素**，这个元素被称为**基准值**(pivot)。稍后再介绍如何选择合适的基准值。我们暂时将数组的第一个元素用作基准值。接下来，找出比基准值小的元素以及比基准值大的元素。

![](https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041701782.png)
![](https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041701748.png)

这被称为分区(partitioning)。现在你有：
- 一个由所有小于基准值的数字组成的子数组；
- 基准值；
- 一个由所有大于基准值的数组组成的子数组。

这里只是进行了分区，得到的两个子数组是无序的。但如果这两个数组是有序的，对整个数组进行排序将非常容易。

![](https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041702668.png)

如果子数组是有序的，就可以像下面这样合并得到一个有序的数组：左边的数组+基准值+右边的数组。在这里，就是[10,15]+[33]+[]，结果为有序数组[10,15,33]。

如何对子数组进行排序呢？对于包含两个元素的数组（左边的子数组）以及空数组（右边的子数组），快速排序知道如何将它们排序，因此只要对这两个子数组进行快速排序，再合并结果，就能得到一个有序数组！

![](https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041704511.png)

![](https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041705539.png)

快速排序的性能高度依赖于你选择的基准值。假设你总是将第一个元素用作基准值，且要处理的数组是有序的。由于快速排序算法不检查输入数组是否有序，因此它依然尝试对其进行排序。最糟糕的情况运行时间是O(n²)。

