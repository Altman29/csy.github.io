---
title: JS-作用域和闭包
tags:
  - javascript
categories:
  - javascript
keywords: javascript
excerpt: 系统复习一下js。拜读一下《你不知道的JavaScript》，做一下读书笔记。
abbrlink: b92db53e
date: 2024-05-28 21:43:17
index_img: /img/2024/js.png
---
> “JavaScript的确有很多我不了解的地方。我每天从早到晚都在使用JavaScript，并且已经持续了好几年，但我真的了解它了吗？”
> 是的，一直以来能用js实现前端需求，妄称全栈了很久，但一直没有深入细致的了解过，这次通过阅读《你不知道的JavaScript》这个堪称前端必读的佳作来巩固一下前端知识吧。

---

# 作用域


>变量住在哪里？换句话说，它们储存在哪里？最重要的是，程序需要时如何找到它们？


## 编译原理

>通常将JavaScript归类为“动态”或“解释执行”语言，但事实上它是一门编译语言。
>但与传统的编译语言不同，它不是提前编译的，编译结果也不能在分布式系统中进行移植。

在传统**编译语言**的流程中，程序中的一段源代码在执行之前会经历**三个步骤**，统称为“编译”。

- 分词/词法分析（Tokenizing/Lexing）

<p class="note note-secondary">
这个过程会将由字符组成的字符串分解成（对编程语言来说）有意义的代码块，这些代码块被称为词法单元（token）。<br><br>
例如，考虑程序var a = 2;。这段程序通常会被分解成为下面这些词法单元：var、a、=、2 、;。空格是否会被当作词法单元，取决于空格在这门语言中是否具有意义。
</p>


- 解析/语法分析（Parsing）

<p class="note note-secondary">
这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树”（Abstract Syntax Tree,AST）。
<br><br>
var a = 2；的抽象语法树中可能会有一个叫作VariableDeclaration的顶级节点，接下来是一个叫作Identifier（它的值是a）的子节点，以及一个叫作AssignmentExpression的子节点。AssignmentExpression节点有一个叫作NumericLiteral（它的值是2）的子节点。
</p>

- 代码生成

<p class="note note-secondary">
将AST转换为可执行代码的过程被称为代码生成。这个过程与语言、目标平台等息息相关。抛开具体细节，简单来说就是有某种方法可以将var a = 2；的AST转化为一组机器指令，用来创建一个叫作a的变量（包括分配内存等），并将一个值储存在a中。
</p>

比起那些编译过程只有三个步骤的语言的编译器，JavaScript引擎要复杂得多。

<p class="note note-info">
首先，JavaScript引擎不会有大量的（像其他语言编译器那么多的）时间用来进行优化，因为与其他语言不同，JavaScript的编译过程不是发生在构建之前的。
<br><br>
对于JavaScript来说，大部分情况下编译发生在代码执行前的几微秒（甚至更短！）的时间内。在我们所要讨论的作用域背后，JavaScript引擎用尽了各种办法（比如JIT，可以延迟编译甚至实施重编译）来保证性能最佳。
<br><br>
简单地说，任何JavaScript代码片段在执行前都要进行编译（通常就在执行前）。因此，JavaScript编译器首先会对var a = 2；这段程序进行编译，然后做好执行它的准备，并且通常马上就会执行它。
</p>

## 理解作用域

>学习作用域的方式是将这个过程模拟成几个人物之间的对话。

对程序var a = 2；进行处理的过程中的演员们有以下这些：

- 引擎
	- 从头到尾负责整个JavaScript程序的编译及执行过程
- 编译器
	- 引擎的好朋友之一，负责语法分析及代码生成等脏活累活（详见前一节的内容）。
- 作用域
	- 引擎的另一位好朋友，负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。

> 为了能够完全理解JavaScript的工作原理，你需要开始像引擎（和它的朋友们）一样思考，从它们的角度提出问题，并从它们的角度回答这些问题。

### 对话

当看到`var a = 2`的时候，看一下引擎和它的朋友们是如何协同工作的。

编译器首先会将这段程序分解成**词法单元**，然后将词法单元解析成一个**树结构**（AST抽象语法树）。但是当编译器开始进行代码生成时，它对这段程序的处理方式会和预期的有所不同。

可以合理的假设编译器所产生的代码能够用下面的**伪代码进行概括**："为一个变量分配内存，将其命名为a，然后将值2保存进这个变量。" 然而，这并不完全正确。

事实上，编译器会进行如下处理：

1.遇到`var a`，编辑器会询问作用域是否已经有一个该名称的变量存在于同一个作用域集合中。如果是，编译器会忽略该声明，继续进行编译；否则，它将会要求作用域在当前作用的集合中声明一个新的变量，并命名为a。

2.接下来编译器会为引擎生成运行时的所需代码，这些代码用来处理`a = 2`这个赋值操作。引擎会首先询问作用域，在当前的作用域集合中是否存在一个叫做a的变量。如果是，引擎就会使用这个变量；如果否，引擎会继续查找该变量。如果引擎最终找到了a变量，就会将2赋值给它。否则引擎就会举手示意抛出一个异常。

<p class="note note-info">
总结：变量的赋值操作会执行俩个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能找到就对它赋值。
</p>

#### 编译器有话说

为了进一步理解，需要多介绍一点编译器的术语。

编译器在编译过程中的第二步生成了代码，引擎执行它时，会通过查找变量a来判断是否已声明过。查找的过程由作用域进行协助，但是引擎执行怎样的查找，会影响最终的查找结果。

在例子中，引擎会为变量a进行LHS查询。另外一个查找的类型叫做RHS。

L和R分别代表左侧和右侧。什么东西的左侧和右侧？是一个赋值操作的左侧和右侧。

换句话说，当变量出现在赋值操作的左侧时进行LHS查询，当出现在右侧时进行RHS查询。

再精准一点，**RHS查询与简单的查找某个变量的值别无二致，而LHS查询则是试图找到变量的容器本身，从而可以对其赋值。** 从这个角度说，RHS并不是真正意义上的"赋值操作的右侧"，更准确的说是"非左侧"。

比如一下代码：

```js
console.log(a);
```

其中对a的引用是一个RHS引用，因为这里a并没有赋予任何值。相应的，需要查找并取得a的值，这样才能将值传递给console.log()。

相比之下，

```js
a = 2;
```

这里对a的引用则是LHS引用，因为实际上并不关心当前的值是什么，只是想要为=2这个赋值操作找到一个目标。

#### 引擎和作用域的对话

```js
function foo(a){ // 1
	console.log(a); //2
}
foo(2);// 3
```

把上述代码想象成一段对话，这段对话可能是下面这样的：

- 引擎：作用域，我需要为foo进行RHS引用(3， 最后一行foo(..)函数的调用需要对foo进行RHS引用，意味着"去找到foo的值，并把它给我")，你见过它么？
- 作用域：我还真见过，编译器那小子刚刚声明了它。它是一个函数，给你。
- 引擎：够意思，那我来执行一下foo。
- 引擎：作用域，还有个事。我需要a进行LHS引用，你见过它么？
- 作用域：这个也见过，编译器最近把它声明为foo的一个形式参数了，拿去。
- 引擎：感谢感谢。现在我要把2赋值给a。
- 引擎：哥们，不好意思又来打扰。我要为console进行RHS引用，你见过它么。
- 作用域：这个我也有，console是个内置对象，给你。
- 引擎：我的看看这里面是不是有log(...)。太好了，找到了，是一个函数。
- 引擎：能帮我再找一下对a的RHS引用么？虽然我记得它，但想再确认一次。
- 作用域：放心吧，这个变量没有变动过，拿去，不谢。
- 引擎：真棒，我把a的值，也就是2，传递进log(...)。
- ......

#### 小测验

检验一下目前的理解程度，把自己当作引擎，并同作用域进行一次"对话"。

```js
function foo(a){
	var b = a;
	return a + b;
}
var c = foo(2);
```

1.找到其中所有的LHS查询。（一共3处！）

```
c = ..;;

a = 2(隐式变量分配)

b = ..
```

2.找到其中所有的RHS查询。（一共4处！）

```js
foo(2)

= a

a..

..b

```

## 作用域嵌套

> 作用域是根据名称查找变量的一套规则。实际情况中，通常需要同时顾及几个作用域。当一个块或函数嵌套在另一个块或函数中时，就发生了作用域嵌套。
> 因此在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，找到找到该变量，或抵达最外层的作用域（也就是全局作用域）为止。

考虑一下代码：

```js
function foo(a){
	console.log(a + b);
}
var b = 2;
foo(a); // 4
```

对b进行的RHS引用无法在函数foo内部完成，但可以在上一级作用域（在这个例子中就是全局作用域）中完成。

因此，回顾一下引擎和作用域之间的对话，会进一步听到：

- 引擎：foo的作用域兄弟，你见过b么？我需要对它进行RHS引用。
- 作用域：听都没听过，走开。
- 引擎：foo的上级作用域兄弟，咦？有眼不识泰山，原来是全局作用域大佬，你好，你见过b么，我需要对它进行RHS引用。
- 作用域：当前，拿去吧。

<p class="note note-info">
遍历嵌套作用域链的规则很简单：引擎从当前的执行作用域开始查找变量，如果找不到，就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都会停止。
</p>

## 异常

> 为什么区分LHS和RHS是一件重要的事？
> 
> 因为在变量还没有声明（在任何作用域中都无法找到该变量）的情况下，这俩种查询的行为是不一样的。


考虑如下代码：

```js
function foo(a){
	console.log(a + b);
	b = a;
}
foo(2);
```

第一次对b进行RHS查询时是无法找到该变量的。也就是说，这是一个"未声明"的变量，因为在任何一个相关的作用域中都无法找到它。

如果RHS查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出ReferenceError异常。它是一个非常重要的异常类型。

相较之下，当引擎执行LHS查询时，如果在顶层（全局作用域）中也无法找到目标变量，全局作用域就会创建一个具有该名称的变量，并将其返还给引擎，前提是程序运行在非"严格模式"下，ES5中引入了“严格模式”。

接下来，如果RHS查询找到了一个变量，但是你尝试对这个变量的值进行不合理的操作，比如试图对一个非函数类型的值进行函数调用，或者引用null或undefined类型的值中的属性，那么引擎会抛出另外一种类型的异常，叫作TypeError。

ReferenceError同作用域判别失败相关，而TypeError则代表作用域判别成功了，但是对结果的操作是非法或不合理的。

## 小结

作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。如果查找的目的是对变量进行赋值，那么就会使用LHS查询；如果目的是获取变量的值，就会使用RHS查询。

LHS和RHS查询都会在当前执行作用域中开始，如果有需要（也就是说它们没有找到所需的标识符），就会向上级作用域继续查找目标标识符，这样每次上升一级作用域（一层楼），最后抵达全局作用域（顶层），无论找到或没找到都将停止。

不成功的RHS引用会导致抛出ReferenceError异常。不成功的LHS引用会导致自动隐式地创建一个全局变量（非严格模式下），该变量使用LHS引用的目标作为标识符，或者抛出ReferenceError异常（严格模式下）。


---

# 词法作用域

>在第1章中，我们将“作用域”定义为一套规则，这套规则用来管理引擎如何在当前作用域以及嵌套的子作用域中根据标识符名称进行变量查找。
>
>作用域共有两种主要的工作模型。第一种是最为普遍的，被大多数编程语言所采用的词法作用域，我们会对这种作用域进行深入讨论。另外一种叫作动态作用域，仍有一些编程语言在使用。


## 词法阶段

大部分标准语言编译器的第一个工作阶段叫作词法化（也叫单词化）。回忆一下，词法化的过程会对源代码中的字符进行检查，如果是有状态的解析过程，还会赋予单词语义。

’这个概念是理解词法作用域及其名称来历的基础。

简单地说，词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变（大部分情况下是这样的）。

```js
function foo(a){
	var b = a * 2;
	function bar(c){
		console.log(a, b, c);
	}
	bar(b * 3);
}
foo(2); // 2, 4 ,12
```

在这个例子中有三个逐级嵌套的作用域。
![](https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202405271324825.png)
1. 包含着整个全局作用域，其中只有一个标识符：foo。
2. 包含着foo所创建的作用域，其中有三个标识符: a、bar和b。
3. 包含着bar所创建的作用域，其中只有一个标识符: c。

作用域气泡的结构和互相之间的位置关系给引擎提供了足够的位置信息，引擎用这些信息来查找标识符的位置。

在上一个代码片段中，引擎执行console.log(..)声明，并查找a、b和c三个变量的引用。它首先从最内部的作用域，也就是bar(..)函数的作用域气泡开始查找。引擎无法在这里找到a，因此会去上一级到所嵌套的foo(..)的作用域中继续查找。在这里找到了a，因此引擎使用了这个引用。对b来讲也是一样的。而对c来说，引擎在bar(..)中就找到了它。

作用域查找会在找到第一个匹配的标识符时停止。在多层的嵌套作用域中可以定义同名的标识符，这叫作“**遮蔽效应**”（内部的标识符“遮蔽”了外部的标识符）。抛开遮蔽效应，作用域查找始终从运行时所处的最内部作用域开始，逐级向外或者说向上进行，直到遇见第一个匹配的标识符为止。

>全局变量会自动成为全局对象（比如浏览器中的window对象）的属性，因此可以不直接通过全局对象的词法名称，而是间接地通过对全局对象属性的引用来对其进行访问。` window.a`
>
>通过这种技术可以访问那些被同名变量**所遮蔽的全局变量**。但非全局的变量如果被遮蔽了，无论如何都无法被访问到。

## 欺骗词法

如果词法作用域完全由写代码期间函数所声明的位置来定义，怎样才能在运行时来“修改”（也可以说欺骗）词法作用域呢？

JavaScript中有两种机制来实现这个目的。社区普遍认为在代码中使用这两种机制并不是什么好注意。但是关于它们的争论通常会忽略掉最重要的点：**欺骗词法作用域会导致性能下降**。

### eval

>JavaScript中的eval(..)函数可以接受一个字符串为参数，并将其中的内容视为好像在书写时就存在于程序中这个位置的代码。
>换句话说，可以在你写的代码中用程序生成代码并运行，就好像代码是写在那个位置的一样。

考虑一下代码：

```js
function foo(str, a){
	eval(str) //欺骗
	console.log(a, b)
}
var b = 2
foo("var b = 3", 1) // 1, 3
```

<p class="note note-info">
eval(..)调用中的"var b = 3; "这段代码会被当作本来就在那里一样来处理。由于那段代码声明了一个新的变量b，因此它对已经存在的foo(..)的词法作用域进行了修改。事实上，和前面提到的原理一样，这段代码实际上在foo(..)内部创建了一个变量b，并遮蔽了外部（全局）作用域中的同名变量。
</p>

>当console.log(..)被执行时，会在foo(..)的内部同时找到a和b，但是永远也无法找到外部的b。因此会输出“1, 3”而不是正常情况下会输出的“1, 2”。

>在严格模式的程序中，eval(..)在运行时有其自己的词法作用域，意味着其中的声明无法修改所在的作用域。

![](https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202405272220656.png)

### with

>with通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。

比如：

![](https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202405272221119.png)


>eval(..)函数如果接受了含有一个或多个声明的代码，就会修改其所处的词法作用域，而with声明实际上是根据你传递给它的对象凭空创建了一个全新的词法作用域。



### 性能

JavaScript引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。

但如果引擎在代码中发现了eval(..)或with，它只能简单地假设关于标识符位置的判断都是无效的，因为无法在词法分析阶段明确知道eval(..)会接收到什么代码，这些代码会如何对作用域进行修改，也无法知道传递给with用来创建新词法作用域的对象的内容到底是什么。

最悲观的情况是如果出现了eval(..)或with，所有的优化可能都是无意义的，因此最简单的做法就是完全不做任何优化。

## 小结

词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。编译的词法分析阶段基本能够知道全部标识符在哪里以及是如何声明的，从而能够预测在执行过程中如何对它们进行查找。

JavaScript中有两个机制可以“欺骗”词法作用域：eval(..)和with。这两个机制的副作用是引擎无法在编译时对作用域查找进行优化，因为引擎只能谨慎地认为这样的优化是无效的。使用这其中任何一个机制都将导致代码运行变慢。**不要使用它们**。


---

# 函数作用域和块作用域

正如直接说的，作用域包含了一系列的“气泡”，每一个都可以作为容器，其中包含了标识符（变量、函数）的定义。这些气泡互相嵌套并且整齐地排列成蜂窝型，排列的结构是在写代码时定义的。

<p class="note note-info">
作用域包含了一系列的“气泡”，每一个都可以作为容器，其中包含了标识符（变量、函数）的定义。这些气泡互相嵌套并且整齐地排列成蜂窝型，排列的结构是在写代码时定义的。
</p>

## 函数中的作用域

对于前面提出的问题，最常见的答案是JavaScript具有基于函数的作用域，意味着每声明一个函数都会为其自身创建一个气泡，而其他结构都不会创建作用域气泡。*但事实上这并不完全正确*。

考虑以下代码：

```js
function foo(a) { 
	var b = 2; 
	// 一些代码 
	function bar() { 
	// ... 
	}
	//更多代码
	var c = 3
}
```

在这个代码片段中，foo(..)的作用域气泡中包含了标识符a、b、c和bar。无论标识符声明出现在作用域中的何处，这个标识符所代表的变量或函数**都将附属于所处作用域的气泡**。

bar(..)拥有自己的作用域气泡。全局作用域也有自己的作用域气泡，它只包含了一个标识符：foo。

由于标识符a、b、c和bar都附属于foo(..)的作用域气泡，因此无法从foo(..)的外部对它们进行访问。也就是说，这些标识符全都无法从全局作用域中进行访问，因此下面的代码会导致ReferenceError错误:

```js
bar() //失败

console.log(a, b, c) // 三个全部失败
```

但是，这些标识符（a、b、c、foo和bar）在foo(..)的内部都是可以被访问的，同样在bar(..)内部也可以被访问（假设bar(..)内部没有同名的标识符声明）。

<p class="note note-info">
函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用（事实上在嵌套的作用域中也可以使用）。这种设计方案是非常有用的，能充分利用JavaScript变量可以根据需要改变值类型的“动态”特性。<br><br>
但与此同时，如果不细心处理那些可以在整个作用域范围内被访问的变量，可能会带来意想不到的问题。
</p>

## 隐藏内部实现

>对函数的传统认知就是先声明一个函数，然后再向里面添加代码。但反过来想也可以带来一些启示：从所写的代码中挑选出一个任意的片段，然后用函数声明对它进行包装，实际上就是把这些代码“**隐藏**”起来了。

有很多原因促成了这种基于作用域的隐藏方法。它们大都是从最小特权原则中引申出来的，也叫最小授权或最小暴露原则。这个原则是指在软件设计中，应该最小限度地暴露必要内容，而将其他内容都“隐藏”起来，比如某个模块或对象的API设计。

### 规避冲突

>“隐藏”作用域中的变量和函数所带来的另一个好处，是可以避免同名标识符之间的冲突，两个标识符可能具有相同的名字但用途却不一样，无意间可能造成命名冲突。冲突会导致变量的值被意外覆盖。

例如：

```js
function foo(){
	function bar(a){
		i = 3 // 修改for循环所属作用域中的i
		console.log(a + i)
	}
	for(var i = 0;i < 10; i++){
		bar(i * 2)// ！ 这里无限循环了
	}
}
foo()
```

bar(..)内部的赋值表达式i = 3意外地覆盖了声明在foo(..)内部for循环中的i。在这个例子中将会导致无限循环，因为i被固定设置为3，永远满足小于10这个条件。

bar(..)内部的赋值操作需要声明一个本地变量来使用，采用任何名字都可以，var i = 3;就可以满足这个需求（同时会为i声明一个前面提到过的“遮蔽变量”）。另外一种方法是采用一个完全不同的标识符名称，比如var j = 3;。

软件设计在某种情况下可能自然而然地要求使用同样的标识符名称，因此在这种情况下使用作用域来“隐藏”内部声明是唯一的最佳选择。

### 全局命名空间

变量冲突的一个典型例子存在于全局作用域中。当程序中加载了多个第三方库时，如果它们没有妥善地将内部私有的函数或变量隐藏起来，就会很容易引发冲突。

这些库通常会在全局作用域中声明一个名字足够独特的变量，通常是一个对象。这个对象被用作库的命名空间，所有需要暴露给外界的功能都会成为这个对象（命名空间）的属性，而不是将自己的标识符暴露在顶级的词法作用域中。

### 模块管理

另外一种避免冲突的办法和现代的模块机制很接近，就是从众多模块管理器中挑选一个来使用。使用这些工具，任何库都无需将标识符加入到全局作用域中，而是通过依赖管理器的机制将库的标识符显式地导入到另外一个特定的作用域中。

这些工具并没有能够违反词法作用域规则的“神奇”功能。它们只是利用作用域的规则强制所有标识符都不能注入到共享作用域中，而是保持在私有、无冲突的作用域中，这样可以有效规避掉所有的意外冲突。

## 函数作用域

已经知道在任意代码片段外部添加包装函数，可以将内部的变量和函数定义“隐藏”起来，外部作用域无法访问包装函数内部的任何内容。

例如：

```js
var a = 2
function foo(){ // 添加这一行
	var a = 3
	console.log(a) // 3
}
foo() //以及这一行
console.log(a) // 2
```

<p class="note note-info">
虽然这种技术可以解决一些问题，但是它并不理想，因为会导致一些额外的问题。首先，必须声明一个具名函数foo()，意味着foo这个名称本身“污染”了所在作用域（在这个例子中是全局作用域）。其次，必须显式地通过函数名（foo()）调用这个函数才能运行其中的代码。<br><br>
如果函数不需要函数名（或者至少函数名可以不污染所在作用域），并且能够自动运行，这将会更加理想。<br><br>
幸好，JavaScript提供了能够同时解决这两个问题的方案
</p>

```js
var a = 2
(function foo(){ // 添加这一行
	var a = 3
	console.log(a) // 3
})(); // 以及这一行
console.log(a) // 2
```

首先，包装函数的声明以(function..．而不仅是以function..．开始。尽管看上去这并不是一个很显眼的细节，但实际上却是非常重要的区别。**函数会被当作函数表达式**而不是一个标准的函数声明来处理。

>函数声明和函数表达式之间最重要的区别是它们的名称标识符将会绑定在何处。

比较一下前面两个代码片段。第一个片段中foo被绑定在所在作用域中，可以直接通过foo()来调用它。第二个片段中foo被绑定在函数表达式自身的函数中而不是所在作用域中。

>换句话说，(function foo(){ .. })作为函数表达式意味着foo只能在．．所代表的位置中被访问，外部作用域则不行。foo变量名被隐藏在自身中意味着不会非必要地污染外部作用域。

### 匿名和具名

对于函数表达式你最熟悉的场景可能就是回调参数了，比如：

```js
setTimeout(function(){
	console.log('waited 1 second!')
}, 1000)
```

>这叫作匿名函数表达式，因为function().．没有名称标识符。函数表达式可以是匿名的，而函数声明则不可以省略函数名。

匿名函数表达式书写起来简单快捷，很多库和工具也倾向鼓励使用这种风格的代码。但是它也有几个缺点需要考虑。

- 匿名函数表达式书写起来简单快捷，很多库和工具也倾向鼓励使用这种风格的代码。但是它也有几个缺点需要考虑。
- 如果没有函数名，当函数需要引用自身时只能使用已经过期的arguments.callee引用，比如在递归中。另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑自身。
- 匿名函数省略了对于代码可读性/可理解性很重要的函数名。

>行内函数表达式非常强大且有用——匿名和具名之间的区别并不会对这点有任何影响。给函数表达式指定一个函数名可以有效解决以上问题。**始终给函数表达式命名是一个最佳实践**：

```js
setTimeout(function timeoutHandler(){ // 增加函数名
	console.log('waited 1 second!')
}, 1000)
```

### 立即执行函数表达式

```js
var a = 2
(function foo(){ // 添加这一行
	var a = 3
	console.log(a) // 3
})(); // 以及这一行
console.log(a) // 2
```

<p class="note note-info">
由于函数被包含在一对()括号内部，因此成为了一个表达式，通过在末尾加上另外一个()可以立即执行这个函数，比如(function foo(){ .. })()。第一个()将函数变成表达式，第二个()执行了这个函数。
</p>

>这种模式很常见，社区给它规定了一个术语：IIFE，代表立即执行函数表达式（Immediately Invoked Function Expression）；

函数名对IIFE当然不是必须的，IIFE最常见的用法是使用一个匿名函数表达式。虽然使用具名函数的IIFE并不常见，但它具有上述匿名函数表达式的所有优势，因此也是一个值得推广的实践。

```js
var a = 2
(function IIFE(){ // 添加这一行
	var a = 3
	console.log(a) // 3
})(); // 以及这一行
console.log(a) // 2
```

相较于传统的IIFE形式，很多人都更喜欢另一个改进的形式：(function(){ .. }())。仔细观察其中的区别。第一种形式中函数表达式被包含在()中，然后在后面用另一个()括号来调用。第二种形式中用来调用的()括号被移进了用来包装的()括号中。

这两种形式在功能上是一致的。选择哪个全凭个人喜好。

## 块作用域

>尽管函数作用域是最常见的作用域单元，当然也是现行大多数JavaScript中最普遍的设计方法，但其他类型的作用域单元也是存在的，并且通过使用其他类型的作用域单元甚至可以实现维护起来更加优秀、简洁的代码。

下面这种很常见的JavaScript代码一定很熟悉：

```js
for(var i = 0;i < 10; i++){
	console.log(i)
}
```

<p class="note note-info">
在for循环的头部直接定义了变量i，通常是因为只想在for循环内部的上下文中使用i，而忽略了i会被绑定在外部作用域（函数或全局）中的事实。
</p>

>块作用域是一个用来对之前的最小授权原则进行扩展的工具，将代码从在函数中隐藏信息扩展为在块中隐藏信息。
>
>块作用域的用处。变量的声明应该距离使用的地方越近越好，并最大限度地本地化。

### with

with关键字。它不仅是一个难于理解的结构，同时也是块作用域的一个例子（块作用域的一种形式），用with从对象中创建出的作用域仅在with声明中而非外部作用域中有效。

### try/catch

少有人会注意到JavaScript的ES3规范中规定try/catch的catch分句会创建一个块作用域，其中声明的变量仅在catch内部有效。

### let

<p class="note note-info">
幸好，ES6改变了现状，引入了新的let关键字，提供了除var以外的另一种变量声明方式。
</p>

>let关键字可以将变量绑定到所在的任意作用域中（通常是{ .. }内部）。换句话说，let为其声明的变量隐式地劫持了所在的块作用域。

为块作用域显式地创建块，可以使变量的附属关系变得更加清晰。通常来讲，显式的代码优于隐式或一些精巧但不清晰的代码。

```js
var foo = true

if(foo){
	{ // 显式的块
		let bar = foo * 2
		bar = something(bar)
		console.log(bar)
	}
}

console.log(bar) // ReferenceError
```

>后续会讨论提升，提升是指声明会被视为存在于其所出现的作用域的整个范围内。
>
>但是使用let进行的声明不会在块作用域中进行提升。声明的代码被运行之前，声明并不“存在”。

```js
{
	console.log(bar) // ReferenceError!!
	let bar = 2
}
```

#### 垃圾收集

>另一个块作用域非常有用的原因和闭包及回收内存垃圾的回收机制相关。这里简要说明一下，而内部的实现原理，也就是闭包的机制会在后续探究。

考虑以下代码：

```js
function process(data){
	// do something
}

var someReallyBigData = {..}

process(someReallyBigData)

var btn = document.getElementById('myButton')

btn.addEventListener("click", function click(evt){
	console.log('button clicked')
}, false)
```

click函数的点击回调并不需要someReallyBigData变量。理论上这意味着当process(..)执行后，在内存中占用大量空间的数据结构就可以被垃圾回收了。但是，由于click函数形成了一个覆盖整个作用域的闭包，JavaScript引擎极有可能依然保存着这个结构（取决于具体实现）。

>块作用域可以打消这种顾虑，可以让引擎清楚地知道没有必要继续保存someReallyBigData了：

```js

function process(data){
	// do something
}

{ // 在这个块中定义的内容完事可以销毁！！
	let someReallyBigData = {..}
	process(someReallyBigData)
}

var btn = document.getElementById('myButton')

btn.addEventListener("click", function click(evt){
	console.log('button clicked')
}, false)
```
#### let循环

>一个let可以发挥优势的典型例子就是之前讨论的for循环。

```js
for(let i = 0;i < 10; i++){
	console.log(i)
}
console.log(i) // ReferenceError!!!
```

下面通过另一种方式来说明每次迭代时进行重新绑定的行为：

```js
{
	let j
	for(j = 0; j < 10; j++){
		let i = j
		console.log(i)
	}
}
```

>每个迭代进行重新绑定非常有趣，会在之后探究闭包的时候进行说明。

### const

<p class="note note-info">
除了let以外，ES6还引入了const，同样可以用来创建块作用域变量，但其值是固定的（常量）。之后任何试图修改值的操作都会引起错误。
</p>

```js
var foo = true

if(foo){
	var a = 2
	const b = 3 //包含在if中的块作用域常量
	a = 3 // 正常
	b = 4 // 错误！！
}

console.log(a) // 3
console.log(b) // ReferenceError!!
```

## 小结

函数是JavaScript中最常见的作用域单元。本质上，声明在一个函数内部的变量或函数会在所处的作用域中“隐藏”起来，这是有意为之的良好软件的设计原则。

但函数不是唯一的作用域单元。块作用域指的是变量和函数不仅可以属于所处的作用域，也可以属于某个代码块（通常指{ .. }内部）。

从ES3开始，try/catch结构在catch分句中具有块作用域。

在ES6中引入了let关键字（var关键字的表亲），用来在任意代码块中声明变量。if (..) { let a = 2; }会声明一个劫持了if的{ .. }块的变量，并且将变量添加到这个块中。

有些人认为块作用域不应该完全作为函数作用域的替代方案。两种功能应该同时存在，开发者可以并且也应该根据需要选择使用何种作用域，创造可读、可维护的优良代码。

---

# 提升

>已经很熟悉作用域的概念，以及根据声明的位置和方式将变量分配给作用域的相关原理了。函数作用域和块作用域的行为是一样的，
>
>可以总结为：任何声明在某个作用域内的变量，都将附属于这个作用域。
>
>但是作用域同其中的变量声明出现的位置有某种微妙的联系，而这个细节正是我们将要讨论的内容。

## 先有鸡还是先有蛋

直觉上会认为JavaScript代码在执行时是由上到下一行一行执行的。但实际上这并不完全正确，有一种特殊情况会导致这个假设是错误的。

考虑以下代码：

```js
a = 2

var a

console.log(a)

//你认为console.log(..)声明会输出什么呢？
```

很多开发者会认为是undefined，因为var a声明在a = 2之后，他们自然而然地认为变量被重新赋值了，因此会被赋予默认值undefined。但是，真正的**输出结果是2**。

考虑另外一段代码：

```js
console.log(a)

var a = 2
```

鉴于上一个代码片段所表现出来的某种非自上而下的行为特点，你可能会认为这个代码片段也会有同样的行为而输出2。还有人可能会认为，由于变量a在使用前没有先进行声明，因此会抛出ReferenceError异常。不幸的是两种猜测都是不对的。**输出来的会是undefined**。

>那么到底发生了什么？看起来我们面对的是一个先有鸡还是先有蛋的问题。到底是声明（蛋）在前，还是赋值（鸡）在前？


## 编译器again

为了搞明白这个问题，需要回顾一下关于编译器的内容。

>引擎会在解释JavaScript代码之前首先对其进行编译。编译阶段中的一部分工作就是找到所有的声明，并用合适的作用域将它们关联起来。第2章中展示了这个机制，也正是词法作用域的核心内容。

>因此，正确的思考思路是，包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理。

>当你看到var a = 2；时，可能会认为这是一个声明。但JavaScript实际上会将其看成两个声明：var a；和a = 2;。第一个定义声明是在编译阶段进行的。第二个赋值声明会被留在原地等待执行阶段。

第一个代码片段会以如下形式进行处理:

```js
var a 

a = 2

console.log(a)
```

**其中第一部分是编译，而第二部分是执行。**


类似地，第二个代码片段实际是按照以下流程处理的：

```js
var a

console.log(a)

a = 2
```

<p class="note note-info">
因此，打个比方，这个过程就好像变量和函数声明从它们在代码中出现的位置被“移动”到了最上面。这个过程就叫作提升。<br><br>
换句话说：先有蛋（声明）。后有鸡（赋值）。
</p>

>只有声明本身会被提升，而赋值或其他运行逻辑会留在原地。如果提升改变了代码执行的顺序，会造成非常严重的破坏。

```js
foo()

function foo(){
	console.log(a) // 因为下面的a被提升，但赋值会留在原地，所以这里是undefined
	var a = 2
}
```

另外值得注意的是，每个作用域都会进行提升操作。而我们正在讨论的foo(..)函数自身也会在内部对var a进行提升（显然并不是提升到了整个程序的最上方）。因此这段代码实际上会被理解为下面的形式：

```js
function foo(){
	var a  // 提升
	console.log(a) // undefined
	a = 2 //停留
}

foo()
```


可以看到，函数声明会被提升，**但是函数表达式却不会被提升**。

```js
foo() // 不是ReferenceError 而是TypeError！！！！

var foo = function bar(){
	//...
}
```

>这段程序中的变量标识符foo()被提升并分配给所在作用域（在这里是全局作用域），因此foo()不会导致ReferenceError。但是foo此时并没有赋值（如果它是一个函数声明而不是函数表达式，那么就会赋值）。foo()由于对undefined值进行函数调用而导致非法操作，因此抛出TypeError异常。

同时，即使是**具名的函数表达式，名称标识符在赋值之前也无法在所在作用域中使用**：

```js
foo() // TypeError
bar() // ReferenceError

var foo = function bar(){
	//...
}
```

这个代码片段经过提升后，实际上会被理解为以下形式：

```js
var foo

foo() // TypeError
bar() // ReferenceError

foo = function bar(){
	//...
}
```

## 函数优先

>函数声明和变量声明都会被提升。但是一个值得注意的细节是**函数会首先被提升，然后才是变量。**

考虑以下代码：

```js
foo() // 1!!!

var foo

function foo(){
	console.log(1)
}

foo = function(){
	console.log(2)
}
```

会输出1而不是2！！ 这个代码片段会被引擎理解为如下形式：

```js
function foo){
	console.log(1)
}

foo() // 1

foo = function(){
	console.log(2)
}
```

注意，var foo尽管出现在function foo()..．的声明之前，但它是重复的声明（因此被忽略了），因为函数声明会被提升到普通变量之前。

尽管重复的var声明会被忽略掉，但出现在后面的函数声明还是可以覆盖前面的。

```js
foo() // 3

function foo(){
	console.log(1)
}

var foo = function(){
	console.log(2)
}

function foo(){
	console.log(3)
}
```


## 小结

我们习惯将var a = 2；看作一个声明，而实际上JavaScript引擎并不这么认为。它将var a和a = 2当作**两个单独的声明，第一个是编译阶段的任务，而第二个则是执行阶段的任务**。

这意味着无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先进行处理。可以将这个过程形象地想象成所有的声明（变量和函数）都会被“移动”到各自作用域的最顶端，这个过程被称为**提升**。

声明本身会被提升，而包括**函数表达式**的赋值在内的赋值操作**并不会提升**。

要注意避免重复声明，特别是当普通的var声明和函数声明混合在一起的时候，否则会引起很多危险的问题！

---

# 作用域闭包

>这门语言中一个非常重要但又难以掌握，近乎神话的概念上：闭包。

## 启示


>对于那些有一点JavaScript使用经验但从未真正理解闭包概念的人来说，理解闭包可以看作是某种意义上的重生。
>
>JavaScript中闭包无处不在，你只需要能够识别并拥抱它。闭包并不是一个需要学习新的语法或模式才能使用的工具。
>
>闭包是基于词法作用域书写代码时所产生的自然结果，你甚至不需要为了利用它们而有意识地创建闭包。闭包的创建和使用在你的代码中随处可见。你缺少的是根据你自己的意愿来识别、拥抱和影响闭包的思维环境。

<p class="note note-info">
理解闭包就好像Neo第一次见到矩阵一样。
</p>


## 实质问题

下面是直接了当的定义：

<p class="note note-primary">
当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。
</p>

下面用一些代码来解释这个定义。

```js
function foo(){
	var a = 2

	function bar(){
		console.log(a) // 2
	}

	bar()
}

foo()
```

这段代码看起来和嵌套作用域中的示例代码很相似。基于词法作用域的查找规则，函数bar()可以访问外部作用域中的变量a（这个例子中的是一个RHS引用查询）。

>这是闭包吗？

技术上来讲，也许是。但根据前面的定义，确切地说并不是。我认为最准确地用来解释bar()对a的引用的方法是词法作用域的查找规则，而这些规则只是闭包的一部分。（但却是非常重要的一部分！）

从纯学术的角度说，在上面的代码片段中，函数bar()具有一个涵盖foo()作用域的闭包（事实上，涵盖了它能访问的所有作用域，比如全局作用域）。也可**以认为bar()封闭了foo()的作用域中**。为什么呢？原因简单明了，**因为bar()嵌套在foo()内部**。

但是通过这种方式定义的闭包并不能直接进行观察，也无法明白在这个代码片段中闭包是如何工作的。我们可以很容易地理解词法作用域，而闭包则隐藏在代码之后的神秘阴影里，并不那么容易理解。

下面我们来看一段代码，清晰地展示了闭包：

```js
function foo(){
	var a = 2

	function bar(){
		console.log(a)
	}

	return bar
}

var baz = foo()
baz() // 朋友~ 这就是闭包的效果！！！
```


<p class="note note-primary">
函数bar()的词法作用域能够访问foo()的内部作用域。然后我们将bar()函数本身当作一个值类型进行传递。在这个例子中，我们将bar所引用的函数对象本身当作返回值。
<br><br>
在foo()执行后，其返回值（也就是内部的bar()函数）赋值给变量baz并调用baz()，实际上只是通过不同的标识符引用调用了内部的函数bar()。
<br><br>
bar()显然可以被正常执行。但是在这个例子中，它在自己定义的词法作用域以外的地方执行。
<br><br>
在foo()执行后，通常会期待foo()的整个内部作用域都被销毁，因为我们知道引擎有垃圾回收器用来释放不再使用的内存空间。由于看上去foo()的内容不会再被使用，所以很自然地会考虑对其进行回收。
<br><br>
而闭包的“神奇”之处正是可以阻止这件事情的发生。事实上内部作用域依然存在，因此没有被回收。谁在使用这个内部作用域？原来是bar()本身在使用。
<br><br>
拜bar()所声明的位置所赐，它拥有涵盖foo()内部作用域的闭包，使得该作用域能够一直存活，以供bar()在之后任何时间进行引用。
<br><br>
bar()依然持有对该作用域的引用，而这个引用就叫作闭包。
</p>

>因此，在几微秒之后变量baz被实际调用（调用内部函数bar），不出意外它可以访问定义时的词法作用域，因此它也可以如预期般访问变量a。
>
>这个函数在定义时的词法作用域以外的地方被调用。闭包使得函数可以继续访问定义时的词法作用域。
>
>当然，无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都可以观察到闭包。

```js
function foo(){
	var a = 2

	function baz(){
		console.log(a) // 2
	}

	bar(baz)
}

function bar(fn){
	fn(); // 快看，这就是闭包！！！
}
```

把内部函数baz传递给bar，当调用这个内部函数时（现在叫作fn），它涵盖的foo()内部作用域的闭包就可以观察到了，因为它能够访问a。

**传递函数当然也可以是间接的。**

```js
var fn

function foo(){
	var a = 2

	function baz(){
		console.log(a)
	}

	fn = baz // 将baz分配给全局变量
}

function bar(){
	fn() // 快看 ， 这就是闭包！！！
}


foo()

bar() // 2
```


<p class="note note-info">
无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。
</p>

## 现在我悟了

前面的代码片段有点死板，并且为了解释如何使用闭包而人为地在结构上进行了修饰。但我保证闭包绝不仅仅是一个好玩的玩具。你已经写过的代码中一定到处都是闭包的身影。现在让我们来搞懂这个事实。

```js
function wait(message){
	setTimeout(function timer(){
		console.log(message)
	},1000)
}

wait("hello closure")
```

将一个内部函数（名为timer）传递给setTimeout(..)。timer具有涵盖wait(..)作用域的闭包，因此还保有对变量message的引用。

wait(..)执行1000毫秒后，它的内部作用域并不会消失，timer函数依然保有wait(..)作用域的闭包。

在引擎内部，内置的工具函数setTimeout(..)持有对一个参数的引用，这个参数也许叫作fn或者func，或者其他类似的名字。引擎会调用这个函数，在例子中就是内部的timer函数，而词法作用域在这个过程中保持完整。这就是闭包。

**只要使用了回调函数，实际上就是在使用闭包！**


IIFE模式。通常认为IIFE是典型的闭包例子，但根据先前对闭包的定义，我并不是很同意这个观点。

```js
var a = 2
(function IIFE(){
	console.log(a)
})()
```

虽然这段代码可以正常工作，但严格来讲它并不是闭包。为什么？因为函数（示例代码中的IIFE）**并不是在它本身的词法作用域以外执行的**。它在定义时所在的作用域中执行（而外部作用域，也就是全局作用域也持有a）。**a是通过普通的词法作用域查找而非闭包被发现的**。

## 循环和闭包


要说明闭包，for循环是最常见的例子。

```js
for(var i = 1; i <= 5; i++){
	setTimeout(function timer(){
		console.log(i)
	}, i * 1000)
}
```

正常情况下，我们对这段代码行为的预期是分别输出数字1～5，每秒一次，每次一个。

但实际上，这段代码在运行时会以每秒一次的频率输出五次6。

首先解释6是从哪里来的。这个循环的终止条件是i不再<=5。条件首次成立时i的值是6。因此，输出显示的是循环结束时i的最终值。

仔细想一下，这好像又是显而易见的，延迟函数的回调会在循环结束时才执行。事实上，当定时器运行时即使每个迭代中执行的是setTimeout(.., 0)，所有的回调函数依然是在循环结束后才会被执行，因此会每次输出一个6出来。

这里引伸出一个更深入的问题，代码中到底有什么缺陷导致它的行为同语义所暗示的不一致呢？

>缺陷是我们试图假设循环中的每个迭代在运行时都会给自己“捕获”一个i的副本。但是根据作用域的工作原理，实际情况是尽管循环中的五个函数是在各个迭代中分别定义的，但是它们都被封闭在一个共享的全局作用域中，因此实际上只有一个i。


下面回到正题。缺陷是什么？我们需要更多的闭包作用域，特别是在循环的过程中每个迭代都需要一个闭包作用域。第3章介绍过，IIFE会通过声明并立即执行一个函数来创建作用域。

```js
for(var i = 1; i <= 5; i++){
	(function (){
		setTimeout(function timer(){
			console.log(i)
		}, i * 1000)
	})();
}
```

这样能行吗？

这样不行。但是为什么呢？我们现在显然拥有更多的词法作用域了。的确每个延迟函数都会将IIFE在每次迭代中创建的作用域封闭起来。

如果作用域是空的，那么仅仅将它们进行封闭是不够的。仔细看一下，我们的IIFE只是一个什么都没有的空作用域。它需要包含一点实质内容才能为我们所用。

它需要有自己的变量，用来在每个迭代中储存i的值：

```js
for(var i = 1; i <= 5; i++){
	(function (){
		var j = i
		setTimeout(function timer(){
			console.log(j)
		}, j * 1000)
	})();
}
```

行了！可以正常工作量！！

可以对这段代码进行一些改进：

```js
for(var i = 1; i <= 5; i++){
	(function (j){
		setTimeout(function timer(){
			console.log(j)
		}, j * 1000)
	})(i);
}
```

<p class="note note-info">
在迭代内使用IIFE会为每个迭代都生成一个新的作用域，使得延迟函数的回调可以将新的作用域封闭在每个迭代内部，每个迭代中都会含有一个具有正确值的变量供我们访问。
</p>

### 重返块作用域

思考我们对前面的解决方案的分析。我们使用IIFE在每次迭代时都创建一个新的作用域。换句话说，每次迭代我们都需要一个块作用域。第3章介绍了let声明，可以用来劫持块作用域，并且在这个块作用域中声明一个变量。

本质上这是将一个块转换成一个可以被关闭的作用域。可以这么实现：

```js
for(var i = 1; i <= 5; i++){
	let j = i // 是的，闭包的块作用域！！！
	setTimeout(function timer(){
		console.log(j)
	}, j * 1000)
}
```

但是，这还不是全部！

for循环头部的let声明还会有一个特殊的行为。这个行为指出变量在循环过程中不止被声明一次，每次迭代都会声明。随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。

```js
for(let i = 1; i <= 5; i++){
	setTimeout(function timer(){
		console.log(i)
	}, i * 1000)
}
```

>很酷是吧？块作用域和闭包联手便可天下无敌。


## 模块

>还有其他的代码模式利用闭包的强大威力，但从表面上看，它们似乎与回调无关。下面一起来研究其中最强大的一个：模块。

```js
function foo(){
	var something = 'cool'
	var another = [1, 2, 3]

	function doSomething(){
		console.log(something)
	}

	function doAnother(){
		console.log(another.join('! '))
	}
}
```

正如在这段代码中所看到的，这里并没有明显的闭包，只有两个私有数据变量something和another，以及doSomething()和doAnother()两个内部函数，**它们的词法作用域（而这就是闭包）也就是foo()的内部作用域**。

接下来考虑以下代码：

```js
function CoolModule(){
	var something = 'cool'
	var another = [1, 2, 3]

	function doSomething(){
		console.log(something)
	}

	function doAnother(){
		console.log(another.join('! '))
	}

	return {
		doSomething: doSomething,
		doAnother: doAnother
	}
}

var foo = CoolModule()

foo.doSomething() // cool
foo.doAnother() // 1! 2! 3!
```

>这个模式在JavaScript中被称为模块。最常见的实现模块模式的方法通常被称为模块暴露，这里展示的是其变体。

<p class="note note-info">
首先，CoolModule()只是一个函数，必须要通过调用它来创建一个模块实例。如果不执行外部函数，内部作用域和闭包都无法被创建。
<br><br>
其次，CoolModule()返回一个用对象字面量语法{ key: value, ... }来表示的对象。这个返回的对象中含有对内部函数而不是内部数据变量的引用。我们保持内部数据变量是隐藏且私有的状态。可以将这个对象类型的返回值看作本质上是模块的公共API。
<br><br>
这个对象类型的返回值最终被赋值给外部的变量foo，然后就可以通过它来访问API中的属性方法，比如foo.doSomething()。
</p>

>doSomething()和doAnother()函数具有涵盖模块实例内部作用域的闭包（通过调用CoolModule()实现）。当通过返回一个含有属性引用的对象的方式来将函数传递到词法作用域外部时，我们已经创造了可以观察和实践闭包的条件。

**如果要更简单的描述，模块模式需要具备两个必要条件。**

1．必须有外部的封闭函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块实例）。
2．封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。

一个具有函数属性的对象本身并不是真正的模块。从方便观察的角度看，一个从函数调用所返回的，只有数据属性而没有闭包函数的对象并不是真正的模块。

上一个示例代码中有一个叫作CoolModule()的独立的模块创建器，可以被调用任意多次，每次调用都会创建一个新的模块实例。当只需要一个实例时，可以对这个模式进行简单的改进来**实现单例模式**：

```js
var foo = (function CoolModule() { 
	var something = "cool"; 
	var another = [1, 2, 3]; 
	
	function doSomething() { 
		console.log(something); 
	} 
	
	function doAnother() { 
		console.log(another.join(" ! ")); 
	} 
	return { 
		doSomething: doSomething, 
		doAnother: doAnother }; 
	})(); 
	
	foo.doSomething(); // cool 
	foo.doAnother(); // 1 ! 2 ! 3
```


**模块也是普通的函数，因此可以接受参数：**

```js
function CoolModule(id) { 
	function identify() { 
		console.log(id); 
	} 
	
	return { 
		identify: identify 
	}; 
} 

var foo1 = CoolModule("foo 1"); 
var foo2 = CoolModule("foo 2");

foo1.identify() // foo 1
foo2.identify() // foo 2
```

**模块模式另一个简单但强大的用法是命名将要作为公共API返回的对象**：

```js
var foo = (function CoolModule(id){
	function change(){
		//修改公共API
		publicAPI.identify = identify2
	}

	function identify1(){
		console.log(id)
	}

	function identify2(){
		console.log(id.toUpperCase())
	}

	var publicAPI = {
		change: change,
		identify: identify1
	}

	return publicAPI
})('foo module')

foo.identify() // foo module
foo.change()
foo.identify // FOO MODULE
```

>通过在模块实例的内部保留对公共API对象的内部引用，可以从内部对模块实例进行修改，包括添加或删除方法和属性，以及修改它们的值。

### 模块机制使用

ES6中为模块增加了一级语法支持。在通过模块系统进行加载时，ES6会将文件当作独立的模块来处理。每个模块都可以导入其他模块或特定的API成员，同样也可以导出自己的API成员。

考虑以下代码：

**bar.js**

```js
function hello(who){
	return "Let me introduce: "+ who
}

export hello;
```


**foo.js**

```js
//仅从bar模块导入hello()
import hello from "bar"

var hungry = "hippo"

function awesome(){
	console.log(
		hello(hungry).toUpperCase()
	)
}

export awesome
```


**baz.js**

```js
//导入完整的foo和bar模块
module foo from "foo"
module bar from "bar"

console.log(
	bar.hello("rhino") //Let me introduce: rhino
)

foo.awesome() // LET ME INTRODUC：HIPPO
```

import可以将一个模块中的一个或多个API导入到当前作用域中，并分别绑定在一个变量上（在我们的例子里是hello）。module会将整个模块的API导入并绑定到一个变量上（在我们的例子里是foo和bar）。

export会将当前模块的一个标识符（变量、函数）导出为公共API。这些操作可以在模块定义中根据需要使用任意多次。

模块文件中的内容会被当作好像包含在作用域闭包中一样来处理，就和前面介绍的函数闭包模块一样。

## 小结


闭包就好像从JavaScript中分离出来的一个充满神秘色彩的未开化世界，只有最勇敢的人才能够到达那里。但实际上它只是一个普通且明显的事实，那就是我们在词法作用域的环境下写代码，而其中的函数也是值，可以随意传来传去。


<p class="note note-info">
当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包。
</p>


如果没能认出闭包，也不了解它的工作原理，在使用它的过程中就很容易犯错，比如在循环中。但同时闭包也是一个非常强大的工具，可以用多种形式来实现模块等模式。

模块有两个主要特征：**（1）** 为创建内部作用域而调用了一个包装函数；**（2）** 包装函数的返回值必须至少包括一个对内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭包。

现在我们会发现代码中到处都有闭包存在，并且我们能够识别闭包然后用它来做一些有用的事！