

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="拾叁">
  <meta name="keywords" content="Java多线程">
  
    <meta name="description" content="并发编程技术，允许程序同时执行多个线程，以提高性能和资源利用率，但也引入了线程安全、竞态条件和复杂的调试挑战，需要谨慎处理共享资源、同步和互斥问题，需要注意线程之间的协调与管理，以避免潜在的问题。">
<meta property="og:type" content="article">
<meta property="og:title" content="关于并发编程（上）">
<meta property="og:url" content="https://blog.13space.cn/posts/6aabc494/index.html">
<meta property="og:site_name" content="拾叁的小破站">
<meta property="og:description" content="并发编程技术，允许程序同时执行多个线程，以提高性能和资源利用率，但也引入了线程安全、竞态条件和复杂的调试挑战，需要谨慎处理共享资源、同步和互斥问题，需要注意线程之间的协调与管理，以避免潜在的问题。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://blog.13space.cn/img/thread/duo.jpg">
<meta property="article:published_time" content="2019-05-02T02:16:24.000Z">
<meta property="article:modified_time" content="2024-03-04T08:40:04.721Z">
<meta property="article:author" content="拾叁">
<meta property="article:tag" content="并发">
<meta property="article:tag" content="并行">
<meta property="article:tag" content="同步">
<meta property="article:tag" content="异步">
<meta property="article:tag" content="互斥">
<meta property="article:tag" content="线程安全">
<meta property="article:tag" content="悲观锁">
<meta property="article:tag" content="乐观锁">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://blog.13space.cn/img/thread/duo.jpg">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>关于并发编程（上） - 拾叁的小破站</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"blog.13space.cn","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":100,"cursorChar":"*","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  

  

  



  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>拾叁 | space</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>时间轴</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/remark/">
                <i class="iconfont icon-speakernotes"></i>
                <span>留言板</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                <span>Links</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/home_bg.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="关于并发编程（上）"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        拾叁
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2019-05-02 10:16" pubdate>
          May 2, 2019 am
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          38k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          316 mins
        
      </span>
    

    
    
  </div>


<script src="/js/custom-iconfont.js?v=" ></script>

        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">关于并发编程（上）</h1>
            
            
              <div class="markdown-body">
                
                <p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402211423293.png" srcset="/img/loading.gif" lazyload></p>
<hr>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>进程：程序是静止的，进程实体的运行过程就是进程，是系统进行<strong>资源分配的基本单位</strong></p>
<p>进程的特征：并发性、异步性、动态性、独立性、结构性</p>
<p><strong>线程</strong>：线程是属于进程的，是一个基本的 CPU 执行单元，是程序执行流的最小单元。线程是进程中的一个实体，是系统<strong>独立调度的基本单位</strong>，线程本身不拥有系统资源，只拥有一点在运行中必不可少的资源，与同属一个进程的其他线程共享进程所拥有的全部资源</p>
<p>关系：一个进程可以包含多个线程，这就是多线程，比如看视频是进程，图画、声音、广告等就是多个线程</p>
<p>线程的作用：使多道程序更好的并发执行，提高资源利用率和系统吞吐量，增强操作系统的并发性能</p>
<p>并发并行：</p>
<ul>
<li><p>并行：在同一时刻，有多个指令在多个 CPU 上同时执行</p>
</li>
<li><p>并发：在同一时刻，有多个指令在单个 CPU 上交替执行</p>
</li>
</ul>
<p>同步异步：</p>
<ul>
<li><p>需要等待结果返回，才能继续运行就是同步</p>
</li>
<li><p>不需要等待结果返回，就能继续运行就是异步</p>
</li>
</ul>
<hr>
<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>线程进程对比：</p>
<ul>
<li><p>进程基本上相互独立的，而线程存在于进程内，是进程的一个子集</p>
</li>
<li><p>进程拥有共享的资源，如内存空间等，供其<strong>内部的线程共享</strong></p>
</li>
<li><p>进程间通信较为复杂</p>
<p>  同一台计算机的进程通信称为 IPC（Inter-process communication）</p>
<ul>
<li><p>信号量：信号量是一个计数器，用于多进程对共享数据的访问，解决同步相关的问题并避免竞争条件</p>
</li>
<li><p>共享存储：多个进程可以访问同一块内存空间，需要使用信号量用来同步对共享存储的访问</p>
</li>
<li><p>管道通信：管道是用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件 pipe 文件，该文件同一时间只允许一个进程访问，所以只支持<strong>半双工通信</strong></p>
<ul>
<li><p>匿名管道（Pipes）：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信</p>
</li>
<li><p>命名管道（Names Pipes）：以磁盘文件的方式存在，可以实现本机任意两个进程通信，遵循 FIFO</p>
</li>
</ul>
</li>
<li><p>消息队列：内核中存储消息的链表，由消息队列标识符标识，能在不同进程之间提供<strong>全双工通信</strong>，对比管道：</p>
<ul>
<li><p>匿名管道存在于内存中的文件；命名管道存在于实际的磁盘介质或者文件系统；消息队列存放在内核中，只有在内核重启（操作系统重启）或者显示地删除一个消息队列时，该消息队列才被真正删除</p>
</li>
<li><p>读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收</p>
</li>
</ul>
</li>
</ul>
<p>  不同计算机之间的<strong>进程通信</strong>，需要通过网络，并遵守共同的协议，例如 HTTP</p>
<ul>
<li>套接字：与其它通信机制不同的是，可用于不同机器间的互相通信</li>
</ul>
</li>
<li><p>线程通信相对简单，因为线程之间共享进程内的内存，一个例子是多个线程可以访问同一个共享变量</p>
<p>  <strong>Java 中的通信机制</strong>：volatile、等待&#x2F;通知机制、join 方式、InheritableThreadLocal、MappedByteBuffer</p>
</li>
<li><p>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低</p>
</li>
</ul>
<hr>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><h4 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h4><p>Thread 创建线程方式：创建线程类，匿名内部类方式</p>
<ul>
<li><p><strong>start() 方法底层其实是给 CPU 注册当前线程，并且触发 run() 方法执行</strong></p>
</li>
<li><p>线程的启动必须调用 start() 方法，如果线程直接调用 run() 方法，相当于变成了普通类的执行，此时主线程将只有执行该线程</p>
</li>
<li><p>建议线程先创建子线程，主线程的任务放在之后，否则主线程（main）永远是先执行完</p>
</li>
</ul>
<p>Thread 构造器：</p>
<ul>
<li><p><code>public Thread()</code></p>
</li>
<li><p><code>public Thread(String name)</code></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadDemo</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();  <br>        t.start();  <br>       	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">100</span> ; i++ )&#123;  <br>            System.out.println(<span class="hljs-string">&quot;main线程&quot;</span> + i)  <br>        &#125;  <br>        <span class="hljs-comment">// main线程输出放在上面 就变成有先后顺序了，因为是 main 线程驱动的子线程运行  </span><br>    &#125;  <br>&#125;  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">100</span> ; i++ ) &#123;  <br>            System.out.println(<span class="hljs-string">&quot;子线程输出：&quot;</span>+i)  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>

<p>继承 Thread 类的优缺点：</p>
<ul>
<li><p>优点：编码简单</p>
</li>
<li><p>缺点：线程类已经继承了 Thread 类无法继承其他类了，功能不能通过继承拓展（单继承的局限性）</p>
</li>
</ul>
<hr>
<h4 id="Runnable"><a href="#Runnable" class="headerlink" title="Runnable"></a>Runnable</h4><p>Runnable 创建线程方式：创建线程类，匿名内部类方式</p>
<p>Thread 的构造器：</p>
<ul>
<li><p><code>public Thread(Runnable target)</code></p>
</li>
<li><p><code>public Thread(Runnable target, String name)</code></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadDemo</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>();  <br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(target,<span class="hljs-string">&quot;1号线程&quot;</span>);  <br>		t1.start();  <br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(target);<span class="hljs-comment">//Thread-0  </span><br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">10</span> ; i++ )&#123;  <br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;-&gt;&quot;</span> + i);  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>Thread 类本身也是实现了 Runnable 接口</strong>，Thread 类中持有 Runnable 的属性，执行线程 run 方法底层是调用 Runnable run：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;  <br>    <span class="hljs-keyword">private</span> Runnable target;  <br>      <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">if</span> (target != <span class="hljs-literal">null</span>) &#123;  <br>          	<span class="hljs-comment">// 底层调用的是 Runnable 的 run 方法  </span><br>            target.run();  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>

<p>Runnable 方式的优缺点：</p>
<ul>
<li><p>缺点：代码复杂一点。</p>
</li>
<li><p>优点：</p>
<ol>
<li><p>线程任务类只是实现了 Runnable 接口，可以继续继承其他类，避免了单继承的局限性</p>
</li>
<li><p>同一个线程任务对象可以被包装成多个线程对象</p>
</li>
<li><p>适合多个多个线程去共享同一个资源</p>
</li>
<li><p>实现解耦操作，线程任务代码可以被多个线程共享，线程任务代码和线程独立</p>
</li>
<li><p>线程池可以放入实现 Runnable 或 Callable 线程任务对象</p>
</li>
</ol>
</li>
</ul>
<hr>
<h4 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h4><p>实现 Callable 接口：</p>
<ol>
<li><p>定义一个线程任务类实现 Callable 接口，申明线程执行的结果类型</p>
</li>
<li><p>重写线程任务类的 call 方法，这个方法可以直接返回执行的结果</p>
</li>
<li><p>创建一个 Callable 的线程任务对象</p>
</li>
<li><p>把 Callable 的线程任务对象<strong>包装成一个未来任务对象</strong></p>
</li>
<li><p>把未来任务对象包装成线程对象</p>
</li>
<li><p>调用线程的 start() 方法启动线程</p>
</li>
</ol>
<p><code>public FutureTask(Callable&lt;V&gt; callable)</code>：未来任务对象，在线程执行完后得到线程的执行结果</p>
<ul>
<li><p>FutureTask 就是 Runnable 对象，因为 <strong>Thread 类只能执行 Runnable 实例的任务对象</strong>，所以把 Callable 包装成未来任务对象</p>
</li>
<li><p>线程池部分详解了 FutureTask 的源码</p>
</li>
</ul>
<p><code>public V get()</code>：同步等待 task 执行完毕的结果，如果在线程中获取另一个线程执行结果，会阻塞等待，用于线程同步</p>
<ul>
<li><p>get() 线程会阻塞等待任务执行完成</p>
</li>
<li><p>run() 执行完后会把结果设置到 FutureTask 的一个成员变量，get() 线程可以获取到该变量的值</p>
</li>
</ul>
<p>优缺点：</p>
<ul>
<li><p>优点：同 Runnable，并且能得到线程执行的结果</p>
</li>
<li><p>缺点：编码复杂</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadDemo</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">Callable</span> <span class="hljs-variable">call</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>();  <br>        FutureTask&lt;String&gt; task = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(call);  <br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task);  <br>        t.start();  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> task.get(); <span class="hljs-comment">// 获取call方法返回的结果（正常/异常结果）  </span><br>            System.out.println(s);  <br>        &#125;  <span class="hljs-keyword">catch</span> (Exception e) &#123;  <br>            e.printStackTrace();  <br>        &#125;  <br>    &#125;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;String&gt; &#123;  <br>    <span class="hljs-meta">@Override</span><span class="hljs-comment">//重写线程任务类方法  </span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;  <br>        <span class="hljs-keyword">return</span> Thread.currentThread().getName() + <span class="hljs-string">&quot;-&gt;&quot;</span> + <span class="hljs-string">&quot;Hello World&quot;</span>;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="线程方法"><a href="#线程方法" class="headerlink" title="线程方法"></a>线程方法</h3><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><p>Thread 类 API：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public void start()</td>
<td>启动一个新线程，Java虚拟机调用此线程的 run 方法</td>
</tr>
<tr>
<td>public void run()</td>
<td>线程启动后调用该方法</td>
</tr>
<tr>
<td>public void setName(String name)</td>
<td>给当前线程取名字</td>
</tr>
<tr>
<td>public void getName()</td>
<td>获取当前线程的名字 线程存在默认名称：子线程是 Thread-索引，主线程是 main</td>
</tr>
<tr>
<td>public static Thread currentThread()</td>
<td>获取当前线程对象，代码在哪个线程中执行</td>
</tr>
<tr>
<td>public static void sleep(long time)</td>
<td>让当前线程休眠多少毫秒再继续执行 <strong>Thread.sleep(0)</strong> : 让操作系统立刻重新进行一次 CPU 竞争</td>
</tr>
<tr>
<td>public static native void yield()</td>
<td>提示线程调度器让出当前线程对 CPU 的使用</td>
</tr>
<tr>
<td>public final int getPriority()</td>
<td>返回此线程的优先级</td>
</tr>
<tr>
<td>public final void setPriority(int priority)</td>
<td>更改此线程的优先级，常用 1 5 10</td>
</tr>
<tr>
<td>public void interrupt()</td>
<td>中断这个线程，异常处理机制</td>
</tr>
<tr>
<td>public static boolean interrupted()</td>
<td>判断当前线程是否被打断，清除打断标记</td>
</tr>
<tr>
<td>public boolean isInterrupted()</td>
<td>判断当前线程是否被打断，不清除打断标记</td>
</tr>
<tr>
<td>public final void join()</td>
<td>等待这个线程结束</td>
</tr>
<tr>
<td>public final void join(long millis)</td>
<td>等待这个线程死亡 millis 毫秒，0 意味着永远等待</td>
</tr>
<tr>
<td>public final native boolean isAlive()</td>
<td>线程是否存活（还没有运行完毕）</td>
</tr>
<tr>
<td>public final void setDaemon(boolean on)</td>
<td>将此线程标记为守护线程或用户线程</td>
</tr>
</tbody></table>
<hr>
<h4 id="run-start"><a href="#run-start" class="headerlink" title="run start"></a>run start</h4><p>run：称为线程体，包含了要执行的这个线程的内容，方法运行结束，此线程随即终止。直接调用 run 是在主线程中执行了 run，没有启动新的线程，需要顺序执行</p>
<p>start：使用 start 是启动新的线程，此线程处于就绪（可运行）状态，通过新的线程间接执行 run 中的代码</p>
<p>说明：<strong>线程控制资源类</strong></p>
<p>run() 方法中的异常不能抛出，只能 try&#x2F;catch</p>
<ul>
<li><p>因为父类中没有抛出任何异常，子类不能比父类抛出更多的异常</p>
</li>
<li><p><strong>异常不能跨线程传播回 main() 中</strong>，因此必须在本地进行处理</p>
</li>
</ul>
<hr>
<h4 id="sleep-yield"><a href="#sleep-yield" class="headerlink" title="sleep yield"></a>sleep yield</h4><p>sleep：</p>
<ul>
<li><p>调用 sleep 会让当前线程从 <code>Running</code> 进入 <code>Timed Waiting</code> 状态（阻塞）</p>
</li>
<li><p>sleep() 方法的过程中，<strong>线程不会释放对象锁</strong></p>
</li>
<li><p>其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException</p>
</li>
<li><p>睡眠结束后的线程未必会立刻得到执行，需要抢占 CPU</p>
</li>
<li><p>建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性</p>
</li>
</ul>
<p>yield：</p>
<ul>
<li><p>调用 yield 会让提示线程调度器让出当前线程对 CPU 的使用</p>
</li>
<li><p>具体的实现依赖于操作系统的任务调度器</p>
</li>
<li><p><strong>会放弃 CPU 资源，锁资源不会释放</strong></p>
</li>
</ul>
<hr>
<h4 id="join"><a href="#join" class="headerlink" title="join"></a>join</h4><p>public final void join()：等待这个线程结束</p>
<p>原理：调用者轮询检查线程 alive 状态，t1.join() 等价于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">join</span><span class="hljs-params">(<span class="hljs-type">long</span> millis)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>    <span class="hljs-comment">// 调用者线程进入 thread 的 waitSet 等待, 直到当前线程运行结束  </span><br>    <span class="hljs-keyword">while</span> (isAlive()) &#123;  <br>        wait(<span class="hljs-number">0</span>);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>join 方法是被 synchronized 修饰的，本质上是一个对象锁，其内部的 wait 方法调用也是释放锁的，但是<strong>释放的是当前的线程对象锁，而不是外面的锁</strong></p>
</li>
<li><p>当调用某个线程（t1）的 join 方法后，该线程（t1）抢占到 CPU 资源，就不再释放，直到线程执行完毕</p>
</li>
</ul>
<p>线程同步：</p>
<ul>
<li><p>join 实现线程同步，因为会阻塞等待另一个线程的结束，才能继续向下运行</p>
<ul>
<li><p>需要外部共享变量，不符合面向对象封装的思想</p>
</li>
<li><p>必须等待线程结束，不能配合线程池使用</p>
</li>
</ul>
</li>
<li><p>Future 实现（同步）：get() 方法阻塞等待执行结果</p>
<ul>
<li><p>main 线程接收结果</p>
</li>
<li><p>get 方法是让调用线程同步等待</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;  <br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>        test1();  <br>    &#125;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>            <span class="hljs-keyword">try</span> &#123;  <br>                Thread.sleep(<span class="hljs-number">1000</span>);  <br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>                e.printStackTrace();  <br>            &#125;  <br>            r = <span class="hljs-number">10</span>;  <br>        &#125;);  <br>        t1.start();  <br>        t1.join();<span class="hljs-comment">//不等待线程执行结束，输出的10  </span><br>        System.out.println(r);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h4><h5 id="打断线程"><a href="#打断线程" class="headerlink" title="打断线程"></a>打断线程</h5><p><code>public void interrupt()</code>：打断这个线程，异常处理机制</p>
<p><code>public static boolean interrupted()</code>：判断当前线程是否被打断，打断返回 true，<strong>清除打断标记</strong>，连续调用两次一定返回 false</p>
<p><code>public boolean isInterrupted()</code>：判断当前线程是否被打断，不清除打断标记</p>
<p>打断的线程会发生上下文切换，操作系统会保存线程信息，抢占到 CPU 后会从中断的地方接着运行（打断不是停止）</p>
<ul>
<li>sleep、wait、join 方法都会让线程进入阻塞状态，打断线程<strong>会清空打断状态</strong>（false）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            Thread.sleep(<span class="hljs-number">1000</span>);  <br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>            e.printStackTrace();  <br>        &#125;  <br>    &#125;, <span class="hljs-string">&quot;t1&quot;</span>);  <br>    t1.start();  <br>    Thread.sleep(<span class="hljs-number">500</span>);  <br>    t1.interrupt();  <br>    System.out.println(<span class="hljs-string">&quot; 打断状态: &#123;&#125;&quot;</span> + t1.isInterrupted());<span class="hljs-comment">// 打断状态: &#123;&#125;false  </span><br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>打断正常运行的线程：不会清空打断状态（true）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;  <br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;  <br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;  <br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();  <br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> current.isInterrupted();  <br>            <span class="hljs-keyword">if</span>(interrupted) &#123;  <br>                System.out.println(<span class="hljs-string">&quot; 打断状态: &#123;&#125;&quot;</span> + interrupted);<span class="hljs-comment">//打断状态: &#123;&#125;true  </span><br>                <span class="hljs-keyword">break</span>;  <br>            &#125;  <br>        &#125;  <br>    &#125;, <span class="hljs-string">&quot;t2&quot;</span>);  <br>    t2.start();  <br>    Thread.sleep(<span class="hljs-number">500</span>);  <br>    t2.interrupt();  <br>&#125;<br><br></code></pre></td></tr></table></figure>

<hr>
<h5 id="打断-park"><a href="#打断-park" class="headerlink" title="打断 park"></a>打断 park</h5><p>park 作用类似 sleep，打断 park 线程，不会清空打断状态（true）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;  <br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>        System.out.println(<span class="hljs-string">&quot;park...&quot;</span>);  <br>        LockSupport.park();  <br>        System.out.println(<span class="hljs-string">&quot;unpark...&quot;</span>);  <br>        System.out.println(<span class="hljs-string">&quot;打断状态：&quot;</span> + Thread.currentThread().isInterrupted());<span class="hljs-comment">//打断状态：true  </span><br>    &#125;, <span class="hljs-string">&quot;t1&quot;</span>);  <br>    t1.start();  <br>    Thread.sleep(<span class="hljs-number">2000</span>);  <br>    t1.interrupt();  <br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果打断标记已经是 true, 则 park 会失效</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">LockSupport.park();  <br>System.out.println(<span class="hljs-string">&quot;unpark...&quot;</span>);  <br>LockSupport.park();<span class="hljs-comment">//失效，不会阻塞  </span><br>System.out.println(<span class="hljs-string">&quot;unpark...&quot;</span>);<span class="hljs-comment">//和上一个unpark同时执行</span><br></code></pre></td></tr></table></figure>

<p>可以修改获取打断状态方法，使用 <code>Thread.interrupted()</code>，清除打断标记</p>
<p>LockSupport 类在 同步 → park-un 详解</p>
<hr>
<h5 id="终止模式"><a href="#终止模式" class="headerlink" title="终止模式"></a>终止模式</h5><p>终止模式之两阶段终止模式：Two Phase Termination</p>
<p>目标：在一个线程 T1 中如何优雅终止线程 T2？优雅指的是给 T2 一个后置处理器</p>
<p>错误思想：</p>
<ul>
<li><p>使用线程对象的 stop() 方法停止线程：stop 方法会真正杀死线程，如果这时线程锁住了共享资源，当它被杀死后就再也没有机会释放锁，其它线程将永远无法获取锁</p>
</li>
<li><p>使用 System.exit(int) 方法停止线程：目的仅是停止一个线程，但这种做法会让整个程序都停止</p>
</li>
</ul>
<p>两阶段终止模式图示：</p>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041617846.png" srcset="/img/loading.gif" lazyload></p>
<p>打断线程可能在任何时间，所以需要考虑在任何时刻被打断的处理方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>        <span class="hljs-type">TwoPhaseTermination</span> <span class="hljs-variable">tpt</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TwoPhaseTermination</span>();  <br>        tpt.start();  <br>        Thread.sleep(<span class="hljs-number">3500</span>);  <br>        tpt.stop();  <br>    &#125;  <br>&#125;  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TwoPhaseTermination</span> &#123;  <br>    <span class="hljs-keyword">private</span> Thread monitor;  <br>    <span class="hljs-comment">// 启动监控线程  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;  <br>        monitor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;  <br>            <span class="hljs-meta">@Override</span>  <br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;  <br>                    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> Thread.currentThread();  <br>                    <span class="hljs-keyword">if</span> (thread.isInterrupted()) &#123;  <br>                        System.out.println(<span class="hljs-string">&quot;后置处理&quot;</span>);  <br>                        <span class="hljs-keyword">break</span>;  <br>                    &#125;  <br>                    <span class="hljs-keyword">try</span> &#123;  <br>                        Thread.sleep(<span class="hljs-number">1000</span>);					<span class="hljs-comment">// 睡眠  </span><br>                        System.out.println(<span class="hljs-string">&quot;执行监控记录&quot;</span>);	<span class="hljs-comment">// 在此被打断不会异常  </span><br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;		<span class="hljs-comment">// 在睡眠期间被打断，进入异常处理的逻辑  </span><br>                        e.printStackTrace();  <br>                        <span class="hljs-comment">// 重新设置打断标记，打断 sleep 会清除打断状态  </span><br>                        thread.interrupt();  <br>                    &#125;  <br>                &#125;  <br>            &#125;  <br>        &#125;);  <br>        monitor.start();  <br>    &#125;  <br>    <span class="hljs-comment">// 停止监控线程  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">()</span> &#123;  <br>        monitor.interrupt();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>


<hr>
<h4 id="daemon"><a href="#daemon" class="headerlink" title="daemon"></a>daemon</h4><p><code>public final void setDaemon(boolean on)</code>：如果是 true ，将此线程标记为守护线程</p>
<p>线程<strong>启动前</strong>调用此方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>() &#123;  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;running&quot;</span>);  <br>    &#125;  <br>&#125;;  <br><span class="hljs-comment">// 设置该线程为守护线程  </span><br>t.setDaemon(<span class="hljs-literal">true</span>);  <br>t.start();<br></code></pre></td></tr></table></figure>

<p>用户线程：平常创建的普通线程</p>
<p>守护线程：服务于用户线程，只要其它非守护线程运行结束了，即使守护线程代码没有执行完，也会强制结束。守护进程是<strong>脱离于终端并且在后台运行的进程</strong>，脱离终端是为了避免在执行的过程中的信息在终端上显示</p>
<p>说明：当运行的线程都是守护线程，Java 虚拟机将退出，因为普通线程执行完后，JVM 是守护线程，不会继续运行下去</p>
<p>常见的守护线程：</p>
<ul>
<li><p>垃圾回收器线程就是一种守护线程</p>
</li>
<li><p>Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等待它们处理完当前请求</p>
</li>
</ul>
<hr>
<h4 id="不推荐"><a href="#不推荐" class="headerlink" title="不推荐"></a>不推荐</h4><p>不推荐使用的方法，这些方法已过时，容易破坏同步代码块，造成线程死锁：</p>
<ul>
<li><p><code>public final void stop()</code>：停止线程运行</p>
<p>  废弃原因：方法粗暴，除非可能执行 finally 代码块以及释放 synchronized 外，线程将直接被终止，如果线程持有 JUC 的互斥锁可能导致锁来不及释放，造成其他线程永远等待的局面</p>
</li>
<li><p><code>public final void suspend()</code>：<strong>挂起（暂停）线程运行</strong></p>
<p>  废弃原因：如果目标线程在暂停时对系统资源持有锁，则在目标线程恢复之前没有线程可以访问该资源，如果<strong>恢复目标线程的线程</strong>在调用 resume 之前会尝试访问此共享资源，则会导致死锁</p>
</li>
<li><p><code>public final void resume()</code>：恢复线程运行</p>
</li>
</ul>
<hr>
<h3 id="线程原理"><a href="#线程原理" class="headerlink" title="线程原理"></a>线程原理</h3><h4 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h4><p>Java Virtual Machine Stacks（Java 虚拟机栈）：每个线程启动后，虚拟机就会为其分配一块栈内存</p>
<ul>
<li><p>每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存</p>
</li>
<li><p>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</p>
</li>
</ul>
<p>线程上下文切换（Thread Context Switch）：一些原因导致 CPU 不再执行当前线程，转而执行另一个线程</p>
<ul>
<li><p>线程的 CPU 时间片用完</p>
</li>
<li><p>垃圾回收</p>
</li>
<li><p>有更高优先级的线程需要运行</p>
</li>
<li><p>线程自己调用了 sleep、yield、wait、join、park 等方法</p>
</li>
</ul>
<p>程序计数器（Program Counter Register）：记住下一条 JVM 指令的执行地址，是线程私有的</p>
<p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态（PCB 中），并恢复另一个线程的状态，包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等</p>
<p>JVM 规范并没有限定线程模型，以 HotSopot 为例：</p>
<ul>
<li><p>Java 的线程是内核级线程（1:1 线程模型），每个 Java 线程都映射到一个操作系统原生线程，需要消耗一定的内核资源（堆栈）</p>
</li>
<li><p><strong>线程的调度是在内核态运行的，而线程中的代码是在用户态运行</strong>，所以线程切换（状态改变）会导致用户与内核态转换进行系统调用，这是非常消耗性能</p>
</li>
</ul>
<p>Java 中 main 方法启动的是一个进程也是一个主线程，main 方法里面的其他线程均为子线程，main 线程是这些线程的父线程</p>
<hr>
<h4 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h4><p>线程调度指系统为线程分配处理器使用权的过程，方式有两种：协同式线程调度、抢占式线程调度（Java 选择）</p>
<p>协同式线程调度：线程的执行时间由线程本身控制</p>
<ul>
<li><p>优点：线程做完任务才通知系统切换到其他线程，相当于所有线程串行执行，不会出现线程同步问题</p>
</li>
<li><p>缺点：线程执行时间不可控，如果代码编写出现问题，可能导致程序一直阻塞，引起系统的奔溃</p>
</li>
</ul>
<p>抢占式线程调度：线程的执行时间由系统分配</p>
<ul>
<li><p>优点：线程执行时间可控，不会因为一个线程的问题而导致整体系统不可用</p>
</li>
<li><p>缺点：无法主动为某个线程多分配时间</p>
</li>
</ul>
<p>Java 提供了线程优先级的机制，优先级会提示（hint）调度器优先调度该线程，但这仅仅是一个提示，调度器可以忽略它。在线程的就绪状态时，如果 CPU 比较忙，那么优先级高的线程会获得更多的时间片，但 CPU 闲时，优先级几乎没作用</p>
<p>说明：并不能通过优先级来判断线程执行的先后顺序</p>
<hr>
<h4 id="未来优化"><a href="#未来优化" class="headerlink" title="未来优化"></a>未来优化</h4><p>内核级线程调度的成本较大，所以引入了更轻量级的协程。用户线程的调度由用户自己实现（多对一的线程模型，多<strong>个用户线程映射到一个内核级线程</strong>），被设计为协同式调度，所以叫协程</p>
<ul>
<li><p>有栈协程：协程会完整的做调用栈的保护、恢复工作，所以叫有栈协程</p>
</li>
<li><p>无栈协程：本质上是一种有限状态机，状态保存在闭包里，比有栈协程更轻量，但是功能有限</p>
</li>
</ul>
<p>有栈协程中有一种特例叫纤程，在新并发模型中，一段纤程的代码被分为两部分，执行过程和调度器：</p>
<ul>
<li><p>执行过程：用于维护执行现场，保护、恢复上下文状态</p>
</li>
<li><p>调度器：负责编排所有要执行的代码顺序</p>
</li>
</ul>
<hr>
<h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><p>进程的状态参考操作系统：创建态、就绪态、运行态、阻塞态、终止态</p>
<p>线程由生到死的完整过程（生命周期）：当线程被创建并启动以后，既不是一启动就进入了执行状态，也不是一直处于执行状态，在 API 中 <code>java.lang.Thread.State</code> 这个枚举中给出了六种线程状态：</p>
<table>
<thead>
<tr>
<th>线程状态</th>
<th>导致状态发生条件</th>
</tr>
</thead>
<tbody><tr>
<td>NEW（新建）</td>
<td>线程刚被创建，但是并未启动，还没调用 start 方法，只有线程对象，没有线程特征</td>
</tr>
<tr>
<td>Runnable（可运行）</td>
<td>线程可以在 Java 虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操作系统处理器，调用了 t.start() 方法：就绪（经典叫法）</td>
</tr>
<tr>
<td>Blocked（阻塞）</td>
<td>当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入 Blocked 状态；当该线程持有锁时，该线程将变成 Runnable 状态</td>
</tr>
<tr>
<td>Waiting（无限等待）</td>
<td>一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入 Waiting 状态，进入这个状态后不能自动唤醒，必须等待另一个线程调用 notify 或者 notifyAll 方法才能唤醒</td>
</tr>
<tr>
<td>Timed Waiting （限期等待）</td>
<td>有几个方法有超时参数，调用将进入 Timed Waiting 状态，这一状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有 Thread.sleep 、Object.wait</td>
</tr>
<tr>
<td>Teminated（结束）</td>
<td>run 方法正常退出而死亡，或者因为没有捕获的异常终止了 run 方法而死亡</td>
</tr>
</tbody></table>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041618351.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><p>NEW → RUNNABLE：当调用 t.start() 方法时，由 NEW → RUNNABLE</p>
</li>
<li><p>RUNNABLE &lt;–&gt; WAITING：</p>
<ul>
<li><p>调用 obj.wait() 方法时</p>
<p>  调用 obj.notify()、obj.notifyAll()、t.interrupt()：</p>
<ul>
<li><p>竞争锁成功，t 线程从 WAITING → RUNNABLE</p>
</li>
<li><p>竞争锁失败，t 线程从 WAITING → BLOCKED</p>
</li>
</ul>
</li>
<li><p>当前线程调用 t.join() 方法，注意是当前线程在 t 线程对象的监视器上等待</p>
</li>
<li><p>当前线程调用 LockSupport.park() 方法</p>
</li>
</ul>
</li>
<li><p>RUNNABLE &lt;–&gt; TIMED_WAITING：调用 obj.wait(long n) 方法、当前线程调用 t.join(long n) 方法、当前线程调用 Thread.sleep(long n)</p>
</li>
<li><p>RUNNABLE &lt;–&gt; BLOCKED：t 线程用 synchronized(obj) 获取了对象锁时竞争失败</p>
</li>
</ul>
<hr>
<h3 id="查看线程"><a href="#查看线程" class="headerlink" title="查看线程"></a>查看线程</h3><p>Windows：</p>
<ul>
<li><p>任务管理器可以查看进程和线程数，也可以用来杀死进程</p>
</li>
<li><p>tasklist 查看进程</p>
</li>
<li><p>taskkill 杀死进程</p>
</li>
</ul>
<p>Linux：</p>
<ul>
<li><p>ps -ef 查看所有进程</p>
</li>
<li><p>ps -fT -p &lt; PID&gt; 查看某个进程（PID）的所有线程</p>
</li>
<li><p>kill 杀死进程</p>
</li>
<li><p>top 按大写 H 切换是否显示线程</p>
</li>
<li><p>top -H -p &lt; PID&gt; 查看某个进程（PID）的所有线程</p>
</li>
</ul>
<p>Java：</p>
<ul>
<li><p>jps 命令查看所有 Java 进程</p>
</li>
<li><p>jstack &lt; PID&gt; 查看某个 Java 进程（PID）的所有线程状态</p>
</li>
<li><p>jconsole 来查看某个 Java 进程中线程的运行情况（图形界面）</p>
</li>
</ul>
<hr>
<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><p>临界资源：一次仅允许一个进程使用的资源成为临界资源</p>
<p>临界区：访问临界资源的代码块</p>
<p>竞态条件：多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了竞态条件</p>
<p>一个程序运行多个线程是没有问题，多个线程读共享资源也没有问题，在多个线程对共享资源读写操作时发生指令交错，就会出现问题</p>
<p>为了避免临界区的竞态条件发生（解决线程安全问题）：</p>
<ul>
<li><p>阻塞式的解决方案：synchronized，lock</p>
</li>
<li><p>非阻塞式的解决方案：原子变量</p>
</li>
</ul>
<p>管程（monitor）：由局部于自己的若干公共变量和所有访问这些公共变量的过程所组成的软件模块，保证同一时刻只有一个进程在管程内活动，即管程内定义的操作在同一时刻只被一个进程调用（由编译器实现）</p>
<p><strong>synchronized：对象锁，保证了临界区内代码的原子性</strong>，采用互斥的方式让同一时刻至多只有一个线程能持有对象锁，其它线程获取这个对象锁时会阻塞，保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换</p>
<p>互斥和同步都可以采用 synchronized 关键字来完成，区别：</p>
<ul>
<li><p>互斥是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区代码</p>
</li>
<li><p>同步是由于线程执行的先后、顺序不同、需要一个线程等待其它线程运行到某个点</p>
</li>
</ul>
<p>性能：</p>
<ul>
<li><p>线程安全，性能差</p>
</li>
<li><p>线程不安全性能好，假如开发中不会存在多线程安全问题，建议使用线程不安全的设计类</p>
</li>
</ul>
<hr>
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><h4 id="使用锁"><a href="#使用锁" class="headerlink" title="使用锁"></a>使用锁</h4><h5 id="同步块"><a href="#同步块" class="headerlink" title="同步块"></a>同步块</h5><p>锁对象：理论上可以是<strong>任意的唯一对象</strong></p>
<p>synchronized 是可重入、不公平的重量级锁</p>
<p>原则上：</p>
<ul>
<li><p>锁对象建议使用共享资源</p>
</li>
<li><p>在实例方法中使用 this 作为锁对象，锁住的 this 正好是共享资源</p>
</li>
<li><p>在静态方法中使用类名 .class 字节码作为锁对象，因为静态成员属于类，被所有实例对象共享，所以需要锁住类</p>
</li>
</ul>
<p>同步代码块格式：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">synchronized</span><span class="hljs-params">(锁对象)</span></span>&#123;  <br>	<span class="hljs-comment">// 访问共享资源的核心代码  </span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">demo</span> &#123;  <br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br>    <span class="hljs-comment">//static修饰，则元素是属于类本身的，不属于对象  ，与类一起加载一次，只有一个  </span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">room</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;  <br>                <span class="hljs-keyword">synchronized</span> (room) &#123;  <br>                    counter++;  <br>                &#125;  <br>            &#125;  <br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);  <br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;  <br>                <span class="hljs-keyword">synchronized</span> (room) &#123;  <br>                    counter--;  <br>                &#125;  <br>            &#125;  <br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>);  <br>        t1.start();  <br>        t2.start();  <br>        t1.join();  <br>        t2.join();  <br>        System.out.println(counter);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h5 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h5><p>把出现线程安全问题的核心方法锁起来，每次只能一个线程进入访问</p>
<p>synchronized 修饰的方法的不具备继承性，所以子类是线程不安全的，如果子类的方法也被 synchronized 修饰，两个锁对象其实是一把锁，而且是<strong>子类对象作为锁</strong></p>
<p>用法：直接给方法加上一个修饰符 synchronized</p>
<p>&#x2F;&#x2F;同步方法  </p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada">修饰符 <span class="hljs-keyword">synchronized</span> 返回值类型 方法名(方法参数) &#123;   <br>	方法体；  <br>&#125;  <br></code></pre></td></tr></table></figure>
<p>&#x2F;&#x2F;同步静态方法  </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino">修饰符 <span class="hljs-type">static</span> <span class="hljs-keyword">synchronized</span> 返回值类型 方法名(方法参数) &#123;   <br>	方法体；  <br>&#125;<br></code></pre></td></tr></table></figure>

<p>同步方法底层也是有锁对象的：</p>
<ul>
<li>如果方法是实例方法：同步方法默认用 this 作为的锁对象</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> synchronized <span class="hljs-built_in">void</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;&#125; <span class="hljs-comment">//等价于  </span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;  <br><span class="hljs-title function_">synchronized</span>(<span class="hljs-params"><span class="hljs-variable language_">this</span></span>) &#123;&#125;  <br> &#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>如果方法是静态方法：同步方法默认用类名 .class 作为的锁对象</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;  <br>	<span class="hljs-keyword">public</span> synchronized <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;&#125;  <br>&#125;  <br><span class="hljs-comment">//等价于  </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;  <br>        <span class="hljs-title function_">synchronized</span>(<span class="hljs-params">Test.<span class="hljs-keyword">class</span></span>) &#123;&#125;  <br>	&#125;  <br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<h5 id="线程八锁"><a href="#线程八锁" class="headerlink" title="线程八锁"></a>线程八锁</h5><p>线程八锁就是考察 synchronized 锁住的是哪个对象，直接百度搜索相关的实例</p>
<p>说明：主要关注锁住的对象是不是同一个</p>
<ul>
<li><p>锁住类对象，所有类的实例的方法都是安全的，类的所有实例都相当于同一把锁</p>
</li>
<li><p>锁住 this 对象，只有在当前实例对象的线程内是安全的，如果有多个实例就不安全</p>
</li>
</ul>
<p>线程不安全：因为锁住的不是同一个对象，线程 1 调用 a 方法锁住的n1对象，线程 2 调用 b 方法锁住的 n2 对象，不是同一个对象</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Number</span>&#123;  <br>    public <span class="hljs-keyword">static</span> synchronized <span class="hljs-literal">void</span> a()&#123;  <br>        Thread.sleep(<span class="hljs-number">1000</span>);  <br>        System.out.println(<span class="hljs-string">&quot;1&quot;</span>);  <br>    &#125;  <br>    public synchronized <span class="hljs-literal">void</span> b() &#123;  <br>        System.out.println(<span class="hljs-string">&quot;2&quot;</span>);  <br>    &#125;  <br>&#125;  <br>public <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> main(<span class="hljs-built_in">String</span>[] args) &#123;  <br>    <span class="hljs-built_in">Number</span> n1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>();  <br>    <span class="hljs-built_in">Number</span> n2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>();  <br>    <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(()-&gt;&#123; n1.a(); &#125;)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;  </span><br><span class="hljs-function">    <span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(()-&gt;&#123; n2.b(); &#125;)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;  </span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure>

<p>线程安全：因为 n1 调用 a() 方法，锁住的是类对象，n2 调用 b() 方法，锁住的也是类对象，所以线程安全</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Number</span>&#123;  <br>    public <span class="hljs-keyword">static</span> synchronized <span class="hljs-literal">void</span> a()&#123;  <br>        Thread.sleep(<span class="hljs-number">1000</span>);  <br>        System.out.println(<span class="hljs-string">&quot;1&quot;</span>);  <br>    &#125;  <br>    public <span class="hljs-keyword">static</span> synchronized <span class="hljs-literal">void</span> b() &#123;  <br>        System.out.println(<span class="hljs-string">&quot;2&quot;</span>);  <br>    &#125;  <br>&#125;  <br>public <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> main(<span class="hljs-built_in">String</span>[] args) &#123;  <br>    <span class="hljs-built_in">Number</span> n1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>();  <br>    <span class="hljs-built_in">Number</span> n2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>();  <br>    <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(()-&gt;&#123; n1.a(); &#125;)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;  </span><br><span class="hljs-function">    <span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(()-&gt;&#123; n2.b(); &#125;)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;  </span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure>

<hr>
<h4 id="锁原理"><a href="#锁原理" class="headerlink" title="锁原理"></a>锁原理</h4><h5 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h5><p>Monitor 被翻译为监视器或管程</p>
<p>每个 Java 对象都可以关联一个 Monitor 对象，Monitor 也是 class，其<strong>实例存储在堆中</strong>，如果使用 synchronized 给对象上锁（重量级）之后，该对象头的 Mark Word 中就被设置指向 Monitor 对象的指针，这就是重量级锁</p>
<ul>
<li>Mark Word 结构：最后两位是<strong>锁标志位</strong></li>
</ul>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041620782.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>64 位虚拟机 Mark Word：</li>
</ul>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041620048.png" srcset="/img/loading.gif" lazyload></p>
<p>工作流程：</p>
<ul>
<li><p>开始时 Monitor 中 Owner 为 null</p>
</li>
<li><p>当 Thread-2 执行 synchronized(obj) 就会将 Monitor 的所有者 Owner 置为 Thread-2，Monitor 中只能有一个 Owner，<strong>obj 对象的 Mark Word 指向 Monitor</strong>，把<strong>对象原有的 MarkWord 存入线程栈中的锁记录</strong>中（轻量级锁部分详解）<br><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041621477.png" srcset="/img/loading.gif" lazyload>    </p>
</li>
<li><p>在 Thread-2 上锁的过程，Thread-3、Thread-4、Thread-5 也执行 synchronized(obj)，就会进入 EntryList BLOCKED（双向链表）</p>
</li>
<li><p>Thread-2 执行完同步代码块的内容，根据 obj 对象头中 Monitor 地址寻找，设置 Owner 为空，把线程栈的锁记录中的对象头的值设置回 MarkWord</p>
</li>
<li><p>唤醒 EntryList 中等待的线程来竞争锁，竞争是<strong>非公平的</strong>，如果这时有新的线程想要获取锁，可能直接就抢占到了，阻塞队列的线程就会继续阻塞</p>
</li>
<li><p>WaitSet 中的 Thread-0，是以前获得过锁，但条件不满足进入 WAITING 状态的线程（wait-notify 机制）</p>
</li>
</ul>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041621372.png" srcset="/img/loading.gif" lazyload></p>
<p>注意：</p>
<ul>
<li><p>synchronized 必须是进入同一个对象的 Monitor 才有上述的效果</p>
</li>
<li><p>不加 synchronized 的对象不会关联监视器，不遵从以上规则</p>
</li>
</ul>
<hr>
<h5 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h5><p>代码：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) &#123;  <br>    Object lock = <span class="hljs-keyword">new</span> Object();  <br>    <span class="hljs-keyword">synchronized</span> (lock) &#123;  <br>        System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;ok&quot;</span>);  <br>    &#125;  <br>&#125;<br><br><span class="hljs-number">0</span>: 	<span class="hljs-keyword">new</span>				#<span class="hljs-number">2</span>		<span class="hljs-comment">// new Object  </span><br><span class="hljs-number">3</span>: 	dup  <br><span class="hljs-number">4</span>: 	invokespecial 	#<span class="hljs-number">1</span> 		<span class="hljs-comment">// invokespecial &lt;init&gt;:()V，非虚方法  </span><br><span class="hljs-number">7</span>: 	astore_1 				<span class="hljs-comment">// lock引用 -&gt; lock  </span><br><span class="hljs-number">8</span>: 	aload_1					<span class="hljs-comment">// lock （synchronized开始）  </span><br><span class="hljs-number">9</span>: 	dup						<span class="hljs-comment">// 一份用来初始化，一份用来引用  </span><br><span class="hljs-number">10</span>: astore_2 				<span class="hljs-comment">// lock引用 -&gt; slot 2  </span><br><span class="hljs-number">11</span>: monitorenter 			<span class="hljs-comment">// 【将 lock对象 MarkWord 置为 Monitor 指针】  </span><br><span class="hljs-number">12</span>: getstatic 		#<span class="hljs-number">3</span>		<span class="hljs-comment">// System.out  </span><br><span class="hljs-number">15</span>: ldc 			#<span class="hljs-number">4</span>		<span class="hljs-comment">// &quot;ok&quot;  </span><br><span class="hljs-number">17</span>: invokevirtual 	#<span class="hljs-number">5</span> 		<span class="hljs-comment">// invokevirtual println:(Ljava/lang/String;)V  </span><br><span class="hljs-number">20</span>: aload_2 				<span class="hljs-comment">// slot 2(lock引用)  </span><br><span class="hljs-number">21</span>: monitorexit 			<span class="hljs-comment">// 【将 lock对象 MarkWord 重置, 唤醒 EntryList】  </span><br><span class="hljs-number">22</span>: goto <span class="hljs-number">30</span>  <br><span class="hljs-number">25</span>: astore_3 				<span class="hljs-comment">// any -&gt; slot 3  </span><br><span class="hljs-number">26</span>: aload_2 				<span class="hljs-comment">// slot 2(lock引用)  </span><br><span class="hljs-number">27</span>: monitorexit 			<span class="hljs-comment">// 【将 lock对象 MarkWord 重置, 唤醒 EntryList】  </span><br><span class="hljs-number">28</span>: aload_3  <br><span class="hljs-number">29</span>: athrow  <br><span class="hljs-number">30</span>: <span class="hljs-keyword">return</span>  <br>Exception table:  <br>    <span class="hljs-keyword">from</span> to target type  <br>      <span class="hljs-number">12</span> <span class="hljs-number">22</span> <span class="hljs-number">25</span> 		<span class="hljs-keyword">any</span>  <br>      <span class="hljs-number">25</span> <span class="hljs-number">28</span> <span class="hljs-number">25</span> 		<span class="hljs-keyword">any</span>  <br>LineNumberTable: ...  <br>LocalVariableTable:  <br>    Start Length Slot Name Signature  <br>    	<span class="hljs-number">0</span> 	<span class="hljs-number">31</span> 		<span class="hljs-number">0</span> args [Ljava<span class="hljs-regexp">/lang/</span>String;  <br>    	<span class="hljs-number">8</span> 	<span class="hljs-number">23</span> 		<span class="hljs-number">1</span> lock Ljava<span class="hljs-regexp">/lang/</span>Object;<br><br></code></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li><p>通过异常 <strong>try-catch 机制</strong>，确保一定会被解锁</p>
</li>
<li><p>方法级别的 synchronized 不会在字节码指令中有所体现</p>
</li>
</ul>
<hr>
<h4 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h4><h5 id="升级过程"><a href="#升级过程" class="headerlink" title="升级过程"></a>升级过程</h5><p><strong>synchronized 是可重入、不公平的重量级锁</strong>，所以可以对其进行优化</p>
<p>无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁	&#x2F;&#x2F; 随着竞争的增加，只能锁升级，不能降级</p>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041622328.png" srcset="/img/loading.gif" lazyload></p>
<hr>
<h5 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h5><p>偏向锁的思想是偏向于让第一个获取锁对象的线程，这个线程之后重新获取该锁不再需要同步操作：</p>
<ul>
<li><p>当锁对象第一次被线程获得的时候进入偏向状态，标记为 101，同时<strong>使用 CAS 操作将线程 ID 记录到 Mark Word</strong>。如果 CAS 操作成功，这个线程以后进入这个锁相关的同步块，查看这个线程 ID 是自己的就表示没有竞争，就不需要再进行任何同步操作</p>
</li>
<li><p>当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向（Revoke Bias）后恢复到未锁定或轻量级锁状态</p>
</li>
</ul>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041622764.png" srcset="/img/loading.gif" lazyload></p>
<p>一个对象创建时：</p>
<ul>
<li><p>如果开启了偏向锁（默认开启），那么对象创建后，MarkWord 值为 0x05 即最后 3 位为 101，thread、epoch、age 都为 0</p>
</li>
<li><p>偏向锁是默认是延迟的，不会在程序启动时立即生效，如果想避免延迟，可以加 VM 参数 <code>-XX:BiasedLockingStartupDelay=0</code> 来禁用延迟。JDK 8 延迟 4s 开启偏向锁原因：在刚开始执行代码时，会有好多线程来抢锁，如果开偏向锁效率反而降低</p>
</li>
<li><p>当一个对象已经计算过 hashCode，就再也无法进入偏向状态了</p>
</li>
<li><p>添加 VM 参数 <code>-XX:-UseBiasedLocking</code> 禁用偏向锁</p>
</li>
</ul>
<p>撤销偏向锁的状态：</p>
<ul>
<li><p>调用对象的 hashCode：偏向锁的对象 MarkWord 中存储的是线程 id，调用 hashCode 导致偏向锁被撤销</p>
</li>
<li><p>当有其它线程使用偏向锁对象时，会将偏向锁升级为轻量级锁</p>
</li>
<li><p>调用 wait&#x2F;notify，需要申请 Monitor，进入 WaitSet</p>
</li>
</ul>
<p><strong>批量撤销</strong>：如果对象被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，重偏向会重置对象的 Thread ID</p>
<ul>
<li><p>批量重偏向：当撤销偏向锁阈值超过 20 次后，JVM 会觉得是不是偏向错了，于是在给这些对象加锁时重新偏向至加锁线程</p>
</li>
<li><p>批量撤销：当撤销偏向锁阈值超过 40 次后，JVM 会觉得自己确实偏向错了，根本就不该偏向，于是整个类的所有对象都会变为不可偏向的，新建的对象也是不可偏向的</p>
</li>
</ul>
<hr>
<h5 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h5><p>一个对象有多个线程要加锁，但加锁的时间是错开的（没有竞争），可以使用轻量级锁来优化，轻量级锁对使用者是透明的（不可见）</p>
<p>可重入锁：线程可以进入任何一个它已经拥有的锁所同步着的代码块，可重入锁最大的作用是<strong>避免死锁</strong></p>
<p>轻量级锁在没有竞争时（锁重入时），每次重入仍然需要执行 CAS 操作，Java 6 才引入的偏向锁来优化</p>
<p>锁重入实例：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">static</span> final <span class="hljs-title class_">Object</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">method1</span>(<span class="hljs-params"></span>) &#123;  <br>    <span class="hljs-title function_">synchronized</span>(<span class="hljs-params"> obj </span>) &#123;  <br>        <span class="hljs-comment">// 同步块 A  </span><br>        <span class="hljs-title function_">method2</span>();  <br>    &#125;  <br>&#125;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">method2</span>(<span class="hljs-params"></span>) &#123;  <br>    <span class="hljs-title function_">synchronized</span>(<span class="hljs-params"> obj </span>) &#123;  <br>    	<span class="hljs-comment">// 同步块 B  </span><br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>创建锁记录（Lock Record）对象，每个线程的<strong>栈帧</strong>都会包含一个锁记录的结构，存储锁定对象的 Mark Word</li>
</ul>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041622396.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><p>让锁记录中 Object reference 指向锁住的对象，并尝试用 CAS 替换 Object 的 Mark Word，将 Mark Word 的值存入锁记录</p>
</li>
<li><p>如果 CAS 替换成功，对象头中存储了锁记录地址和状态 00（轻量级锁） ，表示由该线程给对象加锁<br><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041623035.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>如果 CAS 失败，有两种情况：</p>
<ul>
<li><p>如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入锁膨胀过程</p>
</li>
<li><p>如果是线程自己执行了 synchronized 锁重入，就添加一条 Lock Record 作为重入的计数</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041623988.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><p>当退出 synchronized 代码块（解锁时）</p>
<ul>
<li><p>如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减 1</p>
</li>
<li><p>如果锁记录的值不为 null，这时使用 CAS <strong>将 Mark Word 的值恢复给对象头</strong></p>
<ul>
<li><p>成功，则解锁成功</p>
</li>
<li><p>失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h5 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h5><p>在尝试加轻量级锁的过程中，CAS 操作无法成功，可能是其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为<strong>重量级锁</strong></p>
<ul>
<li>当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁</li>
</ul>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041623875.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>Thread-1 加轻量级锁失败，进入锁膨胀流程：为 Object 对象申请 Monitor 锁，<strong>通过 Object 对象头获取到持锁线程</strong>，将 Monitor 的 Owner 置为 Thread-0，将 Object 的对象头指向重量级锁地址，然后自己进入 Monitor 的 EntryList BLOCKED</li>
</ul>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041624894.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>当 Thread-0 退出同步块解锁时，使用 CAS 将 Mark Word 的值恢复给对象头失败，这时进入重量级解锁流程，即按照 Monitor 地址找到 Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中 BLOCKED 线程</li>
</ul>
<hr>
<h4 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h4><h5 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h5><p>重量级锁竞争时，尝试获取锁的线程不会立即阻塞，可以使用<strong>自旋</strong>（默认 10 次）来进行优化，采用循环的方式去尝试获取锁</p>
<p>注意：</p>
<ul>
<li><p>自旋占用 CPU 时间，单核 CPU 自旋就是浪费时间，因为同一时刻只能运行一个线程，多核 CPU 自旋才能发挥优势</p>
</li>
<li><p>自旋失败的线程会进入阻塞状态</p>
</li>
</ul>
<p>优点：不会进入阻塞状态，<strong>减少线程上下文切换的消耗</strong></p>
<p>缺点：当自旋的线程越来越多时，会不断的消耗 CPU 资源</p>
<p>自旋锁情况：</p>
<ul>
<li><p>自旋成功的情况：<br><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041624183.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>自旋失败的情况：</p>
</li>
</ul>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041625916.png" srcset="/img/loading.gif" lazyload></p>
<p>自旋锁说明：</p>
<ul>
<li><p>在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，比较智能</p>
</li>
<li><p>Java 7 之后不能控制是否开启自旋功能，由 JVM 控制</p>
</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><br><span class="hljs-comment">//手写自旋锁  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SpinLock</span> &#123;  <br>    <span class="hljs-comment">// 泛型装的是Thread，原子引用线程  </span><br>    AtomicReference&lt;Thread&gt; atomicReference = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;();  <br>  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span>()</span> &#123;  <br>        Thread thread = Thread.currentThread();  <br>        System.<span class="hljs-keyword">out</span>.println(thread.getName() + <span class="hljs-string">&quot; come in&quot;</span>);  <br>  <br>        <span class="hljs-comment">//开始自旋，期望值为null，更新值是当前线程  </span><br>        <span class="hljs-keyword">while</span> (!atomicReference.compareAndSet(<span class="hljs-literal">null</span>, thread)) &#123;  <br>            Thread.sleep(<span class="hljs-number">1000</span>);  <br>            System.<span class="hljs-keyword">out</span>.println(thread.getName() + <span class="hljs-string">&quot; 正在自旋&quot;</span>);  <br>        &#125;  <br>        System.<span class="hljs-keyword">out</span>.println(thread.getName() + <span class="hljs-string">&quot; 自旋成功&quot;</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span>()</span> &#123;  <br>        Thread thread = Thread.currentThread();  <br>  <br>        <span class="hljs-comment">//线程使用完锁把引用变为null  </span><br>		atomicReference.compareAndSet(thread, <span class="hljs-literal">null</span>);  <br>        System.<span class="hljs-keyword">out</span>.println(thread.getName() + <span class="hljs-string">&quot; invoke unlock&quot;</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>) throws InterruptedException</span> &#123;  <br>        SpinLock <span class="hljs-keyword">lock</span> = <span class="hljs-keyword">new</span> SpinLock();  <br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;  <br>            <span class="hljs-comment">//占有锁  </span><br>            <span class="hljs-keyword">lock</span>.<span class="hljs-keyword">lock</span>();  <br>            Thread.sleep(<span class="hljs-number">10000</span>);   <br>  <br>            <span class="hljs-comment">//释放锁  </span><br>            <span class="hljs-keyword">lock</span>.unlock();  <br>        &#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();  <br>  <br>        <span class="hljs-comment">// 让main线程暂停1秒，使得t1线程，先执行  </span><br>        Thread.sleep(<span class="hljs-number">1000</span>);  <br>  <br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;  <br>            <span class="hljs-keyword">lock</span>.<span class="hljs-keyword">lock</span>();  <br>            <span class="hljs-keyword">lock</span>.unlock();  <br>        &#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h5 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h5><p>锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除，这是 JVM <strong>即时编译器的优化</strong></p>
<p>锁消除主要是通过<strong>逃逸分析</strong>来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除（同步消除：JVM 逃逸分析）</p>
<hr>
<h5 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h5><p>对相同对象多次加锁，导致线程发生多次重入，频繁的加锁操作就会导致性能损耗，可以使用锁粗化方式优化</p>
<p>如果虚拟机探测到一串的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部</p>
<ul>
<li><p>一些看起来没有加锁的代码，其实隐式的加了很多锁：</p>
<p>  public static String concatString(String s1, String s2, String s3) {<br>  return s1 + s2 + s3;<br>  }</p>
</li>
<li><p>String 是一个不可变的类，编译器会对 String 的拼接自动优化。在 JDK 1.5 之前，转化为 StringBuffer 对象的连续 append() 操作，每个 append() 方法中都有一个同步块</p>
<p>  public static String concatString(String s1, String s2, String s3) {<br>  StringBuffer sb &#x3D; new StringBuffer();<br>  sb.append(s1);<br>  sb.append(s2);<br>  sb.append(s3);<br>  return sb.toString();<br>  }</p>
</li>
</ul>
<p>扩展到第一个 append() 操作之前直至最后一个 append() 操作之后，只需要加锁一次就可以</p>
<hr>
<h4 id="多把锁"><a href="#多把锁" class="headerlink" title="多把锁"></a>多把锁</h4><p>多把不相干的锁：一间大屋子有两个功能睡觉、学习，互不相干。现在一人要学习，一人要睡觉，如果只用一间屋子（一个对象锁）的话，那么并发度很低</p>
<p>将锁的粒度细分：</p>
<ul>
<li><p>好处，是可以增强并发度</p>
</li>
<li><p>坏处，如果一个线程需要同时获得多把锁，就容易发生死锁</p>
</li>
</ul>
<p>解决方法：准备多个对象锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    <span class="hljs-type">BigRoom</span> <span class="hljs-variable">bigRoom</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigRoom</span>();  <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123; bigRoom.study(); &#125;).start();  <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123; bigRoom.sleep(); &#125;).start();  <br>&#125;  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BigRoom</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">studyRoom</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">sleepRoom</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>        <span class="hljs-keyword">synchronized</span> (sleepRoom) &#123;  <br>            System.out.println(<span class="hljs-string">&quot;sleeping 2 小时&quot;</span>);  <br>            Thread.sleep(<span class="hljs-number">2000</span>);  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>        <span class="hljs-keyword">synchronized</span> (studyRoom) &#123;  <br>            System.out.println(<span class="hljs-string">&quot;study 1 小时&quot;</span>);  <br>            Thread.sleep(<span class="hljs-number">1000</span>);  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="活跃性"><a href="#活跃性" class="headerlink" title="活跃性"></a>活跃性</h4><h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><h6 id="形成"><a href="#形成" class="headerlink" title="形成"></a>形成</h6><p>死锁：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放，由于线程被无限期地阻塞，因此程序不可能正常终止</p>
<p>Java 死锁产生的四个必要条件：</p>
<ol>
<li><p>互斥条件，即当资源被一个线程使用（占有）时，别的线程不能使用</p>
</li>
<li><p>不可剥夺条件，资源请求者不能强制从资源占有者手中夺取资源，资源只能由资源占有者主动释放</p>
</li>
<li><p>请求和保持条件，即当资源请求者在请求其他的资源的同时保持对原有资源的占有</p>
</li>
<li><p>循环等待条件，即存在一个等待循环队列：p1 要 p2 的资源，p2 要 p1 的资源，形成了一个等待环路</p>
</li>
</ol>
<p>四个条件都成立的时候，便形成死锁。死锁情况下打破上述任何一个条件，便可让死锁消失</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dead</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">resources1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">resources2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>            <span class="hljs-comment">// 线程1：占用资源1 ，请求资源2  </span><br>            <span class="hljs-keyword">synchronized</span>(resources1)&#123;  <br>                System.out.println(<span class="hljs-string">&quot;线程1已经占用了资源1，开始请求资源2&quot;</span>);  <br>                Thread.sleep(<span class="hljs-number">2000</span>);<span class="hljs-comment">//休息两秒，防止线程1直接运行完成。  </span><br>                <span class="hljs-comment">//2秒内线程2肯定可以锁住资源2  </span><br>                <span class="hljs-keyword">synchronized</span> (resources2)&#123;  <br>                    System.out.println(<span class="hljs-string">&quot;线程1已经占用了资源2&quot;</span>);  <br>                &#125;  <br>        &#125;).start();  <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>            <span class="hljs-comment">// 线程2：占用资源2 ，请求资源1  </span><br>            <span class="hljs-keyword">synchronized</span>(resources2)&#123;  <br>                System.out.println(<span class="hljs-string">&quot;线程2已经占用了资源2，开始请求资源1&quot;</span>);  <br>                Thread.sleep(<span class="hljs-number">2000</span>);  <br>                <span class="hljs-keyword">synchronized</span> (resources1)&#123;  <br>                    System.out.println(<span class="hljs-string">&quot;线程2已经占用了资源1&quot;</span>);  <br>                &#125;  <br>            &#125;&#125;  <br>        &#125;).start();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h6 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h6><p>定位死锁的方法：</p>
<ul>
<li><p>使用 jps 定位进程 id，再用 <code>jstack id</code> 定位死锁，找到死锁的线程去查看源码，解决优化</p>
<p>  “Thread-1” #12 prio&#x3D;5 os_prio&#x3D;0 tid&#x3D;0x000000001eb69000 nid&#x3D;0xd40 waiting formonitor entry [0x000000001f54f000]<br>  java.lang.Thread.State: BLOCKED (on object monitor)<br>  #省略<br>  “Thread-1” #12 prio&#x3D;5 os_prio&#x3D;0 tid&#x3D;0x000000001eb69000 nid&#x3D;0xd40 waiting for monitor entry [0x000000001f54f000]<br>  java.lang.Thread.State: BLOCKED (on object monitor)<br>  #省略<br>  Found one Java-level deadlock:<br>  “Thread-1”:<br>  waiting to lock monitor 0x000000000361d378 (object 0x000000076b5bf1c0, a java.lang.Object),<br>  which is held by “Thread-0”<br>  “Thread-0”:<br>  waiting to lock monitor 0x000000000361e768 (object 0x000000076b5bf1d0, a java.lang.Object),<br>  which is held by “Thread-1”<br><br>  Java stack information for the threads listed above:<br>  “Thread-1”:<br>  at thread.TestDeadLock.lambda$main$1(TestDeadLock.java:28)<br>  - waiting to lock &lt;0x000000076b5bf1c0&gt; (a java.lang.Object)<br>  - locked &lt;0x000000076b5bf1d0&gt; (a java.lang.Object)<br>  at thread.TestDeadLock$$Lambda$2&#x2F;883049899.run(Unknown Source)<br>  at java.lang.Thread.run(Thread.java:745)<br>  “Thread-0”:<br>  at thread.TestDeadLock.lambda$main$0(TestDeadLock.java:15)<br>  - waiting to lock &lt;0x000000076b5bf1d0&gt; (a java.lang.Object)<br>  - locked &lt;0x000000076b5bf1c0&gt; (a java.lang.Object)<br>  at thread.TestDeadLock$$Lambda$1&#x2F;495053715</p>
</li>
<li><p>Linux 下可以通过 top 先定位到 CPU 占用高的 Java 进程，再利用 <code>top -Hp 进程id</code> 来定位是哪个线程，最后再用 jstack &lt; pid&gt;的输出来看各个线程栈</p>
</li>
<li><p>避免死锁：避免死锁要注意加锁顺序</p>
</li>
<li><p>可以使用 jconsole 工具，在 <code>jdk\bin</code> 目录下</p>
</li>
</ul>
<hr>
<h5 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h5><p>活锁：指的是任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试—失败—尝试—失败的过程</p>
<p>两个线程互相改变对方的结束条件，最后谁也无法结束：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestLiveLock</span> &#123;  <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;  <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>            <span class="hljs-comment">// 期望减到 0 退出循环  </span><br>            <span class="hljs-keyword">while</span> (count &gt; <span class="hljs-number">0</span>) &#123;  <br>                Thread.sleep(<span class="hljs-number">200</span>);  <br>                count--;  <br>                System.out.println(<span class="hljs-string">&quot;线程一count:&quot;</span> + count);  <br>            &#125;  <br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();  <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>            <span class="hljs-comment">// 期望超过 20 退出循环  </span><br>            <span class="hljs-keyword">while</span> (count &lt; <span class="hljs-number">20</span>) &#123;  <br>                Thread.sleep(<span class="hljs-number">200</span>);  <br>                count++;  <br>                System.out.println(<span class="hljs-string">&quot;线程二count:&quot;</span>+ count);  <br>            &#125;  <br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h5 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h5><p>饥饿：一个线程由于优先级太低，始终得不到 CPU 调度执行，也不能够结束</p>
<hr>
<h3 id="wait-ify"><a href="#wait-ify" class="headerlink" title="wait-ify"></a>wait-ify</h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>需要获取对象锁后才可以调用 <code>锁对象.wait()</code>，notify 随机唤醒一个线程，notifyAll 唤醒所有线程去竞争 CPU</p>
<p>Object 类 API：</p>
<p>public final void notify():唤醒正在等待对象监视器的单个线程。<br>public final void notifyAll():唤醒正在等待对象监视器的所有线程。<br>public final void wait():导致当前线程等待，直到另一个线程调用该对象的 notify() 方法或 notifyAll()方法。<br>public final native void wait(long timeout):有时限的等待, 到n毫秒后结束等待，或是被唤醒</p>
<p>说明：<strong>wait 是挂起线程，需要唤醒的都是挂起操作</strong>，阻塞线程可以自己去争抢锁，挂起的线程需要唤醒后去争抢锁</p>
<p>对比 sleep()：</p>
<ul>
<li><p>原理不同：sleep() 方法是属于 Thread 类，是线程用来控制自身流程的，使此线程暂停执行一段时间而把执行机会让给其他线程；wait() 方法属于 Object 类，用于线程间通信</p>
</li>
<li><p>对<strong>锁的处理机制</strong>不同：调用 sleep() 方法的过程中，线程不会释放对象锁，当调用 wait() 方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池（不释放锁其他线程怎么抢占到锁执行唤醒操作），但是都会释放 CPU</p>
</li>
<li><p>使用区域不同：wait() 方法必须放在<strong>同步控制方法和同步代码块（先获取锁）</strong>中使用，sleep() 方法则可以放在任何地方使用</p>
</li>
</ul>
<p>底层原理：</p>
<ul>
<li><p>Owner 线程发现条件不满足，调用 wait 方法，即可进入 WaitSet 变为 WAITING 状态</p>
</li>
<li><p>BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片</p>
</li>
<li><p>BLOCKED 线程会在 Owner 线程释放锁时唤醒</p>
</li>
<li><p>WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，唤醒后并不意味者立刻获得锁，<strong>需要进入 EntryList 重新竞争</strong></p>
</li>
</ul>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041625177.png" srcset="/img/loading.gif" lazyload></p>
<hr>
<h4 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h4><p>虚假唤醒：notify 只能随机唤醒一个 WaitSet 中的线程，这时如果有其它线程也在等待，那么就可能唤醒不了正确的线程</p>
<p>解决方法：采用 notifyAll</p>
<p>notifyAll 仅解决某个线程的唤醒问题，使用 if + wait 判断仅有一次机会，一旦条件不成立，无法重新判断</p>
<p>解决方法：用 while + wait，当条件不成立，再次 wait</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@Slf4j(topic = &quot;c.demo&quot;)</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">demo</span> &#123;  <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">room</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();  <br>    <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">hasCigarette</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;    <span class="hljs-comment">//有没有烟  </span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">hasTakeout</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>            <span class="hljs-keyword">synchronized</span> (room) &#123;  <br>                log.debug(<span class="hljs-string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);  <br>                <span class="hljs-keyword">while</span> (!hasCigarette) &#123;<span class="hljs-comment">//while防止虚假唤醒  </span><br>                    log.debug(<span class="hljs-string">&quot;没烟，先歇会！&quot;</span>);  <br>                    <span class="hljs-keyword">try</span> &#123;  <br>                        room.wait();  <br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>                        e.printStackTrace();  <br>                    &#125;  <br>                &#125;  <br>                log.debug(<span class="hljs-string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);  <br>                <span class="hljs-keyword">if</span> (hasCigarette) &#123;  <br>                    log.debug(<span class="hljs-string">&quot;可以开始干活了&quot;</span>);  <br>                &#125; <span class="hljs-keyword">else</span> &#123;  <br>                    log.debug(<span class="hljs-string">&quot;没干成活...&quot;</span>);  <br>                &#125;  <br>            &#125;  <br>        &#125;, <span class="hljs-string">&quot;小南&quot;</span>).start();  <br>  <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>            <span class="hljs-keyword">synchronized</span> (room) &#123;  <br>                <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> Thread.currentThread();  <br>                log.debug(<span class="hljs-string">&quot;外卖送到没？[&#123;&#125;]&quot;</span>, hasTakeout);  <br>                <span class="hljs-keyword">if</span> (!hasTakeout) &#123;  <br>                    log.debug(<span class="hljs-string">&quot;没外卖，先歇会！&quot;</span>);  <br>                    <span class="hljs-keyword">try</span> &#123;  <br>                        room.wait();  <br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>                        e.printStackTrace();  <br>                    &#125;  <br>                &#125;  <br>                log.debug(<span class="hljs-string">&quot;外卖送到没？[&#123;&#125;]&quot;</span>, hasTakeout);  <br>                <span class="hljs-keyword">if</span> (hasTakeout) &#123;  <br>                    log.debug(<span class="hljs-string">&quot;可以开始干活了&quot;</span>);  <br>                &#125; <span class="hljs-keyword">else</span> &#123;  <br>                    log.debug(<span class="hljs-string">&quot;没干成活...&quot;</span>);  <br>                &#125;  <br>            &#125;  <br>        &#125;, <span class="hljs-string">&quot;小女&quot;</span>).start();  <br>  <br>  <br>        Thread.sleep(<span class="hljs-number">1000</span>);  <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>        <span class="hljs-comment">// 这里能不能加 synchronized (room)？  </span><br>            <span class="hljs-keyword">synchronized</span> (room) &#123;  <br>                hasTakeout = <span class="hljs-literal">true</span>;  <br>				<span class="hljs-comment">//log.debug(&quot;烟到了噢！&quot;);  </span><br>                log.debug(<span class="hljs-string">&quot;外卖到了噢！&quot;</span>);  <br>                room.notifyAll();  <br>            &#125;  <br>        &#125;, <span class="hljs-string">&quot;送外卖的&quot;</span>).start();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="park-un"><a href="#park-un" class="headerlink" title="park-un"></a>park-un</h3><p>LockSupport 是用来创建锁和其他同步类的<strong>线程原语</strong></p>
<p>LockSupport 类方法：</p>
<ul>
<li><p><code>LockSupport.park()</code>：暂停当前线程，挂起原语</p>
</li>
<li><p><code>LockSupport.unpark(暂停的线程对象)</code>：恢复某个线程的运行</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>        System.out.println(<span class="hljs-string">&quot;start...&quot;</span>);	<span class="hljs-comment">//1  </span><br>		Thread.sleep(<span class="hljs-number">1000</span>);<span class="hljs-comment">// Thread.sleep(3000)  </span><br>        <span class="hljs-comment">// 先 park 再 unpark 和先 unpark 再 park 效果一样，都会直接恢复线程的运行  </span><br>        System.out.println(<span class="hljs-string">&quot;park...&quot;</span>);	<span class="hljs-comment">//2  </span><br>        LockSupport.park();  <br>        System.out.println(<span class="hljs-string">&quot;resume...&quot;</span>);<span class="hljs-comment">//4  </span><br>    &#125;,<span class="hljs-string">&quot;t1&quot;</span>);  <br>    t1.start();  <br>   	Thread.sleep(<span class="hljs-number">2000</span>);  <br>    System.out.println(<span class="hljs-string">&quot;unpark...&quot;</span>);	<span class="hljs-comment">//3  </span><br>    LockSupport.unpark(t1);  <br>&#125;<br></code></pre></td></tr></table></figure>

<p>LockSupport 出现就是为了增强 wait &amp; notify 的功能：</p>
<ul>
<li><p>wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park、unpark 不需要</p>
</li>
<li><p>park &amp; unpark <strong>以线程为单位</strong>来阻塞和唤醒线程，而 notify 只能随机唤醒一个等待线程，notifyAll 是唤醒所有等待线程</p>
</li>
<li><p>park &amp; unpark 可以先 unpark，而 wait &amp; notify 不能先 notify。类比生产消费，先消费发现有产品就消费，没有就等待；先生产就直接产生商品，然后线程直接消费</p>
</li>
<li><p>wait 会释放锁资源进入等待队列，<strong>park 不会释放锁资源</strong>，只负责阻塞当前线程，会释放 CPU</p>
</li>
</ul>
<p>原理：类似生产者消费者</p>
<ul>
<li><p>先 park：</p>
<ol>
<li><p>当前线程调用 Unsafe.park() 方法</p>
</li>
<li><p>检查 _counter ，本情况为 0，这时获得 _mutex 互斥锁</p>
</li>
<li><p>线程进入 _cond 条件变量挂起</p>
</li>
<li><p>调用 Unsafe.unpark(Thread_0) 方法，设置 _counter 为 1</p>
</li>
<li><p>唤醒 _cond 条件变量中的 Thread_0，Thread_0 恢复运行，设置 _counter 为 0</p>
</li>
</ol>
</li>
</ul>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041626876.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><p>先 unpark：</p>
<ol>
<li><p>调用 Unsafe.unpark(Thread_0) 方法，设置 _counter 为 1</p>
</li>
<li><p>当前线程调用 Unsafe.park() 方法</p>
</li>
<li><p>检查 _counter ，本情况为 1，这时线程无需挂起，继续运行，设置 _counter 为 0</p>
</li>
</ol>
</li>
</ul>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041626568.png" srcset="/img/loading.gif" lazyload></p>
<hr>
<h3 id="安全分析"><a href="#安全分析" class="headerlink" title="安全分析"></a>安全分析</h3><p>成员变量和静态变量：</p>
<ul>
<li><p>如果它们没有共享，则线程安全</p>
</li>
<li><p>如果它们被共享了，根据它们的状态是否能够改变，分两种情况：</p>
<ul>
<li><p>如果只有读操作，则线程安全</p>
</li>
<li><p>如果有读写操作，则这段代码是临界区，需要考虑线程安全问题</p>
</li>
</ul>
</li>
</ul>
<p>局部变量：</p>
<ul>
<li><p>局部变量是线程安全的</p>
</li>
<li><p>局部变量引用的对象不一定线程安全（逃逸分析）：</p>
<ul>
<li><p>如果该对象没有逃离方法的作用访问，它是线程安全的（每一个方法有一个栈帧）</p>
</li>
<li><p>如果该对象逃离方法的作用范围，需要考虑线程安全问题（暴露引用）</p>
</li>
</ul>
</li>
</ul>
<p>常见线程安全类：String、Integer、StringBuffer、Random、Vector、Hashtable、java.util.concurrent 包</p>
<ul>
<li><p>线程安全的是指，多个线程调用它们同一个实例的某个方法时，是线程安全的</p>
</li>
<li><p><strong>每个方法是原子的，但多个方法的组合不是原子的</strong>，只能保证调用的方法内部安全：</p>
<p>  Hashtable table &#x3D; new Hashtable();<br>  &#x2F;&#x2F; 线程1，线程2<br>  if(table.get(“key”) &#x3D;&#x3D; null) {<br>  table.put(“key”, value);<br>  }</p>
</li>
</ul>
<p>无状态类线程安全，就是没有成员变量的类</p>
<p>不可变类线程安全：String、Integer 等都是不可变类，<strong>内部的状态不可以改变</strong>，所以方法是线程安全</p>
<ul>
<li><p>replace 等方法底层是新建一个对象，复制过去</p>
<p>  Map&lt;String,Object&gt; map &#x3D; new HashMap&lt;&gt;();	&#x2F;&#x2F; 线程不安全<br>  String S1 &#x3D; “…”;							&#x2F;&#x2F; 线程安全<br>  final String S2 &#x3D; “…”;					&#x2F;&#x2F; 线程安全<br>  Date D1 &#x3D; new Date();						&#x2F;&#x2F; 线程不安全<br>  final Date D2 &#x3D; new Date();					&#x2F;&#x2F; 线程不安全，final让D2引用的对象不能变，但对象的内容可以变</p>
</li>
</ul>
<p>抽象方法如果有参数，被重写后行为不确定可能造成线程不安全，被称之为外星方法：<code>public abstract foo(Student s);</code></p>
<hr>
<h3 id="同步模式"><a href="#同步模式" class="headerlink" title="同步模式"></a>同步模式</h3><h4 id="保护性暂停"><a href="#保护性暂停" class="headerlink" title="保护性暂停"></a>保护性暂停</h4><h5 id="单任务版"><a href="#单任务版" class="headerlink" title="单任务版"></a>单任务版</h5><p>Guarded Suspension，用在一个线程等待另一个线程的执行结果</p>
<ul>
<li><p>有一个结果需要从一个线程传递到另一个线程，让它们关联同一个 GuardedObject</p>
</li>
<li><p>如果有结果不断从一个线程到另一个线程那么可以使用消息队列（见生产者&#x2F;消费者）</p>
</li>
<li><p>JDK 中，join 的实现、Future 的实现，采用的就是此模式</p>
</li>
</ul>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041627568.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    <span class="hljs-type">GuardedObject</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GuardedObjectV2</span>();  <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>        sleep(<span class="hljs-number">1</span>);  <br>        object.complete(Arrays.asList(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>));  <br>    &#125;).start();  <br>      <br>    <span class="hljs-type">Object</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> object.get(<span class="hljs-number">2500</span>);  <br>    <span class="hljs-keyword">if</span> (response != <span class="hljs-literal">null</span>) &#123;  <br>        log.debug(<span class="hljs-string">&quot;get response: [&#123;&#125;] lines&quot;</span>, ((List&lt;String&gt;) response).size());  <br>    &#125; <span class="hljs-keyword">else</span> &#123;  <br>        log.debug(<span class="hljs-string">&quot;can&#x27;t get response&quot;</span>);  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GuardedObject</span> &#123;  <br>    <span class="hljs-keyword">private</span> Object response;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();  <br>  <br>    <span class="hljs-comment">//获取结果  </span><br>    <span class="hljs-comment">//timeout :最大等待时间  </span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> millis)</span> &#123;  <br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;  <br>            <span class="hljs-comment">// 1) 记录最初时间  </span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> System.currentTimeMillis();  <br>            <span class="hljs-comment">// 2) 已经经历的时间  </span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">timePassed</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br>            <span class="hljs-keyword">while</span> (response == <span class="hljs-literal">null</span>) &#123;  <br>                <span class="hljs-comment">// 4) 假设 millis 是 1000，结果在 400 时唤醒了，那么还有 600 要等  </span><br>                <span class="hljs-type">long</span> <span class="hljs-variable">waitTime</span> <span class="hljs-operator">=</span> millis - timePassed;  <br>                log.debug(<span class="hljs-string">&quot;waitTime: &#123;&#125;&quot;</span>, waitTime);  <br>                <span class="hljs-comment">//经历时间超过最大等待时间退出循环  </span><br>                <span class="hljs-keyword">if</span> (waitTime &lt;= <span class="hljs-number">0</span>) &#123;  <br>                    log.debug(<span class="hljs-string">&quot;break...&quot;</span>);  <br>                    <span class="hljs-keyword">break</span>;  <br>                &#125;  <br>                <span class="hljs-keyword">try</span> &#123;  <br>                    lock.wait(waitTime);  <br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>                    e.printStackTrace();  <br>                &#125;  <br>                <span class="hljs-comment">// 3) 如果提前被唤醒，这时已经经历的时间假设为 400  </span><br>                timePassed = System.currentTimeMillis() - begin;  <br>                log.debug(<span class="hljs-string">&quot;timePassed: &#123;&#125;, object is null &#123;&#125;&quot;</span>,  <br>                        timePassed, response == <span class="hljs-literal">null</span>);  <br>            &#125;  <br>            <span class="hljs-keyword">return</span> response;  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//产生结果  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">complete</span><span class="hljs-params">(Object response)</span> &#123;  <br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;  <br>            <span class="hljs-comment">// 条件满足，通知等待线程  </span><br>            <span class="hljs-built_in">this</span>.response = response;  <br>            log.debug(<span class="hljs-string">&quot;notify...&quot;</span>);  <br>            lock.notifyAll();  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="多任务版"><a href="#多任务版" class="headerlink" title="多任务版"></a>多任务版</h5><p>多任务版保护性暂停：</p>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041627603.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;  <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">People</span>().start();  <br>    &#125;  <br>    Thread.sleep(<span class="hljs-number">1000</span>);  <br>    <span class="hljs-keyword">for</span> (Integer id : Mailboxes.getIds()) &#123;  <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Postman</span>(id, id + <span class="hljs-string">&quot;号快递到了&quot;</span>).start();  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-meta">@Slf4j(topic = &quot;c.People&quot;)</span>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-comment">// 收信  </span><br>        <span class="hljs-type">GuardedObject</span> <span class="hljs-variable">guardedObject</span> <span class="hljs-operator">=</span> Mailboxes.createGuardedObject();  <br>        log.debug(<span class="hljs-string">&quot;开始收信i d:&#123;&#125;&quot;</span>, guardedObject.getId());  <br>        <span class="hljs-type">Object</span> <span class="hljs-variable">mail</span> <span class="hljs-operator">=</span> guardedObject.get(<span class="hljs-number">5000</span>);  <br>        log.debug(<span class="hljs-string">&quot;收到信id:&#123;&#125;，内容:&#123;&#125;&quot;</span>, guardedObject.getId(),mail);  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Postman</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;  <br>    <span class="hljs-keyword">private</span> String mail;  <br>    <span class="hljs-comment">//构造方法  </span><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-type">GuardedObject</span> <span class="hljs-variable">guardedObject</span> <span class="hljs-operator">=</span> Mailboxes.getGuardedObject(id);  <br>        log.debug(<span class="hljs-string">&quot;开始送信i d:&#123;&#125;，内容:&#123;&#125;&quot;</span>, guardedObject.getId(),mail);  <br>        guardedObject.complete(mail);  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-keyword">class</span>  <span class="hljs-title class_">Mailboxes</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;Integer, GuardedObject&gt; boxes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hashtable</span>&lt;&gt;();  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;  <br>  <br>    <span class="hljs-comment">//产生唯一的id  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">int</span> <span class="hljs-title function_">generateId</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> id++;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GuardedObject <span class="hljs-title function_">getGuardedObject</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;  <br>        <span class="hljs-keyword">return</span> boxes.remove(id);  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GuardedObject <span class="hljs-title function_">createGuardedObject</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-type">GuardedObject</span> <span class="hljs-variable">go</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GuardedObject</span>(generateId());  <br>        boxes.put(go.getId(), go);  <br>        <span class="hljs-keyword">return</span> go;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Set&lt;Integer&gt; <span class="hljs-title function_">getIds</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> boxes.keySet();  <br>    &#125;  <br>&#125;  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GuardedObject</span> &#123;  <br>    <span class="hljs-comment">//标识，Guarded Object  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<span class="hljs-comment">//添加get set方法  </span><br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="顺序输出"><a href="#顺序输出" class="headerlink" title="顺序输出"></a>顺序输出</h4><p>顺序输出 2 1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;  <br>            <span class="hljs-comment">//try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; &#125;  </span><br>            <span class="hljs-comment">// 当没有许可时，当前线程暂停运行；有许可时，用掉这个许可，当前线程恢复运行  </span><br>            LockSupport.park();  <br>            System.out.println(<span class="hljs-string">&quot;1&quot;</span>);  <br>        &#125;  <br>    &#125;);  <br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;  <br>            System.out.println(<span class="hljs-string">&quot;2&quot;</span>);  <br>            <span class="hljs-comment">// 给线程 t1 发放『许可』（多次连续调用 unpark 只会发放一个『许可』）  </span><br>            LockSupport.unpark(t1);  <br>            <span class="hljs-keyword">try</span> &#123; Thread.sleep(<span class="hljs-number">500</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; &#125;  <br>        &#125;  <br>    &#125;);  <br>    t1.start();  <br>    t2.start();  <br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="交替输出"><a href="#交替输出" class="headerlink" title="交替输出"></a>交替输出</h4><p>连续输出 5 次 abc</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">day2_14</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>        <span class="hljs-type">AwaitSignal</span> <span class="hljs-variable">awaitSignal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AwaitSignal</span>(<span class="hljs-number">5</span>);  <br>        <span class="hljs-type">Condition</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> awaitSignal.newCondition();  <br>        <span class="hljs-type">Condition</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> awaitSignal.newCondition();  <br>        <span class="hljs-type">Condition</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> awaitSignal.newCondition();  <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>            awaitSignal.print(<span class="hljs-string">&quot;a&quot;</span>, a, b);  <br>        &#125;).start();  <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>            awaitSignal.print(<span class="hljs-string">&quot;b&quot;</span>, b, c);  <br>        &#125;).start();  <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>            awaitSignal.print(<span class="hljs-string">&quot;c&quot;</span>, c, a);  <br>        &#125;).start();  <br>  <br>        Thread.sleep(<span class="hljs-number">1000</span>);  <br>        awaitSignal.lock();  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            a.signal();  <br>        &#125; <span class="hljs-keyword">finally</span> &#123;  <br>            awaitSignal.unlock();  <br>        &#125;  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AwaitSignal</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ReentrantLock</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> loopNumber;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AwaitSignal</span><span class="hljs-params">(<span class="hljs-type">int</span> loopNumber)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.loopNumber = loopNumber;  <br>    &#125;  <br>    <span class="hljs-comment">//参数1：打印内容  参数二：条件变量  参数二：唤醒下一个  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(String str, Condition condition, Condition next)</span> &#123;  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;  <br>            lock();  <br>            <span class="hljs-keyword">try</span> &#123;  <br>                condition.await();  <br>                System.out.print(str);  <br>                next.signal();  <br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>                e.printStackTrace();  <br>            &#125; <span class="hljs-keyword">finally</span> &#123;  <br>                unlock();  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="异步模式"><a href="#异步模式" class="headerlink" title="异步模式"></a>异步模式</h3><h4 id="传统版"><a href="#传统版" class="headerlink" title="传统版"></a>传统版</h4><p>异步模式之生产者&#x2F;消费者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ShareData</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">condition</span> <span class="hljs-operator">=</span> lock.newCondition();  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;  <br>        <span class="hljs-comment">// 同步代码块，加锁  </span><br>        lock.lock();  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            <span class="hljs-comment">// 判断  防止虚假唤醒  </span><br>            <span class="hljs-keyword">while</span>(number != <span class="hljs-number">0</span>) &#123;  <br>                <span class="hljs-comment">// 等待不能生产  </span><br>                condition.await();  <br>            &#125;  <br>            <span class="hljs-comment">// 干活  </span><br>            number++;  <br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t &quot;</span> + number);  <br>            <span class="hljs-comment">// 通知 唤醒  </span><br>            condition.signalAll();  <br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;  <br>            e.printStackTrace();  <br>        &#125; <span class="hljs-keyword">finally</span> &#123;  <br>            lock.unlock();  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decrement</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;  <br>        <span class="hljs-comment">// 同步代码块，加锁  </span><br>        lock.lock();  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            <span class="hljs-comment">// 判断 防止虚假唤醒  </span><br>            <span class="hljs-keyword">while</span>(number == <span class="hljs-number">0</span>) &#123;  <br>                <span class="hljs-comment">// 等待不能消费  </span><br>                condition.await();  <br>            &#125;  <br>            <span class="hljs-comment">// 干活  </span><br>            number--;  <br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t &quot;</span> + number);  <br>            <span class="hljs-comment">// 通知 唤醒  </span><br>            condition.signalAll();  <br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;  <br>            e.printStackTrace();  <br>        &#125; <span class="hljs-keyword">finally</span> &#123;  <br>            lock.unlock();  <br>        &#125;  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TraditionalProducerConsumer</span> &#123;  <br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">ShareData</span> <span class="hljs-variable">shareData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ShareData</span>();  <br>        <span class="hljs-comment">// t1线程，生产  </span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;  <br>            	shareData.increment();  <br>            &#125;  <br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();  <br>  <br>        <span class="hljs-comment">// t2线程，消费  </span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;  <br>				shareData.decrement();  <br>            &#125;  <br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();   <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="改进版"><a href="#改进版" class="headerlink" title="改进版"></a>改进版</h4><p>异步模式之生产者&#x2F;消费者：</p>
<ul>
<li><p>消费队列可以用来平衡生产和消费的线程资源，不需要产生结果和消费结果的线程一一对应</p>
</li>
<li><p>生产者仅负责产生结果数据，不关心数据该如何处理，而消费者专心处理结果数据</p>
</li>
<li><p>消息队列是有容量限制的，满时不会再加入数据，空时不会再消耗数据</p>
</li>
<li><p>JDK 中各种阻塞队列，采用的就是这种模式</p>
</li>
</ul>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041627710.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">demo</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">MessageQueue</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageQueue</span>(<span class="hljs-number">2</span>);  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;  <br>            <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> i;  <br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>                queue.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(id,<span class="hljs-string">&quot;值&quot;</span>+id));  <br>            &#125;, <span class="hljs-string">&quot;生产者&quot;</span> + i).start();  <br>        &#125;  <br>          <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;  <br>                <span class="hljs-keyword">try</span> &#123;  <br>                    Thread.sleep(<span class="hljs-number">1000</span>);  <br>                    <span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> queue.take();  <br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>                    e.printStackTrace();  <br>                &#125;  <br>            &#125;  <br>        &#125;,<span class="hljs-string">&quot;消费者&quot;</span>).start();  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-comment">//消息队列类，Java间线程之间通信  </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageQueue</span> &#123;  <br>    <span class="hljs-keyword">private</span> LinkedList&lt;Message&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<span class="hljs-comment">//消息的队列集合  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capacity;<span class="hljs-comment">//队列容量  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MessageQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.capacity = capacity;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//获取消息  </span><br>    <span class="hljs-keyword">public</span> Message <span class="hljs-title function_">take</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-comment">//检查队列是否为空  </span><br>        <span class="hljs-keyword">synchronized</span> (list) &#123;  <br>            <span class="hljs-keyword">while</span> (list.isEmpty()) &#123;  <br>                <span class="hljs-keyword">try</span> &#123;  <br>                    sout(Thread.currentThread().getName() + <span class="hljs-string">&quot;:队列为空，消费者线程等待&quot;</span>);  <br>                    list.wait();  <br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>                    e.printStackTrace();  <br>                &#125;  <br>            &#125;  <br>            <span class="hljs-comment">//从队列的头部获取消息返回  </span><br>            <span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> list.removeFirst();  <br>            sout(Thread.currentThread().getName() + <span class="hljs-string">&quot;：已消费消息--&quot;</span> + message);  <br>            list.notifyAll();  <br>            <span class="hljs-keyword">return</span> message;  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//存入消息  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(Message message)</span> &#123;  <br>        <span class="hljs-keyword">synchronized</span> (list) &#123;  <br>            <span class="hljs-comment">//检查队列是否满  </span><br>            <span class="hljs-keyword">while</span> (list.size() == capacity) &#123;  <br>                <span class="hljs-keyword">try</span> &#123;  <br>                    sout(Thread.currentThread().getName()+<span class="hljs-string">&quot;:队列为已满，生产者线程等待&quot;</span>);  <br>                    list.wait();  <br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>                    e.printStackTrace();  <br>                &#125;  <br>            &#125;  <br>            <span class="hljs-comment">//将消息加入队列尾部  </span><br>            list.addLast(message);  <br>            sout(Thread.currentThread().getName() + <span class="hljs-string">&quot;:已生产消息--&quot;</span> + message);  <br>            list.notifyAll();  <br>        &#125;  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Message</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;  <br>    <span class="hljs-keyword">private</span> Object value;  <br>	<span class="hljs-comment">//get set  </span><br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">1</span>);  <br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">producer</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">1</span>);  <br>    BlockingQueue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;&gt;();  <br>    producer.submit(() -&gt; &#123;  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            System.out.println(<span class="hljs-string">&quot;生产...&quot;</span>);  <br>            Thread.sleep(<span class="hljs-number">1000</span>);  <br>            queue.put(<span class="hljs-number">10</span>);  <br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>            e.printStackTrace();  <br>        &#125;  <br>    &#125;);  <br>    consumer.submit(() -&gt; &#123;  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            System.out.println(<span class="hljs-string">&quot;等待消费...&quot;</span>);  <br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> queue.take();  <br>            System.out.println(<span class="hljs-string">&quot;结果为:&quot;</span> + result);  <br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>            e.printStackTrace();  <br>        &#125;  <br>    &#125;);  <br>&#125;<br></code></pre></td></tr></table></figure>

<hr>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="category-chain-item">多线程</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%B9%B6%E5%8F%91/">#并发</a>
      
        <a href="/tags/%E5%B9%B6%E8%A1%8C/">#并行</a>
      
        <a href="/tags/%E5%90%8C%E6%AD%A5/">#同步</a>
      
        <a href="/tags/%E5%BC%82%E6%AD%A5/">#异步</a>
      
        <a href="/tags/%E4%BA%92%E6%96%A5/">#互斥</a>
      
        <a href="/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/">#线程安全</a>
      
        <a href="/tags/%E6%82%B2%E8%A7%82%E9%94%81/">#悲观锁</a>
      
        <a href="/tags/%E4%B9%90%E8%A7%82%E9%94%81/">#乐观锁</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>关于并发编程（上）</div>
      <div>https://blog.13space.cn/posts/6aabc494/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>拾叁</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>May 2, 2019</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/posts/a4f048b3/" title="关于并发编程（下）">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">关于并发编程（下）</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/posts/bd826a18/" title="重拾设计模式（三）">
                        <span class="hidden-mobile">重拾设计模式（三）</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="twikoo"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/twikoo/1.6.8/twikoo.all.min.js', function() {
        var options = Object.assign(
          {"envId":"https://hexo-blog-twikoo-flame.vercel.app/","region":"ap-shanghai","path":"window.location.pathname"},
          {
            el: '#twikoo',
            path: 'window.location.pathname',
            onCommentLoaded: function() {
              var imgSelector = '#twikoo .tk-content img:not(.tk-owo-emotion)';
              Fluid.plugins.imageCaption(imgSelector);
              Fluid.plugins.fancyBox(imgSelector);
            }
          }
        )
        twikoo.init(options)
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> </br>拾叁的小破站，欢迎浏览啊~</br> <div style="font-size: 0.85rem"> <span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span> <script src="/js/duration.js"></script> </div> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        Views: 
        <span id="busuanzi_value_site_pv"></span>
        
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        Visitors: 
        <span id="busuanzi_value_site_uv"></span>
        
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
