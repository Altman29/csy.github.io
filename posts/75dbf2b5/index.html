

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="拾叁">
  <meta name="keywords" content="redis">
  
    <meta name="description" content="本文将带您深入了解Redis分布式缓存的内部机制和应用场景。通过探索Redis的数据结构、主从复制、分片和集群等关键概念，您将了解如何构建可靠的分布式缓存系统，并优化性能以满足不断增长的数据处理需求。更好地利用Redis提升应用程序的效率和可扩展性。">
<meta property="og:type" content="article">
<meta property="og:title" content="redis-分布式缓存">
<meta property="og:url" content="https://blog.13space.cn/posts/75dbf2b5/index.html">
<meta property="og:site_name" content="拾叁的小破站">
<meta property="og:description" content="本文将带您深入了解Redis分布式缓存的内部机制和应用场景。通过探索Redis的数据结构、主从复制、分片和集群等关键概念，您将了解如何构建可靠的分布式缓存系统，并优化性能以满足不断增长的数据处理需求。更好地利用Redis提升应用程序的效率和可扩展性。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://blog.13space.cn/img/micro/r1.jpg">
<meta property="article:published_time" content="2022-01-22T09:41:51.000Z">
<meta property="article:modified_time" content="2024-03-23T05:15:53.662Z">
<meta property="article:author" content="拾叁">
<meta property="article:tag" content="redis">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://blog.13space.cn/img/micro/r1.jpg">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>redis-分布式缓存 - 拾叁的小破站</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"blog.13space.cn","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":100,"cursorChar":"*","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  

  

  



  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>拾叁 | space</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>时间轴</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/remark/">
                <i class="iconfont icon-speakernotes"></i>
                <span>留言板</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                <span>Links</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/home_bg.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="redis-分布式缓存"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        拾叁
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-01-22 17:41" pubdate>
          January 22, 2022 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          15k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          122 mins
        
      </span>
    

    
    
  </div>


<script src="/js/custom-iconfont.js?v=" ></script>

        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">redis-分布式缓存</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="单机Redis问题"><a href="#单机Redis问题" class="headerlink" title="单机Redis问题"></a>单机Redis问题</h1><p>单机的Redis存在四大问题：</p>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231027998.png" srcset="/img/loading.gif" lazyload></p>
<p class="note note-primary">所以，掌握分布式缓存是一种必备的技能。</p>

<h1 id="redis持久化"><a href="#redis持久化" class="headerlink" title="redis持久化"></a>redis持久化</h1><p>Redis有两种持久化方案：</p>
<ul>
<li><p>RDB持久化</p>
</li>
<li><p>AOF持久化</p>
</li>
</ul>
<h2 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h2><p>RDB全称Redis Database Backup file（Redis数据备份文件），也被叫做Redis数据快照。简单来说就是把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。快照文件称为RDB文件，默认是保存在当前运行目录。</p>
<h3 id="执行时机"><a href="#执行时机" class="headerlink" title="执行时机"></a>执行时机</h3><p>RDB持久化在四种情况下会执行：</p>
<ul>
<li><p>执行save命令</p>
</li>
<li><p>执行bgsave命令</p>
</li>
<li><p>Redis停机时</p>
</li>
<li><p>触发RDB条件时</p>
</li>
</ul>
<p><strong>1）save命令</strong></p>
<p>执行下面的命令，可以立即执行一次RDB：</p>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231035635.png" srcset="/img/loading.gif" lazyload></p>
<p><code>save</code>命令会导致主进程执行RDB，这个过程中其它所有命令都会被阻塞。只有在数据迁移时可能用到。</p>
<p><strong>2）bgsave命令</strong></p>
<p>下面的命令可以<strong>异步</strong>执行RDB：</p>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231036151.png" srcset="/img/loading.gif" lazyload></p>
<p>这个命令执行后会开启独立进程完成RDB，主进程可以持续处理用户请求，不受影响。</p>
<p><strong>3）停机时</strong></p>
<p>Redis停机时会执行一次save命令，实现RDB持久化。</p>
<p><strong>4）触发RDB条件</strong></p>
<p>Redis内部有触发RDB的机制，可以在redis.conf文件中找到，格式如下：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 900秒内，如果至少有1个key被修改，则执行bgsave ; 如果是save &quot;&quot; 则表示禁用RDB</span><br><span class="hljs-attr">save</span> <span class="hljs-string">900 1  </span><br><span class="hljs-attr">save</span> <span class="hljs-string">300 10  </span><br><span class="hljs-attr">save</span> <span class="hljs-string">60 10000 </span><br></code></pre></td></tr></table></figure>

<p>RDB的其它配置也可以在redis.conf文件中设置：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 是否压缩 ,建议不开启，压缩也会消耗cpu，磁盘的话不值钱</span><br><span class="hljs-attr">rdbcompression</span> <span class="hljs-string">yes</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># RDB文件名称</span><br><span class="hljs-attr">dbfilename</span> <span class="hljs-string">dump.rdb  </span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 文件保存的路径目录</span><br><span class="hljs-attr">dir</span> <span class="hljs-string">./ </span><br></code></pre></td></tr></table></figure>

<h3 id="RDB原理"><a href="#RDB原理" class="headerlink" title="RDB原理"></a>RDB原理</h3><p>bgsave开始时会fork主进程得到子进程，子进程共享主进程的内存数据。完成fork后读取内存数据并写入 RDB 文件。</p>
<p>fork采用的是copy-on-write技术：</p>
<ul>
<li><p>当主进程执行读操作时，访问共享内存；</p>
</li>
<li><p>当主进程执行写操作时，则会拷贝一份数据，执行写操作。</p>
</li>
</ul>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231048414.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>RDB方式bgsave的基本流程？</p>
<ul>
<li><p>fork主进程得到一个子进程，共享内存空间</p>
</li>
<li><p>子进程读取内存数据并写入新的RDB文件</p>
</li>
<li><p>用新RDB文件替换旧的RDB文件</p>
</li>
</ul>
<p>RDB会在什么时候执行？save 60 1000代表什么含义？</p>
<ul>
<li><p>默认是服务停止时</p>
</li>
<li><p>代表60秒内至少执行1000次修改则触发RDB</p>
</li>
</ul>
<p>RDB的缺点？</p>
<ul>
<li><p>RDB执行间隔时间长，两次RDB之间写入数据有丢失的风险</p>
</li>
<li><p>fork子进程、压缩、写出RDB文件都比较耗时</p>
</li>
</ul>
<h2 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h2><h3 id="AOF原理"><a href="#AOF原理" class="headerlink" title="AOF原理"></a>AOF原理</h3><p>AOF全称为Append Only File（追加文件）。Redis处理的每一个写命令都会记录在AOF文件，可以看做是命令日志文件。</p>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231050397.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="AOF配置"><a href="#AOF配置" class="headerlink" title="AOF配置"></a>AOF配置</h3><p>AOF默认是关闭的，需要修改redis.conf配置文件来开启AOF：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 是否开启AOF功能，默认是no</span><br><span class="hljs-attr">appendonly</span> <span class="hljs-string">yes</span><br><span class="hljs-comment"># AOF文件的名称</span><br><span class="hljs-attr">appendfilename</span> <span class="hljs-string">&quot;appendonly.aof&quot;</span><br></code></pre></td></tr></table></figure>

<p>AOF的命令记录的频率也可以通过redis.conf文件来配：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 表示每执行一次写命令，立即记录到AOF文件</span><br><span class="hljs-attr">appendfsync</span> <span class="hljs-string">always </span><br><span class="hljs-comment"># 写命令执行完先放入AOF缓冲区，然后表示每隔1秒将缓冲区数据写到AOF文件，是默认方案</span><br><span class="hljs-attr">appendfsync</span> <span class="hljs-string">everysec </span><br><span class="hljs-comment"># 写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘</span><br><span class="hljs-attr">appendfsync</span> <span class="hljs-string">no</span><br></code></pre></td></tr></table></figure>

<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231051257.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="AOF文件重写"><a href="#AOF文件重写" class="headerlink" title="AOF文件重写"></a>AOF文件重写</h3><p>因为是记录命令，AOF文件会比RDB文件大的多。而且AOF会记录对同一个key的多次写操作，但只有最后一次写操作才有意义。通过执行<code>bgrewriteaof</code>命令，可以让AOF文件执行重写功能，用最少的命令达到相同效果。</p>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231052679.png" srcset="/img/loading.gif" lazyload></p>
<p>如图，AOF原本有三个命令，但是<code>set num 123 和 set num 666</code>都是对num的操作，第二次会覆盖第一次的值，因此第一个命令记录下来没有意义。</p>
<p>所以重写命令后，AOF文件内容就是：<code>mset name jack num 666</code></p>
<p>Redis也会在触发阈值时自动去重写AOF文件。阈值也可以在redis.conf中配置：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># AOF文件比上次文件 增长超过多少百分比则触发重写</span><br><span class="hljs-attr">auto-aof-rewrite-percentage</span> <span class="hljs-string">100</span><br><span class="hljs-comment"># AOF文件体积最小多大以上才触发重写 </span><br><span class="hljs-attr">auto-aof-rewrite-min-size</span> <span class="hljs-string">64mb </span><br></code></pre></td></tr></table></figure>

<h2 id="RDB与AOF对比"><a href="#RDB与AOF对比" class="headerlink" title="RDB与AOF对比"></a>RDB与AOF对比</h2><p>RDB和AOF各有自己的优缺点，如果对数据安全性要求较高，在实际开发中往往会<strong>结合</strong>两者来使用。</p>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231054380.png" srcset="/img/loading.gif" lazyload></p>
<h1 id="Redis主从"><a href="#Redis主从" class="headerlink" title="Redis主从"></a>Redis主从</h1><h2 id="搭建主从架构"><a href="#搭建主从架构" class="headerlink" title="搭建主从架构"></a>搭建主从架构</h2><p>单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离。</p>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231055000.png" srcset="/img/loading.gif" lazyload></p>
<p>共包含三个节点，一个主节点，两个从节点。</p>
<p>这里我们会在同一台虚拟机中开启3个redis实例，模拟主从集群，信息如下：</p>
<table>
<thead>
<tr>
<th>IP</th>
<th>PORT</th>
<th>角色</th>
</tr>
</thead>
<tbody><tr>
<td>192.168.150.101</td>
<td>7001</td>
<td>master</td>
</tr>
<tr>
<td>192.168.150.101</td>
<td>7002</td>
<td>slave</td>
</tr>
<tr>
<td>192.168.150.101</td>
<td>7003</td>
<td>slave</td>
</tr>
</tbody></table>
<h3 id="准备实例和配置"><a href="#准备实例和配置" class="headerlink" title="准备实例和配置"></a>准备实例和配置</h3><p>要在同一台虚拟机开启3个实例，必须准备三份不同的配置文件和目录，配置文件所在目录也就是工作目录。</p>
<p>1）创建目录</p>
<p>我们创建三个文件夹，名字分别叫7001、7002、7003：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 进入/tmp目录</span><br><span class="hljs-built_in">cd</span> /tmp<br><span class="hljs-comment"># 创建目录</span><br><span class="hljs-built_in">mkdir</span> 7001 7002 7003<br></code></pre></td></tr></table></figure>

<p>如图：</p>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231058832.png" srcset="/img/loading.gif" lazyload></p>
<p>2）恢复原始配置</p>
<p>修改redis-6.2.4&#x2F;redis.conf文件，将其中的持久化模式改为默认的RDB模式，AOF保持关闭状态。</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 开启RDB</span><br><span class="hljs-comment"># save &quot;&quot;</span><br><span class="hljs-attr">save</span> <span class="hljs-string">3600 1</span><br><span class="hljs-attr">save</span> <span class="hljs-string">300 100</span><br><span class="hljs-attr">save</span> <span class="hljs-string">60 10000</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 关闭AOF</span><br><span class="hljs-attr">appendonly</span> <span class="hljs-string">no</span><br></code></pre></td></tr></table></figure>

<p>3）拷贝配置文件到每个实例目录</p>
<p>然后将redis-6.2.4&#x2F;redis.conf文件拷贝到三个目录中（在&#x2F;tmp目录执行下列命令）：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 方式一：逐个拷贝</span><br><span class="hljs-built_in">cp</span> redis-6.2.4/redis.conf 7001<br><span class="hljs-built_in">cp</span> redis-6.2.4/redis.conf 7002<br><span class="hljs-built_in">cp</span> redis-6.2.4/redis.conf 7003<br><br><span class="hljs-comment"># 方式二：管道组合命令，一键拷贝</span><br><span class="hljs-built_in">echo</span> 7001 7002 7003 | xargs -t -n 1 <span class="hljs-built_in">cp</span> redis-6.2.4/redis.conf<br></code></pre></td></tr></table></figure>

<p>4）修改每个实例的端口、工作目录</p>
<p>修改每个文件夹内的配置文件，将端口分别修改为7001、7002、7003，将rdb文件保存位置都修改为自己所在目录（在&#x2F;tmp目录执行下列命令）：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">sed -i -e <span class="hljs-string">&#x27;s/6379/7001/g&#x27;</span> -e <span class="hljs-string">&#x27;s/dir .\//dir \/tmp\/7001\//g&#x27;</span> 7001/redis.conf<br>sed -i -e <span class="hljs-string">&#x27;s/6379/7002/g&#x27;</span> -e <span class="hljs-string">&#x27;s/dir .\//dir \/tmp\/7002\//g&#x27;</span> 7002/redis.conf<br>sed -i -e <span class="hljs-string">&#x27;s/6379/7003/g&#x27;</span> -e <span class="hljs-string">&#x27;s/dir .\//dir \/tmp\/7003\//g&#x27;</span> 7003/redis.conf<br></code></pre></td></tr></table></figure>

<p>5）修改每个实例的声明IP</p>
<p>虚拟机本身有多个IP，为了避免将来混乱，我们需要在redis.conf文件中指定每一个实例的绑定ip信息，格式如下：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># redis实例的声明 IP</span><br><span class="hljs-attr">replica-announce-ip</span> <span class="hljs-string">192.168.150.101</span><br></code></pre></td></tr></table></figure>

<p>每个目录都要改，我们一键完成修改（在&#x2F;tmp目录执行下列命令）：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 逐一执行</span><br>sed -i <span class="hljs-string">&#x27;1a replica-announce-ip 192.168.150.101&#x27;</span> 7001/redis.conf<br>sed -i <span class="hljs-string">&#x27;1a replica-announce-ip 192.168.150.101&#x27;</span> 7002/redis.conf<br>sed -i <span class="hljs-string">&#x27;1a replica-announce-ip 192.168.150.101&#x27;</span> 7003/redis.conf<br><br><span class="hljs-comment"># 或者一键修改</span><br><span class="hljs-built_in">printf</span> <span class="hljs-string">&#x27;%s\n&#x27;</span> 7001 7002 7003 | xargs -I&#123;&#125; -t sed -i <span class="hljs-string">&#x27;1a replica-announce-ip 192.168.150.101&#x27;</span> &#123;&#125;/redis.conf<br></code></pre></td></tr></table></figure>

<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>为了方便查看日志，我们打开3个ssh窗口，分别启动3个redis实例，启动命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 第1个</span><br>redis-server 7001/redis.conf<br><span class="hljs-comment"># 第2个</span><br>redis-server 7002/redis.conf<br><span class="hljs-comment"># 第3个</span><br>redis-server 7003/redis.conf<br></code></pre></td></tr></table></figure>

<p>启动后：</p>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231101656.png" srcset="/img/loading.gif" lazyload></p>
<p>如果要一键停止，可以运行下面命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">printf</span> <span class="hljs-string">&#x27;%s\n&#x27;</span> 7001 7002 7003 | xargs -I&#123;&#125; -t redis-cli -p &#123;&#125; shutdown<br></code></pre></td></tr></table></figure>

<h3 id="开启主从关系"><a href="#开启主从关系" class="headerlink" title="开启主从关系"></a>开启主从关系</h3><p>现在三个实例还没有任何关系，要配置主从可以使用replicaof 或者slaveof（5.0以前）命令。</p>
<p>有临时和永久两种模式：</p>
<ul>
<li><p>修改配置文件（永久生效）</p>
<ul>
<li>在redis.conf中添加一行配置：<code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code></li>
</ul>
</li>
<li><p>使用redis-cli客户端连接到redis服务，执行slaveof命令（重启后失效）：</p>
</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">slaveof &lt;masterip&gt; &lt;masterport&gt;<br></code></pre></td></tr></table></figure>

<p><strong>注意</strong>：在5.0以后新增命令replicaof，与salveof效果一致。</p>
<p>这里我们为了演示方便，使用方式二。</p>
<p>通过redis-cli命令连接7002，执行下面命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 连接 7002</span><br>redis-cli -p 7002<br><span class="hljs-comment"># 执行slaveof</span><br>slaveof 192.168.150.101 7001<br></code></pre></td></tr></table></figure>

<p>通过redis-cli命令连接7003，执行下面命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 连接 7003</span><br>redis-cli -p 7003<br><span class="hljs-comment"># 执行slaveof</span><br>slaveof 192.168.150.101 7001<br></code></pre></td></tr></table></figure>

<p>然后连接 7001节点，查看集群状态：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 连接 7001</span><br>redis-cli -p 7001<br><span class="hljs-comment"># 查看状态</span><br>info replication<br></code></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231103515.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>执行下列操作以测试：</p>
<ul>
<li><p>利用redis-cli连接7001，执行<code>set num 123</code></p>
</li>
<li><p>利用redis-cli连接7002，执行<code>get num</code>，再执行<code>set num 666</code></p>
</li>
<li><p>利用redis-cli连接7003，执行<code>get num</code>，再执行<code>set num 888</code></p>
</li>
</ul>
<p>可以发现，只有在7001这个master节点上可以执行写操作，7002和7003这两个slave节点只能执行读操作。</p>
<h2 id="主从数据同步原理"><a href="#主从数据同步原理" class="headerlink" title="主从数据同步原理"></a>主从数据同步原理</h2><h3 id="全量同步"><a href="#全量同步" class="headerlink" title="全量同步"></a>全量同步</h3><p>主从第一次建立连接时，会执行<strong>全量同步</strong>，将master节点的所有数据都拷贝给slave节点，流程：</p>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231104444.png" srcset="/img/loading.gif" lazyload><br>这里有一个问题，master如何得知salve是第一次来连接呢？？</p>
<p>有几个概念，可以作为判断依据：</p>
<ul>
<li><p><strong>Replication Id</strong>：简称replid，是数据集的标记，id一致则说明是同一数据集。每一个master都有唯一的replid，slave则会继承master节点的replid</p>
</li>
<li><p><strong>offset</strong>：偏移量，随着记录在repl_baklog中的数据增多而逐渐增大。slave完成同步时也会记录当前同步的offset。如果slave的offset小于master的offset，说明slave数据落后于master，需要更新。</p>
</li>
</ul>
<p>因此slave做数据同步，必须向master声明自己的replication id 和offset，master才可以判断到底需要同步哪些数据。</p>
<p>因为slave原本也是一个master，有自己的replid和offset，当第一次变成slave，与master建立连接时，发送的replid和offset是自己的replid和offset。</p>
<p>master判断发现slave发送来的replid与自己的不一致，说明这是一个全新的slave，就知道要做全量同步了。</p>
<p>master会将自己的replid和offset都发送给这个slave，slave保存这些信息。以后slave的replid就与master一致了。</p>
<p>因此，<strong>master判断一个节点是否是第一次同步的依据，就是看replid是否一致</strong>。</p>
<p>如图：</p>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231105079.png" srcset="/img/loading.gif" lazyload></p>
<p>完整流程描述：</p>
<ul>
<li><p>slave节点请求增量同步</p>
</li>
<li><p>master节点判断replid，发现不一致，拒绝增量同步</p>
</li>
<li><p>master将完整内存数据生成RDB，发送RDB到slave</p>
</li>
<li><p>slave清空本地数据，加载master的RDB</p>
</li>
<li><p>master将RDB期间的命令记录在repl_baklog，并持续将log中的命令发送给slave</p>
</li>
<li><p>slave执行接收到的命令，保持与master之间的同步</p>
</li>
</ul>
<h3 id="增量同步"><a href="#增量同步" class="headerlink" title="增量同步"></a>增量同步</h3><p>全量同步需要先做RDB，然后将RDB文件通过网络传输个slave，成本太高了。因此除了第一次做全量同步，其它大多数时候slave与master都是做<strong>增量同步</strong>。</p>
<p>什么是增量同步？就是只更新slave与master存在差异的部分数据。如图：</p>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231105751.png" srcset="/img/loading.gif" lazyload></p>
<p>那么master怎么知道slave与自己的数据差异在哪里呢?</p>
<h3 id="repl-backlog原理"><a href="#repl-backlog原理" class="headerlink" title="repl_backlog原理"></a>repl_backlog原理</h3><p>master怎么知道slave与自己的数据差异在哪里呢?</p>
<p>这就要说到全量同步时的repl_baklog文件了。</p>
<p>这个文件是一个固定大小的数组，只不过数组是环形，也就是说<strong>角标到达数组末尾后，会再次从0开始读写</strong>，这样数组头部的数据就会被覆盖。</p>
<p>repl_baklog中会记录Redis处理过的命令日志及offset，包括master当前的offset，和slave已经拷贝到的offset：</p>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231106526.png" srcset="/img/loading.gif" lazyload></p>
<p>slave与master的offset之间的差异，就是salve需要增量拷贝的数据了。</p>
<p>随着不断有数据写入，master的offset逐渐变大，slave也不断的拷贝，追赶master的offset：</p>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231106960.png" srcset="/img/loading.gif" lazyload></p>
<p>直到数组被填满：</p>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231107705.png" srcset="/img/loading.gif" lazyload></p>
<p>此时，如果有新的数据写入，就会覆盖数组中的旧数据。不过，旧的数据只要是绿色的，说明是已经被同步到slave的数据，即便被覆盖了也没什么影响。因为未同步的仅仅是红色部分。</p>
<p>但是，如果slave出现网络阻塞，导致master的offset远远超过了slave的offset：</p>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231107994.png" srcset="/img/loading.gif" lazyload></p>
<p>如果master继续写入新数据，其offset就会覆盖旧的数据，直到将slave现在的offset也覆盖：</p>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231107424.png" srcset="/img/loading.gif" lazyload></p>
<p>棕色框中的红色部分，就是尚未同步，但是却已经被覆盖的数据。此时如果slave恢复，需要同步，却发现自己的offset都没有了，无法完成增量同步了。只能做全量同步。</p>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231107374.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="主从同步优化"><a href="#主从同步优化" class="headerlink" title="主从同步优化"></a>主从同步优化</h2><p>主从同步可以保证主从数据的一致性，非常重要。</p>
<p>可以从以下几个方面来优化Redis主从就集群：</p>
<ul>
<li><p>在master中配置repl-diskless-sync yes启用无磁盘复制，避免全量同步时的磁盘IO。</p>
</li>
<li><p>Redis单节点上的内存占用不要太大，减少RDB导致的过多磁盘IO</p>
</li>
<li><p>适当提高repl_baklog的大小，发现slave宕机时尽快实现故障恢复，尽可能避免全量同步</p>
</li>
<li><p>限制一个master上的slave节点数量，如果实在是太多slave，则可以采用主-从-从链式结构，减少master压力</p>
</li>
</ul>
<p>主从从架构图：</p>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231108206.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>简述全量同步和增量同步区别？</p>
<ul>
<li><p>全量同步：master将完整内存数据生成RDB，发送RDB到slave。后续命令则记录在repl_baklog，逐个发送给slave。</p>
</li>
<li><p>增量同步：slave提交自己的offset到master，master获取repl_baklog中从offset之后的命令给slave。</p>
</li>
</ul>
<p>什么时候执行全量同步？</p>
<ul>
<li><p>slave节点第一次连接master节点时。</p>
</li>
<li><p>slave节点断开时间太久，repl_baklog中的offset已经被覆盖时。</p>
</li>
</ul>
<p>什么时候执行增量同步？</p>
<ul>
<li>slave节点断开又恢复，并且在repl_baklog中能找到offset时。</li>
</ul>
<h1 id="Redis哨兵"><a href="#Redis哨兵" class="headerlink" title="Redis哨兵"></a>Redis哨兵</h1><p>Redis提供了哨兵（Sentinel）机制来实现主从集群的自动故障恢复。</p>
<h2 id="哨兵原理"><a href="#哨兵原理" class="headerlink" title="哨兵原理"></a>哨兵原理</h2><h3 id="集群结构和作用"><a href="#集群结构和作用" class="headerlink" title="集群结构和作用"></a>集群结构和作用</h3><p>哨兵的结构如图：</p>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231247108.png" srcset="/img/loading.gif" lazyload></p>
<p>哨兵的作用如下：</p>
<ul>
<li><p><strong>监控</strong>：Sentinel 会不断检查您的master和slave是否按预期工作</p>
</li>
<li><p><strong>自动故障恢复</strong>：如果master故障，Sentinel会将一个slave提升为master。当故障实例恢复后也以新的master为主</p>
</li>
<li><p><strong>通知</strong>：Sentinel充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给Redis的客户端</p>
</li>
</ul>
<h3 id="集群监控原理"><a href="#集群监控原理" class="headerlink" title="集群监控原理"></a>集群监控原理</h3><p>Sentinel基于心跳机制监测服务状态，每隔1秒向集群的每个实例发送ping命令：</p>
<p>•主观下线：如果某sentinel节点发现某实例未在规定时间响应，则认为该实例<strong>主观下线</strong>。</p>
<p>•客观下线：若超过指定数量（quorum）的sentinel都认为该实例主观下线，则该实例<strong>客观下线</strong>。quorum值最好超过Sentinel实例数量的一半。</p>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231248419.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="集群故障恢复原理"><a href="#集群故障恢复原理" class="headerlink" title="集群故障恢复原理"></a>集群故障恢复原理</h3><p>一旦发现master故障，sentinel需要在salve中选择一个作为新的master，选择依据是这样的：</p>
<ul>
<li><p>首先会判断slave节点与master节点断开时间长短，如果超过指定值（down-after-milliseconds * 10）则会排除该slave节点</p>
</li>
<li><p>然后判断slave节点的slave-priority值，越小优先级越高，如果是0则永不参与选举</p>
</li>
<li><p>如果slave-prority一样，则判断slave节点的offset值，越大说明数据越新，优先级越高</p>
</li>
<li><p>最后是判断slave节点的运行id大小，越小优先级越高。</p>
</li>
</ul>
<p>当选出一个新的master后，该如何实现切换呢？</p>
<p>流程如下：</p>
<ul>
<li><p>sentinel给备选的slave1节点发送slaveof no one命令，让该节点成为master。</p>
</li>
<li><p>sentinel给所有其它slave发送slaveof 192.168.150.101 7002 命令，让这些slave成为新master的从节点，开始从新的master上同步数据。</p>
</li>
<li><p>最后，sentinel将故障节点标记为slave，当故障节点恢复后会自动成为新的master的slave节点。</p>
</li>
</ul>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231248712.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>Sentinel的三个作用是什么？</p>
<ul>
<li><p>监控</p>
</li>
<li><p>故障转移</p>
</li>
<li><p>通知</p>
</li>
</ul>
<p>Sentinel如何判断一个redis实例是否健康？</p>
<ul>
<li><p>每隔1秒发送一次ping命令，如果超过一定时间没有相向则认为是主观下线</p>
</li>
<li><p>如果大多数sentinel都认为实例主观下线，则判定服务下线</p>
</li>
</ul>
<p>故障转移步骤有哪些？</p>
<ul>
<li><p>首先选定一个slave作为新的master，执行slaveof no one</p>
</li>
<li><p>然后让所有节点都执行slaveof 新master</p>
</li>
<li><p>修改故障节点配置，添加slaveof 新master</p>
</li>
</ul>
<h2 id="搭建哨兵集群"><a href="#搭建哨兵集群" class="headerlink" title="搭建哨兵集群"></a>搭建哨兵集群</h2><p>这里我们搭建一个三节点形成的Sentinel集群，来监管之前的Redis主从集群。如图：</p>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231249718.png" srcset="/img/loading.gif" lazyload></p>
<p>三个sentinel实例信息如下：</p>
<table>
<thead>
<tr>
<th>节点</th>
<th>IP</th>
<th>PORT</th>
</tr>
</thead>
<tbody><tr>
<td>s1</td>
<td>192.168.150.101</td>
<td>27001</td>
</tr>
<tr>
<td>s2</td>
<td>192.168.150.101</td>
<td>27002</td>
</tr>
<tr>
<td>s3</td>
<td>192.168.150.101</td>
<td>27003</td>
</tr>
</tbody></table>
<h3 id="准备实例和配置-1"><a href="#准备实例和配置-1" class="headerlink" title="准备实例和配置"></a>准备实例和配置</h3><p>要在同一台虚拟机开启3个实例，必须准备三份不同的配置文件和目录，配置文件所在目录也就是工作目录。</p>
<p>我们创建三个文件夹，名字分别叫s1、s2、s3：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 进入/tmp目录</span><br><span class="hljs-built_in">cd</span> /tmp<br><span class="hljs-comment"># 创建目录</span><br><span class="hljs-built_in">mkdir</span> s1 s2 s3<br></code></pre></td></tr></table></figure>

<p>如图：</p>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231250483.png" srcset="/img/loading.gif" lazyload></p>
<p>然后我们在s1目录创建一个sentinel.conf文件，添加下面的内容：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ini">port 27001<br>sentinel announce-ip 192.168.150.101<br>sentinel monitor mymaster 192.168.150.101 7001 2<br>sentinel down-after-milliseconds mymaster 5000<br>sentinel failover-timeout mymaster 60000<br>dir &quot;/tmp/s1&quot;<br></code></pre></td></tr></table></figure>

<p><strong>解读</strong>：</p>
<ul>
<li><p><code>port 27001</code>：是当前sentinel实例的端口</p>
</li>
<li><p><code>sentinel monitor mymaster 192.168.150.101 7001 2</code>：指定主节点信息</p>
<ul>
<li><p><code>mymaster</code>：主节点名称，自定义，任意写</p>
</li>
<li><p><code>192.168.150.101 7001</code>：主节点的ip和端口</p>
</li>
<li><p><code>2</code>：选举master时的quorum值</p>
</li>
</ul>
</li>
</ul>
<p>然后将s1&#x2F;sentinel.conf文件拷贝到s2、s3两个目录中（在&#x2F;tmp目录执行下列命令）：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 方式一：逐个拷贝</span><br><span class="hljs-built_in">cp</span> s1/sentinel.conf s2<br><span class="hljs-built_in">cp</span> s1/sentinel.conf s3<br><span class="hljs-comment"># 方式二：管道组合命令，一键拷贝</span><br><span class="hljs-built_in">echo</span> s2 s3 | xargs -t -n 1 <span class="hljs-built_in">cp</span> s1/sentinel.conf<br></code></pre></td></tr></table></figure>

<p>修改s2、s3两个文件夹内的配置文件，将端口分别修改为27002、27003：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">sed -i -e <span class="hljs-string">&#x27;s/27001/27002/g&#x27;</span> -e <span class="hljs-string">&#x27;s/s1/s2/g&#x27;</span> s2/sentinel.conf<br>sed -i -e <span class="hljs-string">&#x27;s/27001/27003/g&#x27;</span> -e <span class="hljs-string">&#x27;s/s1/s3/g&#x27;</span> s3/sentinel.conf<br></code></pre></td></tr></table></figure>
<h3 id="启动-1"><a href="#启动-1" class="headerlink" title="启动"></a>启动</h3><p>为了方便查看日志，我们打开3个ssh窗口，分别启动3个redis实例，启动命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 第1个</span><br>redis-sentinel s1/sentinel.conf<br><span class="hljs-comment"># 第2个</span><br>redis-sentinel s2/sentinel.conf<br><span class="hljs-comment"># 第3个</span><br>redis-sentinel s3/sentinel.conf<br></code></pre></td></tr></table></figure>

<p>启动后：</p>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231253851.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><p>尝试让master节点7001宕机，查看sentinel日志：</p>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231254210.png" srcset="/img/loading.gif" lazyload></p>
<p>查看7003的日志：</p>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231254813.png" srcset="/img/loading.gif" lazyload></p>
<p>查看7002的日志：</p>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231254894.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="RedisTemplate"><a href="#RedisTemplate" class="headerlink" title="RedisTemplate"></a>RedisTemplate</h2><p>在Sentinel集群监管下的Redis主从集群，其节点会因为自动故障转移而发生变化，Redis的客户端必须感知这种变化，及时更新连接信息。Spring的RedisTemplate底层利用lettuce实现了节点的感知和自动切换。</p>
<p>下面，我们通过一个测试来实现RedisTemplate集成哨兵机制。</p>
<h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><p>在项目的pom文件中引入依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pom">&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure>

<h3 id="配置Redis地址"><a href="#配置Redis地址" class="headerlink" title="配置Redis地址"></a>配置Redis地址</h3><p>然后在配置文件application.yml中指定redis的sentinel相关信息：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">sentinel:</span><br>      <span class="hljs-attr">master:</span> <span class="hljs-string">mymaster</span><br>      <span class="hljs-attr">nodes:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-number">192.168</span><span class="hljs-number">.150</span><span class="hljs-number">.101</span><span class="hljs-string">:27001</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-number">192.168</span><span class="hljs-number">.150</span><span class="hljs-number">.101</span><span class="hljs-string">:27002</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-number">192.168</span><span class="hljs-number">.150</span><span class="hljs-number">.101</span><span class="hljs-string">:27003</span><br></code></pre></td></tr></table></figure>

<h3 id="配置读写分离"><a href="#配置读写分离" class="headerlink" title="配置读写分离"></a>配置读写分离</h3><p>在项目的启动类中，添加一个新的bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> LettuceClientConfigurationBuilderCustomizer <span class="hljs-title function_">clientConfigurationBuilderCustomizer</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> clientConfigurationBuilder -&gt; clientConfigurationBuilder.readFrom(ReadFrom.REPLICA_PREFERRED);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个bean中配置的就是读写策略，包括四种：</p>
<ul>
<li><p>MASTER：从主节点读取</p>
</li>
<li><p>MASTER_PREFERRED：优先从master节点读取，master不可用才读取replica</p>
</li>
<li><p>REPLICA：从slave（replica）节点读取</p>
</li>
<li><p>REPLICA _PREFERRED：优先从slave（replica）节点读取，所有的slave都不可用才读取master</p>
</li>
</ul>
<h1 id="Redis分片集群"><a href="#Redis分片集群" class="headerlink" title="Redis分片集群"></a>Redis分片集群</h1><p>主从和哨兵可以解决高可用、高并发读的问题。但是依然有两个问题没有解决：</p>
<ul>
<li><p>海量数据存储问题</p>
</li>
<li><p>高并发写的问题</p>
</li>
</ul>
<p>使用分片集群可以解决上述问题，如图:</p>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231257987.png" srcset="/img/loading.gif" lazyload></p>
<p>分片集群特征：</p>
<ul>
<li><p>集群中有多个master，每个master保存不同数据</p>
</li>
<li><p>每个master都可以有多个slave节点</p>
</li>
<li><p>master之间通过ping监测彼此健康状态</p>
</li>
<li><p>客户端请求可以访问集群任意节点，最终都会被转发到正确节点</p>
</li>
</ul>
<h2 id="搭建分配集群"><a href="#搭建分配集群" class="headerlink" title="搭建分配集群"></a>搭建分配集群</h2><p>这里我们会在同一台虚拟机中开启6个redis实例，模拟分片集群，信息如下：</p>
<table>
<thead>
<tr>
<th>IP</th>
<th>PORT</th>
<th>角色</th>
</tr>
</thead>
<tbody><tr>
<td>192.168.150.101</td>
<td>7001</td>
<td>master</td>
</tr>
<tr>
<td>192.168.150.101</td>
<td>7002</td>
<td>master</td>
</tr>
<tr>
<td>192.168.150.101</td>
<td>7003</td>
<td>master</td>
</tr>
<tr>
<td>192.168.150.101</td>
<td>8001</td>
<td>slave</td>
</tr>
<tr>
<td>192.168.150.101</td>
<td>8002</td>
<td>slave</td>
</tr>
<tr>
<td>192.168.150.101</td>
<td>8003</td>
<td>slave</td>
</tr>
</tbody></table>
<h3 id="准备实例和配置-2"><a href="#准备实例和配置-2" class="headerlink" title="准备实例和配置"></a>准备实例和配置</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 进入/tmp目录</span><br><span class="hljs-built_in">cd</span> /tmp<br><span class="hljs-comment"># 删除旧的，避免配置干扰</span><br><span class="hljs-built_in">rm</span> -rf 7001 7002 7003<br><span class="hljs-comment"># 创建目录</span><br><span class="hljs-built_in">mkdir</span> 7001 7002 7003 8001 8002 8003<br></code></pre></td></tr></table></figure>

<p>在&#x2F;tmp下准备一个新的redis.conf文件，内容如下：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">port</span> <span class="hljs-string">6379</span><br><span class="hljs-comment"># 开启集群功能</span><br><span class="hljs-attr">cluster-enabled</span> <span class="hljs-string">yes</span><br><span class="hljs-comment"># 集群的配置文件名称，不需要我们创建，由redis自己维护</span><br><span class="hljs-attr">cluster-config-file</span> <span class="hljs-string">/tmp/6379/nodes.conf</span><br><span class="hljs-comment"># 节点心跳失败的超时时间</span><br><span class="hljs-attr">cluster-node-timeout</span> <span class="hljs-string">5000</span><br><span class="hljs-comment"># 持久化文件存放目录</span><br><span class="hljs-attr">dir</span> <span class="hljs-string">/tmp/6379</span><br><span class="hljs-comment"># 绑定地址</span><br><span class="hljs-attr">bind</span> <span class="hljs-string">0.0.0.0</span><br><span class="hljs-comment"># 让redis后台运行</span><br><span class="hljs-attr">daemonize</span> <span class="hljs-string">yes</span><br><span class="hljs-comment"># 注册的实例ip</span><br><span class="hljs-attr">replica-announce-ip</span> <span class="hljs-string">192.168.150.101</span><br><span class="hljs-comment"># 保护模式</span><br><span class="hljs-attr">protected-mode</span> <span class="hljs-string">no</span><br><span class="hljs-comment"># 数据库数量</span><br><span class="hljs-attr">databases</span> <span class="hljs-string">1</span><br><span class="hljs-comment"># 日志</span><br><span class="hljs-attr">logfile</span> <span class="hljs-string">/tmp/6379/run.log</span><br></code></pre></td></tr></table></figure>

<p>将这个文件拷贝到每个目录下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 进入/tmp目录</span><br><span class="hljs-built_in">cd</span> /tmp<br><span class="hljs-comment"># 执行拷贝</span><br><span class="hljs-built_in">echo</span> 7001 7002 7003 8001 8002 8003 | xargs -t -n 1 <span class="hljs-built_in">cp</span> redis.conf<br></code></pre></td></tr></table></figure>

<p>修改每个目录下的redis.conf，将其中的6379修改为与所在目录一致：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 进入/tmp目录</span><br><span class="hljs-built_in">cd</span> /tmp<br><span class="hljs-comment"># 修改配置文件</span><br><span class="hljs-built_in">printf</span> <span class="hljs-string">&#x27;%s\n&#x27;</span> 7001 7002 7003 8001 8002 8003 | xargs -I&#123;&#125; -t sed -i <span class="hljs-string">&#x27;s/6379/&#123;&#125;/g&#x27;</span> &#123;&#125;/redis.conf<br></code></pre></td></tr></table></figure>
<h3 id="启动-2"><a href="#启动-2" class="headerlink" title="启动"></a>启动</h3><p>因为已经配置了后台启动模式，所以可以直接启动服务：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 进入/tmp目录</span><br><span class="hljs-built_in">cd</span> /tmp<br><span class="hljs-comment"># 一键启动所有服务</span><br><span class="hljs-built_in">printf</span> <span class="hljs-string">&#x27;%s\n&#x27;</span> 7001 7002 7003 8001 8002 8003 | xargs -I&#123;&#125; -t redis-server &#123;&#125;/redis.conf<br></code></pre></td></tr></table></figure>

<p>通过ps查看状态：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ps -ef | grep redis<br></code></pre></td></tr></table></figure>

<p>发现服务都已经正常启动：</p>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231300210.png" srcset="/img/loading.gif" lazyload></p>
<p>如果要关闭所有进程，可以执行命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ps -ef | grep redis | awk <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span> | xargs <span class="hljs-built_in">kill</span><br></code></pre></td></tr></table></figure>

<p>或者（推荐这种方式）：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">printf</span> <span class="hljs-string">&#x27;%s\n&#x27;</span> 7001 7002 7003 8001 8002 8003 | xargs -I&#123;&#125; -t redis-cli -p &#123;&#125; shutdown<br></code></pre></td></tr></table></figure>
<h3 id="创建集群"><a href="#创建集群" class="headerlink" title="创建集群"></a>创建集群</h3><p>虽然服务启动了，但是目前每个服务之间都是独立的，没有任何关联。</p>
<p>我们需要执行命令来创建集群，在Redis5.0之前创建集群比较麻烦，5.0之后集群管理命令都集成到了redis-cli中。</p>
<p>1）Redis5.0之前</p>
<p>Redis5.0之前集群命令都是用redis安装包下的src&#x2F;redis-trib.rb来实现的。因为redis-trib.rb是有ruby语言编写的所以需要安装ruby环境。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 安装依赖</span><br>yum -y install zlib ruby rubygems<br>gem install redis<br></code></pre></td></tr></table></figure>

<p>然后通过命令来管理集群：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 进入redis的src目录</span><br><span class="hljs-built_in">cd</span> /tmp/redis-6.2.4/src<br><span class="hljs-comment"># 创建集群</span><br>./redis-trib.rb create --replicas 1 192.168.150.101:7001 192.168.150.101:7002 192.168.150.101:7003 192.168.150.101:8001 192.168.150.101:8002 192.168.150.101:8003<br></code></pre></td></tr></table></figure>

<p>2）Redis5.0以后</p>
<p>我们使用的是Redis6.2.4版本，集群管理以及集成到了redis-cli中，格式如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">redis-cli --cluster create --cluster-replicas 1 192.168.150.101:7001 192.168.150.101:7002 192.168.150.101:7003 192.168.150.101:8001 192.168.150.101:8002 192.168.150.101:8003<br></code></pre></td></tr></table></figure>

<p>命令说明：</p>
<ul>
<li><p><code>redis-cli --cluster</code>或者<code>./redis-trib.rb</code>：代表集群操作命令</p>
</li>
<li><p><code>create</code>：代表是创建集群</p>
</li>
<li><p><code>--replicas 1</code>或者<code>--cluster-replicas 1</code> ：指定集群中每个master的副本个数为1，此时<code>节点总数 ÷ (replicas + 1)</code> 得到的就是master的数量。因此节点列表中的前n个就是master，其它节点都是slave节点，随机分配到不同master</p>
</li>
</ul>
<p>运行后的样子：</p>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231302511.png" srcset="/img/loading.gif" lazyload></p>
<p>这里输入yes，则集群开始创建：</p>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231302590.png" srcset="/img/loading.gif" lazyload></p>
<p>通过命令可以查看集群状态：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">redis-cli -p 7001 cluster nodes<br></code></pre></td></tr></table></figure>

<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231303949.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h3><p>尝试连接7001节点，存储一个数据：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 连接</span><br>redis-cli -p 7001<br><span class="hljs-comment"># 存储数据</span><br><span class="hljs-built_in">set</span> num 123<br><span class="hljs-comment"># 读取数据</span><br>get num<br><span class="hljs-comment"># 再次存储</span><br><span class="hljs-built_in">set</span> a 1<br></code></pre></td></tr></table></figure>

<p>结果悲剧了：</p>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231303226.png" srcset="/img/loading.gif" lazyload></p>
<p>集群操作时，需要给<code>redis-cli</code>加上<code>-c</code>参数才可以：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">redis-cli -c -p 7001<br></code></pre></td></tr></table></figure>

<p>这次可以了：</p>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231304328.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="散列插槽"><a href="#散列插槽" class="headerlink" title="散列插槽"></a>散列插槽</h2><h3 id="插槽原理"><a href="#插槽原理" class="headerlink" title="插槽原理"></a>插槽原理</h3><p>Redis会把每一个master节点映射到0~16383共16384个插槽（hash slot）上，查看集群信息时就能看到：</p>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231304987.png" srcset="/img/loading.gif" lazyload></p>
<p>数据key不是与节点绑定，而是与插槽绑定。redis会根据key的有效部分计算插槽值，分两种情况：</p>
<ul>
<li><p>key中包含”{}”，且“{}”中至少包含1个字符，“{}”中的部分是有效部分</p>
</li>
<li><p>key中不包含“{}”，整个key都是有效部分</p>
</li>
</ul>
<p>例如：key是num，那么就根据num计算，如果是{itcast}num，则根据itcast计算。计算方式是利用CRC16算法得到一个hash值，然后对16384取余，得到的结果就是slot值。</p>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231304071.png" srcset="/img/loading.gif" lazyload></p>
<p>如图，在7001这个节点执行set a 1时，对a做hash运算，对16384取余，得到的结果是15495，因此要存储到103节点。</p>
<p>到了7003后，执行<code>get num</code>时，对num做hash运算，对16384取余，得到的结果是2765，因此需要切换到7001节点</p>
<h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>Redis如何判断某个key应该在哪个实例？</p>
<ul>
<li><p>将16384个插槽分配到不同的实例</p>
</li>
<li><p>根据key的有效部分计算哈希值，对16384取余</p>
</li>
<li><p>余数作为插槽，寻找插槽所在实例即可</p>
</li>
</ul>
<p>如何将同一类数据固定的保存在同一个Redis实例？</p>
<ul>
<li>这一类数据使用相同的有效部分，例如key都以{typeId}为前缀</li>
</ul>
<h2 id="集群伸缩"><a href="#集群伸缩" class="headerlink" title="集群伸缩"></a>集群伸缩</h2><p>redis-cli –cluster提供了很多操作集群的命令，可以通过下面方式查看：</p>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231305820.png" srcset="/img/loading.gif" lazyload></p>
<p>比如，添加节点的命令：</p>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231305324.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>需求：向集群中添加一个新的master节点，并向其中存储 num &#x3D; 10</p>
<ul>
<li><p>启动一个新的redis实例，端口为7004</p>
</li>
<li><p>添加7004到之前的集群，并作为一个master节点</p>
</li>
<li><p>给7004节点分配插槽，使得num这个key可以存储到7004实例</p>
</li>
</ul>
<p>这里需要两个新的功能：</p>
<ul>
<li><p>添加一个节点到集群中</p>
</li>
<li><p>将部分插槽分配到新插槽</p>
</li>
</ul>
<h3 id="创新新的redis实例"><a href="#创新新的redis实例" class="headerlink" title="创新新的redis实例"></a>创新新的redis实例</h3><p>创建一个文件夹：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">mkdir</span> 7004<br></code></pre></td></tr></table></figure>

<p>拷贝配置文件：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cp</span> redis.conf /7004<br></code></pre></td></tr></table></figure>

<p>修改配置文件：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sed /s/6379/7004/g 7004/redis.conf<br></code></pre></td></tr></table></figure>

<p>启动</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">redis-server 7004/redis.conf<br></code></pre></td></tr></table></figure>

<h3 id="添加新节点到redis"><a href="#添加新节点到redis" class="headerlink" title="添加新节点到redis"></a>添加新节点到redis</h3><p>添加节点的语法如下：</p>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231307119.png" srcset="/img/loading.gif" lazyload></p>
<p>执行命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">redis-cli --cluster add-node  192.168.150.101:7004 192.168.150.101:7001<br></code></pre></td></tr></table></figure>

<p>通过命令查看集群状态：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">redis-cli -p 7001 cluster nodes<br></code></pre></td></tr></table></figure>

<p>如图，7004加入了集群，并且默认是一个master节点：</p>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231307600.png" srcset="/img/loading.gif" lazyload></p>
<p>但是，可以看到7004节点的插槽数量为0，因此没有任何数据可以存储到7004上</p>
<h3 id="转移插槽"><a href="#转移插槽" class="headerlink" title="转移插槽"></a>转移插槽</h3><p>我们要将num存储到7004节点，因此需要先看看num的插槽是多少：</p>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231308184.png" srcset="/img/loading.gif" lazyload></p>
<p>如上图所示，num的插槽为2765.</p>
<p>我们可以将0~3000的插槽从7001转移到7004，命令格式如下：</p>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231308039.png" srcset="/img/loading.gif" lazyload></p>
<p>具体命令如下：</p>
<p>建立连接：</p>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231308221.png" srcset="/img/loading.gif" lazyload></p>
<p>得到下面的反馈：</p>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231308576.png" srcset="/img/loading.gif" lazyload></p>
<p>询问要移动多少个插槽，我们计划是3000个：</p>
<p>新的问题来了：</p>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231309810.png" srcset="/img/loading.gif" lazyload></p>
<p>哪个node来接收这些插槽？？</p>
<p>显然是7004，那么7004节点的id是多少呢？</p>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231309214.png" srcset="/img/loading.gif" lazyload></p>
<p>复制这个id，然后拷贝到刚才的控制台后：</p>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231310527.png" srcset="/img/loading.gif" lazyload></p>
<p>这里询问，你的插槽是从哪里移动过来的？</p>
<ul>
<li><p>all：代表全部，也就是三个节点各转移一部分</p>
</li>
<li><p>具体的id：目标节点的id</p>
</li>
<li><p>done：没有了</p>
</li>
</ul>
<p>这里我们要从7001获取，因此填写7001的id：</p>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231310812.png" srcset="/img/loading.gif" lazyload></p>
<p>填完后，点击done，这样插槽转移就准备好了：</p>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231311617.png" srcset="/img/loading.gif" lazyload></p>
<p>确认要转移吗？输入yes：</p>
<p>然后，通过命令查看结果：</p>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231311985.png" srcset="/img/loading.gif" lazyload></p>
<p>可以看到：</p>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231311630.png" srcset="/img/loading.gif" lazyload></p>
<p>目的达成。</p>
<h2 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h2><p>集群初始状态是这样的：</p>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231312493.png" srcset="/img/loading.gif" lazyload></p>
<p>其中7001、7002、7003都是master，我们计划让7002宕机。</p>
<h3 id="自动故障转移"><a href="#自动故障转移" class="headerlink" title="自动故障转移"></a>自动故障转移</h3><p>当集群中有一个master宕机会发生什么呢？</p>
<p>直接停止一个redis实例，例如7002：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">redis-cli -p 7002 shutdown<br></code></pre></td></tr></table></figure>

<p>1）首先是该实例与其它实例失去连接</p>
<p>2）然后是疑似宕机：</p>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231312355.png" srcset="/img/loading.gif" lazyload></p>
<p>3）最后是确定下线，自动提升一个slave为新的master：</p>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231313565.png" srcset="/img/loading.gif" lazyload></p>
<p>4）当7002再次启动，就会变为一个slave节点了：</p>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231313458.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="手动故障转移"><a href="#手动故障转移" class="headerlink" title="手动故障转移"></a>手动故障转移</h3><p>利用cluster failover命令可以手动让集群中的某个master宕机，切换到执行cluster failover命令的这个slave节点，实现无感知的数据迁移。其流程如下：</p>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231313950.png" srcset="/img/loading.gif" lazyload></p>
<p>这种failover命令可以指定三种模式：</p>
<ul>
<li><p>缺省：默认的流程，如图1~6歩</p>
</li>
<li><p>force：省略了对offset的一致性校验</p>
</li>
<li><p>takeover：直接执行第5歩，忽略数据一致性、忽略master状态和其它master的意见</p>
</li>
</ul>
<p><strong>案例需求</strong>：在7002这个slave节点执行手动故障转移，重新夺回master地位</p>
<p>步骤如下：</p>
<p>1）利用redis-cli连接7002这个节点</p>
<p>2）执行cluster failover命令</p>
<p>如图：</p>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231314469.png" srcset="/img/loading.gif" lazyload></p>
<p>效果：</p>
<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231314613.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="RedisTemplate访问分片集群"><a href="#RedisTemplate访问分片集群" class="headerlink" title="RedisTemplate访问分片集群"></a>RedisTemplate访问分片集群</h2><p>RedisTemplate底层同样基于lettuce实现了分片集群的支持，而使用的步骤与哨兵模式基本一致：</p>
<p>1）引入redis的starter依赖</p>
<p>2）配置分片集群地址</p>
<p>3）配置读写分离</p>
<p>与哨兵模式相比，其中只有分片集群的配置方式略有差异，如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh">spring:<br>  redis:<br>    cluster:<br>      nodes:<br>        - 192.168.150.101:7001<br>        - 192.168.150.101:7002<br>        - 192.168.150.101:7003<br>        - 192.168.150.101:8001<br>        - 192.168.150.101:8002<br>        - 192.168.150.101:8003<br></code></pre></td></tr></table></figure>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" class="category-chain-item">微服务</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/redis/">#redis</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>redis-分布式缓存</div>
      <div>https://blog.13space.cn/posts/75dbf2b5/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>拾叁</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>January 22, 2022</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/posts/5326b2b2/" title="redis-最佳实践">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">redis-最佳实践</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/posts/554b12af/" title="redis-guide">
                        <span class="hidden-mobile">redis-guide</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="twikoo"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/twikoo/1.6.8/twikoo.all.min.js', function() {
        var options = Object.assign(
          {"envId":"https://hexo-blog-twikoo-flame.vercel.app/","region":"ap-shanghai","path":"window.location.pathname"},
          {
            el: '#twikoo',
            path: 'window.location.pathname',
            onCommentLoaded: function() {
              var imgSelector = '#twikoo .tk-content img:not(.tk-owo-emotion)';
              Fluid.plugins.imageCaption(imgSelector);
              Fluid.plugins.fancyBox(imgSelector);
            }
          }
        )
        twikoo.init(options)
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> </br>拾叁的小破站，欢迎浏览啊~</br> <div style="font-size: 0.85rem"> <span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span> <script src="/js/duration.js"></script> </div> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        Views: 
        <span id="busuanzi_value_site_pv"></span>
        
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        Visitors: 
        <span id="busuanzi_value_site_uv"></span>
        
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
