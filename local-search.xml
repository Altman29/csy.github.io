<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>云原生之DevOps</title>
    <link href="/posts/9393e822/"/>
    <url>/posts/9393e822/</url>
    
    <content type="html"><![CDATA[<p>123123ss拾叁</p>]]></content>
    
    
    <categories>
      
      <category>云原生</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DevOps</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>云原生之kubeSphere</title>
    <link href="/posts/68893475/"/>
    <url>/posts/68893475/</url>
    
    <content type="html"><![CDATA[<p>1111222</p>]]></content>
    
    
    <categories>
      
      <category>云原生</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kubeSphere</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>云原生之k8s</title>
    <link href="/posts/7b28abd7/"/>
    <url>/posts/7b28abd7/</url>
    
    <content type="html"><![CDATA[<p>kkk8s<br>11</p>]]></content>
    
    
    <categories>
      
      <category>云原生</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kubernetes</tag>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nginx</title>
    <link href="/posts/c06c050/"/>
    <url>/posts/c06c050/</url>
    
    <content type="html"><![CDATA[<p>2323</p>]]></content>
    
    
    <categories>
      
      <category>网络应用组件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nginx</tag>
      
      <tag>反向代理</tag>
      
      <tag>线程安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mongodb</title>
    <link href="/posts/c9d19155/"/>
    <url>/posts/c9d19155/</url>
    
    <content type="html"><![CDATA[<p>1212</p>]]></content>
    
    
    <categories>
      
      <category>nosql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nosql</tag>
      
      <tag>mongodb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xxl-job</title>
    <link href="/posts/89b2e006/"/>
    <url>/posts/89b2e006/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>xxl-job</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入了解-mysql</title>
    <link href="/posts/bb4eda82/"/>
    <url>/posts/bb4eda82/</url>
    
    <content type="html"><![CDATA[<p>333311</p>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis-深入理解</title>
    <link href="/posts/6fe0354c/"/>
    <url>/posts/6fe0354c/</url>
    
    <content type="html"><![CDATA[<p>原理篇<br>2022-02-13 11:23:54</p>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>redis-最佳实践</title>
    <link href="/posts/5326b2b2/"/>
    <url>/posts/5326b2b2/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis键值设计"><a href="#Redis键值设计" class="headerlink" title="Redis键值设计"></a>Redis键值设计</h1><h2 id="优雅的key结构"><a href="#优雅的key结构" class="headerlink" title="优雅的key结构"></a>优雅的key结构</h2><p>Redis的Key虽然可以自定义，但最好遵循下面的几个最佳实践约定：</p><ul><li><p>遵循基本格式：[业务名称]:[数据名]:[id]</p></li><li><p>长度不超过44字节</p></li><li><p>不包含特殊字符</p></li></ul><p>例如：我们的登录业务，保存用户信息，其key可以设计成如下格式：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231400753.png"><br>这样设计的好处：</p><ul><li><p>可读性强</p></li><li><p>避免key冲突</p></li><li><p>方便管理</p></li><li><p>更节省内存： key是string类型，底层编码包含int、embstr和raw三种。embstr在小于44字节使用，采用连续内存空间，内存占用更小。当字节数大于44字节时，会转为raw模式存储，在raw模式下，内存空间不是连续的，而是采用一个指针指向了另外一段内存空间，在这段空间里存储SDS内容，这样空间不连续，访问的时候性能也就会收到影响，还有可能产生内存碎片。</p></li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231400537.png"></p><h2 id="拒绝BigKey"><a href="#拒绝BigKey" class="headerlink" title="拒绝BigKey"></a>拒绝BigKey</h2><p>BigKey通常以Key的大小和Key中成员的数量来综合判定，例如：</p><ul><li><p>Key本身的数据量过大：一个String类型的Key，它的值为5 MB</p></li><li><p>Key中的成员数过多：一个ZSET类型的Key，它的成员数量为10,000个</p></li><li><p>Key中成员的数据量过大：一个Hash类型的Key，它的成员数量虽然只有1,000个但这些成员的Value（值）总大小为100 MB</p></li></ul><p>那么如何判断元素的大小呢？redis也给我们提供了命令：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231401566.png"></p><p>推荐值：</p><ul><li><p>单个key的value小于10KB</p></li><li><p>对于集合类型的key，建议元素数量小于1000</p></li></ul><h3 id="BigKey危害"><a href="#BigKey危害" class="headerlink" title="BigKey危害"></a>BigKey危害</h3><ul><li><p>网络阻塞</p><ul><li>对BigKey执行读请求时，少量的QPS就可能导致带宽使用率被占满，导致Redis实例，乃至所在物理机变慢</li></ul></li><li><p>数据倾斜</p><ul><li>BigKey所在的Redis实例内存使用率远超其他实例，无法使数据分片的内存资源达到均衡</li></ul></li><li><p>Redis阻塞</p><ul><li>对元素较多的hash、list、zset等做运算会耗时较旧，使主线程被阻塞</li></ul></li><li><p>CPU压力</p><ul><li>对BigKey的数据序列化和反序列化会导致CPU的使用率飙升，影响Redis实例和本机其它应用</li></ul></li></ul><h3 id="如何发现BigKey"><a href="#如何发现BigKey" class="headerlink" title="如何发现BigKey"></a>如何发现BigKey</h3><h4 id="redis-cli-–bigkeys"><a href="#redis-cli-–bigkeys" class="headerlink" title="redis-cli –bigkeys"></a>redis-cli –bigkeys</h4><p>利用redis-cli提供的–bigkeys参数，可以遍历分析所有key，并返回Key的整体统计信息与每个数据的Top1的big key</p><p>命令：<code>redis-cli -a 密码 --bigkeys</code></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231403788.png"></p><h4 id="scan扫描"><a href="#scan扫描" class="headerlink" title="scan扫描"></a>scan扫描</h4><p>自己编程，利用scan扫描Redis中的所有key，利用strlen、hlen等命令判断key的长度（此处不建议使用MEMORY USAGE）。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231404593.png"></p><p>scan 命令调用完后每次会返回2个元素，第一个是下一次迭代的光标，第一次光标会设置为0，当最后一次scan 返回的光标等于0时，表示整个scan遍历结束了，第二个返回的是List，一个匹配的key的数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.heima.jedis.util.JedisConnectionFactory;<br><span class="hljs-keyword">import</span> org.junit.jupiter.api.AfterEach;<br><span class="hljs-keyword">import</span> org.junit.jupiter.api.BeforeEach;<br><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;<br><span class="hljs-keyword">import</span> redis.clients.jedis.Jedis;<br><span class="hljs-keyword">import</span> redis.clients.jedis.ScanResult;<br><br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JedisTest</span> &#123;<br>    <span class="hljs-keyword">private</span> Jedis jedis;<br><br>    <span class="hljs-meta">@BeforeEach</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUp</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 1.建立连接</span><br>        <span class="hljs-comment">// jedis = new Jedis(&quot;192.168.150.101&quot;, 6379);</span><br>        jedis = JedisConnectionFactory.getJedis();<br>        <span class="hljs-comment">// 2.设置密码</span><br>        jedis.auth(<span class="hljs-string">&quot;123321&quot;</span>);<br>        <span class="hljs-comment">// 3.选择库</span><br>        jedis.select(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">STR_MAX_LEN</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">HASH_MAX_LEN</span> <span class="hljs-operator">=</span> <span class="hljs-number">500</span>;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testScan</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">cursor</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;0&quot;</span>;<br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-comment">// 扫描并获取一部分key</span><br>            ScanResult&lt;String&gt; result = jedis.scan(cursor);<br>            <span class="hljs-comment">// 记录cursor</span><br>            cursor = result.getCursor();<br>            List&lt;String&gt; list = result.getResult();<br>            <span class="hljs-keyword">if</span> (list == <span class="hljs-literal">null</span> || list.isEmpty()) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">// 遍历</span><br>            <span class="hljs-keyword">for</span> (String key : list) &#123;<br>                <span class="hljs-comment">// 判断key的类型</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> jedis.type(key);<br>                <span class="hljs-keyword">switch</span> (type) &#123;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;string&quot;</span>:<br>                        len = jedis.strlen(key);<br>                        maxLen = STR_MAX_LEN;<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;hash&quot;</span>:<br>                        len = jedis.hlen(key);<br>                        maxLen = HASH_MAX_LEN;<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;list&quot;</span>:<br>                        len = jedis.llen(key);<br>                        maxLen = HASH_MAX_LEN;<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;set&quot;</span>:<br>                        len = jedis.scard(key);<br>                        maxLen = HASH_MAX_LEN;<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;zset&quot;</span>:<br>                        len = jedis.zcard(key);<br>                        maxLen = HASH_MAX_LEN;<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">default</span>:<br>                        <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (len &gt;= maxLen) &#123;<br>                    System.out.printf(<span class="hljs-string">&quot;Found big key : %s, type: %s, length or size: %d %n&quot;</span>, key, type, len);<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">while</span> (!cursor.equals(<span class="hljs-string">&quot;0&quot;</span>));<br>    &#125;<br>    <br>    <span class="hljs-meta">@AfterEach</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">tearDown</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (jedis != <span class="hljs-literal">null</span>) &#123;<br>            jedis.close();<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="第三方工具"><a href="#第三方工具" class="headerlink" title="第三方工具"></a>第三方工具</h4><ul><li><p>利用第三方工具，如 Redis-Rdb-Tools 分析RDB快照文件，全面分析内存使用情况</p></li><li><p><a href="https://github.com/sripathikrishnan/redis-rdb-tools">https://github.com/sripathikrishnan/redis-rdb-tools</a></p></li></ul><h4 id="网络监控"><a href="#网络监控" class="headerlink" title="网络监控"></a>网络监控</h4><ul><li><p>自定义工具，监控进出Redis的网络数据，超出预警值时主动告警</p></li><li><p>一般阿里云搭建的云服务器就有相关监控页面</p></li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231405915.png"></p><h3 id="如何删除BigKey"><a href="#如何删除BigKey" class="headerlink" title="如何删除BigKey"></a>如何删除BigKey</h3><p>BigKey内存占用较多，即便时删除这样的key也需要耗费很长时间，导致Redis主线程阻塞，引发一系列问题。</p><ul><li><p>redis 3.0 及以下版本</p><ul><li>如果是集合类型，则遍历BigKey的元素，先逐个删除子元素，最后删除BigKey</li></ul></li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231405571.png"></p><ul><li><p>Redis 4.0以后</p><ul><li>Redis在4.0后提供了异步删除的命令：unlink</li></ul></li></ul><h2 id="恰当的数据类型"><a href="#恰当的数据类型" class="headerlink" title="恰当的数据类型"></a>恰当的数据类型</h2><h3 id="User对象"><a href="#User对象" class="headerlink" title="User对象"></a>User对象</h3><p>比如存储一个User对象，我们有三种存储方式。</p><h4 id="json字符串"><a href="#json字符串" class="headerlink" title="json字符串"></a>json字符串</h4><table><thead><tr><th>user:1</th><th>{“name”: “Jack”, “age”: 21}</th></tr></thead></table><p>优点：实现简单粗暴</p><p>缺点：数据耦合，不够灵活</p><h4 id="字段打散"><a href="#字段打散" class="headerlink" title="字段打散"></a>字段打散</h4><table><thead><tr><th>user:1:name</th><th>Jack</th></tr></thead><tbody><tr><td>user:1:age</td><td>21</td></tr></tbody></table><p>优点：可以灵活访问对象任意字段</p><p>缺点：占用空间大、没办法做统一控制</p><h4 id="hash（推荐）"><a href="#hash（推荐）" class="headerlink" title="hash（推荐）"></a>hash（推荐）</h4><p>​<img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231408702.png"></p><p>优点：底层使用ziplist，空间占用小，可以灵活访问对象的任意字段</p><p>缺点：代码相对复杂</p><h3 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h3><p>假如有hash类型的key，其中有100万对field和value，field是自增id，这个key存在什么问题？如何优化？</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231409718.png"></p><p>存在的问题：</p><ul><li>hash的entry数量超过500时，会使用哈希表而不是ZipList，内存占用较多<ul><li><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231409136.png"></li></ul></li><li>可以通过hash-max-ziplist-entries配置entry上限。但是如果entry过多就会导致BigKey问题</li></ul><h4 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h4><p>拆分为string类型</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231410682.png"></p><p>存在的问题：</p><ul><li><p>string结构底层没有太多内存优化，内存占用较多<br><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231410799.png"></p></li><li><p>想要批量获取这些数据比较麻烦</p></li></ul><h4 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h4><p>拆分为小的hash，将 id &#x2F; 100 作为key， 将id % 100 作为field，这样每100个元素为一个Hash</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231411234.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231411030.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.heima.test;<br><br><span class="hljs-keyword">import</span> com.heima.jedis.util.JedisConnectionFactory;<br><span class="hljs-keyword">import</span> org.junit.jupiter.api.AfterEach;<br><span class="hljs-keyword">import</span> org.junit.jupiter.api.BeforeEach;<br><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;<br><span class="hljs-keyword">import</span> redis.clients.jedis.Jedis;<br><span class="hljs-keyword">import</span> redis.clients.jedis.Pipeline;<br><span class="hljs-keyword">import</span> redis.clients.jedis.ScanResult;<br><br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JedisTest</span> &#123;<br>    <span class="hljs-keyword">private</span> Jedis jedis;<br><br>    <span class="hljs-meta">@BeforeEach</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUp</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 1.建立连接</span><br>        <span class="hljs-comment">// jedis = new Jedis(&quot;192.168.150.101&quot;, 6379);</span><br>        jedis = JedisConnectionFactory.getJedis();<br>        <span class="hljs-comment">// 2.设置密码</span><br>        jedis.auth(<span class="hljs-string">&quot;123321&quot;</span>);<br>        <span class="hljs-comment">// 3.选择库</span><br>        jedis.select(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSetBigKey</span><span class="hljs-params">()</span> &#123;<br>        Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">650</span>; i++) &#123;<br>            map.put(<span class="hljs-string">&quot;hello_&quot;</span> + i, <span class="hljs-string">&quot;world!&quot;</span>);<br>        &#125;<br>        jedis.hmset(<span class="hljs-string">&quot;m2&quot;</span>, map);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testBigHash</span><span class="hljs-params">()</span> &#123;<br>        Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100000</span>; i++) &#123;<br>            map.put(<span class="hljs-string">&quot;key_&quot;</span> + i, <span class="hljs-string">&quot;value_&quot;</span> + i);<br>        &#125;<br>        jedis.hmset(<span class="hljs-string">&quot;test:big:hash&quot;</span>, map);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testBigString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100000</span>; i++) &#123;<br>            jedis.set(<span class="hljs-string">&quot;test:str:key_&quot;</span> + i, <span class="hljs-string">&quot;value_&quot;</span> + i);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSmallHash</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">hashSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>        Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(hashSize);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100000</span>; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> (i - <span class="hljs-number">1</span>) / hashSize;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> i % hashSize;<br>            map.put(<span class="hljs-string">&quot;key_&quot;</span> + v, <span class="hljs-string">&quot;value_&quot;</span> + v);<br>            <span class="hljs-keyword">if</span> (v == <span class="hljs-number">0</span>) &#123;<br>                jedis.hmset(<span class="hljs-string">&quot;test:small:hash_&quot;</span> + k, map);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@AfterEach</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">tearDown</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (jedis != <span class="hljs-literal">null</span>) &#123;<br>            jedis.close();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>Key的最佳实践</p><ul><li><p>固定格式：[业务名]:[数据名]:[id]</p></li><li><p>足够简短：不超过44字节</p></li><li><p>不包含特殊字符</p></li></ul></li><li><p>Value的最佳实践：</p><ul><li><p>合理的拆分数据，拒绝BigKey</p></li><li><p>选择合适数据结构</p></li><li><p>Hash结构的entry数量不要超过1000</p></li><li><p>设置合理的超时时间</p></li></ul></li></ul><h1 id="批处理优化"><a href="#批处理优化" class="headerlink" title="批处理优化"></a>批处理优化</h1><h2 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>我们的客户端与redis服务器是这样交互的:</p><p><strong>单个命令的执行流程</strong></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231426309.png"></p><p><strong>N条命令的执行流程</strong></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231426041.png"></p><p><strong>redis处理指令是很快的，主要花费的时候在于网络传输</strong>。于是乎很容易想到将多条指令批量的传输给redis。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231427861.png"></p><h3 id="MSet"><a href="#MSet" class="headerlink" title="MSet"></a>MSet</h3><p>Redis提供了很多Mxxx这样的命令，可以实现批量插入数据，例如：</p><ul><li><p>mset</p></li><li><p>hmset</p></li></ul><p>利用mset批量插入10万条数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testMxx</span><span class="hljs-params">()</span> &#123;<br>    String[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">2000</span>];<br>    <span class="hljs-type">int</span> j;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100000</span>; i++) &#123;<br>        j = (i % <span class="hljs-number">1000</span>) &lt;&lt; <span class="hljs-number">1</span>;<br>        arr[j] = <span class="hljs-string">&quot;test:key_&quot;</span> + i;<br>        arr[j + <span class="hljs-number">1</span>] = <span class="hljs-string">&quot;value_&quot;</span> + i;<br>        <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>) &#123;<br>            jedis.mset(arr);<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    System.out.println(<span class="hljs-string">&quot;time: &quot;</span> + (e - b));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Pipeline-1"><a href="#Pipeline-1" class="headerlink" title="Pipeline"></a>Pipeline</h3><p>MSET虽然可以批处理，但是却只能操作部分数据类型，因此如果有对复杂数据类型的批处理需要，建议使用Pipeline。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testPipeline</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 创建管道</span><br>    <span class="hljs-type">Pipeline</span> <span class="hljs-variable">pipeline</span> <span class="hljs-operator">=</span> jedis.pipelined();<br>    <span class="hljs-type">long</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100000</span>; i++) &#123;<br>        <span class="hljs-comment">// 放入命令到管道</span><br>        pipeline.set(<span class="hljs-string">&quot;test:key_&quot;</span> + i, <span class="hljs-string">&quot;value_&quot;</span> + i);<br>        <span class="hljs-keyword">if</span> (i % <span class="hljs-number">1000</span> == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 每放入1000条命令，批量执行</span><br>            pipeline.sync();<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    System.out.println(<span class="hljs-string">&quot;time: &quot;</span> + (e - b));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="集群下的批处理"><a href="#集群下的批处理" class="headerlink" title="集群下的批处理"></a>集群下的批处理</h2><p>如MSET或Pipeline这样的批处理需要在一次请求中携带多条命令，而此时如果Redis是一个集群，那批处理命令的多个key必须落在一个插槽中，否则就会导致执行失败。大家可以想一想这样的要求其实很难实现，因为我们在批处理时，可能一次要插入很多条数据，这些数据很有可能不会都落在相同的节点上，这就会导致报错了</p><p>这个时候，我们可以找到4种解决方案：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231433619.png"></p><p><strong>第一种方案</strong>：串行执行，所以这种方式没有什么意义，当然，执行起来就很简单了，缺点就是耗时过久。</p><p><strong>第二种方案</strong>：串行slot，简单来说，就是执行前，客户端先计算一下对应的key的slot，一样slot的key就放到一个组里边，不同的，就放到不同的组里边，然后对每个组执行pipeline的批处理，他就能串行执行各个组的命令，这种做法比第一种方法耗时要少，但是缺点呢，相对来说复杂一点，所以这种方案还需要优化一下</p><p><strong>第三种方案</strong>：并行slot，相较于第二种方案，在分组完成后串行执行，第三种方案，就变成了并行执行各个命令，所以他的耗时就非常短，但是实现呢，也更加复杂。</p><p><strong>第四种方案</strong>：hash_tag，redis计算key的slot的时候，其实是根据key的有效部分来计算的，通过这种方式就能一次处理所有的key，这种方式耗时最短，实现也简单，但是如果通过操作key的有效部分，那么就会导致所有的key都落在一个节点上，产生数据倾斜的问题，所以我们推荐使用第三种方式。</p><h3 id="串行化执行代码实践"><a href="#串行化执行代码实践" class="headerlink" title="串行化执行代码实践"></a>串行化执行代码实践</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JedisClusterTest</span> &#123;<br><br>    <span class="hljs-keyword">private</span> JedisCluster jedisCluster;<br><br>    <span class="hljs-meta">@BeforeEach</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUp</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 配置连接池</span><br>        <span class="hljs-type">JedisPoolConfig</span> <span class="hljs-variable">poolConfig</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPoolConfig</span>();<br>        poolConfig.setMaxTotal(<span class="hljs-number">8</span>);<br>        poolConfig.setMaxIdle(<span class="hljs-number">8</span>);<br>        poolConfig.setMinIdle(<span class="hljs-number">0</span>);<br>        poolConfig.setMaxWaitMillis(<span class="hljs-number">1000</span>);<br>        HashSet&lt;HostAndPort&gt; nodes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        nodes.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HostAndPort</span>(<span class="hljs-string">&quot;192.168.150.101&quot;</span>, <span class="hljs-number">7001</span>));<br>        nodes.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HostAndPort</span>(<span class="hljs-string">&quot;192.168.150.101&quot;</span>, <span class="hljs-number">7002</span>));<br>        nodes.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HostAndPort</span>(<span class="hljs-string">&quot;192.168.150.101&quot;</span>, <span class="hljs-number">7003</span>));<br>        nodes.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HostAndPort</span>(<span class="hljs-string">&quot;192.168.150.101&quot;</span>, <span class="hljs-number">8001</span>));<br>        nodes.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HostAndPort</span>(<span class="hljs-string">&quot;192.168.150.101&quot;</span>, <span class="hljs-number">8002</span>));<br>        nodes.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HostAndPort</span>(<span class="hljs-string">&quot;192.168.150.101&quot;</span>, <span class="hljs-number">8003</span>));<br>        jedisCluster = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisCluster</span>(nodes, poolConfig);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testMSet</span><span class="hljs-params">()</span> &#123;<br>        jedisCluster.mset(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Jack&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-string">&quot;21&quot;</span>, <span class="hljs-string">&quot;sex&quot;</span>, <span class="hljs-string">&quot;male&quot;</span>);<br><br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testMSet2</span><span class="hljs-params">()</span> &#123;<br>        Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(<span class="hljs-number">3</span>);<br>        map.put(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Jack&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-string">&quot;21&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;sex&quot;</span>, <span class="hljs-string">&quot;Male&quot;</span>);<br>        <span class="hljs-comment">//对Map数据进行分组。根据相同的slot放在一个分组</span><br>        <span class="hljs-comment">//key就是slot，value就是一个组</span><br>        Map&lt;Integer, List&lt;Map.Entry&lt;String, String&gt;&gt;&gt; result = map.entrySet()<br>                .stream()<br>                .collect(Collectors.groupingBy(<br>                        entry -&gt; ClusterSlotHashUtil.calculateSlot(entry.getKey()))<br>                );<br>        <span class="hljs-comment">//串行的去执行mset的逻辑</span><br>        <span class="hljs-keyword">for</span> (List&lt;Map.Entry&lt;String, String&gt;&gt; list : result.values()) &#123;<br>            String[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[list.size() * <span class="hljs-number">2</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size(); i++) &#123;<br>                j = i&lt;&lt;<span class="hljs-number">2</span>;<br>                Map.Entry&lt;String, String&gt; e = list.get(<span class="hljs-number">0</span>);<br>                arr[j] = e.getKey();<br>                arr[j + <span class="hljs-number">1</span>] = e.getValue();<br>            &#125;<br>            jedisCluster.mset(arr);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@AfterEach</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">tearDown</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (jedisCluster != <span class="hljs-literal">null</span>) &#123;<br>            jedisCluster.close();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Spring集群环境下批处理代码"><a href="#Spring集群环境下批处理代码" class="headerlink" title="Spring集群环境下批处理代码"></a>Spring集群环境下批处理代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testMSetInCluster</span><span class="hljs-params">()</span> &#123;<br>     Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(<span class="hljs-number">3</span>);<br>     map.put(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Rose&quot;</span>);<br>     map.put(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-string">&quot;21&quot;</span>);<br>     map.put(<span class="hljs-string">&quot;sex&quot;</span>, <span class="hljs-string">&quot;Female&quot;</span>);<br>     stringRedisTemplate.opsForValue().multiSet(map);<br><br><br>     List&lt;String&gt; strings = stringRedisTemplate.opsForValue().multiGet(Arrays.asList(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-string">&quot;sex&quot;</span>));<br>     strings.forEach(System.out::println);<br><br> &#125;<br></code></pre></td></tr></table></figure><p><strong>原理分析</strong></p><p>在RedisAdvancedClusterAsyncCommandsImpl 类中</p><p>首先根据slotHash算出来一个partitioned的map，map中的key就是slot，而他的value就是对应的对应相同slot的key对应的数据</p><p>通过 RedisFuture&lt;String&gt; mset &#x3D; super.mset(op);进行异步的消息发送</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> RedisFuture&lt;String&gt; <span class="hljs-title function_">mset</span><span class="hljs-params">(Map&lt;K, V&gt; map)</span> &#123;<br><br>    Map&lt;Integer, List&lt;K&gt;&gt; partitioned = SlotHash.partition(codec, map.keySet());<br><br>    <span class="hljs-keyword">if</span> (partitioned.size() &lt; <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.mset(map);<br>    &#125;<br><br>    Map&lt;Integer, RedisFuture&lt;String&gt;&gt; executions = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, List&lt;K&gt;&gt; entry : partitioned.entrySet()) &#123;<br><br>        Map&lt;K, V&gt; op = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        entry.getValue().forEach(k -&gt; op.put(k, map.get(k)));<br><br>        RedisFuture&lt;String&gt; mset = <span class="hljs-built_in">super</span>.mset(op);<br>        executions.put(entry.getKey(), mset);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> MultiNodeExecution.firstOfAsync(executions);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="服务端优化-持久化配置"><a href="#服务端优化-持久化配置" class="headerlink" title="服务端优化-持久化配置"></a>服务端优化-持久化配置</h1><p>Redis的持久化虽然可以保证数据安全，但也会带来很多额外的开销，因此持久化请遵循下列建议：</p><ul><li><p>用来做缓存的Redis实例尽量不要开启持久化功能</p></li><li><p>建议关闭RDB持久化功能，使用AOF持久化</p></li><li><p>利用脚本定期在slave节点做RDB，实现数据备份</p></li><li><p>设置合理的rewrite阈值，避免频繁的bgrewrite</p></li><li><p>配置no-appendfsync-on-rewrite &#x3D; yes，禁止在rewrite期间做aof，避免因AOF引起的阻塞</p></li><li><p>部署有关建议：</p><ul><li><p>Redis实例的物理机要预留足够内存，应对fork和rewrite</p></li><li><p>单个Redis实例内存上限不要太大，例如4G或8G。可以加快fork的速度、减少主从同步、数据迁移压力</p></li><li><p>不要与CPU密集型应用部署在一起</p></li><li><p>不要与高硬盘负载应用一起部署。例如：数据库、消息队列</p></li></ul></li></ul><h1 id="服务端优化-慢查询优化"><a href="#服务端优化-慢查询优化" class="headerlink" title="服务端优化-慢查询优化"></a>服务端优化-慢查询优化</h1><h2 id="什么是慢查询"><a href="#什么是慢查询" class="headerlink" title="什么是慢查询"></a>什么是慢查询</h2><p>并不是很慢的查询才是慢查询，而是：在Redis执行时耗时超过某个阈值的命令，称为慢查询。</p><p>慢查询的危害：由于Redis是单线程的，所以当客户端发出指令后，他们都会进入到redis底层的queue来执行，如果此时有一些慢查询的数据，就会导致大量请求阻塞，从而引起报错，所以我们需要解决慢查询问题。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231436247.png"></p><p>慢查询的阈值可以通过配置指定：</p><p>slowlog-log-slower-than：慢查询阈值，单位是微秒。默认是10000，建议1000</p><p>慢查询会被放入慢查询日志中，日志的长度有上限，可以通过配置指定：</p><p>slowlog-max-len：慢查询日志（本质是一个队列）的长度。默认是128，建议1000</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231436979.png"></p><p>修改这两个配置可以使用：config set命令：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231436723.png"></p><h2 id="如何查看慢查询"><a href="#如何查看慢查询" class="headerlink" title="如何查看慢查询"></a>如何查看慢查询</h2><p>知道了以上内容之后，那么咱们如何去查看慢查询日志列表呢：</p><ul><li><p>slowlog len：查询慢查询日志长度</p></li><li><p>slowlog get [n]：读取n条慢查询日志</p></li><li><p>slowlog reset：清空慢查询列表</p></li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231437510.png"></p><h1 id="服务端优化-命令及安全配置"><a href="#服务端优化-命令及安全配置" class="headerlink" title="服务端优化-命令及安全配置"></a>服务端优化-命令及安全配置</h1><p>安全可以说是服务器端一个非常重要的话题，如果安全出现了问题，那么一旦这个漏洞被一些坏人知道了之后，并且进行攻击，那么这就会给咱们的系统带来很多的损失，所以我们这节课就来解决这个问题。</p><p>Redis会绑定在0.0.0.0:6379，这样将会将Redis服务暴露到公网上，而Redis如果没有做身份认证，会出现严重的安全漏洞. 漏洞重现方式：<a href="https://cloud.tencent.com/developer/article/1039000">https://cloud.tencent.com/developer/article/1039000</a></p><p>为什么会出现不需要密码也能够登录呢，主要是Redis考虑到每次登录都比较麻烦，所以Redis就有一种ssh免秘钥登录的方式，生成一对公钥和私钥，私钥放在本地，公钥放在redis端，当我们登录时服务器，再登录时候，他会去解析公钥和私钥，如果没有问题，则不需要利用redis的登录也能访问，这种做法本身也很常见，但是这里有一个前提，前提就是公钥必须保存在服务器上，才行，但是Redis的漏洞在于在不登录的情况下，也能把秘钥送到Linux服务器，从而产生漏洞</p><p>漏洞出现的核心的原因有以下几点：</p><ul><li><p>Redis未设置密码</p></li><li><p>利用了Redis的config set命令动态修改Redis配置</p></li><li><p>使用了Root账号权限启动Redis</p></li></ul><p>所以：如何解决呢？我们可以采用如下几种方案</p><p>为了避免这样的漏洞，这里给出一些建议：</p><ul><li><p>Redis一定要设置密码</p></li><li><p>禁止线上使用下面命令：keys、flushall、flushdb、config set等命令。可以利用rename-command禁用。</p></li><li><p>bind：限制网卡，禁止外网网卡访问</p></li><li><p>开启防火墙</p></li><li><p>不要使用Root账户启动Redis</p></li><li><p>尽量不是有默认的端口</p></li></ul><h1 id="服务端优化-Redis内存划分和内存配置"><a href="#服务端优化-Redis内存划分和内存配置" class="headerlink" title="服务端优化-Redis内存划分和内存配置"></a>服务端优化-Redis内存划分和内存配置</h1><p>当Redis内存不足时，可能导致Key频繁被删除、响应时间变长、QPS不稳定等问题。当内存使用率达到90%以上时就需要我们警惕，并快速定位到内存占用的原因。</p><p><strong>有关碎片问题分析</strong></p><p>Redis底层分配并不是这个key有多大，他就会分配多大，而是有他自己的分配策略，比如8,16,20等等，假定当前key只需要10个字节，此时分配8肯定不够，那么他就会分配16个字节，多出来的6个字节就不能被使用，这就是我们常说的 碎片问题</p><p><strong>进程内存问题分析：</strong></p><p>这片内存，通常我们都可以忽略不计</p><p><strong>缓冲区内存问题分析：</strong></p><p>一般包括客户端缓冲区、AOF缓冲区、复制缓冲区等。客户端缓冲区又包括输入缓冲区和输出缓冲区两种。这部分内存占用波动较大，所以这片内存也是我们需要重点分析的内存问题。</p><table><thead><tr><th><strong>内存占用</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>数据内存</td><td>是Redis最主要的部分，存储Redis的键值信息。主要问题是BigKey问题、内存碎片问题</td></tr><tr><td>进程内存</td><td>Redis主进程本身运⾏肯定需要占⽤内存，如代码、常量池等等；这部分内存⼤约⼏兆，在⼤多数⽣产环境中与Redis数据占⽤的内存相⽐可以忽略。</td></tr><tr><td>缓冲区内存</td><td>一般包括客户端缓冲区、AOF缓冲区、复制缓冲区等。客户端缓冲区又包括输入缓冲区和输出缓冲区两种。这部分内存占用波动较大，不当使用BigKey，可能导致内存溢出。</td></tr></tbody></table><p>于是我们就需要通过一些命令，可以查看到Redis目前的内存分配状态：</p><ul><li><p>info memory：查看内存分配的情况<br><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231438245.png"></p></li><li><p>memory xxx：查看key的主要占用情况<br><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231438754.png"></p></li></ul><p>接下来我们看到了这些配置，最关键的缓存区内存如何定位和解决呢？</p><p>内存缓冲区常见的有三种：</p><ul><li><p>复制缓冲区：主从复制的repl_backlog_buf，如果太小可能导致频繁的全量复制，影响性能。通过replbacklog-size来设置，默认1mb</p></li><li><p>AOF缓冲区：AOF刷盘之前的缓存区域，AOF执行rewrite的缓冲区。无法设置容量上限</p></li><li><p>客户端缓冲区：分为输入缓冲区和输出缓冲区，输入缓冲区最大1G且不能设置。输出缓冲区可以设置</p></li></ul><p>以上复制缓冲区和AOF缓冲区 不会有问题，最关键就是客户端缓冲区的问题</p><p>客户端缓冲区：指的就是我们发送命令时，客户端用来缓存命令的一个缓冲区，也就是我们向redis输入数据的输入端缓冲区和redis向客户端返回数据的响应缓存区，输入缓冲区最大1G且不能设置，所以这一块我们根本不用担心，如果超过了这个空间，redis会直接断开，因为本来此时此刻就代表着redis处理不过来了，我们需要担心的就是输出端缓冲区</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231438670.png"></p><p>我们在使用redis过程中，处理大量的big value，那么会导致我们的输出结果过多，如果输出缓存区过大，会导致redis直接断开，而默认配置的情况下， 其实他是没有大小的，这就比较坑了，内存可能一下子被占满，会直接导致咱们的redis断开，所以解决方案有两个</p><p>1、设置一个大小。</p><p>2、增加我们带宽的大小，避免我们出现大量数据从而直接超过了redis的承受能力。</p><h1 id="服务端集群优化-集群还是主从？"><a href="#服务端集群优化-集群还是主从？" class="headerlink" title="服务端集群优化-集群还是主从？"></a>服务端集群优化-集群还是主从？</h1><p>集群虽然具备高可用特性，能实现自动故障恢复，但是如果使用不当，也会存在一些问题：</p><ul><li><p>集群完整性问题</p></li><li><p>集群带宽问题</p></li><li><p>数据倾斜问题</p></li><li><p>客户端性能问题</p></li><li><p>命令的集群兼容性问题</p></li><li><p>lua和事务问题</p></li></ul><p><strong>问题1、在Redis的默认配置中，如果发现任意一个插槽不可用，则整个集群都会停止对外服务：</strong></p><p>大家可以设想一下，如果有几个slot不能使用，那么此时整个集群都不能用了，我们在开发中，其实最重要的是可用性，所以需要把如下配置修改成no，即有slot不能使用时，我们的redis集群还是可以对外提供服务</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231439693.png"></p><p><strong>问题2、集群带宽问题</strong></p><p>集群节点之间会不断的互相Ping来确定集群中其它节点的状态。每次Ping携带的信息至少包括：</p><ul><li><p>插槽信息</p></li><li><p>集群状态信息</p></li></ul><p>集群中节点越多，集群状态信息数据量也越大，10个节点的相关信息可能达到1kb，此时每次集群互通需要的带宽会非常高，这样会导致集群中大量的带宽都会被ping信息所占用，这是一个非常可怕的问题，所以我们需要去解决这样的问题</p><p><strong>解决途径：</strong></p><ul><li><p>避免大集群，集群节点数不要太多，最好少于1000，如果业务庞大，则建立多个集群。</p></li><li><p>避免在单个物理机中运行太多Redis实例</p></li><li><p>配置合适的cluster-node-timeout值</p></li></ul><p><strong>问题3、命令的集群兼容性问题</strong></p><p>有关这个问题咱们已经探讨过了，当我们使用批处理的命令时，redis要求我们的key必须落在相同的slot上，然后大量的key同时操作时，是无法完成的，所以客户端必须要对这样的数据进行处理，这些方案我们之前已经探讨过了，所以不再这个地方赘述了。</p><p><strong>问题4、lua和事务的问题</strong></p><p>lua和事务都是要保证原子性问题，如果你的key不在一个节点，那么是无法保证lua的执行和事务的特性的，所以在集群模式是没有办法执行lua和事务的</p><p><strong>到底是集群还是主从</strong></p><p>单体Redis（主从Redis）已经能达到万级别的QPS，并且也具备很强的高可用特性。如果主从能满足业务需求的情况下，所以如果不是在万不得已的情况下，尽量不搭建Redis集群。</p>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>redis-分布式缓存</title>
    <link href="/posts/75dbf2b5/"/>
    <url>/posts/75dbf2b5/</url>
    
    <content type="html"><![CDATA[<h1 id="单机Redis问题"><a href="#单机Redis问题" class="headerlink" title="单机Redis问题"></a>单机Redis问题</h1><p>单机的Redis存在四大问题：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231027998.png"></p><p class="note note-primary">所以，掌握分布式缓存是一种必备的技能。</p><h1 id="redis持久化"><a href="#redis持久化" class="headerlink" title="redis持久化"></a>redis持久化</h1><p>Redis有两种持久化方案：</p><ul><li><p>RDB持久化</p></li><li><p>AOF持久化</p></li></ul><h2 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h2><p>RDB全称Redis Database Backup file（Redis数据备份文件），也被叫做Redis数据快照。简单来说就是把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。快照文件称为RDB文件，默认是保存在当前运行目录。</p><h3 id="执行时机"><a href="#执行时机" class="headerlink" title="执行时机"></a>执行时机</h3><p>RDB持久化在四种情况下会执行：</p><ul><li><p>执行save命令</p></li><li><p>执行bgsave命令</p></li><li><p>Redis停机时</p></li><li><p>触发RDB条件时</p></li></ul><p><strong>1）save命令</strong></p><p>执行下面的命令，可以立即执行一次RDB：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231035635.png"></p><p><code>save</code>命令会导致主进程执行RDB，这个过程中其它所有命令都会被阻塞。只有在数据迁移时可能用到。</p><p><strong>2）bgsave命令</strong></p><p>下面的命令可以<strong>异步</strong>执行RDB：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231036151.png"></p><p>这个命令执行后会开启独立进程完成RDB，主进程可以持续处理用户请求，不受影响。</p><p><strong>3）停机时</strong></p><p>Redis停机时会执行一次save命令，实现RDB持久化。</p><p><strong>4）触发RDB条件</strong></p><p>Redis内部有触发RDB的机制，可以在redis.conf文件中找到，格式如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 900秒内，如果至少有1个key被修改，则执行bgsave ; 如果是save &quot;&quot; 则表示禁用RDB</span><br><span class="hljs-attr">save</span> <span class="hljs-string">900 1  </span><br><span class="hljs-attr">save</span> <span class="hljs-string">300 10  </span><br><span class="hljs-attr">save</span> <span class="hljs-string">60 10000 </span><br></code></pre></td></tr></table></figure><p>RDB的其它配置也可以在redis.conf文件中设置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 是否压缩 ,建议不开启，压缩也会消耗cpu，磁盘的话不值钱</span><br><span class="hljs-attr">rdbcompression</span> <span class="hljs-string">yes</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># RDB文件名称</span><br><span class="hljs-attr">dbfilename</span> <span class="hljs-string">dump.rdb  </span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 文件保存的路径目录</span><br><span class="hljs-attr">dir</span> <span class="hljs-string">./ </span><br></code></pre></td></tr></table></figure><h3 id="RDB原理"><a href="#RDB原理" class="headerlink" title="RDB原理"></a>RDB原理</h3><p>bgsave开始时会fork主进程得到子进程，子进程共享主进程的内存数据。完成fork后读取内存数据并写入 RDB 文件。</p><p>fork采用的是copy-on-write技术：</p><ul><li><p>当主进程执行读操作时，访问共享内存；</p></li><li><p>当主进程执行写操作时，则会拷贝一份数据，执行写操作。</p></li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231048414.png"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>RDB方式bgsave的基本流程？</p><ul><li><p>fork主进程得到一个子进程，共享内存空间</p></li><li><p>子进程读取内存数据并写入新的RDB文件</p></li><li><p>用新RDB文件替换旧的RDB文件</p></li></ul><p>RDB会在什么时候执行？save 60 1000代表什么含义？</p><ul><li><p>默认是服务停止时</p></li><li><p>代表60秒内至少执行1000次修改则触发RDB</p></li></ul><p>RDB的缺点？</p><ul><li><p>RDB执行间隔时间长，两次RDB之间写入数据有丢失的风险</p></li><li><p>fork子进程、压缩、写出RDB文件都比较耗时</p></li></ul><h2 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h2><h3 id="AOF原理"><a href="#AOF原理" class="headerlink" title="AOF原理"></a>AOF原理</h3><p>AOF全称为Append Only File（追加文件）。Redis处理的每一个写命令都会记录在AOF文件，可以看做是命令日志文件。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231050397.png"></p><h3 id="AOF配置"><a href="#AOF配置" class="headerlink" title="AOF配置"></a>AOF配置</h3><p>AOF默认是关闭的，需要修改redis.conf配置文件来开启AOF：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 是否开启AOF功能，默认是no</span><br><span class="hljs-attr">appendonly</span> <span class="hljs-string">yes</span><br><span class="hljs-comment"># AOF文件的名称</span><br><span class="hljs-attr">appendfilename</span> <span class="hljs-string">&quot;appendonly.aof&quot;</span><br></code></pre></td></tr></table></figure><p>AOF的命令记录的频率也可以通过redis.conf文件来配：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 表示每执行一次写命令，立即记录到AOF文件</span><br><span class="hljs-attr">appendfsync</span> <span class="hljs-string">always </span><br><span class="hljs-comment"># 写命令执行完先放入AOF缓冲区，然后表示每隔1秒将缓冲区数据写到AOF文件，是默认方案</span><br><span class="hljs-attr">appendfsync</span> <span class="hljs-string">everysec </span><br><span class="hljs-comment"># 写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘</span><br><span class="hljs-attr">appendfsync</span> <span class="hljs-string">no</span><br></code></pre></td></tr></table></figure><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231051257.png"></p><h3 id="AOF文件重写"><a href="#AOF文件重写" class="headerlink" title="AOF文件重写"></a>AOF文件重写</h3><p>因为是记录命令，AOF文件会比RDB文件大的多。而且AOF会记录对同一个key的多次写操作，但只有最后一次写操作才有意义。通过执行<code>bgrewriteaof</code>命令，可以让AOF文件执行重写功能，用最少的命令达到相同效果。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231052679.png"></p><p>如图，AOF原本有三个命令，但是<code>set num 123 和 set num 666</code>都是对num的操作，第二次会覆盖第一次的值，因此第一个命令记录下来没有意义。</p><p>所以重写命令后，AOF文件内容就是：<code>mset name jack num 666</code></p><p>Redis也会在触发阈值时自动去重写AOF文件。阈值也可以在redis.conf中配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># AOF文件比上次文件 增长超过多少百分比则触发重写</span><br><span class="hljs-attr">auto-aof-rewrite-percentage</span> <span class="hljs-string">100</span><br><span class="hljs-comment"># AOF文件体积最小多大以上才触发重写 </span><br><span class="hljs-attr">auto-aof-rewrite-min-size</span> <span class="hljs-string">64mb </span><br></code></pre></td></tr></table></figure><h2 id="RDB与AOF对比"><a href="#RDB与AOF对比" class="headerlink" title="RDB与AOF对比"></a>RDB与AOF对比</h2><p>RDB和AOF各有自己的优缺点，如果对数据安全性要求较高，在实际开发中往往会<strong>结合</strong>两者来使用。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231054380.png"></p><h1 id="Redis主从"><a href="#Redis主从" class="headerlink" title="Redis主从"></a>Redis主从</h1><h2 id="搭建主从架构"><a href="#搭建主从架构" class="headerlink" title="搭建主从架构"></a>搭建主从架构</h2><p>单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231055000.png"></p><p>共包含三个节点，一个主节点，两个从节点。</p><p>这里我们会在同一台虚拟机中开启3个redis实例，模拟主从集群，信息如下：</p><table><thead><tr><th>IP</th><th>PORT</th><th>角色</th></tr></thead><tbody><tr><td>192.168.150.101</td><td>7001</td><td>master</td></tr><tr><td>192.168.150.101</td><td>7002</td><td>slave</td></tr><tr><td>192.168.150.101</td><td>7003</td><td>slave</td></tr></tbody></table><h3 id="准备实例和配置"><a href="#准备实例和配置" class="headerlink" title="准备实例和配置"></a>准备实例和配置</h3><p>要在同一台虚拟机开启3个实例，必须准备三份不同的配置文件和目录，配置文件所在目录也就是工作目录。</p><p>1）创建目录</p><p>我们创建三个文件夹，名字分别叫7001、7002、7003：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 进入/tmp目录</span><br><span class="hljs-built_in">cd</span> /tmp<br><span class="hljs-comment"># 创建目录</span><br><span class="hljs-built_in">mkdir</span> 7001 7002 7003<br></code></pre></td></tr></table></figure><p>如图：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231058832.png"></p><p>2）恢复原始配置</p><p>修改redis-6.2.4&#x2F;redis.conf文件，将其中的持久化模式改为默认的RDB模式，AOF保持关闭状态。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 开启RDB</span><br><span class="hljs-comment"># save &quot;&quot;</span><br><span class="hljs-attr">save</span> <span class="hljs-string">3600 1</span><br><span class="hljs-attr">save</span> <span class="hljs-string">300 100</span><br><span class="hljs-attr">save</span> <span class="hljs-string">60 10000</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 关闭AOF</span><br><span class="hljs-attr">appendonly</span> <span class="hljs-string">no</span><br></code></pre></td></tr></table></figure><p>3）拷贝配置文件到每个实例目录</p><p>然后将redis-6.2.4&#x2F;redis.conf文件拷贝到三个目录中（在&#x2F;tmp目录执行下列命令）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 方式一：逐个拷贝</span><br><span class="hljs-built_in">cp</span> redis-6.2.4/redis.conf 7001<br><span class="hljs-built_in">cp</span> redis-6.2.4/redis.conf 7002<br><span class="hljs-built_in">cp</span> redis-6.2.4/redis.conf 7003<br><br><span class="hljs-comment"># 方式二：管道组合命令，一键拷贝</span><br><span class="hljs-built_in">echo</span> 7001 7002 7003 | xargs -t -n 1 <span class="hljs-built_in">cp</span> redis-6.2.4/redis.conf<br></code></pre></td></tr></table></figure><p>4）修改每个实例的端口、工作目录</p><p>修改每个文件夹内的配置文件，将端口分别修改为7001、7002、7003，将rdb文件保存位置都修改为自己所在目录（在&#x2F;tmp目录执行下列命令）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">sed -i -e <span class="hljs-string">&#x27;s/6379/7001/g&#x27;</span> -e <span class="hljs-string">&#x27;s/dir .\//dir \/tmp\/7001\//g&#x27;</span> 7001/redis.conf<br>sed -i -e <span class="hljs-string">&#x27;s/6379/7002/g&#x27;</span> -e <span class="hljs-string">&#x27;s/dir .\//dir \/tmp\/7002\//g&#x27;</span> 7002/redis.conf<br>sed -i -e <span class="hljs-string">&#x27;s/6379/7003/g&#x27;</span> -e <span class="hljs-string">&#x27;s/dir .\//dir \/tmp\/7003\//g&#x27;</span> 7003/redis.conf<br></code></pre></td></tr></table></figure><p>5）修改每个实例的声明IP</p><p>虚拟机本身有多个IP，为了避免将来混乱，我们需要在redis.conf文件中指定每一个实例的绑定ip信息，格式如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># redis实例的声明 IP</span><br><span class="hljs-attr">replica-announce-ip</span> <span class="hljs-string">192.168.150.101</span><br></code></pre></td></tr></table></figure><p>每个目录都要改，我们一键完成修改（在&#x2F;tmp目录执行下列命令）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 逐一执行</span><br>sed -i <span class="hljs-string">&#x27;1a replica-announce-ip 192.168.150.101&#x27;</span> 7001/redis.conf<br>sed -i <span class="hljs-string">&#x27;1a replica-announce-ip 192.168.150.101&#x27;</span> 7002/redis.conf<br>sed -i <span class="hljs-string">&#x27;1a replica-announce-ip 192.168.150.101&#x27;</span> 7003/redis.conf<br><br><span class="hljs-comment"># 或者一键修改</span><br><span class="hljs-built_in">printf</span> <span class="hljs-string">&#x27;%s\n&#x27;</span> 7001 7002 7003 | xargs -I&#123;&#125; -t sed -i <span class="hljs-string">&#x27;1a replica-announce-ip 192.168.150.101&#x27;</span> &#123;&#125;/redis.conf<br></code></pre></td></tr></table></figure><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>为了方便查看日志，我们打开3个ssh窗口，分别启动3个redis实例，启动命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 第1个</span><br>redis-server 7001/redis.conf<br><span class="hljs-comment"># 第2个</span><br>redis-server 7002/redis.conf<br><span class="hljs-comment"># 第3个</span><br>redis-server 7003/redis.conf<br></code></pre></td></tr></table></figure><p>启动后：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231101656.png"></p><p>如果要一键停止，可以运行下面命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">printf</span> <span class="hljs-string">&#x27;%s\n&#x27;</span> 7001 7002 7003 | xargs -I&#123;&#125; -t redis-cli -p &#123;&#125; shutdown<br></code></pre></td></tr></table></figure><h3 id="开启主从关系"><a href="#开启主从关系" class="headerlink" title="开启主从关系"></a>开启主从关系</h3><p>现在三个实例还没有任何关系，要配置主从可以使用replicaof 或者slaveof（5.0以前）命令。</p><p>有临时和永久两种模式：</p><ul><li><p>修改配置文件（永久生效）</p><ul><li>在redis.conf中添加一行配置：<code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code></li></ul></li><li><p>使用redis-cli客户端连接到redis服务，执行slaveof命令（重启后失效）：</p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">slaveof &lt;masterip&gt; &lt;masterport&gt;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：在5.0以后新增命令replicaof，与salveof效果一致。</p><p>这里我们为了演示方便，使用方式二。</p><p>通过redis-cli命令连接7002，执行下面命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 连接 7002</span><br>redis-cli -p 7002<br><span class="hljs-comment"># 执行slaveof</span><br>slaveof 192.168.150.101 7001<br></code></pre></td></tr></table></figure><p>通过redis-cli命令连接7003，执行下面命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 连接 7003</span><br>redis-cli -p 7003<br><span class="hljs-comment"># 执行slaveof</span><br>slaveof 192.168.150.101 7001<br></code></pre></td></tr></table></figure><p>然后连接 7001节点，查看集群状态：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 连接 7001</span><br>redis-cli -p 7001<br><span class="hljs-comment"># 查看状态</span><br>info replication<br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231103515.png"></p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>执行下列操作以测试：</p><ul><li><p>利用redis-cli连接7001，执行<code>set num 123</code></p></li><li><p>利用redis-cli连接7002，执行<code>get num</code>，再执行<code>set num 666</code></p></li><li><p>利用redis-cli连接7003，执行<code>get num</code>，再执行<code>set num 888</code></p></li></ul><p>可以发现，只有在7001这个master节点上可以执行写操作，7002和7003这两个slave节点只能执行读操作。</p><h2 id="主从数据同步原理"><a href="#主从数据同步原理" class="headerlink" title="主从数据同步原理"></a>主从数据同步原理</h2><h3 id="全量同步"><a href="#全量同步" class="headerlink" title="全量同步"></a>全量同步</h3><p>主从第一次建立连接时，会执行<strong>全量同步</strong>，将master节点的所有数据都拷贝给slave节点，流程：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231104444.png"><br>这里有一个问题，master如何得知salve是第一次来连接呢？？</p><p>有几个概念，可以作为判断依据：</p><ul><li><p><strong>Replication Id</strong>：简称replid，是数据集的标记，id一致则说明是同一数据集。每一个master都有唯一的replid，slave则会继承master节点的replid</p></li><li><p><strong>offset</strong>：偏移量，随着记录在repl_baklog中的数据增多而逐渐增大。slave完成同步时也会记录当前同步的offset。如果slave的offset小于master的offset，说明slave数据落后于master，需要更新。</p></li></ul><p>因此slave做数据同步，必须向master声明自己的replication id 和offset，master才可以判断到底需要同步哪些数据。</p><p>因为slave原本也是一个master，有自己的replid和offset，当第一次变成slave，与master建立连接时，发送的replid和offset是自己的replid和offset。</p><p>master判断发现slave发送来的replid与自己的不一致，说明这是一个全新的slave，就知道要做全量同步了。</p><p>master会将自己的replid和offset都发送给这个slave，slave保存这些信息。以后slave的replid就与master一致了。</p><p>因此，<strong>master判断一个节点是否是第一次同步的依据，就是看replid是否一致</strong>。</p><p>如图：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231105079.png"></p><p>完整流程描述：</p><ul><li><p>slave节点请求增量同步</p></li><li><p>master节点判断replid，发现不一致，拒绝增量同步</p></li><li><p>master将完整内存数据生成RDB，发送RDB到slave</p></li><li><p>slave清空本地数据，加载master的RDB</p></li><li><p>master将RDB期间的命令记录在repl_baklog，并持续将log中的命令发送给slave</p></li><li><p>slave执行接收到的命令，保持与master之间的同步</p></li></ul><h3 id="增量同步"><a href="#增量同步" class="headerlink" title="增量同步"></a>增量同步</h3><p>全量同步需要先做RDB，然后将RDB文件通过网络传输个slave，成本太高了。因此除了第一次做全量同步，其它大多数时候slave与master都是做<strong>增量同步</strong>。</p><p>什么是增量同步？就是只更新slave与master存在差异的部分数据。如图：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231105751.png"></p><p>那么master怎么知道slave与自己的数据差异在哪里呢?</p><h3 id="repl-backlog原理"><a href="#repl-backlog原理" class="headerlink" title="repl_backlog原理"></a>repl_backlog原理</h3><p>master怎么知道slave与自己的数据差异在哪里呢?</p><p>这就要说到全量同步时的repl_baklog文件了。</p><p>这个文件是一个固定大小的数组，只不过数组是环形，也就是说<strong>角标到达数组末尾后，会再次从0开始读写</strong>，这样数组头部的数据就会被覆盖。</p><p>repl_baklog中会记录Redis处理过的命令日志及offset，包括master当前的offset，和slave已经拷贝到的offset：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231106526.png"></p><p>slave与master的offset之间的差异，就是salve需要增量拷贝的数据了。</p><p>随着不断有数据写入，master的offset逐渐变大，slave也不断的拷贝，追赶master的offset：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231106960.png"></p><p>直到数组被填满：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231107705.png"></p><p>此时，如果有新的数据写入，就会覆盖数组中的旧数据。不过，旧的数据只要是绿色的，说明是已经被同步到slave的数据，即便被覆盖了也没什么影响。因为未同步的仅仅是红色部分。</p><p>但是，如果slave出现网络阻塞，导致master的offset远远超过了slave的offset：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231107994.png"></p><p>如果master继续写入新数据，其offset就会覆盖旧的数据，直到将slave现在的offset也覆盖：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231107424.png"></p><p>棕色框中的红色部分，就是尚未同步，但是却已经被覆盖的数据。此时如果slave恢复，需要同步，却发现自己的offset都没有了，无法完成增量同步了。只能做全量同步。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231107374.png"></p><h2 id="主从同步优化"><a href="#主从同步优化" class="headerlink" title="主从同步优化"></a>主从同步优化</h2><p>主从同步可以保证主从数据的一致性，非常重要。</p><p>可以从以下几个方面来优化Redis主从就集群：</p><ul><li><p>在master中配置repl-diskless-sync yes启用无磁盘复制，避免全量同步时的磁盘IO。</p></li><li><p>Redis单节点上的内存占用不要太大，减少RDB导致的过多磁盘IO</p></li><li><p>适当提高repl_baklog的大小，发现slave宕机时尽快实现故障恢复，尽可能避免全量同步</p></li><li><p>限制一个master上的slave节点数量，如果实在是太多slave，则可以采用主-从-从链式结构，减少master压力</p></li></ul><p>主从从架构图：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231108206.png"></p><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>简述全量同步和增量同步区别？</p><ul><li><p>全量同步：master将完整内存数据生成RDB，发送RDB到slave。后续命令则记录在repl_baklog，逐个发送给slave。</p></li><li><p>增量同步：slave提交自己的offset到master，master获取repl_baklog中从offset之后的命令给slave。</p></li></ul><p>什么时候执行全量同步？</p><ul><li><p>slave节点第一次连接master节点时。</p></li><li><p>slave节点断开时间太久，repl_baklog中的offset已经被覆盖时。</p></li></ul><p>什么时候执行增量同步？</p><ul><li>slave节点断开又恢复，并且在repl_baklog中能找到offset时。</li></ul><h1 id="Redis哨兵"><a href="#Redis哨兵" class="headerlink" title="Redis哨兵"></a>Redis哨兵</h1><p>Redis提供了哨兵（Sentinel）机制来实现主从集群的自动故障恢复。</p><h2 id="哨兵原理"><a href="#哨兵原理" class="headerlink" title="哨兵原理"></a>哨兵原理</h2><h3 id="集群结构和作用"><a href="#集群结构和作用" class="headerlink" title="集群结构和作用"></a>集群结构和作用</h3><p>哨兵的结构如图：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231247108.png"></p><p>哨兵的作用如下：</p><ul><li><p><strong>监控</strong>：Sentinel 会不断检查您的master和slave是否按预期工作</p></li><li><p><strong>自动故障恢复</strong>：如果master故障，Sentinel会将一个slave提升为master。当故障实例恢复后也以新的master为主</p></li><li><p><strong>通知</strong>：Sentinel充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给Redis的客户端</p></li></ul><h3 id="集群监控原理"><a href="#集群监控原理" class="headerlink" title="集群监控原理"></a>集群监控原理</h3><p>Sentinel基于心跳机制监测服务状态，每隔1秒向集群的每个实例发送ping命令：</p><p>•主观下线：如果某sentinel节点发现某实例未在规定时间响应，则认为该实例<strong>主观下线</strong>。</p><p>•客观下线：若超过指定数量（quorum）的sentinel都认为该实例主观下线，则该实例<strong>客观下线</strong>。quorum值最好超过Sentinel实例数量的一半。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231248419.png"></p><h3 id="集群故障恢复原理"><a href="#集群故障恢复原理" class="headerlink" title="集群故障恢复原理"></a>集群故障恢复原理</h3><p>一旦发现master故障，sentinel需要在salve中选择一个作为新的master，选择依据是这样的：</p><ul><li><p>首先会判断slave节点与master节点断开时间长短，如果超过指定值（down-after-milliseconds * 10）则会排除该slave节点</p></li><li><p>然后判断slave节点的slave-priority值，越小优先级越高，如果是0则永不参与选举</p></li><li><p>如果slave-prority一样，则判断slave节点的offset值，越大说明数据越新，优先级越高</p></li><li><p>最后是判断slave节点的运行id大小，越小优先级越高。</p></li></ul><p>当选出一个新的master后，该如何实现切换呢？</p><p>流程如下：</p><ul><li><p>sentinel给备选的slave1节点发送slaveof no one命令，让该节点成为master。</p></li><li><p>sentinel给所有其它slave发送slaveof 192.168.150.101 7002 命令，让这些slave成为新master的从节点，开始从新的master上同步数据。</p></li><li><p>最后，sentinel将故障节点标记为slave，当故障节点恢复后会自动成为新的master的slave节点。</p></li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231248712.png"></p><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>Sentinel的三个作用是什么？</p><ul><li><p>监控</p></li><li><p>故障转移</p></li><li><p>通知</p></li></ul><p>Sentinel如何判断一个redis实例是否健康？</p><ul><li><p>每隔1秒发送一次ping命令，如果超过一定时间没有相向则认为是主观下线</p></li><li><p>如果大多数sentinel都认为实例主观下线，则判定服务下线</p></li></ul><p>故障转移步骤有哪些？</p><ul><li><p>首先选定一个slave作为新的master，执行slaveof no one</p></li><li><p>然后让所有节点都执行slaveof 新master</p></li><li><p>修改故障节点配置，添加slaveof 新master</p></li></ul><h2 id="搭建哨兵集群"><a href="#搭建哨兵集群" class="headerlink" title="搭建哨兵集群"></a>搭建哨兵集群</h2><p>这里我们搭建一个三节点形成的Sentinel集群，来监管之前的Redis主从集群。如图：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231249718.png"></p><p>三个sentinel实例信息如下：</p><table><thead><tr><th>节点</th><th>IP</th><th>PORT</th></tr></thead><tbody><tr><td>s1</td><td>192.168.150.101</td><td>27001</td></tr><tr><td>s2</td><td>192.168.150.101</td><td>27002</td></tr><tr><td>s3</td><td>192.168.150.101</td><td>27003</td></tr></tbody></table><h3 id="准备实例和配置-1"><a href="#准备实例和配置-1" class="headerlink" title="准备实例和配置"></a>准备实例和配置</h3><p>要在同一台虚拟机开启3个实例，必须准备三份不同的配置文件和目录，配置文件所在目录也就是工作目录。</p><p>我们创建三个文件夹，名字分别叫s1、s2、s3：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 进入/tmp目录</span><br><span class="hljs-built_in">cd</span> /tmp<br><span class="hljs-comment"># 创建目录</span><br><span class="hljs-built_in">mkdir</span> s1 s2 s3<br></code></pre></td></tr></table></figure><p>如图：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231250483.png"></p><p>然后我们在s1目录创建一个sentinel.conf文件，添加下面的内容：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ini">port 27001<br>sentinel announce-ip 192.168.150.101<br>sentinel monitor mymaster 192.168.150.101 7001 2<br>sentinel down-after-milliseconds mymaster 5000<br>sentinel failover-timeout mymaster 60000<br>dir &quot;/tmp/s1&quot;<br></code></pre></td></tr></table></figure><p><strong>解读</strong>：</p><ul><li><p><code>port 27001</code>：是当前sentinel实例的端口</p></li><li><p><code>sentinel monitor mymaster 192.168.150.101 7001 2</code>：指定主节点信息</p><ul><li><p><code>mymaster</code>：主节点名称，自定义，任意写</p></li><li><p><code>192.168.150.101 7001</code>：主节点的ip和端口</p></li><li><p><code>2</code>：选举master时的quorum值</p></li></ul></li></ul><p>然后将s1&#x2F;sentinel.conf文件拷贝到s2、s3两个目录中（在&#x2F;tmp目录执行下列命令）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 方式一：逐个拷贝</span><br><span class="hljs-built_in">cp</span> s1/sentinel.conf s2<br><span class="hljs-built_in">cp</span> s1/sentinel.conf s3<br><span class="hljs-comment"># 方式二：管道组合命令，一键拷贝</span><br><span class="hljs-built_in">echo</span> s2 s3 | xargs -t -n 1 <span class="hljs-built_in">cp</span> s1/sentinel.conf<br></code></pre></td></tr></table></figure><p>修改s2、s3两个文件夹内的配置文件，将端口分别修改为27002、27003：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">sed -i -e <span class="hljs-string">&#x27;s/27001/27002/g&#x27;</span> -e <span class="hljs-string">&#x27;s/s1/s2/g&#x27;</span> s2/sentinel.conf<br>sed -i -e <span class="hljs-string">&#x27;s/27001/27003/g&#x27;</span> -e <span class="hljs-string">&#x27;s/s1/s3/g&#x27;</span> s3/sentinel.conf<br></code></pre></td></tr></table></figure><h3 id="启动-1"><a href="#启动-1" class="headerlink" title="启动"></a>启动</h3><p>为了方便查看日志，我们打开3个ssh窗口，分别启动3个redis实例，启动命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 第1个</span><br>redis-sentinel s1/sentinel.conf<br><span class="hljs-comment"># 第2个</span><br>redis-sentinel s2/sentinel.conf<br><span class="hljs-comment"># 第3个</span><br>redis-sentinel s3/sentinel.conf<br></code></pre></td></tr></table></figure><p>启动后：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231253851.png"></p><h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><p>尝试让master节点7001宕机，查看sentinel日志：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231254210.png"></p><p>查看7003的日志：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231254813.png"></p><p>查看7002的日志：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231254894.png"></p><h2 id="RedisTemplate"><a href="#RedisTemplate" class="headerlink" title="RedisTemplate"></a>RedisTemplate</h2><p>在Sentinel集群监管下的Redis主从集群，其节点会因为自动故障转移而发生变化，Redis的客户端必须感知这种变化，及时更新连接信息。Spring的RedisTemplate底层利用lettuce实现了节点的感知和自动切换。</p><p>下面，我们通过一个测试来实现RedisTemplate集成哨兵机制。</p><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><p>在项目的pom文件中引入依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pom">&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><h3 id="配置Redis地址"><a href="#配置Redis地址" class="headerlink" title="配置Redis地址"></a>配置Redis地址</h3><p>然后在配置文件application.yml中指定redis的sentinel相关信息：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">sentinel:</span><br>      <span class="hljs-attr">master:</span> <span class="hljs-string">mymaster</span><br>      <span class="hljs-attr">nodes:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-number">192.168</span><span class="hljs-number">.150</span><span class="hljs-number">.101</span><span class="hljs-string">:27001</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-number">192.168</span><span class="hljs-number">.150</span><span class="hljs-number">.101</span><span class="hljs-string">:27002</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-number">192.168</span><span class="hljs-number">.150</span><span class="hljs-number">.101</span><span class="hljs-string">:27003</span><br></code></pre></td></tr></table></figure><h3 id="配置读写分离"><a href="#配置读写分离" class="headerlink" title="配置读写分离"></a>配置读写分离</h3><p>在项目的启动类中，添加一个新的bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> LettuceClientConfigurationBuilderCustomizer <span class="hljs-title function_">clientConfigurationBuilderCustomizer</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> clientConfigurationBuilder -&gt; clientConfigurationBuilder.readFrom(ReadFrom.REPLICA_PREFERRED);<br>&#125;<br></code></pre></td></tr></table></figure><p>这个bean中配置的就是读写策略，包括四种：</p><ul><li><p>MASTER：从主节点读取</p></li><li><p>MASTER_PREFERRED：优先从master节点读取，master不可用才读取replica</p></li><li><p>REPLICA：从slave（replica）节点读取</p></li><li><p>REPLICA _PREFERRED：优先从slave（replica）节点读取，所有的slave都不可用才读取master</p></li></ul><h1 id="Redis分片集群"><a href="#Redis分片集群" class="headerlink" title="Redis分片集群"></a>Redis分片集群</h1><p>主从和哨兵可以解决高可用、高并发读的问题。但是依然有两个问题没有解决：</p><ul><li><p>海量数据存储问题</p></li><li><p>高并发写的问题</p></li></ul><p>使用分片集群可以解决上述问题，如图:</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231257987.png"></p><p>分片集群特征：</p><ul><li><p>集群中有多个master，每个master保存不同数据</p></li><li><p>每个master都可以有多个slave节点</p></li><li><p>master之间通过ping监测彼此健康状态</p></li><li><p>客户端请求可以访问集群任意节点，最终都会被转发到正确节点</p></li></ul><h2 id="搭建分配集群"><a href="#搭建分配集群" class="headerlink" title="搭建分配集群"></a>搭建分配集群</h2><p>这里我们会在同一台虚拟机中开启6个redis实例，模拟分片集群，信息如下：</p><table><thead><tr><th>IP</th><th>PORT</th><th>角色</th></tr></thead><tbody><tr><td>192.168.150.101</td><td>7001</td><td>master</td></tr><tr><td>192.168.150.101</td><td>7002</td><td>master</td></tr><tr><td>192.168.150.101</td><td>7003</td><td>master</td></tr><tr><td>192.168.150.101</td><td>8001</td><td>slave</td></tr><tr><td>192.168.150.101</td><td>8002</td><td>slave</td></tr><tr><td>192.168.150.101</td><td>8003</td><td>slave</td></tr></tbody></table><h3 id="准备实例和配置-2"><a href="#准备实例和配置-2" class="headerlink" title="准备实例和配置"></a>准备实例和配置</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 进入/tmp目录</span><br><span class="hljs-built_in">cd</span> /tmp<br><span class="hljs-comment"># 删除旧的，避免配置干扰</span><br><span class="hljs-built_in">rm</span> -rf 7001 7002 7003<br><span class="hljs-comment"># 创建目录</span><br><span class="hljs-built_in">mkdir</span> 7001 7002 7003 8001 8002 8003<br></code></pre></td></tr></table></figure><p>在&#x2F;tmp下准备一个新的redis.conf文件，内容如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">port</span> <span class="hljs-string">6379</span><br><span class="hljs-comment"># 开启集群功能</span><br><span class="hljs-attr">cluster-enabled</span> <span class="hljs-string">yes</span><br><span class="hljs-comment"># 集群的配置文件名称，不需要我们创建，由redis自己维护</span><br><span class="hljs-attr">cluster-config-file</span> <span class="hljs-string">/tmp/6379/nodes.conf</span><br><span class="hljs-comment"># 节点心跳失败的超时时间</span><br><span class="hljs-attr">cluster-node-timeout</span> <span class="hljs-string">5000</span><br><span class="hljs-comment"># 持久化文件存放目录</span><br><span class="hljs-attr">dir</span> <span class="hljs-string">/tmp/6379</span><br><span class="hljs-comment"># 绑定地址</span><br><span class="hljs-attr">bind</span> <span class="hljs-string">0.0.0.0</span><br><span class="hljs-comment"># 让redis后台运行</span><br><span class="hljs-attr">daemonize</span> <span class="hljs-string">yes</span><br><span class="hljs-comment"># 注册的实例ip</span><br><span class="hljs-attr">replica-announce-ip</span> <span class="hljs-string">192.168.150.101</span><br><span class="hljs-comment"># 保护模式</span><br><span class="hljs-attr">protected-mode</span> <span class="hljs-string">no</span><br><span class="hljs-comment"># 数据库数量</span><br><span class="hljs-attr">databases</span> <span class="hljs-string">1</span><br><span class="hljs-comment"># 日志</span><br><span class="hljs-attr">logfile</span> <span class="hljs-string">/tmp/6379/run.log</span><br></code></pre></td></tr></table></figure><p>将这个文件拷贝到每个目录下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 进入/tmp目录</span><br><span class="hljs-built_in">cd</span> /tmp<br><span class="hljs-comment"># 执行拷贝</span><br><span class="hljs-built_in">echo</span> 7001 7002 7003 8001 8002 8003 | xargs -t -n 1 <span class="hljs-built_in">cp</span> redis.conf<br></code></pre></td></tr></table></figure><p>修改每个目录下的redis.conf，将其中的6379修改为与所在目录一致：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 进入/tmp目录</span><br><span class="hljs-built_in">cd</span> /tmp<br><span class="hljs-comment"># 修改配置文件</span><br><span class="hljs-built_in">printf</span> <span class="hljs-string">&#x27;%s\n&#x27;</span> 7001 7002 7003 8001 8002 8003 | xargs -I&#123;&#125; -t sed -i <span class="hljs-string">&#x27;s/6379/&#123;&#125;/g&#x27;</span> &#123;&#125;/redis.conf<br></code></pre></td></tr></table></figure><h3 id="启动-2"><a href="#启动-2" class="headerlink" title="启动"></a>启动</h3><p>因为已经配置了后台启动模式，所以可以直接启动服务：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 进入/tmp目录</span><br><span class="hljs-built_in">cd</span> /tmp<br><span class="hljs-comment"># 一键启动所有服务</span><br><span class="hljs-built_in">printf</span> <span class="hljs-string">&#x27;%s\n&#x27;</span> 7001 7002 7003 8001 8002 8003 | xargs -I&#123;&#125; -t redis-server &#123;&#125;/redis.conf<br></code></pre></td></tr></table></figure><p>通过ps查看状态：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ps -ef | grep redis<br></code></pre></td></tr></table></figure><p>发现服务都已经正常启动：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231300210.png"></p><p>如果要关闭所有进程，可以执行命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ps -ef | grep redis | awk <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span> | xargs <span class="hljs-built_in">kill</span><br></code></pre></td></tr></table></figure><p>或者（推荐这种方式）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">printf</span> <span class="hljs-string">&#x27;%s\n&#x27;</span> 7001 7002 7003 8001 8002 8003 | xargs -I&#123;&#125; -t redis-cli -p &#123;&#125; shutdown<br></code></pre></td></tr></table></figure><h3 id="创建集群"><a href="#创建集群" class="headerlink" title="创建集群"></a>创建集群</h3><p>虽然服务启动了，但是目前每个服务之间都是独立的，没有任何关联。</p><p>我们需要执行命令来创建集群，在Redis5.0之前创建集群比较麻烦，5.0之后集群管理命令都集成到了redis-cli中。</p><p>1）Redis5.0之前</p><p>Redis5.0之前集群命令都是用redis安装包下的src&#x2F;redis-trib.rb来实现的。因为redis-trib.rb是有ruby语言编写的所以需要安装ruby环境。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 安装依赖</span><br>yum -y install zlib ruby rubygems<br>gem install redis<br></code></pre></td></tr></table></figure><p>然后通过命令来管理集群：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 进入redis的src目录</span><br><span class="hljs-built_in">cd</span> /tmp/redis-6.2.4/src<br><span class="hljs-comment"># 创建集群</span><br>./redis-trib.rb create --replicas 1 192.168.150.101:7001 192.168.150.101:7002 192.168.150.101:7003 192.168.150.101:8001 192.168.150.101:8002 192.168.150.101:8003<br></code></pre></td></tr></table></figure><p>2）Redis5.0以后</p><p>我们使用的是Redis6.2.4版本，集群管理以及集成到了redis-cli中，格式如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">redis-cli --cluster create --cluster-replicas 1 192.168.150.101:7001 192.168.150.101:7002 192.168.150.101:7003 192.168.150.101:8001 192.168.150.101:8002 192.168.150.101:8003<br></code></pre></td></tr></table></figure><p>命令说明：</p><ul><li><p><code>redis-cli --cluster</code>或者<code>./redis-trib.rb</code>：代表集群操作命令</p></li><li><p><code>create</code>：代表是创建集群</p></li><li><p><code>--replicas 1</code>或者<code>--cluster-replicas 1</code> ：指定集群中每个master的副本个数为1，此时<code>节点总数 ÷ (replicas + 1)</code> 得到的就是master的数量。因此节点列表中的前n个就是master，其它节点都是slave节点，随机分配到不同master</p></li></ul><p>运行后的样子：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231302511.png"></p><p>这里输入yes，则集群开始创建：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231302590.png"></p><p>通过命令可以查看集群状态：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">redis-cli -p 7001 cluster nodes<br></code></pre></td></tr></table></figure><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231303949.png"></p><h3 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h3><p>尝试连接7001节点，存储一个数据：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 连接</span><br>redis-cli -p 7001<br><span class="hljs-comment"># 存储数据</span><br><span class="hljs-built_in">set</span> num 123<br><span class="hljs-comment"># 读取数据</span><br>get num<br><span class="hljs-comment"># 再次存储</span><br><span class="hljs-built_in">set</span> a 1<br></code></pre></td></tr></table></figure><p>结果悲剧了：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231303226.png"></p><p>集群操作时，需要给<code>redis-cli</code>加上<code>-c</code>参数才可以：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">redis-cli -c -p 7001<br></code></pre></td></tr></table></figure><p>这次可以了：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231304328.png"></p><h2 id="散列插槽"><a href="#散列插槽" class="headerlink" title="散列插槽"></a>散列插槽</h2><h3 id="插槽原理"><a href="#插槽原理" class="headerlink" title="插槽原理"></a>插槽原理</h3><p>Redis会把每一个master节点映射到0~16383共16384个插槽（hash slot）上，查看集群信息时就能看到：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231304987.png"></p><p>数据key不是与节点绑定，而是与插槽绑定。redis会根据key的有效部分计算插槽值，分两种情况：</p><ul><li><p>key中包含”{}”，且“{}”中至少包含1个字符，“{}”中的部分是有效部分</p></li><li><p>key中不包含“{}”，整个key都是有效部分</p></li></ul><p>例如：key是num，那么就根据num计算，如果是{itcast}num，则根据itcast计算。计算方式是利用CRC16算法得到一个hash值，然后对16384取余，得到的结果就是slot值。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231304071.png"></p><p>如图，在7001这个节点执行set a 1时，对a做hash运算，对16384取余，得到的结果是15495，因此要存储到103节点。</p><p>到了7003后，执行<code>get num</code>时，对num做hash运算，对16384取余，得到的结果是2765，因此需要切换到7001节点</p><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>Redis如何判断某个key应该在哪个实例？</p><ul><li><p>将16384个插槽分配到不同的实例</p></li><li><p>根据key的有效部分计算哈希值，对16384取余</p></li><li><p>余数作为插槽，寻找插槽所在实例即可</p></li></ul><p>如何将同一类数据固定的保存在同一个Redis实例？</p><ul><li>这一类数据使用相同的有效部分，例如key都以{typeId}为前缀</li></ul><h2 id="集群伸缩"><a href="#集群伸缩" class="headerlink" title="集群伸缩"></a>集群伸缩</h2><p>redis-cli –cluster提供了很多操作集群的命令，可以通过下面方式查看：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231305820.png"></p><p>比如，添加节点的命令：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231305324.png"></p><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>需求：向集群中添加一个新的master节点，并向其中存储 num &#x3D; 10</p><ul><li><p>启动一个新的redis实例，端口为7004</p></li><li><p>添加7004到之前的集群，并作为一个master节点</p></li><li><p>给7004节点分配插槽，使得num这个key可以存储到7004实例</p></li></ul><p>这里需要两个新的功能：</p><ul><li><p>添加一个节点到集群中</p></li><li><p>将部分插槽分配到新插槽</p></li></ul><h3 id="创新新的redis实例"><a href="#创新新的redis实例" class="headerlink" title="创新新的redis实例"></a>创新新的redis实例</h3><p>创建一个文件夹：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">mkdir</span> 7004<br></code></pre></td></tr></table></figure><p>拷贝配置文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cp</span> redis.conf /7004<br></code></pre></td></tr></table></figure><p>修改配置文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sed /s/6379/7004/g 7004/redis.conf<br></code></pre></td></tr></table></figure><p>启动</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">redis-server 7004/redis.conf<br></code></pre></td></tr></table></figure><h3 id="添加新节点到redis"><a href="#添加新节点到redis" class="headerlink" title="添加新节点到redis"></a>添加新节点到redis</h3><p>添加节点的语法如下：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231307119.png"></p><p>执行命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">redis-cli --cluster add-node  192.168.150.101:7004 192.168.150.101:7001<br></code></pre></td></tr></table></figure><p>通过命令查看集群状态：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">redis-cli -p 7001 cluster nodes<br></code></pre></td></tr></table></figure><p>如图，7004加入了集群，并且默认是一个master节点：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231307600.png"></p><p>但是，可以看到7004节点的插槽数量为0，因此没有任何数据可以存储到7004上</p><h3 id="转移插槽"><a href="#转移插槽" class="headerlink" title="转移插槽"></a>转移插槽</h3><p>我们要将num存储到7004节点，因此需要先看看num的插槽是多少：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231308184.png"></p><p>如上图所示，num的插槽为2765.</p><p>我们可以将0~3000的插槽从7001转移到7004，命令格式如下：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231308039.png"></p><p>具体命令如下：</p><p>建立连接：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231308221.png"></p><p>得到下面的反馈：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231308576.png"></p><p>询问要移动多少个插槽，我们计划是3000个：</p><p>新的问题来了：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231309810.png"></p><p>哪个node来接收这些插槽？？</p><p>显然是7004，那么7004节点的id是多少呢？</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231309214.png"></p><p>复制这个id，然后拷贝到刚才的控制台后：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231310527.png"></p><p>这里询问，你的插槽是从哪里移动过来的？</p><ul><li><p>all：代表全部，也就是三个节点各转移一部分</p></li><li><p>具体的id：目标节点的id</p></li><li><p>done：没有了</p></li></ul><p>这里我们要从7001获取，因此填写7001的id：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231310812.png"></p><p>填完后，点击done，这样插槽转移就准备好了：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231311617.png"></p><p>确认要转移吗？输入yes：</p><p>然后，通过命令查看结果：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231311985.png"></p><p>可以看到：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231311630.png"></p><p>目的达成。</p><h2 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h2><p>集群初始状态是这样的：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231312493.png"></p><p>其中7001、7002、7003都是master，我们计划让7002宕机。</p><h3 id="自动故障转移"><a href="#自动故障转移" class="headerlink" title="自动故障转移"></a>自动故障转移</h3><p>当集群中有一个master宕机会发生什么呢？</p><p>直接停止一个redis实例，例如7002：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">redis-cli -p 7002 shutdown<br></code></pre></td></tr></table></figure><p>1）首先是该实例与其它实例失去连接</p><p>2）然后是疑似宕机：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231312355.png"></p><p>3）最后是确定下线，自动提升一个slave为新的master：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231313565.png"></p><p>4）当7002再次启动，就会变为一个slave节点了：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231313458.png"></p><h3 id="手动故障转移"><a href="#手动故障转移" class="headerlink" title="手动故障转移"></a>手动故障转移</h3><p>利用cluster failover命令可以手动让集群中的某个master宕机，切换到执行cluster failover命令的这个slave节点，实现无感知的数据迁移。其流程如下：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231313950.png"></p><p>这种failover命令可以指定三种模式：</p><ul><li><p>缺省：默认的流程，如图1~6歩</p></li><li><p>force：省略了对offset的一致性校验</p></li><li><p>takeover：直接执行第5歩，忽略数据一致性、忽略master状态和其它master的意见</p></li></ul><p><strong>案例需求</strong>：在7002这个slave节点执行手动故障转移，重新夺回master地位</p><p>步骤如下：</p><p>1）利用redis-cli连接7002这个节点</p><p>2）执行cluster failover命令</p><p>如图：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231314469.png"></p><p>效果：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403231314613.png"></p><h2 id="RedisTemplate访问分片集群"><a href="#RedisTemplate访问分片集群" class="headerlink" title="RedisTemplate访问分片集群"></a>RedisTemplate访问分片集群</h2><p>RedisTemplate底层同样基于lettuce实现了分片集群的支持，而使用的步骤与哨兵模式基本一致：</p><p>1）引入redis的starter依赖</p><p>2）配置分片集群地址</p><p>3）配置读写分离</p><p>与哨兵模式相比，其中只有分片集群的配置方式略有差异，如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh">spring:<br>  redis:<br>    cluster:<br>      nodes:<br>        - 192.168.150.101:7001<br>        - 192.168.150.101:7002<br>        - 192.168.150.101:7003<br>        - 192.168.150.101:8001<br>        - 192.168.150.101:8002<br>        - 192.168.150.101:8003<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis-入门&amp;场景运用</title>
    <link href="/posts/554b12af/"/>
    <url>/posts/554b12af/</url>
    
    <content type="html"><![CDATA[<h1 id="初识Redis"><a href="#初识Redis" class="headerlink" title="初识Redis"></a>初识Redis</h1><p>Redis是一种键值型的NoSql数据库，这里有两个关键字：</p><ul><li><p>键值型</p></li><li><p>NoSql</p></li></ul><p>其中<strong>键值型</strong>，是指Redis中存储的数据都是以key、value对的形式存储，而value的形式多种多样，可以是字符串、数值、甚至json：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221008130.png"></p><p>而NoSql则是相对于传统关系型数据库而言，有很大差异的一种数据库。</p><h2 id="认识NoSQL"><a href="#认识NoSQL" class="headerlink" title="认识NoSQL"></a>认识NoSQL</h2><p><strong>NoSql</strong>可以翻译做Not Only Sql（不仅仅是SQL），或者是No Sql（非Sql的）数据库。是相对于传统关系型数据库而言，有很大差异的一种特殊的数据库，因此也称之为<strong>非关系型数据库</strong>。</p><h3 id="结构化和非结构化"><a href="#结构化和非结构化" class="headerlink" title="结构化和非结构化"></a>结构化和非结构化</h3><p>传统关系型数据库是结构化数据，每一张表都有严格的约束信息：字段名、字段数据类型、字段约束等等信息，插入的数据必须遵守这些约束：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221009624.png"></p><p>而NoSql则对数据库格式没有严格约束，往往形式松散，自由。</p><p>可以是键值型：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221009934.png"><br>也可以是文档型(elasticsearch)：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221009704.png"><br>甚至可以是图格式：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221009022.png"></p><h3 id="关联和非关联"><a href="#关联和非关联" class="headerlink" title="关联和非关联"></a>关联和非关联</h3><p>传统数据库的表与表之间往往存在关联，例如外键：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221010981.png"></p><p>而非关系型数据库不存在关联关系，要维护关系要么靠代码中的业务逻辑，要么靠数据之间的耦合：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  id<span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>  name<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;张三&quot;</span><span class="hljs-punctuation">,</span><br>  orders<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>       id<span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>       item<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br> id<span class="hljs-punctuation">:</span> <span class="hljs-number">10</span><span class="hljs-punctuation">,</span> title<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;荣耀6&quot;</span><span class="hljs-punctuation">,</span> price<span class="hljs-punctuation">:</span> <span class="hljs-number">4999</span><br>       <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>       id<span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span><br>       item<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br> id<span class="hljs-punctuation">:</span> <span class="hljs-number">20</span><span class="hljs-punctuation">,</span> title<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;小米11&quot;</span><span class="hljs-punctuation">,</span> price<span class="hljs-punctuation">:</span> <span class="hljs-number">3999</span><br>       <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>此处要维护“张三”的订单与商品“荣耀”和“小米11”的关系，不得不冗余的将这两个商品保存在张三的订单文档中，不够优雅。还是建议用业务来维护关联关系。</p><h3 id="查询方式"><a href="#查询方式" class="headerlink" title="查询方式"></a>查询方式</h3><p>传统关系型数据库会基于Sql语句做查询，语法有统一标准；</p><p>而不同的非关系数据库查询语法差异极大，五花八门各种各样。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221012258.png"></p><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>传统关系型数据库能满足事务ACID的原则。</p><p>而非关系型数据库往往不支持事务，或者不能严格保证ACID的特性，只能实现基本的一致性。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>除了上述四点以外，在存储方式、扩展性、查询性能上关系型与非关系型也都有着显著差异，总结如下：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221013261.png"></p><ul><li><p>存储方式</p><ul><li><p>关系型数据库基于磁盘进行存储，会有大量的磁盘IO，对性能有一定影响</p></li><li><p>非关系型数据库，他们的操作更多的是依赖于内存来操作，内存的读写速度会非常快，性能自然会好一些</p></li></ul></li><li><p>扩展性</p><ul><li><p>关系型数据库集群模式一般是主从，主从数据一致，起到数据备份的作用，称为垂直扩展。</p></li><li><p>非关系型数据库可以将数据拆分，存储在不同机器上，可以保存海量数据，解决内存大小有限的问题。称为<strong>水平扩展</strong>。</p></li><li><p>关系型数据库因为表之间存在关联关系，如果做水平扩展会给数据查询带来很多麻烦。</p></li></ul></li></ul><h2 id="认识Redis"><a href="#认识Redis" class="headerlink" title="认识Redis"></a>认识Redis</h2><p>Redis诞生于2009年全称是<strong>Re</strong>mote <strong>D</strong>ictionary <strong>S</strong>erver 远程词典服务器，是一个基于内存的键值型NoSQL数据库。</p><p><strong>特征</strong>：</p><ul><li><p>键值（key-value）型，value支持多种不同数据结构，功能丰富</p></li><li><p>单线程，每个命令具备原子性</p></li><li><p>低延迟，速度快（基于内存、IO多路复用、良好的编码）。</p></li><li><p>支持数据持久化</p></li><li><p>支持主从集群、分片集群</p></li><li><p>支持多语言客户端</p></li></ul><h2 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h2><p>大多数企业都是基于Linux服务器来部署项目。</p><h3 id="依赖库"><a href="#依赖库" class="headerlink" title="依赖库"></a>依赖库</h3><p>Redis是基于C语言编写的，因此首先需要安装Redis所需要的gcc依赖：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">yum install -y gcc tcl<br></code></pre></td></tr></table></figure><h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221015494.png"><br>解压缩：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">tar -xzf redis-6.2.6.tar.gz<br></code></pre></td></tr></table></figure><p>进入redis目录：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> redis-6.2.6<br></code></pre></td></tr></table></figure><p>运行编译命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">make &amp;&amp; make install<br></code></pre></td></tr></table></figure><p>如果没有出错，应该就安装成功了。</p><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>redis的启动方式有很多种，例如：</p><ul><li><p>默认启动</p></li><li><p>指定配置启动</p></li><li><p>开机自启</p></li></ul><h3 id="默认启动"><a href="#默认启动" class="headerlink" title="默认启动"></a>默认启动</h3><p>安装完成后，在任意目录输入redis-server命令即可启动Redis：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">redis-server<br></code></pre></td></tr></table></figure><p>如图：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221017959.png"></p><p>这种启动属于<code>前台启动</code>，会阻塞整个会话窗口，窗口关闭或者按下<code>CTRL + C</code>则Redis停止。不推荐使用。</p><h3 id="指定配置启动"><a href="#指定配置启动" class="headerlink" title="指定配置启动"></a>指定配置启动</h3><p>如果要让Redis以<code>后台</code>方式启动，则必须修改Redis配置文件，就在我们之前解压的redis安装包下（<code>/usr/local/src/redis-6.2.6</code>），名字叫redis.conf：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221017106.png"></p><p>我们先将这个配置文件备份一份：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cp</span> redis.conf redis.conf.bak<br></code></pre></td></tr></table></figure><p>然后修改redis.conf文件中的一些配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs conf"># 允许访问的地址，默认是127.0.0.1，会导致只能在本地访问。修改为0.0.0.0则可以在任意IP访问，生产环境不要设置为0.0.0.0<br>bind 0.0.0.0<br># 守护进程，修改为yes后即可后台运行<br>daemonize yes <br># 密码，设置后访问Redis必须输入密码<br>requirepass 123321<br></code></pre></td></tr></table></figure><p>Redis的其它常见配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 监听的端口</span><br><span class="hljs-attr">port</span> <span class="hljs-string">6379</span><br><span class="hljs-comment"># 工作目录，默认是当前目录，也就是运行redis-server时的命令，日志、持久化等文件会保存在这个目录</span><br><span class="hljs-attr">dir</span> <span class="hljs-string">.</span><br><span class="hljs-comment"># 数据库数量，设置为1，代表只使用1个库，默认有16个库，编号0~15</span><br><span class="hljs-attr">databases</span> <span class="hljs-string">1</span><br><span class="hljs-comment"># 设置redis能够使用的最大内存</span><br><span class="hljs-attr">maxmemory</span> <span class="hljs-string">512mb</span><br><span class="hljs-comment"># 日志文件，默认为空，不记录日志，可以指定日志文件名</span><br><span class="hljs-attr">logfile</span> <span class="hljs-string">&quot;redis.log&quot;</span><br></code></pre></td></tr></table></figure><p>启动Redis：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 进入redis安装目录 </span><br><span class="hljs-built_in">cd</span> /usr/local/src/redis-6.2.6<br><span class="hljs-comment"># 启动</span><br>redis-server redis.conf<br></code></pre></td></tr></table></figure><p>停止服务：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 利用redis-cli来执行 shutdown 命令，即可停止 Redis 服务，</span><br><span class="hljs-comment"># 因为之前配置了密码，因此需要通过 -u 来指定密码</span><br>redis-cli -u 123321 shutdown<br></code></pre></td></tr></table></figure><h3 id="开机自启"><a href="#开机自启" class="headerlink" title="开机自启"></a>开机自启</h3><p>需要配置系统服务，这里不再赘述。</p><h1 id="Redis常见命令"><a href="#Redis常见命令" class="headerlink" title="Redis常见命令"></a>Redis常见命令</h1><p>Redis是典型的key-value数据库，key一般是字符串，而value包含很多不同的数据类型：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221023888.png"></p><p>Redis为了方便我们学习，将操作不同数据类型的命令也做了分组，在官网（ <a href="https://redis.io/commands">https://redis.io/commands</a> ）可以查看到不同的命令：</p><p>不同类型的命令称为一个group，我们也可以通过help命令来查看各种不同group的命令：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221024700.png"></p><h2 id="通用命令"><a href="#通用命令" class="headerlink" title="通用命令"></a>通用命令</h2><p>通用指令是部分数据类型的，都可以使用的指令，常见的有：</p><ul><li><p>KEYS：查看符合模板的所有key</p></li><li><p>DEL：删除一个指定的key</p></li><li><p>EXISTS：判断key是否存在</p></li><li><p>EXPIRE：给一个key设置有效期，有效期到期时该key会被自动删除</p></li><li><p>TTL：查看一个KEY的剩余有效期</p></li></ul><p>通过help [command] 可以查看一个命令的具体用法，例如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 查看keys命令的帮助信息：</span><br>127.0.0.1:6379&gt; <span class="hljs-built_in">help</span> keys<br><br>KEYS pattern<br>summary: Find all keys matching the given pattern<br>since: 1.0.0<br>group: generic<br></code></pre></td></tr></table></figure><h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><p>String类型，也就是字符串类型，是Redis中最简单的存储类型。</p><p>其value是字符串，不过根据字符串的格式不同，又可以分为3类：</p><ul><li><p>string：普通字符串</p></li><li><p>int：整数类型，可以做自增、自减操作</p></li><li><p>float：浮点类型，可以做自增、自减操作</p></li></ul><p>不管是哪种格式，底层都是字节数组形式存储，只不过是编码方式不同。字符串类型的最大空间不能超过512m.</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221026987.png"></p><h3 id="String常见命令"><a href="#String常见命令" class="headerlink" title="String常见命令"></a>String常见命令</h3><p>String的常见命令有：</p><ul><li><p>SET：添加或者修改已经存在的一个String类型的键值对</p></li><li><p>GET：根据key获取String类型的value</p></li><li><p>MSET：批量添加多个String类型的键值对</p></li><li><p>MGET：根据多个key获取多个String类型的value</p></li><li><p>INCR：让一个整型的key自增1</p></li><li><p>INCRBY:让一个整型的key自增并指定步长，例如：incrby num 2 让num值自增2</p></li><li><p>INCRBYFLOAT：让一个浮点类型的数字自增并指定步长</p></li><li><p>SETNX：添加一个String类型的键值对，前提是这个key不存在，否则不执行</p></li><li><p>SETEX：添加一个String类型的键值对，并且指定有效期</p></li></ul><h3 id="Key结构"><a href="#Key结构" class="headerlink" title="Key结构"></a>Key结构</h3><p>Redis没有类似MySQL中的Table的概念，我们该如何区分不同类型的key呢？</p><p>例如，需要存储用户、商品信息到redis，有一个用户id是1，有一个商品id恰好也是1，此时如果使用id作为key，那就会冲突了，该怎么办？</p><p>我们可以通过给key添加前缀加以区分，不过这个前缀不是随便加的，有一定的规范：</p><p>Redis的key允许有多个单词形成层级结构，多个单词之间用’:’隔开，格式如下：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">项目名:业务名:类型:<span class="hljs-built_in">id</span><br></code></pre></td></tr></table></figure><h2 id="Hash类型"><a href="#Hash类型" class="headerlink" title="Hash类型"></a>Hash类型</h2><p>Hash类型，也叫散列，其value是一个无序字典，类似于Java中的HashMap结构。</p><p>String结构是将对象序列化为JSON字符串后存储，当需要修改对象某个字段时很不方便：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221028704.png"></p><p>Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221029537.png"></p><p>Hash的常见命令有：</p><ul><li><p>HSET key field value：添加或者修改hash类型key的field的值</p></li><li><p>HGET key field：获取一个hash类型key的field的值</p></li><li><p>HMSET：批量添加多个hash类型key的field的值</p></li><li><p>HMGET：批量获取多个hash类型key的field的值</p></li><li><p>HGETALL：获取一个hash类型的key中的所有的field和value</p></li><li><p>HKEYS：获取一个hash类型的key中的所有的field</p></li><li><p>HINCRBY:让一个hash类型key的字段值自增并指定步长</p></li><li><p>HSETNX：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行</p></li></ul><h2 id="List类型"><a href="#List类型" class="headerlink" title="List类型"></a>List类型</h2><p>Redis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。</p><p>特征也与LinkedList类似：</p><ul><li><p>有序</p></li><li><p>元素可以重复</p></li><li><p>插入和删除快</p></li><li><p>查询速度一般</p></li></ul><p>常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等。</p><p>List的常见命令有：</p><ul><li><p>LPUSH key element … ：向列表左侧插入一个或多个元素</p></li><li><p>LPOP key：移除并返回列表左侧的第一个元素，没有则返回nil</p></li><li><p>RPUSH key element … ：向列表右侧插入一个或多个元素</p></li><li><p>RPOP key：移除并返回列表右侧的第一个元素</p></li><li><p>LRANGE key star end：返回一段角标范围内的所有元素</p></li><li><p>BLPOP和BRPOP：与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil</p></li></ul><h2 id="Set类型"><a href="#Set类型" class="headerlink" title="Set类型"></a>Set类型</h2><p>Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征：</p><ul><li><p>无序</p></li><li><p>元素不可重复</p></li><li><p>查找快</p></li><li><p>支持交集、并集、差集等功能</p></li></ul><p>Set的常见命令有：</p><ul><li><p>SADD key member … ：向set中添加一个或多个元素</p></li><li><p>SREM key member … : 移除set中的指定元素</p></li><li><p>SCARD key： 返回set中元素的个数</p></li><li><p>SISMEMBER key member：判断一个元素是否存在于set中</p></li><li><p>SMEMBERS：获取set中的所有元素</p></li><li><p>SINTER key1 key2 … ：求key1与key2的交集</p></li></ul><h2 id="SortedSet类型"><a href="#SortedSet类型" class="headerlink" title="SortedSet类型"></a>SortedSet类型</h2><p>Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。</p><p>SortedSet具备下列特性：</p><ul><li><p>可排序</p></li><li><p>元素不重复</p></li><li><p>查询速度快</p></li></ul><p>因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能。</p><p>SortedSet的常见命令有：</p><ul><li><p>ZADD key score member：添加一个或多个元素到sorted set ，如果已经存在则更新其score值</p></li><li><p>ZREM key member：删除sorted set中的一个指定元素</p></li><li><p>ZSCORE key member : 获取sorted set中的指定元素的score值</p></li><li><p>ZRANK key member：获取sorted set 中的指定元素的排名</p></li><li><p>ZCARD key：获取sorted set中的元素个数</p></li><li><p>ZCOUNT key min max：统计score值在给定范围内的所有元素的个数</p></li><li><p>ZINCRBY key increment member：让sorted set中的指定元素自增，步长为指定的increment值</p></li><li><p>ZRANGE key min max：按照score排序后，获取指定排名范围内的元素</p></li><li><p>ZRANGEBYSCORE key min max：按照score排序后，获取指定score范围内的元素</p></li><li><p>ZDIFF、ZINTER、ZUNION：求差集、交集、并集</p></li></ul><p>注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可，例如：</p><ul><li><p><strong>升序</strong>获取sorted set 中的指定元素的排名：ZRANK key member</p></li><li><p><strong>降序</strong>获取sorted set 中的指定元素的排名：ZREVRANK key memeber</p></li></ul><h1 id="Redis的Java客户端"><a href="#Redis的Java客户端" class="headerlink" title="Redis的Java客户端"></a>Redis的Java客户端</h1><p>在Redis官网中提供了各种语言的客户端，地址：<a href="https://redis.io/docs/clients/">https://redis.io/docs/clients/</a></p><p>其中Java客户端也包含很多：</p><ul><li><p>Jedis和Lettuce：这两个主要是提供了Redis命令对应的API，方便我们操作Redis，而SpringDataRedis又对这两种做了抽象和封装，因此我们后期会直接以SpringDataRedis来学习。</p></li><li><p>Redisson：是在Redis基础上实现了分布式的可伸缩的java数据结构，例如Map、Queue等，而且支持跨进程的同步机制：Lock、Semaphore等待，比较适合用来实现特殊的功能需求。</p></li></ul><h2 id="Jedis客户端"><a href="#Jedis客户端" class="headerlink" title="Jedis客户端"></a>Jedis客户端</h2><p>Jedis的官网地址： <a href="https://github.com/redis/jedis">https://github.com/redis/jedis</a></p><h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><p>我们先来个快速入门：</p><p>1）引入依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pom">&lt;!--jedis--&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;redis.clients&lt;/groupId&gt;<br>    &lt;artifactId&gt;jedis&lt;/artifactId&gt;<br>    &lt;version&gt;3.7.0&lt;/version&gt;<br>&lt;/dependency&gt;<br>&lt;!--单元测试--&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;<br>    &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt;<br>    &lt;version&gt;5.7.0&lt;/version&gt;<br>    &lt;scope&gt;test&lt;/scope&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><p>2）建立连接</p><p>新建一个单元测试类，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Jedis jedis;<br><br><span class="hljs-meta">@BeforeEach</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">setUp</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 1.建立连接</span><br>    <span class="hljs-comment">// jedis = new Jedis(&quot;192.168.150.101&quot;, 6379);</span><br>    jedis = JedisConnectionFactory.getJedis();<br>    <span class="hljs-comment">// 2.设置密码</span><br>    jedis.auth(<span class="hljs-string">&quot;123321&quot;</span>);<br>    <span class="hljs-comment">// 3.选择库</span><br>    jedis.select(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>3）测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testString</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 存入数据</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> jedis.set(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;虎哥&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;result = &quot;</span> + result);<br>    <span class="hljs-comment">// 获取数据</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> jedis.get(<span class="hljs-string">&quot;name&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;name = &quot;</span> + name);<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testHash</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 插入hash数据</span><br>    jedis.hset(<span class="hljs-string">&quot;user:1&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Jack&quot;</span>);<br>    jedis.hset(<span class="hljs-string">&quot;user:1&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-string">&quot;21&quot;</span>);<br><br>    <span class="hljs-comment">// 获取</span><br>    Map&lt;String, String&gt; map = jedis.hgetAll(<span class="hljs-string">&quot;user:1&quot;</span>);<br>    System.out.println(map);<br>&#125;<br></code></pre></td></tr></table></figure><p>4）释放资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AfterEach</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">tearDown</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (jedis != <span class="hljs-literal">null</span>) &#123;<br>        jedis.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><p>Jedis本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此我们推荐大家使用Jedis连接池代替Jedis的直连方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.heima.jedis.util;<br><br><span class="hljs-keyword">import</span> redis.clients.jedis.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JedisConnectionFactory</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> JedisPool jedisPool;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-comment">// 配置连接池</span><br>        <span class="hljs-type">JedisPoolConfig</span> <span class="hljs-variable">poolConfig</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPoolConfig</span>();<br>        poolConfig.setMaxTotal(<span class="hljs-number">8</span>);<br>        poolConfig.setMaxIdle(<span class="hljs-number">8</span>);<br>        poolConfig.setMinIdle(<span class="hljs-number">0</span>);<br>        poolConfig.setMaxWaitMillis(<span class="hljs-number">1000</span>);<br>        <span class="hljs-comment">// 创建连接池对象，参数：连接池配置、服务端ip、服务端端口、超时时间、密码</span><br>        jedisPool = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPool</span>(poolConfig, <span class="hljs-string">&quot;192.168.150.101&quot;</span>, <span class="hljs-number">6379</span>, <span class="hljs-number">1000</span>, <span class="hljs-string">&quot;123321&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Jedis <span class="hljs-title function_">getJedis</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> jedisPool.getResource();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="SpringDataRedis客户端"><a href="#SpringDataRedis客户端" class="headerlink" title="SpringDataRedis客户端"></a>SpringDataRedis客户端</h2><p>SpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做SpringDataRedis，官网地址：<a href="https://spring.io/projects/spring-data-redis">https://spring.io/projects/spring-data-redis</a></p><ul><li><p>提供了对不同Redis客户端的整合（Lettuce和Jedis）</p></li><li><p>提供了RedisTemplate统一API来操作Redis</p></li><li><p>支持Redis的发布订阅模型</p></li><li><p>支持Redis哨兵和Redis集群</p></li><li><p>支持基于Lettuce的响应式编程</p></li><li><p>支持基于JDK、JSON、字符串、Spring对象的数据序列化及反序列化</p></li><li><p>支持基于Redis的JDKCollection实现</p></li></ul><p>SpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封装到了不同的类型中：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221034846.png"></p><h3 id="快速入门-1"><a href="#快速入门-1" class="headerlink" title="快速入门"></a>快速入门</h3><p>SpringBoot已经提供了对SpringDataRedis的支持，使用非常简单。</p><p>首先，新建一个maven项目，然后按照下面步骤执行：</p><p>1）引入依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs pom">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;<br>         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;<br>    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;<br>    &lt;parent&gt;<br>        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;<br>        &lt;version&gt;2.5.7&lt;/version&gt;<br>        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;<br>    &lt;/parent&gt;<br>    &lt;groupId&gt;com.heima&lt;/groupId&gt;<br>    &lt;artifactId&gt;redis-demo&lt;/artifactId&gt;<br>    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;<br>    &lt;name&gt;redis-demo&lt;/name&gt;<br>    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;<br>    &lt;properties&gt;<br>        &lt;java.version&gt;1.8&lt;/java.version&gt;<br>    &lt;/properties&gt;<br>    &lt;dependencies&gt;<br>        &lt;!--redis依赖--&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;<br>        &lt;/dependency&gt;<br>        &lt;!--common-pool--&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;<br>            &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;<br>        &lt;/dependency&gt;<br>        &lt;!--Jackson依赖--&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;<br>            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;<br>        &lt;/dependency&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;<br>            &lt;artifactId&gt;lombok&lt;/artifactId&gt;<br>            &lt;optional&gt;true&lt;/optional&gt;<br>        &lt;/dependency&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;<br>            &lt;scope&gt;test&lt;/scope&gt;<br>        &lt;/dependency&gt;<br>    &lt;/dependencies&gt;<br><br>    &lt;build&gt;<br>        &lt;plugins&gt;<br>            &lt;plugin&gt;<br>                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;<br>                &lt;configuration&gt;<br>                    &lt;excludes&gt;<br>                        &lt;exclude&gt;<br>                            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;<br>                            &lt;artifactId&gt;lombok&lt;/artifactId&gt;<br>                        &lt;/exclude&gt;<br>                    &lt;/excludes&gt;<br>                &lt;/configuration&gt;<br>            &lt;/plugin&gt;<br>        &lt;/plugins&gt;<br>    &lt;/build&gt;<br><br>&lt;/project&gt;<br></code></pre></td></tr></table></figure><p>2）配置Redis</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.150</span><span class="hljs-number">.101</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123321</span><br>    <span class="hljs-attr">lettuce:</span><br>      <span class="hljs-attr">pool:</span><br>        <span class="hljs-attr">max-active:</span> <span class="hljs-number">8</span><br>        <span class="hljs-attr">max-idle:</span> <span class="hljs-number">8</span><br>        <span class="hljs-attr">min-idle:</span> <span class="hljs-number">0</span><br>        <span class="hljs-attr">max-wait:</span> <span class="hljs-string">100ms</span><br></code></pre></td></tr></table></figure><p>3）注入RedisTemplate</p><p>因为有了SpringBoot的自动装配，我们可以拿来就用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisStringTests</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br>&#125;<br></code></pre></td></tr></table></figure><p>4）编写测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisStringTests</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate edisTemplate;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 写入一条String数据</span><br>        redisTemplate.opsForValue().set(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;虎哥&quot;</span>);<br>        <span class="hljs-comment">// 获取string数据</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(<span class="hljs-string">&quot;name&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;name = &quot;</span> + name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="自定义序列化"><a href="#自定义序列化" class="headerlink" title="自定义序列化"></a>自定义序列化</h3><p>RedisTemplate可以接收任意Object作为值写入Redis：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221035220.png"></p><p>只不过写入前会把Object序列化为字节形式，默认是采用JDK序列化，得到的结果是这样的：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221036129.png"></p><p>缺点：</p><ul><li><p>可读性差</p></li><li><p>内存占用较大</p></li></ul><p>我们可以自定义RedisTemplate的序列化方式，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="hljs-title function_">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory connectionFactory)</span>&#123;<br>        <span class="hljs-comment">// 创建RedisTemplate对象</span><br>        RedisTemplate&lt;String, Object&gt; template = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisTemplate</span>&lt;&gt;();<br>        <span class="hljs-comment">// 设置连接工厂</span><br>        template.setConnectionFactory(connectionFactory);<br>        <span class="hljs-comment">// 创建JSON序列化工具</span><br>        <span class="hljs-type">GenericJackson2JsonRedisSerializer</span> <span class="hljs-variable">jsonRedisSerializer</span> <span class="hljs-operator">=</span> <br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericJackson2JsonRedisSerializer</span>();<br>        <span class="hljs-comment">// 设置Key的序列化</span><br>        template.setKeySerializer(RedisSerializer.string());<br>        template.setHashKeySerializer(RedisSerializer.string());<br>        <span class="hljs-comment">// 设置Value的序列化</span><br>        template.setValueSerializer(jsonRedisSerializer);<br>        template.setHashValueSerializer(jsonRedisSerializer);<br>        <span class="hljs-comment">// 返回</span><br>        <span class="hljs-keyword">return</span> template;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里采用了JSON序列化来代替默认的JDK序列化方式。最终结果如图：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221036928.png"></p><p>整体可读性有了很大提升，并且能将Java对象自动的序列化为JSON字符串，并且查询时能自动把JSON反序列化为Java对象。不过，其中记录了序列化时对应的class名称，目的是为了查询时实现自动反序列化。这会带来额外的内存开销。</p><h3 id="StringRedisTemplate"><a href="#StringRedisTemplate" class="headerlink" title="StringRedisTemplate"></a>StringRedisTemplate</h3><p>为了节省内存空间，我们可以不使用JSON序列化器来处理value，而是统一使用String序列化器，要求只能存储String类型的key和value。当需要存储Java对象时，手动完成对象的序列化和反序列化。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221037941.png"></p><p>因为存入和读取时的序列化及反序列化都是我们自己实现的，SpringDataRedis就不会将class信息写入Redis了。</p><p>这种用法比较普遍，因此SpringDataRedis就提供了RedisTemplate的子类：StringRedisTemplate，它的key和value的序列化方式默认就是String方式。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221038594.png"></p><p>省去了我们自定义RedisTemplate的序列化方式的步骤，而是直接使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br><span class="hljs-comment">// JSON序列化工具</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testSaveUser</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> JsonProcessingException &#123;<br>    <span class="hljs-comment">// 创建对象</span><br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;虎哥&quot;</span>, <span class="hljs-number">21</span>);<br>    <span class="hljs-comment">// 手动序列化</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> mapper.writeValueAsString(user);<br>    <span class="hljs-comment">// 写入数据</span><br>    stringRedisTemplate.opsForValue().set(<span class="hljs-string">&quot;user:200&quot;</span>, json);<br><br>    <span class="hljs-comment">// 获取数据</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">jsonUser</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(<span class="hljs-string">&quot;user:200&quot;</span>);<br>    <span class="hljs-comment">// 手动反序列化</span><br>    <span class="hljs-type">User</span> <span class="hljs-variable">user1</span> <span class="hljs-operator">=</span> mapper.readValue(jsonUser, User.class);<br>    System.out.println(<span class="hljs-string">&quot;user1 = &quot;</span> + user1);<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="场景运用"><a href="#场景运用" class="headerlink" title="场景运用"></a>场景运用</h1><h2 id="商户查询缓存"><a href="#商户查询缓存" class="headerlink" title="商户查询缓存"></a>商户查询缓存</h2><p>标准的操作方式就是查询数据库之前先查询缓存，如果缓存数据存在，则直接从缓存中返回，如果缓存数据不存在，再查询数据库，然后将数据存入redis。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221439586.png"></p><h3 id="核心实现"><a href="#核心实现" class="headerlink" title="核心实现"></a>核心实现</h3><p>代码思路：如果缓存有，则直接返回，如果缓存不存在，则查询数据库，然后存入redis。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221441395.png"></p><h3 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h3><p>缓存更新是redis为了节约内存而设计出来的一个东西，主要是因为内存数据宝贵，当我们向redis插入太多数据，此时就可能会导致缓存中的数据过多，所以redis会对部分数据进行更新，或者把他叫为<strong>淘汰</strong>更合适。</p><p><strong>内存淘汰：</strong> redis自动进行，当redis内存达到咱们设定的max-memery的时候，会自动触发淘汰机制，淘汰掉一些不重要的数据(可以自己设置策略方式)。</p><p><strong>超时剔除：</strong> 当我们给redis设置了过期时间ttl之后，redis会将超时的数据进行删除，方便咱们继续使用缓存。</p><p><strong>主动更新：</strong> 我们可以手动调用方法把缓存删掉，通常用于解决缓存和数据库不一致问题。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221443029.png"></p><h3 id="数据库缓存不一致解决方案"><a href="#数据库缓存不一致解决方案" class="headerlink" title="数据库缓存不一致解决方案"></a>数据库缓存不一致解决方案</h3><p>由于我们的<strong>缓存的数据源来自于数据库</strong>,而数据库的<strong>数据是会发生变化的</strong>,因此,如果当数据库中<strong>数据发生变化,而缓存却没有同步</strong>,此时就会有<strong>一致性问题存在</strong>,其后果是:</p><p>用户使用缓存中的过时数据,就会产生类似多线程数据安全问题,从而影响业务,产品口碑等;怎么解决呢？有如下几种方案</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221445394.png"></p><p>综合考虑使用方案一，但是方案一调用者如何处理呢？这里有几个问题</p><p>操作缓存和数据库时有三个问题需要考虑：</p><p>如果采用第一个方案，那么假设我们每次操作数据库后，都操作缓存，但是中间如果没有人查询，那么这个更新动作实际上只有最后一次生效，中间的更新动作意义并不大，我们可以把缓存删除，等待再次查询时，将缓存中的数据加载出来</p><ul><li><p>删除缓存还是更新缓存？</p><ul><li><p>更新缓存：每次更新数据库都更新缓存，无效写操作较多</p></li><li><p>删除缓存：更新数据库时让缓存失效，查询时再更新缓存</p></li></ul></li><li><p>如何保证缓存与数据库的操作的同时成功或失败？</p><ul><li><p>单体系统，将缓存与数据库操作放在一个事务</p></li><li><p>分布式系统，利用TCC等分布式事务方案</p></li></ul></li></ul><p>应该具体操作缓存还是操作数据库，我们应当是先操作数据库，再删除缓存，原因在于，如果你选择第一种方案，在两个线程并发来访问时，假设线程1先来，他先把缓存删了，此时线程2过来，他查询缓存数据并不存在，此时他写入缓存，当他写入缓存后，线程1再执行更新动作时，实际上写入的就是旧的数据，新的数据被旧数据覆盖了。</p><ul><li><p>先操作缓存还是先操作数据库？</p><ul><li><p>先删除缓存，再操作数据库</p></li><li><p>先操作数据库，再删除缓存</p></li></ul></li></ul><p>综合考虑还是<strong>先操作数据库，再删除缓存</strong>更优。</p><h3 id="双写一致-amp-解决思路"><a href="#双写一致-amp-解决思路" class="headerlink" title="双写一致&amp;解决思路"></a>双写一致&amp;解决思路</h3><p>根据id查询店铺时，如果缓存未命中，则查询数据库，将数据库结果写入缓存，并设置超时时间</p><p>根据id修改店铺时，先修改数据库，再删除缓存</p><p><strong>修改重点代码1</strong>：修改<strong>ShopServiceImpl</strong>的queryById方法</p><p><strong>设置redis缓存时添加过期时间</strong></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221449066.png"></p><p><strong>修改重点代码2</strong></p><p>代码分析：通过之前的淘汰，我们确定了<strong>采用删除策略，来解决双写问题</strong>，当我们修改了数据之后，然后把缓存中的数据进行删除，查询时发现缓存中没有数据，则会从mysql中加载最新的数据，从而避免数据库和缓存不一致的问题。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221450726.png"></p><h2 id="缓存穿透-amp-解决思路"><a href="#缓存穿透-amp-解决思路" class="headerlink" title="缓存穿透&amp;解决思路"></a>缓存穿透&amp;解决思路</h2><p>缓存穿透 ：缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。</p><p>常见的解决方案有两种：</p><ul><li><p>缓存空对象</p><ul><li><p>优点：实现简单，维护方便</p></li><li><p>缺点：</p><ul><li><p>额外的内存消耗</p></li><li><p>可能造成短期的不一致</p></li></ul></li></ul></li><li><p>布隆过滤</p><ul><li><p>优点：内存占用较少，没有多余key</p></li><li><p>缺点：</p><ul><li><p>实现复杂</p></li><li><p>存在误判可能</p></li></ul></li></ul></li></ul><p><strong>缓存空对象思路分析：</strong> 当我们客户端访问不存在的数据时，先请求redis，但是此时redis中没有数据，此时会访问到数据库，但是数据库中也没有数据，这个数据穿透了缓存，直击数据库，我们都知道数据库能够承载的并发不如redis这么高，如果大量的请求同时过来访问这种不存在的数据，这些请求就都会访问到数据库，简单的解决方案就是哪怕这个数据在数据库中也不存在，我们也把这个数据存入到redis中去，这样，下次用户过来访问这个不存在的数据，那么在redis中也能找到这个数据就不会进入到缓存了</p><p><strong>布隆过滤：</strong> 布隆过滤器其实采用的是哈希思想来解决这个问题，通过一个庞大的二进制数组，走哈希思想去判断当前这个要查询的这个数据是否存在，如果布隆过滤器判断存在，则放行，这个请求会去访问redis，哪怕此时redis中的数据过期了，但是数据库中一定存在这个数据，在数据库中查询出来这个数据后，再将其放入到redis中，假设布隆过滤器判断这个数据不存在，则直接返回。这种方式优点在于节约内存空间，<strong>存在误判</strong>，误判原因在于：布隆过滤器走的是哈希思想，只要哈希思想，就<strong>可能存在哈希冲突</strong>。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221452376.png"></p><p><strong>总结</strong></p><p>缓存穿透产生的原因是什么？</p><ul><li>用户请求的数据在缓存中和数据库中都不存在，不断发起这样的请求，给数据库带来巨大压力</li></ul><p>缓存穿透的解决方案有哪些？</p><ul><li><p>缓存null值</p></li><li><p>布隆过滤</p></li><li><p>增强id的复杂度，避免被猜测id规律</p></li><li><p>做好数据的基础格式校验</p></li><li><p>加强用户权限校验</p></li><li><p>做好热点参数的限流</p></li></ul><h2 id="缓存雪崩-amp-解决思路"><a href="#缓存雪崩-amp-解决思路" class="headerlink" title="缓存雪崩&amp;解决思路"></a>缓存雪崩&amp;解决思路</h2><p>缓存雪崩是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。</p><p>解决方案：</p><ul><li><p>给不同的Key的TTL添加随机值</p></li><li><p>利用Redis集群提高服务的可用性</p></li><li><p>给缓存业务添加降级限流策略</p></li><li><p>给业务添加多级缓存</p></li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221454922.png"></p><h2 id="缓存击穿-amp-解决思路"><a href="#缓存击穿-amp-解决思路" class="headerlink" title="缓存击穿&amp;解决思路"></a>缓存击穿&amp;解决思路</h2><p>缓存击穿问题也叫<strong>热点Key问题</strong>，就是一个<strong>被高并发访问并且缓存重建业务较复杂的key突然失效</strong>了，无数的请求访问会在瞬间给数据库带来巨大的冲击。</p><p>常见的解决方案有两种：</p><ul><li><p>互斥锁</p></li><li><p>逻辑过期</p></li></ul><p>逻辑分析：假设线程1在查询缓存之后，本来应该去查询数据库，然后把这个数据重新加载到缓存的，此时只要线程1走完这个逻辑，其他线程就都能从缓存中加载这些数据了，但是假设在线程1没有走完的时候，后续的线程2，线程3，线程4同时过来访问当前这个方法， 那么这些线程都不能从缓存中查询到数据，那么他们就会同一时刻来访问查询缓存，都没查到，接着同一时间去访问数据库，同时的去执行数据库代码，对数据库访问压力过大</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221456721.png"></p><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>解决方案一、<strong>使用锁来解决</strong>：</p><p>因为锁能实现互斥性。假设线程过来，只能一个人一个人的来访问数据库，从而避免对于数据库访问压力过大，但这也会影响查询的性能，因为此时会让查询的性能从并行变成了串行，我们可以采用tryLock方法 + double check来解决这样的问题。</p><p>假设现在线程1过来访问，他查询缓存没有命中，但是此时他获得到了锁的资源，那么线程1就会一个人去执行逻辑，假设现在线程2过来，线程2在执行过程中，并没有获得到锁，那么线程2就可以进行到休眠，直到线程1把锁释放后，线程2获得到锁，然后再来执行逻辑，此时就能够从缓存中拿到数据了。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221456099.png"></p><h3 id="逻辑过期"><a href="#逻辑过期" class="headerlink" title="逻辑过期"></a>逻辑过期</h3><p>解决方案二、<strong>逻辑过期方案</strong></p><p>方案分析：我们之所以会出现这个缓存击穿问题，主要原因是在于我们对key设置了过期时间，假设我们不设置过期时间，其实就不会有缓存击穿的问题，但是不设置过期时间，这样数据不就一直占用我们内存了吗，我们可以采用逻辑过期方案。</p><p>我们把过期时间设置在 redis的value中，注意：这个过期时间并不会直接作用于redis，而是我们后续通过逻辑去处理。假设线程1去查询缓存，然后从value中判断出来当前的数据已经过期了，此时线程1去获得互斥锁，那么其他线程会进行阻塞，获得了锁的线程他会开启一个 线程去进行 以前的重构数据的逻辑，直到新开的线程完成这个逻辑后，才释放锁， 而线程1直接进行返回，假设现在线程3过来访问，由于线程线程2持有着锁，所以线程3无法获得锁，线程3也直接返回数据，只有等到新开的线程2把重建数据构建完后，其他线程才能走返回正确的数据。</p><p>这种方案巧妙在于 <strong>，异步的构建缓存</strong>，缺点在于在构建完缓存之前，返回的都是<strong>脏数据</strong>。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221458607.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221458082.png"></p><h3 id="方案对比"><a href="#方案对比" class="headerlink" title="方案对比"></a>方案对比</h3><p><strong>互斥锁方案：</strong> 由于保证了互斥性，所以数据一致，且实现简单，因为仅仅只需要加一把锁而已，也没其他的事情需要操心，所以没有额外的内存消耗，缺点在于<strong>有锁就有死锁问题的发生</strong>，且<strong>只能串行执行性能肯定受到影响</strong>。</p><p><strong>逻辑过期方案：</strong> 线程读取过程中不需要等待，性能好，有一个额外的线程持有锁去进行重构数据，但是在重构数据完成前，其他的线程只能返回之前的数据，且实现起来比较复杂。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221500612.png"></p><h3 id="互斥锁实现"><a href="#互斥锁实现" class="headerlink" title="互斥锁实现"></a>互斥锁实现</h3><p>核心思路：相较于原来从缓存中查询不到数据后直接查询数据库而言，现在的方案是 进行查询之后，如果从缓存没有查询到数据，则进行互斥锁的获取，获取互斥锁后，判断是否获得到了锁，如果没有获得到，则休眠，过一会再进行尝试，直到获取到锁为止，才能进行查询</p><p>如果获取到了锁的线程，再去进行查询，查询后将数据写入redis，再释放锁，返回数据，利用互斥锁就能保证只有一个线程去执行操作数据库的逻辑，防止缓存击穿。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221502726.png"></p><p><strong>操作锁的代码：</strong></p><p>核心思路就是利用redis的<strong>setnx方法</strong>来表示获取锁，该方法含义是redis中如果没有这个key，则插入成功，返回1，在stringRedisTemplate中返回true， 如果有这个key则插入失败，则返回0，在stringRedisTemplate返回false，我们可以通过true，或者是false，来表示是否有线程成功插入key，成功插入的key的线程我们认为他就是获得到锁的线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(String key)</span> &#123;<br>    <span class="hljs-type">Boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-number">10</span>, TimeUnit.SECONDS);<br>    <span class="hljs-keyword">return</span> BooleanUtil.isTrue(flag);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">(String key)</span> &#123;<br>    stringRedisTemplate.delete(key);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>操作代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Shop <span class="hljs-title function_">queryWithMutex</span><span class="hljs-params">(Long id)</span>  &#123;<br>       <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> CACHE_SHOP_KEY + id;<br>       <span class="hljs-comment">// 1、从redis中查询商铺缓存</span><br>       <span class="hljs-type">String</span> <span class="hljs-variable">shopJson</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(<span class="hljs-string">&quot;key&quot;</span>);<br>       <span class="hljs-comment">// 2、判断是否存在</span><br>       <span class="hljs-keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;<br>           <span class="hljs-comment">// 存在,直接返回</span><br>           <span class="hljs-keyword">return</span> JSONUtil.toBean(shopJson, Shop.class);<br>       &#125;<br>       <span class="hljs-comment">//判断命中的值是否是空值</span><br>       <span class="hljs-keyword">if</span> (shopJson != <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-comment">//返回一个错误信息</span><br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>       &#125;<br>       <span class="hljs-comment">// 4.实现缓存重构</span><br>       <span class="hljs-comment">//4.1 获取互斥锁</span><br>       <span class="hljs-type">String</span> <span class="hljs-variable">lockKey</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;lock:shop:&quot;</span> + id;<br>       <span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>       <span class="hljs-keyword">try</span> &#123;<br>           <span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> tryLock(lockKey);<br>           <span class="hljs-comment">// 4.2 判断否获取成功</span><br>           <span class="hljs-keyword">if</span>(!isLock)&#123;<br>               <span class="hljs-comment">//4.3 失败，则休眠重试</span><br>               Thread.sleep(<span class="hljs-number">50</span>);<br>               <span class="hljs-keyword">return</span> queryWithMutex(id);<br>           &#125;<br>           <span class="hljs-comment">//4.4 成功，根据id查询数据库</span><br>            shop = getById(id);<br>           <span class="hljs-comment">// 5.不存在，返回错误</span><br>           <span class="hljs-keyword">if</span>(shop == <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-comment">//将空值写入redis</span><br>               stringRedisTemplate.opsForValue().set(key,<span class="hljs-string">&quot;&quot;</span>,CACHE_NULL_TTL,TimeUnit.MINUTES);<br>               <span class="hljs-comment">//返回错误信息</span><br>               <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>           &#125;<br>           <span class="hljs-comment">//6.写入redis</span><br>           stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(shop),CACHE_NULL_TTL,TimeUnit.MINUTES);<br><br>       &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>       &#125;<br>       <span class="hljs-keyword">finally</span> &#123;<br>           <span class="hljs-comment">//7.释放互斥锁</span><br>           unlock(lockKey);<br>       &#125;<br>       <span class="hljs-keyword">return</span> shop;<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="逻辑过期实现"><a href="#逻辑过期实现" class="headerlink" title="逻辑过期实现"></a>逻辑过期实现</h3><p><strong>需求：修改根据id查询商铺的业务，基于逻辑过期方式来解决缓存击穿问题</strong></p><p>思路分析：当用户开始查询redis时，判断是否命中，如果没有命中则直接返回空数据，不查询数据库，而一旦命中后，将value取出，判断value中的过期时间是否满足，如果没有过期，则直接返回redis中的数据，如果过期，则在开启独立线程后直接返回之前的数据，独立线程去重构数据，重构完成后释放互斥锁。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221504878.png"></p><p><strong>步骤一、</strong></p><p>如果封装数据：因为现在redis中存储的数据的value需要带上过期时间，此时要么你去修改原来的实体类，要么你新建一个实体类，我们采用第二个方案，这个方案，对原来代码没有侵入性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisData</span> &#123;<br>    <span class="hljs-keyword">private</span> LocalDateTime expireTime;<br>    <span class="hljs-keyword">private</span> Object data;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>步骤二、</strong></p><p>在<strong>ShopServiceImpl</strong> 新增此方法，利用单元测试进行缓存预热</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221506842.png"></p><p><strong>在测试类中</strong></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221507102.png"></p><p><strong>步骤三</strong></p><p><strong>ShopServiceImpl</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">CACHE_REBUILD_EXECUTOR</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br><span class="hljs-keyword">public</span> Shop <span class="hljs-title function_">queryWithLogicalExpire</span><span class="hljs-params">( Long id )</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> CACHE_SHOP_KEY + id;<br>    <span class="hljs-comment">// 1.从redis查询商铺缓存</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(key);<br>    <span class="hljs-comment">// 2.判断是否存在</span><br>    <span class="hljs-keyword">if</span> (StrUtil.isBlank(json)) &#123;<br>        <span class="hljs-comment">// 3.存在，直接返回</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">// 4.命中，需要先把json反序列化为对象</span><br>    <span class="hljs-type">RedisData</span> <span class="hljs-variable">redisData</span> <span class="hljs-operator">=</span> JSONUtil.toBean(json, RedisData.class);<br>    <span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), Shop.class);<br>    <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">expireTime</span> <span class="hljs-operator">=</span> redisData.getExpireTime();<br>    <span class="hljs-comment">// 5.判断是否过期</span><br>    <span class="hljs-keyword">if</span>(expireTime.isAfter(LocalDateTime.now())) &#123;<br>        <span class="hljs-comment">// 5.1.未过期，直接返回店铺信息</span><br>        <span class="hljs-keyword">return</span> shop;<br>    &#125;<br>    <span class="hljs-comment">// 5.2.已过期，需要缓存重建</span><br>    <span class="hljs-comment">// 6.缓存重建</span><br>    <span class="hljs-comment">// 6.1.获取互斥锁</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">lockKey</span> <span class="hljs-operator">=</span> LOCK_SHOP_KEY + id;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> tryLock(lockKey);<br>    <span class="hljs-comment">// 6.2.判断是否获取锁成功</span><br>    <span class="hljs-keyword">if</span> (isLock)&#123;<br>        CACHE_REBUILD_EXECUTOR.submit( ()-&gt;&#123;<br><br>            <span class="hljs-keyword">try</span>&#123;<br>                <span class="hljs-comment">//重建缓存</span><br>                <span class="hljs-built_in">this</span>.saveShop2Redis(id,<span class="hljs-number">20L</span>);<br>            &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<span class="hljs-keyword">finally</span> &#123;<br>                unlock(lockKey);<br>            &#125;<br>        &#125;);<br>    &#125;<br>    <span class="hljs-comment">// 6.4.返回过期的商铺信息</span><br>    <span class="hljs-keyword">return</span> shop;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="通用Redis工具类封装"><a href="#通用Redis工具类封装" class="headerlink" title="通用Redis工具类封装"></a>通用Redis工具类封装</h2><p>基于StringRedisTemplate封装一个缓存工具类，满足下列需求：</p><ul><li><p>方法1：将任意Java对象序列化为json并存储在string类型的key中，并且可以设置TTL过期时间</p></li><li><p>方法2：将任意Java对象序列化为json并存储在string类型的key中，并且可以设置逻辑过期时间，用于处理<strong>缓存击穿</strong>问题</p></li><li><p>方法3：根据指定的key查询缓存，并反序列化为指定类型，利用<strong>缓存空值</strong>的方式解决<strong>缓存穿透</strong>问题</p></li><li><p>方法4：根据指定的key查询缓存，并反序列化为指定类型，需要利用逻辑过期解决<strong>缓存击穿</strong>问题</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CacheClient</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">CACHE_REBUILD_EXECUTOR</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CacheClient</span><span class="hljs-params">(StringRedisTemplate stringRedisTemplate)</span> &#123;<br>        <span class="hljs-built_in">this</span>.stringRedisTemplate = stringRedisTemplate;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(String key, Object value, Long time, TimeUnit unit)</span> &#123;<br>        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time, unit);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setWithLogicalExpire</span><span class="hljs-params">(String key, Object value, Long time, TimeUnit unit)</span> &#123;<br>        <span class="hljs-comment">// 设置逻辑过期</span><br>        <span class="hljs-type">RedisData</span> <span class="hljs-variable">redisData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisData</span>();<br>        redisData.setData(value);<br>        redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(time)));<br>        <span class="hljs-comment">// 写入Redis</span><br>        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> &lt;R,ID&gt; R <span class="hljs-title function_">queryWithPassThrough</span><span class="hljs-params">(</span><br><span class="hljs-params">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span>&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> keyPrefix + id;<br>        <span class="hljs-comment">// 1.从redis查询商铺缓存</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(key);<br>        <span class="hljs-comment">// 2.判断是否存在</span><br>        <span class="hljs-keyword">if</span> (StrUtil.isNotBlank(json)) &#123;<br>            <span class="hljs-comment">// 3.存在，直接返回</span><br>            <span class="hljs-keyword">return</span> JSONUtil.toBean(json, type);<br>        &#125;<br>        <span class="hljs-comment">// 判断命中的是否是空值</span><br>        <span class="hljs-keyword">if</span> (json != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 返回一个错误信息</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 4.不存在，根据id查询数据库</span><br>        <span class="hljs-type">R</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> dbFallback.apply(id);<br>        <span class="hljs-comment">// 5.不存在，返回错误</span><br>        <span class="hljs-keyword">if</span> (r == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 将空值写入redis</span><br>            stringRedisTemplate.opsForValue().set(key, <span class="hljs-string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);<br>            <span class="hljs-comment">// 返回错误信息</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">// 6.存在，写入redis</span><br>        <span class="hljs-built_in">this</span>.set(key, r, time, unit);<br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> &lt;R, ID&gt; R <span class="hljs-title function_">queryWithLogicalExpire</span><span class="hljs-params">(</span><br><span class="hljs-params">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> keyPrefix + id;<br>        <span class="hljs-comment">// 1.从redis查询商铺缓存</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(key);<br>        <span class="hljs-comment">// 2.判断是否存在</span><br>        <span class="hljs-keyword">if</span> (StrUtil.isBlank(json)) &#123;<br>            <span class="hljs-comment">// 3.存在，直接返回</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">// 4.命中，需要先把json反序列化为对象</span><br>        <span class="hljs-type">RedisData</span> <span class="hljs-variable">redisData</span> <span class="hljs-operator">=</span> JSONUtil.toBean(json, RedisData.class);<br>        <span class="hljs-type">R</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), type);<br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">expireTime</span> <span class="hljs-operator">=</span> redisData.getExpireTime();<br>        <span class="hljs-comment">// 5.判断是否过期</span><br>        <span class="hljs-keyword">if</span>(expireTime.isAfter(LocalDateTime.now())) &#123;<br>            <span class="hljs-comment">// 5.1.未过期，直接返回店铺信息</span><br>            <span class="hljs-keyword">return</span> r;<br>        &#125;<br>        <span class="hljs-comment">// 5.2.已过期，需要缓存重建</span><br>        <span class="hljs-comment">// 6.缓存重建</span><br>        <span class="hljs-comment">// 6.1.获取互斥锁</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">lockKey</span> <span class="hljs-operator">=</span> LOCK_SHOP_KEY + id;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> tryLock(lockKey);<br>        <span class="hljs-comment">// 6.2.判断是否获取锁成功</span><br>        <span class="hljs-keyword">if</span> (isLock)&#123;<br>            <span class="hljs-comment">// 6.3.成功，开启独立线程，实现缓存重建</span><br>            CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 查询数据库</span><br>                    <span class="hljs-type">R</span> <span class="hljs-variable">newR</span> <span class="hljs-operator">=</span> dbFallback.apply(id);<br>                    <span class="hljs-comment">// 重建缓存</span><br>                    <span class="hljs-built_in">this</span>.setWithLogicalExpire(key, newR, time, unit);<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                &#125;<span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-comment">// 释放锁</span><br>                    unlock(lockKey);<br>                &#125;<br>            &#125;);<br>        &#125;<br>        <span class="hljs-comment">// 6.4.返回过期的商铺信息</span><br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> &lt;R, ID&gt; R <span class="hljs-title function_">queryWithMutex</span><span class="hljs-params">(</span><br><span class="hljs-params">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> keyPrefix + id;<br>        <span class="hljs-comment">// 1.从redis查询商铺缓存</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">shopJson</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(key);<br>        <span class="hljs-comment">// 2.判断是否存在</span><br>        <span class="hljs-keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;<br>            <span class="hljs-comment">// 3.存在，直接返回</span><br>            <span class="hljs-keyword">return</span> JSONUtil.toBean(shopJson, type);<br>        &#125;<br>        <span class="hljs-comment">// 判断命中的是否是空值</span><br>        <span class="hljs-keyword">if</span> (shopJson != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 返回一个错误信息</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 4.实现缓存重建</span><br>        <span class="hljs-comment">// 4.1.获取互斥锁</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">lockKey</span> <span class="hljs-operator">=</span> LOCK_SHOP_KEY + id;<br>        <span class="hljs-type">R</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> tryLock(lockKey);<br>            <span class="hljs-comment">// 4.2.判断是否获取成功</span><br>            <span class="hljs-keyword">if</span> (!isLock) &#123;<br>                <span class="hljs-comment">// 4.3.获取锁失败，休眠并重试</span><br>                Thread.sleep(<span class="hljs-number">50</span>);<br>                <span class="hljs-keyword">return</span> queryWithMutex(keyPrefix, id, type, dbFallback, time, unit);<br>            &#125;<br>            <span class="hljs-comment">// 4.4.获取锁成功，根据id查询数据库</span><br>            r = dbFallback.apply(id);<br>            <span class="hljs-comment">// 5.不存在，返回错误</span><br>            <span class="hljs-keyword">if</span> (r == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 将空值写入redis</span><br>                stringRedisTemplate.opsForValue().set(key, <span class="hljs-string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);<br>                <span class="hljs-comment">// 返回错误信息</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>            <span class="hljs-comment">// 6.存在，写入redis</span><br>            <span class="hljs-built_in">this</span>.set(key, r, time, unit);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 7.释放锁</span><br>            unlock(lockKey);<br>        &#125;<br>        <span class="hljs-comment">// 8.返回</span><br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(String key)</span> &#123;<br>        <span class="hljs-type">Boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-number">10</span>, TimeUnit.SECONDS);<br>        <span class="hljs-keyword">return</span> BooleanUtil.isTrue(flag);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">(String key)</span> &#123;<br>        stringRedisTemplate.delete(key);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在ShopServiceImpl 中使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> CacheClient cacheClient;<br><br> <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryById</span><span class="hljs-params">(Long id)</span> &#123;<br>        <span class="hljs-comment">// 解决缓存穿透</span><br>        <span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> cacheClient<br>                .queryWithPassThrough(CACHE_SHOP_KEY, id, Shop.class, <span class="hljs-built_in">this</span>::getById, CACHE_SHOP_TTL, TimeUnit.MINUTES);<br><br>        <span class="hljs-comment">// 互斥锁解决缓存击穿</span><br>        <span class="hljs-comment">// Shop shop = cacheClient</span><br>        <span class="hljs-comment">//         .queryWithMutex(CACHE_SHOP_KEY, id, Shop.class, this::getById, CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><br>        <span class="hljs-comment">// 逻辑过期解决缓存击穿</span><br>        <span class="hljs-comment">// Shop shop = cacheClient</span><br>        <span class="hljs-comment">//         .queryWithLogicalExpire(CACHE_SHOP_KEY, id, Shop.class, this::getById, 20L, TimeUnit.SECONDS);</span><br><br>        <span class="hljs-keyword">if</span> (shop == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;店铺不存在！&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 7.返回</span><br>        <span class="hljs-keyword">return</span> Result.ok(shop);<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="实现全局唯一ID"><a href="#实现全局唯一ID" class="headerlink" title="实现全局唯一ID"></a>实现全局唯一ID</h2><p>场景分析：如果我们的id具有太明显的规则，用户或者说商业对手很容易猜测出来我们的一些敏感信息，比如商城在一天时间内，卖出了多少单，这明显不合适。</p><p>场景分析二：随着我们商城规模越来越大，mysql的单表的容量不宜超过500W，数据量过大之后，我们要进行拆库拆表，但拆分表了之后，他们从逻辑上讲他们是同一张表，所以他们的id是不能一样的， 于是乎我们需要保证id的唯一性。</p><p><strong>全局ID生成器</strong>，是一种在分布式系统下用来生成全局唯一ID的工具，一般要满足下列特性：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221511092.png"></p><p>为了增加ID的安全性，我们可以不直接使用Redis自增的数值，而是拼接一些其它信息：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221511382.png"><br>ID的组成部分：符号位：1bit，永远为0。<br>时间戳：31bit，以秒为单位，可以使用69年。<br>序列号：32bit，秒内的计数器，支持每秒产生2^32个不同ID。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisIdWorker</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 开始时间戳</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">BEGIN_TIMESTAMP</span> <span class="hljs-operator">=</span> <span class="hljs-number">1640995200L</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 序列号的位数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">COUNT_BITS</span> <span class="hljs-operator">=</span> <span class="hljs-number">32</span>;<br><br>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RedisIdWorker</span><span class="hljs-params">(StringRedisTemplate stringRedisTemplate)</span> &#123;<br>        <span class="hljs-built_in">this</span>.stringRedisTemplate = stringRedisTemplate;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">nextId</span><span class="hljs-params">(String keyPrefix)</span> &#123;<br>        <span class="hljs-comment">// 1.生成时间戳</span><br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> LocalDateTime.now();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">nowSecond</span> <span class="hljs-operator">=</span> now.toEpochSecond(ZoneOffset.UTC);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">timestamp</span> <span class="hljs-operator">=</span> nowSecond - BEGIN_TIMESTAMP;<br><br>        <span class="hljs-comment">// 2.生成序列号</span><br>        <span class="hljs-comment">// 2.1.获取当前日期，精确到天</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy:MM:dd&quot;</span>));<br>        <span class="hljs-comment">// 2.2.自增长</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().increment(<span class="hljs-string">&quot;icr:&quot;</span> + keyPrefix + <span class="hljs-string">&quot;:&quot;</span> + date);<br><br>        <span class="hljs-comment">// 3.拼接并返回</span><br>        <span class="hljs-keyword">return</span> timestamp &lt;&lt; COUNT_BITS | count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="秒杀下单"><a href="#秒杀下单" class="headerlink" title="秒杀下单"></a>秒杀下单</h2><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221515025.png"></p><p>秒杀下单应该思考的内容：</p><p>下单时需要判断两点：</p><ul><li><p>秒杀是否开始或结束，如果尚未开始或已经结束则无法下单</p></li><li><p>库存是否充足，不足则无法下单</p></li></ul><p>下单核心逻辑分析：</p><p>当用户开始进行下单，我们应当去查询优惠卷信息，查询到优惠卷信息，判断是否满足秒杀条件</p><p>比如时间是否充足，如果时间充足，则进一步判断库存是否足够，如果两者都满足，则扣减库存，创建订单，然后返回订单id，如果有一个条件不满足则直接结束。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221515595.png"></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>VoucherOrderServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">seckillVoucher</span><span class="hljs-params">(Long voucherId)</span> &#123;<br>    <span class="hljs-comment">// 1.查询优惠券</span><br>    <span class="hljs-type">SeckillVoucher</span> <span class="hljs-variable">voucher</span> <span class="hljs-operator">=</span> seckillVoucherService.getById(voucherId);<br>    <span class="hljs-comment">// 2.判断秒杀是否开始</span><br>    <span class="hljs-keyword">if</span> (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;<br>        <span class="hljs-comment">// 尚未开始</span><br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀尚未开始！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 3.判断秒杀是否已经结束</span><br>    <span class="hljs-keyword">if</span> (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;<br>        <span class="hljs-comment">// 尚未开始</span><br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀已经结束！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 4.判断库存是否充足</span><br>    <span class="hljs-keyword">if</span> (voucher.getStock() &lt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 库存不足</span><br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;库存不足！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//5，扣减库存</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> seckillVoucherService.update()<br>            .setSql(<span class="hljs-string">&quot;stock= stock -1&quot;</span>)<br>            .eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).update();<br>    <span class="hljs-keyword">if</span> (!success) &#123;<br>        <span class="hljs-comment">//扣减库存</span><br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;库存不足！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//6.创建订单</span><br>    <span class="hljs-type">VoucherOrder</span> <span class="hljs-variable">voucherOrder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VoucherOrder</span>();<br>    <span class="hljs-comment">// 6.1.订单id</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> redisIdWorker.nextId(<span class="hljs-string">&quot;order&quot;</span>);<br>    voucherOrder.setId(orderId);<br>    <span class="hljs-comment">// 6.2.用户id</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    voucherOrder.setUserId(userId);<br>    <span class="hljs-comment">// 6.3.代金券id</span><br>    voucherOrder.setVoucherId(voucherId);<br>    save(voucherOrder);<br><br>    <span class="hljs-keyword">return</span> Result.ok(orderId);<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="超卖问题分析"><a href="#超卖问题分析" class="headerlink" title="超卖问题分析"></a>超卖问题分析</h3><p>有关超卖问题分析：在原有代码中是这么写的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (voucher.getStock() &lt; <span class="hljs-number">1</span>) &#123;<br>       <span class="hljs-comment">// 库存不足</span><br>       <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;库存不足！&quot;</span>);<br>   &#125;<br>   <span class="hljs-comment">//5，扣减库存</span><br>   <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> seckillVoucherService.update()<br>           .setSql(<span class="hljs-string">&quot;stock= stock -1&quot;</span>)<br>           .eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).update();<br>   <span class="hljs-keyword">if</span> (!success) &#123;<br>       <span class="hljs-comment">//扣减库存</span><br>       <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;库存不足！&quot;</span>);<br>   &#125;<br></code></pre></td></tr></table></figure><p>假设线程1过来查询库存，判断出来库存大于1，正准备去扣减库存，但是还没有来得及去扣减，此时线程2过来，线程2也去查询库存，发现这个数量一定也大于1，那么这两个线程都会去扣减库存，最终多个线程相当于一起去扣减库存，此时就会出现库存的超卖问题。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221516687.png"></p><p><strong>超卖问题是典型的多线程安全问题，针对这一问题的常见解决方案就是加锁</strong>：而对于加锁，我们通常有两种解决方案：见下图：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221517381.png"></p><p><strong>悲观锁：</strong></p><p>悲观锁可以实现对于数据的串行化执行，比如syn，和lock都是悲观锁的代表，同时，悲观锁中又可以再细分为公平锁，非公平锁，可重入锁，等等</p><p><strong>乐观锁：</strong></p><p>乐观锁：会有一个版本号，每次操作数据会对版本号+1，再提交回数据时，会去校验是否比之前的版本大1 ，如果大1 ，则进行操作成功，这套机制的核心逻辑在于，如果在操作过程中，版本号只比原来大1 ，那么就意味着操作过程中没有人对他进行过修改，他的操作就是安全的，如果不大1，则数据被修改过，当然乐观锁还有一些变种的处理方式比如cas</p><p>乐观锁的典型代表：就是<strong>cas</strong>，利用cas进行无锁化机制加锁，var5 是操作前读取的内存值，while中的var1+var2 是预估值，如果预估值 &#x3D;&#x3D; 内存值，则代表中间没有被人修改过，此时就将新值去替换 内存值</p><p>其中do while 是为了在操作失败时，再次进行自旋操作，即把之前的逻辑再操作一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> var5;<br><span class="hljs-keyword">do</span> &#123;<br>    var5 = <span class="hljs-built_in">this</span>.getIntVolatile(var1, var2);<br>&#125; <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));<br><br><span class="hljs-keyword">return</span> var5;<br></code></pre></td></tr></table></figure><h3 id="乐观锁解决超卖"><a href="#乐观锁解决超卖" class="headerlink" title="乐观锁解决超卖"></a>乐观锁解决超卖</h3><p><strong>修改代码方案一、</strong></p><p>VoucherOrderServiceImpl 在扣减库存时，改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> seckillVoucherService.update()<br>            .setSql(<span class="hljs-string">&quot;stock= stock -1&quot;</span>) <span class="hljs-comment">//set stock = stock -1</span><br>            .eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).eq(<span class="hljs-string">&quot;stock&quot;</span>,voucher.getStock()).update(); <span class="hljs-comment">//where id = ？ and stock = ?</span><br></code></pre></td></tr></table></figure><p>以上逻辑的核心含义是：只要我扣减库存时的库存和之前我查询到的库存是一样的，就意味着没有人在中间修改过库存，那么此时就是安全的，但是以上这种方式通过测试发现会有很多失败的情况，失败的原因在于：在使用乐观锁过程中假设100个线程同时都拿到了100的库存，然后大家一起去进行扣减，但是100个人中只有1个人能扣减成功，其他的人在处理时，他们在扣减时，库存已经被修改过了，所以此时其他线程都会失败</p><p><strong>修改代码方案二、</strong></p><p>之前的方式要修改前后都保持一致，但是这样我们分析过，成功的概率太低，所以我们的乐观锁需要变一下，改成stock大于0 即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> seckillVoucherService.update()<br>            .setSql(<span class="hljs-string">&quot;stock= stock -1&quot;</span>)<br>            .eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).update().gt(<span class="hljs-string">&quot;stock&quot;</span>,<span class="hljs-number">0</span>); <span class="hljs-comment">//where id = ? and stock &gt; 0</span><br></code></pre></td></tr></table></figure><h3 id="一人一单"><a href="#一人一单" class="headerlink" title="一人一单"></a>一人一单</h3><p>需求：修改秒杀业务，要求同一个优惠券，一个用户只能下一单</p><p><strong>现在的问题在于：</strong></p><p>优惠卷是为了引流，但是目前的情况是，一个人可以无限制的抢这个优惠卷，所以我们应当增加一层逻辑，让一个用户只能下一个单，而不是让一个用户下多个单</p><p>具体操作逻辑如下：比如时间是否充足，如果时间充足，则进一步判断库存是否足够，然后再根据优惠卷id和用户id查询是否已经下过这个订单，如果下过这个订单，则不再下单，否则进行下单。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221522253.png"></p><p><strong>初步代码：增加一人一单逻辑</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">seckillVoucher</span><span class="hljs-params">(Long voucherId)</span> &#123;<br>    <span class="hljs-comment">// 1.查询优惠券</span><br>    <span class="hljs-type">SeckillVoucher</span> <span class="hljs-variable">voucher</span> <span class="hljs-operator">=</span> seckillVoucherService.getById(voucherId);<br>    <span class="hljs-comment">// 2.判断秒杀是否开始</span><br>    <span class="hljs-keyword">if</span> (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;<br>        <span class="hljs-comment">// 尚未开始</span><br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀尚未开始！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 3.判断秒杀是否已经结束</span><br>    <span class="hljs-keyword">if</span> (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;<br>        <span class="hljs-comment">// 尚未开始</span><br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀已经结束！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 4.判断库存是否充足</span><br>    <span class="hljs-keyword">if</span> (voucher.getStock() &lt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 库存不足</span><br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;库存不足！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 5.一人一单逻辑</span><br>    <span class="hljs-comment">// 5.1.用户id</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> query().eq(<span class="hljs-string">&quot;user_id&quot;</span>, userId).eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).count();<br>    <span class="hljs-comment">// 5.2.判断是否存在</span><br>    <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 用户已经购买过了</span><br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;用户已经购买过一次！&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//6，扣减库存</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> seckillVoucherService.update()<br>            .setSql(<span class="hljs-string">&quot;stock= stock -1&quot;</span>)<br>            .eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).update();<br>    <span class="hljs-keyword">if</span> (!success) &#123;<br>        <span class="hljs-comment">//扣减库存</span><br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;库存不足！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//7.创建订单</span><br>    <span class="hljs-type">VoucherOrder</span> <span class="hljs-variable">voucherOrder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VoucherOrder</span>();<br>    <span class="hljs-comment">// 7.1.订单id</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> redisIdWorker.nextId(<span class="hljs-string">&quot;order&quot;</span>);<br>    voucherOrder.setId(orderId);<br><br>    voucherOrder.setUserId(userId);<br>    <span class="hljs-comment">// 7.3.代金券id</span><br>    voucherOrder.setVoucherId(voucherId);<br>    save(voucherOrder);<br><br>    <span class="hljs-keyword">return</span> Result.ok(orderId);<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>存在问题：</strong> 现在的问题还是和之前一样，并发过来，查询数据库，都不存在订单，所以我们还是需要加锁，但是<font color="#245bdb"><strong>乐观锁比较适合更新数据，而现在是插入数据，所以我们需要使用悲观锁</strong></font>操作。</p><p><strong>注意：</strong> 在这里提到了非常多的问题，我们需要慢慢的来思考，首先我们的初始方案是封装了一个createVoucherOrder方法，同时为了确保他线程安全，在方法上添加了一把synchronized 锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> Result <span class="hljs-title function_">createVoucherOrder</span><span class="hljs-params">(Long voucherId)</span> &#123;<br><br><span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>         <span class="hljs-comment">// 5.1.查询订单</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> query().eq(<span class="hljs-string">&quot;user_id&quot;</span>, userId).eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).count();<br>        <span class="hljs-comment">// 5.2.判断是否存在</span><br>        <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 用户已经购买过了</span><br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;用户已经购买过一次！&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 6.扣减库存</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> seckillVoucherService.update()<br>                .setSql(<span class="hljs-string">&quot;stock = stock - 1&quot;</span>) <span class="hljs-comment">// set stock = stock - 1</span><br>                .eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).gt(<span class="hljs-string">&quot;stock&quot;</span>, <span class="hljs-number">0</span>) <span class="hljs-comment">// where id = ? and stock &gt; 0</span><br>                .update();<br>        <span class="hljs-keyword">if</span> (!success) &#123;<br>            <span class="hljs-comment">// 扣减失败</span><br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;库存不足！&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 7.创建订单</span><br>        <span class="hljs-type">VoucherOrder</span> <span class="hljs-variable">voucherOrder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VoucherOrder</span>();<br>        <span class="hljs-comment">// 7.1.订单id</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> redisIdWorker.nextId(<span class="hljs-string">&quot;order&quot;</span>);<br>        voucherOrder.setId(orderId);<br>        <span class="hljs-comment">// 7.2.用户id</span><br>        voucherOrder.setUserId(userId);<br>        <span class="hljs-comment">// 7.3.代金券id</span><br>        voucherOrder.setVoucherId(voucherId);<br>        save(voucherOrder);<br><br>        <span class="hljs-comment">// 7.返回订单id</span><br>        <span class="hljs-keyword">return</span> Result.ok(orderId);<br>&#125;<br></code></pre></td></tr></table></figure><p>但是这样添加锁，锁的粒度太粗了，在使用锁过程中，控制<strong>锁粒度</strong> 是一个非常重要的事情，因为<strong>如果锁的粒度太大，会导致每个线程进来都会锁住</strong>，所以我们需要去控制锁的粒度，以下这段代码需要修改为： intern() 这个方法是从常量池中拿到数据，如果我们直接使用userId.toString() 他拿到的对象实际上是不同的对象，new出来的对象，我们使用锁必须保证锁必须是同一把，所以我们需要使用intern()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span>  Result <span class="hljs-title function_">createVoucherOrder</span><span class="hljs-params">(Long voucherId)</span> &#123;<br><span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br><span class="hljs-keyword">synchronized</span>(userId.toString().intern())&#123;<br>         <span class="hljs-comment">// 5.1.查询订单</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> query().eq(<span class="hljs-string">&quot;user_id&quot;</span>, userId).eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).count();<br>        <span class="hljs-comment">// 5.2.判断是否存在</span><br>        <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 用户已经购买过了</span><br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;用户已经购买过一次！&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 6.扣减库存</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> seckillVoucherService.update()<br>                .setSql(<span class="hljs-string">&quot;stock = stock - 1&quot;</span>) <span class="hljs-comment">// set stock = stock - 1</span><br>                .eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).gt(<span class="hljs-string">&quot;stock&quot;</span>, <span class="hljs-number">0</span>) <span class="hljs-comment">// where id = ? and stock &gt; 0</span><br>                .update();<br>        <span class="hljs-keyword">if</span> (!success) &#123;<br>            <span class="hljs-comment">// 扣减失败</span><br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;库存不足！&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 7.创建订单</span><br>        <span class="hljs-type">VoucherOrder</span> <span class="hljs-variable">voucherOrder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VoucherOrder</span>();<br>        <span class="hljs-comment">// 7.1.订单id</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> redisIdWorker.nextId(<span class="hljs-string">&quot;order&quot;</span>);<br>        voucherOrder.setId(orderId);<br>        <span class="hljs-comment">// 7.2.用户id</span><br>        voucherOrder.setUserId(userId);<br>        <span class="hljs-comment">// 7.3.代金券id</span><br>        voucherOrder.setVoucherId(voucherId);<br>        save(voucherOrder);<br><br>        <span class="hljs-comment">// 7.返回订单id</span><br>        <span class="hljs-keyword">return</span> Result.ok(orderId);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是以上代码还是存在问题，问题的原因在于<strong>当前方法被spring的事务控制，如果你在方法内部加锁，可能会导致当前方法事务还没有提交，但是锁已经释放也会导致问题</strong>，所以我们选择将当前方法整体包裹起来，确保事务不会出现问题：如下：</p><p>在seckillVoucher 方法中，添加以下逻辑，这样就能保证事务的特性，同时也控制了锁的粒度。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221525127.png"></p><p>但是以上做法依然有问题，因为你调用的方法，其实是this.的方式调用的，<strong>事务想要生效，还得利用代理来生效，所以这个地方，我们需要获得原始的事务对象</strong>， 来操作事务。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221525056.png"></p><p>（PS：汗流浃背了。。。）</p><h3 id="集群环境下的并发问题"><a href="#集群环境下的并发问题" class="headerlink" title="集群环境下的并发问题"></a>集群环境下的并发问题</h3><p>通过加锁可以解决在单机情况下的一人一单安全问题，但是在集群模式下就不行了。</p><p>1、我们将服务启动两份，端口分别为8081和8082</p><p>2、然后修改nginx的conf目录下的nginx.conf文件，配置反向代理和负载均衡</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221527442.png"></p><p><strong>具体操作(略)</strong></p><p><strong>有关锁失效原因分析</strong></p><p>由于现在我们部署了多个tomcat，每个tomcat都有一个属于自己的jvm，那么假设在服务器A的tomcat内部，有两个线程，这两个线程由于使用的是同一份代码，那么他们的锁对象是同一个，是可以实现互斥的，但是如果现在是服务器B的tomcat内部，又有两个线程，但是他们的锁对象写的虽然和服务器A一样，但是锁对象却不是同一个，所以线程3和线程4可以实现互斥，但是却无法和线程1和线程2实现互斥，这就是 集群环境下，syn锁失效的原因，在这种情况下，我们就需要使用分布式锁来解决这个问题。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221528458.png"></p><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><h3 id="基本原理和实现方式对比"><a href="#基本原理和实现方式对比" class="headerlink" title="基本原理和实现方式对比"></a>基本原理和实现方式对比</h3><p>分布式锁：满足分布式系统或集群模式下多进程可见并且互斥的锁。</p><p>分布式锁的核心思想就是<strong>让大家都使用同一把锁</strong>，只要大家使用的是同一把锁，那么我们就能锁住线程，不让线程进行，让程序串行执行，这就是分布式锁的核心思路。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221530470.png"></p><p>那么分布式锁他应该满足一些什么样的条件呢？</p><p>可见性：多个线程都能看到相同的结果，注意：这个地方说的可见性并不是并发编程中指的内存可见性，只是说多个进程之间都能感知到变化的意思</p><p>互斥：互斥是分布式锁的最基本的条件，使得程序串行执行</p><p>高可用：程序不易崩溃，时时刻刻都保证较高的可用性</p><p>高性能：由于加锁本身就让性能降低，所有对于分布式锁本身需要他就较高的加锁性能和释放锁性能</p><p>安全性：安全也是程序中必不可少的一环</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221531211.png"></p><p>常见的分布式锁有三种</p><p>Mysql：mysql本身就带有锁机制，但是由于mysql性能本身一般，所以采用分布式锁的情况下，其实使用mysql作为分布式锁比较少见</p><p>Redis：redis作为分布式锁是非常常见的一种使用方式，现在企业级开发中基本都使用redis或者zookeeper作为分布式锁，利用<strong>setnx</strong>这个方法，如果插入key成功，则表示获得到了锁，如果有人插入成功，其他人插入失败则表示无法获得到锁，利用这套逻辑来实现分布式锁</p><p>Zookeeper：zookeeper也是企业级开发中较好的一个实现分布式锁的方案，由于本套视频并不讲解zookeeper的原理和分布式锁的实现，所以不过多阐述</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221531248.png"></p><h3 id="Redis分布式锁核心"><a href="#Redis分布式锁核心" class="headerlink" title="Redis分布式锁核心"></a>Redis分布式锁核心</h3><p>实现分布式锁时需要实现的两个基本方法：</p><ul><li><p>获取锁：</p><ul><li><p>互斥：确保只能有一个线程获取锁</p></li><li><p>非阻塞：尝试一次，成功返回true，失败返回false</p></li></ul></li><li><p>释放锁：</p><ul><li><p>手动释放</p></li><li><p>超时释放：获取锁时添加一个超时时间</p></li></ul></li></ul><p>核心思路：</p><p>我们利用redis 的setNx 方法，当有多个线程进入时，我们就利用该方法，第一个线程进入时，redis 中就有这个key 了，返回了1，如果结果是1，则表示他抢到了锁，那么他去执行业务，然后再删除锁，退出锁逻辑，没有抢到锁的哥们，等待一定时间后重试即可。</p><h3 id="实现分布式锁"><a href="#实现分布式锁" class="headerlink" title="实现分布式锁"></a>实现分布式锁</h3><p><strong>锁的基本接口</strong></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221534208.png"></p><p><strong>SimpleRedisLock</strong></p><p>利用setnx方法进行加锁，同时增加过期时间，防止死锁，此方法可以保证加锁和增加过期时间具有原子性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String KEY_PREFIX=<span class="hljs-string">&quot;lock:&quot;</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> timeoutSec)</span> &#123;<br>    <span class="hljs-comment">// 获取线程标示</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> Thread.currentThread().getId()<br>    <span class="hljs-comment">// 获取锁</span><br>    <span class="hljs-type">Boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue()<br>            .setIfAbsent(KEY_PREFIX + name, threadId + <span class="hljs-string">&quot;&quot;</span>, timeoutSec, TimeUnit.SECONDS);<br>    <span class="hljs-keyword">return</span> Boolean.TRUE.equals(success);<br>&#125;<br></code></pre></td></tr></table></figure><p>释放锁逻辑</p><p>SimpleRedisLock</p><p>释放锁，防止删除别人的锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//通过del删除锁</span><br>    stringRedisTemplate.delete(KEY_PREFIX + name);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>修改业务代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">seckillVoucher</span><span class="hljs-params">(Long voucherId)</span> &#123;<br>      <span class="hljs-comment">// 1.查询优惠券</span><br>      <span class="hljs-type">SeckillVoucher</span> <span class="hljs-variable">voucher</span> <span class="hljs-operator">=</span> seckillVoucherService.getById(voucherId);<br>      <span class="hljs-comment">// 2.判断秒杀是否开始</span><br>      <span class="hljs-keyword">if</span> (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;<br>          <span class="hljs-comment">// 尚未开始</span><br>          <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀尚未开始！&quot;</span>);<br>      &#125;<br>      <span class="hljs-comment">// 3.判断秒杀是否已经结束</span><br>      <span class="hljs-keyword">if</span> (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;<br>          <span class="hljs-comment">// 尚未开始</span><br>          <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀已经结束！&quot;</span>);<br>      &#125;<br>      <span class="hljs-comment">// 4.判断库存是否充足</span><br>      <span class="hljs-keyword">if</span> (voucher.getStock() &lt; <span class="hljs-number">1</span>) &#123;<br>          <span class="hljs-comment">// 库存不足</span><br>          <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;库存不足！&quot;</span>);<br>      &#125;<br>      <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>      <span class="hljs-comment">//创建锁对象(新增代码)</span><br>      <span class="hljs-type">SimpleRedisLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleRedisLock</span>(<span class="hljs-string">&quot;order:&quot;</span> + userId, stringRedisTemplate);<br>      <span class="hljs-comment">//获取锁对象</span><br>      <span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> lock.tryLock(<span class="hljs-number">1200</span>);<br><span class="hljs-comment">//加锁失败</span><br>      <span class="hljs-keyword">if</span> (!isLock) &#123;<br>          <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;不允许重复下单&quot;</span>);<br>      &#125;<br>      <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-comment">//获取代理对象(事务)</span><br>          <span class="hljs-type">IVoucherOrderService</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (IVoucherOrderService) AopContext.currentProxy();<br>          <span class="hljs-keyword">return</span> proxy.createVoucherOrder(voucherId);<br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>          <span class="hljs-comment">//释放锁</span><br>          lock.unlock();<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="锁误删"><a href="#锁误删" class="headerlink" title="锁误删"></a>锁误删</h3><p>逻辑说明：</p><p>持有锁的线程在锁的内部出现了阻塞，导致他的锁自动释放，这时其他线程，线程2来尝试获得锁，就拿到了这把锁，然后线程2在持有锁执行过程中，线程1反应过来，继续执行，而线程1执行过程中，走到了删除锁逻辑，此时就会把本应该属于线程2的锁进行删除，这就是误删别人锁的情况说明</p><p>解决方案：解决方案就是在每个线程释放锁的时候，去判断一下当前这把锁是否属于自己，如果属于自己，则不进行锁的删除，假设还是上边的情况，线程1卡顿，锁自动释放，线程2进入到锁的内部执行逻辑，此时线程1反应过来，然后删除锁，但是线程1，一看当前这把锁不是属于自己，于是不进行删除锁逻辑，当线程2走到删除锁逻辑时，如果没有卡过自动释放锁的时间点，则判断当前这把锁是属于自己的，于是删除这把锁。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221536580.png"></p><h3 id="锁误删解决思路"><a href="#锁误删解决思路" class="headerlink" title="锁误删解决思路"></a>锁误删解决思路</h3><p>需求：修改之前的分布式锁实现，满足：在获取锁时存入线程标示（可以用UUID表示） 在释放锁时先获取锁中的线程标示，判断是否与当前线程标示一致</p><ul><li><p>如果一致则释放锁</p></li><li><p>如果不一致则不释放锁</p></li></ul><p>核心逻辑：在存入锁时，放入自己线程的标识，在删除锁时，判断当前这把锁的标识是不是自己存入的，如果是，则进行删除，如果不是，则不进行删除。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221537907.png"></p><p>具体代码如下：加锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ID_PREFIX</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString(<span class="hljs-literal">true</span>) + <span class="hljs-string">&quot;-&quot;</span>;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> timeoutSec)</span> &#123;<br>   <span class="hljs-comment">// 获取线程标示</span><br>   <span class="hljs-type">String</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> ID_PREFIX + Thread.currentThread().getId();<br>   <span class="hljs-comment">// 获取锁</span><br>   <span class="hljs-type">Boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue()<br>                .setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS);<br>   <span class="hljs-keyword">return</span> Boolean.TRUE.equals(success);<br>&#125;<br></code></pre></td></tr></table></figure><p>释放锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 获取线程标示</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> ID_PREFIX + Thread.currentThread().getId();<br>    <span class="hljs-comment">// 获取锁中的标示</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);<br>    <span class="hljs-comment">// 判断标示是否一致</span><br>    <span class="hljs-keyword">if</span>(threadId.equals(id)) &#123;<br>        <span class="hljs-comment">// 释放锁</span><br>        stringRedisTemplate.delete(KEY_PREFIX + name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="分布式锁的原子性"><a href="#分布式锁的原子性" class="headerlink" title="分布式锁的原子性"></a>分布式锁的原子性</h3><p>更为极端的误删逻辑说明：</p><p>线程1现在持有锁之后，在执行业务逻辑过程中，他正准备删除锁，而且已经走到了条件判断的过程中，比如他已经拿到了当前这把锁确实是属于他自己的，正准备删除锁，但是此时他的锁到期了，那么此时线程2进来，但是线程1他会接着往后执行，当他卡顿结束后，他直接就会执行删除锁那行代码，相当于条件判断并没有起到作用，这就是删锁时的原子性问题，之所以有这个问题，是因为线程1的拿锁，比锁，删锁，实际上并不是<strong>原子性</strong>的。</p><p>Redis提供了Lua脚本功能，在一个脚本中编写多条Redis命令，确保多条命令执行时的原子性。Lua是一种编程语言，它的基本语法大家可以参考网站：<a href="https://www.runoob.com/lua/lua-tutorial.html">https://www.runoob.com/lua/lua-tutorial.html</a>，这里重点介绍Redis提供的调用函数，我们可以使用lua去操作redis，又能保证他的原子性，这样就可以实现拿锁比锁删锁是一个原子性动作了。</p><p>这里重点介绍Redis提供的调用函数，语法如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">redis.call(<span class="hljs-string">&#x27;命令名称&#x27;</span>, <span class="hljs-string">&#x27;key&#x27;</span>, <span class="hljs-string">&#x27;其它参数&#x27;</span>, ...)<br></code></pre></td></tr></table></figure><p>例如，要执行set name jack，则脚本是这样：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua"># 执行 set name jack<br>redis.call(<span class="hljs-string">&#x27;set&#x27;</span>, <span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;jack&#x27;</span>)<br></code></pre></td></tr></table></figure><p>例如，要先执行set name Rose，再执行get name，则脚本如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua"># 先执行 set name jack<br>redis.call(<span class="hljs-string">&#x27;set&#x27;</span>, <span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;Rose&#x27;</span>)<br># 再执行 get name<br><span class="hljs-keyword">local</span> name = redis.call(<span class="hljs-string">&#x27;get&#x27;</span>, <span class="hljs-string">&#x27;name&#x27;</span>)<br># 返回<br><span class="hljs-keyword">return</span> name<br></code></pre></td></tr></table></figure><p>如果脚本中的key、value不想写死，可以作为参数传递。key类型参数会放入KEYS数组，其它参数会放入ARGV数组，在脚本中可以从KEYS和ARGV数组获取这些参数：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221543641.png"></p><p>接下来我们来回一下我们释放锁的逻辑：</p><p>释放锁的业务流程是这样的</p><p>1、获取锁中的线程标示</p><p>2、判断是否与指定的标示（当前线程标示）一致</p><p>3、如果一致则释放锁（删除）</p><p>4、如果不一致则什么都不做</p><p>如果用Lua脚本来表示则是这样的：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 这里的 KEYS[1] 就是锁的key，这里的ARGV[1] 就是当前线程标示</span><br><span class="hljs-comment">-- 获取锁中的标示，判断是否与当前线程标示一致</span><br><span class="hljs-keyword">if</span> (redis.call(<span class="hljs-string">&#x27;GET&#x27;</span>, KEYS[<span class="hljs-number">1</span>]) == ARGV[<span class="hljs-number">1</span>]) <span class="hljs-keyword">then</span><br>  <span class="hljs-comment">-- 一致，则删除锁</span><br>  <span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">&#x27;DEL&#x27;</span>, KEYS[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">end</span><br><span class="hljs-comment">-- 不一致，则直接返回</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h3 id="利用Java代码调用Lua脚本改造分布式锁"><a href="#利用Java代码调用Lua脚本改造分布式锁" class="headerlink" title="利用Java代码调用Lua脚本改造分布式锁"></a>利用Java代码调用Lua脚本改造分布式锁</h3><p>我们的RedisTemplate中，可以利用execute方法去执行lua脚本，参数对应关系就如下图:</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221546523.png"></p><p><strong>java代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;<br>    <span class="hljs-keyword">static</span> &#123;<br>        UNLOCK_SCRIPT = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>&lt;&gt;();<br>        UNLOCK_SCRIPT.setLocation(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathResource</span>(<span class="hljs-string">&quot;unlock.lua&quot;</span>));<br>        UNLOCK_SCRIPT.setResultType(Long.class);<br>    &#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 调用lua脚本</span><br>    stringRedisTemplate.execute(<br>            UNLOCK_SCRIPT,<br>            Collections.singletonList(KEY_PREFIX + name),<br>            ID_PREFIX + Thread.currentThread().getId());<br>&#125;<br><span class="hljs-comment">//经过以上代码改造后，我们就能够实现 拿锁比锁删锁的原子性动作了~</span><br></code></pre></td></tr></table></figure><h2 id="redission"><a href="#redission" class="headerlink" title="redission"></a>redission</h2><p>基于setnx实现的分布式锁存在下面的问题：</p><p><strong>重入问题</strong>：重入问题是指 获得锁的线程可以再次进入到相同的锁的代码块中，可重入锁的意义在于防止死锁，比如HashTable这样的代码中，他的方法都是使用synchronized修饰的，假如他在一个方法内，调用另一个方法，那么此时如果是不可重入的，不就死锁了吗？所以可重入锁他的主要意义是防止死锁，我们的synchronized和Lock锁都是可重入的。</p><p><strong>不可重试</strong>：是指目前的分布式只能尝试一次，我们认为合理的情况是：当线程在获得锁失败后，他应该能再次尝试获得锁。</p><p><strong>超时释放：</strong>我们在加锁时增加了过期时间，这样的我们可以防止死锁，但是如果卡顿的时间超长，虽然我们采用了lua表达式防止删锁的时候，误删别人的锁，但是毕竟没有锁住，有安全隐患</p><p><strong>主从一致性：</strong> 如果Redis提供了主从集群，当我们向集群写数据时，主机需要异步的将数据同步给从机，而万一在同步过去之前，主机宕机了，就会出现死锁问题。</p><p>那么什么是Redission呢</p><p>Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。</p><p>Redission提供了分布式锁的多种多样的功能</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221550578.png"></p><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>引入依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pom">&lt;dependency&gt;<br>&lt;groupId&gt;org.redisson&lt;/groupId&gt;<br>&lt;artifactId&gt;redisson&lt;/artifactId&gt;<br>&lt;version&gt;3.13.6&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><p>配置Redisson客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedissonConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RedissonClient <span class="hljs-title function_">redissonClient</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// 配置</span><br>        <span class="hljs-type">Config</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Config</span>();<br>        config.useSingleServer().setAddress(<span class="hljs-string">&quot;redis://192.168.150.101:6379&quot;</span>)<br>            .setPassword(<span class="hljs-string">&quot;123321&quot;</span>);<br>        <span class="hljs-comment">// 创建RedissonClient对象</span><br>        <span class="hljs-keyword">return</span> Redisson.create(config);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>如何使用Redission的分布式锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> RedissionClient redissonClient;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testRedisson</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>    <span class="hljs-comment">//获取锁(可重入)，指定锁的名称</span><br>    <span class="hljs-type">RLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> redissonClient.getLock(<span class="hljs-string">&quot;anyLock&quot;</span>);<br>    <span class="hljs-comment">//尝试获取锁，参数分别是：获取锁的最大等待时间(期间会重试)，锁自动释放时间，时间单位</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> lock.tryLock(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>,TimeUnit.SECONDS);<br>    <span class="hljs-comment">//判断获取锁成功</span><br>    <span class="hljs-keyword">if</span>(isLock)&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;执行业务&quot;</span>);          <br>        &#125;<span class="hljs-keyword">finally</span>&#123;<br>            <span class="hljs-comment">//释放锁</span><br>            lock.unlock();<br>        &#125;<br>        <br>    &#125;<br>    <br>    <br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>在 VoucherOrderServiceImpl</p><p>注入RedissonClient</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> RedissonClient redissonClient;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">seckillVoucher</span><span class="hljs-params">(Long voucherId)</span> &#123;<br>        <span class="hljs-comment">// 1.查询优惠券</span><br>        <span class="hljs-type">SeckillVoucher</span> <span class="hljs-variable">voucher</span> <span class="hljs-operator">=</span> seckillVoucherService.getById(voucherId);<br>        <span class="hljs-comment">// 2.判断秒杀是否开始</span><br>        <span class="hljs-keyword">if</span> (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;<br>            <span class="hljs-comment">// 尚未开始</span><br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀尚未开始！&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 3.判断秒杀是否已经结束</span><br>        <span class="hljs-keyword">if</span> (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;<br>            <span class="hljs-comment">// 尚未开始</span><br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀已经结束！&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 4.判断库存是否充足</span><br>        <span class="hljs-keyword">if</span> (voucher.getStock() &lt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">// 库存不足</span><br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;库存不足！&quot;</span>);<br>        &#125;<br>        <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>        <span class="hljs-comment">//创建锁对象 这个代码不用了，因为我们现在要使用分布式锁</span><br>        <span class="hljs-comment">//SimpleRedisLock lock = new SimpleRedisLock(&quot;order:&quot; + userId, stringRedisTemplate);</span><br>        <span class="hljs-type">RLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> redissonClient.getLock(<span class="hljs-string">&quot;lock:order:&quot;</span> + userId);<br>        <span class="hljs-comment">//获取锁对象</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> lock.tryLock();<br>       <br><span class="hljs-comment">//加锁失败</span><br>        <span class="hljs-keyword">if</span> (!isLock) &#123;<br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;不允许重复下单&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//获取代理对象(事务)</span><br>            <span class="hljs-type">IVoucherOrderService</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (IVoucherOrderService) AopContext.currentProxy();<br>            <span class="hljs-keyword">return</span> proxy.createVoucherOrder(voucherId);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">//释放锁</span><br>            lock.unlock();<br>        &#125;<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="redission可重入锁原理"><a href="#redission可重入锁原理" class="headerlink" title="redission可重入锁原理"></a>redission可重入锁原理</h3><p>在Lock锁中，他是借助于底层的一个voaltile的一个state变量来记录重入的状态的，比如当前没有人持有这把锁，那么state&#x3D;0，假如有人持有这把锁，那么state&#x3D;1，如果持有这把锁的人再次持有这把锁，那么state就会+1 ，如果是对于synchronized而言，他在c语言代码中会有一个count，原理和state类似，也是重入一次就加一，释放一次就-1 ，直到减少成0 时，表示当前这把锁没有被人持有。</p><p>在redission中，我们的也支持支持可重入锁</p><p>Redisson是基于hash结构实现的，记录线程id和重入次数。代替了自定义锁时用的string结构。每一次获取锁的时候先判断锁是否存在，如果不存在就直接获取，如果已经存在那么不代表获取锁失败了，这时候如果发现线程标识就是当前线程，那么就代表我可以再次获取，只用把重入次数加1。将来在释放锁的时候，每释放一次，重入次数就减一，知道重入次数减为0，证明走到最外层，所有业务都结束了，在真正的释放锁。从而实现所的可重入。这个和jdk提供的reententLock原理是基本一致的。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221556772.png"></p><h3 id="锁重试和WatchDog机制"><a href="#锁重试和WatchDog机制" class="headerlink" title="锁重试和WatchDog机制"></a>锁重试和WatchDog机制</h3><p>Redission的锁重试机制<strong>是在Redisson是基于信号量，和PubSub发布订阅这样功能实现的</strong>。在第一次尝试获取锁失败以后，不是立即失败，而是做一个等待。等待什么呢？等待一个释放锁的消息，利用pubsub机制。而获取锁成功的线程在释放锁的时候去发布这样一个消息，从而被捕获到。当捕获到这个消息时，就可以去重新尝试获取锁了，如果再次获取又失败了，就可以继续去等待这样一个锁释放的信号，然后再次去重试，从而实现重试机制。当然这个重试也不是无限制的，会有一个等待的时间，如果超过了时间就不在等待了。因为重试机制采用了等待唤醒这种方案，所以并不会过多的占用cpu。效率还是不错的。</p><p>WatchDog机制可以延续锁时间。默认情况下，如果锁超过默认时间还没有结束，看门狗会自动续期1&#x2F;3 的时间。</p><h3 id="MultiLock原理"><a href="#MultiLock原理" class="headerlink" title="MultiLock原理"></a>MultiLock原理</h3><p>为了提高redis的可用性，我们会搭建集群或者主从，现在以主从为例</p><p>此时我们去写命令，写在主机上， 主机会将数据同步给从机，但是假设在主机还没有来得及把数据写入到从机去的时候，此时主机宕机，哨兵会发现主机宕机，并且选举一个slave变成master，而此时新的master中实际上并没有锁信息，此时锁信息就已经丢掉了。</p><p>为了解决这个问题，redission提出来了MutiLock锁，使用这把锁咱们<strong>就不使用主从了，每个节点的地位都是一样的， 这把锁加锁的逻辑需要写入到每一个主丛节点上</strong>，只有所有的服务器都写入成功，此时才是加锁成功，假设现在某个节点挂了，那么他去获得锁的时候，只要有一个节点拿不到，都不能算是加锁成功，就保证了加锁的可靠性。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221604632.png"></p><p><strong>MutiLock 加锁原理</strong>：</p><p>当我们去设置了多个锁时，redission会将多个锁添加到一个集合中，然后用while循环去不停去尝试拿锁，但是会有一个总共的加锁时间，这个时间是用需要加锁的个数 * 1500ms ，假设有3个锁，那么时间就是4500ms，假设在这4500ms内，所有的锁都加锁成功， 那么此时才算是加锁成功，如果在4500ms有线程加锁失败，则会再次去进行重试。</p><h2 id="秒杀优化"><a href="#秒杀优化" class="headerlink" title="秒杀优化"></a>秒杀优化</h2><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221606285.png"></p><h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>回顾一下下单流程</p><p>当用户发起请求，此时会请求nginx，nginx会访问到tomcat，而tomcat中的程序，会进行串行操作，分成如下几个步骤</p><p>1、查询优惠卷</p><p>2、判断秒杀库存是否足够</p><p>3、查询订单</p><p>4、校验是否是一人一单</p><p>5、扣减库存</p><p>6、创建订单</p><p>在这六步操作中，又有很多操作是要去操作数据库的，而且还是一个线程串行执行， 这样就会导致我们的程序执行的很慢，所以我们需要异步程序执行，那么如何加速呢？</p><p>我们现在来看看整体思路：当用户下单之后，判断库存是否充足只需要导redis中去根据key找对应的value是否大于0即可，如果不充足，则直接结束，如果充足，继续在redis中判断用户是否可以下单，如果set集合中没有这条数据，说明他可以下单，如果set集合中没有这条记录，则将userId和优惠卷存入到redis中，并且返回0，整个过程需要保证是原子性的，我们可以使用lua来操作</p><p>当以上判断逻辑走完之后，我们可以判断当前redis中返回的结果是否是0 ，如果是0，则表示可以下单，则将之前说的信息存入到到queue中去，然后返回，然后再来个线程异步的下单，前端可以通过返回的订单id来判断是否下单成功。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221611242.png"></p><h3 id="秒杀资格判断"><a href="#秒杀资格判断" class="headerlink" title="秒杀资格判断"></a>秒杀资格判断</h3><p>需求：</p><ul><li><p>新增秒杀优惠券的同时，将优惠券信息保存到Redis中</p></li><li><p>基于Lua脚本，判断秒杀库存、一人一单，决定用户是否抢购成功</p></li><li><p>如果抢购成功，将优惠券id和用户id封装后存入阻塞队列</p></li><li><p>开启线程任务，不断从阻塞队列中获取信息，实现异步下单功能</p></li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221612515.png"></p><p>VoucherServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addSeckillVoucher</span><span class="hljs-params">(Voucher voucher)</span> &#123;<br>    <span class="hljs-comment">// 保存优惠券</span><br>    save(voucher);<br>    <span class="hljs-comment">// 保存秒杀信息</span><br>    <span class="hljs-type">SeckillVoucher</span> <span class="hljs-variable">seckillVoucher</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SeckillVoucher</span>();<br>    seckillVoucher.setVoucherId(voucher.getId());<br>    seckillVoucher.setStock(voucher.getStock());<br>    seckillVoucher.setBeginTime(voucher.getBeginTime());<br>    seckillVoucher.setEndTime(voucher.getEndTime());<br>    seckillVoucherService.save(seckillVoucher);<br>    <span class="hljs-comment">// 保存秒杀库存到Redis中</span><br>    <span class="hljs-comment">//SECKILL_STOCK_KEY 这个变量定义在RedisConstans中</span><br>    <span class="hljs-comment">//private static final String SECKILL_STOCK_KEY =&quot;seckill:stock:&quot;</span><br>    stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString());<br>&#125;<br></code></pre></td></tr></table></figure><p>完整lua脚本</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 1.参数列表</span><br><span class="hljs-comment">-- 1.1.优惠券id</span><br><span class="hljs-keyword">local</span> voucherId = ARGV[<span class="hljs-number">1</span>]<br><span class="hljs-comment">-- 1.2.用户id</span><br><span class="hljs-keyword">local</span> userId = ARGV[<span class="hljs-number">2</span>]<br><span class="hljs-comment">-- 1.3.订单id</span><br><span class="hljs-keyword">local</span> orderId = ARGV[<span class="hljs-number">3</span>]<br><br><span class="hljs-comment">-- 2.数据key</span><br><span class="hljs-comment">-- 2.1.库存key</span><br><span class="hljs-keyword">local</span> stockKey = <span class="hljs-string">&#x27;seckill:stock:&#x27;</span> .. voucherId<br><span class="hljs-comment">-- 2.2.订单key</span><br><span class="hljs-keyword">local</span> orderKey = <span class="hljs-string">&#x27;seckill:order:&#x27;</span> .. voucherId<br><br><span class="hljs-comment">-- 3.脚本业务</span><br><span class="hljs-comment">-- 3.1.判断库存是否充足 get stockKey</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">tonumber</span>(redis.call(<span class="hljs-string">&#x27;get&#x27;</span>, stockKey)) &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">then</span><br>    <span class="hljs-comment">-- 3.2.库存不足，返回1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">end</span><br><span class="hljs-comment">-- 3.2.判断用户是否下单 SISMEMBER orderKey userId</span><br><span class="hljs-keyword">if</span>(redis.call(<span class="hljs-string">&#x27;sismember&#x27;</span>, orderKey, userId) == <span class="hljs-number">1</span>) <span class="hljs-keyword">then</span><br>    <span class="hljs-comment">-- 3.3.存在，说明是重复下单，返回2</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br><span class="hljs-keyword">end</span><br><span class="hljs-comment">-- 3.4.扣库存 incrby stockKey -1</span><br>redis.call(<span class="hljs-string">&#x27;incrby&#x27;</span>, stockKey, <span class="hljs-number">-1</span>)<br><span class="hljs-comment">-- 3.5.下单（保存用户）sadd orderKey userId</span><br>redis.call(<span class="hljs-string">&#x27;sadd&#x27;</span>, orderKey, userId)<br><span class="hljs-comment">-- 3.6.发送消息到队列中， XADD stream.orders * k1 v1 k2 v2 ...</span><br>redis.call(<span class="hljs-string">&#x27;xadd&#x27;</span>, <span class="hljs-string">&#x27;stream.orders&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-string">&#x27;userId&#x27;</span>, userId, <span class="hljs-string">&#x27;voucherId&#x27;</span>, voucherId, <span class="hljs-string">&#x27;id&#x27;</span>, orderId)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>当以上lua表达式执行完毕后，剩下的就是根据步骤3,4来执行我们接下来的任务了</p><p>VoucherOrderServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">seckillVoucher</span><span class="hljs-params">(Long voucherId)</span> &#123;<br>    <span class="hljs-comment">//获取用户</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-type">long</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> redisIdWorker.nextId(<span class="hljs-string">&quot;order&quot;</span>);<br>    <span class="hljs-comment">// 1.执行lua脚本</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> stringRedisTemplate.execute(<br>            SECKILL_SCRIPT,<br>            Collections.emptyList(),<br>            voucherId.toString(), userId.toString(), String.valueOf(orderId)<br>    );<br>    <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> result.intValue();<br>    <span class="hljs-comment">// 2.判断结果是否为0</span><br>    <span class="hljs-keyword">if</span> (r != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 2.1.不为0 ，代表没有购买资格</span><br>        <span class="hljs-keyword">return</span> Result.fail(r == <span class="hljs-number">1</span> ? <span class="hljs-string">&quot;库存不足&quot;</span> : <span class="hljs-string">&quot;不能重复下单&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//TODO 保存阻塞队列</span><br>    <span class="hljs-comment">// 3.返回订单id</span><br>    <span class="hljs-keyword">return</span> Result.ok(orderId);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="基于阻塞队列实现秒杀优化"><a href="#基于阻塞队列实现秒杀优化" class="headerlink" title="基于阻塞队列实现秒杀优化"></a>基于阻塞队列实现秒杀优化</h3><p>VoucherOrderServiceImpl</p><p>修改下单动作，现在我们去下单时，是通过lua表达式去原子执行判断逻辑，如果判断出来不为0 ，则要么是库存不足，要么是重复下单，返回错误信息，如果是0，则把下单的逻辑保存到队列中去，然后异步执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//异步处理线程池</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">SECKILL_ORDER_EXECUTOR</span> <span class="hljs-operator">=</span> Executors.newSingleThreadExecutor();<br><br><span class="hljs-comment">//在类初始化之后执行，因为当这个类初始化好了之后，随时都是有可能要执行的</span><br><span class="hljs-meta">@PostConstruct</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>   SECKILL_ORDER_EXECUTOR.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">VoucherOrderHandler</span>());<br>&#125;<br><span class="hljs-comment">// 用于线程池处理的任务</span><br><span class="hljs-comment">// 当初始化完毕后，就会去从对列中去拿信息</span><br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VoucherOrderHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 1.获取队列中的订单信息</span><br>                    <span class="hljs-type">VoucherOrder</span> <span class="hljs-variable">voucherOrder</span> <span class="hljs-operator">=</span> orderTasks.take();<br>                    <span class="hljs-comment">// 2.创建订单</span><br>                    handleVoucherOrder(voucherOrder);<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    log.error(<span class="hljs-string">&quot;处理订单异常&quot;</span>, e);<br>                &#125;<br>           &#125;<br>        &#125;<br>     <br>       <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleVoucherOrder</span><span class="hljs-params">(VoucherOrder voucherOrder)</span> &#123;<br>            <span class="hljs-comment">//1.获取用户</span><br>            <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> voucherOrder.getUserId();<br>            <span class="hljs-comment">// 2.创建锁对象</span><br>            <span class="hljs-type">RLock</span> <span class="hljs-variable">redisLock</span> <span class="hljs-operator">=</span> redissonClient.getLock(<span class="hljs-string">&quot;lock:order:&quot;</span> + userId);<br>            <span class="hljs-comment">// 3.尝试获取锁</span><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> redisLock.lock();<br>            <span class="hljs-comment">// 4.判断是否获得锁成功</span><br>            <span class="hljs-keyword">if</span> (!isLock) &#123;<br>                <span class="hljs-comment">// 获取锁失败，直接返回失败或者重试</span><br>                log.error(<span class="hljs-string">&quot;不允许重复下单！&quot;</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//注意：由于是spring的事务是放在threadLocal中，此时的是多线程，事务会失效</span><br>                proxy.createVoucherOrder(voucherOrder);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">// 释放锁</span><br>                redisLock.unlock();<br>            &#125;<br>    &#125;<br>     <span class="hljs-comment">//a</span><br><span class="hljs-keyword">private</span> BlockingQueue&lt;VoucherOrder&gt; orderTasks =<span class="hljs-keyword">new</span>  <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">seckillVoucher</span><span class="hljs-params">(Long voucherId)</span> &#123;<br>        <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> redisIdWorker.nextId(<span class="hljs-string">&quot;order&quot;</span>);<br>        <span class="hljs-comment">// 1.执行lua脚本</span><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> stringRedisTemplate.execute(<br>                SECKILL_SCRIPT,<br>                Collections.emptyList(),<br>                voucherId.toString(), userId.toString(), String.valueOf(orderId)<br>        );<br>        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> result.intValue();<br>        <span class="hljs-comment">// 2.判断结果是否为0</span><br>        <span class="hljs-keyword">if</span> (r != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 2.1.不为0 ，代表没有购买资格</span><br>            <span class="hljs-keyword">return</span> Result.fail(r == <span class="hljs-number">1</span> ? <span class="hljs-string">&quot;库存不足&quot;</span> : <span class="hljs-string">&quot;不能重复下单&quot;</span>);<br>        &#125;<br>        <span class="hljs-type">VoucherOrder</span> <span class="hljs-variable">voucherOrder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VoucherOrder</span>();<br>        <span class="hljs-comment">// 2.3.订单id</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> redisIdWorker.nextId(<span class="hljs-string">&quot;order&quot;</span>);<br>        voucherOrder.setId(orderId);<br>        <span class="hljs-comment">// 2.4.用户id</span><br>        voucherOrder.setUserId(userId);<br>        <span class="hljs-comment">// 2.5.代金券id</span><br>        voucherOrder.setVoucherId(voucherId);<br>        <span class="hljs-comment">// 2.6.放入阻塞队列</span><br>        orderTasks.add(voucherOrder);<br>        <span class="hljs-comment">//3.获取代理对象</span><br>         proxy = (IVoucherOrderService)AopContext.currentProxy();<br>        <span class="hljs-comment">//4.返回订单id</span><br>        <span class="hljs-keyword">return</span> Result.ok(orderId);<br>    &#125;<br>     <br>      <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">createVoucherOrder</span><span class="hljs-params">(VoucherOrder voucherOrder)</span> &#123;<br>        <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> voucherOrder.getUserId();<br>        <span class="hljs-comment">// 5.1.查询订单</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> query().eq(<span class="hljs-string">&quot;user_id&quot;</span>, userId).eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherOrder.getVoucherId()).count();<br>        <span class="hljs-comment">// 5.2.判断是否存在</span><br>        <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 用户已经购买过了</span><br>           log.error(<span class="hljs-string">&quot;用户已经购买过了&quot;</span>);<br>           <span class="hljs-keyword">return</span> ;<br>        &#125;<br><br>        <span class="hljs-comment">// 6.扣减库存</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> seckillVoucherService.update()<br>                .setSql(<span class="hljs-string">&quot;stock = stock - 1&quot;</span>) <span class="hljs-comment">// set stock = stock - 1</span><br>                .eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherOrder.getVoucherId()).gt(<span class="hljs-string">&quot;stock&quot;</span>, <span class="hljs-number">0</span>) <span class="hljs-comment">// where id = ? and stock &gt; 0</span><br>                .update();<br>        <span class="hljs-keyword">if</span> (!success) &#123;<br>            <span class="hljs-comment">// 扣减失败</span><br>            log.error(<span class="hljs-string">&quot;库存不足&quot;</span>);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        save(voucherOrder);<br> <br>    &#125;<br><br></code></pre></td></tr></table></figure><p><strong>总结：</strong></p><p>秒杀业务的优化思路是什么？</p><ul><li><p>先利用Redis完成库存余量、一人一单判断，完成抢单业务</p></li><li><p>再将下单业务放入阻塞队列，利用独立线程异步下单</p></li><li><p>基于阻塞队列的异步秒杀存在哪些问题？</p><ul><li><p>内存限制问题</p></li><li><p>数据安全问题</p></li></ul></li></ul><h2 id="Redis消息队列"><a href="#Redis消息队列" class="headerlink" title="Redis消息队列"></a>Redis消息队列</h2><h3 id="认识Redis消息队列"><a href="#认识Redis消息队列" class="headerlink" title="认识Redis消息队列"></a>认识Redis消息队列</h3><p>什么是消息队列：字面意思就是存放消息的队列。最简单的消息队列模型包括3个角色：</p><ul><li><p>消息队列：存储和管理消息，也被称为消息代理（Message Broker）</p></li><li><p>生产者：发送消息到消息队列</p></li><li><p>消费者：从消息队列获取消息并处理消息</p></li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221616588.png"></p><p>使用队列的好处在于 <strong>解耦：</strong> 所谓解耦，举一个生活中的例子就是：快递员(生产者)把快递放到快递柜里边(Message Queue)去，我们(消费者)从快递柜里边去拿东西，这就是一个异步，如果耦合，那么这个快递员相当于直接把快递交给你，这事固然好，但是万一你不在家，那么快递员就会一直等你，这就浪费了快递员的时间，所以这种思想在我们日常开发中，是非常有必要的。</p><p>这种场景在我们秒杀中就变成了：我们下单之后，利用redis去进行校验下单条件，再通过队列把消息发送出去，然后再启动一个线程去消费这个消息，完成解耦，同时也加快我们的响应速度。</p><p>这里我们可以使用一些现成的mq，比如kafka，rabbitmq等等，但是呢，如果没有安装mq，我们也可以直接使用redis提供的mq方案，降低我们的部署和学习成本。</p><h3 id="基于List实现消息队列"><a href="#基于List实现消息队列" class="headerlink" title="基于List实现消息队列"></a>基于List实现消息队列</h3><p><strong>基于List结构模拟消息队列</strong></p><p>消息队列（Message Queue），字面意思就是存放消息的队列。而Redis的list数据结构是一个双向链表，很容易模拟出队列效果。</p><p>队列是入口和出口不在一边，因此我们可以利用：LPUSH 结合 RPOP、或者 RPUSH 结合 LPOP来实现。 不过要注意的是，当队列中没有消息时RPOP或LPOP操作会返回null，并不像JVM的阻塞队列那样会阻塞并等待消息。因此这里应该使用BRPOP或者BLPOP来实现阻塞效果。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221618256.png"></p><p>基于List的消息队列有哪些优缺点？ 优点：</p><ul><li><p>利用Redis存储，不受限于JVM内存上限</p></li><li><p>基于Redis的持久化机制，数据安全性有保证</p></li><li><p>可以满足消息有序性</p></li></ul><p>缺点：</p><ul><li><p>无法避免消息丢失</p></li><li><p>只支持单消费者</p></li></ul><h3 id="基于PubSub的消息队列"><a href="#基于PubSub的消息队列" class="headerlink" title="基于PubSub的消息队列"></a>基于PubSub的消息队列</h3><p>PubSub（发布订阅）是Redis2.0版本引入的消息传递模型。顾名思义，消费者可以订阅一个或多个channel，生产者向对应channel发送消息后，所有订阅者都能收到相关消息。</p><p>SUBSCRIBE channel [channel] ：订阅一个或多个频道 PUBLISH channel msg ：向一个频道发送消息 PSUBSCRIBE pattern[pattern] ：订阅与pattern格式匹配的所有频道</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221619037.png"></p><p>基于PubSub的消息队列有哪些优缺点？ 优点：</p><ul><li>采用发布订阅模型，支持多生产、多消费</li></ul><p>缺点：</p><ul><li><p>不支持数据持久化</p></li><li><p>无法避免消息丢失</p></li><li><p>消息堆积有上限，超出时数据丢失</p></li></ul><h3 id="基于Stream的消息队列"><a href="#基于Stream的消息队列" class="headerlink" title="基于Stream的消息队列"></a>基于Stream的消息队列</h3><p>Stream 是 Redis 5.0 引入的一种新数据类型，可以实现一个功能非常完善的消息队列。</p><p>发送消息的命令：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221620874.png"></p><p>例如：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221620898.png"></p><p>读取消息的方式之一：XREAD</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221620831.png"></p><p>例如：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221620949.png"></p><p>XREAD阻塞方式，读取最新的消息：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221621294.png"></p><p>在业务开发中，我们可以循环的调用XREAD阻塞方式来查询最新消息，从而<strong>实现持续监听队列的效果</strong>，伪代码如下</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221621689.png"></p><p>STREAM类型消息队列的XREAD命令特点：</p><ul><li><p>消息可回溯</p></li><li><p>一个消息可以被多个消费者读取</p></li><li><p>可以阻塞读取</p></li><li><p>有消息漏读的风险</p></li></ul><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221622374.png"></p><h2 id="点赞功能"><a href="#点赞功能" class="headerlink" title="点赞功能"></a>点赞功能</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/likes/&#123;id&#125;&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryBlogLikes</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;<br>    <span class="hljs-comment">//修改点赞数量</span><br>    blogService.update().setSql(<span class="hljs-string">&quot;liked = liked +1 &quot;</span>).eq(<span class="hljs-string">&quot;id&quot;</span>,id).update();<br>    <span class="hljs-keyword">return</span> Result.ok();<br>&#125;<br></code></pre></td></tr></table></figure><p>问题分析：这种方式会导致一个用户无限点赞，明显是不合理的</p><p>造成这个问题的原因是，我们现在的逻辑，发起请求只是给数据库+1，所以才会出现这个问题。</p><p>完善点赞功能</p><p>需求：</p><ul><li><p>同一个用户只能点赞一次，再次点击则取消点赞</p></li><li><p>如果当前用户已经点赞，则点赞按钮高亮显示（前端已实现，判断字段Blog类的isLike属性）</p></li></ul><p>实现步骤：</p><ul><li><p>给Blog类中添加一个isLike字段，标示是否被当前用户点赞</p></li><li><p>修改点赞功能，利用Redis的set集合判断是否点赞过，未点赞过则点赞数+1，已点赞过则点赞数-1</p></li><li><p>修改根据id查询Blog的业务，判断当前登录用户是否点赞过，赋值给isLike字段</p></li><li><p>修改分页查询Blog业务，判断当前登录用户是否点赞过，赋值给isLike字段</p></li></ul><p>为什么采用set集合：</p><p>因为我们的数据是不能重复的，当用户操作过之后，无论他怎么操作，都是</p><p>具体步骤：</p><p>1、在Blog 添加一个字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@TableField(exist = false)</span><br><span class="hljs-keyword">private</span> Boolean isLike;<br></code></pre></td></tr></table></figure><p>2、修改代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">likeBlog</span><span class="hljs-params">(Long id)</span>&#123;<br>       <span class="hljs-comment">// 1.获取登录用户</span><br>       <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>       <span class="hljs-comment">// 2.判断当前登录用户是否已经点赞</span><br>       <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> BLOG_LIKED_KEY + id;<br>       <span class="hljs-type">Boolean</span> <span class="hljs-variable">isMember</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForSet().isMember(key, userId.toString());<br>       <span class="hljs-keyword">if</span>(BooleanUtil.isFalse(isMember))&#123;<br>            <span class="hljs-comment">//3.如果未点赞，可以点赞</span><br>           <span class="hljs-comment">//3.1 数据库点赞数+1</span><br>           <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> update().setSql(<span class="hljs-string">&quot;liked = liked + 1&quot;</span>).eq(<span class="hljs-string">&quot;id&quot;</span>, id).update();<br>           <span class="hljs-comment">//3.2 保存用户到Redis的set集合</span><br>           <span class="hljs-keyword">if</span>(isSuccess)&#123;<br>               stringRedisTemplate.opsForSet().add(key,userId.toString());<br>           &#125;<br>       &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">//4.如果已点赞，取消点赞</span><br>           <span class="hljs-comment">//4.1 数据库点赞数-1</span><br>           <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> update().setSql(<span class="hljs-string">&quot;liked = liked - 1&quot;</span>).eq(<span class="hljs-string">&quot;id&quot;</span>, id).update();<br>           <span class="hljs-comment">//4.2 把用户从Redis的set集合移除</span><br>           <span class="hljs-keyword">if</span>(isSuccess)&#123;<br>               stringRedisTemplate.opsForSet().remove(key,userId.toString());<br>           &#125;<br>       &#125;<br></code></pre></td></tr></table></figure><h2 id="排行榜功能"><a href="#排行榜功能" class="headerlink" title="排行榜功能"></a>排行榜功能</h2><p>在探店笔记的详情页面，应该把给该笔记点赞的人显示出来，比如最早点赞的TOP5，形成点赞排行榜：</p><p>之前的点赞是放到set集合，但是set集合是不能排序的，所以这个时候，咱们可以采用一个可以排序的set集合，就是咱们的sortedSet。</p><p>所有点赞的人，需要是唯一的，所以我们应当使用set或者是sortedSet</p><p>其次我们需要排序，就可以直接锁定使用sortedSet</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221626843.png"></p><p>修改代码</p><p>BlogServiceImpl</p><p>点赞逻辑代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br> <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">likeBlog</span><span class="hljs-params">(Long id)</span> &#123;<br>     <span class="hljs-comment">// 1.获取登录用户</span><br>     <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>     <span class="hljs-comment">// 2.判断当前登录用户是否已经点赞</span><br>     <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> BLOG_LIKED_KEY + id;<br>     <span class="hljs-type">Double</span> <span class="hljs-variable">score</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForZSet().score(key, userId.toString());<br>     <span class="hljs-keyword">if</span> (score == <span class="hljs-literal">null</span>) &#123;<br>         <span class="hljs-comment">// 3.如果未点赞，可以点赞</span><br>         <span class="hljs-comment">// 3.1.数据库点赞数 + 1</span><br>         <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> update().setSql(<span class="hljs-string">&quot;liked = liked + 1&quot;</span>).eq(<span class="hljs-string">&quot;id&quot;</span>, id).update();<br>         <span class="hljs-comment">// 3.2.保存用户到Redis的set集合  zadd key value score</span><br>         <span class="hljs-keyword">if</span> (isSuccess) &#123;<br>             stringRedisTemplate.opsForZSet().add(key, userId.toString(), System.currentTimeMillis());<br>         &#125;<br>     &#125; <span class="hljs-keyword">else</span> &#123;<br>         <span class="hljs-comment">// 4.如果已点赞，取消点赞</span><br>         <span class="hljs-comment">// 4.1.数据库点赞数 -1</span><br>         <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> update().setSql(<span class="hljs-string">&quot;liked = liked - 1&quot;</span>).eq(<span class="hljs-string">&quot;id&quot;</span>, id).update();<br>         <span class="hljs-comment">// 4.2.把用户从Redis的set集合移除</span><br>         <span class="hljs-keyword">if</span> (isSuccess) &#123;<br>             stringRedisTemplate.opsForZSet().remove(key, userId.toString());<br>         &#125;<br>     &#125;<br>     <span class="hljs-keyword">return</span> Result.ok();<br> &#125;<br><br><br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">isBlogLiked</span><span class="hljs-params">(Blog blog)</span> &#123;<br>     <span class="hljs-comment">// 1.获取登录用户</span><br>     <span class="hljs-type">UserDTO</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> UserHolder.getUser();<br>     <span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span>) &#123;<br>         <span class="hljs-comment">// 用户未登录，无需查询是否点赞</span><br>         <span class="hljs-keyword">return</span>;<br>     &#125;<br>     <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> user.getId();<br>     <span class="hljs-comment">// 2.判断当前登录用户是否已经点赞</span><br>     <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;blog:liked:&quot;</span> + blog.getId();<br>     <span class="hljs-type">Double</span> <span class="hljs-variable">score</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForZSet().score(key, userId.toString());<br>     blog.setIsLike(score != <span class="hljs-literal">null</span>);<br> &#125;<br></code></pre></td></tr></table></figure><p>点赞列表查询列表</p><p>BlogController</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/likes/&#123;id&#125;&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryBlogLikes</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;<br><br>    <span class="hljs-keyword">return</span> blogService.queryBlogLikes(id);<br>&#125;<br></code></pre></td></tr></table></figure><p>BlogService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryBlogLikes</span><span class="hljs-params">(Long id)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> BLOG_LIKED_KEY + id;<br>    <span class="hljs-comment">// 1.查询top5的点赞用户 zrange key 0 4</span><br>    Set&lt;String&gt; top5 = stringRedisTemplate.opsForZSet().range(key, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>);<br>    <span class="hljs-keyword">if</span> (top5 == <span class="hljs-literal">null</span> || top5.isEmpty()) &#123;<br>        <span class="hljs-keyword">return</span> Result.ok(Collections.emptyList());<br>    &#125;<br>    <span class="hljs-comment">// 2.解析出其中的用户id</span><br>    List&lt;Long&gt; ids = top5.stream().map(Long::valueOf).collect(Collectors.toList());<br>    <span class="hljs-type">String</span> <span class="hljs-variable">idStr</span> <span class="hljs-operator">=</span> StrUtil.join(<span class="hljs-string">&quot;,&quot;</span>, ids);<br>    <span class="hljs-comment">// 3.根据用户id查询用户 WHERE id IN ( 5 , 1 ) ORDER BY FIELD(id, 5, 1)</span><br>    List&lt;UserDTO&gt; userDTOS = userService.query()<br>            .in(<span class="hljs-string">&quot;id&quot;</span>, ids).last(<span class="hljs-string">&quot;ORDER BY FIELD(id,&quot;</span> + idStr + <span class="hljs-string">&quot;)&quot;</span>).list()<br>            .stream()<br>            .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class))<br>            .collect(Collectors.toList());<br>    <span class="hljs-comment">// 4.返回</span><br>    <span class="hljs-keyword">return</span> Result.ok(userDTOS);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="用户签到"><a href="#用户签到" class="headerlink" title="用户签到"></a>用户签到</h2><p>我们针对签到功能完全可以通过mysql来完成，比如说以下这张表</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221628669.png"></p><p>用户一次签到，就是一条记录，假如有1000万用户，平均每人每年签到次数为10次，则这张表一年的数据量为 1亿条</p><p>每签到一次需要使用（8 + 8 + 1 + 1 + 3 + 1）共22 字节的内存，一个月则最多需要600多字节</p><p>我们如何能够简化一点呢？其实可以考虑小时候一个挺常见的方案，就是小时候，咱们准备一张小小的卡片，你只要签到就打上一个勾，我最后判断你是否签到，其实只需要到小卡片上看一看就知道了</p><p>我们可以采用类似这样的方案来实现我们的签到需求。</p><p>我们按月来统计用户签到信息，签到记录为1，未签到则记录为0.</p><p>把每一个bit位对应当月的每一天，形成了映射关系。用0和1标示业务状态，这种思路就称为位图（BitMap）。这样我们就用极小的空间，来实现了大量数据的表示</p><p>Redis中是利用string类型数据结构实现BitMap，因此最大上限是512M，转换为bit则是 2^32个bit位。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221628054.png"></p><p>BitMap的操作命令有：</p><ul><li><p>SETBIT：向指定位置（offset）存入一个0或1</p></li><li><p>GETBIT ：获取指定位置（offset）的bit值</p></li><li><p>BITCOUNT ：统计BitMap中值为1的bit位的数量</p></li><li><p>BITFIELD ：操作（查询、修改、自增）BitMap中bit数组中的指定位置（offset）的值</p></li><li><p>BITFIELD_RO ：获取BitMap中bit数组，并以十进制形式返回</p></li><li><p>BITOP ：将多个BitMap的结果做位运算（与 、或、异或）</p></li><li><p>BITPOS ：查找bit数组中指定范围内第一个0或1出现的位置</p></li></ul><h3 id="需求实现"><a href="#需求实现" class="headerlink" title="需求实现"></a>需求实现</h3><p>需求：实现签到接口，将当前用户当天签到信息保存到Redis中</p><p>思路：我们可以把年和月作为bitMap的key，然后保存到一个bitMap中，每次签到就到对应的位上把数字从0变成1，只要对应是1，就表明说明这一天已经签到了，反之则没有签到。</p><p>我们通过接口文档发现，此接口并没有传递任何的参数，没有参数怎么确实是哪一天签到呢？这个很容易，可以通过后台代码直接获取即可，然后到对应的地址上去修改bitMap。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221629849.png"></p><p><strong>代码</strong></p><p>UserController</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;/sign&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">sign</span><span class="hljs-params">()</span>&#123;<br>   <span class="hljs-keyword">return</span> userService.sign();<br>&#125;<br></code></pre></td></tr></table></figure><p>UserServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">sign</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 1.获取当前登录用户</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-comment">// 2.获取日期</span><br>    <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> LocalDateTime.now();<br>    <span class="hljs-comment">// 3.拼接key</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">keySuffix</span> <span class="hljs-operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;:yyyyMM&quot;</span>));<br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> USER_SIGN_KEY + userId + keySuffix;<br>    <span class="hljs-comment">// 4.获取今天是本月的第几天</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">dayOfMonth</span> <span class="hljs-operator">=</span> now.getDayOfMonth();<br>    <span class="hljs-comment">// 5.写入Redis SETBIT key offset 1</span><br>    stringRedisTemplate.opsForValue().setBit(key, dayOfMonth - <span class="hljs-number">1</span>, <span class="hljs-literal">true</span>);<br>    <span class="hljs-keyword">return</span> Result.ok();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="用户签到统计"><a href="#用户签到统计" class="headerlink" title="用户签到统计"></a>用户签到统计</h3><p><strong>问题1：</strong> 什么叫做连续签到天数？ 从最后一次签到开始向前统计，直到遇到第一次未签到为止，计算总的签到次数，就是连续签到天数。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221630479.png"></p><pre><code class="hljs">Java逻辑代码：获得当前这个月的最后一次签到数据，定义一个计数器，然后不停的向前统计，直到获得第一个非0的数字即可，每得到一个非0的数字计数器+1，直到遍历完所有的数据，就可以获得当前月的签到总天数了</code></pre><p><strong>问题2：</strong>如何得到本月到今天为止的所有签到数据？</p><p><code>BITFIELD key GET u[dayOfMonth] 0</code></p><p>假设今天是10号，那么我们就可以从当前月的第一天开始，获得到当前这一天的位数，是10号，那么就是10位，去拿这段时间的数据，就能拿到所有的数据了，那么这10天里边签到了多少次呢？统计有多少个1即可。</p><p><strong>问题3：如何从后向前遍历每个bit位？</strong></p><p>注意：bitMap返回的数据是10进制，哪假如说返回一个数字8，那么我哪儿知道到底哪些是0，哪些是1呢？我们只需要让得到的10进制数字和1做与运算就可以了，因为1只有遇见1 才是1，其他数字都是0 ，我们把签到结果和1进行与操作，每与一次，就把签到结果向右移动一位，依次内推，我们就能完成逐个遍历的效果了。</p><p>需求：实现下面接口，统计当前用户截止当前时间在本月的连续签到天数</p><p>有用户有时间我们就可以组织出对应的key，此时就能找到这个用户截止这天的所有签到记录，再根据这套算法，就能统计出来他连续签到的次数了。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221631760.png"></p><p>代码</p><p><strong>UserController</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/sign/count&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">signCount</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> userService.signCount();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>UserServiceImpl</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">signCount</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 1.获取当前登录用户</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-comment">// 2.获取日期</span><br>    <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> LocalDateTime.now();<br>    <span class="hljs-comment">// 3.拼接key</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">keySuffix</span> <span class="hljs-operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;:yyyyMM&quot;</span>));<br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> USER_SIGN_KEY + userId + keySuffix;<br>    <span class="hljs-comment">// 4.获取今天是本月的第几天</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">dayOfMonth</span> <span class="hljs-operator">=</span> now.getDayOfMonth();<br>    <span class="hljs-comment">// 5.获取本月截止今天为止的所有的签到记录，返回的是一个十进制的数字 BITFIELD sign:5:202203 GET u14 0</span><br>    List&lt;Long&gt; result = stringRedisTemplate.opsForValue().bitField(<br>            key,<br>            BitFieldSubCommands.create()<br>                    .get(BitFieldSubCommands.BitFieldType.unsigned(dayOfMonth)).valueAt(<span class="hljs-number">0</span>)<br>    );<br>    <span class="hljs-keyword">if</span> (result == <span class="hljs-literal">null</span> || result.isEmpty()) &#123;<br>        <span class="hljs-comment">// 没有任何签到结果</span><br>        <span class="hljs-keyword">return</span> Result.ok(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-type">Long</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> result.get(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (num == <span class="hljs-literal">null</span> || num == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> Result.ok(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-comment">// 6.循环遍历</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-comment">// 6.1.让这个数字与1做与运算，得到数字的最后一个bit位  // 判断这个bit位是否为0</span><br>        <span class="hljs-keyword">if</span> ((num &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 如果为0，说明未签到，结束</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果不为0，说明已签到，计数器+1</span><br>            count++;<br>        &#125;<br>        <span class="hljs-comment">// 把数字右移一位，抛弃最后一个bit位，继续下一个bit位</span><br>        num &gt;&gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> Result.ok(count);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="UV统计"><a href="#UV统计" class="headerlink" title="UV统计"></a>UV统计</h2><p>首先我们搞懂两个概念：</p><ul><li><p>UV：全称Unique Visitor，也叫独立访客量，是指通过互联网访问、浏览这个网页的自然人。1天内同一个用户多次访问该网站，只记录1次。</p></li><li><p>PV：全称Page View，也叫页面访问量或点击量，用户每访问网站的一个页面，记录1次PV，用户多次打开页面，则记录多次PV。往往用来衡量网站的流量。</p></li></ul><p>通常来说UV会比PV大很多，所以衡量同一个网站的访问量，我们需要综合考虑很多因素，所以我们只是单纯的把这两个值作为一个参考值</p><p>UV统计在服务端做会比较麻烦，因为要判断该用户是否已经统计过了，需要将统计过的用户信息保存。但是如果每个访问的用户都保存到Redis中，数据量会非常恐怖，那怎么处理呢？</p><p>Hyperloglog(HLL)是从Loglog算法派生的概率算法，用于确定非常大的集合的基数，而不需要存储其所有值。相关算法原理大家可以参考：<a href="https://juejin.cn/post/6844903785744056333#heading-0">https://juejin.cn/post/6844903785744056333#heading-0</a> Redis中的HLL是基于string结构实现的，单个HLL的内存<strong>永远小于16kb</strong>，<strong>内存占用低</strong>的令人发指！作为代价，其测量结果是概率性的，<strong>有小于0.81％的误差</strong>。不过对于UV统计来说，这完全可以忽略。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221632858.png"></p><h3 id="测试百万数据的统计"><a href="#测试百万数据的统计" class="headerlink" title="测试百万数据的统计"></a>测试百万数据的统计</h3><p>测试思路：我们直接利用单元测试，向HyperLogLog中添加100万条数据，看看内存占用和统计效果如何。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403221632426.png"></p><p>经过测试：我们会发生他的误差是在允许范围内，并且内存占用极小</p>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通关微服务-seata</title>
    <link href="/posts/6235e4a0/"/>
    <url>/posts/6235e4a0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>用于管理和协调分布式事务。Seata提供了高性能、易于使用的分布式事务功能，支持多种数据库和事务模型，XA、TCC（Try-Confirm-Cancel）、AT（Automatic Transaction）等。帮助开发者在微服务和分布式系统中确保数据一致性和事务的可靠性。</p></blockquote><hr><h1 id="分布式事务问题"><a href="#分布式事务问题" class="headerlink" title="分布式事务问题"></a>分布式事务问题</h1><h2 id="本地事务"><a href="#本地事务" class="headerlink" title="本地事务"></a>本地事务</h2><p>本地事务，也就是传统的<strong>单机事务</strong>。在传统数据库事务中，必须要满足四个原则：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211514874.png"></p><h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><p><strong>分布式事务</strong>，就是指不是在单个服务或单个数据库架构下，产生的事务，例如：</p><ul><li><p>跨数据源的分布式事务</p></li><li><p>跨服务的分布式事务</p></li><li><p>综合情况</p></li></ul><p>在数据库水平拆分、服务垂直拆分之后，一个业务操作通常要跨多个数据库、服务才能完成。例如电商行业中比较常见的下单付款案例，包括下面几个行为：</p><ul><li><p>创建新订单</p></li><li><p>扣减商品库存</p></li><li><p>从用户账户余额扣除金额</p></li></ul><p>完成上面的操作需要访问三个不同的微服务和三个不同的数据库。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211514508.png"></p><p>订单的创建、库存的扣减、账户扣款在每一个服务和数据库内是一个本地事务，可以保证ACID原则。</p><p>但是当我们把三件事情看做一个”业务”，要满足保证“业务”的原子性，要么所有操作全部成功，要么全部失败，不允许出现部分成功部分失败的现象，这就是<strong>分布式系统下的事务</strong>了。</p><p>此时ACID难以满足，这是分布式事务要解决的问题。</p><h1 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h1><p>解决分布式事务问题，需要一些分布式系统的基础知识作为理论指导。</p><h2 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a>CAP定理</h2><p>1998年，加州大学的计算机科学家 Eric Brewer 提出，分布式系统有三个指标。</p><blockquote><ul><li><p>Consistency（一致性）</p></li><li><p>Availability（可用性）</p></li><li><p>Partition tolerance （分区容错性）</p></li></ul></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211516661.png"><br>它们的第一个字母分别是 C、A、P。</p><p>Eric Brewer 说，这三个指标不可能同时做到。这个结论就叫做 CAP 定理。</p><h3 id="一致性（C）"><a href="#一致性（C）" class="headerlink" title="一致性（C）"></a>一致性（C）</h3><p>Consistency（一致性）：用户访问分布式系统中的任意节点，得到的数据必须一致。</p><p>比如现在包含两个节点，其中的初始数据是一致的：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211516799.png"></p><p>当我们修改其中一个节点的数据时，两者的数据产生了差异：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211517413.png"></p><p>要想保住一致性，就必须实现node01 到 node02的数据 同步：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211517165.png"></p><h3 id="可用性（A）"><a href="#可用性（A）" class="headerlink" title="可用性（A）"></a>可用性（A）</h3><p>Availability （可用性）：用户访问集群中的任意健康节点，必须能得到响应，而不是超时或拒绝。</p><p>如图，有三个节点的集群，访问任何一个都可以及时得到响应：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211517535.png"></p><p>当有部分节点因为网络故障或其它原因无法访问时，代表节点不可用：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211518797.png"></p><h3 id="分区容错（P）"><a href="#分区容错（P）" class="headerlink" title="分区容错（P）"></a>分区容错（P）</h3><p><strong>Partition（分区）</strong>：因为网络故障或其它原因导致分布式系统中的部分节点与其它节点失去连接，形成独立分区。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211518724.png"><br><strong>Tolerance（容错）</strong>：在集群出现分区时，整个系统也要持续对外提供服务</p><h3 id="矛盾"><a href="#矛盾" class="headerlink" title="矛盾"></a>矛盾</h3><p>在分布式系统中，系统间的网络不能100%保证健康，一定会有故障的时候，而服务有必须对外保证服务。因此Partition Tolerance不可避免。</p><p>当节点接收到新的数据变更时，就会出现问题了：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211519125.png"></p><p>如果此时要保证<strong>一致性</strong>，就必须等待网络恢复，完成数据同步后，整个集群才对外提供服务，服务处于阻塞状态，不可用。</p><p>如果此时要保证<strong>可用性</strong>，就不能等待网络恢复，那node01、node02与node03之间就会出现数据不一致。</p><p>也就是说，在P一定会出现的情况下，A和C之间只能保证一个。</p><h2 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h2><p>BASE理论是对CAP的一种解决思路，包含三个思想：</p><ul><li><p><strong>Basically Available</strong> <strong>（基本可用）</strong>：分布式系统在出现故障时，允许损失部分可用性，即保证核心可用。</p></li><li><p><strong>Soft State（软状态）：</strong> 在一定时间内，允许出现中间状态，比如临时的不一致状态。</p></li><li><p><strong>Eventually Consistent（最终一致性）</strong>：虽然无法保证强一致性，但是在软状态结束后，最终达到数据一致。</p></li></ul><h2 id="解决分布式事务的思路"><a href="#解决分布式事务的思路" class="headerlink" title="解决分布式事务的思路"></a>解决分布式事务的思路</h2><p>分布式事务最大的问题是各个子事务的一致性问题，因此可以借鉴CAP定理和BASE理论，有两种解决思路：</p><ul><li><p>AP模式：各子事务分别执行和提交，允许出现结果不一致，然后采用弥补措施恢复数据即可，实现最终一致。</p></li><li><p>CP模式：各个子事务执行后互相等待，同时提交，同时回滚，达成强一致。但事务等待过程中，处于弱可用状态。</p></li></ul><p>但不管是哪一种模式，都需要在子系统事务之间互相通讯，协调事务状态，也就是需要一个**事务协调者(TC)**：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211520971.png"><br>这里的子系统事务，称为<strong>分支事务</strong>；有关联的各个分支事务在一起称为<strong>全局事务</strong>。</p><h1 id="初始Seata"><a href="#初始Seata" class="headerlink" title="初始Seata"></a>初始Seata</h1><p>Seata是 2019 年 1 月份蚂蚁金服和阿里巴巴共同开源的分布式事务解决方案。致力于提供高性能和简单易用的分布式事务服务，为用户打造一站式的分布式解决方案。</p><p>官网地址：<a href="http://seata.io/">http://seata.io/</a>，其中的文档提供了大量的使用说明、源码分析。</p><h2 id="Seata架构"><a href="#Seata架构" class="headerlink" title="Seata架构"></a>Seata架构</h2><p>Seata事务管理中有三个重要的角色：</p><ul><li><p><strong>TC (Transaction Coordinator) -</strong> <strong>事务协调者：</strong> 维护全局和分支事务的状态，协调全局事务提交或回滚。</p></li><li><p><strong>TM (Transaction Manager) -</strong> <strong>事务管理器：</strong> 定义全局事务的范围、开始全局事务、提交或回滚全局事务。</p></li><li><p><strong>RM (Resource Manager) -</strong> <strong>资源管理器：</strong> 管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</p></li></ul><p>整体的架构如图：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211522177.png"></p><p>Seata基于上述架构提供了四种不同的分布式事务解决方案：</p><ul><li><p>XA模式：<font color="#245bdb">强一致性分阶段事务模式</font>，牺牲了一定的可用性，<strong>无业务侵入</strong></p></li><li><p>TCC模式：<font color="#245bdb">最终一致的分阶段事务模式</font>，<strong>有业务侵入</strong></p></li><li><p>AT模式：<font color="#245bdb">最终一致的分阶段事务模式</font>，<strong>无业务侵入</strong>，也是<strong>Seata的默认模式</strong></p></li><li><p>SAGA模式：<font color="#245bdb">长事务模式</font>，<strong>有业务侵入</strong></p></li></ul><p>无论哪种方案，都离不开TC，也就是事务的协调者。</p><h2 id="部署TC服务"><a href="#部署TC服务" class="headerlink" title="部署TC服务"></a>部署TC服务</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>首先我们要下载seata-server包，地址在(<a href="http://seata.io)[.](http://seata.io/zh-cn/blog/download.html)">http://seata.io)[.](http://seata.io/zh-cn/blog/download.html)</a></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211544266.png"></p><h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><p>在非中文目录解压缩这个zip包，其目录结构如下：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211544892.png"></p><h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><p>修改conf目录下的registry.conf文件：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211545207.png"><br>内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs conf">registry &#123;<br>  # tc服务的注册中心类，这里选择nacos，也可以是eureka、zookeeper等<br>  type = &quot;nacos&quot;<br><br>  nacos &#123;<br>    # seata tc 服务注册到 nacos的服务名称，可以自定义<br>    application = &quot;seata-tc-server&quot;<br>    serverAddr = &quot;127.0.0.1:8848&quot;<br>    group = &quot;DEFAULT_GROUP&quot;<br>    namespace = &quot;&quot;<br>    cluster = &quot;SH&quot;<br>    username = &quot;nacos&quot;<br>    password = &quot;nacos&quot;<br>  &#125;<br>&#125;<br><br>config &#123;<br>  # 读取tc服务端的配置文件的方式，这里是从nacos配置中心读取，这样如果tc是集群，可以共享配置<br>  type = &quot;nacos&quot;<br>  # 配置nacos地址等信息<br>  nacos &#123;<br>    serverAddr = &quot;127.0.0.1:8848&quot;<br>    namespace = &quot;&quot;<br>    group = &quot;SEATA_GROUP&quot;<br>    username = &quot;nacos&quot;<br>    password = &quot;nacos&quot;<br>    dataId = &quot;seataServer.properties&quot;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="在nacos添加配置"><a href="#在nacos添加配置" class="headerlink" title="在nacos添加配置"></a>在nacos添加配置</h3><p>特别注意，为了让tc服务的集群可以共享配置，我们选择了nacos作为统一配置中心。因此服务端配置文件seataServer.properties文件需要在nacos中配好。</p><p>格式如下：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211546663.png"></p><p>配置内容如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 数据存储方式，db代表数据库</span><br><span class="hljs-attr">store.mode</span>=<span class="hljs-string">db</span><br><span class="hljs-attr">store.db.datasource</span>=<span class="hljs-string">druid</span><br><span class="hljs-attr">store.db.dbType</span>=<span class="hljs-string">mysql</span><br><span class="hljs-attr">store.db.driverClassName</span>=<span class="hljs-string">com.mysql.jdbc.Driver</span><br><span class="hljs-attr">store.db.url</span>=<span class="hljs-string">jdbc:mysql://127.0.0.1:3306/seata?useUnicode=true&amp;rewriteBatchedStatements=true</span><br><span class="hljs-attr">store.db.user</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">store.db.password</span>=<span class="hljs-string">123</span><br><span class="hljs-attr">store.db.minConn</span>=<span class="hljs-string">5</span><br><span class="hljs-attr">store.db.maxConn</span>=<span class="hljs-string">30</span><br><span class="hljs-attr">store.db.globalTable</span>=<span class="hljs-string">global_table</span><br><span class="hljs-attr">store.db.branchTable</span>=<span class="hljs-string">branch_table</span><br><span class="hljs-attr">store.db.queryLimit</span>=<span class="hljs-string">100</span><br><span class="hljs-attr">store.db.lockTable</span>=<span class="hljs-string">lock_table</span><br><span class="hljs-attr">store.db.maxWait</span>=<span class="hljs-string">5000</span><br><span class="hljs-comment"># 事务、日志等配置</span><br><span class="hljs-attr">server.recovery.committingRetryPeriod</span>=<span class="hljs-string">1000</span><br><span class="hljs-attr">server.recovery.asynCommittingRetryPeriod</span>=<span class="hljs-string">1000</span><br><span class="hljs-attr">server.recovery.rollbackingRetryPeriod</span>=<span class="hljs-string">1000</span><br><span class="hljs-attr">server.recovery.timeoutRetryPeriod</span>=<span class="hljs-string">1000</span><br><span class="hljs-attr">server.maxCommitRetryTimeout</span>=<span class="hljs-string">-1</span><br><span class="hljs-attr">server.maxRollbackRetryTimeout</span>=<span class="hljs-string">-1</span><br><span class="hljs-attr">server.rollbackRetryTimeoutUnlockEnable</span>=<span class="hljs-string">false</span><br><span class="hljs-attr">server.undo.logSaveDays</span>=<span class="hljs-string">7</span><br><span class="hljs-attr">server.undo.logDeletePeriod</span>=<span class="hljs-string">86400000</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 客户端与服务端传输方式</span><br><span class="hljs-attr">transport.serialization</span>=<span class="hljs-string">seata</span><br><span class="hljs-attr">transport.compressor</span>=<span class="hljs-string">none</span><br><span class="hljs-comment"># 关闭metrics功能，提高性能</span><br><span class="hljs-attr">metrics.enabled</span>=<span class="hljs-string">false</span><br><span class="hljs-attr">metrics.registryType</span>=<span class="hljs-string">compact</span><br><span class="hljs-attr">metrics.exporterList</span>=<span class="hljs-string">prometheus</span><br><span class="hljs-attr">metrics.exporterPrometheusPort</span>=<span class="hljs-string">9898</span><br></code></pre></td></tr></table></figure><h3 id="数据库相关配置"><a href="#数据库相关配置" class="headerlink" title="数据库相关配置"></a>数据库相关配置</h3><p>特别注意：tc服务在管理分布式事务时，需要记录事务相关数据到数据库中，你需要提前创建好这些表。</p><p>新建一个名为seata的数据库，这些表主要记录全局事务、分支事务、全局锁信息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs sql"><br><span class="hljs-keyword">SET</span> NAMES utf8mb4;<br><span class="hljs-keyword">SET</span> FOREIGN_KEY_CHECKS <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">-- ----------------------------</span><br><span class="hljs-comment">-- 分支事务表</span><br><span class="hljs-comment">-- ----------------------------</span><br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> `branch_table`;<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `branch_table`  (<br>  `branch_id` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `xid` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8 <span class="hljs-keyword">COLLATE</span> utf8_general_ci <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `transaction_id` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `resource_group_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8 <span class="hljs-keyword">COLLATE</span> utf8_general_ci <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `resource_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">256</span>) <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8 <span class="hljs-keyword">COLLATE</span> utf8_general_ci <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `branch_type` <span class="hljs-type">varchar</span>(<span class="hljs-number">8</span>) <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8 <span class="hljs-keyword">COLLATE</span> utf8_general_ci <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `status` tinyint(<span class="hljs-number">4</span>) <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `client_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8 <span class="hljs-keyword">COLLATE</span> utf8_general_ci <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `application_data` <span class="hljs-type">varchar</span>(<span class="hljs-number">2000</span>) <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8 <span class="hljs-keyword">COLLATE</span> utf8_general_ci <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `gmt_create` datetime(<span class="hljs-number">6</span>) <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `gmt_modified` datetime(<span class="hljs-number">6</span>) <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`branch_id`) <span class="hljs-keyword">USING</span> BTREE,<br>  INDEX `idx_xid`(`xid`) <span class="hljs-keyword">USING</span> BTREE<br>) ENGINE <span class="hljs-operator">=</span> InnoDB <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> <span class="hljs-operator">=</span> utf8 <span class="hljs-keyword">COLLATE</span> <span class="hljs-operator">=</span> utf8_general_ci ROW_FORMAT <span class="hljs-operator">=</span> Compact;<br><br><span class="hljs-comment">-- ----------------------------</span><br><span class="hljs-comment">-- 全局事务表</span><br><span class="hljs-comment">-- ----------------------------</span><br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> `global_table`;<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `global_table`  (<br>  `xid` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8 <span class="hljs-keyword">COLLATE</span> utf8_general_ci <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `transaction_id` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `status` tinyint(<span class="hljs-number">4</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `application_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8 <span class="hljs-keyword">COLLATE</span> utf8_general_ci <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `transaction_service_group` <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8 <span class="hljs-keyword">COLLATE</span> utf8_general_ci <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `transaction_name` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8 <span class="hljs-keyword">COLLATE</span> utf8_general_ci <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `timeout` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `begin_time` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `application_data` <span class="hljs-type">varchar</span>(<span class="hljs-number">2000</span>) <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8 <span class="hljs-keyword">COLLATE</span> utf8_general_ci <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `gmt_create` datetime <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `gmt_modified` datetime <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`xid`) <span class="hljs-keyword">USING</span> BTREE,<br>  INDEX `idx_gmt_modified_status`(`gmt_modified`, `status`) <span class="hljs-keyword">USING</span> BTREE,<br>  INDEX `idx_transaction_id`(`transaction_id`) <span class="hljs-keyword">USING</span> BTREE<br>) ENGINE <span class="hljs-operator">=</span> InnoDB <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> <span class="hljs-operator">=</span> utf8 <span class="hljs-keyword">COLLATE</span> <span class="hljs-operator">=</span> utf8_general_ci ROW_FORMAT <span class="hljs-operator">=</span> Compact;<br><br><span class="hljs-keyword">SET</span> FOREIGN_KEY_CHECKS <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h3 id="启动TC服务"><a href="#启动TC服务" class="headerlink" title="启动TC服务"></a>启动TC服务</h3><p>进入bin目录，运行其中的seata-server.bat即可：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211548214.png"></p><p>启动成功后，seata-server应该已经注册到nacos注册中心了。</p><p>打开浏览器，访问nacos地址：<a href="http://localhost:8848/">http://localhost:8848</a>，然后进入服务列表页面，可以看到seata-tc-server的信息：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211548892.png"></p><h2 id="微服务集成Seata"><a href="#微服务集成Seata" class="headerlink" title="微服务集成Seata"></a>微服务集成Seata</h2><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><p>首先，在order-service中引入依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs pom">&lt;!--seata--&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-cloud-starter-alibaba-seata&lt;/artifactId&gt;<br>    &lt;exclusions&gt;<br>        &lt;!--版本较低，1.3.0，因此排除--&gt; <br>        &lt;exclusion&gt;<br>            &lt;artifactId&gt;seata-spring-boot-starter&lt;/artifactId&gt;<br>            &lt;groupId&gt;io.seata&lt;/groupId&gt;<br>        &lt;/exclusion&gt;<br>    &lt;/exclusions&gt;<br>&lt;/dependency&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;io.seata&lt;/groupId&gt;<br>    &lt;artifactId&gt;seata-spring-boot-starter&lt;/artifactId&gt;<br>    &lt;!--seata starter 采用1.4.2版本--&gt;<br>    &lt;version&gt;$&#123;seata.version&#125;&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><h3 id="配置TC地址"><a href="#配置TC地址" class="headerlink" title="配置TC地址"></a>配置TC地址</h3><p>在order-service中的application.yml中，配置TC服务信息，通过注册中心nacos，结合服务名称获取TC地址：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">seata:</span><br>  <span class="hljs-attr">registry:</span> <span class="hljs-comment"># TC服务注册中心的配置，微服务根据这些信息去注册中心获取tc服务地址</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">nacos</span> <span class="hljs-comment"># 注册中心类型 nacos</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:8848</span> <span class="hljs-comment"># nacos地址</span><br>      <span class="hljs-attr">namespace:</span> <span class="hljs-string">&quot;&quot;</span> <span class="hljs-comment"># namespace，默认为空</span><br>      <span class="hljs-attr">group:</span> <span class="hljs-string">DEFAULT_GROUP</span> <span class="hljs-comment"># 分组，默认是DEFAULT_GROUP</span><br>      <span class="hljs-attr">application:</span> <span class="hljs-string">seata-tc-server</span> <span class="hljs-comment"># seata服务名称</span><br>      <span class="hljs-attr">username:</span> <span class="hljs-string">nacos</span><br>      <span class="hljs-attr">password:</span> <span class="hljs-string">nacos</span><br>  <span class="hljs-attr">tx-service-group:</span> <span class="hljs-string">seata-demo</span> <span class="hljs-comment"># 事务组名称</span><br>  <span class="hljs-attr">service:</span><br>    <span class="hljs-attr">vgroup-mapping:</span> <span class="hljs-comment"># 事务组与cluster的映射关系</span><br>      <span class="hljs-attr">seata-demo:</span> <span class="hljs-string">SH</span><br></code></pre></td></tr></table></figure><p>微服务如何根据这些配置寻找TC的地址呢？</p><p>我们知道注册到Nacos中的微服务，确定一个具体实例需要四个信息：</p><ul><li><p>namespace：命名空间</p></li><li><p>group：分组</p></li><li><p>application：服务名</p></li><li><p>cluster：集群名</p></li></ul><p>以上四个信息，在刚才的yaml文件中都能找到：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211550412.png"></p><p>namespace为空，就是默认的public</p><p>结合起来，TC服务的信息就是：public@DEFAULT_GROUP@seata-tc-server@SH，这样就能确定TC服务集群了。然后就可以去Nacos拉取对应的实例信息了。</p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>下面动手实践下Seata中的四种不同的事务模式。</p><h2 id="XA模式"><a href="#XA模式" class="headerlink" title="XA模式"></a>XA模式</h2><p>XA 规范 是 X&#x2F;Open 组织定义的分布式事务处理（DTP，Distributed Transaction Processing）标准，XA 规范 描述了全局的TM与局部的RM之间的接口，几乎所有主流的数据库都对 XA 规范 提供了支持。</p><h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3><p>XA是规范，目前主流数据库都实现了这种规范，实现的原理都是基于<strong>两阶段提交</strong>。</p><p>正常情况：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211552240.png"></p><p>异常情况：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211552272.png"></p><p>一阶段：</p><ul><li><p>事务协调者通知每个事物参与者执行本地事务</p></li><li><p>本地事务执行完成后报告事务执行状态给事务协调者，此时事务不提交，继续持有数据库锁</p></li></ul><p>二阶段：</p><ul><li><p>事务协调者基于一阶段的报告来判断下一步操作</p><ul><li><p>如果一阶段都成功，则通知所有事务参与者，提交事务</p></li><li><p>如果一阶段任意一个参与者失败，则通知所有事务参与者回滚事务</p></li></ul></li></ul><h3 id="Seata的XA模型"><a href="#Seata的XA模型" class="headerlink" title="Seata的XA模型"></a>Seata的XA模型</h3><p>Seata对原始的XA模式做了简单的封装和改造，以适应自己的事务模型，基本架构如图：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211553346.png"><br>RM一阶段的工作：</p><p>① 注册分支事务到TC</p><p>② 执行分支业务sql但不提交</p><p>③ 报告执行状态到TC</p><p>TC二阶段的工作：</p><ul><li><p>TC检测各分支事务执行状态</p><p>  a.如果都成功，通知所有RM提交事务</p><p>  b.如果有失败，通知所有RM回滚事务</p></li></ul><p>RM二阶段的工作：</p><ul><li>接收TC指令，提交或回滚事务</li></ul><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>XA模式的优点是什么？</p><ul><li><p>事务的强一致性，满足ACID原则。</p></li><li><p>常用数据库都支持，实现简单，并且没有代码侵入</p></li></ul><p>XA模式的缺点是什么？</p><ul><li><p>因为一阶段需要锁定数据库资源，等待二阶段结束才释放，性能较差</p></li><li><p>依赖关系型数据库实现事务</p></li></ul><h3 id="实现XA模式"><a href="#实现XA模式" class="headerlink" title="实现XA模式"></a>实现XA模式</h3><p>Seata的starter已经完成了XA模式的自动装配，实现非常简单，步骤如下：</p><p>1）修改application.yml文件（每个参与事务的微服务），开启XA模式：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">seata:</span><br>  <span class="hljs-attr">data-source-proxy-mode:</span> <span class="hljs-string">XA</span><br></code></pre></td></tr></table></figure><p>2）给发起全局事务的入口方法添加@GlobalTransactional注解:</p><p>本例中是OrderServiceImpl中的create方法.</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211555775.png"></p><p>3）重启服务并测试</p><p>重启order-service，再次测试，发现无论怎样，三个微服务都能成功回滚。</p><h2 id="AT模式"><a href="#AT模式" class="headerlink" title="AT模式"></a>AT模式</h2><p>AT模式同样是分阶段提交的事务模型，不过<em>缺弥补了XA模型中资源锁定周期过长的缺陷</em>。</p><h3 id="Seata的AT模型"><a href="#Seata的AT模型" class="headerlink" title="Seata的AT模型"></a>Seata的AT模型</h3><p>基本流程图：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211556802.png"><br>阶段一RM的工作：</p><ul><li><p>注册分支事务</p></li><li><p>记录undo-log（数据快照）</p></li><li><p>执行业务sql并提交</p></li><li><p>报告事务状态</p></li></ul><p>阶段二提交时RM的工作：</p><ul><li>删除undo-log即可</li></ul><p>阶段二回滚时RM的工作：</p><ul><li>根据undo-log恢复数据到更新前</li></ul><h3 id="流程梳理"><a href="#流程梳理" class="headerlink" title="流程梳理"></a>流程梳理</h3><p>用一个真实的业务来梳理下AT模式的原理。</p><p>比如，现在又一个数据库表，记录用户余额：</p><table><thead><tr><th><strong>id</strong></th><th><strong>money</strong></th></tr></thead><tbody><tr><td>1</td><td>100</td></tr></tbody></table><p>其中一个分支业务要执行的SQL为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> tb_account <span class="hljs-keyword">set</span> money <span class="hljs-operator">=</span> money <span class="hljs-operator">-</span> <span class="hljs-number">10</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>AT模式下，当前分支事务执行流程如下：</p><p><strong>一阶段</strong>：</p><p>1）TM发起并注册全局事务到TC</p><p>2）TM调用分支事务</p><p>3）分支事务准备执行业务SQL</p><p>4）RM拦截业务SQL，根据where条件查询原始数据，形成快照。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;money&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">100</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>5）RM执行业务SQL，提交本地事务，释放数据库锁。此时 <code>money = 90</code></p><p>6）RM报告本地事务状态给TC</p><p><strong>二阶段</strong>：</p><p>1）TM通知TC事务结束</p><p>2）TC检查分支事务状态</p><p>a）如果都成功，则立即删除快照</p><p>b）如果有分支事务失败，需要回滚。读取快照数据（<code>&#123;&quot;id&quot;: 1, &quot;money&quot;: 100&#125;</code>），将快照恢复到数据库。此时数据库再次恢复为100。</p><p><strong>流程图</strong>：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211558136.png"></p><h3 id="AT与XA的区别"><a href="#AT与XA的区别" class="headerlink" title="AT与XA的区别"></a>AT与XA的区别</h3><p>简述AT模式与XA模式最大的区别是什么？</p><ul><li><p>XA模式一阶段不提交事务，锁定资源；AT模式一阶段直接提交，不锁定资源。</p></li><li><p>XA模式依赖数据库机制实现回滚；AT模式利用数据快照实现数据回滚。</p></li><li><p>XA模式强一致；AT模式最终一致</p></li></ul><h3 id="脏写问题"><a href="#脏写问题" class="headerlink" title="脏写问题"></a>脏写问题</h3><p>在多线程并发访问AT模式的分布式事务时，有可能出现脏写问题，如图：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211559525.png"></p><p>解决思路就是引入了全局锁的概念。在释放DB锁之前，先拿到全局锁。避免同一时刻有另外一个事务来操作当前数据。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211600654.png"></p><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p>AT模式的优点：</p><ul><li><p>一阶段完成直接提交事务，释放数据库资源，性能比较好</p></li><li><p>利用全局锁实现读写隔离</p></li><li><p>没有代码侵入，框架自动完成回滚和提交</p></li></ul><p>AT模式的缺点：</p><ul><li><p>两阶段之间属于软状态，属于最终一致</p></li><li><p>框架的快照功能会影响性能，但比XA模式要好很多</p></li></ul><h3 id="实现AT模式"><a href="#实现AT模式" class="headerlink" title="实现AT模式"></a>实现AT模式</h3><p>AT模式中的快照生成、回滚等动作都是由框架自动完成，没有任何代码侵入，因此实现非常简单。</p><p>只不过，AT模式需要一个表来记录全局锁、另一张表来记录数据快照undo_log。</p><p>1）导入数据库表，记录全局锁</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> Navicat Premium Data Transfer</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> Source Server         : local</span><br><span class="hljs-comment"> Source Server Type    : MySQL</span><br><span class="hljs-comment"> Source Server Version : 50622</span><br><span class="hljs-comment"> Source Host           : localhost:3306</span><br><span class="hljs-comment"> Source Schema         : seata_demo</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> Target Server Type    : MySQL</span><br><span class="hljs-comment"> Target Server Version : 50622</span><br><span class="hljs-comment"> File Encoding         : 65001</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> Date: 20/06/2021 12:39:03</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">SET</span> NAMES utf8mb4;<br><span class="hljs-keyword">SET</span> FOREIGN_KEY_CHECKS <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">-- ----------------------------</span><br><span class="hljs-comment">-- Table structure for undo_log</span><br><span class="hljs-comment">-- ----------------------------</span><br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> `undo_log`;<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `undo_log`  (<br>  `branch_id` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;branch transaction id&#x27;</span>,<br>  `xid` <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>) <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8 <span class="hljs-keyword">COLLATE</span> utf8_general_ci <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;global transaction id&#x27;</span>,<br>  `context` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8 <span class="hljs-keyword">COLLATE</span> utf8_general_ci <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;undo_log context,such as serialization&#x27;</span>,<br>  `rollback_info` longblob <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;rollback info&#x27;</span>,<br>  `log_status` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;0:normal status,1:defense status&#x27;</span>,<br>  `log_created` datetime(<span class="hljs-number">6</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;create datetime&#x27;</span>,<br>  `log_modified` datetime(<span class="hljs-number">6</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;modify datetime&#x27;</span>,<br>  <span class="hljs-keyword">UNIQUE</span> INDEX `ux_undo_log`(`xid`, `branch_id`) <span class="hljs-keyword">USING</span> BTREE<br>) ENGINE <span class="hljs-operator">=</span> InnoDB <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> <span class="hljs-operator">=</span> utf8 <span class="hljs-keyword">COLLATE</span> <span class="hljs-operator">=</span> utf8_general_ci COMMENT <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;AT transaction mode undo table&#x27;</span> ROW_FORMAT <span class="hljs-operator">=</span> Compact;<br><br><span class="hljs-comment">-- ----------------------------</span><br><span class="hljs-comment">-- Records of undo_log</span><br><span class="hljs-comment">-- ----------------------------</span><br><br><br><br><span class="hljs-comment">-- ----------------------------</span><br><span class="hljs-comment">-- Table structure for lock_table</span><br><span class="hljs-comment">-- ----------------------------</span><br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> `lock_table`;<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `lock_table`  (<br>  `row_key` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8 <span class="hljs-keyword">COLLATE</span> utf8_general_ci <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `xid` <span class="hljs-type">varchar</span>(<span class="hljs-number">96</span>) <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8 <span class="hljs-keyword">COLLATE</span> utf8_general_ci <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `transaction_id` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `branch_id` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `resource_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">256</span>) <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8 <span class="hljs-keyword">COLLATE</span> utf8_general_ci <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `table_name` <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8 <span class="hljs-keyword">COLLATE</span> utf8_general_ci <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `pk` <span class="hljs-type">varchar</span>(<span class="hljs-number">36</span>) <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8 <span class="hljs-keyword">COLLATE</span> utf8_general_ci <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `gmt_create` datetime <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `gmt_modified` datetime <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`row_key`) <span class="hljs-keyword">USING</span> BTREE,<br>  INDEX `idx_branch_id`(`branch_id`) <span class="hljs-keyword">USING</span> BTREE<br>) ENGINE <span class="hljs-operator">=</span> InnoDB <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> <span class="hljs-operator">=</span> utf8 <span class="hljs-keyword">COLLATE</span> <span class="hljs-operator">=</span> utf8_general_ci ROW_FORMAT <span class="hljs-operator">=</span> Compact;<br><br><br><span class="hljs-keyword">SET</span> FOREIGN_KEY_CHECKS <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>2）修改application.yml文件，将事务模式修改为AT模式即可：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">seata:</span><br>  <span class="hljs-attr">data-source-proxy-mode:</span> <span class="hljs-string">AT</span> <span class="hljs-comment"># 默认就是AT</span><br></code></pre></td></tr></table></figure><p>3）重启服务并测试</p><h2 id="TCC模式"><a href="#TCC模式" class="headerlink" title="TCC模式"></a>TCC模式</h2><p>TCC模式与AT模式非常相似，每阶段都是独立事务，不同的是TCC通过人工编码来实现数据恢复。需要实现三个方法：</p><ul><li><p>Try：资源的检测和预留；</p></li><li><p>Confirm：完成资源操作业务；要求 Try 成功 Confirm 一定要能成功。</p></li><li><p>Cancel：预留资源释放，可以理解为try的反向操作。</p></li></ul><h3 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h3><p>举例，一个扣减用户余额的业务。假设账户A原来余额是100，需要余额扣减30元。</p><ul><li><strong>阶段一（ Try ）</strong>：检查余额是否充足，如果充足则冻结金额增加30元，可用余额扣除30</li></ul><p>初始余额：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211602024.png"></p><p>余额充足，可以冻结：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211602639.png"></p><p>此时，总金额 &#x3D; 冻结金额 + 可用金额，数量依然是100不变。事务直接提交无需等待其它事务。</p><ul><li>**阶段二（Confirm)**：假如要提交（Confirm），则冻结金额扣减30</li></ul><p>确认可以提交，不过之前可用金额已经扣减过了，这里只要清除冻结金额就好了：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211603668.png"></p><p>此时，总金额 &#x3D; 冻结金额 + 可用金额 &#x3D; 0 + 70 &#x3D; 70元</p><ul><li>**阶段二(Canncel)**：如果要回滚（Cancel），则冻结金额扣减30，可用余额增加30</li></ul><p>需要回滚，那么就要释放冻结金额，恢复可用金额：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211603169.png"></p><h3 id="Seata的TCC模型"><a href="#Seata的TCC模型" class="headerlink" title="Seata的TCC模型"></a>Seata的TCC模型</h3><p>Seata中的TCC模型依然延续之前的事务架构，如图：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211604749.png"></p><h3 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h3><p>TCC模式的每个阶段是做什么的？</p><ul><li><p>Try：资源检查和预留</p></li><li><p>Confirm：业务执行和提交</p></li><li><p>Cancel：预留资源的释放</p></li></ul><p>TCC的优点是什么？</p><ul><li><p>一阶段完成直接提交事务，释放数据库资源，性能好</p></li><li><p>相比AT模型，无需生成快照，无需使用全局锁，性能最强</p></li><li><p>不依赖数据库事务，而是依赖补偿操作，可以用于非事务型数据库</p></li></ul><p>TCC的缺点是什么？</p><ul><li><p>有代码侵入，需要人为编写try、Confirm和Cancel接口，太麻烦</p></li><li><p>软状态，事务是最终一致</p></li><li><p>需要考虑Confirm和Cancel的失败情况，做好幂等处理</p></li></ul><h3 id="事务悬挂和空回滚"><a href="#事务悬挂和空回滚" class="headerlink" title="事务悬挂和空回滚"></a>事务悬挂和空回滚</h3><h4 id="空回滚"><a href="#空回滚" class="headerlink" title="空回滚"></a>空回滚</h4><p>当某分支事务的try阶段<strong>阻塞</strong>时，可能导致全局事务超时而触发二阶段的cancel操作。在未执行try操作时先执行了cancel操作，这时cancel不能做回滚，就是<strong>空回滚</strong>。</p><p>如图：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211605704.png"></p><p>执行cancel操作时，应当判断try是否已经执行，如果尚未执行，则应该空回滚。</p><h4 id="业务悬挂"><a href="#业务悬挂" class="headerlink" title="业务悬挂"></a>业务悬挂</h4><p>对于已经空回滚的业务，之前被阻塞的try操作恢复，继续执行try，就永远不可能confirm或cancel ，事务一直处于中间状态，这就是<strong>业务悬挂</strong>。</p><p>执行try操作时，应当判断cancel是否已经执行过了，如果已经执行，应当阻止空回滚后的try操作，避免悬挂。</p><h3 id="实现TCC模式"><a href="#实现TCC模式" class="headerlink" title="实现TCC模式"></a>实现TCC模式</h3><p>解决空回滚和业务悬挂问题，必须要记录当前事务状态，是在try、还是cancel？</p><h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>这里我们定义一张表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `account_freeze_tbl` (<br>  `xid` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `user_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;用户id&#x27;</span>,<br>  `freeze_money` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) unsigned <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span> COMMENT <span class="hljs-string">&#x27;冻结金额&#x27;</span>,<br>  `state` <span class="hljs-type">int</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;事务状态，0:try，1:confirm，2:cancel&#x27;</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`xid`) <span class="hljs-keyword">USING</span> BTREE<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8 ROW_FORMAT<span class="hljs-operator">=</span>COMPACT;<br><br></code></pre></td></tr></table></figure><p>其中：</p><ul><li><p>xid：是全局事务id</p></li><li><p>freeze_money：用来记录用户冻结金额</p></li><li><p>state：用来记录事务状态</p></li></ul><p>那此时，我们的业务开怎么做呢？</p><ul><li><p>Try业务：</p><ul><li><p>记录冻结金额和事务状态到account_freeze表</p></li><li><p>扣减account表可用金额</p></li></ul></li><li><p>Confirm业务</p><ul><li>根据xid删除account_freeze表的冻结记录</li></ul></li><li><p>Cancel业务</p><ul><li><p>修改account_freeze表，冻结金额为0，state为2</p></li><li><p>修改account表，恢复可用金额</p></li></ul></li><li><p>如何判断是否空回滚？</p><ul><li>cancel业务中，根据xid查询account_freeze，如果为null则说明try还没做，需要空回滚</li></ul></li><li><p>如何避免业务悬挂？</p><ul><li>try业务中，根据xid查询account_freeze ，如果已经存在则证明Cancel已经执行，拒绝执行try业务</li></ul></li></ul><p>接下来，我们改造account-service，利用TCC实现余额扣减功能。</p><h4 id="声明TCC接口"><a href="#声明TCC接口" class="headerlink" title="声明TCC接口"></a>声明TCC接口</h4><p>TCC的Try、Confirm、Cancel方法都需要在接口中基于注解来声明，</p><p>我们在account-service项目中的<code>cn.itcast.account.service</code>包中新建一个接口，声明TCC三个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.account.service;<br><br><span class="hljs-keyword">import</span> io.seata.rm.tcc.api.BusinessActionContext;<br><span class="hljs-keyword">import</span> io.seata.rm.tcc.api.BusinessActionContextParameter;<br><span class="hljs-keyword">import</span> io.seata.rm.tcc.api.LocalTCC;<br><span class="hljs-keyword">import</span> io.seata.rm.tcc.api.TwoPhaseBusinessAction;<br><br><span class="hljs-meta">@LocalTCC</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">AccountTCCService</span> &#123;<br><br>    <span class="hljs-meta">@TwoPhaseBusinessAction(name = &quot;deduct&quot;, commitMethod = &quot;confirm&quot;, rollbackMethod = &quot;cancel&quot;)</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">deduct</span><span class="hljs-params">(<span class="hljs-meta">@BusinessActionContextParameter(paramName = &quot;userId&quot;)</span> String userId,</span><br><span class="hljs-params">                <span class="hljs-meta">@BusinessActionContextParameter(paramName = &quot;money&quot;)</span><span class="hljs-type">int</span> money)</span>;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">confirm</span><span class="hljs-params">(BusinessActionContext ctx)</span>;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">cancel</span><span class="hljs-params">(BusinessActionContext ctx)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="编写实现"><a href="#编写实现" class="headerlink" title="编写实现"></a>编写实现</h4><p>在account-service服务中的<code>cn.itcast.account.service.impl</code>包下新建一个类，实现TCC业务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.account.service.impl;<br><br><span class="hljs-keyword">import</span> cn.itcast.account.entity.AccountFreeze;<br><span class="hljs-keyword">import</span> cn.itcast.account.mapper.AccountFreezeMapper;<br><span class="hljs-keyword">import</span> cn.itcast.account.mapper.AccountMapper;<br><span class="hljs-keyword">import</span> cn.itcast.account.service.AccountTCCService;<br><span class="hljs-keyword">import</span> io.seata.core.context.RootContext;<br><span class="hljs-keyword">import</span> io.seata.rm.tcc.api.BusinessActionContext;<br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><span class="hljs-keyword">import</span> org.springframework.transaction.annotation.Transactional;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AccountTCCServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AccountTCCService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> AccountMapper accountMapper;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> AccountFreezeMapper freezeMapper;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deduct</span><span class="hljs-params">(String userId, <span class="hljs-type">int</span> money)</span> &#123;<br>        <span class="hljs-comment">// 0.获取事务id</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">xid</span> <span class="hljs-operator">=</span> RootContext.getXID();<br>        <span class="hljs-comment">// 1.扣减可用余额</span><br>        accountMapper.deduct(userId, money);<br>        <span class="hljs-comment">// 2.记录冻结金额，事务状态</span><br>        <span class="hljs-type">AccountFreeze</span> <span class="hljs-variable">freeze</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AccountFreeze</span>();<br>        freeze.setUserId(userId);<br>        freeze.setFreezeMoney(money);<br>        freeze.setState(AccountFreeze.State.TRY);<br>        freeze.setXid(xid);<br>        freezeMapper.insert(freeze);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">confirm</span><span class="hljs-params">(BusinessActionContext ctx)</span> &#123;<br>        <span class="hljs-comment">// 1.获取事务id</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">xid</span> <span class="hljs-operator">=</span> ctx.getXid();<br>        <span class="hljs-comment">// 2.根据id删除冻结记录</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> freezeMapper.deleteById(xid);<br>        <span class="hljs-keyword">return</span> count == <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">cancel</span><span class="hljs-params">(BusinessActionContext ctx)</span> &#123;<br>        <span class="hljs-comment">// 0.查询冻结记录</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">xid</span> <span class="hljs-operator">=</span> ctx.getXid();<br>        <span class="hljs-type">AccountFreeze</span> <span class="hljs-variable">freeze</span> <span class="hljs-operator">=</span> freezeMapper.selectById(xid);<br><br>        <span class="hljs-comment">// 1.恢复可用余额</span><br>        accountMapper.refund(freeze.getUserId(), freeze.getFreezeMoney());<br>        <span class="hljs-comment">// 2.将冻结金额清零，状态改为CANCEL</span><br>        freeze.setFreezeMoney(<span class="hljs-number">0</span>);<br>        freeze.setState(AccountFreeze.State.CANCEL);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> freezeMapper.updateById(freeze);<br>        <span class="hljs-keyword">return</span> count == <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="SAGA模式"><a href="#SAGA模式" class="headerlink" title="SAGA模式"></a>SAGA模式</h2><p>Saga 模式是 Seata 即将开源的长事务解决方案。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>在 Saga 模式下，分布式事务内有多个参与者，每一个参与者都是一个冲正补偿服务，需要用户根据业务场景实现其正向操作和逆向回滚操作。</p><p>分布式事务执行过程中，依次执行各参与者的正向操作，如果所有正向操作均执行成功，那么分布式事务提交。如果任何一个正向操作执行失败，那么分布式事务会去退回去执行前面各参与者的逆向回滚操作，回滚已提交的参与者，使分布式事务回到初始状态。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211609695.png"></p><p>Saga也分为两个阶段：</p><ul><li><p>一阶段：直接提交本地事务</p></li><li><p>二阶段：成功则什么都不做；失败则通过编写补偿业务来回滚</p></li></ul><h3 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ul><li><p>事务参与者可以基于事件驱动实现异步调用，吞吐高</p></li><li><p>一阶段直接提交事务，无锁，性能好</p></li><li><p>不用编写TCC中的三个阶段，实现简单</p></li></ul><p>缺点：</p><ul><li><p>软状态持续时间不确定，时效性差</p></li><li><p>没有锁，没有事务隔离，会有脏写</p></li></ul><h2 id="四种模式对比"><a href="#四种模式对比" class="headerlink" title="四种模式对比"></a>四种模式对比</h2><p>我们从以下几个方面来对比四种实现：</p><ul><li><p>一致性：能否保证事务的一致性？强一致还是最终一致？</p></li><li><p>隔离性：事务之间的隔离性如何？</p></li><li><p>代码侵入：是否需要对业务代码改造？</p></li><li><p>性能：有无性能损耗？</p></li><li><p>场景：常见的业务场景</p></li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211610641.png"></p><h1 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h1><p>Seata的TC服务作为分布式事务核心，一定要保证集群的高可用性。</p><h2 id="高可用架构模型"><a href="#高可用架构模型" class="headerlink" title="高可用架构模型"></a>高可用架构模型</h2><p>搭建TC服务集群非常简单，启动多个TC服务，注册到nacos即可。</p><p>但集群并不能确保100%安全，万一集群所在机房故障怎么办？所以如果要求较高，一般都会做异地多机房容灾。</p><p>比如一个TC集群在上海，另一个TC集群在杭州：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211611352.png"></p><p>微服务基于事务组（tx-service-group)与TC集群的映射关系，来查找当前应该使用哪个TC集群。当SH集群故障时，只需要将vgroup-mapping中的映射关系改成HZ。则所有微服务就会切换到HZ的TC集群了。</p><h2 id="实现高可用"><a href="#实现高可用" class="headerlink" title="实现高可用"></a>实现高可用</h2><p>计划启动两台seata的tc服务节点：</p><table><thead><tr><th>节点名称</th><th>ip地址</th><th>端口号</th><th>集群名称</th></tr></thead><tbody><tr><td>seata</td><td>127.0.0.1</td><td>8091</td><td>SH</td></tr><tr><td>seata2</td><td>127.0.0.1</td><td>8092</td><td>HZ</td></tr></tbody></table><p>之前我们已经启动了一台seata服务，端口是8091，集群名为SH。</p><p>现在，将seata目录复制一份，起名为seata2</p><p>修改seata2&#x2F;conf&#x2F;registry.conf内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs conf">registry &#123;<br>  # tc服务的注册中心类，这里选择nacos，也可以是eureka、zookeeper等<br>  type = &quot;nacos&quot;<br><br>  nacos &#123;<br>    # seata tc 服务注册到 nacos的服务名称，可以自定义<br>    application = &quot;seata-tc-server&quot;<br>    serverAddr = &quot;127.0.0.1:8848&quot;<br>    group = &quot;DEFAULT_GROUP&quot;<br>    namespace = &quot;&quot;<br>    cluster = &quot;HZ&quot;<br>    username = &quot;nacos&quot;<br>    password = &quot;nacos&quot;<br>  &#125;<br>&#125;<br><br>config &#123;<br>  # 读取tc服务端的配置文件的方式，这里是从nacos配置中心读取，这样如果tc是集群，可以共享配置<br>  type = &quot;nacos&quot;<br>  # 配置nacos地址等信息<br>  nacos &#123;<br>    serverAddr = &quot;127.0.0.1:8848&quot;<br>    namespace = &quot;&quot;<br>    group = &quot;SEATA_GROUP&quot;<br>    username = &quot;nacos&quot;<br>    password = &quot;nacos&quot;<br>    dataId = &quot;seataServer.properties&quot;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>进入seata2&#x2F;bin目录，然后运行命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">seata-server.bat -p 8092<br></code></pre></td></tr></table></figure><p>打开nacos控制台，查看服务列表：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211612751.png"></p><p>点进详情查看：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211613323.png"></p><p>接下来，我们需要将tx-service-group与cluster的映射关系都配置到nacos配置中心。</p><p>新建一个配置：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211613497.png"></p><p>配置的内容如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 事务组映射关系</span><br><span class="hljs-attr">service.vgroupMapping.seata-demo</span>=<span class="hljs-string">SH</span><br><br><span class="hljs-attr">service.enableDegrade</span>=<span class="hljs-string">false</span><br><span class="hljs-attr">service.disableGlobalTransaction</span>=<span class="hljs-string">false</span><br><span class="hljs-comment"># 与TC服务的通信配置</span><br><span class="hljs-attr">transport.type</span>=<span class="hljs-string">TCP</span><br><span class="hljs-attr">transport.server</span>=<span class="hljs-string">NIO</span><br><span class="hljs-attr">transport.heartbeat</span>=<span class="hljs-string">true</span><br><span class="hljs-attr">transport.enableClientBatchSendRequest</span>=<span class="hljs-string">false</span><br><span class="hljs-attr">transport.threadFactory.bossThreadPrefix</span>=<span class="hljs-string">NettyBoss</span><br><span class="hljs-attr">transport.threadFactory.workerThreadPrefix</span>=<span class="hljs-string">NettyServerNIOWorker</span><br><span class="hljs-attr">transport.threadFactory.serverExecutorThreadPrefix</span>=<span class="hljs-string">NettyServerBizHandler</span><br><span class="hljs-attr">transport.threadFactory.shareBossWorker</span>=<span class="hljs-string">false</span><br><span class="hljs-attr">transport.threadFactory.clientSelectorThreadPrefix</span>=<span class="hljs-string">NettyClientSelector</span><br><span class="hljs-attr">transport.threadFactory.clientSelectorThreadSize</span>=<span class="hljs-string">1</span><br><span class="hljs-attr">transport.threadFactory.clientWorkerThreadPrefix</span>=<span class="hljs-string">NettyClientWorkerThread</span><br><span class="hljs-attr">transport.threadFactory.bossThreadSize</span>=<span class="hljs-string">1</span><br><span class="hljs-attr">transport.threadFactory.workerThreadSize</span>=<span class="hljs-string">default</span><br><span class="hljs-attr">transport.shutdown.wait</span>=<span class="hljs-string">3</span><br><span class="hljs-comment"># RM配置</span><br><span class="hljs-attr">client.rm.asyncCommitBufferLimit</span>=<span class="hljs-string">10000</span><br><span class="hljs-attr">client.rm.lock.retryInterval</span>=<span class="hljs-string">10</span><br><span class="hljs-attr">client.rm.lock.retryTimes</span>=<span class="hljs-string">30</span><br><span class="hljs-attr">client.rm.lock.retryPolicyBranchRollbackOnConflict</span>=<span class="hljs-string">true</span><br><span class="hljs-attr">client.rm.reportRetryCount</span>=<span class="hljs-string">5</span><br><span class="hljs-attr">client.rm.tableMetaCheckEnable</span>=<span class="hljs-string">false</span><br><span class="hljs-attr">client.rm.tableMetaCheckerInterval</span>=<span class="hljs-string">60000</span><br><span class="hljs-attr">client.rm.sqlParserType</span>=<span class="hljs-string">druid</span><br><span class="hljs-attr">client.rm.reportSuccessEnable</span>=<span class="hljs-string">false</span><br><span class="hljs-attr">client.rm.sagaBranchRegisterEnable</span>=<span class="hljs-string">false</span><br><span class="hljs-comment"># TM配置</span><br><span class="hljs-attr">client.tm.commitRetryCount</span>=<span class="hljs-string">5</span><br><span class="hljs-attr">client.tm.rollbackRetryCount</span>=<span class="hljs-string">5</span><br><span class="hljs-attr">client.tm.defaultGlobalTransactionTimeout</span>=<span class="hljs-string">60000</span><br><span class="hljs-attr">client.tm.degradeCheck</span>=<span class="hljs-string">false</span><br><span class="hljs-attr">client.tm.degradeCheckAllowTimes</span>=<span class="hljs-string">10</span><br><span class="hljs-attr">client.tm.degradeCheckPeriod</span>=<span class="hljs-string">2000</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># undo日志配置</span><br><span class="hljs-attr">client.undo.dataValidation</span>=<span class="hljs-string">true</span><br><span class="hljs-attr">client.undo.logSerialization</span>=<span class="hljs-string">jackson</span><br><span class="hljs-attr">client.undo.onlyCareUpdateColumns</span>=<span class="hljs-string">true</span><br><span class="hljs-attr">client.undo.logTable</span>=<span class="hljs-string">undo_log</span><br><span class="hljs-attr">client.undo.compress.enable</span>=<span class="hljs-string">true</span><br><span class="hljs-attr">client.undo.compress.type</span>=<span class="hljs-string">zip</span><br><span class="hljs-attr">client.undo.compress.threshold</span>=<span class="hljs-string">64k</span><br><span class="hljs-attr">client.log.exceptionRate</span>=<span class="hljs-string">100</span><br></code></pre></td></tr></table></figure><p>接下来，需要修改每一个微服务的application.yml文件，让微服务读取nacos中的client.properties文件：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">seata:</span><br>  <span class="hljs-attr">config:</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">nacos</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:8848</span><br>      <span class="hljs-attr">username:</span> <span class="hljs-string">nacos</span><br>      <span class="hljs-attr">password:</span> <span class="hljs-string">nacos</span><br>      <span class="hljs-attr">group:</span> <span class="hljs-string">SEATA_GROUP</span><br>      <span class="hljs-attr">data-id:</span> <span class="hljs-string">client.properties</span><br></code></pre></td></tr></table></figure><p>重启微服务，现在微服务到底是连接tc的SH集群，还是tc的HZ集群，都统一由nacos的client.properties来决定了。</p>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>seata</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通关微服务-sentinel</title>
    <link href="/posts/60bdb85a/"/>
    <url>/posts/60bdb85a/</url>
    
    <content type="html"><![CDATA[<h1 id="初识Sentinel"><a href="#初识Sentinel" class="headerlink" title="初识Sentinel"></a>初识Sentinel</h1><h2 id="雪崩问题及解决方案"><a href="#雪崩问题及解决方案" class="headerlink" title="雪崩问题及解决方案"></a>雪崩问题及解决方案</h2><h3 id="雪崩问题"><a href="#雪崩问题" class="headerlink" title="雪崩问题"></a>雪崩问题</h3><p>微服务中，服务间调用关系错综复杂，一个微服务往往依赖于多个其它微服务。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403201622916.png"></p><p>如图，如果服务提供者I发生了故障，当前的应用的部分业务因为依赖于服务I，因此也会被阻塞。此时，其它不依赖于服务I的业务似乎不受影响。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403201622974.png"></p><p>但是，依赖服务I的业务请求被阻塞，用户不会得到响应，则tomcat的这个线程不会释放，于是越来越多的用户请求到来，越来越多的线程会阻塞：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403201623895.png"></p><p>服务器支持的线程和并发数有限，请求一直阻塞，会导致服务器资源耗尽，从而导致所有其它服务都不可用，那么当前服务也就不可用了。</p><p>那么，依赖于当前服务的其它服务随着时间的推移，最终也都会变的不可用，形成<strong>级联失败</strong>，<strong>雪崩</strong>就发生了：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403201623726.png"></p><h3 id="超时处理"><a href="#超时处理" class="headerlink" title="超时处理"></a>超时处理</h3><p>解决雪崩问题的常见方式有四种：</p><p>方案一：超时处理，设定超时时间，请求超过一定时间没有响应就返回错误信息，不会无休止等待。</p><h3 id="舱壁模式"><a href="#舱壁模式" class="headerlink" title="舱壁模式"></a>舱壁模式</h3><p>方案2：仓壁模式</p><p>仓壁模式来源于船舱的设计：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403201627216.png"></p><p>船舱都会被隔板分离为多个独立空间，当船体破损时，只会导致部分空间进入，将故障控制在一定范围内，避免整个船体都被淹没。</p><p>于此类似，我们可以<strong>限定每个业务能使用的线程数，避免耗尽整个tomcat的资源</strong>，因此也叫<strong>线程隔离</strong>。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403201628541.png"></p><h3 id="断路器"><a href="#断路器" class="headerlink" title="断路器"></a>断路器</h3><p>方案三：</p><p>断路器模式：由<strong>断路器</strong>统计业务执行的异常比例，如果超出阈值则会<strong>熔断</strong>该业务，拦截访问该业务的一切请求。</p><p>断路器会统计访问某个服务的请求数量，异常比例：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403201629212.png"><br>当发现访问服务D的请求异常比例过高时，认为服务D有导致雪崩的风险，会拦截访问服务D的一切请求，形成熔断：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403201629751.png"></p><h3 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h3><p>方案四：</p><p><strong>流量控制</strong>：限制业务访问的QPS，避免服务因流量的突增而故障。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403201630512.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>什么是雪崩问题？</p><ul><li>微服务之间相互调用，因为调用链中的一个服务故障，引起整个链路都无法访问的情况。</li></ul><p>可以认为：</p><p><strong>限流</strong>是对服务的保护，避免因瞬间高并发流量而导致服务故障，进而避免雪崩。是一种<strong>预防</strong>措施。</p><p><strong>超时处理、线程隔离、降级熔断</strong>是在部分服务故障时，将故障控制在一定范围，避免雪崩。是一种<strong>补救</strong>措施。</p><h2 id="服务保护技术对比"><a href="#服务保护技术对比" class="headerlink" title="服务保护技术对比"></a>服务保护技术对比</h2><p>在SpringCloud当中支持多种服务保护技术：</p><ul><li><p><a href="https://github.com/Netflix/Hystrix">Netfix Hystrix</a></p></li><li><p><a href="https://github.com/alibaba/Sentinel">Sentinel</a></p></li><li><p><a href="https://github.com/resilience4j/resilience4j">Resilience4J</a></p></li></ul><p>早期比较流行的是Hystrix框架，但目前国内实用最广泛的还是阿里巴巴的Sentinel框架，这里我们做下对比：</p><table><thead><tr><th></th><th><strong>Sentinel</strong></th><th><strong>Hystrix</strong></th></tr></thead><tbody><tr><td>隔离策略</td><td>信号量隔离</td><td>线程池隔离&#x2F;信号量隔离</td></tr><tr><td>熔断降级策略</td><td>基于慢调用比例或异常比例</td><td>基于失败比率</td></tr><tr><td>实时指标实现</td><td>滑动窗口</td><td>滑动窗口（基于 RxJava）</td></tr><tr><td>规则配置</td><td>支持多种数据源</td><td>支持多种数据源</td></tr><tr><td>扩展性</td><td>多个扩展点</td><td>插件的形式</td></tr><tr><td>基于注解的支持</td><td>支持</td><td>支持</td></tr><tr><td>限流</td><td>基于 QPS，支持基于调用关系的限流</td><td>有限的支持</td></tr><tr><td>流量整形</td><td>支持慢启动、匀速排队模式</td><td>不支持</td></tr><tr><td>系统自适应保护</td><td>支持</td><td>不支持</td></tr><tr><td>控制台</td><td>开箱即用，可配置规则、查看秒级监控、机器发现等</td><td>不完善</td></tr><tr><td>常见框架的适配</td><td>Servlet、Spring Cloud、Dubbo、gRPC 等</td><td>Servlet、Spring Cloud Netflix</td></tr></tbody></table><h2 id="Sentinel安装"><a href="#Sentinel安装" class="headerlink" title="Sentinel安装"></a>Sentinel安装</h2><h3 id="Sentinel介绍"><a href="#Sentinel介绍" class="headerlink" title="Sentinel介绍"></a>Sentinel介绍</h3><p>Sentinel是阿里巴巴开源的一款微服务流量控制组件。官网地址：<a href="https://sentinelguard.io/zh-cn/index.html">https://sentinelguard.io/zh-cn/index.html</a></p><p>Sentinel 具有以下特征:</p><p>•<strong>丰富的应用场景</strong>：Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。</p><p>•<strong>完备的实时监控</strong>：Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。</p><p>•<strong>广泛的开源生态</strong>：Sentinel 提供开箱即用的与其它开源框架&#x2F;库的整合模块，例如与 Spring Cloud、Dubbo、gRPC 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel。</p><p>•<strong>完善的</strong> <strong>SPI</strong> <strong>扩展点</strong>：Sentinel 提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。</p><h3 id="Sentinel安装-1"><a href="#Sentinel安装-1" class="headerlink" title="Sentinel安装"></a>Sentinel安装</h3><p>1）下载</p><p>sentinel官方提供了UI控制台，方便我们对系统做限流设置。大家可以在<a href="https://github.com/alibaba/Sentinel/releases">GitHub</a>下载。</p><p>2）运行</p><p>将jar包放到任意非中文目录，执行命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">java -jar sentinel-dashboard-1.8.1.jar<br></code></pre></td></tr></table></figure><p>如果要修改Sentinel的默认端口、账户、密码，可以通过下列配置：</p><table><thead><tr><th><strong>配置项</strong></th><th><strong>默认值</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>server.port</td><td>8080</td><td>服务端口</td></tr><tr><td>sentinel.dashboard.auth.username</td><td>sentinel</td><td>默认用户名</td></tr><tr><td>sentinel.dashboard.auth.password</td><td>sentinel</td><td>默认密码</td></tr></tbody></table><p>例如，修改端口：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">java -Dserver.port=8090 -jar sentinel-dashboard-1.8.1.jar<br></code></pre></td></tr></table></figure><p>3）访问</p><p>访问<a href="http://localhost:8080/">http://localhost:8080</a>页面，就可以看到sentinel的控制台了：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403201633970.png"></p><p>需要输入账号和密码，默认都是：sentinel</p><p>登录后，会发现一片空白，什么都没有：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403201634695.png"><br>这是因为我们还没有与微服务整合。</p><h2 id="微服务整合Sentinel"><a href="#微服务整合Sentinel" class="headerlink" title="微服务整合Sentinel"></a>微服务整合Sentinel</h2><p>我们在order-service中整合sentinel，并连接sentinel的控制台，步骤如下：</p><p>1）引入sentinel依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pom">&lt;!--sentinel--&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; <br>    &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><p>2）配置控制台</p><p>修改application.yaml文件，添加下面内容：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8088</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span> <br>    <span class="hljs-attr">sentinel:</span><br>      <span class="hljs-attr">transport:</span><br>        <span class="hljs-attr">dashboard:</span> <span class="hljs-string">localhost:8080</span><br></code></pre></td></tr></table></figure><p>3）访问order-service的任意端点</p><p>打开浏览器，访问<a href="http://localhost:8088/order/101">http://localhost:8088/order/101</a>，这样才能触发sentinel的监控。</p><p>然后再访问sentinel的控制台，查看效果：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403201635377.png"></p><hr><h1 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h1><p>雪崩问题虽然有四种方案，但是限流是避免服务因突发的流量而发生故障，是对微服务雪崩问题的预防。我们先学习这种模式。</p><h2 id="簇点链路"><a href="#簇点链路" class="headerlink" title="簇点链路"></a>簇点链路</h2><p>当请求进入微服务时，首先会访问DispatcherServlet，然后进入Controller、Service、Mapper，这样的一个调用链就叫做<strong>簇点链路</strong>。簇点链路中被监控的每一个接口就是一个<strong>资源</strong>。</p><p>默认情况下sentinel会监控SpringMVC的每一个端点（Endpoint，也就是controller中的方法），因此SpringMVC的每一个端点（Endpoint）就是调用链路中的一个资源。</p><p>例如，我们刚才访问的order-service中的OrderController中的端点：&#x2F;order&#x2F;{orderId}</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403201636022.png"></p><p>流控、熔断等都是针对簇点链路中的资源来设置的，因此我们可以点击对应资源后面的按钮来设置规则：</p><ul><li><p>流控：流量控制</p></li><li><p>降级：降级熔断</p></li><li><p>热点：热点参数限流，是限流的一种</p></li><li><p>授权：请求的权限控制</p></li></ul><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p><strong>示例</strong></p><p>点击资源&#x2F;order&#x2F;{orderId}后面的流控按钮，就可以弹出表单。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403201637048.png"></p><p>表单中可以填写限流规则，如下：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403201638912.png"></p><p>其含义是限制 &#x2F;order&#x2F;{orderId}这个资源的单机QPS为1，即每秒只允许1次请求，超出的请求会被拦截并报错。</p><p><strong>练习</strong></p><p>1）首先在sentinel控制台添加限流规则</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403210933379.png"></p><p>2）利用jmeter测试</p><p>如果没有用过jmeter，可以参考网上资源</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403210933473.png"></p><p>20个用户，2秒内运行完，QPS是10，超过了5.</p><p>选中<code>流控入门，QPS&lt;5</code>右键运行：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403210934630.png"></p><p>结果：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403210934299.png"></p><p>可以看到，成功的请求每次只有5个。</p><h2 id="流控模式"><a href="#流控模式" class="headerlink" title="流控模式"></a>流控模式</h2><p>在添加限流规则时，点击高级选项，可以选择三种<strong>流控模式</strong>：</p><ul><li><p>直接：统计当前资源的请求，触发阈值时对当前资源直接限流，也是默认的模式</p></li><li><p>关联：统计与当前资源相关的另一个资源，触发阈值时，对当前资源限流</p></li><li><p>链路：统计从指定链路访问到本资源的请求，触发阈值时，对指定链路限流</p></li></ul><h3 id="直接模式"><a href="#直接模式" class="headerlink" title="直接模式"></a>直接模式</h3><blockquote><p>这个比较简单，就是限定当前资源。</p></blockquote><h3 id="关联模式"><a href="#关联模式" class="headerlink" title="关联模式"></a>关联模式</h3><p><strong>关联模式</strong>：统计与当前资源相关的另一个资源，触发阈值时，对当前资源限流。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403210935126.png"></p><p><strong>语法说明</strong>：当&#x2F;write资源访问量触发阈值时，就会对&#x2F;read资源限流，避免影响&#x2F;write资源。</p><p><strong>使用场景</strong>：比如用户支付时需要修改订单状态，同时用户要查询订单。查询和修改操作会争抢数据库锁，产生竞争。业务需求是优先支付和更新订单的业务，因此当修改订单业务触发阈值时，需要对查询订单业务限流。</p><p><strong>需求说明</strong>：</p><ul><li><p>在OrderController新建两个端点：&#x2F;order&#x2F;query和&#x2F;order&#x2F;update，无需实现业务</p></li><li><p>配置流控规则，当&#x2F;order&#x2F; update资源被访问的QPS超过5时，对&#x2F;order&#x2F;query请求限流</p></li></ul><p><strong>1）定义&#x2F;order&#x2F;query端点，模拟订单查询</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/query&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">queryOrder</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;查询订单成功&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2）定义&#x2F;order&#x2F;update端点，模拟订单更新</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/update&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">updateOrder</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;更新订单成功&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>重启服务，查看sentinel控制台的簇点链路：</strong></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403210937348.png"></p><p><strong>3）配置流控规则</strong></p><p>对哪个端点限流，就点击哪个端点后面的按钮。我们是对订单查询&#x2F;order&#x2F;query限流，因此点击它后面的按钮：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403210937589.png"></p><p>在表单中填写流控规则：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403210937312.png"></p><p><strong>4）在Jmeter测试</strong></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403210939715.png"></p><p>可以看到1000个用户，100秒，因此QPS为10，超过了我们设定的阈值：5</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403210939351.png"></p><p>请求的目标是&#x2F;order&#x2F;update，这样这个断点就会触发阈值。</p><p>但限流的目标是&#x2F;order&#x2F;query，我们在浏览器访问，可以发现：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211001774.png"></p><p>确实被限流了。</p><p><strong>5）总结</strong></p><p>满足下面条件可以使用关联模式：</p><ul><li>俩个有竞争关系的资源</li><li>一个优先级高，一个优先级低</li></ul><h3 id="链路模式"><a href="#链路模式" class="headerlink" title="链路模式"></a>链路模式</h3><p><strong>链路模式</strong>：只针对从指定链路访问到本资源的请求做统计，判断是否超过阈值。</p><p><strong>配置示例</strong>：</p><p>例如有两条请求链路：</p><ul><li><p>&#x2F;test1 –&gt; &#x2F;common</p></li><li><p>&#x2F;test2 –&gt; &#x2F;common</p></li></ul><p>如果只希望统计从&#x2F;test2进入到&#x2F;common的请求，则可以这样配置：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403210942613.png"></p><p><strong>实战案例</strong></p><p>需求：有查询订单和创建订单业务，两者都需要查询商品。针对从查询订单进入到查询商品的请求统计，并设置限流。因为创建订单显然比查询订单优先级更高。</p><p>步骤：</p><ol><li><p>在OrderService中添加一个queryGoods方法，不用实现业务</p></li><li><p>在OrderController中，改造&#x2F;order&#x2F;query端点，调用OrderService中的queryGoods方法</p></li><li><p>在OrderController中添加一个&#x2F;order&#x2F;save的端点，调用OrderService的queryGoods方法</p></li><li><p>给queryGoods设置限流规则，从&#x2F;order&#x2F;query进入queryGoods的方法限制QPS必须小于2</p></li></ol><p><strong>添加查询商品方法</strong></p><p>在order-service服务中，给OrderService类添加一个queryGoods方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">queryGoods</span><span class="hljs-params">()</span>&#123;<br>    System.err.println(<span class="hljs-string">&quot;查询商品&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>查询订单时，查询商品</strong></p><p>在order-service的OrderController中，修改&#x2F;order&#x2F;query端点的业务逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/query&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">queryOrder</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 查询商品</span><br>    orderService.queryGoods();<br>    <span class="hljs-comment">// 查询订单</span><br>    System.out.println(<span class="hljs-string">&quot;查询订单&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;查询订单成功&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>新增订单，查询商品</strong></p><p>在order-service的OrderController中，修改&#x2F;order&#x2F;save端点，模拟新增订单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/save&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">saveOrder</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 查询商品</span><br>    orderService.queryGoods();<br>    <span class="hljs-comment">// 查询订单</span><br>    System.err.println(<span class="hljs-string">&quot;新增订单&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;新增订单成功&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>给查询商品添加资源标记</strong></p><p>默认情况下，OrderService中的方法是不被Sentinel监控的，需要我们自己通过注解来标记要监控的方法。</p><p>给OrderService的queryGoods方法添加@SentinelResource注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SentinelResource(&quot;goods&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">queryGoods</span><span class="hljs-params">()</span>&#123;<br>    System.err.println(<span class="hljs-string">&quot;查询商品&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>链路模式中，是对不同来源的两个链路做监控。但是sentinel默认会给进入SpringMVC的所有请求设置同一个root资源，会导致链路模式失效。</p><p>我们需要关闭这种对SpringMVC的资源聚合，修改order-service服务的application.yml文件：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">sentinel:</span><br>      <span class="hljs-attr">web-context-unify:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 关闭context整合</span><br></code></pre></td></tr></table></figure><p>重启服务，访问&#x2F;order&#x2F;query和&#x2F;order&#x2F;save，可以查看到sentinel的簇点链路规则中，出现了新的资源：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403210947186.png"></p><p><strong>添加流控规则</strong></p><p>点击goods资源后面的流控按钮，在弹出的表单中填写下面信息：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403210948508.png"></p><p>只统计从&#x2F;order&#x2F;query进入&#x2F;goods的资源，QPS阈值为2，超出则被限流。</p><p><strong>Jmeter测试</strong></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403210949769.png"></p><p>可以看到这里200个用户，50秒内发完，QPS为4，超过了设定的阈值2</p><p>运行的结果：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403210949093.png"></p><p>另一个是访问&#x2F;order&#x2F;query：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403210950483.png"><br>每次只有2个通过。</p><p><strong>总结</strong></p><p>流控模式有哪些？</p><p>•直接：对当前资源限流</p><p>•关联：高优先级资源触发阈值，对低优先级资源限流。</p><p>•链路：阈值统计时，只统计从指定资源进入当前资源的请求，是对请求来源的限流</p><h2 id="流控效果"><a href="#流控效果" class="headerlink" title="流控效果"></a>流控效果</h2><p>在流控的高级选项中，还有一个流控效果选项：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403210953683.png"></p><p>流控效果是指请求达到流控阈值时应该采取的措施，包括三种：</p><ul><li><p>快速失败：达到阈值后，新的请求会被立即拒绝并抛出FlowException异常。是<strong>默认</strong>的处理方式。</p></li><li><p>warm up：预热模式，对超出阈值的请求同样是拒绝并抛出异常。但这种模式阈值会动态变化，从一个较小值逐渐增加到最大阈值。</p></li><li><p>排队等待：让所有的请求按照先后次序排队执行，两个请求的间隔不能小于指定时长</p></li></ul><h3 id="快速失败"><a href="#快速失败" class="headerlink" title="快速失败"></a>快速失败</h3><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211001774.png"></p><blockquote><p>这个比较简单，就是之前见到的。直接失败。</p></blockquote><h3 id="warm-up"><a href="#warm-up" class="headerlink" title="warm up"></a>warm up</h3><p>阈值一般是一个微服务能承担的最大QPS，但是一个服务刚刚启动时，一切资源尚未初始化（<strong>冷启动</strong>），如果直接将QPS跑到最大值，可能导致服务瞬间宕机。</p><p>warm up也叫<strong>预热模式</strong>，是应对服务冷启动的一种方案。请求阈值初始值是 maxThreshold &#x2F; coldFactor，持续指定时长后，逐渐提高到maxThreshold值。而coldFactor的默认值是3.</p><p>例如，我设置QPS的maxThreshold为10，预热时间为5秒，那么初始阈值就是 10 &#x2F; 3 ，也就是3，然后在5秒后逐渐增长到10。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403210956766.png"></p><p><strong>示例</strong></p><p>需求：给&#x2F;order&#x2F;{orderId}这个资源设置限流，最大QPS为10，利用warm up效果，预热时长为5秒</p><p><strong>配置流控规则</strong></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403210957348.png"></p><p><strong>Jmeter测试</strong></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403210958088.png"><br>QPS为10.</p><p>刚刚启动时，大部分请求失败，成功的只有3个，说明QPS被限定在3：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403210958552.png"></p><p>随着时间推移，成功比例越来越高：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403210958006.png"></p><p>到Sentinel控制台查看实时监控：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403210959712.png"></p><p>一段时间后：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403210959919.png"></p><h3 id="排队等待"><a href="#排队等待" class="headerlink" title="排队等待"></a>排队等待</h3><p>当请求超过QPS阈值时，快速失败和warm up 会拒绝新的请求并抛出异常。</p><p>而排队等待则是让所有请求进入一个队列中，然后按照阈值允许的时间间隔依次执行。后来的请求必须等待前面执行完成，如果请求预期的等待时间超出最大时长，则会被拒绝。</p><p>工作原理</p><p>例如：QPS &#x3D; 5，意味着每200ms处理一个队列中的请求；timeout &#x3D; 2000，意味着<strong>预期等待时长</strong>超过2000ms的请求会被拒绝并抛出异常。</p><p>那什么叫做预期等待时长呢？</p><p>比如现在一下子来了12 个请求，因为每200ms执行一个请求，那么：</p><ul><li><p>第6个请求的<strong>预期等待时长</strong> &#x3D; 200 * （6 - 1） &#x3D; 1000ms</p></li><li><p>第12个请求的预期等待时长 &#x3D; 200 * （12-1） &#x3D; 2200ms</p></li></ul><p>现在，第1秒同时接收到10个请求，但第2秒只有1个请求，此时QPS的曲线这样的：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211003476.png"><br>如果使用队列模式做流控，所有进入的请求都要排队，以固定的200ms的间隔执行，QPS会变的很平滑：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211003957.png"><br>平滑的QPS曲线，对于服务器来说是更友好的。</p><p><strong>示例</strong></p><p>需求：给&#x2F;order&#x2F;{orderId}这个资源设置限流，最大QPS为10，利用排队的流控效果，超时时长设置为5s。</p><p><strong>添加流控规则</strong></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211006346.png"></p><p><strong>jmeter测试</strong></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211007849.png"></p><p>QPS为15，已经超过了我们设定的10。</p><p>如果是之前的 快速失败、warmup模式，超出的请求应该会直接报错。</p><p>但是我们看看队列模式的运行结果：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211007087.png"><br>全部都通过了。</p><p>再去sentinel查看实时监控的QPS曲线：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211007595.png"></p><p>QPS非常平滑，一致保持在10，但是超出的请求没有被拒绝，而是放入队列。因此<strong>响应时间</strong>（等待时间）会越来越长。</p><p>当队列满了以后，才会有部分请求失败：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211008713.png"></p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>流控效果有哪些？</p><ul><li><p>快速失败：QPS超过阈值时，拒绝新的请求</p></li><li><p>warm up： QPS超过阈值时，拒绝新的请求；QPS阈值是逐渐提升的，可以避免冷启动时高并发导致服务宕机。</p></li><li><p>排队等待：请求会进入队列，按照阈值允许的时间间隔依次执行请求；如果请求预期等待时长大于超时时间，直接拒绝。</p></li></ul><h2 id="热点参数限流"><a href="#热点参数限流" class="headerlink" title="热点参数限流"></a>热点参数限流</h2><p>之前的限流是统计访问某个资源的所有请求，判断是否超过QPS阈值。而热点参数限流是<strong>分别统计参数值相同的请求</strong>，判断是否超过QPS阈值。</p><h3 id="全局参数限流"><a href="#全局参数限流" class="headerlink" title="全局参数限流"></a>全局参数限流</h3><p>例如，一个根据id查询商品的接口：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211037540.png"><br>访问&#x2F;goods&#x2F;{id}的请求中，id参数值会有变化，热点参数限流会根据参数值分别统计QPS，统计结果：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211037422.png"></p><p>当id&#x3D;1的请求触发阈值被限流时，id值不为1的请求不受影响。</p><p><strong>配置示例</strong></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211038072.png"></p><p>代表的含义是：对hot这个资源的0号参数（第一个参数）做统计，每1秒<strong>相同参数值</strong>的请求数不能超过5。</p><h3 id="热点参数限流-1"><a href="#热点参数限流-1" class="headerlink" title="热点参数限流"></a>热点参数限流</h3><p>刚才的配置中，对查询商品这个接口的所有商品一视同仁，QPS都限定为5.</p><p>而在实际开发中，可能部分商品是热点商品，例如秒杀商品，我们希望这部分商品的QPS限制与其它商品不一样，高一些。那就需要配置热点参数限流的高级选项了：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211039635.png"></p><p>结合上一个配置，这里的含义是对0号的long类型参数限流，每1秒相同参数的QPS不能超过5，有两个例外：</p><p>•如果参数值是100，则每1秒允许的QPS为10</p><p>•如果参数值是101，则每1秒允许的QPS为15</p><p><strong>案例</strong></p><p>给&#x2F;order&#x2F;{orderId}这个资源添加热点参数限流，规则如下：</p><p>•默认的热点参数规则是每1秒请求量不超过2</p><p>•给102这个参数设置例外：每1秒请求量不超过4</p><p>•给103这个参数设置例外：每1秒请求量不超过10</p><p><strong>注意事项</strong>：热点参数限流对默认的SpringMVC资源无效，需要利用@SentinelResource注解标记资源。</p><p><strong>标记资源</strong></p><p>给order-service中的OrderController中的&#x2F;order&#x2F;{orderId}资源添加注解：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211041889.png"></p><p>访问该接口，可以看到我们标记的hot资源出现了：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211041326.png"></p><p><u>这里不要点击hot后面的按钮，页面有BUG</u></p><p><strong>热点参数限流规则</strong></p><p>点击左侧菜单中<strong>热点规则</strong>菜单：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211042255.png"></p><p>点击新增，填写表单：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211042785.png"></p><hr><h1 id="隔离和降级"><a href="#隔离和降级" class="headerlink" title="隔离和降级"></a>隔离和降级</h1><p>限流是一种<strong>预防措施</strong>，虽然限流可以尽量避免因高并发而引起的服务故障，但服务还会因为其它原因而故障。</p><p>而要将这些故障控制在一定范围，避免雪崩，就要靠<strong>线程隔离</strong>（舱壁模式）和<strong>熔断降级</strong>手段了。</p><p><strong>线程隔离</strong>之前讲到过：调用者在调用服务提供者时，给每个调用的请求分配独立线程池，出现故障时，最多消耗这个线程池内资源，避免把调用者的所有资源耗尽。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211045299.png"></p><p><strong>熔断降级</strong>：是在调用方这边加入断路器，统计对服务提供者的调用，如果调用的失败比例过高，则熔断该业务，不允许访问该服务的提供者了。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211046098.png"><br>可以看到，不管是线程隔离还是熔断降级，都是对<strong>客户端</strong>（调用方）的保护。需要在<strong>调用方</strong> 发起远程调用时做线程隔离、或者服务熔断。</p><p>而我们的微服务远程调用都是基于Feign来完成的，因此我们需要将Feign与Sentinel整合，在Feign里面实现线程隔离和服务熔断。</p><h2 id="Feign整合Sentinel"><a href="#Feign整合Sentinel" class="headerlink" title="Feign整合Sentinel"></a>Feign整合Sentinel</h2><p>SpringCloud中，微服务调用都是通过Feign来实现的，因此做客户端保护必须整合Feign和Sentinel。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>修改OrderService的application.yml文件，开启Feign的Sentinel功能：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">sentinel:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 开启feign对sentinel的支持</span><br></code></pre></td></tr></table></figure><h3 id="编写失败降级逻辑"><a href="#编写失败降级逻辑" class="headerlink" title="编写失败降级逻辑"></a>编写失败降级逻辑</h3><p>业务失败后，不能直接报错，而应该返回用户一个友好提示或者默认结果，这个就是失败降级逻辑。</p><p>给FeignClient编写失败后的降级逻辑</p><p>①方式一：FallbackClass，无法对远程调用的异常做处理</p><p>②方式二：FallbackFactory，可以对远程调用的异常做处理，我们选择这种</p><p>这里我们演示方式二的失败降级处理。</p><p><strong>步骤一</strong>：在feing-api项目中定义类，实现FallbackFactory：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211048695.png"></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.feign.clients.fallback;<br><br><span class="hljs-keyword">import</span> cn.itcast.feign.clients.UserClient;<br><span class="hljs-keyword">import</span> cn.itcast.feign.pojo.User;<br><span class="hljs-keyword">import</span> feign.hystrix.FallbackFactory;<br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserClientFallbackFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FallbackFactory</span>&lt;UserClient&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> UserClient <span class="hljs-title function_">create</span><span class="hljs-params">(Throwable throwable)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserClient</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> User <span class="hljs-title function_">findById</span><span class="hljs-params">(Long id)</span> &#123;<br>                log.error(<span class="hljs-string">&quot;查询用户异常&quot;</span>, throwable);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>步骤二</strong>：在feing-api项目中的DefaultFeignConfiguration类中将UserClientFallbackFactory注册为一个Bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> UserClientFallbackFactory <span class="hljs-title function_">userClientFallbackFactory</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserClientFallbackFactory</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>步骤三</strong>：在feing-api项目中的UserClient接口中使用UserClientFallbackFactory：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> cn.itcast.feign.clients.fallback.UserClientFallbackFactory;<br><span class="hljs-keyword">import</span> cn.itcast.feign.pojo.User;<br><span class="hljs-keyword">import</span> org.springframework.cloud.openfeign.FeignClient;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PathVariable;<br><br><span class="hljs-meta">@FeignClient(value = &quot;userservice&quot;, fallbackFactory = UserClientFallbackFactory.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserClient</span> &#123;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span><br>    User <span class="hljs-title function_">findById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>重启后，访问一次订单查询业务，然后查看sentinel控制台，可以看到新的簇点链路：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211050740.png"></p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>Sentinel支持的雪崩解决方案：</p><ul><li><p>线程隔离（仓壁模式）</p></li><li><p>降级熔断</p></li></ul><p>Feign整合Sentinel的步骤：</p><ul><li><p>在application.yml中配置：feign.sentienl.enable&#x3D;true</p></li><li><p>给FeignClient编写FallbackFactory并注册为Bean</p></li><li><p>将FallbackFactory配置到FeignClient</p></li></ul><h2 id="线程隔离（舱壁模式）"><a href="#线程隔离（舱壁模式）" class="headerlink" title="线程隔离（舱壁模式）"></a>线程隔离（舱壁模式）</h2><h3 id="线程隔离实现"><a href="#线程隔离实现" class="headerlink" title="线程隔离实现"></a>线程隔离实现</h3><p>线程隔离有两种方式实现：</p><ul><li><p>线程池隔离</p></li><li><p>信号量隔离（Sentinel默认采用）</p></li></ul><p>如图：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211051735.png"></p><p><strong>线程池隔离</strong>：给每个服务调用业务分配一个线程池，利用线程池本身实现隔离效果</p><p><strong>信号量隔离</strong>：不创建线程池，而是计数器模式，记录业务使用的线程数量，达到信号量上限时，禁止新的请求。</p><p>两者的优缺点：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211052631.png"></p><blockquote><p>高扇出大概意思就是一个类或方法被大量引用。</p></blockquote><h3 id="sentinel的线程隔离"><a href="#sentinel的线程隔离" class="headerlink" title="sentinel的线程隔离"></a>sentinel的线程隔离</h3><p><strong>用法说明</strong>：</p><p>在添加限流规则时，可以选择两种阈值类型：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211102807.png"></p><ul><li><p>QPS：就是每秒的请求数，在快速入门中已经演示过</p></li><li><p>线程数：是该资源能使用用的tomcat线程数的最大值。也就是通过限制线程数量，实现<strong>线程隔离</strong>（舱壁模式）。</p></li></ul><p><strong>案例需求</strong></p><p>给 order-service服务中的UserClient的查询用户接口设置流控规则，线程数不能超过 2。然后利用jemeter测试。</p><p><strong>配置隔离规则</strong></p><p>选择feign接口后面的流控按钮：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211103001.png"></p><p>填写表单：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211103394.png"></p><p><strong>Jmeter测试</strong></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211103905.png"><br>一次发生10个请求，有较大概率并发线程数超过2，而超出的请求会走之前定义的失败降级逻辑。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211104471.png"><br>发现虽然结果都是通过了，不过部分请求得到的响应是<strong>降级</strong>返回的null信息。</p><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>线程隔离的两种手段是？</p><ul><li><p>信号量隔离</p></li><li><p>线程池隔离</p></li></ul><p>信号量隔离的特点是？</p><ul><li>基于计数器模式，简单，开销小</li></ul><p>线程池隔离的特点是？</p><ul><li>基于线程池模式，有额外开销，但隔离控制更强</li></ul><h2 id="熔断降级"><a href="#熔断降级" class="headerlink" title="熔断降级"></a>熔断降级</h2><p>熔断降级是解决雪崩问题的重要手段。其思路是由<strong>断路器</strong>统计服务调用的异常比例、慢请求比例，如果超出阈值则会<strong>熔断</strong>该服务。即拦截访问该服务的一切请求；而当服务恢复时，断路器会放行访问该服务的请求。</p><p>断路器控制熔断和放行是通过<strong>状态机</strong>来完成的：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211108475.png"><br>状态机包括三个状态：</p><ul><li><p>closed：关闭状态，断路器放行所有请求，并开始统计异常比例、慢请求比例。超过阈值则切换到open状态</p></li><li><p>open：打开状态，服务调用被<strong>熔断</strong>，访问被熔断服务的请求会被拒绝，快速失败，直接走降级逻辑。Open状态5秒后会进入half-open状态</p></li><li><p>half-open：半开状态，放行一次请求，根据执行结果来判断接下来的操作。</p><ul><li><p>请求成功：则切换到closed状态</p></li><li><p>请求失败：则切换到open状态</p></li></ul></li></ul><p>断路器熔断策略有三种：慢调用、异常比例、异常数</p><h3 id="慢调用"><a href="#慢调用" class="headerlink" title="慢调用"></a>慢调用</h3><p><strong>慢调用</strong>：业务的响应时长（RT）大于指定时长的请求认定为慢调用请求。在指定时间内，如果请求数量超过设定的最小数量，慢调用比例大于设定的阈值，则触发熔断。</p><p>例如：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211109424.png"></p><p>解读：RT超过500ms的调用是慢调用，统计最近10000ms内的请求，如果请求量超过10次，并且慢调用比例不低于0.5，则触发熔断，熔断时长为5秒。然后进入half-open状态，放行一次请求做测试。</p><p><strong>案例</strong></p><p>需求：给 UserClient的查询用户接口设置降级规则，慢调用的RT阈值为50ms，统计时间为1秒，最小请求数量为5，失败阈值比例为0.4，熔断时长为5</p><h4 id="设置慢调用"><a href="#设置慢调用" class="headerlink" title="设置慢调用"></a>设置慢调用</h4><p>修改user-service中的&#x2F;user&#x2F;{id}这个接口的业务。通过休眠模拟一个延迟时间：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211110602.png"></p><p>此时，orderId&#x3D;101的订单，关联的是id为1的用户，调用时长为60ms：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211110821.png"></p><p>orderId&#x3D;102的订单，关联的是id为2的用户，调用时长为非常短；</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211110153.png"></p><h4 id="设置熔断规则"><a href="#设置熔断规则" class="headerlink" title="设置熔断规则"></a>设置熔断规则</h4><p>下面，给feign接口设置降级规则：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211111950.png"></p><p>规则：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211111523.png"></p><p>超过50ms的请求都会被认为是慢请求</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>在浏览器访问：<a href="http://localhost:8088/order/101">http://localhost:8088/order/101</a>，快速刷新5次，可以发现：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211112950.png"></p><p>触发了熔断，请求时长缩短至5ms，快速失败了，并且走降级逻辑，返回的null</p><p>在浏览器访问：<a href="http://localhost:8088/order/102">http://localhost:8088/order/102</a>，竟然也被熔断了：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211112632.png"></p><h3 id="异常比例、异常数"><a href="#异常比例、异常数" class="headerlink" title="异常比例、异常数"></a>异常比例、异常数</h3><p><strong>异常比例或异常数</strong>：统计指定时间内的调用，如果调用次数超过指定请求数，并且出现异常的比例达到设定的比例阈值（或超过指定异常数），则触发熔断。</p><p>例如，一个异常比例设置：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211113604.png"></p><p>解读：统计最近1000ms内的请求，如果请求量超过10次，并且异常比例不低于0.4，则触发熔断。</p><p>一个异常数设置：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211113599.png"></p><p>解读：统计最近1000ms内的请求，如果请求量超过10次，并且异常比例不低于2次，则触发熔断。</p><p><strong>案例</strong></p><p>需求：给 UserClient的查询用户接口设置降级规则，统计时间为1秒，最小请求数量为5，失败阈值比例为0.4，熔断时长为5s</p><h4 id="设置异常请求"><a href="#设置异常请求" class="headerlink" title="设置异常请求"></a>设置异常请求</h4><p>首先，修改user-service中的&#x2F;user&#x2F;{id}这个接口的业务。手动抛出异常，以触发异常比例的熔断：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211114697.png"></p><p>也就是说，id 为 2时，就会触发异常</p><h4 id="设置熔断规则-1"><a href="#设置熔断规则-1" class="headerlink" title="设置熔断规则"></a>设置熔断规则</h4><p>下面，给feign接口设置降级规则：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211114178.png"></p><p>规则：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211114627.png"></p><p>在5次请求中，只要异常比例超过0.4，也就是有2次以上的异常，就会触发熔断。</p><h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><p>在浏览器快速访问：<a href="http://localhost:8088/order/102">http://localhost:8088/order/102</a>，快速刷新5次，触发熔断：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211115072.png"></p><p>此时，我们去访问本来应该正常的103：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211115298.png"></p><hr><h1 id="授权规则"><a href="#授权规则" class="headerlink" title="授权规则"></a>授权规则</h1><p>授权规则可以对请求方来源做判断和控制。</p><h2 id="授权规则-1"><a href="#授权规则-1" class="headerlink" title="授权规则"></a>授权规则</h2><h3 id="基本规则"><a href="#基本规则" class="headerlink" title="基本规则"></a>基本规则</h3><p>授权规则可以对调用方的来源做控制，有白名单和黑名单两种方式。</p><ul><li><p>白名单：来源（origin）在白名单内的调用者允许访问</p></li><li><p>黑名单：来源（origin）在黑名单内的调用者不允许访问</p></li></ul><p>点击左侧菜单的授权，可以看到授权规则：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211451942.png"></p><ul><li><p>资源名：就是受保护的资源，例如&#x2F;order&#x2F;{orderId}</p></li><li><p>流控应用：是来源者的名单，</p><ul><li><p>如果是勾选白名单，则名单中的来源被许可访问。</p></li><li><p>如果是勾选黑名单，则名单中的来源被禁止访问。</p></li></ul></li></ul><p>比如：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211451624.png"></p><p>我们允许请求从gateway到order-service，不允许浏览器访问order-service，那么白名单中就要填写<strong>网关的来源名称（origin）</strong>。</p><h3 id="获取origin"><a href="#获取origin" class="headerlink" title="获取origin"></a>获取origin</h3><p>Sentinel是通过RequestOriginParser这个接口的parseOrigin来获取请求的来源的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">RequestOriginParser</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从请求request对象中获取origin，获取方式自定义</span><br><span class="hljs-comment">     */</span><br>    String <span class="hljs-title function_">parseOrigin</span><span class="hljs-params">(HttpServletRequest request)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法的作用就是从request对象中，获取请求者的origin值并返回。</p><p>默认情况下，sentinel不管请求者从哪里来，返回值永远是default，也就是说一切请求的来源都被认为是一样的值default。</p><p>因此，我们需要自定义这个接口的实现，让<strong>不同的请求，返回不同的origin</strong>。</p><p>例如order-service服务中，我们定义一个RequestOriginParser的实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.order.sentinel;<br><br><span class="hljs-keyword">import</span> com.alibaba.csp.sentinel.adapter.spring.webmvc.callback.RequestOriginParser;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-keyword">import</span> org.springframework.util.StringUtils;<br><br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HeaderOriginParser</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RequestOriginParser</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">parseOrigin</span><span class="hljs-params">(HttpServletRequest request)</span> &#123;<br>        <span class="hljs-comment">// 1.获取请求头</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">origin</span> <span class="hljs-operator">=</span> request.getHeader(<span class="hljs-string">&quot;origin&quot;</span>);<br>        <span class="hljs-comment">// 2.非空判断</span><br>        <span class="hljs-keyword">if</span> (StringUtils.isEmpty(origin)) &#123;<br>            origin = <span class="hljs-string">&quot;blank&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> origin;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>尝试从request-header中获取origin值。</p><h3 id="给网关添加请求头"><a href="#给网关添加请求头" class="headerlink" title="给网关添加请求头"></a>给网关添加请求头</h3><p>既然获取请求origin的方式是从reques-header中获取origin值，我们必须让<strong>所有从gateway路由到微服务的请求都带上origin头</strong>。</p><p>这个需要利用之前学习的一个GatewayFilter来实现，AddRequestHeaderGatewayFilter。</p><p>修改gateway服务中的application.yml，添加一个defaultFilter：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">default-filters:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">AddRequestHeader=origin,gateway</span><br>      <span class="hljs-attr">routes:</span><br>       <span class="hljs-comment"># ...略</span><br></code></pre></td></tr></table></figure><p>这样，从gateway路由的所有请求都会带上origin头，值为gateway。而从其它地方到达微服务的请求则没有这个头。</p><h3 id="配置授权规则"><a href="#配置授权规则" class="headerlink" title="配置授权规则"></a>配置授权规则</h3><p>接下来，我们添加一个授权规则，放行origin值为gateway的请求。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211453591.png"></p><p>配置如下：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211454807.png"></p><p>现在，我们直接跳过网关，访问order-service服务：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211454231.png"></p><p>通过网关访问：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211454660.png"></p><h2 id="自定义异常结果"><a href="#自定义异常结果" class="headerlink" title="自定义异常结果"></a>自定义异常结果</h2><p>默认情况下，发生限流、降级、授权拦截时，都会抛出异常到调用方。异常结果都是flow limmiting（限流）。这样不够友好，无法得知是限流还是降级还是授权拦截。</p><h3 id="异常类型"><a href="#异常类型" class="headerlink" title="异常类型"></a>异常类型</h3><p>而如果要自定义异常时的返回结果，需要实现BlockExceptionHandler接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BlockExceptionHandler</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 处理请求被限流、降级、授权拦截时抛出的异常：BlockException</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, BlockException e)</span> <span class="hljs-keyword">throws</span> Exception;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法有三个参数：</p><ul><li><p>HttpServletRequest request：request对象</p></li><li><p>HttpServletResponse response：response对象</p></li><li><p>BlockException e：被sentinel拦截时抛出的异常</p></li></ul><p>这里的BlockException包含多个不同的子类：</p><table><thead><tr><th><strong>异常</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>FlowException</td><td>限流异常</td></tr><tr><td>ParamFlowException</td><td>热点参数限流的异常</td></tr><tr><td>DegradeException</td><td>降级异常</td></tr><tr><td>AuthorityException</td><td>授权规则异常</td></tr><tr><td>SystemBlockException</td><td>系统规则异常</td></tr></tbody></table><h3 id="自定义异常处理"><a href="#自定义异常处理" class="headerlink" title="自定义异常处理"></a>自定义异常处理</h3><p>下面，我们就在order-service定义一个自定义异常处理类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.order.sentinel;<br><br><span class="hljs-keyword">import</span> com.alibaba.csp.sentinel.adapter.spring.webmvc.callback.BlockExceptionHandler;<br><span class="hljs-keyword">import</span> com.alibaba.csp.sentinel.slots.block.BlockException;<br><span class="hljs-keyword">import</span> com.alibaba.csp.sentinel.slots.block.authority.AuthorityException;<br><span class="hljs-keyword">import</span> com.alibaba.csp.sentinel.slots.block.degrade.DegradeException;<br><span class="hljs-keyword">import</span> com.alibaba.csp.sentinel.slots.block.flow.FlowException;<br><span class="hljs-keyword">import</span> com.alibaba.csp.sentinel.slots.block.flow.param.ParamFlowException;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SentinelExceptionHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BlockExceptionHandler</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, BlockException e)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;未知异常&quot;</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span> <span class="hljs-number">429</span>;<br><br>        <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> FlowException) &#123;<br>            msg = <span class="hljs-string">&quot;请求被限流了&quot;</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> ParamFlowException) &#123;<br>            msg = <span class="hljs-string">&quot;请求被热点参数限流&quot;</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> DegradeException) &#123;<br>            msg = <span class="hljs-string">&quot;请求被降级了&quot;</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> AuthorityException) &#123;<br>            msg = <span class="hljs-string">&quot;没有权限访问&quot;</span>;<br>            status = <span class="hljs-number">401</span>;<br>        &#125;<br><br>        response.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);<br>        response.setStatus(status);<br>        response.getWriter().println(<span class="hljs-string">&quot;&#123;\&quot;msg\&quot;: &quot;</span> + msg + <span class="hljs-string">&quot;, \&quot;status\&quot;: &quot;</span> + status + <span class="hljs-string">&quot;&#125;&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>重启测试，在不同场景下，会返回不同的异常消息.</p><p>限流：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211455802.png"></p><p>授权拦截时：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211456560.png"></p><hr><h1 id="规则持久化"><a href="#规则持久化" class="headerlink" title="规则持久化"></a>规则持久化</h1><p>现在，sentinel的所有规则都是内存存储，重启后所有规则都会丢失。在生产环境下，我们必须确保这些规则的持久化，避免丢失。</p><h2 id="规则管理模式"><a href="#规则管理模式" class="headerlink" title="规则管理模式"></a>规则管理模式</h2><p>规则是否能持久化，取决于规则管理模式，sentinel支持三种规则管理模式：</p><ul><li><p>原始模式：Sentinel的默认模式，将规则保存在内存，重启服务会丢失。</p></li><li><p>pull模式</p></li><li><p>push模式</p></li></ul><h3 id="pull模式"><a href="#pull模式" class="headerlink" title="pull模式"></a>pull模式</h3><p>pull模式：控制台将配置的规则推送到Sentinel客户端，而客户端会将配置规则保存在本地文件或数据库中。以后会定时去本地文件或数据库中查询，更新本地规则。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211456550.png"></p><h3 id="push模式"><a href="#push模式" class="headerlink" title="push模式"></a>push模式</h3><p>push模式：控制台将配置规则推送到远程配置中心，例如Nacos。Sentinel客户端监听Nacos，获取配置变更的推送消息，完成本地配置更新。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403211457047.png"></p><blockquote><p>需要一些nacos配置，这里不再赘述。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sentinel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>elasticsearch-分布式搜索引擎</title>
    <link href="/posts/9b53a343/"/>
    <url>/posts/9b53a343/</url>
    
    <content type="html"><![CDATA[<h1 id="初识elasticsearch"><a href="#初识elasticsearch" class="headerlink" title="初识elasticsearch"></a>初识elasticsearch</h1><h2 id="了解elasticsearch"><a href="#了解elasticsearch" class="headerlink" title="了解elasticsearch"></a>了解elasticsearch</h2><h3 id="elasticsearch的作用"><a href="#elasticsearch的作用" class="headerlink" title="elasticsearch的作用"></a>elasticsearch的作用</h3><p>elasticsearch是一款非常强大的开源搜索引擎，具备非常多强大功能，可以帮助我们从海量数据中快速找到需要的内容。</p><p>例如：</p><ul><li>在GitHub搜索代码</li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191449586.png"></p><ul><li>在电商网站搜索商品</li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191450216.png"></p><ul><li>搜索答案</li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191450969.png"></p><ul><li>在打车软件搜索附近的车</li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191529477.png"></p><h3 id="ELK技术栈"><a href="#ELK技术栈" class="headerlink" title="ELK技术栈"></a>ELK技术栈</h3><p>elasticsearch结合kibana、Logstash、Beats，也就是elastic stack（ELK）。被广泛应用在日志数据分析、实时监控等领域：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191452686.png"></p><p>而elasticsearch是elastic stack的核心，负责存储、搜索、分析数据。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191452075.png"></p><h3 id="elasticsearch和Lucene"><a href="#elasticsearch和Lucene" class="headerlink" title="elasticsearch和Lucene"></a>elasticsearch和Lucene</h3><p>elasticsearch底层是基于<strong>lucene</strong>来实现的。</p><p><strong>Lucene</strong>是一个Java语言的搜索引擎类库，是Apache公司的顶级项目，由DougCutting于1999年研发。官网地址：<a href="https://lucene.apache.org/">https://lucene.apache.org/</a> 。</p><p>Lucene的优势：</p><ul><li>易扩展</li><li>高性能（基于倒排索引）<br>Lucene的缺点：</li><li>只限于Java语言的开发</li><li>学习曲线陡峭</li><li>不支持水平扩展</li></ul><p><strong>elasticsearch</strong>的发展历史：</p><ul><li>2004年Shay Banon基于Lucene开发了Compass</li><li>2010年Shay Banon 重写了Compass，取名为Elasticsearch。</li></ul><h3 id="其他搜索技术"><a href="#其他搜索技术" class="headerlink" title="其他搜索技术"></a>其他搜索技术</h3><p>目前比较知名的搜索引擎技术排名：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191454431.png"></p><p>虽然在早期，Apache Solr是最主要的搜索引擎技术，但随着发展elasticsearch已经渐渐超越了Solr，独占鳌头：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191511315.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>什么是elasticsearch？</p><ul><li>一个开源的分布式搜索引擎，可以用来实现搜索、日志统计、分析、系统监控等功能</li></ul><p>什么是elastic stack（ELK）？</p><ul><li>是以elasticsearch为核心的技术栈，包括beats、Logstash、kibana、elasticsearch</li></ul><p>什么是Lucene？</p><ul><li>是Apache的开源搜索引擎类库，提供了搜索引擎的核心API</li></ul><h2 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h2><p><strong>倒排索引的概念是基于MySQL这样的正向索引而言的。</strong></p><h3 id="正向索引"><a href="#正向索引" class="headerlink" title="正向索引"></a>正向索引</h3><p>那么什么是正向索引呢？例如给下表（tb_goods）中的id创建索引：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191522230.png"></p><p>如果是根据id查询，那么直接走索引，查询速度非常快。</p><p>但如果是基于title做模糊查询，只能是逐行扫描数据，流程如下：</p><p>1）用户搜索数据，条件是title符合<code>&quot;%手机%&quot;</code><br>2）逐行获取数据，比如id为1的数据<br>3）判断数据中的title是否符合用户搜索条件<br>4）如果符合则放入结果集，不符合则丢弃。回到步骤1</p><p><strong>逐行扫描，也就是全表扫描，随着数据量增加，其查询效率也会越来越低。当数据量达到数百万时，就是一场灾难</strong>。</p><h3 id="倒排索引-1"><a href="#倒排索引-1" class="headerlink" title="倒排索引"></a>倒排索引</h3><p>倒排索引中有两个非常重要的概念：</p><ul><li>文档（<code>Document</code>）：用来搜索的数据，其中的<font color="#0070c0"><strong>每一条数据就是一个文档</strong></font>。例如一个网页、一个商品信息</li><li>词条（<code>Term</code>）：对文档数据或用户搜索数据，<font color="#0070c0"><strong>利用某种算法分词，得到的具备含义的词语就是词条</strong></font>。例如：我是中国人，就可以分为：我、是、中国人、中国、国人这样的几个词条</li></ul><p><strong>创建倒排索引</strong>是对正向索引的一种特殊处理，流程如下：</p><ul><li>将每一个文档的数据利用算法分词，得到一个个词条</li><li>创建表，每行数据包括词条、词条所在文档id、位置等信息</li><li>因为词条唯一性，可以给词条创建索引，例如hash表结构索引</li></ul><p>如图：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191524789.png"></p><p>倒排索引的<strong>搜索流程</strong>如下（以搜索”华为手机”为例）：</p><p>1）用户输入条件<code>&quot;华为手机&quot;</code>进行搜索。<br>2）对用户输入内容<strong>分词</strong>，得到词条：<code>华为</code>、<code>手机</code>。<br>3）拿着词条在倒排索引中查找，可以得到包含词条的文档id：1、2、3。<br>4）拿着文档id到正向索引中查找具体文档。</p><p>如图：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191527835.png"></p><p>虽然要先查询倒排索引，再查询倒排索引，但是<font color="#0070c0"><strong>无论是词条、还是文档id都建立了索引，查询速度非常快！无需全表扫描</strong></font>。</p><h3 id="正向和倒排"><a href="#正向和倒排" class="headerlink" title="正向和倒排"></a>正向和倒排</h3><p>那么为什么一个叫做正向索引，一个叫做倒排索引呢？</p><ul><li><strong>正向索引</strong>是最传统的，根据id索引的方式。但根据词条查询时，必须先逐条获取每个文档，然后判断文档中是否包含所需要的词条，是<strong>根据文档找词条的过程</strong>。</li><li>而<strong>倒排索引</strong>则相反，是先找到用户要搜索的词条，根据词条得到包含词条的文档的id，然后根据id获取文档。是<strong>根据词条找文档的过程</strong>。</li></ul><p>是不是恰好反过来了？</p><p>那么两者方式的优缺点是什么呢？</p><p><strong>正向索引</strong>：</p><ul><li>优点：<ul><li>可以给多个字段创建索引</li><li>根据索引字段搜索、排序速度非常快</li></ul></li><li>缺点：<ul><li>根据非索引字段，或者索引字段中的部分词条查找时，只能全表扫描。</li></ul></li></ul><p><strong>倒排索引</strong>：</p><ul><li>优点：<ul><li>根据词条搜索、模糊搜索时，速度非常快</li></ul></li><li>缺点：<ul><li><u>只能给词条创建索引，而不是字段</u></li><li>无法根据字段做排序</li></ul></li></ul><h2 id="es的一些概念"><a href="#es的一些概念" class="headerlink" title="es的一些概念"></a>es的一些概念</h2><p>elasticsearch中有很多独有的概念，与mysql中略有差别，但也有相似之处。</p><h3 id="文档和字段"><a href="#文档和字段" class="headerlink" title="文档和字段"></a>文档和字段</h3><p>elasticsearch是面向文档（Document）存储的，可以是数据库中的一条商品数据，一个订单信息。文档数据会被序列化为json格式后，存储在elasticsearch中：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191532741.png"></p><p>而Json文档中往往包含很多的<strong>字段（Field）</strong>，类似于数据库中的列。</p><h3 id="索引和映射"><a href="#索引和映射" class="headerlink" title="索引和映射"></a>索引和映射</h3><p><strong>索引（Index）</strong>，就是相同类型的文档的集合。</p><p>例如：</p><ul><li>所有用户文档，就可以组织在一起，称为<strong>用户的索引</strong>；</li><li>所有商品的文档，可以组织在一起，称为<strong>商品的索引</strong>；</li><li>所有订单的文档，可以组织在一起，称为<strong>订单的索引</strong>；</li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191534677.png"><br>因此，我们可以<font color="#0070c0"><strong>把索引当做是数据库中的表</strong></font>。</p><p>数据库的表会有约束信息，用来定义表的结构、字段的名称、类型等信息。因此，索引库中就有<strong>映射（mapping）</strong>，是索引中文档的字段约束信息，类似表的结构约束。</p><h3 id="mysql与elasticsearch"><a href="#mysql与elasticsearch" class="headerlink" title="mysql与elasticsearch"></a>mysql与elasticsearch</h3><p>我们统一的把mysql与elasticsearch的概念做一下对比：</p><table><thead><tr><th><strong>MySQL</strong></th><th><strong>Elasticsearch</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>Table</td><td>Index</td><td>索引(index)，就是文档的集合，类似数据库的表(table)</td></tr><tr><td>Row</td><td>Document</td><td>文档（Document），就是一条条的数据，类似数据库中的行（Row），文档都是JSON格式</td></tr><tr><td>Column</td><td>Field</td><td>字段（Field），就是JSON文档中的字段，类似数据库中的列（Column）</td></tr><tr><td>Schema</td><td>Mapping</td><td>Mapping（映射）是索引中文档的约束，例如字段类型约束。类似数据库的表结构（Schema）</td></tr><tr><td>SQL</td><td>DSL</td><td>DSL是elasticsearch提供的JSON风格的请求语句，用来操作elasticsearch，实现CRUD</td></tr></tbody></table><p>是不是说，我们学习了elasticsearch就不再需要mysql了呢？</p><p>并不是如此，两者各自有自己的擅长支出：</p><ul><li>Mysql：擅长事务类型操作，可以确保数据的安全和一致性</li><li>Elasticsearch：擅长海量数据的搜索、分析、计算</li></ul><p>因此在企业中，往往是两者结合使用：</p><ul><li>对安全性要求较高的写操作，使用mysql实现</li><li>对查询性能要求较高的搜索需求，使用elasticsearch实现</li><li>两者再基于某种方式，实现数据的同步，保证一致性</li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191537870.png"></p><h1 id="DSL索引库操作"><a href="#DSL索引库操作" class="headerlink" title="DSL索引库操作"></a>DSL索引库操作</h1><p>索引库就类似数据库表，mapping映射就类似表的结构。</p><p>我们要向es中存储数据，必须先创建“库”和“表”。</p><h2 id="mapping映射属性"><a href="#mapping映射属性" class="headerlink" title="mapping映射属性"></a>mapping映射属性</h2><p>mapping是对索引库中文档的约束，常见的mapping属性包括：</p><ul><li>type：字段数据类型，常见的简单类型有：<ul><li>字符串：text（可分词的文本）、keyword（精确值，例如：品牌、国家、ip地址）</li><li>数值：long、integer、short、byte、double、float、</li><li>布尔：boolean</li><li>日期：date</li><li>对象：object</li></ul></li><li>index：是否创建索引，默认为true</li><li>analyzer：使用哪种分词器</li><li>properties：该字段的子字段</li></ul><p>例如下面的json文档：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">21</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;weight&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">52.1</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;isMarried&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;info&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Java程序员&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;email&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;zy@itcast.cn&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;score&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-number">99.1</span><span class="hljs-punctuation">,</span> <span class="hljs-number">99.5</span><span class="hljs-punctuation">,</span> <span class="hljs-number">98.9</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;firstName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;云&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;lastName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;赵&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>对应的每个字段映射（mapping）：</p><ul><li>age：类型为 integer；参与搜索，因此需要index为true；无需分词器</li><li>weight：类型为float；参与搜索，因此需要index为true；无需分词器</li><li>isMarried：类型为boolean；参与搜索，因此需要index为true；无需分词器</li><li>info：类型为字符串，需要分词，因此是text；参与搜索，因此需要index为true；分词器可以用ik_smart</li><li>email：类型为字符串，但是不需要分词，因此是keyword；不参与搜索，因此需要index为false；无需分词器</li><li>score：虽然是数组，但是我们只看元素的类型，类型为float；参与搜索，因此需要index为true；无需分词器</li><li>name：类型为object，需要定义多个子属性<ul><li>name.firstName；类型为字符串，但是不需要分词，因此是keyword；参与搜索，因此需要index为true；无需分词器</li><li>name.lastName；类型为字符串，但是不需要分词，因此是keyword；参与搜索，因此需要index为true；无需分词器</li></ul></li></ul><h2 id="索引库的CRUD"><a href="#索引库的CRUD" class="headerlink" title="索引库的CRUD"></a>索引库的CRUD</h2><p>这里我们统一使用Kibana编写DSL的方式来演示。</p><h3 id="创建索引库"><a href="#创建索引库" class="headerlink" title="创建索引库"></a>创建索引库</h3><p><strong>基本语法</strong>：</p><ul><li>请求方式：PUT</li><li>请求路径：&#x2F;索引库名，可以自定义</li><li>请求参数：mapping映射</li></ul><p><strong>格式</strong>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs json">PUT /索引库名称<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;mappings&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;字段名&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;analyzer&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ik_smart&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;字段名2&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;keyword&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;index&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;false&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;字段名3&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;子字段&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;keyword&quot;</span><br>          <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-comment">// ...略</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>示例</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs sh">PUT /heima<br>&#123;<br>  <span class="hljs-string">&quot;mappings&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;properties&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;info&quot;</span>:&#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;text&quot;</span>,<br>        <span class="hljs-string">&quot;analyzer&quot;</span>: <span class="hljs-string">&quot;ik_smart&quot;</span><br>      &#125;,<br>      <span class="hljs-string">&quot;email&quot;</span>:&#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span>,<br>        <span class="hljs-string">&quot;index&quot;</span>: <span class="hljs-string">&quot;falsae&quot;</span><br>      &#125;,<br>      <span class="hljs-string">&quot;name&quot;</span>:&#123;<br>        <span class="hljs-string">&quot;properties&quot;</span>: &#123;<br>          <span class="hljs-string">&quot;firstName&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span><br>          &#125;<br>        &#125;<br>      &#125;,<br>      // ... 略<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="查询索引库"><a href="#查询索引库" class="headerlink" title="查询索引库"></a>查询索引库</h3><p><strong>基本语法</strong>：</p><ul><li>请求方式：GET</li><li>请求路径：&#x2F;索引库名</li><li>请求参数：无</li></ul><p><strong>格式</strong>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /索引库名<br></code></pre></td></tr></table></figure><p><strong>示例</strong>：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191544292.png"></p><h3 id="修改索引库"><a href="#修改索引库" class="headerlink" title="修改索引库"></a>修改索引库</h3><p>倒排索引结构虽然不复杂，但是一旦数据结构改变（比如改变了分词器），就需要重新创建倒排索引，这简直是灾难。因此索引库<strong>一旦创建，无法修改mapping</strong>。</p><p>虽然无法修改mapping中已有的字段，但是却允许添加新的字段到mapping中，因为不会对倒排索引产生影响。</p><p><strong>语法说明</strong>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json">PUT /索引库名/_mapping<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;新字段名&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;integer&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>示例</strong>：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191546902.png"></p><h3 id="删除索引库"><a href="#删除索引库" class="headerlink" title="删除索引库"></a>删除索引库</h3><p><strong>语法：</strong></p><ul><li>请求方式：DELETE</li><li>请求路径：&#x2F;索引库名</li><li>请求参数：无</li></ul><p><strong>格式：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">DELETE /索引库名<br></code></pre></td></tr></table></figure><p>在kibana中测试：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191546709.png"></p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>索引库操作有哪些？</p><ul><li>创建索引库：PUT &#x2F;索引库名</li><li>查询索引库：GET &#x2F;索引库名</li><li>删除索引库：DELETE &#x2F;索引库名</li><li>添加字段：PUT &#x2F;索引库名&#x2F;_mapping</li></ul><h1 id="DSL文档操作"><a href="#DSL文档操作" class="headerlink" title="DSL文档操作"></a>DSL文档操作</h1><h2 id="新增文档"><a href="#新增文档" class="headerlink" title="新增文档"></a>新增文档</h2><p><strong>语法</strong>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json">POST /索引库名/_doc/文档id<br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;字段1&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;值1&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;字段2&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;值2&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;字段3&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;子属性1&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;值3&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;子属性2&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;值4&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-comment">// ...</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>示例</strong>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json">POST /heima/_doc/<span class="hljs-number">1</span><br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;info&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;黑马程序员Java讲师&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;email&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;zy@itcast.cn&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;firstName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;云&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;lastName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;赵&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>响应</strong>：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191549148.png"></p><h2 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h2><p>根据rest风格，新增是post，查询应该是get，不过查询一般都需要条件，这里我们把文档id带上。</p><p><strong>语法：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /<span class="hljs-punctuation">&#123;</span>索引库名称<span class="hljs-punctuation">&#125;</span>/_doc/<span class="hljs-punctuation">&#123;</span>id<span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>通过kibana查看数据：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /heima/_doc/<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>查看结果：</strong></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191550203.png"></p><h2 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h2><p>删除使用DELETE请求，同样，需要根据id进行删除：</p><p><strong>语法：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">DELETE /<span class="hljs-punctuation">&#123;</span>索引库名<span class="hljs-punctuation">&#125;</span>/_doc/id值<br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs json"># 根据id删除数据<br>DELETE /heima/_doc/<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>结果：</strong></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191551376.png"></p><h2 id="修改文档"><a href="#修改文档" class="headerlink" title="修改文档"></a>修改文档</h2><p>修改有两种方式：</p><ul><li>全量修改：直接覆盖原来的文档</li><li>增量修改：修改文档中的部分字段</li></ul><h3 id="全量修改"><a href="#全量修改" class="headerlink" title="全量修改"></a>全量修改</h3><p>全量修改是覆盖原来的文档，其本质是：</p><ul><li>根据指定的id删除文档</li><li>新增一个相同id的文档</li></ul><p><strong>注意</strong>：如果根据id删除时，id不存在，第二步的新增也会执行，也就从修改变成了新增操作了。</p><p><strong>语法：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">PUT /<span class="hljs-punctuation">&#123;</span>索引库名<span class="hljs-punctuation">&#125;</span>/_doc/文档id<br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;字段1&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;值1&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;字段2&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;值2&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-comment">// ... 略</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json">PUT /heima/_doc/<span class="hljs-number">1</span><br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;info&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;黑马程序员高级Java讲师&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;email&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;zy@itcast.cn&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;firstName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;云&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;lastName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;赵&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="增量修改"><a href="#增量修改" class="headerlink" title="增量修改"></a>增量修改</h3><p>增量修改是只修改指定id匹配的文档中的部分字段。</p><p><strong>语法：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">POST /<span class="hljs-punctuation">&#123;</span>索引库名<span class="hljs-punctuation">&#125;</span>/_update/文档id<br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;doc&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>         <span class="hljs-attr">&quot;字段名&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;新的值&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">POST /heima/_update/<span class="hljs-number">1</span><br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;doc&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;email&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ZhaoYun@itcast.cn&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>文档操作有哪些？</p><ul><li>创建文档：POST &#x2F;{索引库名}&#x2F;_doc&#x2F;文档id { json文档 }</li><li>查询文档：GET &#x2F;{索引库名}&#x2F;_doc&#x2F;文档id</li><li>删除文档：DELETE &#x2F;{索引库名}&#x2F;_doc&#x2F;文档id</li><li>修改文档：<ul><li>全量修改：PUT &#x2F;{索引库名}&#x2F;_doc&#x2F;文档id { json文档 }</li><li>增量修改：POST &#x2F;{索引库名}&#x2F;_update&#x2F;文档id { “doc”: {字段}}</li></ul></li></ul><h1 id="RestApi"><a href="#RestApi" class="headerlink" title="RestApi"></a>RestApi</h1><p>ES官方提供了各种不同语言的客户端，用来操作ES。这些客户端的本质就是组装DSL语句，通过http请求发送给ES。官方文档地址：<a href="https://www.elastic.co/guide/en/elasticsearch/client/index.html">https://www.elastic.co/guide/en/elasticsearch/client/index.html</a></p><p>其中的Java Rest Client又包括两种：</p><ul><li>Java Low Level Rest Client</li><li>Java High Level Rest Client</li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191557974.png"></p><blockquote><p>Java REST Client 有两种风格：<br>Java Low Level REST Client ：用于Elasticsearch的官方低级客户端。它允许通过http与Elasticsearch集群通信。将请求编排和响应反编排留给用户自己处理。它兼容所有的Elasticsearch版本。（PS：学过WebService的话，对编排与反编排这个概念。应该不陌生。可以理解为对请求参数的封装，以及对响应结果的解析）</p><p>Java High Level REST Client ：用于Elasticsearch的官方高级客户端。它是基于低级客户端的，它提供很多API，并负责请求的编排与响应的反编排。（PS：就好比是，一个是传自己拼接好的字符串，并且自己解析返回的结果；而另一个是传对象，返回的结果也已经封装好了，直接是对象，更加规范了参数的名称以及格式，更加面对对象一点）（PS：所谓低级与高级，我觉得一个很形象的比喻是，面向过程编程与面向对象编程）使用需与ES版本保持一致。</p><p>在 Elasticsearch 7.0 中不建议使用TransportClient，并且在8.0中会完全删除TransportClient。因此，官方更建议我们用Java High Level REST Client，它执行HTTP请求，而不是序列号的Java请求。既然如此，这里就直接用高级了。</p></blockquote><h2 id="导入Demo"><a href="#导入Demo" class="headerlink" title="导入Demo"></a>导入Demo</h2><h3 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h3><p>首先导入资料提供的数据库数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `tb_hotel` (<br>  `id` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;酒店id&#x27;</span>,<br>  `name` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;酒店名称；例：7天酒店&#x27;</span>,<br>  `address` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;酒店地址；例：航头路&#x27;</span>,<br>  `price` <span class="hljs-type">int</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;酒店价格；例：329&#x27;</span>,<br>  `score` <span class="hljs-type">int</span>(<span class="hljs-number">2</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;酒店评分；例：45，就是4.5分&#x27;</span>,<br>  `brand` <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;酒店品牌；例：如家&#x27;</span>,<br>  `city` <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;所在城市；例：上海&#x27;</span>,<br>  `star_name` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;酒店星级，从低到高分别是：1星到5星，1钻到5钻&#x27;</span>,<br>  `business` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;商圈；例：虹桥&#x27;</span>,<br>  `latitude` <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;纬度；例：31.2497&#x27;</span>,<br>  `longitude` <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;经度；例：120.3925&#x27;</span>,<br>  `pic` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;酒店图片；例:/img/1.jpg&#x27;</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8mb4;<br></code></pre></td></tr></table></figure><h3 id="导入项目"><a href="#导入项目" class="headerlink" title="导入项目"></a>导入项目</h3><p>项目结构如图：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191602083.png"></p><h3 id="mapping映射分析"><a href="#mapping映射分析" class="headerlink" title="mapping映射分析"></a>mapping映射分析</h3><p>创建索引库，最关键的是mapping映射，而mapping映射要考虑的信息包括：</p><ul><li>字段名</li><li>字段数据类型</li><li>是否参与搜索</li><li>是否需要分词</li><li>如果分词，分词器是什么？</li></ul><p>其中：</p><ul><li>字段名、字段数据类型，可以参考数据表结构的名称和类型</li><li>是否参与搜索要分析业务来判断，例如图片地址，就无需参与搜索</li><li>是否分词呢要看内容，内容如果是一个整体就无需分词，反之则要分词</li><li>分词器，我们可以统一使用ik_max_word</li></ul><p>来看下酒店数据的索引库结构:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs json">PUT /hotel<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;mappings&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;keyword&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;analyzer&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ik_max_word&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;copy_to&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;all&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;address&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;keyword&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;index&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;price&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;integer&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;score&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;integer&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;brand&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;keyword&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;copy_to&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;all&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;city&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;keyword&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;copy_to&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;all&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;starName&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;keyword&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;business&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;keyword&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;location&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;geo_point&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;pic&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;keyword&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;index&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;all&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;analyzer&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ik_max_word&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>几个特殊字段说明：</p><ul><li>location：地理坐标，里面包含精度、纬度</li><li>all：一个组合字段，其目的是将多字段的值 利用copy_to合并，提供给用户搜索</li></ul><p><strong>地理坐标说明：</strong></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191604786.png"></p><p><strong>copy_to说明：</strong></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191604974.png"></p><h3 id="初始化RestClient"><a href="#初始化RestClient" class="headerlink" title="初始化RestClient"></a>初始化RestClient</h3><p>在elasticsearch提供的API中，与elasticsearch一切交互都封装在一个名为RestHighLevelClient的类中，必须先完成这个对象的初始化，建立与elasticsearch的连接。</p><p>分为三步：</p><p>1）引入es的RestHighLevelClient依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pom">&lt;dependency&gt;<br>    &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt;<br>    &lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><p>2）因为SpringBoot默认的ES版本是7.6.2，所以我们需要覆盖默认的ES版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pom">&lt;properties&gt;<br>    &lt;java.version&gt;1.8&lt;/java.version&gt;<br>    &lt;elasticsearch.version&gt;7.12.1&lt;/elasticsearch.version&gt;<br>&lt;/properties&gt;<br></code></pre></td></tr></table></figure><p>3）初始化RestHighLevelClient：</p><p>初始化的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">RestHighLevelClient</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestHighLevelClient</span>(RestClient.builder(<br>        HttpHost.create(<span class="hljs-string">&quot;http://192.168.150.101:9200&quot;</span>)<br>));<br></code></pre></td></tr></table></figure><p>这里为了单元测试方便，我们创建一个测试类HotelIndexTest，然后将初始化的代码编写在@BeforeEach方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.hotel;<br><br><span class="hljs-keyword">import</span> org.apache.http.HttpHost;<br><span class="hljs-keyword">import</span> org.elasticsearch.client.RestHighLevelClient;<br><span class="hljs-keyword">import</span> org.junit.jupiter.api.AfterEach;<br><span class="hljs-keyword">import</span> org.junit.jupiter.api.BeforeEach;<br><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HotelIndexTest</span> &#123;<br>    <span class="hljs-keyword">private</span> RestHighLevelClient client;<br><br>    <span class="hljs-meta">@BeforeEach</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUp</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.client = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestHighLevelClient</span>(RestClient.builder(<br>                HttpHost.create(<span class="hljs-string">&quot;http://192.168.150.101:9200&quot;</span>)<br>        ));<br>    &#125;<br><br>    <span class="hljs-meta">@AfterEach</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">tearDown</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-built_in">this</span>.client.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="RestClient索引库操作"><a href="#RestClient索引库操作" class="headerlink" title="RestClient索引库操作"></a>RestClient索引库操作</h1><h2 id="创建索引库-1"><a href="#创建索引库-1" class="headerlink" title="创建索引库"></a>创建索引库</h2><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>创建索引库的API如下：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191607163.png"></p><p>代码分为三步：</p><ul><li>1）创建Request对象。因为是创建索引库的操作，因此Request是CreateIndexRequest。</li><li>2）添加请求参数，其实就是DSL的JSON参数部分。因为json字符串很长，这里是定义了静态字符串常量MAPPING_TEMPLATE，让代码看起来更加优雅。</li><li>3）发送请求，client.indices()方法的返回值是IndicesClient类型，封装了所有与索引库操作有关的方法。</li></ul><h3 id="完整示例"><a href="#完整示例" class="headerlink" title="完整示例"></a>完整示例</h3><p>在hotel-demo的cn.itcast.hotel.constants包下，创建一个类，定义mapping映射的JSON字符串常量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.hotel.constants;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HotelConstants</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">MAPPING_TEMPLATE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;  \&quot;mappings\&quot;: &#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;    \&quot;properties\&quot;: &#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;      \&quot;id\&quot;: &#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;\n&quot;</span> +<br>            <span class="hljs-string">&quot;      &#125;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;      \&quot;name\&quot;:&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;type\&quot;: \&quot;text\&quot;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;analyzer\&quot;: \&quot;ik_max_word\&quot;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;copy_to\&quot;: \&quot;all\&quot;\n&quot;</span> +<br>            <span class="hljs-string">&quot;      &#125;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;      \&quot;address\&quot;:&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;index\&quot;: false\n&quot;</span> +<br>            <span class="hljs-string">&quot;      &#125;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;      \&quot;price\&quot;:&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;type\&quot;: \&quot;integer\&quot;\n&quot;</span> +<br>            <span class="hljs-string">&quot;      &#125;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;      \&quot;score\&quot;:&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;type\&quot;: \&quot;integer\&quot;\n&quot;</span> +<br>            <span class="hljs-string">&quot;      &#125;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;      \&quot;brand\&quot;:&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;copy_to\&quot;: \&quot;all\&quot;\n&quot;</span> +<br>            <span class="hljs-string">&quot;      &#125;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;      \&quot;city\&quot;:&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;copy_to\&quot;: \&quot;all\&quot;\n&quot;</span> +<br>            <span class="hljs-string">&quot;      &#125;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;      \&quot;starName\&quot;:&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;\n&quot;</span> +<br>            <span class="hljs-string">&quot;      &#125;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;      \&quot;business\&quot;:&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;\n&quot;</span> +<br>            <span class="hljs-string">&quot;      &#125;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;      \&quot;location\&quot;:&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;type\&quot;: \&quot;geo_point\&quot;\n&quot;</span> +<br>            <span class="hljs-string">&quot;      &#125;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;      \&quot;pic\&quot;:&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;index\&quot;: false\n&quot;</span> +<br>            <span class="hljs-string">&quot;      &#125;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;      \&quot;all\&quot;:&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;type\&quot;: \&quot;text\&quot;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;analyzer\&quot;: \&quot;ik_max_word\&quot;\n&quot;</span> +<br>            <span class="hljs-string">&quot;      &#125;\n&quot;</span> +<br>            <span class="hljs-string">&quot;    &#125;\n&quot;</span> +<br>            <span class="hljs-string">&quot;  &#125;\n&quot;</span> +<br>            <span class="hljs-string">&quot;&#125;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在hotel-demo中的HotelIndexTest测试类中，编写单元测试，实现创建索引：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">createHotelIndex</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 1.创建Request对象</span><br>    <span class="hljs-type">CreateIndexRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CreateIndexRequest</span>(<span class="hljs-string">&quot;hotel&quot;</span>);<br>    <span class="hljs-comment">// 2.准备请求的参数：DSL语句</span><br>    request.source(MAPPING_TEMPLATE, XContentType.JSON);<br>    <span class="hljs-comment">// 3.发送请求</span><br>    client.indices().create(request, RequestOptions.DEFAULT);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="删除索引库-1"><a href="#删除索引库-1" class="headerlink" title="删除索引库"></a>删除索引库</h2><p>删除索引库的DSL语句非常简单：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">DELETE /hotel<br></code></pre></td></tr></table></figure><p>与创建索引库相比：</p><ul><li>请求方式从PUT变为DELTE</li><li>请求路径不变</li><li>无请求参数</li></ul><p>所以代码的差异，注意体现在Request对象上。依然是三步走：</p><ul><li>1）创建Request对象。这次是DeleteIndexRequest对象</li><li>2）准备参数。这里是无参</li><li>3）发送请求。改用delete方法</li></ul><p>在hotel-demo中的HotelIndexTest测试类中，编写单元测试，实现删除索引：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testDeleteHotelIndex</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 1.创建Request对象</span><br>    <span class="hljs-type">DeleteIndexRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DeleteIndexRequest</span>(<span class="hljs-string">&quot;hotel&quot;</span>);<br>    <span class="hljs-comment">// 2.发送请求</span><br>    client.indices().delete(request, RequestOptions.DEFAULT);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="判断索引库是否存在"><a href="#判断索引库是否存在" class="headerlink" title="判断索引库是否存在"></a>判断索引库是否存在</h2><p>判断索引库是否存在，本质就是查询，对应的DSL是：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /hotel<br></code></pre></td></tr></table></figure><p>因此与删除的Java代码流程是类似的。依然是三步走：</p><ul><li>1）创建Request对象。这次是GetIndexRequest对象</li><li>2）准备参数。这里是无参</li><li>3）发送请求。改用exists方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testExistsHotelIndex</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 1.创建Request对象</span><br>    <span class="hljs-type">GetIndexRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GetIndexRequest</span>(<span class="hljs-string">&quot;hotel&quot;</span>);<br>    <span class="hljs-comment">// 2.发送请求</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">exists</span> <span class="hljs-operator">=</span> client.indices().exists(request, RequestOptions.DEFAULT);<br>    <span class="hljs-comment">// 3.输出</span><br>    System.err.println(exists ? <span class="hljs-string">&quot;索引库已经存在！&quot;</span> : <span class="hljs-string">&quot;索引库不存在！&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>JavaRestClient操作elasticsearch的流程基本类似。核心是client.indices()方法来获取索引库的操作对象。</p><p>索引库操作的基本步骤：</p><ul><li>初始化RestHighLevelClient</li><li>创建XxxIndexRequest。XXX是Create、Get、Delete</li><li>准备DSL（ Create时需要，其它是无参）</li><li>发送请求。调用RestHighLevelClient#indices().xxx()方法，xxx是create、exists、delete</li></ul><h1 id="RestClient文档操作"><a href="#RestClient文档操作" class="headerlink" title="RestClient文档操作"></a>RestClient文档操作</h1><blockquote><p>为了与索引库操作分离，我们再次参加一个测试类，做两件事情：</p></blockquote><ul><li>初始化RestHighLevelClient</li><li>我们的酒店数据在数据库，需要利用IHotelService去查询，所以注入这个接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.hotel;<br><br><span class="hljs-keyword">import</span> cn.itcast.hotel.pojo.Hotel;<br><span class="hljs-keyword">import</span> cn.itcast.hotel.service.IHotelService;<br><span class="hljs-keyword">import</span> org.junit.jupiter.api.AfterEach;<br><span class="hljs-keyword">import</span> org.junit.jupiter.api.BeforeEach;<br><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.boot.test.context.SpringBootTest;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HotelDocumentTest</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> IHotelService hotelService;<br><br>    <span class="hljs-keyword">private</span> RestHighLevelClient client;<br><br>    <span class="hljs-meta">@BeforeEach</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUp</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.client = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestHighLevelClient</span>(RestClient.builder(<br>                HttpHost.create(<span class="hljs-string">&quot;http://192.168.150.101:9200&quot;</span>)<br>        ));<br>    &#125;<br><br>    <span class="hljs-meta">@AfterEach</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">tearDown</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-built_in">this</span>.client.close();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="新增文档-1"><a href="#新增文档-1" class="headerlink" title="新增文档"></a>新增文档</h2><p>我们要将数据库的酒店数据查询出来，写入elasticsearch中。</p><h3 id="索引库实体类"><a href="#索引库实体类" class="headerlink" title="索引库实体类"></a>索引库实体类</h3><p>数据库查询后的结果是一个Hotel类型的对象。结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@TableName(&quot;tb_hotel&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hotel</span> &#123;<br>    <span class="hljs-meta">@TableId(type = IdType.INPUT)</span><br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String address;<br>    <span class="hljs-keyword">private</span> Integer price;<br>    <span class="hljs-keyword">private</span> Integer score;<br>    <span class="hljs-keyword">private</span> String brand;<br>    <span class="hljs-keyword">private</span> String city;<br>    <span class="hljs-keyword">private</span> String starName;<br>    <span class="hljs-keyword">private</span> String business;<br>    <span class="hljs-keyword">private</span> String longitude;<br>    <span class="hljs-keyword">private</span> String latitude;<br>    <span class="hljs-keyword">private</span> String pic;<br>&#125;<br></code></pre></td></tr></table></figure><p>与我们的索引库结构存在差异：</p><ul><li>longitude和latitude需要合并为location</li></ul><p>因此，我们需要定义一个新的类型，与索引库结构吻合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.hotel.pojo;<br><br><span class="hljs-keyword">import</span> lombok.Data;<br><span class="hljs-keyword">import</span> lombok.NoArgsConstructor;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HotelDoc</span> &#123;<br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String address;<br>    <span class="hljs-keyword">private</span> Integer price;<br>    <span class="hljs-keyword">private</span> Integer score;<br>    <span class="hljs-keyword">private</span> String brand;<br>    <span class="hljs-keyword">private</span> String city;<br>    <span class="hljs-keyword">private</span> String starName;<br>    <span class="hljs-keyword">private</span> String business;<br>    <span class="hljs-keyword">private</span> String location;<br>    <span class="hljs-keyword">private</span> String pic;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">HotelDoc</span><span class="hljs-params">(Hotel hotel)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = hotel.getId();<br>        <span class="hljs-built_in">this</span>.name = hotel.getName();<br>        <span class="hljs-built_in">this</span>.address = hotel.getAddress();<br>        <span class="hljs-built_in">this</span>.price = hotel.getPrice();<br>        <span class="hljs-built_in">this</span>.score = hotel.getScore();<br>        <span class="hljs-built_in">this</span>.brand = hotel.getBrand();<br>        <span class="hljs-built_in">this</span>.city = hotel.getCity();<br>        <span class="hljs-built_in">this</span>.starName = hotel.getStarName();<br>        <span class="hljs-built_in">this</span>.business = hotel.getBusiness();<br>        <span class="hljs-built_in">this</span>.location = hotel.getLatitude() + <span class="hljs-string">&quot;, &quot;</span> + hotel.getLongitude();<br>        <span class="hljs-built_in">this</span>.pic = hotel.getPic();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="语法说明"><a href="#语法说明" class="headerlink" title="语法说明"></a>语法说明</h3><p>新增文档的DSL语句如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">POST /<span class="hljs-punctuation">&#123;</span>索引库名<span class="hljs-punctuation">&#125;</span>/_doc/<span class="hljs-number">1</span><br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Jack&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">21</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>对应的java代码如图：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191613346.png"></p><p>可以看到与创建索引库类似，同样是三步走：</p><ul><li>1）创建Request对象</li><li>2）准备请求参数，也就是DSL中的JSON文档</li><li>3）发送请求</li></ul><p>变化的地方在于，这里直接使用client.xxx()的API，不再需要client.indices()了。</p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><p>我们导入酒店数据，基本流程一致，但是需要考虑几点变化：</p><ul><li>酒店数据来自于数据库，我们需要先查询出来，得到hotel对象</li><li>hotel对象需要转为HotelDoc对象</li><li>HotelDoc需要序列化为json格式</li></ul><p>因此，代码整体步骤如下：</p><ul><li>1）根据id查询酒店数据Hotel</li><li>2）将Hotel封装为HotelDoc</li><li>3）将HotelDoc序列化为JSON</li><li>4）创建IndexRequest，指定索引库名和id</li><li>5）准备请求参数，也就是JSON文档</li><li>6）发送请求</li></ul><p>在hotel-demo的HotelDocumentTest测试类中，编写单元测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testAddDocument</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 1.根据id查询酒店数据</span><br>    <span class="hljs-type">Hotel</span> <span class="hljs-variable">hotel</span> <span class="hljs-operator">=</span> hotelService.getById(<span class="hljs-number">61083L</span>);<br>    <span class="hljs-comment">// 2.转换为文档类型</span><br>    <span class="hljs-type">HotelDoc</span> <span class="hljs-variable">hotelDoc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HotelDoc</span>(hotel);<br>    <span class="hljs-comment">// 3.将HotelDoc转json</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> JSON.toJSONString(hotelDoc);<br><br>    <span class="hljs-comment">// 1.准备Request对象</span><br>    <span class="hljs-type">IndexRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexRequest</span>(<span class="hljs-string">&quot;hotel&quot;</span>).id(hotelDoc.getId().toString());<br>    <span class="hljs-comment">// 2.准备Json文档</span><br>    request.source(json, XContentType.JSON);<br>    <span class="hljs-comment">// 3.发送请求</span><br>    client.index(request, RequestOptions.DEFAULT);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="查询文档-1"><a href="#查询文档-1" class="headerlink" title="查询文档"></a>查询文档</h2><h3 id="语法说明-1"><a href="#语法说明-1" class="headerlink" title="语法说明"></a>语法说明</h3><p>查询的DSL语句如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /hotel/_doc/<span class="hljs-punctuation">&#123;</span>id<span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>非常简单，因此代码大概分两步：</p><ul><li>准备Request对象</li><li>发送请求</li></ul><p>不过查询的目的是得到结果，解析为HotelDoc，因此难点是结果的解析。完整代码如下：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191617468.png"><br>可以看到，结果是一个JSON，其中文档放在一个<code>_source</code>属性中，因此解析就是拿到<code>_source</code>，反序列化为Java对象即可。</p><p>与之前类似，也是三步走：</p><ul><li>1）准备Request对象。这次是查询，所以是GetRequest</li><li>2）发送请求，得到结果。因为是查询，这里调用client.get()方法</li><li>3）解析结果，就是对JSON做反序列化</li></ul><h3 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h3><p>在hotel-demo的HotelDocumentTest测试类中，编写单元测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testGetDocumentById</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 1.准备Request</span><br>    <span class="hljs-type">GetRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GetRequest</span>(<span class="hljs-string">&quot;hotel&quot;</span>, <span class="hljs-string">&quot;61082&quot;</span>);<br>    <span class="hljs-comment">// 2.发送请求，得到响应</span><br>    <span class="hljs-type">GetResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> client.get(request, RequestOptions.DEFAULT);<br>    <span class="hljs-comment">// 3.解析响应结果</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> response.getSourceAsString();<br><br>    <span class="hljs-type">HotelDoc</span> <span class="hljs-variable">hotelDoc</span> <span class="hljs-operator">=</span> JSON.parseObject(json, HotelDoc.class);<br>    System.out.println(hotelDoc);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="删除文档-1"><a href="#删除文档-1" class="headerlink" title="删除文档"></a>删除文档</h2><p>删除的DSL为是这样的：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">DELETE /hotel/_doc/<span class="hljs-punctuation">&#123;</span>id<span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>与查询相比，仅仅是请求方式从GET变成DELETE，可以想象Java代码应该依然是三步走：</p><ul><li>1）准备Request对象，因为是删除，这次是DeleteRequest对象。要指定索引库名和id</li><li>2）准备参数，无参</li><li>3）发送请求。因为是删除，所以是client.delete()方法</li></ul><p>在hotel-demo的HotelDocumentTest测试类中，编写单元测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testDeleteDocument</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 1.准备Request</span><br>    <span class="hljs-type">DeleteRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DeleteRequest</span>(<span class="hljs-string">&quot;hotel&quot;</span>, <span class="hljs-string">&quot;61083&quot;</span>);<br>    <span class="hljs-comment">// 2.发送请求</span><br>    client.delete(request, RequestOptions.DEFAULT);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="修改文档-1"><a href="#修改文档-1" class="headerlink" title="修改文档"></a>修改文档</h2><h3 id="语法说明-2"><a href="#语法说明-2" class="headerlink" title="语法说明"></a>语法说明</h3><p>修改我们讲过两种方式：</p><ul><li>全量修改：本质是先根据id删除，再新增</li><li>增量修改：修改文档中的指定字段值</li></ul><p>在RestClient的API中，全量修改与新增的API完全一致，判断依据是ID：</p><ul><li>如果新增时，ID已经存在，则修改</li><li>如果新增时，ID不存在，则新增</li></ul><p>这里不再赘述，我们主要关注增量修改。</p><p>代码示例如图：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191619061.png"></p><p>与之前类似，也是三步走：</p><ul><li>1）准备Request对象。这次是修改，所以是UpdateRequest</li><li>2）准备参数。也就是JSON文档，里面包含要修改的字段</li><li>3）更新文档。这里调用client.update()方法</li></ul><h3 id="完整代码-2"><a href="#完整代码-2" class="headerlink" title="完整代码"></a>完整代码</h3><p>在hotel-demo的HotelDocumentTest测试类中，编写单元测试：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs json">@Test<br>void testUpdateDocument() throws IOException <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-comment">// 1.准备Request</span><br>    UpdateRequest request = new UpdateRequest(<span class="hljs-string">&quot;hotel&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;61083&quot;</span>);<br>    <span class="hljs-comment">// 2.准备请求参数</span><br>    request.doc(<br>        <span class="hljs-string">&quot;price&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;952&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;starName&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;四钻&quot;</span><br>    );<br>    <span class="hljs-comment">// 3.发送请求</span><br>    client.update(request<span class="hljs-punctuation">,</span> RequestOptions.DEFAULT);<br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="批量导入文档"><a href="#批量导入文档" class="headerlink" title="批量导入文档"></a>批量导入文档</h2><p>案例需求：利用BulkRequest批量将数据库数据导入到索引库中。</p><p>步骤如下：</p><ul><li>利用mybatis-plus查询酒店数据</li><li>将查询到的酒店数据（Hotel）转换为文档类型数据（HotelDoc）</li><li>利用JavaRestClient中的BulkRequest批处理，实现批量新增文档</li></ul><h3 id="语法说明-3"><a href="#语法说明-3" class="headerlink" title="语法说明"></a>语法说明</h3><p>批量处理BulkRequest，其本质就是将多个普通的CRUD请求组合在一起发送。</p><p>其中提供了一个add方法，用来添加其他请求：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191621547.png"></p><p>可以看到，能添加的请求包括：</p><ul><li>IndexRequest，也就是新增</li><li>UpdateRequest，也就是修改</li><li>DeleteRequest，也就是删除</li></ul><p>因此Bulk中添加了多个IndexRequest，就是批量新增功能了。示例：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191621267.png"></p><p>其实还是三步走：</p><ul><li>1）创建Request对象。这里是BulkRequest</li><li>2）准备参数。批处理的参数，就是其它Request对象，这里就是多个IndexRequest</li><li>3）发起请求。这里是批处理，调用的方法为client.bulk()方法</li></ul><p>我们在导入酒店数据时，将上述代码改造成for循环处理即可。</p><h3 id="完整代码-3"><a href="#完整代码-3" class="headerlink" title="完整代码"></a>完整代码</h3><p>在hotel-demo的HotelDocumentTest测试类中，编写单元测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testBulkRequest</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 批量查询酒店数据</span><br>    List&lt;Hotel&gt; hotels = hotelService.list();<br><br>    <span class="hljs-comment">// 1.创建Request</span><br>    <span class="hljs-type">BulkRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BulkRequest</span>();<br>    <span class="hljs-comment">// 2.准备参数，添加多个新增的Request</span><br>    <span class="hljs-keyword">for</span> (Hotel hotel : hotels) &#123;<br>        <span class="hljs-comment">// 2.1.转换为文档类型HotelDoc</span><br>        <span class="hljs-type">HotelDoc</span> <span class="hljs-variable">hotelDoc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HotelDoc</span>(hotel);<br>        <span class="hljs-comment">// 2.2.创建新增文档的Request对象</span><br>        request.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexRequest</span>(<span class="hljs-string">&quot;hotel&quot;</span>)<br>                    .id(hotelDoc.getId().toString())<br>                    .source(JSON.toJSONString(hotelDoc), XContentType.JSON));<br>    &#125;<br>    <span class="hljs-comment">// 3.发送请求</span><br>    client.bulk(request, RequestOptions.DEFAULT);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p>文档操作的基本步骤：</p><ul><li>初始化RestHighLevelClient</li><li>创建XxxRequest。XXX是Index、Get、Update、Delete、Bulk</li><li>准备参数（Index、Update、Bulk时需要）</li><li>发送请求。调用RestHighLevelClient#.xxx()方法，xxx是index、get、update、delete、bulk</li><li>解析结果（Get时需要）</li></ul><hr><hr><blockquote><p>已经导入了大量数据到elasticsearch中，实现了elasticsearch的数据存储功能。但elasticsearch最擅长的还是搜索和数据分析。</p><p>所以接下来研究下elasticsearch的数据搜索功能。分别使用<strong>DSL</strong>和<strong>RestClient</strong>实现搜索。</p></blockquote><h1 id="DSL文档查询"><a href="#DSL文档查询" class="headerlink" title="DSL文档查询"></a>DSL文档查询</h1><p>elasticsearch的查询依然是基于JSON风格的DSL来实现的。</p><h2 id="DSL查询分类"><a href="#DSL查询分类" class="headerlink" title="DSL查询分类"></a>DSL查询分类</h2><p>Elasticsearch提供了基于JSON的DSL（<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html">Domain Specific Language</a>）来定义查询。常见的查询类型包括：</p><ul><li><strong>查询所有</strong>：查询出所有数据，一般测试用。例如：match_all</li><li><strong>全文检索（full text）查询</strong>：利用分词器对用户输入内容分词，然后去倒排索引库中匹配。例如：<ul><li>match_query</li><li>multi_match_query</li></ul></li><li><strong>精确查询</strong>：根据精确词条值查找数据，一般是查找keyword、数值、日期、boolean等类型字段。例如：<ul><li>ids</li><li>range</li><li>term</li></ul></li><li><strong>地理（geo）查询</strong>：根据经纬度查询。例如：<ul><li>geo_distance</li><li>geo_bounding_box</li></ul></li><li><strong>复合（compound）查询</strong>：复合查询可以将上述各种查询条件组合起来，合并查询条件。例如：<ul><li>bool</li><li>function_score</li></ul></li></ul><p>查询的语法基本一致：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /indexName/_search<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;查询类型&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;查询条件&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;条件值&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>我们以查询所有为例，其中：</p><ul><li>查询类型为match_all</li><li>没有查询条件</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// 查询所有</span><br>GET /indexName/_search<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;match_all&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>其它查询无非就是<strong>查询类型</strong>、<strong>查询条件</strong>的变化。</p><h2 id="全文检索查询"><a href="#全文检索查询" class="headerlink" title="全文检索查询"></a>全文检索查询</h2><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>全文检索查询的基本流程如下：</p><ul><li>对用户搜索的内容做分词，得到词条</li><li>根据词条去倒排索引库中匹配，得到文档id</li><li>根据文档id找到文档，返回给用户</li></ul><p>比较常用的场景包括：</p><ul><li>商城的输入框搜索</li><li>百度输入框搜索</li></ul><p>例如京东：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191745730.png"></p><p>因为是拿着词条去匹配，因此参与搜索的字段也必须是可分词的text类型的字段。</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>常见的全文检索查询包括：</p><ul><li>match查询：单字段查询</li><li>multi_match查询：多字段查询，任意一个字段符合条件就算符合查询条件</li></ul><p>match查询语法如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /indexName/_search<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;match&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;FIELD&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;TEXT&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>mulit_match语法如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /indexName/_search<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;multi_match&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;TEXT&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;fields&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;FIELD1&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot; FIELD12&quot;</span><span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>match查询示例：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191746605.png"></p><p>multi_match查询示例：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191746789.png"></p><p>可以看到，两种查询结果是一样的，为什么？</p><p>因为我们将brand、name、business值都利用copy_to复制到了all字段中。因此你根据三个字段搜索，和根据all字段搜索效果当然一样了。</p><p>但是，搜索字段越多，对查询性能影响越大，因此建议采用copy_to，然后单字段查询的方式。</p><h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><p>match和multi_match的区别是什么？</p><ul><li>match：根据一个字段查询</li><li>multi_match：根据多个字段查询，参与查询字段越多，查询性能越差</li></ul><h2 id="精准查询"><a href="#精准查询" class="headerlink" title="精准查询"></a>精准查询</h2><p>精确查询一般是查找keyword、数值、日期、boolean等类型字段。所以<strong>不会</strong>对搜索条件分词。常见的有：</p><ul><li>term：根据词条精确值查询</li><li>range：根据值的范围查询</li></ul><h3 id="term查询"><a href="#term查询" class="headerlink" title="term查询"></a>term查询</h3><p>因为精确查询的字段搜是不分词的字段，因此查询的条件也必须是<strong>不分词</strong>的词条。查询时，用户输入的内容跟自动值完全匹配时才认为符合条件。如果用户输入的内容过多，反而搜索不到数据。</p><p>语法说明：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// term查询</span><br>GET /indexName/_search<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;term&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;FIELD&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;value&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;VALUE&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><p>当我搜索的是精确词条时，能正确查询出结果：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191751430.png"></p><p>但是，当我搜索的内容不是词条，而是多个词语形成的短语时，反而搜索不到：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191751778.png"></p><h3 id="range查询"><a href="#range查询" class="headerlink" title="range查询"></a>range查询</h3><p>范围查询，一般应用在对数值类型做范围过滤的时候。比如做价格范围过滤。</p><p><strong>基本语法：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// range查询</span><br>GET /indexName/_search<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;range&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;FIELD&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;gte&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">10</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 这里的gte代表大于等于，gt则代表大于</span><br>        <span class="hljs-attr">&quot;lte&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">20</span> <span class="hljs-comment">// lte代表小于等于，lt则代表小于</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191752273.png"></p><h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3><p>精确查询常见的有哪些？</p><ul><li>term查询：根据词条精确匹配，一般搜索keyword类型、数值类型、布尔类型、日期类型字段</li><li>range查询：根据数值范围查询，可以是数值、日期的范围</li></ul><h2 id="地理坐标查询"><a href="#地理坐标查询" class="headerlink" title="地理坐标查询"></a>地理坐标查询</h2><p>所谓的地理坐标查询，其实就是根据经纬度查询，官方文档：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/geo-queries.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/geo-queries.html</a></p><p>常见的使用场景包括：</p><ul><li>携程：搜索我附近的酒店</li><li>滴滴：搜索我附近的出租车</li><li>微信：搜索我附近的人</li></ul><h3 id="矩形范围查询"><a href="#矩形范围查询" class="headerlink" title="矩形范围查询"></a>矩形范围查询</h3><p>矩形范围查询，也就是geo_bounding_box查询，查询坐标落在某个矩形范围的所有文档：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191753120.png"></p><p>查询时，需要指定矩形的<strong>左上</strong>、<strong>右下</strong>两个点的坐标，然后画出一个矩形，落在该矩形内的都是符合条件的点。</p><p><strong>语法如下：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// geo_bounding_box查询</span><br>GET /indexName/_search<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;geo_bounding_box&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;FIELD&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;top_left&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-comment">// 左上点</span><br>          <span class="hljs-attr">&quot;lat&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">31.1</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;lon&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">121.5</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;bottom_right&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-comment">// 右下点</span><br>          <span class="hljs-attr">&quot;lat&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">30.9</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;lon&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">121.7</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="附近查询"><a href="#附近查询" class="headerlink" title="附近查询"></a>附近查询</h3><p>附近查询，也叫做距离查询（geo_distance）：查询到指定中心点小于某个距离值的所有文档。</p><p>换句话来说，在地图上找一个点作为圆心，以指定距离为半径，画一个圆，落在圆内的坐标都算符合条件：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191753570.png"></p><p><strong>语法说明：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// geo_distance 查询</span><br>GET /indexName/_search<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;geo_distance&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;distance&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;15km&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 半径</span><br>      <span class="hljs-attr">&quot;FIELD&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;31.21,121.5&quot;</span> <span class="hljs-comment">// 圆心</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>示例：</p><p>我们先搜索陆家嘴附近15km的酒店：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191754610.png"></p><p>发现共有47家酒店。</p><p>然后把半径缩短到3公里：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191755094.png"></p><p>可以发现，搜索到的酒店数量减少到了5家。</p><h2 id="复合查询"><a href="#复合查询" class="headerlink" title="复合查询"></a>复合查询</h2><p>复合（compound）查询：复合查询可以将其它简单查询组合起来，实现更复杂的搜索逻辑。常见的有两种：</p><ul><li>fuction score：算分函数查询，可以控制文档相关性算分，控制文档排名</li><li>bool query：布尔查询，利用逻辑关系组合多个其它的查询，实现复杂搜索</li></ul><h3 id="相关性算分"><a href="#相关性算分" class="headerlink" title="相关性算分"></a>相关性算分</h3><p>当我们利用match查询时，文档结果会根据与搜索词条的关联度打分（_score），返回结果时按照分值降序排列。</p><p>例如，我们搜索 “虹桥如家”，结果如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">[</span><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;_score&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">17.850193</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;_source&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;name&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;虹桥如家酒店真不错&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;_score&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">12.259849</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;_source&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;name&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;外滩如家酒店真不错&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;_score&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">11.91091</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;_source&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;name&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;迪士尼如家酒店真不错&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><p>在elasticsearch中，早期使用的打分算法是TF-IDF算法，公式如下：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191756440.png"></p><p>在后来的5.1版本升级中，elasticsearch将算法改进为BM25算法，公式如下：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191757440.png"></p><p>TF-IDF算法有一各缺陷，就是词条频率越高，文档得分也会越高，单个词条对文档影响较大。而BM25则会让单个词条的算分有一个上限，曲线更加平滑：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191757365.png"></p><p>小结：elasticsearch会根据词条和文档的相关度做打分，算法由两种：</p><ul><li>TF-IDF算法</li><li>BM25算法，elasticsearch5.1版本后采用的算法</li></ul><h3 id="算分函数查询"><a href="#算分函数查询" class="headerlink" title="算分函数查询"></a>算分函数查询</h3><p>根据相关度打分是比较合理的需求，但<strong>合理的不一定是产品经理需要</strong>的。</p><p>以百度为例，你搜索的结果中，并不是相关度越高排名越靠前，而是谁掏的钱多排名就越靠前。。。。。。</p><p>要想认为控制相关性算分，就需要利用elasticsearch中的function score 查询了。</p><h4 id="语法说明-4"><a href="#语法说明-4" class="headerlink" title="语法说明"></a>语法说明</h4><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191758200.png"></p><p>function score 查询中包含四部分内容：</p><ul><li><strong>原始查询</strong>条件：query部分，基于这个条件搜索文档，并且基于BM25算法给文档打分，<strong>原始算分</strong>（query score)</li><li><strong>过滤条件</strong>：filter部分，符合该条件的文档才会重新算分</li><li><strong>算分函数</strong>：符合filter条件的文档要根据这个函数做运算，得到的<strong>函数算分</strong>（function score），有四种函数<ul><li>weight：函数结果是常量</li><li>field_value_factor：以文档中的某个字段值作为函数结果</li><li>random_score：以随机数作为函数结果</li><li>script_score：自定义算分函数算法</li></ul></li><li><strong>运算模式</strong>：算分函数的结果、原始查询的相关性算分，两者之间的运算方式，包括：<ul><li>multiply：相乘</li><li>replace：用function score替换query score</li><li>其它，例如：sum、avg、max、min</li></ul></li></ul><p>function score的运行流程如下：</p><ul><li>1）根据<strong>原始条件</strong>查询搜索文档，并且计算相关性算分，称为<strong>原始算分</strong>（query score）</li><li>2）根据<strong>过滤条件</strong>，过滤文档</li><li>3）符合<strong>过滤条件</strong>的文档，基于<strong>算分函数</strong>运算，得到<strong>函数算分</strong>（function score）</li><li>4）将<strong>原始算分</strong>（query score）和<strong>函数算分</strong>（function score）基于<strong>运算模式</strong>做运算，得到最终结果，作为相关性算分。</li></ul><p>因此，其中的关键点是：</p><ul><li>过滤条件：决定哪些文档的算分被修改</li><li>算分函数：决定函数算分的算法</li><li>运算模式：决定最终算分结果</li></ul><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p>需求：给“如家”这个品牌的酒店排名靠前一些。</p><p>翻译一下这个需求，转换为之前说的四个要点：</p><ul><li>原始条件：不确定，可以任意变化</li><li>过滤条件：brand &#x3D; “如家”</li><li>算分函数：可以简单粗暴，直接给固定的算分结果，weight</li><li>运算模式：比如求和</li></ul><p>因此最终的DSL语句如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /hotel/_search<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;function_score&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>  .... <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 原始查询，可以是任意条件</span><br>      <span class="hljs-attr">&quot;functions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span> <span class="hljs-comment">// 算分函数</span><br>        <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;filter&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-comment">// 满足的条件，品牌必须是如家</span><br>            <span class="hljs-attr">&quot;term&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>              <span class="hljs-attr">&quot;brand&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;如家&quot;</span><br>            <span class="hljs-punctuation">&#125;</span><br>          <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;weight&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span> <span class="hljs-comment">// 算分权重为2</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;boost_mode&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;sum&quot;</span> <span class="hljs-comment">// 加权模式，求和</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>测试，在未添加算分函数时，如家得分如下：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191801527.png"></p><p>添加了算分函数后，如家得分就提升了：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191802790.png"></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>function score query定义的三要素是什么？</p><ul><li>过滤条件：哪些文档要加分</li><li>算分函数：如何计算function score</li><li>加权方式：function score 与 query score如何运算</li></ul><h3 id="布尔查询"><a href="#布尔查询" class="headerlink" title="布尔查询"></a>布尔查询</h3><p>布尔查询是一个或多个查询子句的组合，每一个子句就是一个<strong>子查询</strong>。子查询的组合方式有：</p><ul><li>must：必须匹配每个子查询，类似“与”</li><li>should：选择性匹配子查询，类似“或”</li><li>must_not：必须不匹配，<strong>不参与算分</strong>，类似“非”</li><li>filter：必须匹配，<strong>不参与算分</strong></li></ul><p>比如在搜索酒店时，除了关键字搜索外，我们还可能根据品牌、价格、城市等字段做过滤：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191804351.png"></p><p>每一个不同的字段，其查询的条件、方式都不一样，必须是多个不同的查询，而要组合这些查询，就必须用bool查询了。</p><p>需要注意的是，搜索时，参与<strong>打分的字段越多，查询的性能也越差</strong>。因此这种多条件查询时，建议这样做：</p><ul><li>搜索框的关键字搜索，是全文检索查询，使用must查询，参与算分</li><li>其它过滤条件，采用filter查询。不参与算分</li></ul><h4 id="语法示例"><a href="#语法示例" class="headerlink" title="语法示例"></a>语法示例</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /hotel/_search<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;bool&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;must&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;term&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;city&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;上海&quot;</span> <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;should&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;term&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;brand&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;皇冠假日&quot;</span> <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;term&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;brand&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;华美达&quot;</span> <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;must_not&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;range&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;price&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;lte&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">500</span> <span class="hljs-punctuation">&#125;</span> <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;filter&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;range&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;score&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;gte&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">45</span> <span class="hljs-punctuation">&#125;</span> <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><p>需求：搜索名字包含“如家”，价格不高于400，在坐标31.21,121.5周围10km范围内的酒店。</p><p>分析：</p><ul><li>名称搜索，属于全文检索查询，应该参与算分。放到must中</li><li>价格不高于400，用range查询，属于过滤条件，不参与算分。放到must_not中</li><li>周围10km范围内，用geo_distance查询，属于过滤条件，不参与算分。放到filter中</li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191805689.png"></p><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>bool查询有几种逻辑关系？</p><ul><li>must：必须匹配的条件，可以理解为“与”</li><li>should：选择性匹配的条件，可以理解为“或”</li><li>must_not：必须不匹配的条件，不参与打分</li><li>filter：必须匹配的条件，不参与打分</li></ul><h1 id="DSL搜索结果处理"><a href="#DSL搜索结果处理" class="headerlink" title="DSL搜索结果处理"></a>DSL搜索结果处理</h1><p>搜索的结果可以按照用户指定的方式去处理或展示。</p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>elasticsearch默认是根据相关度算分（_score）来排序，但是也支持自定义方式对搜索<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/sort-search-results.html">结果排序</a>。可以排序字段类型有：keyword类型、数值类型、地理坐标类型、日期类型等。</p><h3 id="普通字段排序"><a href="#普通字段排序" class="headerlink" title="普通字段排序"></a>普通字段排序</h3><p>keyword、数值、日期类型排序的语法基本一致。</p><p><strong>语法</strong>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /indexName/_search<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;match_all&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;sort&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;FIELD&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;desc&quot;</span>  <span class="hljs-comment">// 排序字段、排序方式ASC、DESC</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>排序条件是一个数组，也就是可以写多个排序条件。按照声明的顺序，当第一个条件相等时，再按照第二个条件排序，以此类推</p><p><strong>示例</strong>：</p><p>需求描述：酒店数据按照用户评价（score)降序排序，评价相同的按照价格(price)升序排序:</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191807482.png"></p><h3 id="地理坐标排序"><a href="#地理坐标排序" class="headerlink" title="地理坐标排序"></a>地理坐标排序</h3><p>地理坐标排序略有不同。</p><p><strong>语法说明</strong>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /indexName/_search<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;match_all&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;sort&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;_geo_distance&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;FIELD&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;纬度，经度&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 文档中geo_point类型的字段名、目标坐标点</span><br>          <span class="hljs-attr">&quot;order&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;asc&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 排序方式</span><br>          <span class="hljs-attr">&quot;unit&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;km&quot;</span> <span class="hljs-comment">// 排序的距离单位</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>这个查询的含义是：</p><ul><li>指定一个坐标，作为目标点</li><li>计算每一个文档中，指定字段（必须是geo_point类型）的坐标 到目标点的距离是多少</li><li>根据距离排序</li></ul><p><strong>示例：</strong></p><p>需求描述：实现对酒店数据按照到你的位置坐标的距离升序排序</p><p>提示：获取你的位置的经纬度的方式：<a href="https://lbs.amap.com/demo/jsapi-v2/example/map/click-to-get-lnglat/">https://lbs.amap.com/demo/jsapi-v2/example/map/click-to-get-lnglat/</a></p><p>假设我的位置是：31.034661，121.612282，寻找我周围距离最近的酒店。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191809019.png"></p><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>elasticsearch 默认情况下只返回top10的数据。而如果要查询更多数据就需要修改分页参数了。</p><p>elasticsearch中通过修改from、size参数来控制要返回的分页结果：</p><ul><li>from：从第几个文档开始</li><li>size：总共查询几个文档</li></ul><p>类似于mysql中的<code>limit ?, ?</code></p><h3 id="基本的分页"><a href="#基本的分页" class="headerlink" title="基本的分页"></a>基本的分页</h3><p>分页的基本语法如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /hotel/_search<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;match_all&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;from&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 分页开始的位置，默认为0</span><br>  <span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">10</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 期望获取的文档总数</span><br>  <span class="hljs-attr">&quot;sort&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;price&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;asc&quot;</span><span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="深度分页问题"><a href="#深度分页问题" class="headerlink" title="深度分页问题"></a>深度分页问题</h3><p>现在，我要查询990~1000的数据，查询逻辑要这么写：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /hotel/_search<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;match_all&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;from&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">990</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 分页开始的位置，默认为0</span><br>  <span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">10</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 期望获取的文档总数</span><br>  <span class="hljs-attr">&quot;sort&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;price&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;asc&quot;</span><span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>这里是查询990开始的数据，也就是 第990~第1000条 数据。</p><p>不过，elasticsearch内部分页时，必须先查询 0~1000条，然后截取其中的990 ~ 1000的这10条：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191810728.png"></p><p>查询TOP1000，如果es是单点模式，这并无太大影响。</p><p>但是elasticsearch将来一定是集群，例如我集群有5个节点，我要查询TOP1000的数据，并不是每个节点查询200条就可以了。</p><p>因为节点A的TOP200，在另一个节点可能排到10000名以外了。</p><p>因此要想获取整个集群的TOP1000，必须先查询出每个节点的TOP1000，汇总结果后，重新排名，重新截取TOP1000。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191811275.png"></p><p>那如果我要查询9900~10000的数据呢？是不是要先查询TOP10000呢？那每个节点都要查询10000条？汇总到内存中？</p><p>当查询分页深度较大时，汇总数据过多，对内存和CPU会产生非常大的压力，因此elasticsearch会禁止from+ size 超过10000的请求。</p><p>针对深度分页，ES提供了两种解决方案，<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/paginate-search-results.html">官方文档</a>：</p><ul><li>search after：分页时需要排序，原理是从上一次的排序值开始，查询下一页数据。官方推荐使用的方式。</li><li>scroll：原理将排序后的文档id形成快照，保存在内存。官方已经不推荐使用。</li></ul><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>分页查询的常见实现方案以及优缺点：</p><ul><li><code>from + size</code>：<ul><li>优点：支持随机翻页</li><li>缺点：深度分页问题，默认查询上限（from + size）是10000</li><li>场景：百度、京东、谷歌、淘宝这样的随机翻页搜索</li></ul></li><li><code>after search</code>：<ul><li>优点：没有查询上限（单次查询的size不超过10000）</li><li>缺点：只能向后逐页查询，不支持随机翻页</li><li>场景：没有随机翻页需求的搜索，例如手机向下滚动翻页</li></ul></li><li><code>scroll</code>：<ul><li>优点：没有查询上限（单次查询的size不超过10000）</li><li>缺点：会有额外内存消耗，并且搜索结果是非实时的</li><li>场景：海量数据的获取和迁移。从ES7.1开始不推荐，建议用 after search方案。</li></ul></li></ul><h2 id="高亮"><a href="#高亮" class="headerlink" title="高亮"></a>高亮</h2><h3 id="高亮原理"><a href="#高亮原理" class="headerlink" title="高亮原理"></a>高亮原理</h3><p>什么是高亮显示呢？</p><p>我们在百度，京东搜索时，关键字会变成红色，比较醒目，这叫高亮显示</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191813774.png"></p><p>高亮显示的实现分为两步：</p><ul><li>1）给文档中的所有关键字都添加一个标签，例如<code>&lt;em&gt;</code>标签</li><li>2）页面给<code>&lt;em&gt;</code>标签编写CSS样式</li></ul><h3 id="实现高亮"><a href="#实现高亮" class="headerlink" title="实现高亮"></a>实现高亮</h3><p><strong>高亮的语法</strong>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /hotel/_search<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;match&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;FIELD&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;TEXT&quot;</span> <span class="hljs-comment">// 查询条件，高亮一定要使用全文检索查询</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;highlight&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;fields&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-comment">// 指定要高亮的字段</span><br>      <span class="hljs-attr">&quot;FIELD&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;pre_tags&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&lt;em&gt;&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// 用来标记高亮字段的前置标签</span><br>        <span class="hljs-attr">&quot;post_tags&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&lt;/em&gt;&quot;</span> <span class="hljs-comment">// 用来标记高亮字段的后置标签</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>高亮是对关键字高亮，因此<strong>搜索条件必须带有关键字</strong>，而不能是范围这样的查询。</li><li>默认情况下，<strong>高亮的字段，必须与搜索指定的字段一致</strong>，否则无法高亮</li><li>如果要对非搜索字段高亮，则需要添加一个属性：required_field_match&#x3D;false</li></ul><p><strong>示例</strong>：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191814330.png"></p><h2 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h2><p>查询的DSL是一个大的JSON对象，包含下列属性：</p><ul><li>query：查询条件</li><li>from和size：分页条件</li><li>sort：排序条件</li><li>highlight：高亮条件</li></ul><p>示例：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191815655.png"></p><h1 id="RestClient文档查询"><a href="#RestClient文档查询" class="headerlink" title="RestClient文档查询"></a>RestClient文档查询</h1><p>文档的查询同样适用 RestHighLevelClient对象，基本步骤包括：</p><ul><li>1）准备Request对象</li><li>2）准备请求参数</li><li>3）发起请求</li><li>4）解析响应</li></ul><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p>我们以match_all查询为例。</p><h3 id="发起查询请求"><a href="#发起查询请求" class="headerlink" title="发起查询请求"></a>发起查询请求</h3><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191816790.png"></p><p>代码解读：</p><ul><li>第一步，创建<code>SearchRequest</code>对象，指定索引库名</li><li>第二步，利用<code>request.source()</code>构建DSL，DSL中可以包含查询、分页、排序、高亮等<ul><li><code>query()</code>：代表查询条件，利用<code>QueryBuilders.matchAllQuery()</code>构建一个match_all查询的DSL</li></ul></li><li>第三步，利用client.search()发送请求，得到响应</li></ul><p>这里关键的API有两个，一个是<code>request.source()</code>，其中包含了查询、排序、分页、高亮等所有功能：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191817815.png"></p><p>另一个是<code>QueryBuilders</code>，其中包含match、term、function_score、bool等各种查询：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191818675.png"></p><h3 id="解析响应"><a href="#解析响应" class="headerlink" title="解析响应"></a>解析响应</h3><p>响应结果的解析：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191818337.png"></p><p>elasticsearch返回的结果是一个JSON字符串，结构包含：</p><ul><li><code>hits</code>：命中的结果<ul><li><code>total</code>：总条数，其中的value是具体的总条数值</li><li><code>max_score</code>：所有结果中得分最高的文档的相关性算分</li><li><code>hits</code>：搜索结果的文档数组，其中的每个文档都是一个json对象<ul><li><code>_source</code>：文档中的原始数据，也是json对象</li></ul></li></ul></li></ul><p>因此，我们解析响应结果，就是逐层解析JSON字符串，流程如下：</p><ul><li><code>SearchHits</code>：通过response.getHits()获取，就是JSON中的最外层的hits，代表命中的结果<ul><li><code>SearchHits#getTotalHits().value</code>：获取总条数信息</li><li><code>SearchHits#getHits()</code>：获取SearchHit数组，也就是文档数组<ul><li><code>SearchHit#getSourceAsString()</code>：获取文档结果中的_source，也就是原始的json文档数据</li></ul></li></ul></li></ul><h3 id="完整代码-4"><a href="#完整代码-4" class="headerlink" title="完整代码"></a>完整代码</h3><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testMatchAll</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 1.准备Request</span><br>    <span class="hljs-type">SearchRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SearchRequest</span>(<span class="hljs-string">&quot;hotel&quot;</span>);<br>    <span class="hljs-comment">// 2.准备DSL</span><br>    request.source()<br>        .query(QueryBuilders.matchAllQuery());<br>    <span class="hljs-comment">// 3.发送请求</span><br>    <span class="hljs-type">SearchResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> client.search(request, RequestOptions.DEFAULT);<br><br>    <span class="hljs-comment">// 4.解析响应</span><br>    handleResponse(response);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleResponse</span><span class="hljs-params">(SearchResponse response)</span> &#123;<br>    <span class="hljs-comment">// 4.解析响应</span><br>    <span class="hljs-type">SearchHits</span> <span class="hljs-variable">searchHits</span> <span class="hljs-operator">=</span> response.getHits();<br>    <span class="hljs-comment">// 4.1.获取总条数</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> searchHits.getTotalHits().value;<br>    System.out.println(<span class="hljs-string">&quot;共搜索到&quot;</span> + total + <span class="hljs-string">&quot;条数据&quot;</span>);<br>    <span class="hljs-comment">// 4.2.文档数组</span><br>    SearchHit[] hits = searchHits.getHits();<br>    <span class="hljs-comment">// 4.3.遍历</span><br>    <span class="hljs-keyword">for</span> (SearchHit hit : hits) &#123;<br>        <span class="hljs-comment">// 获取文档source</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> hit.getSourceAsString();<br>        <span class="hljs-comment">// 反序列化</span><br>        <span class="hljs-type">HotelDoc</span> <span class="hljs-variable">hotelDoc</span> <span class="hljs-operator">=</span> JSON.parseObject(json, HotelDoc.class);<br>        System.out.println(<span class="hljs-string">&quot;hotelDoc = &quot;</span> + hotelDoc);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>查询的基本步骤是：</p><ol><li>创建SearchRequest对象</li><li>准备Request.source()，也就是DSL。<br> ① QueryBuilders来构建查询条件<br> ② 传入Request.source() 的 query() 方法</li><li>发送请求，得到结果</li><li>解析结果（参考JSON结果，从外到内，逐层解析）</li></ol><h2 id="match查询"><a href="#match查询" class="headerlink" title="match查询"></a>match查询</h2><p>全文检索的match和multi_match查询与match_all的API基本一致。差别是查询条件，也就是query的部分。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191821268.png"></p><p>因此，Java代码上的差异主要是request.source().query()中的参数了。同样是利用QueryBuilders提供的方法：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191821102.png"></p><p>而结果解析代码则完全一致，可以抽取并共享。</p><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testMatch</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 1.准备Request</span><br>    <span class="hljs-type">SearchRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SearchRequest</span>(<span class="hljs-string">&quot;hotel&quot;</span>);<br>    <span class="hljs-comment">// 2.准备DSL</span><br>    request.source()<br>        .query(QueryBuilders.matchQuery(<span class="hljs-string">&quot;all&quot;</span>, <span class="hljs-string">&quot;如家&quot;</span>));<br>    <span class="hljs-comment">// 3.发送请求</span><br>    <span class="hljs-type">SearchResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> client.search(request, RequestOptions.DEFAULT);<br>    <span class="hljs-comment">// 4.解析响应</span><br>    handleResponse(response);<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="精准查询-1"><a href="#精准查询-1" class="headerlink" title="精准查询"></a>精准查询</h2><p>精确查询主要是两者：</p><ul><li>term：词条精确匹配</li><li>range：范围查询</li></ul><p>与之前的查询相比，差异同样在查询条件，其它都一样。</p><p>查询条件构造的API如下：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191822051.png"></p><h2 id="布尔查询-1"><a href="#布尔查询-1" class="headerlink" title="布尔查询"></a>布尔查询</h2><p>布尔查询是用must、must_not、filter等方式组合其它查询，代码示例如下：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191822540.png"></p><p>可以看到，API与其它查询的差别同样是在查询条件的构建，QueryBuilders，结果解析等其他代码完全不变。</p><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testBool</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 1.准备Request</span><br>    <span class="hljs-type">SearchRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SearchRequest</span>(<span class="hljs-string">&quot;hotel&quot;</span>);<br>    <span class="hljs-comment">// 2.准备DSL</span><br>    <span class="hljs-comment">// 2.1.准备BooleanQuery</span><br>    <span class="hljs-type">BoolQueryBuilder</span> <span class="hljs-variable">boolQuery</span> <span class="hljs-operator">=</span> QueryBuilders.boolQuery();<br>    <span class="hljs-comment">// 2.2.添加term</span><br>    boolQuery.must(QueryBuilders.termQuery(<span class="hljs-string">&quot;city&quot;</span>, <span class="hljs-string">&quot;杭州&quot;</span>));<br>    <span class="hljs-comment">// 2.3.添加range</span><br>    boolQuery.filter(QueryBuilders.rangeQuery(<span class="hljs-string">&quot;price&quot;</span>).lte(<span class="hljs-number">250</span>));<br><br>    request.source().query(boolQuery);<br>    <span class="hljs-comment">// 3.发送请求</span><br>    <span class="hljs-type">SearchResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> client.search(request, RequestOptions.DEFAULT);<br>    <span class="hljs-comment">// 4.解析响应</span><br>    handleResponse(response);<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="排序-amp-分页"><a href="#排序-amp-分页" class="headerlink" title="排序&amp;分页"></a>排序&amp;分页</h2><p>搜索结果的排序和分页是与query同级的参数，因此同样是使用request.source()来设置。</p><p>对应的API如下：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191823337.png"></p><p>完整代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testPageAndSort</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 页码，每页大小</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">page</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, size = <span class="hljs-number">5</span>;<br><br>    <span class="hljs-comment">// 1.准备Request</span><br>    <span class="hljs-type">SearchRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SearchRequest</span>(<span class="hljs-string">&quot;hotel&quot;</span>);<br>    <span class="hljs-comment">// 2.准备DSL</span><br>    <span class="hljs-comment">// 2.1.query</span><br>    request.source().query(QueryBuilders.matchAllQuery());<br>    <span class="hljs-comment">// 2.2.排序 sort</span><br>    request.source().sort(<span class="hljs-string">&quot;price&quot;</span>, SortOrder.ASC);<br>    <span class="hljs-comment">// 2.3.分页 from、size</span><br>    request.source().from((page - <span class="hljs-number">1</span>) * size).size(<span class="hljs-number">5</span>);<br>    <span class="hljs-comment">// 3.发送请求</span><br>    <span class="hljs-type">SearchResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> client.search(request, RequestOptions.DEFAULT);<br>    <span class="hljs-comment">// 4.解析响应</span><br>    handleResponse(response);<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="高亮-1"><a href="#高亮-1" class="headerlink" title="高亮"></a>高亮</h2><p>高亮的代码与之前代码差异较大，有两点：</p><ul><li>查询的DSL：其中除了查询条件，还需要添加高亮条件，同样是与query同级。</li><li>结果解析：结果除了要解析_source文档数据，还要解析高亮结果</li></ul><h3 id="高亮请求构建"><a href="#高亮请求构建" class="headerlink" title="高亮请求构建"></a>高亮请求构建</h3><p>高亮请求的构建API如下：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191824619.png"><br>上述代码省略了查询条件部分，但是大家不要忘了：高亮查询必须使用全文检索查询，并且要有搜索关键字，将来才可以对关键字高亮。</p><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testHighlight</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 1.准备Request</span><br>    <span class="hljs-type">SearchRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SearchRequest</span>(<span class="hljs-string">&quot;hotel&quot;</span>);<br>    <span class="hljs-comment">// 2.准备DSL</span><br>    <span class="hljs-comment">// 2.1.query</span><br>    request.source().query(QueryBuilders.matchQuery(<span class="hljs-string">&quot;all&quot;</span>, <span class="hljs-string">&quot;如家&quot;</span>));<br>    <span class="hljs-comment">// 2.2.高亮</span><br>    request.source().highlighter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HighlightBuilder</span>().field(<span class="hljs-string">&quot;name&quot;</span>).requireFieldMatch(<span class="hljs-literal">false</span>));<br>    <span class="hljs-comment">// 3.发送请求</span><br>    <span class="hljs-type">SearchResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> client.search(request, RequestOptions.DEFAULT);<br>    <span class="hljs-comment">// 4.解析响应</span><br>    handleResponse(response);<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="高亮结果分析"><a href="#高亮结果分析" class="headerlink" title="高亮结果分析"></a>高亮结果分析</h3><p>高亮的结果与查询的文档结果默认是分离的，并不在一起。</p><p>因此解析高亮的代码需要额外处理：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191824160.png"></p><p>代码解读：</p><ul><li>第一步：从结果中获取source。hit.getSourceAsString()，这部分是非高亮结果，json字符串。还需要反序列为HotelDoc对象</li><li>第二步：获取高亮结果。hit.getHighlightFields()，返回值是一个Map，key是高亮字段名称，值是HighlightField对象，代表高亮值</li><li>第三步：从map中根据高亮字段名称，获取高亮字段值对象HighlightField</li><li>第四步：从HighlightField中获取Fragments，并且转为字符串。这部分就是真正的高亮字符串了</li><li>第五步：用高亮的结果替换HotelDoc中的非高亮结果</li></ul><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleResponse</span><span class="hljs-params">(SearchResponse response)</span> &#123;<br>    <span class="hljs-comment">// 4.解析响应</span><br>    <span class="hljs-type">SearchHits</span> <span class="hljs-variable">searchHits</span> <span class="hljs-operator">=</span> response.getHits();<br>    <span class="hljs-comment">// 4.1.获取总条数</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> searchHits.getTotalHits().value;<br>    System.out.println(<span class="hljs-string">&quot;共搜索到&quot;</span> + total + <span class="hljs-string">&quot;条数据&quot;</span>);<br>    <span class="hljs-comment">// 4.2.文档数组</span><br>    SearchHit[] hits = searchHits.getHits();<br>    <span class="hljs-comment">// 4.3.遍历</span><br>    <span class="hljs-keyword">for</span> (SearchHit hit : hits) &#123;<br>        <span class="hljs-comment">// 获取文档source</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> hit.getSourceAsString();<br>        <span class="hljs-comment">// 反序列化</span><br>        <span class="hljs-type">HotelDoc</span> <span class="hljs-variable">hotelDoc</span> <span class="hljs-operator">=</span> JSON.parseObject(json, HotelDoc.class);<br>        <span class="hljs-comment">// 获取高亮结果</span><br>        Map&lt;String, HighlightField&gt; highlightFields = hit.getHighlightFields();<br>        <span class="hljs-keyword">if</span> (!CollectionUtils.isEmpty(highlightFields)) &#123;<br>            <span class="hljs-comment">// 根据字段名获取高亮结果</span><br>            <span class="hljs-type">HighlightField</span> <span class="hljs-variable">highlightField</span> <span class="hljs-operator">=</span> highlightFields.get(<span class="hljs-string">&quot;name&quot;</span>);<br>            <span class="hljs-keyword">if</span> (highlightField != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 获取高亮值</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> highlightField.getFragments()[<span class="hljs-number">0</span>].string();<br>                <span class="hljs-comment">// 覆盖非高亮结果</span><br>                hotelDoc.setName(name);<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;hotelDoc = &quot;</span> + hotelDoc);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><hr><h1 id="数据聚合"><a href="#数据聚合" class="headerlink" title="数据聚合"></a>数据聚合</h1><p>**<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html">聚合（</a><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html">aggregations</a><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html">）</a>**可以让我们极其方便的实现对数据的统计、分析、运算。例如：</p><ul><li>什么品牌的手机最受欢迎？</li><li>这些手机的平均价格、最高价格、最低价格？</li><li>这些手机每月的销售情况如何？</li></ul><p>实现这些统计功能的比数据库的sql要方便的多，而且查询速度非常快，可以实现近实时搜索效果。</p><h2 id="聚合的种类"><a href="#聚合的种类" class="headerlink" title="聚合的种类"></a>聚合的种类</h2><p>聚合常见的有三类：</p><ul><li><p><strong>桶（Bucket）</strong>聚合：用来对文档做分组</p><ul><li><p>TermAggregation：按照文档字段值分组，例如按照品牌值分组、按照国家分组</p></li><li><p>Date Histogram：按照日期阶梯分组，例如一周为一组，或者一月为一组</p></li></ul></li><li><p><strong>度量（Metric）</strong>聚合：用以计算一些值，比如：最大值、最小值、平均值等</p><ul><li><p>Avg：求平均值</p></li><li><p>Max：求最大值</p></li><li><p>Min：求最小值</p></li><li><p>Stats：同时求max、min、avg、sum等</p></li></ul></li><li><p><strong>管道（pipeline）</strong>聚合：其它聚合的结果为基础做聚合</p></li></ul><blockquote><p><strong>注意：</strong>参加聚合的字段必须是keyword、日期、数值、布尔类型</p></blockquote><h2 id="DSL实现聚合"><a href="#DSL实现聚合" class="headerlink" title="DSL实现聚合"></a>DSL实现聚合</h2><p>现在，我们要统计所有数据中的酒店品牌有几种，其实就是按照品牌对数据分组。此时可以根据酒店品牌的名称做聚合，也就是Bucket聚合。</p><h3 id="Bucket聚合语法"><a href="#Bucket聚合语法" class="headerlink" title="Bucket聚合语法"></a>Bucket聚合语法</h3><p>语法如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /hotel/_search<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// 设置size为0，结果中不包含文档，只包含聚合结果</span><br>  <span class="hljs-attr">&quot;aggs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-comment">// 定义聚合</span><br>    <span class="hljs-attr">&quot;brandAgg&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-comment">//给聚合起个名字</span><br>      <span class="hljs-attr">&quot;terms&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-comment">// 聚合的类型，按照品牌值聚合，所以选择term</span><br>        <span class="hljs-attr">&quot;field&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;brand&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 参与聚合的字段</span><br>        <span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">20</span> <span class="hljs-comment">// 希望获取的聚合结果数量</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>结果如图：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191846164.png"></p><h3 id="聚合结果排序"><a href="#聚合结果排序" class="headerlink" title="聚合结果排序"></a>聚合结果排序</h3><p>默认情况下，Bucket聚合会统计Bucket内的文档数量，记为_count，并且按照_count降序排序。</p><p>我们可以指定order属性，自定义聚合的排序方式：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /hotel/_search<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span> <br>  <span class="hljs-attr">&quot;aggs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;brandAgg&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;terms&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;field&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;brand&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;order&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;_count&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;asc&quot;</span> <span class="hljs-comment">// 按照_count升序排列</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">20</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="限定聚合范围"><a href="#限定聚合范围" class="headerlink" title="限定聚合范围"></a>限定聚合范围</h3><p>默认情况下，Bucket聚合是对索引库的所有文档做聚合，但真实场景下，用户会输入搜索条件，因此聚合必须是对搜索结果聚合。那么聚合必须添加限定条件。</p><p>我们可以限定要聚合的文档范围，只要添加query条件即可：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /hotel/_search<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;range&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;price&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;lte&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">200</span> <span class="hljs-comment">// 只对200元以下的文档聚合</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span> <br>  <span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span> <br>  <span class="hljs-attr">&quot;aggs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;brandAgg&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;terms&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;field&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;brand&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">20</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>这次，聚合得到的品牌明显变少了：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191846511.png"></p><h3 id="Metric聚合语法"><a href="#Metric聚合语法" class="headerlink" title="Metric聚合语法"></a>Metric聚合语法</h3><p>上节课，我们对酒店按照品牌分组，形成了一个个桶。现在我们需要对桶内的酒店做运算，获取每个品牌的用户评分的min、max、avg等值。</p><p>这就要用到Metric聚合了，例如stat聚合：就可以获取min、max、avg等结果。</p><p>语法如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /hotel/_search<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span> <br>  <span class="hljs-attr">&quot;aggs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;brandAgg&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <br>      <span class="hljs-attr">&quot;terms&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <br>        <span class="hljs-attr">&quot;field&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;brand&quot;</span><span class="hljs-punctuation">,</span> <br>        <span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">20</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;aggs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-comment">// 是brands聚合的子聚合，也就是分组后对每组分别计算</span><br>        <span class="hljs-attr">&quot;score_stats&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-comment">// 聚合名称</span><br>          <span class="hljs-attr">&quot;stats&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-comment">// 聚合类型，这里stats可以计算min、max、avg等</span><br>            <span class="hljs-attr">&quot;field&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;score&quot;</span> <span class="hljs-comment">// 聚合字段，这里是score</span><br>          <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>这次的score_stats聚合是在brandAgg的聚合内部嵌套的子聚合。因为我们需要在每个桶分别计算。</p><p>另外，我们还可以给聚合结果做个排序，例如按照每个桶的酒店平均分做排序：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191847887.png"></p><h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><p>aggs代表聚合，与query同级，此时query的作用是？</p><ul><li>限定聚合的的文档范围</li></ul><p>聚合必须的三要素：</p><ul><li><p>聚合名称</p></li><li><p>聚合类型</p></li><li><p>聚合字段</p></li></ul><p>聚合可配置属性有：</p><ul><li><p>size：指定聚合结果数量</p></li><li><p>order：指定聚合结果排序方式</p></li><li><p>field：指定聚合字段</p></li></ul><h2 id="RestAPI实现聚合"><a href="#RestAPI实现聚合" class="headerlink" title="RestAPI实现聚合"></a>RestAPI实现聚合</h2><h3 id="API语法"><a href="#API语法" class="headerlink" title="API语法"></a>API语法</h3><p>聚合条件与query条件同级别，因此需要使用request.source()来指定聚合条件。</p><p>聚合条件的语法：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191847693.png"></p><p>聚合的结果也与查询结果不同，API也比较特殊。不过同样是JSON逐层解析：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191848045.png"></p><h3 id="业务需求"><a href="#业务需求" class="headerlink" title="业务需求"></a>业务需求</h3><p>需求：搜索页面的品牌、城市等信息不应该是在页面写死，而是通过聚合索引库中的酒店数据得来的：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191848944.png"></p><p>分析：</p><p>目前，页面的城市列表、星级列表、品牌列表都是写死的，并不会随着搜索结果的变化而变化。但是用户搜索条件改变时，搜索结果会跟着变化。</p><p>例如：用户搜索“东方明珠”，那搜索的酒店肯定是在上海东方明珠附近，因此，城市只能是上海，此时城市列表中就不应该显示北京、深圳、杭州这些信息了。</p><p>也就是说，搜索结果中包含哪些城市，页面就应该列出哪些城市；搜索结果中包含哪些品牌，页面就应该列出哪些品牌。</p><p>如何得知搜索结果中包含哪些品牌？如何得知搜索结果中包含哪些城市？</p><p>使用聚合功能，利用Bucket聚合，对搜索结果中的文档基于品牌分组、基于城市分组，就能得知包含哪些品牌、哪些城市了。</p><p>因为是对搜索结果聚合，因此聚合是<strong>限定范围的聚合</strong>，也就是说聚合的限定条件跟搜索文档的条件一致。</p><p>查看浏览器可以发现，前端其实已经发出了这样的一个请求：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191848354.png"></p><p>请求<strong>参数与搜索文档的参数完全一致</strong>。</p><p>返回值类型就是页面要展示的最终结果：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191849539.png"></p><p>结果是一个Map结构：</p><ul><li><p>key是字符串，城市、星级、品牌、价格</p></li><li><p>value是集合，例如多个城市的名称</p></li></ul><h3 id="业务实现"><a href="#业务实现" class="headerlink" title="业务实现"></a>业务实现</h3><p>在<code>cn.itcast.hotel.web</code>包的<code>HotelController</code>中添加一个方法，遵循下面的要求：</p><ul><li><p>请求方式：<code>POST</code></p></li><li><p>请求路径：<code>/hotel/filters</code></p></li><li><p>请求参数：<code>RequestParams</code>，与搜索文档的参数一致</p></li><li><p>返回值类型：<code>Map&lt;String, List&lt;String&gt;&gt;</code></p></li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;filters&quot;)</span><br><span class="hljs-keyword">public</span> Map&lt;String, List&lt;String&gt;&gt; <span class="hljs-title function_">getFilters</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> RequestParams params)</span>&#123;<br>    <span class="hljs-keyword">return</span> hotelService.getFilters(params);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里调用了IHotelService中的getFilters方法，尚未实现。</p><p>在<code>cn.itcast.hotel.service.IHotelService</code>中定义新方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String, List&lt;String&gt;&gt; <span class="hljs-title function_">filters</span><span class="hljs-params">(RequestParams params)</span>;<br></code></pre></td></tr></table></figure><p>在<code>cn.itcast.hotel.service.impl.HotelService</code>中实现该方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Map&lt;String, List&lt;String&gt;&gt; <span class="hljs-title function_">filters</span><span class="hljs-params">(RequestParams params)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 1.准备Request</span><br>        <span class="hljs-type">SearchRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SearchRequest</span>(<span class="hljs-string">&quot;hotel&quot;</span>);<br>        <span class="hljs-comment">// 2.准备DSL</span><br>        <span class="hljs-comment">// 2.1.query</span><br>        buildBasicQuery(params, request);<br>        <span class="hljs-comment">// 2.2.设置size</span><br>        request.source().size(<span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 2.3.聚合</span><br>        buildAggregation(request);<br>        <span class="hljs-comment">// 3.发出请求</span><br>        <span class="hljs-type">SearchResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> client.search(request, RequestOptions.DEFAULT);<br>        <span class="hljs-comment">// 4.解析结果</span><br>        Map&lt;String, List&lt;String&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">Aggregations</span> <span class="hljs-variable">aggregations</span> <span class="hljs-operator">=</span> response.getAggregations();<br>        <span class="hljs-comment">// 4.1.根据品牌名称，获取品牌结果</span><br>        List&lt;String&gt; brandList = getAggByName(aggregations, <span class="hljs-string">&quot;brandAgg&quot;</span>);<br>        result.put(<span class="hljs-string">&quot;品牌&quot;</span>, brandList);<br>        <span class="hljs-comment">// 4.2.根据品牌名称，获取品牌结果</span><br>        List&lt;String&gt; cityList = getAggByName(aggregations, <span class="hljs-string">&quot;cityAgg&quot;</span>);<br>        result.put(<span class="hljs-string">&quot;城市&quot;</span>, cityList);<br>        <span class="hljs-comment">// 4.3.根据品牌名称，获取品牌结果</span><br>        List&lt;String&gt; starList = getAggByName(aggregations, <span class="hljs-string">&quot;starAgg&quot;</span>);<br>        result.put(<span class="hljs-string">&quot;星级&quot;</span>, starList);<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildAggregation</span><span class="hljs-params">(SearchRequest request)</span> &#123;<br>    request.source().aggregation(AggregationBuilders<br>                                 .terms(<span class="hljs-string">&quot;brandAgg&quot;</span>)<br>                                 .field(<span class="hljs-string">&quot;brand&quot;</span>)<br>                                 .size(<span class="hljs-number">100</span>)<br>                                );<br>    request.source().aggregation(AggregationBuilders<br>                                 .terms(<span class="hljs-string">&quot;cityAgg&quot;</span>)<br>                                 .field(<span class="hljs-string">&quot;city&quot;</span>)<br>                                 .size(<span class="hljs-number">100</span>)<br>                                );<br>    request.source().aggregation(AggregationBuilders<br>                                 .terms(<span class="hljs-string">&quot;starAgg&quot;</span>)<br>                                 .field(<span class="hljs-string">&quot;starName&quot;</span>)<br>                                 .size(<span class="hljs-number">100</span>)<br>                                );<br>&#125;<br><br><span class="hljs-keyword">private</span> List&lt;String&gt; <span class="hljs-title function_">getAggByName</span><span class="hljs-params">(Aggregations aggregations, String aggName)</span> &#123;<br>    <span class="hljs-comment">// 4.1.根据聚合名称获取聚合结果</span><br>    <span class="hljs-type">Terms</span> <span class="hljs-variable">brandTerms</span> <span class="hljs-operator">=</span> aggregations.get(aggName);<br>    <span class="hljs-comment">// 4.2.获取buckets</span><br>    List&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Terms</span>.Bucket&gt; buckets = brandTerms.getBuckets();<br>    <span class="hljs-comment">// 4.3.遍历</span><br>    List&lt;String&gt; brandList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (Terms.Bucket bucket : buckets) &#123;<br>        <span class="hljs-comment">// 4.4.获取key</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> bucket.getKeyAsString();<br>        brandList.add(key);<br>    &#125;<br>    <span class="hljs-keyword">return</span> brandList;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全"></a>自动补全</h1><p>当用户在搜索框输入字符时，我们应该提示出与该字符有关的搜索项，如图：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191850045.png"></p><p>这种根据用户输入的字母，提示完整词条的功能，就是自动补全了。</p><p>因为需要根据拼音字母来推断，因此要用到拼音分词功能。</p><h2 id="拼音分词器"><a href="#拼音分词器" class="headerlink" title="拼音分词器"></a>拼音分词器</h2><p>要实现根据字母做补全，就必须对文档按照拼音分词。在GitHub上恰好有elasticsearch的拼音分词插件。地址：<a href="https://github.com/medcl/elasticsearch-analysis-pinyin">https://github.com/medcl/elasticsearch-analysis-pinyin</a></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191850377.png"></p><p>安装方式与IK分词器一样，分三步：</p><p>①解压</p><p>②上传到虚拟机中，elasticsearch的plugin目录</p><p>③重启elasticsearch</p><p>④测试</p><p>详细安装步骤可以参考IK分词器的安装过程。</p><p>测试用法如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">POST /_analyze<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;text&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;如家酒店还不错&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;analyzer&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;pinyin&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191851524.png"></p><h2 id="自定义分词器"><a href="#自定义分词器" class="headerlink" title="自定义分词器"></a>自定义分词器</h2><p>默认的拼音分词器会将每个汉字单独分为拼音，而我们希望的是每个词条形成一组拼音，需要对拼音分词器做个性化定制，形成自定义分词器。</p><p>elasticsearch中分词器（analyzer）的组成包含三部分：</p><ul><li><p>character filters：在tokenizer之前对文本进行处理。例如删除字符、替换字符</p></li><li><p>tokenizer：将文本按照一定的规则切割成词条（term）。例如keyword，就是不分词；还有ik_smart</p></li><li><p>tokenizer filter：将tokenizer输出的词条做进一步处理。例如大小写转换、同义词处理、拼音处理等</p></li></ul><p>文档分词时会依次由这三部分来处理文档：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191851562.png"></p><p>声明自定义分词器的语法如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs json">PUT /test<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;settings&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;analysis&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;analyzer&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-comment">// 自定义分词器</span><br>        <span class="hljs-attr">&quot;my_analyzer&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>  <span class="hljs-comment">// 分词器名称</span><br>          <span class="hljs-attr">&quot;tokenizer&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ik_max_word&quot;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;filter&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;py&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;filter&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-comment">// 自定义tokenizer filter</span><br>        <span class="hljs-attr">&quot;py&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-comment">// 过滤器名称</span><br>          <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;pinyin&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 过滤器类型，这里是pinyin</span><br>  <span class="hljs-attr">&quot;keep_full_pinyin&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;keep_joined_full_pinyin&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;keep_original&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;limit_first_letter_length&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">16</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;remove_duplicated_term&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;none_chinese_pinyin_tokenize&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;mappings&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;analyzer&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;my_analyzer&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;search_analyzer&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ik_smart&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>测试：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191852256.png"></p><p>总结：</p><p>如何使用拼音分词器？</p><ul><li><p>①下载pinyin分词器</p></li><li><p>②解压并放到elasticsearch的plugin目录</p></li><li><p>③重启即可</p></li></ul><p>如何自定义分词器？</p><ul><li><p>①创建索引库时，在settings中配置，可以包含三部分</p></li><li><p>②character filter</p></li><li><p>③tokenizer</p></li><li><p>④filter</p></li></ul><p>拼音分词器注意事项？</p><ul><li>为了避免搜索到同音字，搜索时不要使用拼音分词器</li></ul><h2 id="自动补全查询"><a href="#自动补全查询" class="headerlink" title="自动补全查询"></a>自动补全查询</h2><p>elasticsearch提供了<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.6/search-suggesters.html">Completion Suggester</a>查询来实现自动补全功能。这个查询会匹配以用户输入内容开头的词条并返回。为了提高补全查询的效率，对于文档中字段的类型有一些约束：</p><ul><li><p>参与补全查询的字段必须是completion类型。</p></li><li><p>字段的内容一般是用来补全的多个词条形成的数组。</p></li></ul><p>比如，一个这样的索引库：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// 创建索引库</span><br>PUT test<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;mappings&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;completion&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>然后插入下面的数据：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// 示例数据</span><br>POST test/_doc<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Sony&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;WH-1000XM3&quot;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br>POST test/_doc<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;SK-II&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;PITERA&quot;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br>POST test/_doc<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Nintendo&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;switch&quot;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>查询的DSL语句如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// 自动补全查询</span><br>GET /test/_search<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;suggest&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;title_suggest&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;text&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;s&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 关键字</span><br>      <span class="hljs-attr">&quot;completion&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;field&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;title&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 补全查询的字段</span><br>        <span class="hljs-attr">&quot;skip_duplicates&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 跳过重复的</span><br>        <span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">10</span> <span class="hljs-comment">// 获取前10条结果</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="实现搜索框自动补全"><a href="#实现搜索框自动补全" class="headerlink" title="实现搜索框自动补全"></a>实现搜索框自动补全</h2><p>现在，我们的hotel索引库还没有设置拼音分词器，需要修改索引库中的配置。但是我们知道索引库是无法修改的，只能删除然后重新创建。</p><p>另外，我们需要添加一个字段，用来做自动补全，将brand、suggestion、city等都放进去，作为自动补全的提示。</p><p>因此，总结一下，我们需要做的事情包括：</p><ol><li><p>修改hotel索引库结构，设置自定义拼音分词器</p></li><li><p>修改索引库的name、all字段，使用自定义分词器</p></li><li><p>索引库添加一个新字段suggestion，类型为completion类型，使用自定义的分词器</p></li><li><p>给HotelDoc类添加suggestion字段，内容包含brand、business</p></li><li><p>重新导入数据到hotel库</p></li></ol><h3 id="修改酒店映射结构"><a href="#修改酒店映射结构" class="headerlink" title="修改酒店映射结构"></a>修改酒店映射结构</h3><p>代码如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// 酒店数据索引库</span><br>PUT /hotel<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;settings&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;analysis&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;analyzer&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;text_anlyzer&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;tokenizer&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ik_max_word&quot;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;filter&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;py&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;completion_analyzer&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;tokenizer&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;keyword&quot;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;filter&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;py&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;filter&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;py&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;pinyin&quot;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;keep_full_pinyin&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;keep_joined_full_pinyin&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;keep_original&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;limit_first_letter_length&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">16</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;remove_duplicated_term&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;none_chinese_pinyin_tokenize&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;mappings&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;keyword&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;analyzer&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text_anlyzer&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;search_analyzer&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ik_smart&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;copy_to&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;all&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;address&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;keyword&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;index&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;price&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;integer&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;score&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;integer&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;brand&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;keyword&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;copy_to&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;all&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;city&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;keyword&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;starName&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;keyword&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;business&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;keyword&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;copy_to&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;all&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;location&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;geo_point&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;pic&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;keyword&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;index&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;all&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;analyzer&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text_anlyzer&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;search_analyzer&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ik_smart&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;suggestion&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;completion&quot;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;analyzer&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;completion_analyzer&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="修改HotelDoc实体"><a href="#修改HotelDoc实体" class="headerlink" title="修改HotelDoc实体"></a>修改HotelDoc实体</h3><p>HotelDoc中要添加一个字段，用来做自动补全，内容可以是酒店品牌、城市、商圈等信息。按照自动补全字段的要求，最好是这些字段的数组。</p><p>因此我们在HotelDoc中添加一个suggestion字段，类型为<code>List&lt;String&gt;</code>，然后将brand、city、business等信息放到里面。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.hotel.pojo;<br><br><span class="hljs-keyword">import</span> lombok.Data;<br><span class="hljs-keyword">import</span> lombok.NoArgsConstructor;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Collections;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HotelDoc</span> &#123;<br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String address;<br>    <span class="hljs-keyword">private</span> Integer price;<br>    <span class="hljs-keyword">private</span> Integer score;<br>    <span class="hljs-keyword">private</span> String brand;<br>    <span class="hljs-keyword">private</span> String city;<br>    <span class="hljs-keyword">private</span> String starName;<br>    <span class="hljs-keyword">private</span> String business;<br>    <span class="hljs-keyword">private</span> String location;<br>    <span class="hljs-keyword">private</span> String pic;<br>    <span class="hljs-keyword">private</span> Object distance;<br>    <span class="hljs-keyword">private</span> Boolean isAD;<br>    <span class="hljs-keyword">private</span> List&lt;String&gt; suggestion;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">HotelDoc</span><span class="hljs-params">(Hotel hotel)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = hotel.getId();<br>        <span class="hljs-built_in">this</span>.name = hotel.getName();<br>        <span class="hljs-built_in">this</span>.address = hotel.getAddress();<br>        <span class="hljs-built_in">this</span>.price = hotel.getPrice();<br>        <span class="hljs-built_in">this</span>.score = hotel.getScore();<br>        <span class="hljs-built_in">this</span>.brand = hotel.getBrand();<br>        <span class="hljs-built_in">this</span>.city = hotel.getCity();<br>        <span class="hljs-built_in">this</span>.starName = hotel.getStarName();<br>        <span class="hljs-built_in">this</span>.business = hotel.getBusiness();<br>        <span class="hljs-built_in">this</span>.location = hotel.getLatitude() + <span class="hljs-string">&quot;, &quot;</span> + hotel.getLongitude();<br>        <span class="hljs-built_in">this</span>.pic = hotel.getPic();<br>        <span class="hljs-comment">// 组装suggestion</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.business.contains(<span class="hljs-string">&quot;/&quot;</span>))&#123;<br>            <span class="hljs-comment">// business有多个值，需要切割</span><br>            String[] arr = <span class="hljs-built_in">this</span>.business.split(<span class="hljs-string">&quot;/&quot;</span>);<br>            <span class="hljs-comment">// 添加元素</span><br>            <span class="hljs-built_in">this</span>.suggestion = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-built_in">this</span>.suggestion.add(<span class="hljs-built_in">this</span>.brand);<br>            Collections.addAll(<span class="hljs-built_in">this</span>.suggestion, arr);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">this</span>.suggestion = Arrays.asList(<span class="hljs-built_in">this</span>.brand, <span class="hljs-built_in">this</span>.business);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="重新导入"><a href="#重新导入" class="headerlink" title="重新导入"></a>重新导入</h3><p>重新执行之前编写的导入数据功能，可以看到新的酒店数据中包含了suggestion：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191853437.png"></p><h3 id="自动补全查询的JavaAPI"><a href="#自动补全查询的JavaAPI" class="headerlink" title="自动补全查询的JavaAPI"></a>自动补全查询的JavaAPI</h3><p>之前学习了自动补全查询的DSL，而没有学习对应的JavaAPI，这里给出一个示例：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191853574.png"></p><p>而自动补全的结果也比较特殊，解析的代码如下：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191854229.png"></p><h3 id="实现搜索框自动补全-1"><a href="#实现搜索框自动补全-1" class="headerlink" title="实现搜索框自动补全"></a>实现搜索框自动补全</h3><p>查看前端页面，可以发现当我们在输入框键入时，前端会发起ajax请求：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191854401.png"></p><p>返回值是补全词条的集合，类型为<code>List&lt;String&gt;</code></p><p>1）在<code>cn.itcast.hotel.web</code>包下的<code>HotelController</code>中添加新接口，接收新的请求：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;suggestion&quot;)</span><br><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">getSuggestions</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;key&quot;)</span> String prefix)</span> &#123;<br>    <span class="hljs-keyword">return</span> hotelService.getSuggestions(prefix);<br>&#125;<br></code></pre></td></tr></table></figure><p>2）在<code>cn.itcast.hotel.service</code>包下的<code>IhotelService</code>中添加方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; <span class="hljs-title function_">getSuggestions</span><span class="hljs-params">(String prefix)</span>;<br></code></pre></td></tr></table></figure><p>3）在<code>cn.itcast.hotel.service.impl.HotelService</code>中实现该方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">getSuggestions</span><span class="hljs-params">(String prefix)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 1.准备Request</span><br>        <span class="hljs-type">SearchRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SearchRequest</span>(<span class="hljs-string">&quot;hotel&quot;</span>);<br>        <span class="hljs-comment">// 2.准备DSL</span><br>        request.source().suggest(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SuggestBuilder</span>().addSuggestion(<br>            <span class="hljs-string">&quot;suggestions&quot;</span>,<br>            SuggestBuilders.completionSuggestion(<span class="hljs-string">&quot;suggestion&quot;</span>)<br>            .prefix(prefix)<br>            .skipDuplicates(<span class="hljs-literal">true</span>)<br>            .size(<span class="hljs-number">10</span>)<br>        ));<br>        <span class="hljs-comment">// 3.发起请求</span><br>        <span class="hljs-type">SearchResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> client.search(request, RequestOptions.DEFAULT);<br>        <span class="hljs-comment">// 4.解析结果</span><br>        <span class="hljs-type">Suggest</span> <span class="hljs-variable">suggest</span> <span class="hljs-operator">=</span> response.getSuggest();<br>        <span class="hljs-comment">// 4.1.根据补全查询名称，获取补全结果</span><br>        <span class="hljs-type">CompletionSuggestion</span> <span class="hljs-variable">suggestions</span> <span class="hljs-operator">=</span> suggest.getSuggestion(<span class="hljs-string">&quot;suggestions&quot;</span>);<br>        <span class="hljs-comment">// 4.2.获取options</span><br>        List&lt;CompletionSuggestion.Entry.Option&gt; options = suggestions.getOptions();<br>        <span class="hljs-comment">// 4.3.遍历</span><br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(options.size());<br>        <span class="hljs-keyword">for</span> (CompletionSuggestion.Entry.Option option : options) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> option.getText().toString();<br>            list.add(text);<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h1><p>elasticsearch中的酒店数据来自于mysql数据库，因此mysql数据发生改变时，elasticsearch也必须跟着改变，这个就是elasticsearch与mysql之间的<strong>数据同步</strong>。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191855313.png"></p><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>常见的数据同步方案有三种：</p><ul><li><p>同步调用</p></li><li><p>异步通知</p></li><li><p>监听binlog</p></li></ul><h3 id="同步调用"><a href="#同步调用" class="headerlink" title="同步调用"></a>同步调用</h3><p>方案一：同步调用</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191855858.png"></p><p>基本步骤如下：</p><ul><li><p>hotel-demo对外提供接口，用来修改elasticsearch中的数据</p></li><li><p>酒店管理服务在完成数据库操作后，直接调用hotel-demo提供的接口，</p></li></ul><h3 id="异步通知"><a href="#异步通知" class="headerlink" title="异步通知"></a>异步通知</h3><p>方案二：异步通知</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191856362.png"></p><p>流程如下：</p><ul><li><p>hotel-admin对mysql数据库数据完成增、删、改后，发送MQ消息</p></li><li><p>hotel-demo监听MQ，接收到消息后完成elasticsearch数据修改</p></li></ul><h3 id="监听binlog"><a href="#监听binlog" class="headerlink" title="监听binlog"></a>监听binlog</h3><p>方案三：监听binlog</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191856817.png"></p><p>流程如下：</p><ul><li><p>给mysql开启binlog功能</p></li><li><p>mysql完成增、删、改操作都会记录在binlog中</p></li><li><p>hotel-demo基于canal监听binlog变化，实时更新elasticsearch中的内容</p></li></ul><h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><p>方式一：同步调用</p><ul><li><p>优点：实现简单，粗暴</p></li><li><p>缺点：业务耦合度高</p></li></ul><p>方式二：异步通知</p><ul><li><p>优点：低耦合，实现难度一般</p></li><li><p>缺点：依赖mq的可靠性</p></li></ul><p>方式三：监听binlog</p><ul><li><p>优点：完全解除服务间耦合</p></li><li><p>缺点：开启binlog增加数据库负担、实现复杂度高</p></li></ul><h2 id="实现数据同步"><a href="#实现数据同步" class="headerlink" title="实现数据同步"></a>实现数据同步</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>当酒店数据发生增、删、改时，要求对elasticsearch中数据也要完成相同操作。</p><p>步骤：</p><ul><li><p>导入资料提供的hotel-admin项目，启动并测试酒店数据的CRUD</p></li><li><p>声明exchange、queue、RoutingKey</p></li><li><p>在hotel-admin中的增、删、改业务中完成消息发送()</p></li><li><p>在hotel-demo中完成消息监听，并更新elasticsearch中数据</p></li><li><p>启动并测试数据同步功能</p></li></ul><blockquote><p>注：发送消息，只发送id即可。在消息接收时，根据id从数据库获取hotel实体，然后保存到索引库中。删除简单，直接删对应id的文档即可。涉及到MQ相关，就不再赘述。</p></blockquote><h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1><p>单机的elasticsearch做数据存储，必然面临两个问题：海量数据存储问题、单点故障问题。</p><ul><li><p>海量数据存储问题：将索引库从逻辑上拆分为N个分片（shard），存储到多个节点</p></li><li><p>单点故障问题：将分片数据在不同节点备份（replica ）</p></li></ul><p><strong>ES集群相关概念</strong>:</p><ul><li><p>集群（cluster）：一组拥有共同的 cluster name 的 节点。</p></li><li><p>节点（node) ：集群中的一个 Elasticearch 实例</p></li><li><p>分片（shard）：索引可以被拆分为不同的部分进行存储，称为分片。在集群环境下，一个索引的不同分片可以拆分到不同的节点中</p><p>  解决问题：数据量太大，单点存储量有限的问题。</p></li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191900448.png"></p><ul><li><blockquote><p>此处，我们把数据分成3片：shard0、shard1、shard2</p></blockquote></li><li><p>主分片（Primary shard）：相对于副本分片的定义。</p></li><li><p>副本分片（Replica shard）每个主分片可以有一个或者多个副本，数据和主分片一样。</p></li></ul><p>数据备份可以保证高可用，但是每个分片备份一份，所需要的节点数量就会翻一倍，成本实在是太高了！</p><p>为了在高可用和成本间寻求平衡，我们可以这样做：</p><ul><li><p>首先对数据分片，存储到不同节点</p></li><li><p>然后对每个分片进行备份，放到对方节点，完成互相备份</p></li></ul><p>这样可以大大减少所需要的服务节点数量，如图，我们以3分片，每个分片备份一份为例：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191900331.png"></p><p>现在，每个分片都有1个备份，存储在3个节点：</p><ul><li><p>node0：保存了分片0和1</p></li><li><p>node1：保存了分片0和2</p></li><li><p>node2：保存了分片1和2</p></li></ul><h2 id="集群脑裂问题"><a href="#集群脑裂问题" class="headerlink" title="集群脑裂问题"></a>集群脑裂问题</h2><h3 id="集群责任划分"><a href="#集群责任划分" class="headerlink" title="集群责任划分"></a>集群责任划分</h3><p>elasticsearch中集群节点有不同的职责划分：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191901730.png"></p><p>默认情况下，集群中的任何一个节点都同时具备上述四种角色。</p><p>但是真实的集群一定要将集群职责分离：</p><ul><li><p>master节点：对CPU要求高，但是内存要求第</p></li><li><p>data节点：对CPU和内存要求都高</p></li><li><p>coordinating节点：对网络带宽、CPU要求高</p></li></ul><p>职责分离可以让我们根据不同节点的需求分配不同的硬件去部署。而且避免业务之间的互相干扰。</p><p>一个典型的es集群职责划分如图：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191902709.png"></p><h3 id="脑裂问题"><a href="#脑裂问题" class="headerlink" title="脑裂问题"></a>脑裂问题</h3><p>脑裂是因为集群中的节点失联导致的。</p><p>例如一个集群中，主节点与其它节点失联：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191902761.png"></p><p>此时，node2和node3认为node1宕机，就会重新选主：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191902983.png"></p><p>当node3当选后，集群继续对外提供服务，node2和node3自成集群，node1自成集群，两个集群数据不同步，出现数据差异。</p><p>当网络恢复后，因为集群中有两个master节点，集群状态的不一致，出现脑裂的情况：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191903504.png"></p><p>解决脑裂的方案是，要求选票超过 ( eligible节点数量 + 1 ）&#x2F; 2 才能当选为主，因此eligible节点数量最好是奇数。对应配置项是discovery.zen.minimum_master_nodes，在es7.0以后，已经成为默认配置，因此一般不会发生脑裂问题。</p><p>例如：3个节点形成的集群，选票必须超过 （3 + 1） &#x2F; 2 ，也就是2票。node3得到node2和node3的选票，当选为主。node1只有自己1票，没有当选。集群中依然只有1个主节点，没有出现脑裂。</p><h3 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h3><p>master eligible节点的作用是什么？</p><ul><li><p>参与集群选主</p></li><li><p>主节点可以管理集群状态、管理分片信息、处理创建和删除索引库的请求</p></li></ul><p>data节点的作用是什么？</p><ul><li>数据的CRUD</li></ul><p>coordinator节点的作用是什么？</p><ul><li><p>路由请求到其它节点</p></li><li><p>合并查询到的结果，返回给用户</p></li></ul><h2 id="集群分布式存储"><a href="#集群分布式存储" class="headerlink" title="集群分布式存储"></a>集群分布式存储</h2><p>当新增文档时，应该保存到不同分片，保证数据均衡，那么coordinating node如何确定数据该存储到哪个分片呢？</p><h3 id="分片存储测试"><a href="#分片存储测试" class="headerlink" title="分片存储测试"></a>分片存储测试</h3><p>插入三条数据：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191903294.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191904027.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191904940.png"></p><p>测试可以看到，三条数据分别在不同分片：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191904981.png"></p><p>结果：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191904828.png"></p><h3 id="分配存储原理"><a href="#分配存储原理" class="headerlink" title="分配存储原理"></a>分配存储原理</h3><p>elasticsearch会通过hash算法来计算文档应该存储到哪个分片：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191905694.png"></p><p>说明：</p><ul><li><p>_routing默认是文档的id</p></li><li><p>算法与分片数量有关，因此索引库一旦创建，分片数量不能修改！</p></li></ul><p>新增文档的流程如下：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191905315.png"></p><p>解读：</p><ul><li><p>1）新增一个id&#x3D;1的文档</p></li><li><p>2）对id做hash运算，假如得到的是2，则应该存储到shard-2</p></li><li><p>3）shard-2的主分片在node3节点，将数据路由到node3</p></li><li><p>4）保存文档</p></li><li><p>5）同步给shard-2的副本replica-2，在node2节点</p></li><li><p>6）返回结果给coordinating-node节点</p></li></ul><h2 id="集群分布式查询"><a href="#集群分布式查询" class="headerlink" title="集群分布式查询"></a>集群分布式查询</h2><p>elasticsearch的查询分成两个阶段：</p><ul><li><p>scatter phase：分散阶段，coordinating node会把请求分发到每一个分片</p></li><li><p>gather phase：聚集阶段，coordinating node汇总data node的搜索结果，并处理为最终结果集返回给用户</p></li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191906021.png"></p><h2 id="集群故障转移"><a href="#集群故障转移" class="headerlink" title="集群故障转移"></a>集群故障转移</h2><p>集群的master节点会监控集群中的节点状态，如果发现有节点宕机，会立即将宕机节点的分片数据迁移到其它节点，确保数据安全，这个叫做故障转移。</p><p>1）例如一个集群结构如图：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191906617.png"></p><p>现在，node1是主节点，其它两个节点是从节点。</p><p>2）突然，node1发生了故障：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191906088.png"></p><p>宕机后的第一件事，需要重新选主，例如选中了node2：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191906495.png"></p><p>node2成为主节点后，会检测集群监控状态，发现：shard-1、shard-0没有副本节点。因此需要将node1上的数据迁移到node2、node3：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191907012.png"></p>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
      <category>nosql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>elasticsearch</tag>
      
      <tag>logstash</tag>
      
      <tag>kibana</tag>
      
      <tag>nosql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>elasticseatch-安装小记</title>
    <link href="/posts/8e215a30/"/>
    <url>/posts/8e215a30/</url>
    
    <content type="html"><![CDATA[<h1 id="部署单点ES"><a href="#部署单点ES" class="headerlink" title="部署单点ES"></a>部署单点ES</h1><h2 id="创建网络"><a href="#创建网络" class="headerlink" title="创建网络"></a>创建网络</h2><p>因为我们还需要部署kibana容器，因此需要让es和kibana容器互联。这里先创建一个网络：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker network create es-net<br></code></pre></td></tr></table></figure><h2 id="加载镜像"><a href="#加载镜像" class="headerlink" title="加载镜像"></a>加载镜像</h2><p>这里我们采用elasticsearch的7.12.1版本的镜像，这个镜像体积非常大，接近1G。</p><p>将其上传到虚拟机中，然后运行命令加载即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 导入数据</span><br>docker load -i es.tar<br></code></pre></td></tr></table></figure><p>同理还有<code>kibana</code>的tar包也需要这样做。</p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>运行docker命令，部署单点es：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d \<br>--name es \<br>    -e <span class="hljs-string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span> \<br>    -e <span class="hljs-string">&quot;discovery.type=single-node&quot;</span> \<br>    -v es-data:/usr/share/elasticsearch/data \<br>    -v es-plugins:/usr/share/elasticsearch/plugins \<br>    --privileged \<br>    --network es-net \<br>    -p 9200:9200 \<br>    -p 9300:9300 \<br>elasticsearch:7.12.1<br></code></pre></td></tr></table></figure><p>命令解释：</p><ul><li><code>-e &quot;cluster.name=es-docker-cluster&quot;</code>：设置集群名称</li><li><code>-e &quot;http.host=0.0.0.0&quot;</code>：监听的地址，可以外网访问</li><li><code>-e &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</code>：内存大小</li><li><code>-e &quot;discovery.type=single-node&quot;</code>：非集群模式</li><li><code>-v es-data:/usr/share/elasticsearch/data</code>：挂载逻辑卷，绑定es的数据目录</li><li><code>-v es-logs:/usr/share/elasticsearch/logs</code>：挂载逻辑卷，绑定es的日志目录</li><li><code>-v es-plugins:/usr/share/elasticsearch/plugins</code>：挂载逻辑卷，绑定es的插件目录</li><li><code>--privileged</code>：授予逻辑卷访问权</li><li><code>--network es-net</code> ：加入一个名为es-net的网络中</li><li><code>-p 9200:9200</code>：端口映射配置</li></ul><p>在浏览器中输入：<a href="http://192.168.150.101:9200/">http://192.168.150.101:9200</a> 即可看到elasticsearch的响应结果：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191330169.png"></p><h1 id="部署kibana"><a href="#部署kibana" class="headerlink" title="部署kibana"></a>部署kibana</h1><p>kibana可以给我们提供一个elasticsearch的可视化界面，便于我们学习。</p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>运行docker命令，部署kibana</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker run -d \<br>--name kibana \<br>-e ELASTICSEARCH_HOSTS=http://es:9200 \<br>--network=es-net \<br>-p 5601:5601  \<br>kibana:7.12.1<br></code></pre></td></tr></table></figure><ul><li><code>--network es-net</code> ：加入一个名为es-net的网络中，与elasticsearch在同一个网络中</li><li><code>-e ELASTICSEARCH_HOSTS=http://es:9200&quot;</code>：设置elasticsearch的地址，因为kibana已经与elasticsearch在一个网络，因此可以用容器名直接访问elasticsearch</li><li><code>-p 5601:5601</code>：端口映射配置</li></ul><p>kibana启动一般比较慢，需要多等待一会，可以通过命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker logs -f kibana<br></code></pre></td></tr></table></figure><p>查看运行日志，当查看到下面的日志，说明成功：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191331082.png"></p><p>此时，在浏览器输入地址访问：<a href="http://192.168.150.101:5601/">http://192.168.150.101:5601</a>，即可看到结果</p><h2 id="DevTools"><a href="#DevTools" class="headerlink" title="DevTools"></a>DevTools</h2><p>kibana中提供了一个DevTools界面：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191331490.png"></p><p>这个界面中可以编写DSL来操作elasticsearch。并且对DSL语句有自动补全功能。</p><h1 id="安装IK分词器"><a href="#安装IK分词器" class="headerlink" title="安装IK分词器"></a>安装IK分词器</h1><h2 id="在线安装ik插件"><a href="#在线安装ik插件" class="headerlink" title="在线安装ik插件"></a>在线安装ik插件</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 进入容器内部</span><br>docker <span class="hljs-built_in">exec</span> -it elasticsearch /bin/bash<br><br><span class="hljs-comment"># 在线下载并安装</span><br>./bin/elasticsearch-plugin  install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.12.1/elasticsearch-analysis-ik-7.12.1.zip<br><br><span class="hljs-comment">#退出</span><br><span class="hljs-built_in">exit</span><br><span class="hljs-comment">#重启容器</span><br>docker restart elasticsearch<br></code></pre></td></tr></table></figure><h2 id="离线安装ik插件（推荐）"><a href="#离线安装ik插件（推荐）" class="headerlink" title="离线安装ik插件（推荐）"></a>离线安装ik插件（推荐）</h2><h3 id="查看数据卷目录"><a href="#查看数据卷目录" class="headerlink" title="查看数据卷目录"></a>查看数据卷目录</h3><p>安装插件需要知道elasticsearch的plugins目录位置，而我们用了数据卷挂载，因此需要查看elasticsearch的数据卷目录，通过下面命令查看:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker volume inspect es-plugins<br></code></pre></td></tr></table></figure><p>显示结果：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sh">[<br>    &#123;<br>        <span class="hljs-string">&quot;CreatedAt&quot;</span>: <span class="hljs-string">&quot;2022-05-06T10:06:34+08:00&quot;</span>,<br>        <span class="hljs-string">&quot;Driver&quot;</span>: <span class="hljs-string">&quot;local&quot;</span>,<br>        <span class="hljs-string">&quot;Labels&quot;</span>: null,<br>        <span class="hljs-string">&quot;Mountpoint&quot;</span>: <span class="hljs-string">&quot;/var/lib/docker/volumes/es-plugins/_data&quot;</span>,<br>        <span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;es-plugins&quot;</span>,<br>        <span class="hljs-string">&quot;Options&quot;</span>: null,<br>        <span class="hljs-string">&quot;Scope&quot;</span>: <span class="hljs-string">&quot;local&quot;</span><br>    &#125;<br>]<br></code></pre></td></tr></table></figure><p>说明plugins目录被挂载到了：<code>/var/lib/docker/volumes/es-plugins/_data</code>这个目录中。</p><h3 id="解压分词器安装包"><a href="#解压分词器安装包" class="headerlink" title="解压分词器安装包"></a>解压分词器安装包</h3><p>把的ik分词器解压缩，重命名为ik。</p><h3 id="上传到es容器的插件数据卷中"><a href="#上传到es容器的插件数据卷中" class="headerlink" title="上传到es容器的插件数据卷中"></a>上传到es容器的插件数据卷中</h3><p>也就是<code>/var/lib/docker/volumes/es-plugins/_data</code>：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191333243.png"></p><h3 id="重启容器"><a href="#重启容器" class="headerlink" title="重启容器"></a>重启容器</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 4、重启容器</span><br>docker restart es<br><br><span class="hljs-comment"># 查看es日志</span><br>docker logs -f es<br></code></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>IK分词器包含两种模式：</p><ul><li><code>ik_smart</code>：最少切分</li><li><code>ik_max_word</code>：最细切分</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /_analyze<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;analyzer&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ik_max_word&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;text&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;java程序员学习太棒了&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;tokens&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;token&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;程序员&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;start_offset&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;end_offset&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">5</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;type&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;CN_WORD&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;position&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;token&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;程序&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;start_offset&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;end_offset&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">4</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;type&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;CN_WORD&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;position&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;token&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;员&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;start_offset&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">4</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;end_offset&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">5</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;type&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;CN_CHAR&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;position&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;token&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;学习&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;start_offset&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">5</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;end_offset&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">7</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;type&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;CN_WORD&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;position&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">4</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;token&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;java&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;start_offset&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">7</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;end_offset&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">11</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;type&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ENGLISH&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;position&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">5</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;token&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;太棒了&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;start_offset&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">11</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;end_offset&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">14</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;type&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;CN_WORD&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;position&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">6</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;token&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;太棒&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;start_offset&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">11</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;end_offset&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">13</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;type&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;CN_WORD&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;position&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">7</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;token&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;了&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;start_offset&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">13</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;end_offset&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">14</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;type&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;CN_CHAR&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;position&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">8</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="扩展词词典"><a href="#扩展词词典" class="headerlink" title="扩展词词典"></a>扩展词词典</h2><p>随着互联网的发展，“造词运动”也越发的频繁。出现了很多新的词语，在原有的词汇列表中并不存在。比如：“奥力给”，“传智播客” 等。</p><p>所以我们的词汇也需要不断的更新，IK分词器提供了扩展词汇的功能。</p><p>1）打开IK分词器config目录：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191335394.png"></p><p>2）在IKAnalyzer.cfg.xml配置文件内容添加：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">properties</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;http://java.sun.com/dtd/properties.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">comment</span>&gt;</span>IK Analyzer 扩展配置<span class="hljs-tag">&lt;/<span class="hljs-name">comment</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--用户可以在这里配置自己的扩展字典 *** 添加扩展词典--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;ext_dict&quot;</span>&gt;</span>ext.dic<span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br></code></pre></td></tr></table></figure><p>3）新建一个 ext.dic，可以参考config目录下复制一个配置文件进行修改</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">奥力给</span><br></code></pre></td></tr></table></figure><p>4）重启elasticsearch</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker restart es<br><br><span class="hljs-comment"># 查看 日志</span><br>docker logs -f elasticsearch<br></code></pre></td></tr></table></figure><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191336321.png"></p><p>日志中已经成功加载ext.dic配置文件</p><p>5）测试效果</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /_analyze<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;analyzer&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ik_max_word&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;text&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Java程序员超过90%,奥力给！&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="停用词词典"><a href="#停用词词典" class="headerlink" title="停用词词典"></a>停用词词典</h2><p>在互联网项目中，在网络间传输的速度很快，所以很多语言是不允许在网络上传递的，如：关于宗教、政治等敏感词语，那么我们在搜索时也应该忽略当前词汇。</p><p>IK分词器也提供了强大的停用词功能，让我们在索引时就直接忽略当前的停用词汇表中的内容。</p><p>1）IKAnalyzer.cfg.xml配置文件内容添加：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">properties</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;http://java.sun.com/dtd/properties.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">comment</span>&gt;</span>IK Analyzer 扩展配置<span class="hljs-tag">&lt;/<span class="hljs-name">comment</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--用户可以在这里配置自己的扩展字典--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;ext_dict&quot;</span>&gt;</span>ext.dic<span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span><br>         <span class="hljs-comment">&lt;!--用户可以在这里配置自己的扩展停止词字典  *** 添加停用词词典--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;ext_stopwords&quot;</span>&gt;</span>stopword.dic<span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br></code></pre></td></tr></table></figure><p>3）在 stopword.dic 添加停用词</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dic">习大大<br></code></pre></td></tr></table></figure><p>4）重启elasticsearch</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 重启服务</span><br>docker restart elasticsearch<br>docker restart kibana<br><br><span class="hljs-comment"># 查看 日志</span><br>docker logs -f elasticsearch<br></code></pre></td></tr></table></figure><p>日志中已经成功加载stopword.dic配置文件</p><p>5）测试效果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /_analyze<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;analyzer&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ik_max_word&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;text&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;习大大都点赞,奥力给！&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h1 id="部署es集群"><a href="#部署es集群" class="headerlink" title="部署es集群"></a>部署es集群</h1><p>在单机上利用docker容器运行多个es实例来模拟es集群。不过生产环境推荐大家每一台服务节点仅部署一个es的实例。</p><p>部署es集群可以直接使用docker-compose来完成，但这要求你的Linux虚拟机至少有<strong>4G</strong>的内存空间</p><h2 id="创建es集群"><a href="#创建es集群" class="headerlink" title="创建es集群"></a>创建es集群</h2><p>首先编写一个docker-compose文件，内容如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs sh">version: <span class="hljs-string">&#x27;2.2&#x27;</span><br>services:<br>  es01:<br>    image: elasticsearch:7.12.1<br>    container_name: es01<br>    environment:<br>      - node.name=es01<br>      - cluster.name=es-docker-cluster<br>      - discovery.seed_hosts=es02,es03<br>      - cluster.initial_master_nodes=es01,es02,es03<br>      - <span class="hljs-string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span><br>    volumes:<br>      - data01:/usr/share/elasticsearch/data<br>    ports:<br>      - 9200:9200<br>    networks:<br>      - elastic<br>  es02:<br>    image: elasticsearch:7.12.1<br>    container_name: es02<br>    environment:<br>      - node.name=es02<br>      - cluster.name=es-docker-cluster<br>      - discovery.seed_hosts=es01,es03<br>      - cluster.initial_master_nodes=es01,es02,es03<br>      - <span class="hljs-string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span><br>    volumes:<br>      - data02:/usr/share/elasticsearch/data<br>    ports:<br>      - 9201:9200<br>    networks:<br>      - elastic<br>  es03:<br>    image: elasticsearch:7.12.1<br>    container_name: es03<br>    environment:<br>      - node.name=es03<br>      - cluster.name=es-docker-cluster<br>      - discovery.seed_hosts=es01,es02<br>      - cluster.initial_master_nodes=es01,es02,es03<br>      - <span class="hljs-string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span><br>    volumes:<br>      - data03:/usr/share/elasticsearch/data<br>    networks:<br>      - elastic<br>    ports:<br>      - 9202:9200<br>volumes:<br>  data01:<br>    driver: <span class="hljs-built_in">local</span><br>  data02:<br>    driver: <span class="hljs-built_in">local</span><br>  data03:<br>    driver: <span class="hljs-built_in">local</span><br><br>networks:<br>  elastic:<br>    driver: bridge<br></code></pre></td></tr></table></figure><p>es运行需要修改一些linux系统权限，修改<code>/etc/sysctl.conf</code>文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">vi /etc/sysctl.conf<br></code></pre></td></tr></table></figure><p>添加下面的内容：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">vm.max_map_count=262144<br></code></pre></td></tr></table></figure><p>然后执行命令，让配置生效：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sysctl -p<br></code></pre></td></tr></table></figure><p>通过docker-compose启动集群：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker-compose up -d<br></code></pre></td></tr></table></figure><h2 id="集群状态监控"><a href="#集群状态监控" class="headerlink" title="集群状态监控"></a>集群状态监控</h2><p>kibana可以监控es集群，不过新版本需要依赖es的x-pack 功能，配置比较复杂。</p><p>这里推荐使用cerebro来监控es集群状态，官方网址：<a href="https://github.com/lmenezes/cerebro">https://github.com/lmenezes/cerebro</a></p><p>解压即可使用，非常方便。</p><p>解压好的目录如下：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191341956.png"></p><p>进入对应的bin目录：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191341437.png"></p><p>双击其中的cerebro.bat文件即可启动服务。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191342477.png"></p><p>访问<a href="http://localhost:9000/">http://localhost:9000</a> 即可进入管理界面：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191342780.png"></p><p>输入你的elasticsearch的任意节点的地址和端口，点击connect即可：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191342137.png"></p><p>绿色的条，代表集群处于绿色（健康状态）。</p><h2 id="创建索引库"><a href="#创建索引库" class="headerlink" title="创建索引库"></a>创建索引库</h2><h3 id="利用kibana的DevTools创建索引库"><a href="#利用kibana的DevTools创建索引库" class="headerlink" title="利用kibana的DevTools创建索引库"></a>利用kibana的DevTools创建索引库</h3><p>在DevTools中输入指令：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs json">PUT /itcast<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;settings&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;number_of_shards&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 分片数量</span><br>    <span class="hljs-attr">&quot;number_of_replicas&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span> <span class="hljs-comment">// 副本数量</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;mappings&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-comment">// mapping映射定义 ...</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="利用cerebro创建索引库"><a href="#利用cerebro创建索引库" class="headerlink" title="利用cerebro创建索引库"></a>利用cerebro创建索引库</h3><p>利用cerebro还可以创建索引库：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191343284.png"></p><p>填写索引库信息：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191343989.png"></p><h2 id="查看分片效果"><a href="#查看分片效果" class="headerlink" title="查看分片效果"></a>查看分片效果</h2><p>回到首页，即可查看索引库分片效果：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191344845.png"></p>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AMQP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通关微服务-rabbitMQ</title>
    <link href="/posts/d4befa93/"/>
    <url>/posts/d4befa93/</url>
    
    <content type="html"><![CDATA[<h1 id="初识MQ"><a href="#初识MQ" class="headerlink" title="初识MQ"></a>初识MQ</h1><h2 id="同步和异步通讯"><a href="#同步和异步通讯" class="headerlink" title="同步和异步通讯"></a>同步和异步通讯</h2><p>微服务间通讯有同步和异步两种方式：</p><p>同步通讯：就像打电话，需要实时响应。</p><p>异步通讯：就像发邮件，不需要马上回复。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191235206.png"></p><p>两种方式各有优劣，打电话可以立即得到响应，但是你却不能跟多个人同时通话。发送邮件可以同时与多个人收发邮件，但是往往响应会有延迟。</p><h3 id="同步通信"><a href="#同步通信" class="headerlink" title="同步通信"></a>同步通信</h3><p>我们之前学习的<code>Feign</code>调用就属于<strong>同步方式</strong>，虽然调用可以<strong>实时得到结果</strong>，但存在下面的问题：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191235260.png"></p><p>总结：</p><p>同步调用的优点：</p><ul><li>时效性较强，可以立即得到结果</li></ul><p>同步调用的问题：</p><ul><li>耦合度高</li><li>性能和吞吐能力下降</li><li>有额外的资源消耗</li><li>有级联失败问题</li></ul><h3 id="异步通信"><a href="#异步通信" class="headerlink" title="异步通信"></a>异步通信</h3><p>异步调用则可以避免上述问题：</p><p>我们以购买商品为例，用户支付后需要调用订单服务完成订单状态修改，调用物流服务，从仓库分配响应的库存并准备发货。</p><p>在事件模式中，支付服务是事件发布者（publisher），在支付完成后只需要发布一个支付成功的事件（event），事件中带上订单id。</p><p>订单服务和物流服务是事件订阅者（Consumer），订阅支付成功的事件，监听到事件后完成自己业务即可。</p><p>为了解除事件发布者与订阅者之间的耦合，两者并不是直接通信，而是有一个中间人（Broker）。发布者发布事件到Broker，不关心谁来订阅事件。订阅者从Broker订阅事件，不关心谁发来的消息。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191236921.png"></p><p>Broker 是一个像数据总线一样的东西，所有的服务要接收数据和发送数据都发到这个总线上，这个总线就像协议一样，让服务间的通讯变得标准和可控。</p><p>好处：</p><ul><li>吞吐量提升：无需等待订阅者处理完成，响应更快速</li><li>故障隔离：服务没有直接调用，不存在级联失败问题</li><li>调用间没有阻塞，不会造成无效的资源占用</li><li>耦合度极低，每个服务都可以灵活插拔，可替换</li><li>流量削峰：不管发布事件的流量波动多大，都由Broker接收，订阅者可以按照自己的速度去处理事件</li></ul><p>缺点：</p><ul><li>架构复杂了，业务没有明显的流程线，不好管理</li><li>需要依赖于Broker的可靠、安全、性能</li></ul><p>好在现在开源软件或云平台上 Broker 的软件是非常成熟的，比较常见的一种就是我们今天要学习的MQ技术。</p><h2 id="技术对比"><a href="#技术对比" class="headerlink" title="技术对比"></a>技术对比</h2><p>MQ，中文是消息队列（MessageQueue），字面来看就是存放消息的队列。也就是事件驱动架构中的Broker。</p><p>比较常见的MQ实现：</p><ul><li>ActiveMQ</li><li>RabbitMQ</li><li>RocketMQ</li><li>Kafka</li></ul><p>几种常见MQ的对比：</p><table><thead><tr><th></th><th><strong>RabbitMQ</strong></th><th><strong>ActiveMQ</strong></th><th><strong>RocketMQ</strong></th><th><strong>Kafka</strong></th></tr></thead><tbody><tr><td>公司&#x2F;社区</td><td>Rabbit</td><td>Apache</td><td>阿里</td><td>Apache</td></tr><tr><td>开发语言</td><td>Erlang</td><td>Java</td><td>Java</td><td>Scala&amp;Java</td></tr><tr><td>协议支持</td><td>AMQP，XMPP，SMTP，STOMP</td><td>OpenWire,STOMP，REST,XMPP,AMQP</td><td>自定义协议</td><td>自定义协议</td></tr><tr><td>可用性</td><td>高</td><td>一般</td><td>高</td><td>高</td></tr><tr><td>单机吞吐量</td><td>一般</td><td>差</td><td>高</td><td>非常高</td></tr><tr><td>消息延迟</td><td>微秒级</td><td>毫秒级</td><td>毫秒级</td><td>毫秒以内</td></tr><tr><td>消息可靠性</td><td>高</td><td>一般</td><td>高</td><td>一般</td></tr></tbody></table><p>追求可用性：Kafka、 RocketMQ 、RabbitMQ<br>追求可靠性：RabbitMQ、RocketMQ<br>追求吞吐能力：RocketMQ、Kafka<br>追求消息低延迟：RabbitMQ、Kafka</p><h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><p>RabbitMQ的基本结构：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191240368.png"></p><p>RabbitMQ中的一些角色：</p><ul><li>publisher：生产者</li><li>consumer：消费者</li><li>exchange：交换机，负责消息路由</li><li>queue：队列，存储消息</li><li>virtualHost：虚拟主机，隔离不同租户的exchange、queue、消息的隔离</li></ul><h2 id="消息模型"><a href="#消息模型" class="headerlink" title="消息模型"></a>消息模型</h2><p>RabbitMQ官方提供了5个不同的Demo示例，对应了不同的消息模型：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191244047.png"></p><h2 id="安装RabbitMQ"><a href="#安装RabbitMQ" class="headerlink" title="安装RabbitMQ"></a>安装RabbitMQ</h2><h2 id="单机部署"><a href="#单机部署" class="headerlink" title="单机部署"></a>单机部署</h2><p>一般公司环境都在Centos7虚拟机中使用Docker来安装。</p><h3 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h3><p>方式一：在线拉取</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker pull rabbitmq:3-management<br></code></pre></td></tr></table></figure><p>方式二：从本地加载</p><p>上传到虚拟机中后，使用命令加载镜像即可：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker load -i mq.tar<br></code></pre></td></tr></table></figure><h3 id="安装MQ"><a href="#安装MQ" class="headerlink" title="安装MQ"></a>安装MQ</h3><p>执行下面的命令来运行MQ容器：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker run \<br> -e RABBITMQ_DEFAULT_USER=itcast \<br> -e RABBITMQ_DEFAULT_PASS=123321 \<br> --name mq \<br> --hostname mq1 \<br> -p 15672:15672 \<br> -p 5672:5672 \<br> -d \<br> rabbitmq:3-management<br></code></pre></td></tr></table></figure><h2 id="集群部署"><a href="#集群部署" class="headerlink" title="集群部署"></a>集群部署</h2><p>在RabbitMQ的官方文档中，讲述了两种集群的配置方式：</p><ul><li><p>普通模式：普通模式集群不进行数据同步，每个MQ都有自己的队列、数据信息（其它元数据信息如交换机等会同步）。例如我们有2个MQ：mq1，和mq2，如果你的消息在mq1，而你连接到了mq2，那么mq2会去mq1拉取消息，然后返回给你。如果mq1宕机，消息就会丢失。</p></li><li><p>镜像模式：与普通模式不同，队列会在各个mq的镜像节点之间同步，因此你连接到任何一个镜像节点，均可获取到消息。而且如果一个节点宕机，并不会导致数据丢失。不过，这种方式增加了数据同步的带宽消耗。</p></li></ul><h3 id="集群分类"><a href="#集群分类" class="headerlink" title="集群分类"></a>集群分类</h3><p>首先，我们需要让3台MQ互相知道对方的存在。</p><p>分别在3台机器中，设置 &#x2F;etc&#x2F;hosts文件，添加如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs conf">192.168.150.101 mq1<br>192.168.150.102 mq2<br>192.168.150.103 mq3<br></code></pre></td></tr></table></figure><p>并在每台机器上测试，是否可以ping通对方：</p><p>详细集群部署还是参照官方文档，这里不再赘述。</p><h2 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h2><p>创建实例Demo工程，mq-demo，</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191245186.png"></p><p>包括三部分：</p><ul><li>mq-demo：父工程，管理项目依赖</li><li>publisher：消息的发送者</li><li>consumer：消息的消费者</li></ul><p>简单队列模式的模型图：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191245190.png"></p><p>官方的HelloWorld是基于最基础的消息队列模型来实现的，只包括三个角色：</p><ul><li>publisher：消息发布者，将消息发送到队列queue</li><li>queue：消息队列，负责接受并缓存消息</li><li>consumer：订阅队列，处理队列中的消息</li></ul><h3 id="publisher实现"><a href="#publisher实现" class="headerlink" title="publisher实现"></a>publisher实现</h3><p>思路：</p><ul><li>建立连接</li><li>创建Channel</li><li>声明队列</li><li>发送消息</li><li>关闭连接和channel</li></ul><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.mq.helloworld;<br><br><span class="hljs-keyword">import</span> com.rabbitmq.client.Channel;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.Connection;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.ConnectionFactory;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeoutException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PublisherTest</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSendMessage</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException &#123;<br>        <span class="hljs-comment">// 1.建立连接</span><br>        <span class="hljs-type">ConnectionFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectionFactory</span>();<br>        <span class="hljs-comment">// 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码</span><br>        factory.setHost(<span class="hljs-string">&quot;192.168.150.101&quot;</span>);<br>        factory.setPort(<span class="hljs-number">5672</span>);<br>        factory.setVirtualHost(<span class="hljs-string">&quot;/&quot;</span>);<br>        factory.setUsername(<span class="hljs-string">&quot;itcast&quot;</span>);<br>        factory.setPassword(<span class="hljs-string">&quot;123321&quot;</span>);<br>        <span class="hljs-comment">// 1.2.建立连接</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> factory.newConnection();<br><br>        <span class="hljs-comment">// 2.创建通道Channel</span><br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br><br>        <span class="hljs-comment">// 3.创建队列</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">queueName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;simple.queue&quot;</span>;<br>        channel.queueDeclare(queueName, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br><br>        <span class="hljs-comment">// 4.发送消息</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello, rabbitmq!&quot;</span>;<br>        channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>, queueName, <span class="hljs-literal">null</span>, message.getBytes());<br>        System.out.println(<span class="hljs-string">&quot;发送消息成功：【&quot;</span> + message + <span class="hljs-string">&quot;】&quot;</span>);<br><br>        <span class="hljs-comment">// 5.关闭通道和连接</span><br>        channel.close();<br>        connection.close();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="consumer实现"><a href="#consumer实现" class="headerlink" title="consumer实现"></a>consumer实现</h3><p>代码思路：</p><ul><li>建立连接</li><li>创建Channel</li><li>声明队列</li><li>订阅消息</li></ul><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.mq.helloworld;<br><br><span class="hljs-keyword">import</span> com.rabbitmq.client.*;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeoutException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConsumerTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException &#123;<br>        <span class="hljs-comment">// 1.建立连接</span><br>        <span class="hljs-type">ConnectionFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectionFactory</span>();<br>        <span class="hljs-comment">// 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码</span><br>        factory.setHost(<span class="hljs-string">&quot;192.168.150.101&quot;</span>);<br>        factory.setPort(<span class="hljs-number">5672</span>);<br>        factory.setVirtualHost(<span class="hljs-string">&quot;/&quot;</span>);<br>        factory.setUsername(<span class="hljs-string">&quot;itcast&quot;</span>);<br>        factory.setPassword(<span class="hljs-string">&quot;123321&quot;</span>);<br>        <span class="hljs-comment">// 1.2.建立连接</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> factory.newConnection();<br><br>        <span class="hljs-comment">// 2.创建通道Channel</span><br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br><br>        <span class="hljs-comment">// 3.创建队列</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">queueName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;simple.queue&quot;</span>;<br>        channel.queueDeclare(queueName, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br><br>        <span class="hljs-comment">// 4.订阅消息</span><br>        channel.basicConsume(queueName, <span class="hljs-literal">true</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultConsumer</span>(channel)&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope,</span><br><span class="hljs-params">                                       AMQP.BasicProperties properties, <span class="hljs-type">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>                <span class="hljs-comment">// 5.处理消息</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(body);<br>                System.out.println(<span class="hljs-string">&quot;接收到消息：【&quot;</span> + message + <span class="hljs-string">&quot;】&quot;</span>);<br>            &#125;<br>        &#125;);<br>        System.out.println(<span class="hljs-string">&quot;等待接收消息。。。。&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>基本消息队列的消息发送流程：</p><ol><li>建立connection</li><li>创建channel</li><li>利用channel声明队列</li><li>利用channel向队列发送消息</li></ol><p>基本消息队列的消息接收流程：</p><ol><li>建立connection</li><li>创建channel</li><li>利用channel声明队列</li><li>定义consumer的消费行为handleDelivery()</li><li>利用channel将消费者与队列绑定</li></ol><h1 id="SpringAMQP"><a href="#SpringAMQP" class="headerlink" title="SpringAMQP"></a>SpringAMQP</h1><p>SpringAMQP是基于RabbitMQ封装的一套模板，并且还利用SpringBoot对其实现了自动装配，使用起来非常方便。</p><p>SpringAmqp的官方地址：<a href="https://spring.io/projects/spring-amqp">https://spring.io/projects/spring-amqp</a></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191248100.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191250431.png"></p><p>SpringAMQP提供了三个功能：</p><ul><li>自动声明队列、交换机及其绑定关系</li><li>基于注解的监听器模式，异步接收消息</li><li>封装了RabbitTemplate工具，用于发送消息</li></ul><h2 id="Basic-Queue简单队列模型"><a href="#Basic-Queue简单队列模型" class="headerlink" title="Basic Queue简单队列模型"></a>Basic Queue简单队列模型</h2><p>在父工程mq-demo中引入依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pom">&lt;!--AMQP依赖，包含RabbitMQ--&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><h3 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h3><p>首先配置MQ地址，在publisher服务的application.yml中添加配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.150</span><span class="hljs-number">.101</span> <span class="hljs-comment"># 主机名</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span> <span class="hljs-comment"># 端口</span><br>    <span class="hljs-attr">virtual-host:</span> <span class="hljs-string">/</span> <span class="hljs-comment"># 虚拟主机</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">mymq</span> <span class="hljs-comment"># 用户名</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">111111</span> <span class="hljs-comment"># 密码</span><br></code></pre></td></tr></table></figure><p>然后在publisher服务中编写测试类SpringAmqpTest，并利用RabbitTemplate实现消息发送：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.mq.spring;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.junit.runner.RunWith;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.boot.test.context.SpringBootTest;<br><span class="hljs-keyword">import</span> org.springframework.test.context.junit4.SpringRunner;<br><br><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringAmqpTest</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSimpleQueue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 队列名称</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">queueName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;simple.queue&quot;</span>;<br>        <span class="hljs-comment">// 消息</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello, spring amqp!&quot;</span>;<br>        <span class="hljs-comment">// 发送消息</span><br>        rabbitTemplate.convertAndSend(queueName, message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="消息接收"><a href="#消息接收" class="headerlink" title="消息接收"></a>消息接收</h3><p>首先配置MQ地址，在consumer服务的application.yml中添加配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.150</span><span class="hljs-number">.101</span> <span class="hljs-comment"># 主机名</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span> <span class="hljs-comment"># 端口</span><br>    <span class="hljs-attr">virtual-host:</span> <span class="hljs-string">/</span> <span class="hljs-comment"># 虚拟主机</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">mymq</span> <span class="hljs-comment"># 用户名</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">111111</span> <span class="hljs-comment"># 密码</span><br></code></pre></td></tr></table></figure><p>然后在consumer服务的<code>cn.itcast.mq.listener</code>包中新建一个类SpringRabbitListener，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.mq.listener;<br><br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringRabbitListener</span> &#123;<br><br>    <span class="hljs-meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenSimpleQueueMessage</span><span class="hljs-params">(String msg)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        System.out.println(<span class="hljs-string">&quot;spring 消费者接收到消息：【&quot;</span> + msg + <span class="hljs-string">&quot;】&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>启动consumer服务，然后在publisher服务中运行测试代码，发送MQ消息，即可看到接收到了。</p><h2 id="WorkQueue"><a href="#WorkQueue" class="headerlink" title="WorkQueue"></a>WorkQueue</h2><p>Work queues，也被称为（Task queues），任务模型。简单来说就是<strong>让多个消费者绑定到一个队列，共同消费队列中的消息</strong>。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191252740.png"><br>当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。</p><p>此时就可以使用work 模型，多个消费者共同处理消息处理，速度就能大大提高了。</p><h3 id="消息发送-1"><a href="#消息发送-1" class="headerlink" title="消息发送"></a>消息发送</h3><p>这次我们循环发送，模拟大量消息堆积现象。</p><p>在publisher服务中的SpringAmqpTest类中添加一个测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * workQueue</span><br><span class="hljs-comment">     * 向队列中不停发送消息，模拟消息堆积。</span><br><span class="hljs-comment">     */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testWorkQueue</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-comment">// 队列名称</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">queueName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;simple.queue&quot;</span>;<br>    <span class="hljs-comment">// 消息</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello, message_&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;<br>        <span class="hljs-comment">// 发送消息</span><br>        rabbitTemplate.convertAndSend(queueName, message + i);<br>        Thread.sleep(<span class="hljs-number">20</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="消息接收-1"><a href="#消息接收-1" class="headerlink" title="消息接收"></a>消息接收</h3><p>要模拟多个消费者绑定同一个队列，我们在consumer服务的SpringRabbitListener中添加2个新的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenWorkQueue1</span><span class="hljs-params">(String msg)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    System.out.println(<span class="hljs-string">&quot;消费者1接收到消息：【&quot;</span> + msg + <span class="hljs-string">&quot;】&quot;</span> + LocalTime.now());<br>    Thread.sleep(<span class="hljs-number">20</span>);<span class="hljs-comment">//模拟任务耗时</span><br>&#125;<br><br><span class="hljs-meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenWorkQueue2</span><span class="hljs-params">(String msg)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    System.err.println(<span class="hljs-string">&quot;消费者2........接收到消息：【&quot;</span> + msg + <span class="hljs-string">&quot;】&quot;</span> + LocalTime.now());<br>    Thread.sleep(<span class="hljs-number">200</span>);<span class="hljs-comment">//模拟任务耗时</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><p>启动ConsumerApplication后，再执行publisher服务中刚刚编写的发送测试方法testWorkQueue。</p><p>可以看到消费者1很快完成了自己的25条消息。消费者2却在缓慢的处理自己的25条消息。</p><p>也就是说消息是<strong>平均分配给每个消费者，并没有考虑到消费者的处理能力</strong>。这样显然是有问题的。</p><h3 id="能者多劳"><a href="#能者多劳" class="headerlink" title="能者多劳"></a>能者多劳</h3><p>在spring中有一个简单的配置，可以解决这个问题。我们修改consumer服务的application.yml文件，添加配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">listener:</span><br>      <span class="hljs-attr">simple:</span><br>        <span class="hljs-attr">prefetch:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 每次只能获取一条消息，处理完成才能获取下一个消息</span><br></code></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>Work模型的使用：</p><ul><li>多个消费者绑定到一个队列，同一条消息只会被一个消费者处理</li><li>通过设置prefetch来控制消费者预取的消息数量</li></ul><h2 id="发布-x2F-订阅"><a href="#发布-x2F-订阅" class="headerlink" title="发布&#x2F;订阅"></a>发布&#x2F;订阅</h2><p>发布订阅的模型如图：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191255102.png"></p><p>可以看到，在订阅模型中，多了一个exchange角色，而且过程略有变化：</p><ul><li>Publisher：生产者，也就是要发送消息的程序，但是不再发送到队列中，而是发给交换机</li><li>Exchange：交换机。一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。Exchange有以下3种类型：<ul><li>Fanout：广播，将消息交给所有绑定到交换机的队列</li><li>Direct：定向，把消息交给符合指定routing key 的队列</li><li>Topic：通配符，把消息交给符合routing pattern（路由模式） 的队列</li></ul></li><li>Consumer：消费者，与以前一样，订阅队列，没有变化</li><li>Queue：消息队列也与以前一样，接收消息、缓存消息。</li></ul><p><strong>Exchange（交换机）只负责转发消息，不具备存储消息的能力</strong>，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！</p><h2 id="Fanout"><a href="#Fanout" class="headerlink" title="Fanout"></a>Fanout</h2><p>Fanout，英文翻译是扇出，我觉得在MQ中叫<strong>广播</strong>更合适。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191257796.png"></p><p>在广播模式下，消息发送流程是这样的：</p><ul><li>1） 可以有多个队列</li><li>2） 每个队列都要绑定到Exchange（交换机）</li><li>3） 生产者发送的消息，只能发送到交换机，交换机来决定要发给哪个队列，生产者无法决定</li><li>4） 交换机把消息发送给绑定过的所有队列</li><li>5） 订阅队列的消费者都能拿到消息</li></ul><p>计划是这样的：</p><ul><li>创建一个交换机 itcast.fanout，类型是Fanout</li><li>创建两个队列fanout.queue1和fanout.queue2，绑定到交换机itcast.fanout</li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191258334.png"></p><h3 id="声明队列和交换机"><a href="#声明队列和交换机" class="headerlink" title="声明队列和交换机"></a>声明队列和交换机</h3><p>Spring提供了一个接口Exchange，来表示所有不同类型的交换机：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191258274.png"></p><p>在consumer中创建一个类，声明队列和交换机：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.mq.config;<br><br><span class="hljs-keyword">import</span> org.springframework.amqp.core.Binding;<br><span class="hljs-keyword">import</span> org.springframework.amqp.core.BindingBuilder;<br><span class="hljs-keyword">import</span> org.springframework.amqp.core.FanoutExchange;<br><span class="hljs-keyword">import</span> org.springframework.amqp.core.Queue;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FanoutConfig</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 声明交换机</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> Fanout类型交换机</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> FanoutExchange <span class="hljs-title function_">fanoutExchange</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FanoutExchange</span>(<span class="hljs-string">&quot;itcast.fanout&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 第1个队列</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">fanoutQueue1</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>(<span class="hljs-string">&quot;fanout.queue1&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 绑定队列和交换机</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">bindingQueue1</span><span class="hljs-params">(Queue fanoutQueue1, FanoutExchange fanoutExchange)</span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(fanoutQueue1).to(fanoutExchange);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 第2个队列</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">fanoutQueue2</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>(<span class="hljs-string">&quot;fanout.queue2&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 绑定队列和交换机</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">bindingQueue2</span><span class="hljs-params">(Queue fanoutQueue2, FanoutExchange fanoutExchange)</span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(fanoutQueue2).to(fanoutExchange);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="消息发送-2"><a href="#消息发送-2" class="headerlink" title="消息发送"></a>消息发送</h3><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testFanoutExchange</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 队列名称</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">exchangeName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;itcast.fanout&quot;</span>;<br>    <span class="hljs-comment">// 消息</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello, everyone!&quot;</span>;<br>    rabbitTemplate.convertAndSend(exchangeName, <span class="hljs-string">&quot;&quot;</span>, message);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="消息接收-2"><a href="#消息接收-2" class="headerlink" title="消息接收"></a>消息接收</h3><p>在consumer服务的SpringRabbitListener中添加两个方法，作为消费者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RabbitListener(queues = &quot;fanout.queue1&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenFanoutQueue1</span><span class="hljs-params">(String msg)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;消费者1接收到Fanout消息：【&quot;</span> + msg + <span class="hljs-string">&quot;】&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">@RabbitListener(queues = &quot;fanout.queue2&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenFanoutQueue2</span><span class="hljs-params">(String msg)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;消费者2接收到Fanout消息：【&quot;</span> + msg + <span class="hljs-string">&quot;】&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>交换机的作用是什么？</p><ul><li>接收publisher发送的消息</li><li>将消息按照规则路由到与之绑定的队列</li><li>不能缓存消息，路由失败，消息丢失</li><li>FanoutExchange的会将消息路由到每个绑定的队列</li></ul><p>声明队列、交换机、绑定关系的Bean是什么？</p><ul><li>Queue</li><li>FanoutExchange</li><li>Binding</li></ul><h2 id="Direct"><a href="#Direct" class="headerlink" title="Direct"></a>Direct</h2><p>在Fanout模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191301419.png"></p><p>在Direct模型下：</p><ul><li>队列与交换机的绑定，不能是任意绑定了，而是要指定一个<code>RoutingKey</code>（路由key）</li><li>消息的发送方在 向 Exchange发送消息时，也必须指定消息的 <code>RoutingKey</code>。</li><li>Exchange不再把消息交给每一个绑定的队列，而是根据消息的<code>Routing Key</code>进行判断，只有队列的<code>Routingkey</code>与消息的 <code>Routing key</code>完全一致，才会接收到消息</li></ul><p><strong>案例需求如下</strong>：</p><ol><li>利用@RabbitListener声明Exchange、Queue、RoutingKey</li><li>在consumer服务中，编写两个消费者方法，分别监听direct.queue1和direct.queue2</li><li>在publisher中编写测试方法，向itcast. direct发送消息</li></ol><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191302750.png"></p><h3 id="基于注解声明队列-amp-交换机"><a href="#基于注解声明队列-amp-交换机" class="headerlink" title="基于注解声明队列&amp;交换机"></a>基于注解声明队列&amp;交换机</h3><p>基于@Bean的方式声明队列和交换机比较麻烦，Spring还提供了基于注解方式来声明。</p><p>在consumer的SpringRabbitListener中添加两个消费者，同时<strong>基于注解来声明队列和交换机</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RabbitListener(bindings = @QueueBinding(</span><br><span class="hljs-meta">    value = @Queue(name = &quot;direct.queue1&quot;),</span><br><span class="hljs-meta">    exchange = @Exchange(name = &quot;itcast.direct&quot;, type = ExchangeTypes.DIRECT),</span><br><span class="hljs-meta">    key = &#123;&quot;red&quot;, &quot;blue&quot;&#125;</span><br><span class="hljs-meta">))</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenDirectQueue1</span><span class="hljs-params">(String msg)</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;消费者接收到direct.queue1的消息：【&quot;</span> + msg + <span class="hljs-string">&quot;】&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">@RabbitListener(bindings = @QueueBinding(</span><br><span class="hljs-meta">    value = @Queue(name = &quot;direct.queue2&quot;),</span><br><span class="hljs-meta">    exchange = @Exchange(name = &quot;itcast.direct&quot;, type = ExchangeTypes.DIRECT),</span><br><span class="hljs-meta">    key = &#123;&quot;red&quot;, &quot;yellow&quot;&#125;</span><br><span class="hljs-meta">))</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenDirectQueue2</span><span class="hljs-params">(String msg)</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;消费者接收到direct.queue2的消息：【&quot;</span> + msg + <span class="hljs-string">&quot;】&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="消息发送-3"><a href="#消息发送-3" class="headerlink" title="消息发送"></a>消息发送</h3><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSendDirectExchange</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 交换机名称</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">exchangeName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;itcast.direct&quot;</span>;<br>    <span class="hljs-comment">// 消息</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;红色警报！日本乱排核废水，导致海洋生物变异，惊现哥斯拉！&quot;</span>;<br>    <span class="hljs-comment">// 发送消息</span><br>    rabbitTemplate.convertAndSend(exchangeName, <span class="hljs-string">&quot;red&quot;</span>, message);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>描述下Direct交换机与Fanout交换机的差异？</p><ul><li>Fanout交换机将消息路由给每一个与之绑定的队列</li><li>Direct交换机根据RoutingKey判断路由给哪个队列</li><li>如果多个队列具有相同的RoutingKey，则与Fanout功能类似</li></ul><p>基于@RabbitListener注解声明队列和交换机有哪些常见注解？</p><ul><li>@Queue</li><li>@Exchange</li></ul><h2 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p><code>Topic</code>类型的<code>Exchange</code>与<code>Direct</code>相比，都是可以根据<code>RoutingKey</code>把消息路由到不同的队列。只不过<code>Topic</code>类型<code>Exchange</code>可以让队列在绑定<code>Routing key</code> 的时候<strong>使用通配符</strong>！</p><p><code>Routingkey</code> 一般都是有一个或多个单词组成，多个单词之间以”.”分割，例如： <code>item.insert</code></p><p>通配符规则：</p><p><code>#</code>：匹配一个或多个<strong>词</strong></p><p><code>*</code>：匹配不多不少恰好1个<strong>词</strong></p><p>举例：</p><p><code>item.#</code>：能够匹配<code>item.spu.insert</code> 或者 <code>item.spu</code></p><p><code>item.*</code>：只能匹配<code>item.spu</code></p><p>图示：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191305599.png"><br>解释：</p><ul><li>Queue1：绑定的是<code>china.#</code> ，因此凡是以 <code>china.</code>开头的<code>routing key</code> 都会被匹配到。包括china.news和china.weather</li><li>Queue2：绑定的是<code>#.news</code> ，因此凡是以 <code>.news</code>结尾的 <code>routing key</code> 都会被匹配。包括china.news和japan.news</li></ul><p><strong>案例需求</strong></p><p>实现思路如下：</p><ol><li>并利用@RabbitListener声明Exchange、Queue、RoutingKey</li><li>在consumer服务中，编写两个消费者方法，分别监听topic.queue1和topic.queue2</li><li>在publisher中编写测试方法，向itcast. topic发送消息</li></ol><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191305740.png"></p><h3 id="消息发送-4"><a href="#消息发送-4" class="headerlink" title="消息发送"></a>消息发送</h3><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * topicExchange</span><br><span class="hljs-comment">     */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSendTopicExchange</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 交换机名称</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">exchangeName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;itcast.topic&quot;</span>;<br>    <span class="hljs-comment">// 消息</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;喜报！孙悟空大战哥斯拉，胜!&quot;</span>;<br>    <span class="hljs-comment">// 发送消息</span><br>    rabbitTemplate.convertAndSend(exchangeName, <span class="hljs-string">&quot;china.news&quot;</span>, message);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="消息接收-3"><a href="#消息接收-3" class="headerlink" title="消息接收"></a>消息接收</h3><p>在consumer服务的SpringRabbitListener中添加方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RabbitListener(bindings = @QueueBinding(</span><br><span class="hljs-meta">    value = @Queue(name = &quot;topic.queue1&quot;),</span><br><span class="hljs-meta">    exchange = @Exchange(name = &quot;itcast.topic&quot;, type = ExchangeTypes.TOPIC),</span><br><span class="hljs-meta">    key = &quot;china.#&quot;</span><br><span class="hljs-meta">))</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenTopicQueue1</span><span class="hljs-params">(String msg)</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;消费者接收到topic.queue1的消息：【&quot;</span> + msg + <span class="hljs-string">&quot;】&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">@RabbitListener(bindings = @QueueBinding(</span><br><span class="hljs-meta">    value = @Queue(name = &quot;topic.queue2&quot;),</span><br><span class="hljs-meta">    exchange = @Exchange(name = &quot;itcast.topic&quot;, type = ExchangeTypes.TOPIC),</span><br><span class="hljs-meta">    key = &quot;#.news&quot;</span><br><span class="hljs-meta">))</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenTopicQueue2</span><span class="hljs-params">(String msg)</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;消费者接收到topic.queue2的消息：【&quot;</span> + msg + <span class="hljs-string">&quot;】&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>描述下Direct交换机与Topic交换机的差异？</p><ul><li>Topic交换机接收的消息RoutingKey必须是多个单词，以 <code>**.**</code> 分割</li><li>Topic交换机与队列绑定时的bindingKey可以指定通配符</li><li><code>#</code>：代表0个或多个词</li><li><code>*</code>：代表1个词</li></ul><h2 id="消息转换器"><a href="#消息转换器" class="headerlink" title="消息转换器"></a>消息转换器</h2><p>之前说过，Spring会<strong>把你发送的消息序列化为字节</strong>发送给MQ，接收消息的时候，还会把字节反序列化为Java对象。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191307596.png"></p><p>只不过，默认情况下Spring采用的序列化方式是JDK序列化。众所周知，JDK序列化存在下列问题：</p><ul><li>数据体积过大</li><li>有安全漏洞</li><li>可读性差</li></ul><p>我们来测试一下。</p><h3 id="测试默认转换器"><a href="#测试默认转换器" class="headerlink" title="测试默认转换器"></a>测试默认转换器</h3><p>我们修改消息发送的代码，发送一个Map对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSendMap</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-comment">// 准备消息</span><br>    Map&lt;String,Object&gt; msg = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    msg.put(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Jack&quot;</span>);<br>    msg.put(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">21</span>);<br>    <span class="hljs-comment">// 发送消息</span><br>    rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;simple.queue&quot;</span>,<span class="hljs-string">&quot;&quot;</span>, msg);<br>&#125;<br></code></pre></td></tr></table></figure><p>停止consumer服务</p><p>发送消息后查看控制台：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191308778.png"></p><h3 id="配置JSON转换器"><a href="#配置JSON转换器" class="headerlink" title="配置JSON转换器"></a>配置JSON转换器</h3><p>显然，JDK序列化方式并不合适。我们希望消息体的体积更小、可读性更高，因此可以使用JSON方式来做序列化和反序列化。</p><p>在publisher和consumer两个服务中都引入依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pom">&lt;dependency&gt;<br>    &lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt;<br>    &lt;artifactId&gt;jackson-dataformat-xml&lt;/artifactId&gt;<br>    &lt;version&gt;2.9.10&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><p>配置消息转换器。</p><p>在启动类中添加一个Bean即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> MessageConverter <span class="hljs-title function_">jsonMessageConverter</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jackson2JsonMessageConverter</span>();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AMQP</tag>
      
      <tag>rabbitMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通关微服务-gateway</title>
    <link href="/posts/4d88743d/"/>
    <url>/posts/4d88743d/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Spring Cloud Gateway 是 Spring Cloud 的一个全新项目，该项目是基于 Spring 5.0，Spring Boot 2.0 和 Project Reactor 等响应式编程和事件流技术开发的网关，它旨在为微服务架构提供一种简单有效的统一的 API 路由管理方式。</p></blockquote><hr><h1 id="为什么需要网关"><a href="#为什么需要网关" class="headerlink" title="为什么需要网关"></a>为什么需要网关</h1><p>Gateway网关是我们服务的守门神，所有微服务的统一入口。</p><p>网关的<strong>核心功能特性</strong>：</p><ul><li>请求路由</li><li>权限控制</li><li>限流</li></ul><p>架构图：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403190959597.png"></p><p><strong>权限控制</strong>：网关作为微服务入口，需要校验用户是是否有请求资格，如果没有则进行拦截。</p><p><strong>路由和负载均衡</strong>：一切请求都必须先经过gateway，但网关不处理业务，而是根据某种规则，把请求转发到某个微服务，这个过程叫做路由。当然路由的目标服务有多个时，还需要做负载均衡。</p><p><strong>限流</strong>：当请求流量过高时，在网关中按照下流的微服务能够接受的速度来放行请求，避免服务压力过大。</p><p>在SpringCloud中网关的实现包括两种：</p><ul><li>gateway</li><li>zuul</li></ul><p>Zuul是基于Servlet的实现，属于<strong>阻塞式编程</strong>。而SpringCloudGateway则是基于Spring5中提供的WebFlux，属于<strong>响应式编程</strong>的实现，具备更好的性能。</p><h1 id="gateway快速入门"><a href="#gateway快速入门" class="headerlink" title="gateway快速入门"></a>gateway快速入门</h1><p>下面，我们就演示下网关的基本路由功能。基本步骤如下：</p><ol><li>创建SpringBoot工程gateway，引入网关依赖</li><li>编写启动类</li><li>编写基础配置和路由规则</li><li>启动网关服务进行测试</li></ol><h2 id="创建gateway服务"><a href="#创建gateway服务" class="headerlink" title="创建gateway服务"></a>创建gateway服务</h2><p>创建服务：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191000330.png"></p><p>引入依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pom">&lt;!--网关--&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br>&lt;!--nacos服务发现依赖--&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><h2 id="编写启动类"><a href="#编写启动类" class="headerlink" title="编写启动类"></a>编写启动类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.gateway;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GatewayApplication</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>SpringApplication.run(GatewayApplication.class, args);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="编写基础配置-amp-路由规则"><a href="#编写基础配置-amp-路由规则" class="headerlink" title="编写基础配置&amp;路由规则"></a>编写基础配置&amp;路由规则</h2><p>创建application.yml文件，内容如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">10010</span> <span class="hljs-comment"># 网关端口</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">gateway</span> <span class="hljs-comment"># 服务名称</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span> <span class="hljs-comment"># nacos地址</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span> <span class="hljs-comment"># 网关路由配置</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">user-service</span> <span class="hljs-comment"># 路由id，自定义，只要唯一即可</span><br>          <span class="hljs-comment"># uri: http://127.0.0.1:8081 # 路由的目标地址 http就是固定地址</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://userservice</span> <span class="hljs-comment"># 路由的目标地址 lb就是负载均衡，后面跟服务名称</span><br>          <span class="hljs-attr">predicates:</span> <span class="hljs-comment"># 路由断言，也就是判断请求是否符合路由规则的条件</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/user/**</span> <span class="hljs-comment"># 这个是按照路径匹配，只要以/user/开头就符合要求</span><br></code></pre></td></tr></table></figure><p>我们将符合<code>Path</code> 规则的一切请求，都代理到 <code>uri</code>参数指定的地址。</p><p>本例中，我们将 <code>/user/**</code>开头的请求，代理到<code>lb://userservice</code>，lb是负载均衡，根据服务名拉取服务列表，实现负载均衡。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>重启网关，访问<a href="http://localhost:10010/user/1">http://localhost:10010/user/1</a>时，符合<code>/user/**</code>规则，请求转发到uri：<a href="http://userservice/user/1">http://userservice/user/1</a>，得到了结果：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191211148.png"></p><h2 id="网关路由流程图"><a href="#网关路由流程图" class="headerlink" title="网关路由流程图"></a>网关路由流程图</h2><p>整个访问的流程如下：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191212861.png"></p><p>总结：</p><p>网关搭建步骤：</p><ol><li>创建项目，引入nacos服务发现和gateway依赖</li><li>配置application.yml，包括服务基本信息、nacos地址、路由</li></ol><p>路由配置包括：</p><ol><li>路由id：路由的唯一标示</li><li>路由目标（uri）：路由的目标地址，http代表固定地址，lb代表根据服务名负载均衡</li><li>路由断言（predicates）：判断路由的规则，</li><li>路由过滤器（filters）：对请求或响应做处理</li></ol><h1 id="断言工厂"><a href="#断言工厂" class="headerlink" title="断言工厂"></a>断言工厂</h1><p>在配置文件中写的断言规则只是字符串，这些字符串会被Predicate Factory读取并处理，转变为路由判断的条件</p><p>例如Path&#x3D;&#x2F;user&#x2F;**是按照路径匹配，这个规则是由</p><p><code>org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory</code>类来</p><p>处理的，像这样的断言工厂在SpringCloudGateway还有十几个:</p><table><thead><tr><th><strong>名称</strong></th><th><strong>说明</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td>After</td><td>是某个时间点后的请求</td><td>- After&#x3D;2037-01-20T17:42:47.789-07:00[America&#x2F;Denver]</td></tr><tr><td>Before</td><td>是某个时间点之前的请求</td><td>- Before&#x3D;2031-04-13T15:14:47.433+08:00[Asia&#x2F;Shanghai]</td></tr><tr><td>Between</td><td>是某两个时间点之前的请求</td><td>- Between&#x3D;2037-01-20T17:42:47.789-07:00[America&#x2F;Denver], 2037-01-21T17:42:47.789-07:00[America&#x2F;Denver]</td></tr><tr><td>Cookie</td><td>请求必须包含某些cookie</td><td>- Cookie&#x3D;chocolate, ch.p</td></tr><tr><td>Header</td><td>请求必须包含某些header</td><td>- Header&#x3D;X-Request-Id, \d+</td></tr><tr><td>Host</td><td>请求必须是访问某个host（域名）</td><td>- Host&#x3D;<strong>.somehost.org,</strong>.anotherhost.org</td></tr><tr><td>Method</td><td>请求方式必须是指定方式</td><td>- Method&#x3D;GET,POST</td></tr><tr><td>Path</td><td>请求路径必须符合指定规则</td><td>- Path&#x3D;&#x2F;red&#x2F;{segment},&#x2F;blue&#x2F;</td></tr><tr><td>Query</td><td>请求参数必须包含指定参数</td><td>- Query&#x3D;name, Jack或者- Query&#x3D;name</td></tr><tr><td>RemoteAddr</td><td>请求者的ip必须是指定范围</td><td>- RemoteAddr&#x3D;192.168.1.1&#x2F;24</td></tr><tr><td>Weight</td><td>权重处理</td><td></td></tr></tbody></table><p>只需要掌握Path这种路由工程就可以了</p><h1 id="过滤器工厂"><a href="#过滤器工厂" class="headerlink" title="过滤器工厂"></a>过滤器工厂</h1><p>GatewayFilter是网关中提供的一种过滤器，可以对进入网关的请求和微服务返回的响应做处理：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191214198.png"></p><h2 id="路由过滤器种类"><a href="#路由过滤器种类" class="headerlink" title="路由过滤器种类"></a>路由过滤器种类</h2><p>Spring提供了31种不同的路由过滤器工厂。例如：</p><table><thead><tr><th><strong>名称</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>AddRequestHeader</td><td>给当前请求添加一个请求头</td></tr><tr><td>RemoveRequestHeader</td><td>移除请求中的一个请求头</td></tr><tr><td>AddResponseHeader</td><td>给响应结果中添加一个响应头</td></tr><tr><td>RemoveResponseHeader</td><td>从响应结果中移除有一个响应头</td></tr><tr><td>RequestRateLimiter</td><td>限制请求的流量</td></tr></tbody></table><h2 id="请求头过滤器"><a href="#请求头过滤器" class="headerlink" title="请求头过滤器"></a>请求头过滤器</h2><p>下面我们以AddRequestHeader 为例来讲解。</p><blockquote><p><strong>需求</strong>：给所有进入userservice的请求添加一个请求头：Truth&#x3D;itcast is freaking awesome!</p></blockquote><p>只需要修改gateway服务的application.yml文件，添加路由过滤即可：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">user-service</span> <br>        <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://userservice</span> <br>        <span class="hljs-attr">predicates:</span> <br>        <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/user/**</span> <br>        <span class="hljs-attr">filters:</span> <span class="hljs-comment"># 过滤器</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">AddRequestHeader=Truth,</span> <span class="hljs-string">Itcast</span> <span class="hljs-string">is</span> <span class="hljs-string">freaking</span> <span class="hljs-string">awesome!</span> <span class="hljs-comment"># 添加请求头</span><br></code></pre></td></tr></table></figure><p>当前过滤器写在userservice路由下，因此仅仅对访问userservice的请求有效。</p><h2 id="默认过滤器"><a href="#默认过滤器" class="headerlink" title="默认过滤器"></a>默认过滤器</h2><p>如果要对所有的路由都生效，则可以将过滤器工厂写到default下。格式如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">user-service</span> <br>        <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://userservice</span> <br>        <span class="hljs-attr">predicates:</span> <br>        <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/user/**</span><br>      <span class="hljs-attr">default-filters:</span> <span class="hljs-comment"># 默认过滤项</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">AddRequestHeader=Truth,</span> <span class="hljs-string">Itcast</span> <span class="hljs-string">is</span> <span class="hljs-string">freaking</span> <span class="hljs-string">awesome!</span> <br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>过滤器的作用是什么？</p><p>① 对路由的请求或响应做加工处理，比如添加请求头<br>② 配置在路由下的过滤器只对当前路由的请求生效</p><p>defaultFilters的作用是什么？<br>对所有路由都生效的过滤器</p><h1 id="全局过滤器"><a href="#全局过滤器" class="headerlink" title="全局过滤器"></a>全局过滤器</h1><p>上一节的过滤器，网关提供了31种，但每一种过滤器的作用都是固定的。如果我们希望拦截请求，做自己的业务逻辑则没办法实现。</p><h2 id="全局过滤器作用"><a href="#全局过滤器作用" class="headerlink" title="全局过滤器作用"></a>全局过滤器作用</h2><p>全局过滤器的作用也是处理一切进入网关的请求和微服务响应，与GatewayFilter的作用一样。区别在于GatewayFilter通过配置定义，处理逻辑是固定的；而GlobalFilter的逻辑需要自己写代码实现。</p><p>定义方式是实现GlobalFilter接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">GlobalFilter</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *  处理当前请求，有必要的话通过&#123;<span class="hljs-doctag">@link</span> GatewayFilterChain&#125;将请求交给下一个过滤器处理</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> exchange 请求上下文，里面可以获取Request、Response等信息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> chain 用来把请求委托给下一个过滤器 </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-doctag">@code</span> Mono&lt;Void&gt;&#125; 返回标示当前过滤器业务结束</span><br><span class="hljs-comment">     */</span><br>    Mono&lt;Void&gt; <span class="hljs-title function_">filter</span><span class="hljs-params">(ServerWebExchange exchange, GatewayFilterChain chain)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在filter中编写自定义逻辑，可以实现下列功能：</p><ul><li>登录状态判断</li><li>权限校验</li><li>请求限流等</li></ul><h2 id="自定义全局过滤器"><a href="#自定义全局过滤器" class="headerlink" title="自定义全局过滤器"></a>自定义全局过滤器</h2><p>需求：定义全局过滤器，拦截请求，判断请求的参数是否满足下面条件：</p><ul><li>参数中是否有authorization，</li><li>authorization参数值是否为admin</li></ul><p>如果同时满足则放行，否则拦截</p><p>实现：</p><p>在gateway中定义一个过滤器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.gateway.filters;<br><br><span class="hljs-keyword">import</span> org.springframework.cloud.gateway.filter.GatewayFilterChain;<br><span class="hljs-keyword">import</span> org.springframework.cloud.gateway.filter.GlobalFilter;<br><span class="hljs-keyword">import</span> org.springframework.core.annotation.Order;<br><span class="hljs-keyword">import</span> org.springframework.http.HttpStatus;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-keyword">import</span> org.springframework.web.server.ServerWebExchange;<br><span class="hljs-keyword">import</span> reactor.core.publisher.Mono;<br><br><span class="hljs-meta">@Order(-1)</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AuthorizeFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">GlobalFilter</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title function_">filter</span><span class="hljs-params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;<br>        <span class="hljs-comment">// 1.获取请求参数</span><br>        MultiValueMap&lt;String, String&gt; params = exchange.getRequest().getQueryParams();<br>        <span class="hljs-comment">// 2.获取authorization参数</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">auth</span> <span class="hljs-operator">=</span> params.getFirst(<span class="hljs-string">&quot;authorization&quot;</span>);<br>        <span class="hljs-comment">// 3.校验</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;admin&quot;</span>.equals(auth)) &#123;<br>            <span class="hljs-comment">// 放行</span><br>            <span class="hljs-keyword">return</span> chain.filter(exchange);<br>        &#125;<br>        <span class="hljs-comment">// 4.拦截</span><br>        <span class="hljs-comment">// 4.1.禁止访问，设置状态码</span><br>        exchange.getResponse().setStatusCode(HttpStatus.FORBIDDEN);<br>        <span class="hljs-comment">// 4.2.结束处理</span><br>        <span class="hljs-keyword">return</span> exchange.getResponse().setComplete();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="过滤器执行顺序"><a href="#过滤器执行顺序" class="headerlink" title="过滤器执行顺序"></a>过滤器执行顺序</h2><p>请求进入网关会碰到三类过滤器：当前路由的过滤器、DefaultFilter、GlobalFilter</p><p>请求路由后，会将当前路由过滤器和DefaultFilter、GlobalFilter，合并到一个过滤器链（集合）中，排序后依次执行每个过滤器：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403191217433.png"></p><p>排序的规则是什么呢？</p><ul><li>每一个过滤器都必须指定一个int类型的order值，<strong>order值越小，优先级越高，执行顺序越靠前</strong>。</li><li>GlobalFilter通过实现Ordered接口，或者添加@Order注解来指定order值，由我们自己指定</li><li>路由过滤器和defaultFilter的order由Spring指定，默认是按照声明顺序从1递增。</li><li>当过滤器的order值一样时，会按照 defaultFilter &gt; 路由过滤器 &gt; GlobalFilter的顺序执行。</li></ul><p>详细内容，可以查看源码：</p><p><code>org.springframework.cloud.gateway.route.RouteDefinitionRouteLocator#getFilters()</code>方法是先加载defaultFilters，然后再加载某个route的filters，然后合并。</p><p><code>org.springframework.cloud.gateway.handler.FilteringWebHandler#handle()</code>方法会加载全局过滤器，与前面的过滤器合并后根据order排序，组织过滤器链</p><h1 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h1><h2 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h2><p>跨域：域名不一致就是跨域，主要包括：</p><ul><li>域名不同： <a href="www.taobao.com">www.taobao.com</a> 和 <a href="www.taobao.org">www.taobao.org</a> 和 <a href="www.jd.com">www.jd.com</a> 和 miaosha.jd.com</li><li>域名相同，端口不同：localhost:8080和localhost8081</li></ul><p>跨域问题：浏览器禁止请求的发起者与服务端发生跨域ajax请求，请求被浏览器拦截的问题</p><p>解决方案：CORS，这里不再赘述了。</p><h2 id="解决跨域问题"><a href="#解决跨域问题" class="headerlink" title="解决跨域问题"></a>解决跨域问题</h2><p>在gateway服务的application.yml文件中，添加下面的配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-comment"># 。。。</span><br>      <span class="hljs-attr">globalcors:</span> <span class="hljs-comment"># 全局的跨域处理</span><br>        <span class="hljs-attr">add-to-simple-url-handler-mapping:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 解决options请求被拦截问题</span><br>        <span class="hljs-attr">corsConfigurations:</span><br>          <span class="hljs-string">&#x27;[/**]&#x27;</span><span class="hljs-string">:</span><br>            <span class="hljs-attr">allowedOrigins:</span> <span class="hljs-comment"># 允许哪些网站的跨域请求 </span><br>              <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;http://localhost:8090&quot;</span><br>            <span class="hljs-attr">allowedMethods:</span> <span class="hljs-comment"># 允许的跨域ajax的请求方式</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;GET&quot;</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;POST&quot;</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;DELETE&quot;</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;PUT&quot;</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;OPTIONS&quot;</span><br>            <span class="hljs-attr">allowedHeaders:</span> <span class="hljs-string">&quot;*&quot;</span> <span class="hljs-comment"># 允许在请求中携带的头信息</span><br>            <span class="hljs-attr">allowCredentials:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 是否允许携带cookie</span><br>            <span class="hljs-attr">maxAge:</span> <span class="hljs-number">360000</span> <span class="hljs-comment"># 这次跨域检测的有效期</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>gateway</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通关微服务-nacos</title>
    <link href="/posts/2c2c4e78/"/>
    <url>/posts/2c2c4e78/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Nacos是spring cloud中的一个组件，它的功能非常强大，可以看到它提供了服务的注册和发现、以及分布式配置等功能。相对于Eureka更强大，也更受欢迎。是微服务开发中必不可少的一个组件。</p></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403181718128.png"></p><hr><h1 id="Nacos安装指南"><a href="#Nacos安装指南" class="headerlink" title="Nacos安装指南"></a>Nacos安装指南</h1><h2 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h2><p>开发阶段采用单机安装即可。</p><p>在Nacos的GitHub页面，提供有下载链接，可以下载编译好的Nacos服务端或者源代码：</p><p>GitHub主页：<a href="https://github.com/alibaba/nacos">https://github.com/alibaba/nacos</a></p><p>GitHub的Release下载页：<a href="https://github.com/alibaba/nacos/releases">https://github.com/alibaba/nacos/releases</a></p><p>如图：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403181725428.png"></p><p>这里采用1.4.1.版本的Nacos，windows版本使用<code>nacos-server-1.4.1.zip</code>包即可。</p><h2 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h2><p>将这个包解压到任意非中文目录下，如图：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403181726806.png"></p><p>目录说明：</p><ul><li>bin：启动脚本</li><li>conf：配置文件</li></ul><h2 id="端口配置"><a href="#端口配置" class="headerlink" title="端口配置"></a>端口配置</h2><p>Nacos的默认端口是8848，如果你电脑上的其它进程占用了8848端口，请先尝试关闭该进程。</p><p><strong>如果无法关闭占用8848端口的进程</strong>，也可以进入nacos的conf目录，修改配置文件中的端口：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403181727808.png"></p><p>修改其中的内容：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403181727382.png"></p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>启动非常简单，进入bin目录，结构如下：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403181727621.png"></p><p>然后执行命令即可：</p><ul><li>windows命令：<br>  startup.cmd -m standalone</li></ul><p>执行后的效果如图：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403181728681.png"></p><h2 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h2><p>在浏览器输入地址：<a href="http://127.0.0.1:8848/nacos">http://127.0.0.1:8848/nacos</a>即可：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403181728109.png"></p><p>默认的账号和密码都是nacos，进入后：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403181728185.png"></p><p>说明启动成功。</p><h1 id="Nacos服务注册和发现"><a href="#Nacos服务注册和发现" class="headerlink" title="Nacos服务注册和发现"></a>Nacos服务注册和发现</h1><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><p>Nacos是SpringCloudAlibaba的组件，而SpringCloudAlibaba也遵循SpringCloud中定义的服务注册、服务发现规范。因此使用Nacos和使用Eureka对于微服务来说，并没有太大区别。</p><p>主要差异在于：</p><ul><li>依赖不同</li><li>服务地址不同</li></ul><p>在cloud-demo父工程的pom文件中的<code>&lt;dependencyManagement&gt;</code>中引入<code>SpringCloudAlibaba</code>的依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pom">&lt;dependency&gt;<br>    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;<br>    &lt;version&gt;2.2.6.RELEASE&lt;/version&gt;<br>    &lt;type&gt;pom&lt;/type&gt;<br>    &lt;scope&gt;import&lt;/scope&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><p>然后在user-service和order-service中的pom文件中引入<code>nacos-discovery</code>依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pom">&lt;dependency&gt;<br>    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><h2 id="配置nacos地址"><a href="#配置nacos地址" class="headerlink" title="配置nacos地址"></a>配置nacos地址</h2><p>在user-service和order-service的application.yml中添加nacos地址：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br></code></pre></td></tr></table></figure><h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><p>登录nacos管理页面，可以看到微服务信息。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403181734915.png"></p><h1 id="Nacos服务分级存储模型"><a href="#Nacos服务分级存储模型" class="headerlink" title="Nacos服务分级存储模型"></a>Nacos服务分级存储模型</h1><p>一个<strong>服务</strong>可以有多个<strong>实例</strong>，例如我们的user-service，可以有:</p><ul><li>127.0.0.1:8081</li><li>127.0.0.1:8082</li><li>127.0.0.1:8083</li></ul><p>假如这些实例分布于全国各地的不同机房，例如：</p><ul><li>127.0.0.1:8081，在上海机房</li><li>127.0.0.1:8082，在上海机房</li><li>127.0.0.1:8083，在杭州机房</li></ul><p>Nacos就将同一机房内的实例 划分为一个<strong>集群</strong>。</p><p>也就是说，user-service是服务，一个服务可以包含多个集群，如杭州、上海，每个集群下可以有多个实例，形成分级模型，如图：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403181736782.png"></p><p>微服务互相访问时，应该尽可能访问<strong>同集群</strong>实例，因为本地访问速度更快。当本集群内不可用时，才访问其它集群。例如：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403181736038.png"></p><h2 id="配置集群"><a href="#配置集群" class="headerlink" title="配置集群"></a>配置集群</h2><p>修改user-service的application.yml文件，添加集群配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">cluster-name:</span> <span class="hljs-string">HZ</span> <span class="hljs-comment"># 集群名称</span><br></code></pre></td></tr></table></figure><p>重启两个user-service实例后，我们可以在nacos控制台看到下面结果：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403181737593.png"></p><p>我们再次复制一个user-service启动配置，添加属性：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">-Dserver.<span class="hljs-attribute">port</span>=8083 -Dspring.cloud.nacos.discovery.<span class="hljs-attribute">cluster-name</span>=SH<br></code></pre></td></tr></table></figure><p>配置如图所示：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403181738115.png"></p><p>启动UserApplication3后再次查看nacos控制台：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403181739548.png"></p><h2 id="负载均衡配置"><a href="#负载均衡配置" class="headerlink" title="负载均衡配置"></a>负载均衡配置</h2><p>默认的<code>ZoneAvoidanceRule</code>并不能实现根据同集群优先来实现负载均衡。</p><p>因此Nacos中提供了一个<code>NacosRule</code>的实现，可以优先从同集群中挑选实例。</p><p>1）给order-service配置集群信息</p><p>修改order-service的application.yml文件，添加集群配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">cluster-name:</span> <span class="hljs-string">HZ</span> <span class="hljs-comment"># 集群名称</span><br></code></pre></td></tr></table></figure><p>2）修改负载均衡规则</p><p>修改order-service的application.yml文件，修改负载均衡规则：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">userservice:</span><br>  <span class="hljs-attr">ribbon:</span><br>    <span class="hljs-attr">NFLoadBalancerRuleClassName:</span> <span class="hljs-string">com.alibaba.cloud.nacos.ribbon.NacosRule</span> <span class="hljs-comment"># 负载均衡规则</span><br></code></pre></td></tr></table></figure><h1 id="权重配置"><a href="#权重配置" class="headerlink" title="权重配置"></a>权重配置</h1><p>实际部署中会出现这样的场景：</p><p>服务器设备性能有差异，部分实例所在机器性能较好，另一些较差，我们希望性能好的机器承担更多的用户请求。</p><p>但默认情况下NacosRule是同集群内随机挑选，不会考虑机器的性能问题。</p><p>因此，Nacos提供了权重配置来控制访问频率，权重越大则访问频率越高。</p><p>在nacos控制台，找到user-service的实例列表，点击编辑，即可修改权重：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403181741376.png"></p><p>在弹出的编辑窗口，修改权重：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403181741663.png"></p><p><strong>注意</strong>：如果权重修改为0，则该实例永远不会被访问。可以用此特性做一些临时操作。</p><h1 id="环境隔离"><a href="#环境隔离" class="headerlink" title="环境隔离"></a>环境隔离</h1><p>Nacos提供了namespace来实现环境隔离功能。</p><ul><li>nacos中可以有多个namespace</li><li>namespace下可以有group、service等</li><li>不同namespace之间相互隔离，例如不同namespace的服务互相不可见</li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403181742906.png"></p><h2 id="创建namespace"><a href="#创建namespace" class="headerlink" title="创建namespace"></a>创建namespace</h2><p>默认情况下，所有service、data、group都在同一个namespace，名为public：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403181743632.png"></p><p>我们可以点击页面新增按钮，添加一个namespace：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403181743218.png"></p><p>然后，填写表单：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403181743779.png"></p><p>就能在页面看到一个新的namespace：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403181744709.png"></p><h2 id="给微服务配置namespace"><a href="#给微服务配置namespace" class="headerlink" title="给微服务配置namespace"></a>给微服务配置namespace</h2><p>给微服务配置namespace只能通过修改配置来实现。</p><p>例如，修改order-service的application.yml文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">cluster-name:</span> <span class="hljs-string">HZ</span><br>        <span class="hljs-attr">namespace:</span> <span class="hljs-string">492a7d5d-237b-46a1-a99a-fa8e98e4b0f9</span> <span class="hljs-comment"># 命名空间，填ID</span><br></code></pre></td></tr></table></figure><p>重启order-service后，访问控制台，可以看到下面的结果：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403181744730.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403181744805.png"></p><p>此时访问order-service，因为namespace不同，会导致找不到userservice，控制台会报错：</p><h1 id="Nacos和Eureka的区别"><a href="#Nacos和Eureka的区别" class="headerlink" title="Nacos和Eureka的区别"></a>Nacos和Eureka的区别</h1><p>Nacos的服务实例分为两种l类型：</p><ul><li>临时实例：如果实例宕机超过一定时间，会从服务列表剔除，<strong>默认的类型</strong>。</li><li>非临时实例：如果实例宕机，不会从服务列表剔除，也可以叫<strong>永久实例</strong>。</li></ul><p>配置一个服务实例为永久实例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">ephemeral:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 设置为非临时实例</span><br></code></pre></td></tr></table></figure><p>Nacos和Eureka整体结构类似，服务注册、服务拉取、心跳等待，但是也存在一些差异：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403181746288.png"></p><ul><li>Nacos与eureka的共同点<ul><li>都支持服务注册和服务拉取</li><li>都支持服务提供者心跳方式做健康检测</li></ul></li><li>Nacos与Eureka的区别<ul><li>Nacos支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式</li><li>临时实例心跳不正常会被剔除，非临时实例则不会被剔除</li><li>Nacos支持服务列表变更的消息推送模式，服务列表更新更及时</li><li>Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式；Eureka采用AP方式</li></ul></li></ul><h1 id="Nacos配置管理"><a href="#Nacos配置管理" class="headerlink" title="Nacos配置管理"></a>Nacos配置管理</h1><p>Nacos除了可以做注册中心，同样可以做配置管理来使用。</p><h2 id="统一配置管理"><a href="#统一配置管理" class="headerlink" title="统一配置管理"></a>统一配置管理</h2><p>当微服务部署的实例越来越多，达到数十、数百时，逐个修改微服务配置就会让人抓狂，而且很容易出错。我们需要一种统一配置管理方案，可以集中管理所有实例的配置。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403181752911.png"></p><p>Nacos一方面可以将配置集中管理，另一方可以在配置变更时，及时通知微服务，实现配置的热更新。</p><h3 id="在nacos中添加配置文件"><a href="#在nacos中添加配置文件" class="headerlink" title="在nacos中添加配置文件"></a>在nacos中添加配置文件</h3><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403181753067.png"></p><p>然后在弹出的表单中，填写配置信息：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403181753568.png"></p><blockquote><p>注意：项目的核心配置，需要热更新的配置才有放到nacos管理的必要。基本不会变更的一些配置还是保存在微服务本地比较好。</p></blockquote><h3 id="拉取配置"><a href="#拉取配置" class="headerlink" title="拉取配置"></a>拉取配置</h3><p>微服务要拉取nacos中管理的配置，并且与本地的application.yml配置合并，才能完成项目启动。</p><p>但如果尚未读取application.yml，又如何得知nacos地址呢？</p><p>因此spring引入了一种新的配置文件：<code>bootstrap.yaml</code>文件，会在<code>application.yml</code><strong>之前被读取</strong>，流程如下：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403181755052.png"></p><p>1）引入nacos-config依赖</p><p>首先，在user-service服务中，引入nacos-config的客户端依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pom">&lt;!--nacos配置管理依赖--&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><p>2）添加bootstrap.yaml</p><p>然后，在user-service中添加一个bootstrap.yaml文件，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">userservice</span> <span class="hljs-comment"># 服务名称</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span> <span class="hljs-comment">#开发环境，这里是dev </span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span> <span class="hljs-comment"># Nacos地址</span><br>      <span class="hljs-attr">config:</span><br>        <span class="hljs-attr">file-extension:</span> <span class="hljs-string">yaml</span> <span class="hljs-comment"># 文件后缀名</span><br></code></pre></td></tr></table></figure><p><code>$&#123;spring.application.name&#125;-$&#123;spring.profiles.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</code>作为文件id，来读取配置。</p><p>本例中，就是去读取<code>userservice-dev.yaml</code>：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403181757971.png"></p><p>3）读取nacos配置</p><p>在user-service中的UserController中添加业务逻辑，读取pattern.dateformat配置：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403181757265.png"></p><p>完整代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.user.web;<br><br><span class="hljs-keyword">import</span> cn.itcast.user.pojo.User;<br><span class="hljs-keyword">import</span> cn.itcast.user.service.UserService;<br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.*;<br><br><span class="hljs-keyword">import</span> java.time.LocalDateTime;<br><span class="hljs-keyword">import</span> java.time.format.DateTimeFormatter;<br><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/user&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserService userService;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;pattern.dateformat&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String dateformat;<br>    <br>    <span class="hljs-meta">@GetMapping(&quot;now&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">now</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> LocalDateTime.now().format(DateTimeFormatter.ofPattern(dateformat));<br>    &#125;<br>    <span class="hljs-comment">// ...略</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在页面访问，可以看到效果：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403181758519.png"></p><h2 id="热更新"><a href="#热更新" class="headerlink" title="热更新"></a>热更新</h2><p>我们最终的目的，是修改nacos中的配置后，微服务中<strong>无需重启即可让配置生效</strong>，也就是<strong>配置热更新</strong>。</p><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><p>在@Value注入的变量所在类上添加注解@RefreshScope：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403181800287.png"></p><h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><p>使用@ConfigurationProperties注解代替@Value注解。</p><p>在user-service服务中，添加一个类，读取patterrn.dateformat属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.user.config;<br><br><span class="hljs-keyword">import</span> lombok.Data;<br><span class="hljs-keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;pattern&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PatternProperties</span> &#123;<br>    <span class="hljs-keyword">private</span> String dateformat;<br>&#125;<br></code></pre></td></tr></table></figure><p>在UserController中使用这个类代替@Value：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403181801064.png"></p><p>完整代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.user.web;<br><br><span class="hljs-keyword">import</span> cn.itcast.user.config.PatternProperties;<br><span class="hljs-keyword">import</span> cn.itcast.user.pojo.User;<br><span class="hljs-keyword">import</span> cn.itcast.user.service.UserService;<br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PathVariable;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><br><span class="hljs-keyword">import</span> java.time.LocalDateTime;<br><span class="hljs-keyword">import</span> java.time.format.DateTimeFormatter;<br><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/user&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserService userService;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> PatternProperties patternProperties;<br><br>    <span class="hljs-meta">@GetMapping(&quot;now&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">now</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> LocalDateTime.now().format(DateTimeFormatter.ofPattern(patternProperties.getDateformat()));<br>    &#125;<br><br>    <span class="hljs-comment">// 略</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h2><p>其实微服务启动时，会去nacos读取多个配置文件，例如：</p><ul><li><code>[spring.application.name]-[spring.profiles.active].yaml</code>，例如：userservice-dev.yaml</li><li><code>[spring.application.name].yaml</code>，例如：userservice.yaml</li></ul><p>而<code>[spring.application.name].yaml</code>不包含环境，因此可以被多个环境共享。</p><p>下面我们通过案例来测试配置共享。</p><h3 id="添加一个环境共享配置"><a href="#添加一个环境共享配置" class="headerlink" title="添加一个环境共享配置"></a>添加一个环境共享配置</h3><p>我们在nacos中添加一个userservice.yaml文件：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403181802578.png"></p><h3 id="读取共享配置"><a href="#读取共享配置" class="headerlink" title="读取共享配置"></a>读取共享配置</h3><p>在user-service服务中，修改PatternProperties类，读取新添加的属性：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403181803302.png"></p><p>在user-service服务中，修改UserController，添加一个方法：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403181803355.png"></p><h3 id="运行两个User，使用不同的profile"><a href="#运行两个User，使用不同的profile" class="headerlink" title="运行两个User，使用不同的profile"></a>运行两个User，使用不同的profile</h3><p>修改UserApplication2这个启动项，改变其profile值：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403181804252.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403181804548.png"></p><p>这样，UserApplication(8081)使用的profile是dev，UserApplication2(8082)使用的profile是test。</p><p>启动UserApplication和UserApplication2</p><p>访问<a href="http://localhost:8081/user/prop">http://localhost:8081/user/prop</a>，结果：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403181805121.png"></p><p>访问<a href="http://localhost:8082/user/prop">http://localhost:8082/user/prop</a>，结果：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403181805483.png"></p><p>可以看出来，不管是dev，还是test环境，都读取到了envSharedValue这个属性的值。</p><h3 id="共享的优先级"><a href="#共享的优先级" class="headerlink" title="共享的优先级"></a>共享的优先级</h3><p>当nacos、服务本地同时出现相同属性时，优先级有高低之分：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403181806140.png"></p><h1 id="nacos集群"><a href="#nacos集群" class="headerlink" title="nacos集群"></a>nacos集群</h1><blockquote><p>Nacos生产环境下一定要部署为集群状态。</p></blockquote><p>集群结构图</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403181818585.png"></p><p>其中包含3个nacos节点，然后一个负载均衡器代理3个Nacos。这里负载均衡器可以使用nginx。这是官方给出的。不过一般工作中会有一个nginx做负载均衡。如下：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403181819566.png"></p><p>三个nacos节点的地址：</p><table><thead><tr><th>节点</th><th>ip</th><th>port</th></tr></thead><tbody><tr><td>nacos1</td><td>192.168.150.1</td><td>8845</td></tr><tr><td>nacos2</td><td>192.168.150.1</td><td>8846</td></tr><tr><td>nacos3</td><td>192.168.150.1</td><td>8847</td></tr></tbody></table><h2 id="搭建集群"><a href="#搭建集群" class="headerlink" title="搭建集群"></a>搭建集群</h2><p>搭建集群的基本步骤：</p><ul><li>搭建数据库，初始化数据库表结构</li><li>下载nacos安装包</li><li>配置nacos</li><li>启动nacos集群</li><li>nginx反向代理</li></ul><h2 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h2><p>Nacos默认数据存储在内嵌数据库Derby中，不属于生产可用的数据库。</p><p>官方推荐的最佳实践是使用带有主从的高可用数据库集群。</p><p>这里我们以单点的数据库为例来讲解。</p><p>首先新建一个数据库，命名为nacos，而后导入下面的SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `config_info` (<br>  `id` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="hljs-string">&#x27;id&#x27;</span>,<br>  `data_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;data_id&#x27;</span>,<br>  `group_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `content` longtext <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;content&#x27;</span>,<br>  `md5` <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;md5&#x27;</span>,<br>  `gmt_create` datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">&#x27;创建时间&#x27;</span>,<br>  `gmt_modified` datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">&#x27;修改时间&#x27;</span>,<br>  `src_user` text COMMENT <span class="hljs-string">&#x27;source user&#x27;</span>,<br>  `src_ip` <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;source ip&#x27;</span>,<br>  `app_name` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `tenant_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span> COMMENT <span class="hljs-string">&#x27;租户字段&#x27;</span>,<br>  `c_desc` <span class="hljs-type">varchar</span>(<span class="hljs-number">256</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `c_use` <span class="hljs-type">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `effect` <span class="hljs-type">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `type` <span class="hljs-type">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `c_schema` text,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`),<br>  <span class="hljs-keyword">UNIQUE</span> KEY `uk_configinfo_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8 <span class="hljs-keyword">COLLATE</span><span class="hljs-operator">=</span>utf8_bin COMMENT<span class="hljs-operator">=</span><span class="hljs-string">&#x27;config_info&#x27;</span>;<br><br><span class="hljs-comment">/******************************************/</span><br><span class="hljs-comment">/*   数据库全名 = nacos_config   */</span><br><span class="hljs-comment">/*   表名称 = config_info_aggr   */</span><br><span class="hljs-comment">/******************************************/</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `config_info_aggr` (<br>  `id` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="hljs-string">&#x27;id&#x27;</span>,<br>  `data_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;data_id&#x27;</span>,<br>  `group_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;group_id&#x27;</span>,<br>  `datum_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;datum_id&#x27;</span>,<br>  `content` longtext <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;内容&#x27;</span>,<br>  `gmt_modified` datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;修改时间&#x27;</span>,<br>  `app_name` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `tenant_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span> COMMENT <span class="hljs-string">&#x27;租户字段&#x27;</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`),<br>  <span class="hljs-keyword">UNIQUE</span> KEY `uk_configinfoaggr_datagrouptenantdatum` (`data_id`,`group_id`,`tenant_id`,`datum_id`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8 <span class="hljs-keyword">COLLATE</span><span class="hljs-operator">=</span>utf8_bin COMMENT<span class="hljs-operator">=</span><span class="hljs-string">&#x27;增加租户字段&#x27;</span>;<br><br><br><span class="hljs-comment">/******************************************/</span><br><span class="hljs-comment">/*   数据库全名 = nacos_config   */</span><br><span class="hljs-comment">/*   表名称 = config_info_beta   */</span><br><span class="hljs-comment">/******************************************/</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `config_info_beta` (<br>  `id` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="hljs-string">&#x27;id&#x27;</span>,<br>  `data_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;data_id&#x27;</span>,<br>  `group_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;group_id&#x27;</span>,<br>  `app_name` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;app_name&#x27;</span>,<br>  `content` longtext <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;content&#x27;</span>,<br>  `beta_ips` <span class="hljs-type">varchar</span>(<span class="hljs-number">1024</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;betaIps&#x27;</span>,<br>  `md5` <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;md5&#x27;</span>,<br>  `gmt_create` datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">&#x27;创建时间&#x27;</span>,<br>  `gmt_modified` datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">&#x27;修改时间&#x27;</span>,<br>  `src_user` text COMMENT <span class="hljs-string">&#x27;source user&#x27;</span>,<br>  `src_ip` <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;source ip&#x27;</span>,<br>  `tenant_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span> COMMENT <span class="hljs-string">&#x27;租户字段&#x27;</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`),<br>  <span class="hljs-keyword">UNIQUE</span> KEY `uk_configinfobeta_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8 <span class="hljs-keyword">COLLATE</span><span class="hljs-operator">=</span>utf8_bin COMMENT<span class="hljs-operator">=</span><span class="hljs-string">&#x27;config_info_beta&#x27;</span>;<br><br><span class="hljs-comment">/******************************************/</span><br><span class="hljs-comment">/*   数据库全名 = nacos_config   */</span><br><span class="hljs-comment">/*   表名称 = config_info_tag   */</span><br><span class="hljs-comment">/******************************************/</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `config_info_tag` (<br>  `id` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="hljs-string">&#x27;id&#x27;</span>,<br>  `data_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;data_id&#x27;</span>,<br>  `group_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;group_id&#x27;</span>,<br>  `tenant_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span> COMMENT <span class="hljs-string">&#x27;tenant_id&#x27;</span>,<br>  `tag_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;tag_id&#x27;</span>,<br>  `app_name` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;app_name&#x27;</span>,<br>  `content` longtext <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;content&#x27;</span>,<br>  `md5` <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;md5&#x27;</span>,<br>  `gmt_create` datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">&#x27;创建时间&#x27;</span>,<br>  `gmt_modified` datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">&#x27;修改时间&#x27;</span>,<br>  `src_user` text COMMENT <span class="hljs-string">&#x27;source user&#x27;</span>,<br>  `src_ip` <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;source ip&#x27;</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`),<br>  <span class="hljs-keyword">UNIQUE</span> KEY `uk_configinfotag_datagrouptenanttag` (`data_id`,`group_id`,`tenant_id`,`tag_id`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8 <span class="hljs-keyword">COLLATE</span><span class="hljs-operator">=</span>utf8_bin COMMENT<span class="hljs-operator">=</span><span class="hljs-string">&#x27;config_info_tag&#x27;</span>;<br><br><span class="hljs-comment">/******************************************/</span><br><span class="hljs-comment">/*   数据库全名 = nacos_config   */</span><br><span class="hljs-comment">/*   表名称 = config_tags_relation   */</span><br><span class="hljs-comment">/******************************************/</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `config_tags_relation` (<br>  `id` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;id&#x27;</span>,<br>  `tag_name` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;tag_name&#x27;</span>,<br>  `tag_type` <span class="hljs-type">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;tag_type&#x27;</span>,<br>  `data_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;data_id&#x27;</span>,<br>  `group_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;group_id&#x27;</span>,<br>  `tenant_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span> COMMENT <span class="hljs-string">&#x27;tenant_id&#x27;</span>,<br>  `nid` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`nid`),<br>  <span class="hljs-keyword">UNIQUE</span> KEY `uk_configtagrelation_configidtag` (`id`,`tag_name`,`tag_type`),<br>  KEY `idx_tenant_id` (`tenant_id`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8 <span class="hljs-keyword">COLLATE</span><span class="hljs-operator">=</span>utf8_bin COMMENT<span class="hljs-operator">=</span><span class="hljs-string">&#x27;config_tag_relation&#x27;</span>;<br><br><span class="hljs-comment">/******************************************/</span><br><span class="hljs-comment">/*   数据库全名 = nacos_config   */</span><br><span class="hljs-comment">/*   表名称 = group_capacity   */</span><br><span class="hljs-comment">/******************************************/</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `group_capacity` (<br>  `id` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) unsigned <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="hljs-string">&#x27;主键ID&#x27;</span>,<br>  `group_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span> COMMENT <span class="hljs-string">&#x27;Group ID，空字符表示整个集群&#x27;</span>,<br>  `quota` <span class="hljs-type">int</span>(<span class="hljs-number">10</span>) unsigned <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span> COMMENT <span class="hljs-string">&#x27;配额，0表示使用默认值&#x27;</span>,<br>  `usage` <span class="hljs-type">int</span>(<span class="hljs-number">10</span>) unsigned <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span> COMMENT <span class="hljs-string">&#x27;使用量&#x27;</span>,<br>  `max_size` <span class="hljs-type">int</span>(<span class="hljs-number">10</span>) unsigned <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span> COMMENT <span class="hljs-string">&#x27;单个配置大小上限，单位为字节，0表示使用默认值&#x27;</span>,<br>  `max_aggr_count` <span class="hljs-type">int</span>(<span class="hljs-number">10</span>) unsigned <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span> COMMENT <span class="hljs-string">&#x27;聚合子配置最大个数，，0表示使用默认值&#x27;</span>,<br>  `max_aggr_size` <span class="hljs-type">int</span>(<span class="hljs-number">10</span>) unsigned <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span> COMMENT <span class="hljs-string">&#x27;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#x27;</span>,<br>  `max_history_count` <span class="hljs-type">int</span>(<span class="hljs-number">10</span>) unsigned <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span> COMMENT <span class="hljs-string">&#x27;最大变更历史数量&#x27;</span>,<br>  `gmt_create` datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">&#x27;创建时间&#x27;</span>,<br>  `gmt_modified` datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">&#x27;修改时间&#x27;</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`),<br>  <span class="hljs-keyword">UNIQUE</span> KEY `uk_group_id` (`group_id`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8 <span class="hljs-keyword">COLLATE</span><span class="hljs-operator">=</span>utf8_bin COMMENT<span class="hljs-operator">=</span><span class="hljs-string">&#x27;集群、各Group容量信息表&#x27;</span>;<br><br><span class="hljs-comment">/******************************************/</span><br><span class="hljs-comment">/*   数据库全名 = nacos_config   */</span><br><span class="hljs-comment">/*   表名称 = his_config_info   */</span><br><span class="hljs-comment">/******************************************/</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `his_config_info` (<br>  `id` <span class="hljs-type">bigint</span>(<span class="hljs-number">64</span>) unsigned <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `nid` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) unsigned <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  `data_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `group_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `app_name` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;app_name&#x27;</span>,<br>  `content` longtext <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `md5` <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `gmt_create` datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>,<br>  `gmt_modified` datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>,<br>  `src_user` text,<br>  `src_ip` <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `op_type` <span class="hljs-type">char</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `tenant_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span> COMMENT <span class="hljs-string">&#x27;租户字段&#x27;</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`nid`),<br>  KEY `idx_gmt_create` (`gmt_create`),<br>  KEY `idx_gmt_modified` (`gmt_modified`),<br>  KEY `idx_did` (`data_id`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8 <span class="hljs-keyword">COLLATE</span><span class="hljs-operator">=</span>utf8_bin COMMENT<span class="hljs-operator">=</span><span class="hljs-string">&#x27;多租户改造&#x27;</span>;<br><br><br><span class="hljs-comment">/******************************************/</span><br><span class="hljs-comment">/*   数据库全名 = nacos_config   */</span><br><span class="hljs-comment">/*   表名称 = tenant_capacity   */</span><br><span class="hljs-comment">/******************************************/</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `tenant_capacity` (<br>  `id` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) unsigned <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="hljs-string">&#x27;主键ID&#x27;</span>,<br>  `tenant_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span> COMMENT <span class="hljs-string">&#x27;Tenant ID&#x27;</span>,<br>  `quota` <span class="hljs-type">int</span>(<span class="hljs-number">10</span>) unsigned <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span> COMMENT <span class="hljs-string">&#x27;配额，0表示使用默认值&#x27;</span>,<br>  `usage` <span class="hljs-type">int</span>(<span class="hljs-number">10</span>) unsigned <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span> COMMENT <span class="hljs-string">&#x27;使用量&#x27;</span>,<br>  `max_size` <span class="hljs-type">int</span>(<span class="hljs-number">10</span>) unsigned <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span> COMMENT <span class="hljs-string">&#x27;单个配置大小上限，单位为字节，0表示使用默认值&#x27;</span>,<br>  `max_aggr_count` <span class="hljs-type">int</span>(<span class="hljs-number">10</span>) unsigned <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span> COMMENT <span class="hljs-string">&#x27;聚合子配置最大个数&#x27;</span>,<br>  `max_aggr_size` <span class="hljs-type">int</span>(<span class="hljs-number">10</span>) unsigned <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span> COMMENT <span class="hljs-string">&#x27;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#x27;</span>,<br>  `max_history_count` <span class="hljs-type">int</span>(<span class="hljs-number">10</span>) unsigned <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span> COMMENT <span class="hljs-string">&#x27;最大变更历史数量&#x27;</span>,<br>  `gmt_create` datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">&#x27;创建时间&#x27;</span>,<br>  `gmt_modified` datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">&#x27;修改时间&#x27;</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`),<br>  <span class="hljs-keyword">UNIQUE</span> KEY `uk_tenant_id` (`tenant_id`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8 <span class="hljs-keyword">COLLATE</span><span class="hljs-operator">=</span>utf8_bin COMMENT<span class="hljs-operator">=</span><span class="hljs-string">&#x27;租户容量信息表&#x27;</span>;<br><br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `tenant_info` (<br>  `id` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="hljs-string">&#x27;id&#x27;</span>,<br>  `kp` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;kp&#x27;</span>,<br>  `tenant_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">default</span> <span class="hljs-string">&#x27;&#x27;</span> COMMENT <span class="hljs-string">&#x27;tenant_id&#x27;</span>,<br>  `tenant_name` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">default</span> <span class="hljs-string">&#x27;&#x27;</span> COMMENT <span class="hljs-string">&#x27;tenant_name&#x27;</span>,<br>  `tenant_desc` <span class="hljs-type">varchar</span>(<span class="hljs-number">256</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;tenant_desc&#x27;</span>,<br>  `create_source` <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;create_source&#x27;</span>,<br>  `gmt_create` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;创建时间&#x27;</span>,<br>  `gmt_modified` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;修改时间&#x27;</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`),<br>  <span class="hljs-keyword">UNIQUE</span> KEY `uk_tenant_info_kptenantid` (`kp`,`tenant_id`),<br>  KEY `idx_tenant_id` (`tenant_id`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8 <span class="hljs-keyword">COLLATE</span><span class="hljs-operator">=</span>utf8_bin COMMENT<span class="hljs-operator">=</span><span class="hljs-string">&#x27;tenant_info&#x27;</span>;<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `users` (<br>`username` <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">PRIMARY</span> KEY,<br>`password` <span class="hljs-type">varchar</span>(<span class="hljs-number">500</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>`enabled` <span class="hljs-type">boolean</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span><br>);<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `roles` (<br>`username` <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>`role` <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br><span class="hljs-keyword">UNIQUE</span> INDEX `idx_user_role` (`username` <span class="hljs-keyword">ASC</span>, `role` <span class="hljs-keyword">ASC</span>) <span class="hljs-keyword">USING</span> BTREE<br>);<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `permissions` (<br>    `role` <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    `resource` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    `action` <span class="hljs-type">varchar</span>(<span class="hljs-number">8</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    <span class="hljs-keyword">UNIQUE</span> INDEX `uk_role_permission` (`role`,`resource`,`action`) <span class="hljs-keyword">USING</span> BTREE<br>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> users (username, password, enabled) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;nacos&#x27;</span>, <span class="hljs-string">&#x27;$2a$10$EuWPZHzz32dJN7jexM34MOeYirDdFAZm2kuWj7VEOJhhZkDrxfvUu&#x27;</span>, <span class="hljs-literal">TRUE</span>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> roles (username, role) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;nacos&#x27;</span>, <span class="hljs-string">&#x27;ROLE_ADMIN&#x27;</span>);<br></code></pre></td></tr></table></figure><h2 id="配置nacos"><a href="#配置nacos" class="headerlink" title="配置nacos"></a>配置nacos</h2><p>进入nacos的conf目录，修改配置文件cluster.conf.example，重命名为cluster.conf：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403181822581.png"></p><p>然后添加内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs conf">127.0.0.1:8845<br>127.0.0.1.8846<br>127.0.0.1.8847<br></code></pre></td></tr></table></figure><p>然后修改application.properties文件，添加数据库配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.datasource.platform</span>=<span class="hljs-string">mysql</span><br><br><span class="hljs-attr">db.num</span>=<span class="hljs-string">1</span><br><br><span class="hljs-attr">db.url.0</span>=<span class="hljs-string">jdbc:mysql://127.0.0.1:3306/nacos?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC</span><br><span class="hljs-attr">db.user.0</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">db.password.0</span>=<span class="hljs-string">123</span><br></code></pre></td></tr></table></figure><h2 id="启动-1"><a href="#启动-1" class="headerlink" title="启动"></a>启动</h2><p>将nacos文件夹复制三份，分别命名为：nacos1、nacos2、nacos3</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403181823735.png"></p><p>然后分别修改三个文件夹中的application.properties，</p><p>nacos1:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">server.port</span>=<span class="hljs-string">8845</span><br></code></pre></td></tr></table></figure><p>nacos2:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">server.port</span>=<span class="hljs-string">8846</span><br></code></pre></td></tr></table></figure><p>nacos3:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">server.port</span>=<span class="hljs-string">8847</span><br></code></pre></td></tr></table></figure><p>然后分别启动三个nacos节点：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos">startup.<span class="hljs-built_in">cmd</span><br></code></pre></td></tr></table></figure><h2 id="nginx反向代理"><a href="#nginx反向代理" class="headerlink" title="nginx反向代理"></a>nginx反向代理</h2><p>获取nginx安装包</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403181825891.png"></p><p>解压到任意非中文目录下：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403181825911.png"></p><p>修改conf&#x2F;nginx.conf文件，配置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs nginx.conf">upstream nacos-cluster &#123;<br>    server 127.0.0.1:8845;<br>server 127.0.0.1:8846;<br>server 127.0.0.1:8847;<br>&#125;<br><br>server &#123;<br>    listen       80;<br>    server_name  localhost;<br><br>    location /nacos &#123;<br>        proxy_pass http://nacos-cluster;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>而后在浏览器访问：<a href="http://localhost/nacos">http://localhost/nacos</a>即可。</p><p>代码中application.yml文件配置如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:80</span> <span class="hljs-comment"># Nacos地址</span><br></code></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>实际部署时，需要给做反向代理的nginx服务器设置一个域名，这样后续如果有服务器迁移nacos的客户端也无需更改配置。</li><li>Nacos的各个节点应该部署到多个不同服务器，做好容灾和隔离。</li></ul>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nacos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通关微服务-feign</title>
    <link href="/posts/2c7fc5c1/"/>
    <url>/posts/2c7fc5c1/</url>
    
    <content type="html"><![CDATA[<blockquote><p>同样是rpc远程调用框架，有dubbo为什么还有再掌握feign呢？<br>先说结论：<br>Feign 是一个声明式的伪 Http 客户端，它使得写 Http 客户端变得更简单。使用 Feign，只需要创建一个接口并注解。它具有可插拔的注解特性，可使用 Feign 注解和 JAX-RS 注解。Feign 支持可插拔的编码器和解码器。Feign 默认集成了 Ribbon，Nacos 也很好的兼容了 Feign，默认实现了负载均衡的效果。<br>虽然dubbo在性能上有优势，<strong>不过这种性能差异除非是达极高的并发量级，否则无需过多考虑。</strong> 相比之下，个人更偏好Feign，因为比较简洁、优雅。</p></blockquote><hr><h1 id="Feign替代RestTemplate"><a href="#Feign替代RestTemplate" class="headerlink" title="Feign替代RestTemplate"></a>Feign替代RestTemplate</h1><p>先来看我们以前利用RestTemplate发起远程调用的代码：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403190936149.png"></p><p>存在下面的问题：</p><p>•代码可读性差，编程体验不统一<br>•参数复杂URL难以维护</p><p>其作用就是帮助我们优雅的实现http请求的发送，解决上面提到的问题。</p><p>feign使用步骤如下</p><h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><p>我们在order-service服务的pom文件中引入feign的依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pom">&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><h2 id="添加注解"><a href="#添加注解" class="headerlink" title="添加注解"></a>添加注解</h2><p>在order-service的<strong>启动类</strong>添加注解开启Feign的功能：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403190937087.png"></p><h2 id="编写Feign的客户端"><a href="#编写Feign的客户端" class="headerlink" title="编写Feign的客户端"></a>编写Feign的客户端</h2><p>在order-service中新建一个接口，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.order.client;<br><br><span class="hljs-keyword">import</span> cn.itcast.order.pojo.User;<br><span class="hljs-keyword">import</span> org.springframework.cloud.openfeign.FeignClient;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PathVariable;<br><br><span class="hljs-meta">@FeignClient(&quot;userservice&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserClient</span> &#123;<br>    <span class="hljs-meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span><br>    User <span class="hljs-title function_">findById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个客户端主要是<strong>基于SpringMVC的注解来声明远程调用的信息</strong>，比如：</p><ul><li>服务名称：userservice</li><li>请求方式：GET</li><li>请求路径：&#x2F;user&#x2F;{id}</li><li>请求参数：Long id</li><li>返回值类型：User</li></ul><p>这样，Feign就可以帮助我们发送http请求，无需自己使用RestTemplate来发送了。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>修改order-service中的OrderService类中的queryOrderById方法，使用Feign客户端代替RestTemplate：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403190939525.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用Feign的步骤：</p><p>① 引入依赖<br>② 添加@EnableFeignClients注解<br>③ 编写FeignClient接口<br>④ 使用FeignClient中定义的方法代替RestTemplate</p><h1 id="自定义配置"><a href="#自定义配置" class="headerlink" title="自定义配置"></a>自定义配置</h1><p>Feign可以支持很多的自定义配置，如下表所示：</p><table><thead><tr><th>类型</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td><strong>feign.Logger.Level</strong></td><td>修改日志级别</td><td>包含四种不同的级别：NONE、BASIC、HEADERS、FULL</td></tr><tr><td>feign.codec.Decoder</td><td>响应结果的解析器</td><td>http远程调用的结果做解析，例如解析json字符串为java对象</td></tr><tr><td>feign.codec.Encoder</td><td>请求参数编码</td><td>将请求参数编码，便于通过http请求发送</td></tr><tr><td>feign. Contract</td><td>支持的注解格式</td><td>默认是SpringMVC的注解</td></tr><tr><td>feign. Retryer</td><td>失败重试机制</td><td>请求失败的重试机制，默认是没有，不过会使用Ribbon的重试</td></tr></tbody></table><p>一般情况下，默认值就能满足我们使用，如果要自定义时，只需要创建自定义的@Bean覆盖默认Bean即可。</p><p>下面以日志为例来演示如何自定义配置。</p><h2 id="配置文件方式"><a href="#配置文件方式" class="headerlink" title="配置文件方式"></a>配置文件方式</h2><p>基于配置文件修改feign的日志级别可以针对单个服务：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">feign:</span>  <br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">config:</span> <br>      <span class="hljs-attr">userservice:</span> <span class="hljs-comment"># 针对某个微服务的配置</span><br>        <span class="hljs-attr">loggerLevel:</span> <span class="hljs-string">FULL</span> <span class="hljs-comment">#  日志级别 </span><br></code></pre></td></tr></table></figure><p>也可以针对所有服务：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">feign:</span>  <br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">config:</span> <br>      <span class="hljs-attr">default:</span> <span class="hljs-comment"># 这里用default就是全局配置，如果是写服务名称，则是针对某个微服务的配置</span><br>        <span class="hljs-attr">loggerLevel:</span> <span class="hljs-string">FULL</span> <span class="hljs-comment">#  日志级别 </span><br></code></pre></td></tr></table></figure><p>而日志的级别分为四种：</p><ul><li>NONE：不记录任何日志信息，这是默认值。</li><li>BASIC：仅记录请求的方法，URL以及响应状态码和执行时间</li><li>HEADERS：在BASIC的基础上，额外记录了请求和响应的头信息</li><li>FULL：记录所有请求和响应的明细，包括头信息、请求体、元数据。</li></ul><h2 id="Java代码方式"><a href="#Java代码方式" class="headerlink" title="Java代码方式"></a>Java代码方式</h2><p>也可以基于Java代码来修改日志级别，先声明一个类，然后声明一个Logger.Level的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultFeignConfiguration</span>  &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Logger.Level <span class="hljs-title function_">feignLogLevel</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> Logger.Level.BASIC; <span class="hljs-comment">// 日志级别为BASIC</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果要<strong>全局生效</strong>，将其放到启动类的@EnableFeignClients这个注解中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableFeignClients(defaultConfiguration = DefaultFeignConfiguration .class)</span> <br></code></pre></td></tr></table></figure><p>如果是<strong>局部生效</strong>，则把它放到对应的@FeignClient这个注解中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(value = &quot;userservice&quot;, configuration = DefaultFeignConfiguration .class)</span> <br></code></pre></td></tr></table></figure><h1 id="使用优化"><a href="#使用优化" class="headerlink" title="使用优化"></a>使用优化</h1><p>Feign底层发起http请求，依赖于其它的框架。其底层客户端实现包括：</p><p>•URLConnection：默认实现，不支持连接池<br>•Apache HttpClient ：支持连接池<br>•OKHttp：支持连接池</p><p>因此提高Feign的性能主要手段就是使用<strong>连接池</strong>代替默认的URLConnection。</p><p>这里我们用Apache的HttpClient来演示。</p><h2 id="引入依赖-1"><a href="#引入依赖-1" class="headerlink" title="引入依赖"></a>引入依赖</h2><p>在order-service的pom文件中引入Apache的HttpClient依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pom">&lt;!--httpClient的依赖 --&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;io.github.openfeign&lt;/groupId&gt;<br>    &lt;artifactId&gt;feign-httpclient&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><h2 id="配置连接池"><a href="#配置连接池" class="headerlink" title="配置连接池"></a>配置连接池</h2><p>在order-service的application.yml中添加配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">config:</span><br>      <span class="hljs-attr">default:</span> <span class="hljs-comment"># default全局的配置</span><br>        <span class="hljs-attr">loggerLevel:</span> <span class="hljs-string">BASIC</span> <span class="hljs-comment"># 日志级别，BASIC就是基本的请求和响应信息</span><br>  <span class="hljs-attr">httpclient:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 开启feign对HttpClient的支持!!!</span><br>    <span class="hljs-attr">max-connections:</span> <span class="hljs-number">200</span> <span class="hljs-comment"># 最大的连接数</span><br>    <span class="hljs-attr">max-connections-per-route:</span> <span class="hljs-number">50</span> <span class="hljs-comment"># 每个路径的最大连接数</span><br></code></pre></td></tr></table></figure><p>接下来，在FeignClientFactoryBean中的loadBalance方法中打断点：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403190943107.png"></p><p>Debug方式启动order-service服务，可以看到这里的client，底层就是Apache HttpClient：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403190944530.png"></p><p>总结，Feign的优化：</p><p>1.日志级别尽量用basic<br>2.使用HttpClient或OKHttp代替URLConnection<br>① 引入feign-httpClient依赖<br>② 配置文件开启httpClient功能，设置连接池参数</p><h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><p>所谓最近实践，就是使用过程中总结的经验，最好的一种使用方式。</p><p>观察可以发现，Feign的客户端与服务提供者的controller代码非常相似：</p><p>feign客户端：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403190944874.png"></p><p>UserController：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403190945882.png"></p><p>有没有一种办法简化这种重复的代码编写呢？</p><h2 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h2><p>一样的代码可以通过继承来共享：</p><p>1）定义一个API接口，利用定义方法，并基于SpringMVC注解做声明。<br>2）Feign客户端和Controller都集成改接口</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403190945915.png"></p><p>优点：</p><ul><li>简单</li><li>实现了代码共享</li></ul><p>缺点：</p><ul><li>服务提供方、服务消费方紧耦合</li><li>参数列表中的注解映射并不会继承，因此Controller中必须再次声明方法、参数列表、注解</li></ul><h2 id="抽取方式"><a href="#抽取方式" class="headerlink" title="抽取方式"></a>抽取方式</h2><p>将Feign的Client抽取为独立模块，并且把接口有关的POJO、默认的Feign配置都放到这个模块中，提供给所有消费者使用。</p><p>例如，将UserClient、User、Feign的默认配置都抽取到一个feign-api包中，所有微服务引用该依赖包，即可直接使用。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403190946725.png"></p><h2 id="基于抽取方式的最佳实践"><a href="#基于抽取方式的最佳实践" class="headerlink" title="基于抽取方式的最佳实践"></a>基于抽取方式的最佳实践</h2><h3 id="抽取"><a href="#抽取" class="headerlink" title="抽取"></a>抽取</h3><p>首先创建一个module，命名为feign-api：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403190948682.png"></p><p>项目结构：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403190948827.png"></p><p>在feign-api中然后引入feign的starter依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pom">&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><p>然后，order-service中编写的UserClient、User、DefaultFeignConfiguration都复制到feign-api项目中：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403190949199.png"></p><h3 id="使用feign-api"><a href="#使用feign-api" class="headerlink" title="使用feign-api"></a>使用feign-api</h3><p>首先，删除order-service中的UserClient、User、DefaultFeignConfiguration等类或接口。</p><p>在order-service的pom文件中中引入feign-api的依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pom">&lt;dependency&gt;<br>    &lt;groupId&gt;cn.itcast.demo&lt;/groupId&gt;<br>    &lt;artifactId&gt;feign-api&lt;/artifactId&gt;<br>    &lt;version&gt;1.0&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><p>修改order-service中的所有与上述三个组件有关的导包部分，改成导入feign-api中的包</p><h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><p>重启后，发现服务报错了：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403190950020.png"></p><p>这是因为UserClient现在在cn.itcast.feign.clients包下，</p><p>而order-service的@EnableFeignClients注解是在cn.itcast.order包下，不在同一个包，无法扫描到UserClient。</p><h3 id="解决扫描包问题"><a href="#解决扫描包问题" class="headerlink" title="解决扫描包问题"></a>解决扫描包问题</h3><p><strong>方式一</strong></p><p>指定Feign应该扫描的包：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableFeignClients(basePackages = &quot;cn.itcast.feign.clients&quot;)</span><br></code></pre></td></tr></table></figure><p><strong>方式二</strong></p><p>指定需要加载的Client接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableFeignClients(clients = &#123;UserClient.class&#125;)</span><br></code></pre></td></tr></table></figure><p>这样就完成了Feign的最佳实践。</p><h1 id="Feign与Dubbo"><a href="#Feign与Dubbo" class="headerlink" title="Feign与Dubbo"></a>Feign与Dubbo</h1><p><strong>Feign</strong>是Spring Cloud提供的一个声明式的伪Http客户端，它使得调用远程服务就像调用本地服务一样简单，只需要创建一个接口并添加一个注解即可。</p><p>Nacos注册中心很好的兼容了Feign，Feign默认集成了Ribbon，所以在Nacos下使用Fegin默认就实现了负载均衡的效果。</p><p><strong>Dubbo</strong>是阿里巴巴开源的基于Java的高性能RPC分布式服务框架，致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案。</p><p>Spring-cloud-alibaba-dubbo是基于SpringCloudAlibaba技术栈对dubbo技术的一种封装，目的在于实现基于RPC的服务调用。</p><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><h3 id="协议支持方面"><a href="#协议支持方面" class="headerlink" title="协议支持方面"></a>协议支持方面</h3><p>Feign更加优雅简单。Feign是通过REST API实现的远程调用，基于Http传输协议，服务提供者需要对外暴露Http接口供消费者调用，服务粒度是http接口级的。通过短连接的方式进行通信，不适合高并发的访问。Feign追求的是简洁，少侵入（因为就服务端而言，在SpringCloud环境下，不需要做任何额外的操作，而Dubbo的服务端需要配置开放的Dubbo接口)。</p><p>Dubbo方式更灵活。Dubbo是通过RPC调用实现的远程调用，支持多传输协议(Dubbo、Rmi、http、redis等等)，可以根据业务场景选择最佳的方式，非常灵活。默认的Dubbo协议：利用Netty，TCP传输，单一、异步、长连接，适合数据量小、高并发和服务提供者远远少于消费者的场景。Dubbo通过TCP长连接的方式进行通信，服务粒度是方法级的。</p><p>从协议层选择看，Dubbo是配置化的，更加灵活。Dubbo协议更适合小数据高并发场景。</p><h3 id="通信性能方面"><a href="#通信性能方面" class="headerlink" title="通信性能方面"></a>通信性能方面</h3><p>从通信的性能上来分析，SpringCloud的通信采用Openfeign（feign）组件。</p><p>Feign基于Http传输协议，底层实现是rest。从OSI 7层模型上来看rest属于应用层。</p><p>在高并发场景下性能不够理想，成为性能瓶颈（虽然他是基于Ribbon以及带有熔断机制可以防止雪崩），需要改造。具体需要改造的内容需要时再研究。</p><p>Dubbo框架的通信协议采用RPC协议，属于传输层协议，性能上自然比rest高。提升了交互的性能，保持了长连接，高性能。</p><p>Dubbo性能更好，比如支持异步调用、Netty性能更好。Dubbo主要是配置而无需改造。</p><table><thead><tr><th>RPC</th><th>REST</th></tr></thead><tbody><tr><td>耦合性</td><td>强耦合</td></tr><tr><td>消息协议</td><td>二进制 thrift&#x2F;protobuf</td></tr><tr><td>通信协议</td><td>TCP</td></tr><tr><td>接口契约IDL</td><td>thrift&#x2F;protobuf</td></tr><tr><td>开发调试</td><td>消息不可读</td></tr><tr><td>对外开放</td><td>一般作为内部各个系统的通信框架</td></tr></tbody></table><h3 id="负载均衡方面"><a href="#负载均衡方面" class="headerlink" title="负载均衡方面"></a>负载均衡方面</h3><p>Feign默认使用Ribbon作为负载均衡的组件。</p><p>Dubbo和Ribbon（Feign默认集成Ribbon）都支持负载均衡策略，但是Dubbo支持的更灵活。</p><p>Dubbo和Ribbon对比：</p><p>Ribbon的负载均衡策略：随机、规则轮询、空闲策略、响应时间策略。</p><p>Dubbo的负载均衡策略：Dubbo支持4种算法，随机、权重轮询、最少活跃调用数、一致性Hash策略。而且算法里面引入权重的概念。</p><p>Dubbo可以使用路由策略，然后再进行负载均衡。</p><p>Dubbo配置的形式不仅支持代码配置，还支持Dubbo控制台灵活动态配置。</p><p>Dubbo负载均衡的算法可以精准到某个服务接口的某个方法，而Ribbon的算法是Client级别的。Ribbon需要进行全局配置，个性化配置比较麻烦。</p><h3 id="容错机制方面"><a href="#容错机制方面" class="headerlink" title="容错机制方面"></a>容错机制方面</h3><p>Feign默认使用Hystix作为服务熔断的组件。Hystix提供了服务降级，服务熔断，依赖隔离，监控（Hystrix Dashboard）等功能。Feign是利用熔断机制来实现容错的，与Dubbo处理的方式不一样。</p><p>Dubbo支持多种容错策略，FailOver、FailFast、Failsafe、FailBack、Aviailable、Broadcast、Forking策略等，以及Mock。也引入了retry次数，timeout等配置参数。Dubbo自带了失败重试的功能。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>如果项目对性能要求不是很严格，可以选择使用Feign，它使用起来更方便。</p><p>如果需要提高性能，避开基于Http方式的性能瓶颈，可以使用Dubbo。</p>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>feign</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通关微服务-dubbo</title>
    <link href="/posts/198ade24/"/>
    <url>/posts/198ade24/</url>
    
    <content type="html"><![CDATA[<h1 id="分布式系统中相关概念"><a href="#分布式系统中相关概念" class="headerlink" title="分布式系统中相关概念"></a>分布式系统中相关概念</h1><h2 id="大型互联网项目架构特点"><a href="#大型互联网项目架构特点" class="headerlink" title="大型互联网项目架构特点"></a>大型互联网项目架构特点</h2><ul><li>用户多</li><li>流量大，并发高</li><li>海量数据</li><li>易受攻击</li><li>功能繁琐</li><li>变更快</li></ul><h2 id="大型互联网项目架构目标"><a href="#大型互联网项目架构目标" class="headerlink" title="大型互联网项目架构目标"></a>大型互联网项目架构目标</h2><ul><li>高性能：提供快速的访问体验</li><li>高可用：网站服务一直可以正常访问</li><li>可伸缩：通过硬件增加&#x2F;减少，提高&#x2F;降低处理能力</li><li>高可扩展：系统间耦合低，方便通过新增&#x2F;移除方式，增加&#x2F;减少功能&#x2F;模块</li><li>安全性：提供网站安全访问和数据加密，安全存储等策略</li><li>敏捷性：随需应变，快速响应</li></ul><h2 id="集群和分布式"><a href="#集群和分布式" class="headerlink" title="集群和分布式"></a>集群和分布式</h2><ul><li>集群：很多”人”一起，干一样的事<ul><li>一个业务模块，部署在多台服务器上。</li></ul></li><li>分布式：很多”人”一起，干不一样的事。这些不一样的事，合起来是一件大事<ul><li>一个大的业务系统，拆分为小的业务模块，分别部署在不同机器上。</li></ul></li></ul><p>（eg.饭店，厨师，洗菜、切菜、炒菜）</p><h2 id="架构演进"><a href="#架构演进" class="headerlink" title="架构演进"></a>架构演进</h2><h3 id="单体架构"><a href="#单体架构" class="headerlink" title="单体架构"></a>单体架构</h3><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403171445668.png"><br>优点：</p><ul><li>简单：开发部署都很方便，小型项目首选</li></ul><p>缺点：</p><ul><li>项目启动慢</li><li>可靠性差</li><li>可伸缩性差</li><li>扩展性和可维护性差</li><li>性能低</li></ul><h3 id="垂直架构"><a href="#垂直架构" class="headerlink" title="垂直架构"></a>垂直架构</h3><p>在某个领域细分就是垂直的意思。<br>垂直架构是指单体架构中的多个模块拆分为多个独立的项目。行程多个独立的单体架构。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403171449282.png"></p><p>垂直架构存在的问题：</p><ul><li>重复功能多</li></ul><h3 id="分布式架构"><a href="#分布式架构" class="headerlink" title="分布式架构"></a>分布式架构</h3><p>分布式架构是指在垂直架构的基础上，将公共业务模块抽取出来，作为独立的服务，供其他调用者消费，以实现服务的共享和重用。</p><p>RPC：Remote Procedure Call远程过程调用。有非常多的协议和技术都来实现了RPC过程。比如：HTTP REST风格，Java RMI规范等等。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403171453372.png"></p><p>分布式架构存在的问题：</p><ul><li>服务的提供方一旦产生变更，所有消费方都需要变更</li></ul><h3 id="SOA架构"><a href="#SOA架构" class="headerlink" title="SOA架构"></a>SOA架构</h3><p>![[Pasted image 20240317145745.png]]</p><p>SOA：Service-Oriented Architecture，面向服务的架构。是一个组件模型，它将应用程序的不同功能单元（称为服务）进行拆分，并通过这些服务之间定义良好的接口和契约联系起来。</p><p>ESB：Enterparise Service Bus企业服务总线，服务中介。主要提供了一个服务于服务之间的交互。ESB包含的功能包含：负载均衡，流量控制，加密处理，服务的监控，异常处理，监控告急等等。</p><h3 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h3><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403171502998.png"></p><p>微服务架构是在SOA上做的升华，微服务架构强调的一个重点是”业务需要彻底的组件化和服务化”，原有的单个业务系统会拆分为多个可以独立开发、设计、运行的小应用。这些小应用之间通过服务完成交互和集成。</p><p>微服务架构 &#x3D; 80%SOA服务架构思想 + 100%的组件化思想 + 80%的领域建模思想。</p><p>特点：</p><ul><li>服务实现组件化：开发者可以自由选择开发技术，也不需要协调其他团队</li><li>服务之间交互一般采用REST API</li><li>去中心化：每个微服务有自己私有的数据库持久化业务数据</li><li>自动化部署：把应用拆分成为一个一个独立的单个服务，方便自动化部署、测试、运维</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403171504101.png"></p><p><font color="#ffc000">注：</font> Dubbo是SOA时代的产物，SpringCloud是微服务时代的产物。</p><h1 id="Dubbo概述"><a href="#Dubbo概述" class="headerlink" title="Dubbo概述"></a>Dubbo概述</h1><h2 id="Dubbo概念"><a href="#Dubbo概念" class="headerlink" title="Dubbo概念"></a>Dubbo概念</h2><ul><li>Dubbo是阿里开源的一个高性能、轻量级的Java RPC框架，现已收录到apache了。</li><li>致力于提供高性能和透明化的RPC<font color="#0070c0"><strong>远程调用方案</strong></font>，已经SOA服务治理方案。</li><li><a href="https://cn.dubbo.apache.org/zh-cn/">dubbo官网</a></li></ul><h2 id="Dubbo架构"><a href="#Dubbo架构" class="headerlink" title="Dubbo架构"></a>Dubbo架构</h2><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403171511719.png"><br>编号标注了使用流程，很清晰<br>0.start：服务的提供者需要运行在容器里，比如tomcat里。<br>1.register：服务启动后，会注册到注册中心，相当于把服务的IP、端口等信息放到注册中心上。<br>2.subscribe：消费者想要调用服务，就需要订阅，向注册中心要，把服务提供者的IP、端口地址给我。<br>3.notify：消费者向注册中心要，注册中心提供信息。<br>4.invoke：这个时候消费者就拿到了目标服务的信息，就可以调用了，就是RPC的过程。这个过程不用管，这是dubbo内部自动实现。<br>5.monitor：管理者，是做服务监控的，比如某个服务调用了多少次。</p><h1 id="Dubbo快速入门"><a href="#Dubbo快速入门" class="headerlink" title="Dubbo快速入门"></a>Dubbo快速入门</h1><h2 id="Zookeeper安装"><a href="#Zookeeper安装" class="headerlink" title="Zookeeper安装"></a>Zookeeper安装</h2><p>其实zookeeper就是dubbo推荐使用的注册中心。</p><h2 id="Dubbo快速入门-1"><a href="#Dubbo快速入门-1" class="headerlink" title="Dubbo快速入门"></a>Dubbo快速入门</h2><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403171559190.png"></p><h3 id="启动注册中心"><a href="#启动注册中心" class="headerlink" title="启动注册中心"></a>启动注册中心</h3><p>对于一个微服务化的应用来说，注册中心是不可或缺的一个组件。只有通过注册中心，消费端才可以成功发现服务端的地址信息，进而进行调用。通过官方教程获取一个基于 Apache Zookeeper 注册中心的简易启动器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">Windows:<br>git <span class="hljs-built_in">clone</span> --depth=1 --branch master git@github.com:apache/dubbo-samples.git<br><span class="hljs-built_in">cd</span> dubbo-samples<br>./mvnw.cmd clean compile <span class="hljs-built_in">exec</span>:java -pl tools/embedded-zookeeper<br><br>Linux / MacOS:<br>git <span class="hljs-built_in">clone</span> --depth=1 --branch master git@github.com:apache/dubbo-samples.git<br><span class="hljs-built_in">cd</span> dubbo-samples<br>./mvnw clean compile <span class="hljs-built_in">exec</span>:java -pl tools/embedded-zookeeper<br><br>Docker:<br>docker run --name some-zookeeper -p 2181:2181 --restart always -d zookeeper<br></code></pre></td></tr></table></figure><h3 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h3><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403171606809.png"></p><p>如上图所示，可以建立一个基础的项目。</p><p>搭建了基础项目之后，我们还需要创建 <code>dubbo-spring-boot-demo-interface</code> 、<code>dubbo-spring-boot-demo-provider</code> 和 <code>dubbo-spring-boot-demo-consumer</code> 三个子模块。</p><p>创建了三个子模块之后，需要创建一下几个文件夹：</p><ol><li>在 <code>dubbo-spring-boot-demo-consumer/src/main/java</code> 下创建 <code>org.apache.dubbo.springboot.demo.consumer</code> package</li><li>在 <code>dubbo-spring-boot-demo-interface/src/main/java</code> 下创建 <code>org.apache.dubbo.springboot.demo</code> package</li><li>在 <code>dubbo-spring-boot-demo-provider/src/main/java</code> 下创建 <code>org.apache.dubbo.springboot.demo.provider</code> package</li></ol><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403171607781.png"></p><h3 id="添加Maven依赖"><a href="#添加Maven依赖" class="headerlink" title="添加Maven依赖"></a>添加Maven依赖</h3><p>在初始化完项目以后，我们需要先添加 Dubbo 相关的 maven 依赖。</p><p>对于多模块项目，首先需要在父项目的 <code>pom.xml</code> 里面配置依赖信息。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403171608057.png"></p><p>编辑 <code>./pom.xml</code> 这个文件，添加下列配置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dubbo.version</span>&gt;</span>3.2.0-beta.4<span class="hljs-tag">&lt;/<span class="hljs-name">dubbo.version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">spring-boot.version</span>&gt;</span>2.7.8<span class="hljs-tag">&lt;/<span class="hljs-name">spring-boot.version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>17<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>17<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- Spring Boot --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring-boot.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>            <span class="hljs-comment">&lt;!-- Dubbo --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo-bom<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;dubbo.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo-dependencies-zookeeper-curator5<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;dubbo.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">pluginManagement</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring-boot.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">pluginManagement</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后在 <code>dubbo-spring-boot-consumer</code> 和 <code>dubbo-spring-boot-provider</code> 两个模块 <code>pom.xml</code> 中进行具体依赖的配置。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403171609745.png"></p><p>编辑 <code>./dubbo-spring-boot-consumer/pom.xml</code> 和 <code>./dubbo-spring-boot-provider/pom.xml</code> 这两文件，都添加下列配置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo-samples-spring-boot-interface<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;project.parent.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- dubbo --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo-dependencies-zookeeper-curator5<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-reload4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- spring boot starter --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在这份配置中，定义了 dubbo 和 zookeeper（以及对应的连接器 curator）的依赖。</p><p>添加了上述的配置以后，可以通过 IDEA 的 <code>Maven - Reload All Maven Projects</code> 刷新依赖</p><h3 id="定义服务接口"><a href="#定义服务接口" class="headerlink" title="定义服务接口"></a>定义服务接口</h3><p>服务接口 Dubbo 中沟通消费端和服务端的桥梁。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403171610622.png"></p><p>在 <code>dubbo-spring-boot-demo-interface</code> 模块的 <code>org.apache.dubbo.samples.api</code> 下建立 <code>DemoService</code> 接口，定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.apache.dubbo.springboot.demo;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">DemoService</span> &#123;<br><br>    String <span class="hljs-title function_">sayHello</span><span class="hljs-params">(String name)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>DemoService</code> 中，定义了 <code>sayHello</code> 这个方法。后续服务端发布的服务，消费端订阅的服务都是围绕着 <code>DemoService</code> 接口展开的。</p><h3 id="定义服务端实现"><a href="#定义服务端实现" class="headerlink" title="定义服务端实现"></a>定义服务端实现</h3><p>定义了服务接口之后，可以在服务端这一侧定义对应的实现，这部分的实现相对于消费端来说是远端的实现，本地没有相关的信息。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403171611053.png"></p><p>在<code>dubbo-spring-boot-demo-provider</code> 模块的 <code>org.apache.dubbo.samples.provider</code> 下建立 <code>DemoServiceImpl</code> 类，定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.apache.dubbo.springboot.demo.provider;<br><br><span class="hljs-keyword">import</span> org.apache.dubbo.config.annotation.DubboService;<br><span class="hljs-keyword">import</span> org.apache.dubbo.springboot.demo.DemoService;<br><br><span class="hljs-meta">@DubboService</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DemoService</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">sayHello</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello &quot;</span> + name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>DemoServiceImpl</code> 中，实现了 <code>DemoService</code> 接口，对于 <code>sayHello</code> 方法返回 <code>Hello name</code>。</p><p>注：在<code>DemoServiceImpl</code> 类中添加了 <code>@DubboService</code> 注解，通过这个配置可以基于 Spring Boot 去发布 Dubbo 服务。</p><h3 id="配置服务端配置文件"><a href="#配置服务端配置文件" class="headerlink" title="配置服务端配置文件"></a>配置服务端配置文件</h3><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403171612651.png"></p><p>在 <code>dubbo-spring-boot-demo-provider</code> 模块的 <code>resources</code> 资源文件夹下建立 <code>application.yml</code> 文件，定义如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">dubbo:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">dubbo-springboot-demo-provider</span><br>  <span class="hljs-attr">protocol:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">dubbo</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">-1</span><br>  <span class="hljs-attr">registry:</span><br>    <span class="hljs-attr">address:</span> <span class="hljs-string">zookeeper://$&#123;zookeeper.address:127.0.0.1&#125;:2181</span><br></code></pre></td></tr></table></figure><p>在这个配置文件中，定义了 Dubbo 的应用名、Dubbo 协议信息、Dubbo 使用的注册中心地址。</p><h3 id="配置消费端配置文件"><a href="#配置消费端配置文件" class="headerlink" title="配置消费端配置文件"></a>配置消费端配置文件</h3><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403171612573.png"></p><p>在 <code>dubbo-spring-boot-demo-consumer</code> 模块的 <code>resources</code> 资源文件夹下建立 <code>application.yml</code> 文件，定义如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">dubbo:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">dubbo-springboot-demo-consumer</span><br>  <span class="hljs-attr">protocol:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">dubbo</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">-1</span><br>  <span class="hljs-attr">registry:</span><br>    <span class="hljs-attr">address:</span> <span class="hljs-string">zookeeper://$&#123;zookeeper.address:127.0.0.1&#125;:2181</span><br></code></pre></td></tr></table></figure><p>在这个配置文件中，定义了 Dubbo 的应用名、Dubbo 协议信息、Dubbo 使用的注册中心地址。</p><h3 id="配置服务端启动类"><a href="#配置服务端启动类" class="headerlink" title="配置服务端启动类"></a>配置服务端启动类</h3><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403171613225.png"></p><p>在 <code>dubbo-spring-boot-demo-provider</code> 模块的 <code>org.apache.dubbo.springboot.demo.provider</code> 下建立 <code>Application</code> 类，定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.apache.dubbo.springboot.demo.provider;<br><br><span class="hljs-keyword">import</span> org.apache.dubbo.config.spring.context.annotation.EnableDubbo;<br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableDubbo</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProviderApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(ProviderApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个启动类中，配置了一个 <code>ProviderApplication</code> 去读取我们前面第 6 步中定义的 <code>application.yml</code> 配置文件并启动应用。</p><h3 id="配置消费端启动类"><a href="#配置消费端启动类" class="headerlink" title="配置消费端启动类"></a>配置消费端启动类</h3><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403171614281.png"></p><p>在 <code>dubbo-spring-boot-demo-consumer</code> 模块的 <code>org.apache.dubbo.springboot.demo.consumer</code> 下建立 <code>Application</code> 类，定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.apache.dubbo.springboot.demo.consumer;<br><br><span class="hljs-keyword">import</span> org.apache.dubbo.config.spring.context.annotation.EnableDubbo;<br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableDubbo</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConsumerApplication</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(ConsumerApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个启动类中，配置了一个 <code>ConsumerApplication</code> 去读取我们前面第 7 步中定义的 <code>application.yml</code> 配置文件并启动应用。</p><h3 id="配置消费端请求任务"><a href="#配置消费端请求任务" class="headerlink" title="配置消费端请求任务"></a>配置消费端请求任务</h3><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403171614249.png"></p><p>在 <code>dubbo-spring-boot-demo-consumer</code> 模块的 <code>org.apache.dubbo.springboot.demo.consumer</code> 下建立 <code>Task</code> 类，定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.apache.dubbo.springboot.demo.consumer;<br><br><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-keyword">import</span> org.apache.dubbo.config.annotation.DubboReference;<br><span class="hljs-keyword">import</span> org.apache.dubbo.springboot.demo.DemoService;<br><span class="hljs-keyword">import</span> org.springframework.boot.CommandLineRunner;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Task</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CommandLineRunner</span> &#123;<br>    <span class="hljs-meta">@DubboReference</span><br>    <span class="hljs-keyword">private</span> DemoService demoService;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(String... args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> demoService.sayHello(<span class="hljs-string">&quot;world&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;Receive result ======&gt; &quot;</span> + result);<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt; &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                    System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>() + <span class="hljs-string">&quot; Receive result ======&gt; &quot;</span> + demoService.sayHello(<span class="hljs-string">&quot;world&quot;</span>));<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                    Thread.currentThread().interrupt();<br>                &#125;<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>Task</code> 类中，通过<code>@DubboReference</code> 从 Dubbo 获取了一个 RPC 订阅，这个 <code>demoService</code> 可以像本地调用一样直接调用。在 <code>run</code>方法中创建了一个线程进行调用。</p><h3 id="启动应用"><a href="#启动应用" class="headerlink" title="启动应用"></a>启动应用</h3><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403171615752.png"></p><p>首先是启动 <code>org.apache.dubbo.samples.provider.Application</code> ，等待一会出现如下图所示的日志（<code>Current Spring Boot Application is await</code>）即代表服务提供者启动完毕，标志着该服务提供者可以对外提供服务了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fallback">[Dubbo] Current Spring Boot Application is await...<br></code></pre></td></tr></table></figure><p>然后是启动<code>org.apache.dubbo.samples.client.Application</code> ，等待一会出现如下图所示的日志（<code>Hello world</code> ）即代表服务消费端启动完毕并调用到服务端成功获取结果。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403171615579.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fallback">Receive result ======&gt; Hello world<br></code></pre></td></tr></table></figure><h1 id="Dubbo高级特性"><a href="#Dubbo高级特性" class="headerlink" title="Dubbo高级特性"></a>Dubbo高级特性</h1><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403171628734.png"></p><ul><li>dubbo内部已经将序列化和反序列化的过程内部封装了</li><li>只需要在定义pojo类时<strong>实现Serializable接口</strong>即可</li><li>一般会定义一个公共的pojo模块，让生产者和消费者都依赖该模块</li></ul><h2 id="地址缓存"><a href="#地址缓存" class="headerlink" title="地址缓存"></a>地址缓存</h2><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403171638042.png"></p><h2 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h2><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403171640671.png"></p><ul><li>服务消费者在调用服务提供者的时候发生了阻塞、等待的情形，服务消费者会一直等待下去。</li><li>在峰值时刻，大量请求同时到达，会造成线程的大量堆积，会造成服务雪崩。</li><li>dubbo利用超时机制来解决，设置一个超时时间，在时间段内无法完成访问，则自动断开。</li><li>使用timeout属性配置超时时间，默认值是1000，单位毫秒。</li></ul><p>注：推荐配置在服务的提供方。</p><h2 id="重试"><a href="#重试" class="headerlink" title="重试"></a>重试</h2><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403171648389.png"></p><ul><li>如果出现了网络抖动，则这一次请求就会失败。</li><li>dubbo提供重试机制来避免类似问题。</li><li>通过retries属性来设置重试次数，默认是2次。</li></ul><h2 id="多版本"><a href="#多版本" class="headerlink" title="多版本"></a>多版本</h2><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403171651383.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403171651129.png"></p><p><font color="#0070c0"><strong>灰度发布</strong></font>：当出现新功能时，会让一部分用户先使用新功能，用户反馈没有问题，再将所有用户迁移到新功能。</p><p>dubbo中使用version属性来设置和调用同一个接口的不同版本。</p><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403171659466.png"></p><p>负载均衡策略：</p><ul><li>Random：按权重随机。</li><li>RoundRobin：按权重轮询。</li><li>LeastActive：最少活跃调用，相同活跃是随机。</li><li>ConsistentHash：一致性Hash，相同参数额请求总是发到同一个提供者。</li></ul><h2 id="集群容错"><a href="#集群容错" class="headerlink" title="集群容错"></a>集群容错</h2><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403171703357.png"></p><p>集群容错模式：</p><ul><li>Failover Cluster：失败重试。默认值。当出现失败，重试其他服务器，默认重试2次，使用retries配置，一般用于<font color="#0070c0">读操作</font>。</li><li>Failfast Cluster：快速失败，只发起一次调用，失败立即报错。通常用于<font color="#0070c0">写操作</font>。</li><li>Failsafe Cluster：失败安全，出现异常时，直接忽略。返回一个空结果。</li><li>Failback Cluster：失败自动回复，后台记录失败请求时，定时重发。</li><li>Forking Cluster：并行调用多个服务器，只要一个成功即返回。比较耗费性能。</li><li>Broadcast Cluster：广播调用所有提供者，逐个调用，任意一台报错则报错。同步要求性比较高的情形。</li></ul><h2 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h2><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403171705376.png"></p><p>在B上，同时存在广告服务，日志服务，支付服务。很明显支付服务较为重要，当B机器cpu达到90%时，除了定位异常外，最先考虑的应该是服务降级，要确保支付服务正常，不重要的广告服务、日志服务可以先停掉。这就是服务降级。</p><p>dubbo服务降级方式：</p><ul><li><code>mock=force:return null</code> 表示消费方对该服务的方法调用都直接返回null，不发起远程调用。用来屏蔽不重要服务可不用时对调用方的影响。</li><li><code>mock=fail:return null</code> 表示消费方对该服务的方法调用在失败后，再返回null，不抛异常。用来容忍不重要服务不稳定时对调用方的影响。</li></ul>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dubbo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>认识微服务体系</title>
    <link href="/posts/ffffd0ab/"/>
    <url>/posts/ffffd0ab/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>结论如下：</strong><br>微服务不等于SpringCloud，微服务是分布式架构的一种，所谓分布式架构就是要把服务做拆分，而拆分的过程中会产生各种各样的问题要解决，<font color="#245bdb"><strong>SpringCloud仅仅是服务拆分时的服务治理问题</strong></font>，至于其他问题并没有给出解决方案，所以一套完整的微服务技术并不仅仅包含SpringCloud技术，那么还包括哪些呢？微服务要做的第一件事就是拆分，因为传统的单体架构，所有的业务全都写在一起，随着业务越来越复杂，代码也变得杂乱耦合不易扩展，想升级维护会变得很困难，所以到一定体量之后必须要做拆分，微服务会根据业务功能模块把一个单体项目拆分成许多个独立的项目，每个项目完成好自己的业务功能，将来独立开发独立部署，把一个独立的项目称为一个服务，一个大型的项目可能包含数十上百的服务，最终形成一个<font color="#245bdb"><strong>服务集群</strong></font>。而一个业务往往需要多个服务共同完成。比如，当一个请求过来，会调用服务A，再调用服务B，当业务越来越多，这些服务的调用关系越来越复杂。人为维护肯定是不行的，所以此时会有一个<font color="#245bdb"><strong>注册中心的组件（Eureka&#x2F;Nacos），负责拉去或注册服务信息，当一个服务调用另一个服务时，它不需要自己记录对方的 IP，只需要找注册中心就行了，从它那里去拉取对应的服务信息</strong></font>。同时随着服务越来越多，每个服务都有自己的配置文件啊，将来要更改配置，难道要逐一修改么，太麻烦了。所以微服务里，还会有一个<font color="#245bdb"><strong>配置中心，负责统一的去管理整个服务群里成百上千的配置，如果有某个服务配置需要变更，至需要去找配置中心就可以了，它会通知相关的微服务实现配置的热更新。</strong></font>当微服务运行起来后，用户就可以来访问了，但是这时候还需要一个网关组件，因为这里有这么的多的微服务，用户怎么知道要访问哪一个呢，而且也不是随便什么人都能来访问所有服务，就像小区的门卫，至少不能让不法分子进。所以<font color="#245bdb"><strong>服务网管组件，一方面对用户什么做校验，另一方面可以把用户的请求路由到具体的服务。当然在路由过程中也可以做一些负载均衡。</strong></font>而这时候服务接收到请求去处理，该访问数据库的时候就拿到数据返回给用户就ok了。数据库集群再庞大也不能有用户多，所以将来数据库肯定扛不住这么高的并发，因此还会有一个<font color="#245bdb"><strong>缓存组件，负责把数据库数据放入到内存中</strong></font>，内存中的效率肯定要比数据库快很多，而且缓存还不能是单体缓存，为了应对高并发<em>还要做成分布式缓存</em>。用户请求先到缓存，缓存未命中了再去查询数据库。之后业务还会有复杂的搜索功能，简单查询可以做缓存，<font color="#245bdb"><strong>一些海量数据复杂的搜索缓存也做不了，这时候就还要用到一个组件分布式搜索。</strong></font>那数据库的主要职责就是做一些写操作还有一些事务类型对数据安全要求比较高的数据存储。最后在微服务里，还要一个<font color="#245bdb"><strong>异步通信的消息队列组件，为什么呢，其实在微服务里面它的业务往往会跨越多个服务。</strong></font>比如一个请求来了，调用服务A再调用B再调用C，整个业务的链路就很长，对性能是有一定下降的。而异步通信的作用就是，请求来了调用服务A，那服务A不是去调用服务B和C，而是去通知你们，发一条小心你们俩个赶紧干活去，然后这俩服务去干了，而服务A直接结束了，所以它的业务链路变短了，响应时间也缩短了，吞吐能力也变强了。所以异步通信其实可以大大提高服务的并发，再一些秒杀啊高并发场景下就可以去利用了。 当然如此庞大的服务在运行的过程当中，如果出现了问题好排查么，不太好排查。所以又引入了俩个新的组件，来解决这种微服务的异常定位，一个是<font color="#245bdb"><strong>分布式日志服务，他可以去统计整个服务集群成百上千服务的日志，同样做一个存储，将来出现问题就比较好定位了</strong></font>。第二个系统的<font color="#245bdb"><strong>监控链路追踪，它可以去实时监控每个节点的运行状态，cpu的负载，内存的占用等待问题，一旦出现什么问题，直接可以定位到某一个服务某一个方法来快速定位问题。</strong></font>那么如此*庞大复杂的一个微服务集群，部署该怎么办呢，人工部署肯定不行，所以要利用一个叫jenkins的工具，它可以帮助我们对这些微服务项目进行<font color="#245bdb"><strong>自动化编译(Jenkins)</strong></font>，<font color="#245bdb"><strong>基于docker再进行打包形成镜像，在基于k8s或者rancher这样的技术去实现自动化的部署。这一套称为持续集成</strong></font>。结合微服务的这些技术再加上持续集成，这才是<u><strong>完整的微服务技术栈</strong></u>。</p></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403171326381.png"></p><hr><h2 id="一、微服务架构介绍"><a href="#一、微服务架构介绍" class="headerlink" title="一、微服务架构介绍"></a><strong>一、微服务架构介绍</strong></h2><p>微服务架构（Microservice Architecture）是一种架构概念，旨在通过将功能分解到各个离散的服务中以实现对解决方案的解耦。你可以将其看作是在架构层次而非获取服务的</p><p>类上应用很多SOLID原则。微服务架构是个很有趣的概念，它的主要作用是将功能分解到离散的各个服务当中，从而降低系统的耦合性，并提供更加灵活的服务支持。</p><p><strong>概念：</strong> 把一个大型的单个应用程序和服务拆分为数个甚至数十个的支持微服务，它可扩展单个组件而不是整个的应用程序堆栈，从而满足服务等级协议。</p><p><strong>定义：</strong> 围绕业务领域组件来创建应用，这些应用可独立地进行开发、管理和迭代。在分散的组件中使用云架构和平台式部署、管理和服务功能，使产品交付变得更加简单。</p><p><strong>本质：</strong> 用一些功能比较明确、业务比较精练的服务去解决更大、更实际的问题。</p><h2 id="二、出现和发展"><a href="#二、出现和发展" class="headerlink" title="二、出现和发展"></a><strong>二、出现和发展</strong></h2><p>微服务（Microservice）这个概念是2012年出现的，作为加快Web和移动应用程序开发进程的一种方法，2014年开始受到各方的关注，而2015年，可以说是微服务的元年；</p><p>越来越多的论坛、社区、blog以及互联网行业巨头开始对微服务进行讨论、实践，可以说这样更近一步推动了微服务的发展和创新。而微服务的流行，Martin Fowler功不可没。</p><p>这老头是个奇人，特别擅长抽象归纳和制造概念。特别是微服务这种新生的名词，都有一个特点：<strong>一解释就懂，一问就不知，一讨论就打架。</strong></p><blockquote><p>Martin Fowler是国际著名的OO专家，敏捷开发方法的创始人之一，现为ThoughtWorks公司的首席科学家。在面向对象分析设计、UML、模式、软件开发方法学、XP、重构等方面，都是世界顶级的专家，现为Thought Works公司的首席科学家。Thought Works是一家从事企业应用开发和集成的公司。早在20世纪80年代，Fowler就是使用对象技术构建多层企业应用的倡导者，他著有几本经典书籍：《企业应用架构模式》、《UML精粹》和《重构》等。 ———— 百度百科</p></blockquote><h2 id="三、传统开发模式和微服务的区别"><a href="#三、传统开发模式和微服务的区别" class="headerlink" title="三、传统开发模式和微服务的区别"></a><strong>三、传统开发模式和微服务的区别</strong></h2><p>先来看看传统的web开发方式，通过对比比较容易理解什么是Microservice Architecture。和Microservice相对应的，这种方式一般被称为Monolithic（单体式开发）。</p><p>所有的功能打包在一个 WAR包里，基本没有外部依赖（除了容器），部署在一个JEE容器（Tomcat，JBoss，WebLogic）里，包含了 DO&#x2F;DAO，Service，UI等所有逻辑。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403171343965.png"></p><p><strong>优点：</strong></p><p>①开发简单，集中式管理</p><p>②基本不会重复开发</p><p>③功能都在本地，没有分布式的管理和调用消耗</p><p><strong>缺点：</strong></p><p>1、效率低：开发都在同一个项目改代码，相互等待，冲突不断</p><p>2、维护难：代码功功能耦合在一起，新人不知道何从下手</p><p>3、不灵活：构建时间长，任何小修改都要重构整个项目，耗时</p><p>4、稳定性差：一个微小的问题，都可能导致整个应用挂掉</p><p>5、扩展性不够：无法满足高并发下的业务需求</p><p><strong>常见的系统架构遵循的三个标准和业务驱动力：</strong></p><p>1、提高敏捷性：及时响应业务需求，促进企业发展</p><p>2、提升用户体验：提升用户体验，减少用户流失</p><p>3、降低成本：降低增加产品、客户或业务方案的成本</p><p><strong>基于微服务架构的设计：</strong></p><p><strong>目的：</strong> 有效的拆分应用，实现敏捷开发和部署</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403171343677.png"></p><p><strong>关于微服务的一个形象表达：</strong></p><p><strong>X轴：</strong> 运行多个负载均衡器之后的运行实例</p><p><strong>Y轴：</strong> 将应用进一步分解为微服务（分库）</p><p><strong>Z轴：</strong> 大数据量时，将服务分区（分表）</p><h2 id="四、微服务的具体特征"><a href="#四、微服务的具体特征" class="headerlink" title="四、微服务的具体特征"></a><strong>四、微服务的具体特征</strong></h2><p><strong>官方的定义：</strong></p><p>1、一些列的独立的服务共同组成系统</p><p>2、单独部署，跑在自己的进程中</p><p>3、每个服务为独立的业务开发</p><p>4、分布式管理</p><p>5、非常强调隔离性</p><p><strong>大概的标准：</strong></p><p>1、分布式服务组成的系统</p><p>2、按照业务，而不是技术来划分组织</p><p>3、做有生命的产品而不是项目</p><p>4、强服务个体和弱通信（ Smart endpoints and dumb pipes ）</p><p>5、自动化运维（ DevOps ）</p><p>6、高度容错性</p><p>7、快速演化和迭代</p><h2 id="五、SOA和微服务的区别"><a href="#五、SOA和微服务的区别" class="headerlink" title="五、SOA和微服务的区别"></a><strong>五、SOA和微服务的区别</strong></h2><p><strong>1、SOA喜欢重用，微服务喜欢重写</strong></p><p><strong>SOA</strong> 的主要目的是为了企业各个系统更加容易地融合在一起。说到SOA不得不说ESB(EnterpriseService Bus)。ESB是什么? 可以把ESB想象成一个连接所有企业级服务的脚手架。通过service broker，它可以把不同数据格式或模型转成canonical格式，把XML的输入转成CSV传给legacy服务，把SOAP 1.1服务转成 SOAP 1.2等等。它还可以把一个服务路由到另一个服务上，也可以集中化管理业务逻辑，规则和验证等等。它还有一个重要功能是消息队列和事件驱动的消息传递，比如把JMS服务转化成SOAP协议。各服务间可能有复杂的依赖关系。</p><p><strong>微服务</strong> 通常由重写一个模块开始。要把整个巨石型的应用重写是有很大的风险的，也不一定必要。我们向微服务迁移的时候通常从耦合度最低的模块或对扩展性要求最高的模块开始，把它们一个一个剥离出来用敏捷地重写，可以尝试最新的技术和语言和框架，然 后单独布署。它通常不依赖其他服务。微服务中常用的API Gateway的模式主要目的也不是重用代码，而是减少客户端和服务间的往来。API gateway模式不等同与Facade模式，我们可以使用如future之类的调用，甚至返回不完整数据。</p><p><strong>2、SOA喜欢水平服务，微服务喜欢垂直服务</strong></p><p><strong>SOA</strong> 设计喜欢给服务分层(如Service Layers模式)。我们常常见到一个Entity服务层的设计，美其名曰Data Access Layer。这种设计要求所有的服务都通过这个Entity服务层来获取数据。这种设计非常不灵活，比如每次数据层的改动都可能影响到所有业务层的服务。而每个微服务通常有它自己独立的data store。我们在拆分数据库时可以适当的做些去范式化(denormalization)，让它不需要依赖其他服务的数据。</p><p><strong>微服务</strong> 通常是直接面对用户的，每个微服务通常直接为用户提供某个功能。类似的功能可能针对手机有一个服务，针对机顶盒是另外一个服务。在SOA设计模式中这种情况通常会用到Multi-ChannelEndpoint的模式返回一个大而全的结果兼顾到所有的客户端的需求。</p><p><strong>3、SOA喜欢自上而下，微服务喜欢自下而上</strong></p><p><strong>SOA</strong> 架构在设计开始时会先定义好服务合同(service contract)。它喜欢集中管理所有的服务，包括集中管理业务逻辑，数据，流程，schema，等等。它使用Enterprise Inventory和Service Composition等方法来集中管理服务。SOA架构通常会预先把每个模块服务接口都定义好。模块系统间的通讯必须遵守这些接口，各服务是针对他们的调用者。</p><p>SOA架构适用于TOGAF之类的架构方法论。</p><p><strong>微服务</strong> 则敏捷得多。只要用户用得到，就先把这个服务挖出来。然后针对性的，快速确认业务需求，快速开发迭代。</p><h2 id="六、怎么具体实践微服务"><a href="#六、怎么具体实践微服务" class="headerlink" title="六、怎么具体实践微服务"></a><strong>六、怎么具体实践微服务</strong></h2><p>要实际的应用微服务，需要解决一下四点问题：</p><p>1、客户端如何访问这些服务</p><p>2、每个服务之间如何通信</p><p>3、如此多的服务，如何实现？</p><p>4、服务挂了，如何解决？（备份方案，应急处理机制）</p><h3 id="1、客户端如何访问这些服务"><a href="#1、客户端如何访问这些服务" class="headerlink" title="1、客户端如何访问这些服务"></a><strong>1、客户端如何访问这些服务</strong></h3><p>原来的Monolithic方式开发，所有的服务都是本地的，UI可以直接调用，现在按功能拆分成独立的服务，跑在独立的一般都在独立的虚拟机上的 Java进程了。客户端UI如何访问他的？</p><p>后台有N个服务，前台就需要记住管理N个服务，一个服务下线&#x2F;更新&#x2F;升级，前台就要重新部署，这明显不服务我们 拆分的理念，特别当前台是移动应用的时候，通常业务变化的节奏更快。</p><p>另外，N个小服务的调用也是一个不小的网络开销。还有一般微服务在系统内部，通常是无 状态的，用户登录信息和权限管理最好有一个统一的地方维护管理（OAuth）。</p><p>所以，一般在后台N个服务和UI之间一般会一个代理或者叫API Gateway，他的作用包括：</p><p>① 提供统一服务入口，让微服务对前台透明</p><p>② 聚合后台的服务，节省流量，提升性能</p><p>③ 提供安全，过滤，流控等API管理功能</p><p>其实这个API Gateway可以有很多广义的实现办法，可以是一个软硬一体的盒子，也可以是一个简单的MVC框架，甚至是一个Node.js的服务端。他们最重要的作 用是为前台（通常是移动应用）提供后台服务的聚合，提供一个统一的服务出口，解除他们之间的耦合，不过API Gateway也有可能成为单点故障点或者性能的瓶颈。</p><p>用过Taobao Open Platform（淘宝开放平台）的就能很容易的体会，TAO就是这个API Gateway。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403171344809.png"></p><h3 id="2、每个服务之间如何通信"><a href="#2、每个服务之间如何通信" class="headerlink" title="2、每个服务之间如何通信"></a><strong>2、每个服务之间如何通信</strong></h3><p>所有的微服务都是独立的Java进程跑在独立的虚拟机上，所以服务间的通信就是IPC（inter process communication），已经有很多成熟的方案。现在基本最通用的有两种方式：</p><p>同步调用：</p><p>①REST（JAX-RS，Spring Boot）</p><p>②RPC（Thrift, Dubbo）</p><p>异步消息调用(Kafka, Notify, MetaQ)</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403171344785.png"></p><p><strong>同步和异步的区别：</strong></p><p>一般同步调用比较简单，一致性强，但是容易出调用问题，性能体验上也会差些，特别是调用层次多的时候。RESTful和RPC的比较也是一个很有意 思的话题。</p><p>一般REST基于HTTP，更容易实现，更容易被接受，服务端实现技术也更灵活些，各个语言都能支持，同时能跨客户端，对客户端没有特殊的要求，只要封装了HTTP的SDK就能调用，所以相对使用的广一些。RPC也有自己的优点，传输协议更高效，安全更可控，特别在一个公司内部，如果有统一个 的开发规范和统一的服务框架时，他的开发效率优势更明显些。就看各自的技术积累实际条件，自己的选择了。</p><p>而异步消息的方式在分布式系统中有特别广泛的应用，他既能减低调用服务之间的耦合，又能成为调用之间的缓冲，确保消息积压不会冲垮被调用方，同时能保证调用方的服务体验，继续干自己该干的活，不至于被后台性能拖慢。不过需要付出的代价是一致性的减弱，需要接受数据最终一致性；还有就是后台服务一般要 实现幂等性，因为消息发送出于性能的考虑一般会有重复（保证消息的被收到且仅收到一次对性能是很大的考验）；最后就是必须引入一个独立的broker，如果公司内部没有技术积累，对broker分布式管理也是一个很大的挑战。</p><h3 id="3、如此多的服务，如何实现？"><a href="#3、如此多的服务，如何实现？" class="headerlink" title="3、如此多的服务，如何实现？"></a><strong>3、如此多的服务，如何实现？</strong></h3><p>在微服务架构中，一般每一个服务都是有多个拷贝，来做负载均衡。一个服务随时可能下线，也可能应对临时访问压力增加新的服务节点。服务之间如何相互感知？服务如何管理？</p><p>这就是服务发现的问题了。一般有两类做法，也各有优缺点。基本都是通过zookeeper等类似技术做服务注册信息的分布式管理。当服务上线时，服务提供者将自己的服务信息注册到ZK（或类似框架），并通过心跳维持长链接，实时更新链接信息。服务调用者通过ZK寻址，根据可定制算法， 找到一个服务，还可以将服务信息缓存在本地以提高性能。当服务下线时，ZK会发通知给服务客户端。</p><p><strong>客户端做：</strong> 优点是架构简单，扩展灵活，只对服务注册器依赖。缺点是客户端要维护所有调用服务的地址，有技术难度，一般大公司都有成熟的内部框架支持，比如Dubbo。</p><p><strong>服务端做：</strong> 优点是简单，所有服务对于前台调用方透明，一般在小公司在云服务上部署的应用采用的比较多。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403171345359.png"></p><h3 id="4、服务挂了，如何解决"><a href="#4、服务挂了，如何解决" class="headerlink" title="4、服务挂了，如何解决"></a><strong>4、服务挂了，如何解决</strong></h3><p>前面提到，Monolithic方式开发一个很大的风险是，把所有鸡蛋放在一个篮子里，一荣俱荣，一损俱损。而分布式最大的特性就是网络是不可靠的。通过微服务拆分能降低这个风险，不过如果没有特别的保障，结局肯定是噩梦。所以当我们的系统是由一系列的服务调用链组成的时候，我们必须确保任一环节出问题都不至于影响整体链路。<strong>相应的手段有很多：</strong></p><p>①重试机制</p><p>②限流</p><p>③熔断机制</p><p>④负载均衡</p><p>⑤降级（本地缓存）</p><p>这些方法基本都很明确通用，比如Netflix的Hystrix</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403171345494.png"></p><h2 id="七、常见的设计模式和应用"><a href="#七、常见的设计模式和应用" class="headerlink" title="七、常见的设计模式和应用"></a><strong>七、常见的设计模式和应用</strong></h2><h3 id="1、聚合器微服务设计模式"><a href="#1、聚合器微服务设计模式" class="headerlink" title="1、聚合器微服务设计模式"></a><strong>1、聚合器微服务设计模式</strong></h3><p>这是一种最常见也最简单的设计模式：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403171347078.png"></p><p>聚合器调用多个服务实现应用程序所需的功能。它可以是一个简单的Web页面，将检索到的数据进行处理展示。它也可以是一个更高层次的组合微服务，对检索到的数据增加业务逻辑后进一步发布成一个新的微服务，这符合DRY原则。另外，每个服务都有自己的缓存和数据库。如果聚合器是一个组合服务，那么它也有自己的缓存和数据库。聚合器可以沿X轴和Z轴独立扩展。</p><h3 id="2、代理微服务设计模式"><a href="#2、代理微服务设计模式" class="headerlink" title="2、代理微服务设计模式"></a><strong>2、代理微服务设计模式</strong></h3><p>这是聚合模式的一个变种，如下图所示：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403171347095.png"><br>在这种情况下，客户端并不聚合数据，但会根据业务需求的差别调用不同的微服务。代理可以仅仅委派请求，也可以进行数据转换工作。</p><h3 id="3、链式微服务设计模式"><a href="#3、链式微服务设计模式" class="headerlink" title="3、链式微服务设计模式"></a><strong>3、链式微服务设计模式</strong></h3><p>这种模式在接收到请求后会产生一个经过合并的响应，如下图所示：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403171348540.png"></p><p>在这种情况下，服务A接收到请求后会与服务B进行通信，类似地，服务B会同服务C进行通信。所有服务都使用同步消息传递。在整个链式调用完成之前，客户端会一直阻塞。</p><p>因此，服务调用链不宜过长，以免客户端长时间等待。</p><h3 id="4、分支微服务设计模式"><a href="#4、分支微服务设计模式" class="headerlink" title="4、分支微服务设计模式"></a><strong>4、分支微服务设计模式</strong></h3><p>这种模式是聚合器模式的扩展，允许同时调用两个微服务链，如下图所示：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403171348003.png"></p><h3 id="5、数据共享微服务设计模式"><a href="#5、数据共享微服务设计模式" class="headerlink" title="5、数据共享微服务设计模式"></a><strong>5、数据共享微服务设计模式</strong></h3><p>自治是微服务的设计原则之一，就是说微服务是全栈式服务。但在重构现有的“单体应用（monolithic application）”时，SQL数据库反规范化可能会导致数据重复和不一致。</p><p>因此，在单体应用到微服务架构的过渡阶段，可以使用这种设计模式，如下图所示：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403171348061.png"></p><p>在这种情况下，部分微服务可能会共享缓存和数据库存储。不过，这只有在两个服务之间存在强耦合关系时才可以。对于基于微服务的新建应用程序而言，这是一种反模式。</p><h3 id="6、异步消息传递微服务设计模式"><a href="#6、异步消息传递微服务设计模式" class="headerlink" title="6、异步消息传递微服务设计模式"></a><strong>6、异步消息传递微服务设计模式</strong></h3><p>虽然REST设计模式非常流行，但它是同步的，会造成阻塞。因此部分基于微服务的架构可能会选择使用消息队列代替REST请求&#x2F;响应，如下图所示：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403171349388.png"></p><h2 id="八、优点和缺点"><a href="#八、优点和缺点" class="headerlink" title="八、优点和缺点"></a><strong>八、优点和缺点</strong></h2><p><strong>1、微服务的优点：</strong></p><p><strong>关键点：</strong> 复杂度可控，独立按需扩展，技术选型灵活，容错，可用性高</p><p><strong>①</strong> 它解决了复杂性的问题。它会将一种怪异的整体应用程序分解成一组服务。虽然功能总量 不变，但应用程序已分解为可管理的块或服务。每个服务都以RPC或消息驱动的API的形式定义了一个明确的边界；Microservice架构模式实现了一个模块化水平。</p><p><strong>②</strong> 这种架构使每个服务都能够由专注于该服务的团队独立开发。开发人员可以自由选择任何有用的技术，只要该服务符合API合同。当然，大多数组织都希望避免完全无政府状态并限制技术选择。然而，这种自由意味着开发人员不再有义务使用在新项目开始时存在的可能过时的技术。在编写新服务时，他们可以选择使用当前的技术。此外，由于服务相对较小，因此使用当前技术重写旧服务变得可行。</p><p><strong>③</strong> Microservice架构模式使每个微服务都能独立部署。开发人员不需要协调部署本地服务的变更。这些变化可以在测试后尽快部署。例如，UI团队可以执行A | B测试，并快速迭代UI更改。Microservice架构模式使连续部署成为可能。</p><p><strong>④</strong> Microservice架构模式使每个服务都可以独立调整。您可以仅部署满足其容量和可用性限制的每个服务的实例数。此外，您可以使用最符合服务资源要求的硬件。</p><p><strong>2、微服务的缺点</strong></p><p><strong>关键点（挑战）：</strong> ，系统部署依赖，服务间通信成本，数据一致性，系统集成测试，重复工作，性能监控等</p><p><strong>①</strong> 一个缺点是名称本身。术语microservice过度强调服务规模。但重要的是要记住，这是一种手段，而不是主要目标。微服务的目标是充分分解应用程序，以便于敏捷应用程序开发和部署。</p><p><strong>②</strong> 微服务器的另一个主要缺点是分布式系统而产生的复杂性。开发人员需要选择和实现基于消息传递或RPC的进程间通信机制。此外，他们还必须编写代码来处理部分故障，因为请求的目的地可能很慢或不可用。</p><p><strong>③</strong> 微服务器的另一个挑战是分区数据库架构。更新多个业务实体的业务交易是相当普遍的。但是，在基于微服务器的应用程序中，您需要更新不同服务所拥有的多个数据库。使用分布式事务通常不是一个选择，而不仅仅是因为CAP定理。许多今天高度可扩展的NoSQL数据库都不支持它们。你最终不得不使用最终的一致性方法，这对开发人员来说更具挑战性。</p><p><strong>④</strong> 测试微服务应用程序也更复杂。服务类似的测试类将需要启动该服务及其所依赖的任何服务（或至少为这些服务配置存根）。再次，重要的是不要低估这样做的复杂性。</p><p><strong>⑤</strong> Microservice架构模式的另一个主要挑战是实现跨越多个服务的更改。例如，我们假设您正在实施一个需要更改服务A，B和C的故事，其中A取决于B和B取决于C.在单片应用程序中，您可以简单地更改相应的模块，整合更改，并一次性部署。相比之下，在Microservice架构模式中，您需要仔细规划和协调对每个服务的更改。例如，您需要更新服务C，然后更新服务B，然后再维修A.幸运的是，大多数更改通常仅影响一个服务，而需要协调的多服务变更相对较少。</p><p><strong>⑥</strong> 部署基于微服务的应用程序也更复杂。单一应用程序简单地部署在传统负载平衡器后面的一组相同的服务器上。每个应用程序实例都配置有基础架构服务（如数据库和消息代理）的位置（主机和端口）。相比之下，微服务应用通常由大量服务组成。例如，每个服务将有多个运行时实例。更多的移动部件需要进行配置，部署，扩展和监控。此外，您还需要实现服务发现机制，使服务能够发现需要与之通信的任何其他服务的位置（主机和端口）。传统的基于故障单和手动操作的方法无法扩展到这种复杂程度。因此，成功部署微服务应用程序需要开发人员更好地控制部署方法，并实现高水平的自动化。</p><p><strong>九、思考：意识的转变</strong></p><p>微服务对我们的思考，更多的是思维上的转变。对于微服务架构：<strong>技术上不是问题，意识比工具重要。</strong></p><p>关于微服务的几点设计出发点：</p><p>1、应用程序的核心是业务逻辑，按照业务或客户需求组织资源（这是最难的）</p><p>2、做有生命的产品，而不是项目</p><p>3、后台服务贯彻Single Responsibility Principle（单一职责原则）</p><p>4、VM-&gt;Docker （to PE）</p><p>5、DevOps (to PE)</p><p>同时，对于开发同学，有这么多的中间件和强大的PE支持固然是好事，我们也需要深入去了解这些中间件背后的原理，知其然知其所以然，在有限的技术资源如何通过开源技术实施微服务？</p><p>最后，一般提到微服务都离不开DevOps和Docker，理解 <strong>微服务架构是核心，devops和docker是工具，是手段。</strong></p>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>vue&amp;elementUI使用总结</title>
    <link href="/posts/888f2d51/"/>
    <url>/posts/888f2d51/</url>
    
    <content type="html"><![CDATA[<blockquote><p>由于工作需要，最近简单使用了vue参与了前端的开发工作，因为有Android开发经验，稍微补充了前端知识后，已经可以应对基础的后台管理项目需求开发了，基本掌握了vue的用法、element UI组件、路由组件、axios等。当然，目前是前端初学者，虽然只看了不到一周，至少能参与公司内部的后台管理前端开发需求了，还挺有自豪感的。简单总结下。</p></blockquote><hr><p>Vues一款用于构建用户界面的渐进式的JavaScript框架。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151728471.png"></p><h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151729541.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151729479.png"></p><h1 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h1><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151730577.png"></p><h2 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h2><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151730170.png"></p><h2 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h2><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151730509.png"></p><h2 id="v-if-amp-v-show"><a href="#v-if-amp-v-show" class="headerlink" title="v-if&amp;v-show"></a>v-if&amp;v-show</h2><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151731436.png"></p><h2 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h2><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151731708.png"></p><h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h2><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151732325.png"></p><h1 id="vue生命周期"><a href="#vue生命周期" class="headerlink" title="vue生命周期"></a>vue生命周期</h1><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151732617.png"></p><h1 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h1><p>Axios对原生Ajax进行了封装，简化书写，快速开发。</p><p>官网: <a href="https://www.axios-http.cn/">https://www.axios-http.cn/</a></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151734525.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151734234.png"></p><h1 id="Vue项目创建"><a href="#Vue项目创建" class="headerlink" title="Vue项目创建"></a>Vue项目创建</h1><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151735996.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151735533.png"></p><p>然后通过 <code>code .</code> 通过vscode打开当前项目。</p><h1 id="vue项目结构"><a href="#vue项目结构" class="headerlink" title="vue项目结构"></a>vue项目结构</h1><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151736513.png"></p><h1 id="项目启动"><a href="#项目启动" class="headerlink" title="项目启动"></a>项目启动</h1><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151736457.png"></p><h1 id="Vue开发流程"><a href="#Vue开发流程" class="headerlink" title="Vue开发流程"></a>Vue开发流程</h1><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151737741.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151737491.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151737613.png"></p><p><strong>重点就是编写.vue文件。</strong></p><h1 id="API-风格"><a href="#API-风格" class="headerlink" title="API 风格"></a>API 风格</h1><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151738494.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151738149.png"></p><h1 id="Element-Plus"><a href="#Element-Plus" class="headerlink" title="Element Plus"></a>Element Plus</h1><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151739356.png"></p><p>官网： <a href="https://element-plus.org/zh-CN/#/zh-CN">https://element-plus.org/zh-CN/#/zh-CN</a></p><p>这个就是一个前端UI组件库，看菜做饭，需要什么直接拿来用，调整成需求需要的形式即可。</p><h1 id="router组件"><a href="#router组件" class="headerlink" title="router组件"></a>router组件</h1><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151740663.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151740061.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151740956.png"></p><h1 id="Pinia状态管理库"><a href="#Pinia状态管理库" class="headerlink" title="Pinia状态管理库"></a>Pinia状态管理库</h1><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151741388.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151741400.png"></p><h1 id="Pinia持久化插件-persist"><a href="#Pinia持久化插件-persist" class="headerlink" title="Pinia持久化插件-persist"></a>Pinia持久化插件-persist</h1><p>网页一刷新，就不再携带Authorization，就会报错。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151742534.png"></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
      <tag>elementUI</tag>
      
      <tag>axios</tag>
      
      <tag>router</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重构法则节选(下)</title>
    <link href="/posts/915cdc75/"/>
    <url>/posts/915cdc75/</url>
    
    <content type="html"><![CDATA[<blockquote><p>重构，并不是额外动作，理应伴随开发流程。并不是无意义，如果只是堆积垃圾代码，迭代多次之后，可能原开发人员也会失去本来的方向。作为开发人员理应重视这样的份内之事。最近重读《重构-改善既有代码的设计》。还是觉得需要落到笔端，吃书也是一种学习方式吧，这里节选认为必要的内容，还是需要反复阅读才能理解其真意。学习重构，是为了减少重构。</p></blockquote><hr><h1 id="10-简化条件逻辑"><a href="#10-简化条件逻辑" class="headerlink" title="10.简化条件逻辑"></a>10.简化条件逻辑</h1><p>程序的大部分威力来自条件逻辑，但很不幸，程序的复杂度也大多来自条件逻辑。我经常借助重构把条件逻辑变得更容易理解。我常用分解条件表达式（260）处理复杂的条件表达式，用合并条件表达式（263）厘清逻辑组合。我会用以卫语句取代嵌套条件表达式（266）清晰表达“在主要处理逻辑之前先做检查”的意图。如果我发现一处 switch 逻辑处理了几种情况，可以考虑拿出以多态取代条件表达式（272）重构手法。</p><p>很多条件逻辑是用于处理特殊情况的，例如处理 null 值。如果对某种特殊情况的处理逻辑大多相同，那么可以用引入特例（289）（常被称作引入空对象）消除重复代码。另外，虽然我很喜欢去除条件逻辑，但如果我想明确地表述（以及检查）程序的状态，引入断言（302）是一个不错的补充。</p><h2 id="10-1-分解条件表达式（Decompose-Conditional）"><a href="#10-1-分解条件表达式（Decompose-Conditional）" class="headerlink" title="10.1 分解条件表达式（Decompose Conditional）"></a>10.1 分解条件表达式（Decompose Conditional）</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">if</span> (!aDate.is<span class="hljs-constructor">Before(<span class="hljs-params">plan</span>.<span class="hljs-params">summerStart</span>)</span> &amp;amp;&amp;amp; !aDate.is<span class="hljs-constructor">After(<span class="hljs-params">plan</span>.<span class="hljs-params">summerEnd</span>)</span>)<br> charge = quantity<span class="hljs-operator"> * </span>plan.summerRate;<br><span class="hljs-keyword">else</span><br> charge = quantity<span class="hljs-operator"> * </span>plan.regularRate + plan.regularServiceCharge;<br><br><br><span class="hljs-keyword">if</span> (summer<span class="hljs-literal">()</span>)<br> charge = summer<span class="hljs-constructor">Charge()</span>;<br><span class="hljs-keyword">else</span><br> charge = regular<span class="hljs-constructor">Charge()</span>;<br></code></pre></td></tr></table></figure><h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><p>程序之中，复杂的条件逻辑是最常导致复杂度上升的地点之一。我必须编写代码来检查不同的条件分支，根据不同的条件做不同的事，然后，我很快就会得到一个相当长的函数。大型函数本身就会使代码的可读性下降，而条件逻辑则会使代码更难阅读。在带有复杂条件逻辑的函数中，代码（包括检查条件分支的代码和真正实现功能的代码）会告诉我发生的事，但常常让我弄不清楚为什么会发生这样的事，这就说明代码的可读性的确大大降低了。</p><p>和任何大块头代码一样，我可以将它分解为多个独立的函数，根据每个小块代码的用途，为分解而得的新函数命名，并将原函数中对应的代码改为调用新函数，从而更清楚地表达自己的意图。对于条件逻辑，将每个分支条件分解成新函数还可以带来更多好处：可以突出条件逻辑，更清楚地表明每个分支的作用，并且突出每个分支的原因。</p><p>本重构手法其实只是提炼函数（106）的一个应用场景。但我要特别强调这个场景，因为我发现它经常会带来很大的价值。</p><h3 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h3><p>对条件判断和每个条件分支分别运用提炼函数（106）手法。</p><h3 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h3><p>假设我要计算购买某样商品的总价（总价&#x3D;数量 × 单价），而这个商品在冬季和夏季的单价是不同的：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">if</span> (!aDate.is<span class="hljs-constructor">Before(<span class="hljs-params">plan</span>.<span class="hljs-params">summerStart</span>)</span> &amp;amp;&amp;amp; !aDate.is<span class="hljs-constructor">After(<span class="hljs-params">plan</span>.<span class="hljs-params">summerEnd</span>)</span>)<br> charge = quantity<span class="hljs-operator"> * </span>plan.summerRate;<br><span class="hljs-keyword">else</span><br> charge = quantity<span class="hljs-operator"> * </span>plan.regularRate + plan.regularServiceCharge;<br></code></pre></td></tr></table></figure><p>我把条件判断提炼到一个独立的函数中：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">if</span> (summer<span class="hljs-literal">()</span>)<br> charge = quantity<span class="hljs-operator"> * </span>plan.summerRate;<br><span class="hljs-keyword">else</span><br> charge = quantity<span class="hljs-operator"> * </span>plan.regularRate + plan.regularServiceCharge;<br><br><span class="hljs-keyword">function</span> summer<span class="hljs-literal">()</span> &#123;<br> return !aDate.is<span class="hljs-constructor">Before(<span class="hljs-params">plan</span>.<span class="hljs-params">summerStart</span>)</span> &amp;amp;&amp;amp; !aDate.is<span class="hljs-constructor">After(<span class="hljs-params">plan</span>.<span class="hljs-params">summerEnd</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后提炼条件判断为真的分支：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">if</span> (summer())<br> charge = summerCharge();<br><span class="hljs-keyword">else</span><br> charge = quantity * plan.regularRate + plan.regularServiceCharge;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title">summer</span>() &#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-type">!aDate.isBefore(plan.summerStart)</span> &amp;amp;&amp;amp; !aDate.isAfter(plan.summerEnd);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title">summerCharge</span>() &#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-type">quantity</span> * plan.summerRate;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后提炼条件判断为假的分支：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">if</span> (summer())<br> charge = summerCharge();<br><span class="hljs-keyword">else</span><br> charge = regularCharge();<br><br><span class="hljs-keyword">function</span> <span class="hljs-title">summer</span>() &#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-type">!aDate.isBefore(plan.summerStart)</span> &amp;amp;&amp;amp; !aDate.isAfter(plan.summerEnd);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title">summerCharge</span>() &#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-type">quantity</span> * plan.summerRate;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title">regularCharge</span>() &#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-type">quantity</span> * plan.regularRate + plan.regularServiceCharge;<br>&#125;<br></code></pre></td></tr></table></figure><p>提炼完成后，我喜欢用三元运算符重新安排条件语句。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ada">  charge = summer() ? summerCharge() : <span class="hljs-type">regularCharge</span>();<br><br><span class="hljs-keyword">function</span> <span class="hljs-title">summer</span>() &#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-type">!aDate.isBefore(plan.summerStart)</span> &amp;amp;&amp;amp; !aDate.isAfter(plan.summerEnd);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title">summerCharge</span>() &#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-type">quantity</span> * plan.summerRate;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title">regularCharge</span>() &#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-type">quantity</span> * plan.regularRate + plan.regularServiceCharge;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="10-2-合并条件表达式（Consolidate-Conditional-Expression）"><a href="#10-2-合并条件表达式（Consolidate-Conditional-Expression）" class="headerlink" title="10.2 合并条件表达式（Consolidate Conditional Expression）"></a>10.2 合并条件表达式（Consolidate Conditional Expression）</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">if</span> (anEmployee.seniority &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (anEmployee.monthsDisabled &gt; <span class="hljs-number">12</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (anEmployee.isPartTime) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br><br><span class="hljs-keyword">if</span> (isNotEligibleForDisability()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>function isNotEligibleForDisability() &#123;<br> <span class="hljs-keyword">return</span> ((anEmployee.seniority &lt; <span class="hljs-number">2</span>)<br>     || (anEmployee.monthsDisabled &gt; <span class="hljs-number">12</span>)<br>     || (anEmployee.isPartTime));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="动机-1"><a href="#动机-1" class="headerlink" title="动机"></a>动机</h3><p>有时我会发现这样一串条件检查：检查条件各不相同，最终行为却一致。如果发现这种情况，就应该使用“逻辑或”和“逻辑与”将它们合并为一个条件表达式。</p><p>之所以要合并条件代码，有两个重要原因。首先，合并后的条件代码会表述“实际上只有一次条件检查，只不过有多个并列条件需要检查而已”，从而使这一次检查的用意更清晰。当然，合并前和合并后的代码有着相同的效果，但原先代码传达出的信息却是“这里有一些各自独立的条件测试，它们只是恰好同时发生”。其次，这项重构往往可以为使用提炼函数（106）做好准备。将检查条件提炼成一个独立的函数对于厘清代码意义非常有用，因为它把描述“做什么”的语句换成了“为什么这样做”。</p><p>条件语句的合并理由也同时指出了不要合并的理由：如果我认为这些检查的确彼此独立，的确不应该被视为同一次检查，我就不会使用本项重构。</p><h3 id="做法-1"><a href="#做法-1" class="headerlink" title="做法"></a>做法</h3><p>确定这些条件表达式都没有副作用。</p><p>如果某个条件表达式有副作用，可以先用将查询函数和修改函数分离（306）处理。</p><p>使用适当的逻辑运算符，将两个相关条件表达式合并为一个。</p><p>顺序执行的条件表达式用逻辑或来合并，嵌套的 if 语句用逻辑与来合并。</p><p>测试。</p><p>重复前面的合并过程，直到所有相关的条件表达式都合并到一起。</p><p>可以考虑对合并后的条件表达式实施提炼函数（106）。</p><h3 id="范例-1"><a href="#范例-1" class="headerlink" title="范例"></a>范例</h3><p>在走读代码的过程中，我看到了下面的代码片段：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">function disabilityAmount(anEmployee) &#123;<br> <span class="hljs-keyword">if</span> (anEmployee.seniority &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> <span class="hljs-keyword">if</span> (anEmployee.monthsDisabled &gt; <span class="hljs-number">12</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> <span class="hljs-keyword">if</span> (anEmployee.isPartTime) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> <span class="hljs-comment">// compute the disability amount</span><br></code></pre></td></tr></table></figure><p>这里有一连串的条件检查，都指向同样的结果。既然结果是相同的，就应该把这些条件检查合并成一条表达式。对于这样顺序执行的条件检查，可以用逻辑或运算符来合并。</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-variable">function</span> <span class="hljs-title function_">disabilityAmount</span>(<span class="hljs-params">anEmployee</span>) &#123;<br> <span class="hljs-keyword">if</span> ((<span class="hljs-variable">anEmployee</span>.<span class="hljs-property">seniority</span> <span class="hljs-operator">&lt;</span> <span class="hljs-number">2</span>)<br>   <span class="hljs-operator">||</span> (<span class="hljs-variable">anEmployee</span>.<span class="hljs-property">monthsDisabled</span> <span class="hljs-operator">&gt;</span> <span class="hljs-number">12</span>)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> <span class="hljs-keyword">if</span> (<span class="hljs-variable">anEmployee</span>.<span class="hljs-property">isPartTime</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> <span class="hljs-comment">// compute the disability amount</span><br></code></pre></td></tr></table></figure><p>测试，然后把下一个条件检查也合并进来：</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-variable">function</span> <span class="hljs-title function_">disabilityAmount</span>(<span class="hljs-params">anEmployee</span>) &#123;<br> <span class="hljs-keyword">if</span> ((<span class="hljs-variable">anEmployee</span>.<span class="hljs-property">seniority</span> <span class="hljs-operator">&lt;</span> <span class="hljs-number">2</span>)<br>   <span class="hljs-operator">||</span> (<span class="hljs-variable">anEmployee</span>.<span class="hljs-property">monthsDisabled</span> <span class="hljs-operator">&gt;</span> <span class="hljs-number">12</span>)<br>   <span class="hljs-operator">||</span> (<span class="hljs-variable">anEmployee</span>.<span class="hljs-property">isPartTime</span>)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> <span class="hljs-comment">// compute the disability amount</span><br></code></pre></td></tr></table></figure><p>合并完成后，再对这句条件表达式使用提炼函数（106）。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">disabilityAmount</span>(anEmployee) &#123;<br> if (<span class="hljs-keyword">is</span>NotEligableForDisability()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> // compute the disability amount<br><br><span class="hljs-keyword">function</span> <span class="hljs-title">isNotEligableForDisability</span>() &#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-type">((anEmployee.seniority</span> &lt; <span class="hljs-number">2</span>)<br>     || (anEmployee.monthsDisabled &gt; <span class="hljs-number">12</span>)<br>     || (anEmployee.isPartTime));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="范例：使用逻辑与"><a href="#范例：使用逻辑与" class="headerlink" title="范例：使用逻辑与"></a>范例：使用逻辑与</h3><p>上面的例子展示了用逻辑或合并条件表达式的做法。不过，我有可能遇到需要逻辑与的情况。例如，嵌套 if 语句的情况：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">if</span> (anEmployee.onVacation)<br> <span class="hljs-attribute">if</span> (anEmployee.seniority &gt; <span class="hljs-number">10</span>)<br>  <span class="hljs-attribute">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-attribute">return</span> <span class="hljs-number">0</span>.<span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><p>可以用逻辑与运算符将其合并。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">if</span> ((anEmployee.onVacation)<br>  &amp;amp;&amp;amp; (anEmployee.seniority &gt; <span class="hljs-number">10</span>)) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0.5</span>;<br></code></pre></td></tr></table></figure><p>如果原来的条件逻辑混杂了这两种情况，我也会根据需要组合使用逻辑与和逻辑或运算符。在这种时候，代码很可能变得混乱，所以我会频繁使用提炼函数（106），把代码变得可读。</p><h2 id="10-3-以卫语句取代嵌套条件表达式（Replace-Nested-Conditional-with-Guard-Clauses）"><a href="#10-3-以卫语句取代嵌套条件表达式（Replace-Nested-Conditional-with-Guard-Clauses）" class="headerlink" title="10.3 以卫语句取代嵌套条件表达式（Replace Nested Conditional with Guard Clauses）"></a>10.3 以卫语句取代嵌套条件表达式（Replace Nested Conditional with Guard Clauses）</h2><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">function</span> <span class="hljs-function"><span class="hljs-title">getPayAmount</span>() &#123;</span><br><span class="hljs-function">  <span class="hljs-variable">let</span> <span class="hljs-variable"><span class="hljs-class">result</span></span>;</span><br><span class="hljs-function">  <span class="hljs-variable"><span class="hljs-keyword">if</span></span> (<span class="hljs-variable">isDead</span>) <span class="hljs-variable"><span class="hljs-class">result</span></span> = <span class="hljs-title">deadAmount</span>();</span><br><span class="hljs-function">  <span class="hljs-variable"><span class="hljs-keyword">else</span></span> &#123;</span><br><span class="hljs-function">    <span class="hljs-variable"><span class="hljs-keyword">if</span></span> (<span class="hljs-variable">isSeparated</span>) <span class="hljs-variable"><span class="hljs-class">result</span></span> = <span class="hljs-title">separatedAmount</span>();</span><br><span class="hljs-function">    <span class="hljs-variable"><span class="hljs-keyword">else</span></span> &#123;</span><br><span class="hljs-function">      <span class="hljs-variable"><span class="hljs-keyword">if</span></span> (<span class="hljs-variable">isRetired</span>) <span class="hljs-variable"><span class="hljs-class">result</span></span> = <span class="hljs-title">retiredAmount</span>();</span><br><span class="hljs-function">      <span class="hljs-variable"><span class="hljs-keyword">else</span></span> <span class="hljs-variable"><span class="hljs-class">result</span></span> = <span class="hljs-title">normalPayAmount</span>();</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function">  &#125;</span><br><span class="hljs-function">  <span class="hljs-variable">return</span> <span class="hljs-variable"><span class="hljs-class">result</span></span>;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-variable">function</span> <span class="hljs-title">getPayAmount</span>() &#123;</span><br><span class="hljs-function">  <span class="hljs-variable"><span class="hljs-keyword">if</span></span> (<span class="hljs-variable">isDead</span>) <span class="hljs-variable">return</span> <span class="hljs-title">deadAmount</span>();</span><br><span class="hljs-function">  <span class="hljs-variable"><span class="hljs-keyword">if</span></span> (<span class="hljs-variable">isSeparated</span>) <span class="hljs-variable">return</span> <span class="hljs-title">separatedAmount</span>();</span><br><span class="hljs-function">  <span class="hljs-variable"><span class="hljs-keyword">if</span></span> (<span class="hljs-variable">isRetired</span>) <span class="hljs-variable">return</span> <span class="hljs-title">retiredAmount</span>();</span><br><span class="hljs-function">  <span class="hljs-variable">return</span> <span class="hljs-title">normalPayAmount</span>();</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="动机-2"><a href="#动机-2" class="headerlink" title="动机"></a>动机</h3><p>根据我的经验，条件表达式通常有两种风格。第一种风格是：两个条件分支都属于正常行为。第二种风格则是：只有一个条件分支是正常行为，另一个分支则是异常的情况。</p><p>这两类条件表达式有不同的用途，这一点应该通过代码表现出来。如果两条分支都是正常行为，就应该使用形如 if…else…的条件表达式；如果某个条件极其罕见，就应该单独检查该条件，并在该条件为真时立刻从函数中返回。这样的单独检查常常被称为“卫语句”（guard clauses）。</p><p>以卫语句取代嵌套条件表达式的精髓就是：给某一条分支以特别的重视。如果使用 if-then-else 结构，你对 if 分支和 else 分支的重视是同等的。这样的代码结构传递给阅读者的消息就是：各个分支有同样的重要性。卫语句就不同了，它告诉阅读者：“这种情况不是本函数的核心逻辑所关心的，如果它真发生了，请做一些必要的整理工作，然后退出。”</p><p>“每个函数只能有一个入口和一个出口”的观念，根深蒂固于某些程序员的脑海里。我发现，当我处理他们编写的代码时，经常需要使用以卫语句取代嵌套条件表达式。现今的编程语言都会强制保证每个函数只有一个入口，至于“单一出口”规则，其实不是那么有用。在我看来，保持代码清晰才是最关键的：如果单一出口能使这个函数更清楚易读，那么就使用单一出口；否则就不必这么做。</p><h3 id="做法-2"><a href="#做法-2" class="headerlink" title="做法"></a>做法</h3><p>选中最外层需要被替换的条件逻辑，将其替换为卫语句。</p><p>测试。</p><p>有需要的话，重复上述步骤。</p><p>如果所有卫语句都引发同样的结果，可以使用合并条件表达式（263）合并之。</p><h3 id="范例-2"><a href="#范例-2" class="headerlink" title="范例"></a>范例</h3><p>下面的代码用于计算要支付给员工（employee）的工资。只有还在公司上班的员工才需要支付工资，所以这个函数需要检查两种“员工已经不在公司上班”的情况。</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs nim">function payAmount(employee) &#123;<br> <span class="hljs-keyword">let</span> <span class="hljs-built_in">result</span>;<br> <span class="hljs-keyword">if</span>(employee.isSeparated) &#123;<br>  <span class="hljs-built_in">result</span> = &#123;amount: <span class="hljs-number">0</span>, reasonCode:<span class="hljs-string">&quot;SEP&quot;</span>&#125;;<br> &#125;<br> <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-keyword">if</span> (employee.isRetired) &#123;<br>   <span class="hljs-built_in">result</span> = &#123;amount: <span class="hljs-number">0</span>, reasonCode: <span class="hljs-string">&quot;RET&quot;</span>&#125;;<br>  &#125;<br>  <span class="hljs-keyword">else</span> &#123;<br>   // logic to compute amount<br>   lorem.ipsum(dolor.sitAmet);<span class="hljs-number">1</span><br>   consectetur(adipiscing).elit();<br>   sed.<span class="hljs-keyword">do</span>.eiusmod = tempor.incididunt.ut(labore) &amp;amp;&amp;amp; dolore(magna.aliqua);<br>   ut.enim.ad(minim.veniam);<br>   <span class="hljs-built_in">result</span> = someFinalComputation();<br>  &#125;<br> &#125;<br> <span class="hljs-keyword">return</span> <span class="hljs-built_in">result</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>嵌套的条件逻辑让我们看不清代码真实的含义。只有当前两个条件表达式都不为真的时候，这段代码才真正开始它的主要工作。所以，卫语句能让代码更清晰地阐述自己的意图。</p><p>一如既往地，我喜欢小步前进，所以我先处理最顶上的条件逻辑。</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs nim">function payAmount(employee) &#123;<br> <span class="hljs-keyword">let</span> <span class="hljs-built_in">result</span>;<br> <span class="hljs-keyword">if</span> (employee.isSeparated) <span class="hljs-keyword">return</span> &#123;amount: <span class="hljs-number">0</span>, reasonCode: <span class="hljs-string">&quot;SEP&quot;</span>&#125;;<br> <span class="hljs-keyword">if</span> (employee.isRetired) &#123;<br>  <span class="hljs-built_in">result</span> = &#123;amount: <span class="hljs-number">0</span>, reasonCode: <span class="hljs-string">&quot;RET&quot;</span>&#125;;<br> &#125;<br> <span class="hljs-keyword">else</span> &#123;<br>  // logic to compute amount<br>  lorem.ipsum(dolor.sitAmet);<br>  consectetur(adipiscing).elit();<br>  sed.<span class="hljs-keyword">do</span>.eiusmod = tempor.incididunt.ut(labore) &amp;amp;&amp;amp; dolore(magna.aliqua);<br>  ut.enim.ad(minim.veniam);<br>  <span class="hljs-built_in">result</span> = someFinalComputation();<br> &#125;<br> <span class="hljs-keyword">return</span> <span class="hljs-built_in">result</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>做完这步修改，我执行测试，然后继续下一步。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">function payAmount(employee) &#123;<br> let result;<br> <span class="hljs-keyword">if</span> (employee.isSeparated) <span class="hljs-keyword">return</span> &#123;amount: <span class="hljs-number">0</span>, reasonCode: <span class="hljs-string">&quot;SEP&quot;</span>&#125;;<br> <span class="hljs-keyword">if</span> (employee.isRetired)   <span class="hljs-keyword">return</span> &#123;amount: <span class="hljs-number">0</span>, reasonCode: <span class="hljs-string">&quot;RET&quot;</span>&#125;;<br> <span class="hljs-comment">// logic to compute amount</span><br> lorem.ipsum(dolor.sitAmet);<br> consectetur(adipiscing).elit();<br> sed.<span class="hljs-keyword">do</span>.eiusmod = tempor.incididunt.ut(labore) &amp;amp;&amp;amp; dolore(magna.aliqua);<br> ut.enim.ad(minim.veniam);<br> result = someFinalComputation();<br> <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时，result 变量已经没有用处了，所以我把它删掉：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">function payAmount(employee) &#123;<br> let result;<br> <span class="hljs-keyword">if</span> (employee.isSeparated) <span class="hljs-keyword">return</span> &#123;amount: <span class="hljs-number">0</span>, reasonCode: <span class="hljs-string">&quot;SEP&quot;</span>&#125;;<br> <span class="hljs-keyword">if</span> (employee.isRetired)   <span class="hljs-keyword">return</span> &#123;amount: <span class="hljs-number">0</span>, reasonCode: <span class="hljs-string">&quot;RET&quot;</span>&#125;;<br> <span class="hljs-comment">// logic to compute amount</span><br> lorem.ipsum(dolor.sitAmet);<br> consectetur(adipiscing).elit();<br> sed.<span class="hljs-keyword">do</span>.eiusmod = tempor.incididunt.ut(labore) &amp;amp;&amp;amp; dolore(magna.aliqua);<br> ut.enim.ad(minim.veniam);<br> <span class="hljs-keyword">return</span> someFinalComputation();<br>&#125;<br></code></pre></td></tr></table></figure><p>能减少一个可变变量总是好的。</p><h3 id="范例：将条件反转"><a href="#范例：将条件反转" class="headerlink" title="范例：将条件反转"></a>范例：将条件反转</h3><p>审阅本书第 1 版的初稿时，Joshua Kerievsky 指出：我们常常可以将条件表达式反转，从而实现以卫语句取代嵌套条件表达式。为了拯救我可怜的想象力，他还好心帮我想了一个例子：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">adjustedCapital</span>(anInstrument) &#123;<br> let result = 0;<br> if (anInstrument.capital &gt; 0) &#123;<br>  if (anInstrument.interestRate &gt; 0 &amp;amp;&amp;amp; anInstrument.duration &gt; 0) &#123;<br>   result = (anInstrument.income / anInstrument.duration) * anInstrument.adjustmentFactor;<br>  &#125;<br> &#125;<br> <span class="hljs-keyword">return</span> <span class="hljs-type">result</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样地，我逐一进行替换。不过这次在插入卫语句时，我需要将相应的条件反转过来：</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nim">function adjustedCapital(anInstrument) &#123;<br> <span class="hljs-keyword">let</span> <span class="hljs-built_in">result</span> = <span class="hljs-number">0</span>;<br> <span class="hljs-keyword">if</span> (anInstrument.capital &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">result</span>;<br> <span class="hljs-keyword">if</span> (anInstrument.interestRate &gt; <span class="hljs-number">0</span> &amp;amp;&amp;amp; anInstrument.duration &gt; <span class="hljs-number">0</span>) &#123;<br>  <span class="hljs-built_in">result</span> = (anInstrument.income / anInstrument.duration) * anInstrument.adjustmentFactor;<br> &#125;<br> <span class="hljs-keyword">return</span> <span class="hljs-built_in">result</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>下一个条件稍微复杂一点，所以我分两步进行反转。首先加入一个逻辑非操作：</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nim">function adjustedCapital(anInstrument) &#123;<br> <span class="hljs-keyword">let</span> <span class="hljs-built_in">result</span> = <span class="hljs-number">0</span>;<br> <span class="hljs-keyword">if</span> (anInstrument.capital &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">result</span>;<br> <span class="hljs-keyword">if</span> (!(anInstrument.interestRate &gt; <span class="hljs-number">0</span> &amp;amp;&amp;amp; anInstrument.duration &gt; <span class="hljs-number">0</span>)) <span class="hljs-keyword">return</span> <span class="hljs-built_in">result</span>;<br> <span class="hljs-built_in">result</span> = (anInstrument.income / anInstrument.duration) * anInstrument.adjustmentFactor;<br> <span class="hljs-keyword">return</span> <span class="hljs-built_in">result</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是在这样的条件表达式中留下一个逻辑非，会把我的脑袋拧成一团乱麻，所以我把它简化成下面这样：</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nim">  function adjustedCapital(anInstrument) &#123;<br> <span class="hljs-keyword">let</span> <span class="hljs-built_in">result</span> = <span class="hljs-number">0</span>;<br> <span class="hljs-keyword">if</span> (anInstrument.capital &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">result</span>;<br> <span class="hljs-keyword">if</span> (anInstrument.interestRate &lt;= <span class="hljs-number">0</span> || anInstrument.duration &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">result</span>;<br> <span class="hljs-built_in">result</span> = (anInstrument.income / anInstrument.duration) * anInstrument.adjustmentFactor;<br> <span class="hljs-keyword">return</span> <span class="hljs-built_in">result</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这两行逻辑语句引发的结果一样，所以我可以用合并条件表达式（263）将其合并。</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nim">function adjustedCapital(anInstrument) &#123;<br> <span class="hljs-keyword">let</span> <span class="hljs-built_in">result</span> = <span class="hljs-number">0</span>;<br> <span class="hljs-keyword">if</span> (   anInstrument.capital      &lt;= <span class="hljs-number">0</span><br>   || anInstrument.interestRate &lt;= <span class="hljs-number">0</span><br>   || anInstrument.duration     &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">result</span>;<br> <span class="hljs-built_in">result</span> = (anInstrument.income / anInstrument.duration) * anInstrument.adjustmentFactor;<br> <span class="hljs-keyword">return</span> <span class="hljs-built_in">result</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时 result 变量做了两件事：一开始我把它设为 0，代表卫语句被触发时的返回值；然后又用最终计算的结果给它赋值。我可以彻底移除这个变量，避免用一个变量承担两重责任，而且又减少了一个可变变量。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">adjustedCapital</span>(anInstrument) &#123;<br> if (   anInstrument.capital     &lt;= 0<br>   || anInstrument.interestRate &lt;= 0<br>   || anInstrument.duration   &lt;= 0) <span class="hljs-keyword">return</span> <span class="hljs-type">0</span>;<br> <span class="hljs-keyword">return</span> (anInstrument.income / anInstrument.duration) * anInstrument.adjustmentFactor;<br>&#125;<br></code></pre></td></tr></table></figure><p>1 “lorem.ipsum……”是一篇常见于排版设计领域的文章，其内容为不具可读性的字符组合，目的是使阅读者只专注于观察段落的字型和版型。——译者注</p><h2 id="10-4-以多态取代条件表达式（Replace-Conditional-with-Polymorphism）"><a href="#10-4-以多态取代条件表达式（Replace-Conditional-with-Polymorphism）" class="headerlink" title="10.4 以多态取代条件表达式（Replace Conditional with Polymorphism）"></a>10.4 以多态取代条件表达式（Replace Conditional with Polymorphism）</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">switch (bird.type) &#123;<br> case <span class="hljs-string">&#x27;EuropeanSwallow&#x27;</span>:<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;average&quot;</span>;<br> case <span class="hljs-string">&#x27;AfricanSwallow&#x27;</span>:<br>  <span class="hljs-keyword">return</span> (bird.numberOfCoconuts &gt; <span class="hljs-number">2</span>) ? <span class="hljs-string">&quot;tired&quot;</span> : <span class="hljs-string">&quot;average&quot;</span>;<br> case <span class="hljs-string">&#x27;NorwegianBlueParrot&#x27;</span>:<br>  <span class="hljs-keyword">return</span> (bird.voltage &gt; <span class="hljs-number">100</span>) ? <span class="hljs-string">&quot;scorched&quot;</span> : <span class="hljs-string">&quot;beautiful&quot;</span>;<br> default:<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;unknown&quot;</span>;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EuropeanSwallow</span> &#123;<br> <span class="hljs-keyword">get</span> plumage() &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;average&quot;</span>;<br> &#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AfricanSwallow</span> &#123;<br> <span class="hljs-keyword">get</span> plumage() &#123;<br>   <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.numberOfCoconuts &gt; <span class="hljs-number">2</span>) ? <span class="hljs-string">&quot;tired&quot;</span> : <span class="hljs-string">&quot;average&quot;</span>;<br> &#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NorwegianBlueParrot</span> &#123;<br> <span class="hljs-keyword">get</span> plumage() &#123;<br>   <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.voltage &gt; <span class="hljs-number">100</span>) ? <span class="hljs-string">&quot;scorched&quot;</span> : <span class="hljs-string">&quot;beautiful&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="动机-3"><a href="#动机-3" class="headerlink" title="动机"></a>动机</h3><p>复杂的条件逻辑是编程中最难理解的东西之一，因此我一直在寻求给条件逻辑添加结构。很多时候，我发现可以将条件逻辑拆分到不同的场景（或者叫高阶用例），从而拆解复杂的条件逻辑。这种拆分有时用条件逻辑本身的结构就足以表达，但使用类和多态能把逻辑的拆分表述得更清晰。</p><p>一个常见的场景是：我可以构造一组类型，每个类型处理各自的一种条件逻辑。例如，我会注意到，图书、音乐、食品的处理方式不同，这是因为它们分属不同类型的商品。最明显的征兆就是有好几个函数都有基于类型代码的 switch 语句。若果真如此，我就可以针对 switch 语句中的每种分支逻辑创建一个类，用多态来承载各个类型特有的行为，从而去除重复的分支逻辑。</p><p>另一种情况是：有一个基础逻辑，在其上又有一些变体。基础逻辑可能是最常用的，也可能是最简单的。我可以把基础逻辑放进超类，这样我可以首先理解这部分逻辑，暂时不管各种变体，然后我可以把每种变体逻辑单独放进一个子类，其中的代码着重强调与基础逻辑的差异。</p><p>多态是面向对象编程的关键特性之一。跟其他一切有用的特性一样，它也很容易被滥用。我曾经遇到有人争论说所有条件逻辑都应该用多态取代。我不赞同这种观点。我的大部分条件逻辑只用到了基本的条件语句——if&#x2F;else 和 switch&#x2F;case，并不需要劳师动众地引入多态。但如果发现如前所述的复杂条件逻辑，多态是改善这种情况的有力工具。</p><h3 id="做法-3"><a href="#做法-3" class="headerlink" title="做法"></a>做法</h3><p>如果现有的类尚不具备多态行为，就用工厂函数创建之，令工厂函数返回恰当的对象实例。</p><p>在调用方代码中使用工厂函数获得对象实例。</p><p>将带有条件逻辑的函数移到超类中。</p><p>如果条件逻辑还未提炼至独立的函数，首先对其使用提炼函数（106）。</p><p>任选一个子类，在其中建立一个函数，使之覆写超类中容纳条件表达式的那个函数。将与该子类相关的条件表达式分支复制到新函数中，并对它进行适当调整。</p><p>重复上述过程，处理其他条件分支。</p><p>在超类函数中保留默认情况的逻辑。或者，如果超类应该是抽象的，就把该函数声明为 abstract，或在其中直接抛出异常，表明计算责任都在子类中。</p><h3 id="范例-3"><a href="#范例-3" class="headerlink" title="范例"></a>范例</h3><p>我的朋友有一群鸟儿，他想知道这些鸟飞得有多快，以及它们的羽毛是什么样的。所以我们写了一小段程序来判断这些信息。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">plumages</span>(<span class="hljs-params">birds</span>) &#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>(birds.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">b</span> =&gt;</span> [b.<span class="hljs-property">name</span>, <span class="hljs-title function_">plumage</span>(b)]));<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">speeds</span>(<span class="hljs-params">birds</span>) &#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>(birds.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">b</span> =&gt;</span> [b.<span class="hljs-property">name</span>, <span class="hljs-title function_">airSpeedVelocity</span>(b)]));<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">plumage</span>(<span class="hljs-params">bird</span>) &#123;<br> <span class="hljs-keyword">switch</span> (bird.<span class="hljs-property">type</span>) &#123;<br> <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;EuropeanSwallow&#x27;</span>:<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;average&quot;</span>;<br> <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;AfricanSwallow&#x27;</span>:<br>  <span class="hljs-keyword">return</span> (bird.<span class="hljs-property">numberOfCoconuts</span> &gt; <span class="hljs-number">2</span>) ? <span class="hljs-string">&quot;tired&quot;</span> : <span class="hljs-string">&quot;average&quot;</span>;<br> <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;NorwegianBlueParrot&#x27;</span>:<br>  <span class="hljs-keyword">return</span> (bird.<span class="hljs-property">voltage</span> &gt; <span class="hljs-number">100</span>) ? <span class="hljs-string">&quot;scorched&quot;</span> : <span class="hljs-string">&quot;beautiful&quot;</span>;<br> <span class="hljs-attr">default</span>:<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;unknown&quot;</span>;<br> &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">airSpeedVelocity</span>(<span class="hljs-params">bird</span>) &#123;<br> <span class="hljs-keyword">switch</span> (bird.<span class="hljs-property">type</span>) &#123;<br> <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;EuropeanSwallow&#x27;</span>:<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">35</span>;<br> <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;AfricanSwallow&#x27;</span>:<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">40</span> - <span class="hljs-number">2</span> * bird.<span class="hljs-property">numberOfCoconuts</span>;<br> <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;NorwegianBlueParrot&#x27;</span>:<br>  <span class="hljs-keyword">return</span> (bird.<span class="hljs-property">isNailed</span>) ? <span class="hljs-number">0</span> : <span class="hljs-number">10</span> + bird.<span class="hljs-property">voltage</span> / <span class="hljs-number">10</span>;<br> <span class="hljs-attr">default</span>:<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>有两个不同的操作，其行为都随着“鸟的类型”发生变化，因此可以创建出对应的类，用多态来处理各类型特有的行为。</p><p>我先对 airSpeedVelocity 和 plumage 两个函数使用函数组合成类（144）。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">function plumage(bird) &#123;<br> <span class="hljs-keyword">return</span> new Bird(bird).plumage;<br>&#125;<br><br>function airSpeedVelocity(bird) &#123;<br> <span class="hljs-keyword">return</span> new Bird(bird).airSpeedVelocity;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bird</span> &#123;<br> <span class="hljs-keyword">constructor</span>(birdObject) &#123;<br>  Object.assign(<span class="hljs-keyword">this</span>, birdObject);<br> &#125;<br> <span class="hljs-keyword">get</span> plumage() &#123;<br>  switch (<span class="hljs-keyword">this</span>.type) &#123;<br>  case <span class="hljs-string">&#x27;EuropeanSwallow&#x27;</span>:<br>   <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;average&quot;</span>;<br>  case <span class="hljs-string">&#x27;AfricanSwallow&#x27;</span>:<br>   <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.numberOfCoconuts &gt; <span class="hljs-number">2</span>) ? <span class="hljs-string">&quot;tired&quot;</span> : <span class="hljs-string">&quot;average&quot;</span>;<br>  case <span class="hljs-string">&#x27;NorwegianBlueParrot&#x27;</span>:<br>   <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.voltage &gt; <span class="hljs-number">100</span>) ? <span class="hljs-string">&quot;scorched&quot;</span> : <span class="hljs-string">&quot;beautiful&quot;</span>;<br>  default:<br>   <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;unknown&quot;</span>;<br>  &#125;<br> &#125;<br> <span class="hljs-keyword">get</span> airSpeedVelocity() &#123;<br>  switch (<span class="hljs-keyword">this</span>.type) &#123;<br>  case <span class="hljs-string">&#x27;EuropeanSwallow&#x27;</span>:<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">35</span>;<br>  case <span class="hljs-string">&#x27;AfricanSwallow&#x27;</span>:<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">40</span> - <span class="hljs-number">2</span> * <span class="hljs-keyword">this</span>.numberOfCoconuts;<br>  case <span class="hljs-string">&#x27;NorwegianBlueParrot&#x27;</span>:<br>   <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.isNailed) ? <span class="hljs-number">0</span> : <span class="hljs-number">10</span> + <span class="hljs-keyword">this</span>.voltage / <span class="hljs-number">10</span>;<br>  default:<br>   <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后针对每种鸟创建一个子类，用一个工厂函数来实例化合适的子类对象。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs scala">function plumage(bird) &#123;<br>  <span class="hljs-keyword">return</span> createBird(bird).plumage;<br>&#125;<br><br>function airSpeedVelocity(bird) &#123;<br>  <span class="hljs-keyword">return</span> createBird(bird).airSpeedVelocity;<br>&#125;<br><br>function createBird(bird) &#123;<br>  switch (bird.<span class="hljs-keyword">type</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;EuropeanSwallow&quot;</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">EuropeanSwallow</span>(bird);<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;AfricanSwallow&quot;</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">AfricanSwallow</span>(bird);<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;NorweigianBlueParrot&quot;</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">NorwegianBlueParrot</span>(bird);<br>    <span class="hljs-keyword">default</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">Bird</span>(bird);<br>  &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EuropeanSwallow</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Bird</span> </span>&#123;&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AfricanSwallow</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Bird</span> </span>&#123;&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NorwegianBlueParrot</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Bird</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>现在我已经有了需要的类结构，可以处理两个条件逻辑了。先从 plumage 函数开始，我从 switch 语句中选一个分支，在适当的子类中覆写这个逻辑。</p><p><strong>class EuropeanSwallow…</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">get</span> <span class="hljs-title">plumage</span>()</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;average&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>class Bird…</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">get</span> <span class="hljs-title">plumage</span>()</span> &#123;<br> <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">this</span>.type) &#123;<br> <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;EuropeanSwallow&#x27;</span>:<br>  <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;oops&quot;</span>;<br> <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;AfricanSwallow&#x27;</span>:<br>  <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.numberOfCoconuts &gt; <span class="hljs-number">2</span>) ? <span class="hljs-string">&quot;tired&quot;</span> : <span class="hljs-string">&quot;average&quot;</span>;<br> <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;NorwegianBlueParrot&#x27;</span>:<br>  <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.voltage &gt; <span class="hljs-number">100</span>) ? <span class="hljs-string">&quot;scorched&quot;</span> : <span class="hljs-string">&quot;beautiful&quot;</span>;<br> <span class="hljs-literal">default</span>:<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;unknown&quot;</span>;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在超类中，我把对应的逻辑分支改为抛出异常，因为我总是偏执地担心出错。</p><p>此时我就可以编译并测试。如果一切顺利的话，我可以接着处理下一个分支。</p><p><strong>class AfricanSwallow…</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">get</span> <span class="hljs-title">plumage</span>()</span> &#123;<br>   <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.numberOfCoconuts &gt; <span class="hljs-number">2</span>) ? <span class="hljs-string">&quot;tired&quot;</span> : <span class="hljs-string">&quot;average&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后是挪威蓝鹦鹉（Norwegian Blue）的分支。</p><p><strong>class NorwegianBlueParrot…</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">get</span> <span class="hljs-title">plumage</span>()</span> &#123;<br>   <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.voltage &gt;<span class="hljs-number">100</span>) ? <span class="hljs-string">&quot;scorched&quot;</span> : <span class="hljs-string">&quot;beautiful&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>超类函数保留下来处理默认情况。</p><p><strong>class Bird…</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">get</span> <span class="hljs-title">plumage</span>()</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;unknown&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>airSpeedVelocity 也如法炮制。完成以后，代码大致如下（我还对顶层的 airSpeedVelocity 和 plumage 函数做了内联处理）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">plumages</span>(<span class="hljs-params">birds</span>) &#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>(birds<br>         .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">b</span> =&gt;</span> <span class="hljs-title function_">createBird</span>(b))<br>         .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">bird</span> =&gt;</span> [bird.<span class="hljs-property">name</span>, bird.<span class="hljs-property">plumage</span>]));<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">speeds</span>(<span class="hljs-params">birds</span>) &#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>(birds<br>         .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">b</span> =&gt;</span> <span class="hljs-title function_">createBird</span>(b))<br>         .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">bird</span> =&gt;</span> [bird.<span class="hljs-property">name</span>, bird.<span class="hljs-property">airSpeedVelocity</span>]));<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createBird</span>(<span class="hljs-params">bird</span>) &#123;<br> <span class="hljs-keyword">switch</span> (bird.<span class="hljs-property">type</span>) &#123;<br> <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;EuropeanSwallow&#x27;</span>:<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EuropeanSwallow</span>(bird);<br> <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;AfricanSwallow&#x27;</span>:<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AfricanSwallow</span>(bird);<br> <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;NorwegianBlueParrot&#x27;</span>:<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NorwegianBlueParrot</span>(bird);<br> <span class="hljs-attr">default</span>:<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bird</span>(bird);<br> &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bird</span> &#123;<br> <span class="hljs-title function_">constructor</span>(<span class="hljs-params">birdObject</span>) &#123;<br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(<span class="hljs-variable language_">this</span>, birdObject);<br> &#125;<br> <span class="hljs-keyword">get</span> <span class="hljs-title function_">plumage</span>() &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;unknown&quot;</span>;<br> &#125;<br> <span class="hljs-keyword">get</span> <span class="hljs-title function_">airSpeedVelocity</span>() &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br> &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EuropeanSwallow</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Bird</span> &#123;<br> <span class="hljs-keyword">get</span> <span class="hljs-title function_">plumage</span>() &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;average&quot;</span>;<br> &#125;<br> <span class="hljs-keyword">get</span> <span class="hljs-title function_">airSpeedVelocity</span>() &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">35</span>;<br> &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AfricanSwallow</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Bird</span> &#123;<br> <span class="hljs-keyword">get</span> <span class="hljs-title function_">plumage</span>() &#123;<br>  <span class="hljs-keyword">return</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">numberOfCoconuts</span> &gt; <span class="hljs-number">2</span>) ? <span class="hljs-string">&quot;tired&quot;</span> : <span class="hljs-string">&quot;average&quot;</span>;<br> &#125;<br> <span class="hljs-keyword">get</span> <span class="hljs-title function_">airSpeedVelocity</span>() &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">40</span> - <span class="hljs-number">2</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">numberOfCoconuts</span>;<br> &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NorwegianBlueParrot</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Bird</span> &#123;<br> <span class="hljs-keyword">get</span> <span class="hljs-title function_">plumage</span>() &#123;<br>  <span class="hljs-keyword">return</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">voltage</span> &gt; <span class="hljs-number">100</span>) ? <span class="hljs-string">&quot;scorched&quot;</span> : <span class="hljs-string">&quot;beautiful&quot;</span>;<br> &#125;<br> <span class="hljs-keyword">get</span> <span class="hljs-title function_">airSpeedVelocity</span>() &#123;<br>  <span class="hljs-keyword">return</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">isNailed</span>) ? <span class="hljs-number">0</span> : <span class="hljs-number">10</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">voltage</span> / <span class="hljs-number">10</span>;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>看着最终的代码，可以看出 Bird 超类并不是必需的。在 JavaScript 中，多态不一定需要类型层级，只要对象实现了适当的函数就行。但在这个例子中，我愿意保留这个不必要的超类，因为它能帮助阐释各个子类与问题域之间的关系。</p><h3 id="范例：用多态处理变体逻辑"><a href="#范例：用多态处理变体逻辑" class="headerlink" title="范例：用多态处理变体逻辑"></a>范例：用多态处理变体逻辑</h3><p>在前面的例子中，“鸟”的类型体系是一个清晰的泛化体系：超类是抽象的“鸟”，子类是各种具体的鸟。这是教科书（包括我写的书）中经常讨论的继承和多态，但并不是实践中使用继承的唯一方式。实际上，这种方式很可能不是最常用或最好的方式。另一种使用继承的情况是：我想表达某个对象与另一个对象大体类似，但又有一些不同之处。</p><p>下面有一个这样的例子：有一家评级机构，要对远洋航船的航行进行投资评级。这家评级机构会给出“A”或者“B”两种评级，取决于多种风险和盈利潜力的因素。在评估风险时，既要考虑航程本身的特征，也要考虑船长过往航行的历史。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">rating</span>(<span class="hljs-params">voyage, history</span>) &#123;<br> const vpf = voyageProfitFactor(voyage, history);<br> const vr = voyageRisk(voyage);<br> const chr = captainHistoryRisk(voyage, history);<br> <span class="hljs-keyword">if</span> (vpf * <span class="hljs-number">3</span> &gt; (vr + chr * <span class="hljs-number">2</span>)) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;A&quot;</span>;<br> <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;B&quot;</span>;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">voyageRisk</span>(<span class="hljs-params">voyage</span>) &#123;<br> let result = <span class="hljs-number">1</span>;<br> <span class="hljs-keyword">if</span> (voyage.<span class="hljs-built_in">length</span> &gt; <span class="hljs-number">4</span>) result += <span class="hljs-number">2</span>;<br> <span class="hljs-keyword">if</span> (voyage.<span class="hljs-built_in">length</span> &gt; <span class="hljs-number">8</span>) result += voyage.<span class="hljs-built_in">length</span> - <span class="hljs-number">8</span>;<br> <span class="hljs-keyword">if</span> ([<span class="hljs-string">&quot;china&quot;</span>, <span class="hljs-string">&quot;east-indies&quot;</span>].<span class="hljs-built_in">includes</span>(voyage.zone)) result += <span class="hljs-number">4</span>;<br> <span class="hljs-keyword">return</span> Math.<span class="hljs-built_in">max</span>(result, <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">captainHistoryRisk</span>(<span class="hljs-params">voyage, history</span>) &#123;<br> let result = <span class="hljs-number">1</span>;<br> <span class="hljs-keyword">if</span> (history.<span class="hljs-built_in">length</span> &lt; <span class="hljs-number">5</span>) result += <span class="hljs-number">4</span>;<br> result += history.<span class="hljs-built_in">filter</span>(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> v.profit &lt; <span class="hljs-number">0</span>).<span class="hljs-built_in">length</span>;<br> <span class="hljs-keyword">if</span> (voyage.zone === <span class="hljs-string">&quot;china&quot;</span> &amp;amp;&amp;amp; hasChina(history)) result -= <span class="hljs-number">2</span>;<br> <span class="hljs-keyword">return</span> Math.<span class="hljs-built_in">max</span>(result, <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">hasChina</span>(<span class="hljs-params">history</span>) &#123;<br> <span class="hljs-keyword">return</span> history.some(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> <span class="hljs-string">&quot;china&quot;</span> === v.zone);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">voyageProfitFactor</span>(<span class="hljs-params">voyage, history</span>) &#123;<br> let result = <span class="hljs-number">2</span>;<br> <span class="hljs-keyword">if</span> (voyage.zone === <span class="hljs-string">&quot;china&quot;</span>) result += <span class="hljs-number">1</span>;<br> <span class="hljs-keyword">if</span> (voyage.zone === <span class="hljs-string">&quot;east-indies&quot;</span>) result += <span class="hljs-number">1</span>;<br> <span class="hljs-keyword">if</span> (voyage.zone === <span class="hljs-string">&quot;china&quot;</span> &amp;amp;&amp;amp; hasChina(history)) &#123;<br>  result += <span class="hljs-number">3</span>;<br>  <span class="hljs-keyword">if</span> (history.<span class="hljs-built_in">length</span> &gt; <span class="hljs-number">10</span>) result += <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (voyage.<span class="hljs-built_in">length</span> &gt; <span class="hljs-number">12</span>) result += <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (voyage.<span class="hljs-built_in">length</span> &gt; <span class="hljs-number">18</span>) result -= <span class="hljs-number">1</span>;<br> &#125;<br> <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-keyword">if</span> (history.<span class="hljs-built_in">length</span> &gt; <span class="hljs-number">8</span>) result += <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (voyage.<span class="hljs-built_in">length</span> &gt; <span class="hljs-number">14</span>) result -= <span class="hljs-number">1</span>;<br> &#125;<br> <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>voyageRisk 和 captainHistoryRisk 两个函数负责打出风险分数，voyageProfitFactor 负责打出盈利潜力分数，rating 函数将 3 个分数组合到一起，给出一次航行的综合评级。</p><p>调用方的代码大概是这样：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">const voyage</span> = &#123; zone: <span class="hljs-string">&quot;west-indies&quot;</span>, length: 10 &#125;;<br><span class="hljs-attribute">const history</span> = [<br>  &#123; zone: <span class="hljs-string">&quot;east-indies&quot;</span>, profit: 5 &#125;,<br>  &#123; zone: <span class="hljs-string">&quot;west-indies&quot;</span>, profit: 15 &#125;,<br>  &#123; zone: <span class="hljs-string">&quot;china&quot;</span>, profit: -2 &#125;,<br>  &#123; zone: <span class="hljs-string">&quot;west-africa&quot;</span>, profit: 7 &#125;,<br>];<br><br><span class="hljs-attribute">const myRating</span> = rating(voyage, history);<br></code></pre></td></tr></table></figure><p>代码中有两处同样的条件逻辑，都在询问“是否有到中国的航程”以及“船长是否曾去过中国”。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">rating</span>(<span class="hljs-params">voyage, history</span>) &#123;<br> const vpf = voyageProfitFactor(voyage, history);<br> const vr = voyageRisk(voyage);<br> const chr = captainHistoryRisk(voyage, history);<br> <span class="hljs-keyword">if</span> (vpf * <span class="hljs-number">3</span> &gt; (vr + chr * <span class="hljs-number">2</span>)) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;A&quot;</span>;<br> <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;B&quot;</span>;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">voyageRisk</span>(<span class="hljs-params">voyage</span>) &#123;<br> let result = <span class="hljs-number">1</span>;<br> <span class="hljs-keyword">if</span> (voyage.<span class="hljs-built_in">length</span> &gt; <span class="hljs-number">4</span>) result += <span class="hljs-number">2</span>;<br> <span class="hljs-keyword">if</span> (voyage.<span class="hljs-built_in">length</span> &gt; <span class="hljs-number">8</span>) result += voyage.<span class="hljs-built_in">length</span> - <span class="hljs-number">8</span>;<br> <span class="hljs-keyword">if</span> ([<span class="hljs-string">&quot;china&quot;</span>, <span class="hljs-string">&quot;east-indies&quot;</span>].<span class="hljs-built_in">includes</span>(voyage.zone)) result += <span class="hljs-number">4</span>;<br> <span class="hljs-keyword">return</span> Math.<span class="hljs-built_in">max</span>(result, <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">captainHistoryRisk</span>(<span class="hljs-params">voyage, history</span>) &#123;<br> let result = <span class="hljs-number">1</span>;<br> <span class="hljs-keyword">if</span> (history.<span class="hljs-built_in">length</span> &lt; <span class="hljs-number">5</span>) result += <span class="hljs-number">4</span>;<br> result += history.<span class="hljs-built_in">filter</span>(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> v.profit &lt; <span class="hljs-number">0</span>).<span class="hljs-built_in">length</span>;<br> <span class="hljs-keyword">if</span> (voyage.zone === <span class="hljs-string">&quot;china&quot;</span> &amp;amp;&amp;amp; hasChina(history)) result -= <span class="hljs-number">2</span>;<br> <span class="hljs-keyword">return</span> Math.<span class="hljs-built_in">max</span>(result, <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">hasChina</span>(<span class="hljs-params">history</span>) &#123;<br> <span class="hljs-keyword">return</span> history.some(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> <span class="hljs-string">&quot;china&quot;</span> === v.zone);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">voyageProfitFactor</span>(<span class="hljs-params">voyage, history</span>) &#123;<br> let result = <span class="hljs-number">2</span>;<br> <span class="hljs-keyword">if</span> (voyage.zone === <span class="hljs-string">&quot;china&quot;</span>) result += <span class="hljs-number">1</span>;<br> <span class="hljs-keyword">if</span> (voyage.zone === <span class="hljs-string">&quot;east-indies&quot;</span>) result += <span class="hljs-number">1</span>;<br> <span class="hljs-keyword">if</span> (voyage.zone === <span class="hljs-string">&quot;china&quot;</span> &amp;amp;&amp;amp; hasChina(history)) &#123;<br>  result += <span class="hljs-number">3</span>;<br>  <span class="hljs-keyword">if</span> (history.<span class="hljs-built_in">length</span> &gt; <span class="hljs-number">10</span>) result += <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (voyage.<span class="hljs-built_in">length</span> &gt; <span class="hljs-number">12</span>) result += <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (voyage.<span class="hljs-built_in">length</span> &gt; <span class="hljs-number">18</span>) result -= <span class="hljs-number">1</span>;<br> &#125;<br> <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-keyword">if</span> (history.<span class="hljs-built_in">length</span> &gt; <span class="hljs-number">8</span>) result += <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (voyage.<span class="hljs-built_in">length</span> &gt; <span class="hljs-number">14</span>) result -= <span class="hljs-number">1</span>;<br> &#125;<br> <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>我会用继承和多态将处理“中国因素”的逻辑从基础逻辑中分离出来。如果还要引入更多的特殊逻辑，这个重构就很有用——这些重复的“中国因素”会混淆视听，让基础逻辑难以理解。</p><p>起初代码里只有一堆函数，如果要引入多态的话，我需要先建立一个类结构，因此我首先使用函数组合成类（144）。这一步重构的结果如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">function rating(voyage, history) &#123;<br> <span class="hljs-keyword">return</span> new Rating(voyage, history).value;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rating</span> &#123;<br> <span class="hljs-keyword">constructor</span>(voyage, history) &#123;<br>  <span class="hljs-keyword">this</span>.voyage = voyage;<br>  <span class="hljs-keyword">this</span>.history = history;<br> &#125;<br> <span class="hljs-keyword">get</span> value() &#123;<br>  <span class="hljs-keyword">const</span> vpf = <span class="hljs-keyword">this</span>.voyageProfitFactor;<br>  <span class="hljs-keyword">const</span> vr = <span class="hljs-keyword">this</span>.voyageRisk;<br>  <span class="hljs-keyword">const</span> chr = <span class="hljs-keyword">this</span>.captainHistoryRisk;<br>  <span class="hljs-keyword">if</span> (vpf * <span class="hljs-number">3</span> &gt; (vr + chr * <span class="hljs-number">2</span>)) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;A&quot;</span>;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;B&quot;</span>;<br> &#125;<br> <span class="hljs-keyword">get</span> voyageRisk() &#123;<br>  let result = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.length &gt; <span class="hljs-number">4</span>) result += <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.length &gt; <span class="hljs-number">8</span>) result += <span class="hljs-keyword">this</span>.voyage.length - <span class="hljs-number">8</span>;<br>  <span class="hljs-keyword">if</span> ([<span class="hljs-string">&quot;china&quot;</span>, <span class="hljs-string">&quot;east-indies&quot;</span>].includes(<span class="hljs-keyword">this</span>.voyage.zone)) result += <span class="hljs-number">4</span>;<br>  <span class="hljs-keyword">return</span> Math.max(result, <span class="hljs-number">0</span>);<br> &#125;<br> <span class="hljs-keyword">get</span> captainHistoryRisk() &#123;<br>  let result = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.history.length &lt; <span class="hljs-number">5</span>) result += <span class="hljs-number">4</span>;<br>  result += <span class="hljs-keyword">this</span>.history.filter(v =&gt; v.profit &lt; <span class="hljs-number">0</span>).length;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.zone === <span class="hljs-string">&quot;china&quot;</span> &amp;amp;&amp;amp; <span class="hljs-keyword">this</span>.hasChinaHistory) result -= <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">return</span> Math.max(result, <span class="hljs-number">0</span>);<br> &#125;<br> <span class="hljs-keyword">get</span> voyageProfitFactor() &#123;<br>  let result = <span class="hljs-number">2</span>;<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.zone === <span class="hljs-string">&quot;china&quot;</span>) result += <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.zone === <span class="hljs-string">&quot;east-indies&quot;</span>) result += <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.zone === <span class="hljs-string">&quot;china&quot;</span> &amp;amp;&amp;amp; <span class="hljs-keyword">this</span>.hasChinaHistory) &#123;<br>   result += <span class="hljs-number">3</span>;<br>   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.history.length &gt; <span class="hljs-number">10</span>) result += <span class="hljs-number">1</span>;<br>   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.length &gt; <span class="hljs-number">12</span>) result += <span class="hljs-number">1</span>;<br>   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.length &gt; <span class="hljs-number">18</span>) result -= <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">else</span> &#123;<br>   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.history.length &gt; <span class="hljs-number">8</span>) result += <span class="hljs-number">1</span>;<br>   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.length &gt; <span class="hljs-number">14</span>) result -= <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br> &#125;<br> <span class="hljs-keyword">get</span> hasChinaHistory() &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.history.some(v =&gt; <span class="hljs-string">&quot;china&quot;</span> === v.zone);<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>于是我就有了一个类，用来安放基础逻辑。现在我需要另建一个空的子类，用来安放与超类不同的行为。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExperiencedChinaRating</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Rating</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>然后，建立一个工厂函数，用于在需要时返回变体类。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> create<span class="hljs-constructor">Rating(<span class="hljs-params">voyage</span>, <span class="hljs-params">history</span>)</span> &#123;<br> <span class="hljs-keyword">if</span> (voyage.zone<span class="hljs-operator"> === </span><span class="hljs-string">&quot;china&quot;</span> &amp;amp;&amp;amp; history.some(v =&gt; <span class="hljs-string">&quot;china&quot;</span><span class="hljs-operator"> === </span>v.zone))<br>  return <span class="hljs-keyword">new</span> <span class="hljs-constructor">ExperiencedChinaRating(<span class="hljs-params">voyage</span>, <span class="hljs-params">history</span>)</span>;<br> <span class="hljs-keyword">else</span> return <span class="hljs-keyword">new</span> <span class="hljs-constructor">Rating(<span class="hljs-params">voyage</span>, <span class="hljs-params">history</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我需要修改所有调用方代码，让它们使用该工厂函数，而不要直接调用构造函数。还好现在调用构造函数的只有 rating 函数一处。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">rating</span>(voyage, history) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">createRating(voyage,</span> history).value;<br>&#125;<br></code></pre></td></tr></table></figure><p>有两处行为需要移入子类中。我先处理 captainHistoryRisk 中的逻辑。</p><p><strong>class Rating…</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">get</span> captainHistoryRisk() &#123;<br> let result = <span class="hljs-number">1</span>;<br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.history.length &lt; <span class="hljs-number">5</span>) result += <span class="hljs-number">4</span>;<br> result += <span class="hljs-keyword">this</span>.history.filter(v =&gt; v.profit &lt; <span class="hljs-number">0</span>).length;<br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.zone === <span class="hljs-string">&quot;china&quot;</span> &amp;amp;&amp;amp; <span class="hljs-keyword">this</span>.hasChinaHistory) result -= <span class="hljs-number">2</span>;<br> <span class="hljs-keyword">return</span> Math.max(result, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在子类中覆写这个函数。</p><p>class ExperiencedChinaRating</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">get</span> <span class="hljs-title function_">captainHistoryRisk</span>() &#123;<br>  <span class="hljs-keyword">const</span> result = <span class="hljs-variable language_">super</span>.<span class="hljs-property">captainHistoryRisk</span> - <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(result, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>class Rating…</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">get</span> captainHistoryRisk() &#123;<br> let result = <span class="hljs-number">1</span>;<br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.history.length &lt; <span class="hljs-number">5</span>) result += <span class="hljs-number">4</span>;<br> result += <span class="hljs-keyword">this</span>.history.filter(v =&gt; v.profit &lt; <span class="hljs-number">0</span>).length;<br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.zone === <span class="hljs-string">&quot;china&quot;</span> &amp;amp;&amp;amp; <span class="hljs-keyword">this</span>.hasChinaHistory) result -= <span class="hljs-number">2</span>;<br> <span class="hljs-keyword">return</span> Math.max(result, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>分离 voyageProfitFactor 函数中的变体行为要更麻烦一些。我不能直接从超类中删掉变体行为，因为在超类中还有另一条执行路径。我又不想把整个超类中的函数复制到子类中。</p><p><strong>class Rating…</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">get</span> voyageProfitFactor() &#123;<br> let result = <span class="hljs-number">2</span>;<br><br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.zone === <span class="hljs-string">&quot;china&quot;</span>) result += <span class="hljs-number">1</span>;<br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.zone === <span class="hljs-string">&quot;east-indies&quot;</span>) result += <span class="hljs-number">1</span>;<br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.zone === <span class="hljs-string">&quot;china&quot;</span> &amp;amp;&amp;amp; <span class="hljs-keyword">this</span>.hasChinaHistory) &#123;<br>  result += <span class="hljs-number">3</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.history.length &gt; <span class="hljs-number">10</span>) result += <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.length &gt; <span class="hljs-number">12</span>) result += <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.length &gt; <span class="hljs-number">18</span>) result -= <span class="hljs-number">1</span>;<br> &#125;<br> <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.history.length &gt; <span class="hljs-number">8</span>) result += <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.length &gt; <span class="hljs-number">14</span>) result -= <span class="hljs-number">1</span>;<br> &#125;<br> <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以我先用提炼函数（106）将整个条件逻辑块提炼出来。</p><p><strong>class Rating…</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">get</span> voyageProfitFactor() &#123;<br> let result = <span class="hljs-number">2</span>;<br><br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.zone === <span class="hljs-string">&quot;china&quot;</span>) result += <span class="hljs-number">1</span>;<br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.zone === <span class="hljs-string">&quot;east-indies&quot;</span>) result += <span class="hljs-number">1</span>;<br> result += <span class="hljs-keyword">this</span>.voyageAndHistoryLengthFactor;<br> <span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-keyword">get</span> voyageAndHistoryLengthFactor() &#123;<br> let result = <span class="hljs-number">0</span>;<br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.zone === <span class="hljs-string">&quot;china&quot;</span> &amp;amp;&amp;amp; <span class="hljs-keyword">this</span>.hasChinaHistory) &#123;<br>  result += <span class="hljs-number">3</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.history.length &gt; <span class="hljs-number">10</span>) result += <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.length &gt; <span class="hljs-number">12</span>) result += <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.length &gt; <span class="hljs-number">18</span>) result -= <span class="hljs-number">1</span>;<br> &#125;<br> <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.history.length &gt; <span class="hljs-number">8</span>) result += <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.length &gt; <span class="hljs-number">14</span>) result -= <span class="hljs-number">1</span>;<br> &#125;<br> <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数名中出现“And”字样是一个很不好的味道，不过我会暂时容忍它，先聚焦子类化操作。</p><p><strong>class Rating…</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-keyword">get</span> voyageAndHistoryLengthFactor() &#123;<br> let <span class="hljs-literal">result</span> = <span class="hljs-number">0</span>;<br> <span class="hljs-keyword">if</span> (this.history.<span class="hljs-built_in">length</span> &gt; <span class="hljs-number">8</span>) <span class="hljs-literal">result</span> += <span class="hljs-number">1</span>;<br> <span class="hljs-keyword">if</span> (this.voyage.<span class="hljs-built_in">length</span> &gt; <span class="hljs-number">14</span>) <span class="hljs-literal">result</span> -= <span class="hljs-number">1</span>;<br><span class="hljs-built_in"> return</span> <span class="hljs-literal">result</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>class ExperiencedChinaRating…</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-keyword">get</span> voyageAndHistoryLengthFactor() &#123;<br> let <span class="hljs-literal">result</span> = <span class="hljs-number">0</span>;<br> <span class="hljs-literal">result</span> += <span class="hljs-number">3</span>;<br> <span class="hljs-keyword">if</span> (this.history.<span class="hljs-built_in">length</span> &gt; <span class="hljs-number">10</span>) <span class="hljs-literal">result</span> += <span class="hljs-number">1</span>;<br> <span class="hljs-keyword">if</span> (this.voyage.<span class="hljs-built_in">length</span> &gt; <span class="hljs-number">12</span>) <span class="hljs-literal">result</span> += <span class="hljs-number">1</span>;<br> <span class="hljs-keyword">if</span> (this.voyage.<span class="hljs-built_in">length</span> &gt; <span class="hljs-number">18</span>) <span class="hljs-literal">result</span> -= <span class="hljs-number">1</span>;<br><span class="hljs-built_in"> return</span> <span class="hljs-literal">result</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>严格说来，重构到这儿就结束了——我已经把变体行为分离到了子类中，超类的逻辑理解和维护起来更简单了，只有在进入子类代码时我才需要操心变体逻辑。子类的代码表述了它与超类的差异。</p><p>但我觉得至少应该谈谈如何处理这个丑陋的新函数。引入一个函数以便子类覆写，这在处理这种“基础和变体”的继承关系时是常见操作。但这样一个难看的函数只会妨碍——而不是帮助——别人理解其中的逻辑。</p><p>函数名中的“And”字样说明其中包含了两件事，所以我觉得应该将它们分开。我会用提炼函数（106）把“历史航行数”（history length）的相关逻辑提炼出来。这一步提炼在超类和子类中都要发生，我首先从超类开始。</p><p><strong>class Rating…</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">get</span> <span class="hljs-title">voyageAndHistoryLengthFactor</span>()</span> &#123;<br> <span class="hljs-keyword">let</span> result = <span class="hljs-number">0</span>;<br> result += <span class="hljs-keyword">this</span>.historyLengthFactor;<br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.length &gt; <span class="hljs-number">14</span>) result -= <span class="hljs-number">1</span>;<br> <span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">get</span> <span class="hljs-title">historyLengthFactor</span>()</span> &#123;<br> <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.history.length &gt; <span class="hljs-number">8</span>) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在子类中也如法炮制。</p><p><strong>class ExperiencedChinaRating…</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">get</span> voyageAndHistoryLengthFactor() &#123;<br> let result = <span class="hljs-number">0</span>;<br> result += <span class="hljs-number">3</span>;<br> result += <span class="hljs-keyword">this</span>.historyLengthFactor;<br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.length &gt; <span class="hljs-number">12</span>) result += <span class="hljs-number">1</span>;<br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.length &gt; <span class="hljs-number">18</span>) result -= <span class="hljs-number">1</span>;<br> <span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-keyword">get</span> historyLengthFactor() &#123;<br> <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.history.length &gt; <span class="hljs-number">10</span>) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在超类中使用搬移语句到调用者（217）。</p><p><strong>class Rating…</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">get</span> voyageProfitFactor() &#123;<br> let result = <span class="hljs-number">2</span>;<br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.zone === <span class="hljs-string">&quot;china&quot;</span>) result += <span class="hljs-number">1</span>;<br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.zone === <span class="hljs-string">&quot;east-indies&quot;</span>) result += <span class="hljs-number">1</span>;<br> result += <span class="hljs-keyword">this</span>.historyLengthFactor;<br> result += <span class="hljs-keyword">this</span>.voyageAndHistoryLengthFactor;<br> <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-keyword">get</span> voyageAndHistoryLengthFactor() &#123;<br> let result = <span class="hljs-number">0</span>;<br> result += <span class="hljs-keyword">this</span>.historyLengthFactor;<br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.length &gt; <span class="hljs-number">14</span>) result -= <span class="hljs-number">1</span>;<br> <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>class ExperiencedChinaRating…</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-keyword">get</span> voyageAndHistoryLengthFactor() &#123;<br> let <span class="hljs-literal">result</span> = <span class="hljs-number">0</span>;<br> <span class="hljs-literal">result</span> += <span class="hljs-number">3</span>;<br> <span class="hljs-literal">result</span> += this.historyLengthFactor;<br> <span class="hljs-keyword">if</span> (this.voyage.<span class="hljs-built_in">length</span> &gt; <span class="hljs-number">12</span>) <span class="hljs-literal">result</span> += <span class="hljs-number">1</span>;<br> <span class="hljs-keyword">if</span> (this.voyage.<span class="hljs-built_in">length</span> &gt; <span class="hljs-number">18</span>) <span class="hljs-literal">result</span> -= <span class="hljs-number">1</span>;<br><span class="hljs-built_in"> return</span> <span class="hljs-literal">result</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>再用函数改名（124）改掉这个难听的名字。</p><p><strong>class Rating…</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">get</span> voyageProfitFactor() &#123;<br> let result = <span class="hljs-number">2</span>;<br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.zone === <span class="hljs-string">&quot;china&quot;</span>) result += <span class="hljs-number">1</span>;<br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.zone === <span class="hljs-string">&quot;east-indies&quot;</span>) result += <span class="hljs-number">1</span>;<br> result += <span class="hljs-keyword">this</span>.historyLengthFactor;<br> result += <span class="hljs-keyword">this</span>.voyageLengthFactor;<br> <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-keyword">get</span> voyageLengthFactor() &#123;<br> <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.voyage.length &gt; <span class="hljs-number">14</span>) ? - <span class="hljs-number">1</span>: <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>改为三元表达式，以简化 voyageLengthFactor 函数。</p><p><strong>class ExperiencedChinaRating…</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-keyword">get</span> voyageLengthFactor() &#123;<br> let <span class="hljs-literal">result</span> = <span class="hljs-number">0</span>;<br> <span class="hljs-literal">result</span> += <span class="hljs-number">3</span>;<br> <span class="hljs-keyword">if</span> (this.voyage.<span class="hljs-built_in">length</span> &gt; <span class="hljs-number">12</span>) <span class="hljs-literal">result</span> += <span class="hljs-number">1</span>;<br> <span class="hljs-keyword">if</span> (this.voyage.<span class="hljs-built_in">length</span> &gt; <span class="hljs-number">18</span>) <span class="hljs-literal">result</span> -= <span class="hljs-number">1</span>;<br><span class="hljs-built_in"> return</span> <span class="hljs-literal">result</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后一件事：在“航程数”（voyage length）因素上加上 3 分，我认为这个逻辑不合理，应该把这 3 分加在最终的结果上。</p><p><strong>class ExperiencedChinaRating…</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-keyword">get</span> voyageProfitFactor() &#123;<br><span class="hljs-built_in">  return</span> super.voyageProfitFactor + <span class="hljs-number">3</span>;<br>&#125;<br><br><span class="hljs-keyword">get</span> voyageLengthFactor() &#123;<br>  let <span class="hljs-literal">result</span> = <span class="hljs-number">0</span>;<br>  <span class="hljs-literal">result</span> += <span class="hljs-number">3</span>;<br>  <span class="hljs-keyword">if</span> (this.voyage.<span class="hljs-built_in">length</span> &gt; <span class="hljs-number">12</span>) <span class="hljs-literal">result</span> += <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (this.voyage.<span class="hljs-built_in">length</span> &gt; <span class="hljs-number">18</span>) <span class="hljs-literal">result</span> -= <span class="hljs-number">1</span>;<br><span class="hljs-built_in">  return</span> <span class="hljs-literal">result</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>重构结束，我得到了如下代码。首先，我有一个基本的 Rating 类，其中不考虑与“中国经验”相关的复杂性：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rating</span> &#123;<br> <span class="hljs-keyword">constructor</span>(voyage, history) &#123;<br>  <span class="hljs-keyword">this</span>.voyage = voyage;<br>  <span class="hljs-keyword">this</span>.history = history;<br> &#125;<br> <span class="hljs-keyword">get</span> value() &#123;<br>  <span class="hljs-keyword">const</span> vpf = <span class="hljs-keyword">this</span>.voyageProfitFactor;<br>  <span class="hljs-keyword">const</span> vr = <span class="hljs-keyword">this</span>.voyageRisk;<br>  <span class="hljs-keyword">const</span> chr = <span class="hljs-keyword">this</span>.captainHistoryRisk;<br>  <span class="hljs-keyword">if</span> (vpf * <span class="hljs-number">3</span> &gt; (vr + chr * <span class="hljs-number">2</span>)) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;A&quot;</span>;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;B&quot;</span>;<br> &#125;<br> <span class="hljs-keyword">get</span> voyageRisk() &#123;<br>  let result = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.length &gt; <span class="hljs-number">4</span>) result += <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.length &gt; <span class="hljs-number">8</span>) result += <span class="hljs-keyword">this</span>.voyage.length - <span class="hljs-number">8</span>;<br>  <span class="hljs-keyword">if</span> ([<span class="hljs-string">&quot;china&quot;</span>, <span class="hljs-string">&quot;east-indies&quot;</span>].includes(<span class="hljs-keyword">this</span>.voyage.zone)) result += <span class="hljs-number">4</span>;<br>  <span class="hljs-keyword">return</span> Math.max(result, <span class="hljs-number">0</span>);<br> &#125;<br> <span class="hljs-keyword">get</span> captainHistoryRisk() &#123;<br>  let result = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.history.length &lt; <span class="hljs-number">5</span>) result += <span class="hljs-number">4</span>;<br>  result += <span class="hljs-keyword">this</span>.history.filter(v =&gt; v.profit &lt; <span class="hljs-number">0</span>).length;<br>  <span class="hljs-keyword">return</span> Math.max(result, <span class="hljs-number">0</span>);<br> &#125;<br> <span class="hljs-keyword">get</span> voyageProfitFactor() &#123;<br>  let result = <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.zone === <span class="hljs-string">&quot;china&quot;</span>) result += <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.zone === <span class="hljs-string">&quot;east-indies&quot;</span>) result += <span class="hljs-number">1</span>;<br>  result += <span class="hljs-keyword">this</span>.historyLengthFactor;<br>  result += <span class="hljs-keyword">this</span>.voyageLengthFactor;<br>  <span class="hljs-keyword">return</span> result;<br> &#125;<br> <span class="hljs-keyword">get</span> voyageLengthFactor() &#123;<br>  <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.voyage.length &gt; <span class="hljs-number">14</span>) ? - <span class="hljs-number">1</span>: <span class="hljs-number">0</span>;<br> &#125;<br> <span class="hljs-keyword">get</span> historyLengthFactor() &#123;<br>  <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.history.length &gt; <span class="hljs-number">8</span>) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>与“中国经验”相关的代码则清晰表述出在基本逻辑之上的一系列变体逻辑：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ExperiencedChinaRating</span> <span class="hljs-title">extends</span> <span class="hljs-title">Rating</span> &#123;<br> <span class="hljs-keyword">get</span> captainHistoryRisk() &#123;<br>  <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">super</span>.captainHistoryRisk - <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">return</span> Math.max(result, <span class="hljs-number">0</span>);<br> &#125;<br> <span class="hljs-keyword">get</span> voyageLengthFactor() &#123;<br>  let result = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.length &gt; <span class="hljs-number">12</span>) result += <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.length &gt; <span class="hljs-number">18</span>) result -= <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">return</span> result;<br> &#125;<br> <span class="hljs-keyword">get</span> historyLengthFactor() &#123;<br>  <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.history.length &gt; <span class="hljs-number">10</span>) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br> &#125;<br> <span class="hljs-keyword">get</span> voyageProfitFactor() &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.voyageProfitFactor + <span class="hljs-number">3</span>;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="10-5-引入特例（Introduce-Special-Case）"><a href="#10-5-引入特例（Introduce-Special-Case）" class="headerlink" title="10.5 引入特例（Introduce Special Case）"></a>10.5 引入特例（Introduce Special Case）</h2><p>曾用名：引入 Null 对象（Introduce Null Object）</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">if (aCustomer <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-string">&quot;unknown&quot;</span>) customerName <span class="hljs-operator">=</span> <span class="hljs-string">&quot;occupant&quot;</span><span class="hljs-comment">;</span><br><br><br>class UnknownCustomer &#123;<br>  get name() &#123;return <span class="hljs-string">&quot;occupant&quot;</span><span class="hljs-comment">;&#125;</span><br></code></pre></td></tr></table></figure><h3 id="动机-4"><a href="#动机-4" class="headerlink" title="动机"></a>动机</h3><p>一种常见的重复代码是这种情况：一个数据结构的使用者都在检查某个特殊的值，并且当这个特殊值出现时所做的处理也都相同。如果我发现代码库中有多处以同样方式应对同一个特殊值，我就会想要把这个处理逻辑收拢到一处。</p><p>处理这种情况的一个好办法是使用“特例”（Special Case）模式：创建一个特例元素，用以表达对这种特例的共用行为的处理。这样我就可以用一个函数调用取代大部分特例检查逻辑。</p><p>特例有几种表现形式。如果我只需要从这个对象读取数据，可以提供一个字面量对象（literal object），其中所有的值都是预先填充好的。如果除简单的数值之外还需要更多的行为，就需要创建一个特殊对象，其中包含所有共用行为所对应的函数。特例对象可以由一个封装类来返回，也可以通过变换插入一个数据结构。</p><p>一个通常需要特例处理的值就是 null，这也是这个模式常被叫作“Null 对象”（Null Object）模式的原因——我喜欢说：Null 对象是特例的一种特例。</p><h3 id="做法-4"><a href="#做法-4" class="headerlink" title="做法"></a>做法</h3><p>我们从一个作为容器的数据结构（或者类）开始，其中包含一个属性，该属性就是我们要重构的目标。容器的客户端每次使用这个属性时，都需要将其与某个特例值做比对。我们希望把这个特例值替换为代表这种特例情况的类或数据结构。</p><p>给重构目标添加检查特例的属性，令其返回 false。</p><p>创建一个特例对象，其中只有检查特例的属性，返回 true。</p><p>对“与特例值做比对”的代码运用提炼函数（106），确保所有客户端都使用这个新函数，而不再直接做特例值的比对。</p><p>将新的特例对象引入代码中，可以从函数调用中返回，也可以在变换函数中生成。</p><p>修改特例比对函数的主体，在其中直接使用检查特例的属性。</p><p>测试。</p><p>使用函数组合成类（144）或函数组合成变换（149），把通用的特例处理逻辑都搬移到新建的特例对象中。</p><p>特例类对于简单的请求通常会返回固定的值，因此可以将其实现为字面记录（literal record）。</p><p>对特例比对函数使用内联函数（115），将其内联到仍然需要的地方。</p><h3 id="范例-4"><a href="#范例-4" class="headerlink" title="范例"></a>范例</h3><p>一家提供公共事业服务的公司将自己的服务安装在各个场所（site）。</p><p><strong>class Site…</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">get</span> <span class="hljs-title">customer</span>()</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._customer;&#125;<br></code></pre></td></tr></table></figure><p>代表“顾客”的 Customer 类有多个属性，我只考虑其中 3 个。</p><p><strong>class Customer…</strong></p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nim">get name()           <span class="hljs-meta">&#123;...&#125;</span><br>get billingPlan()    <span class="hljs-meta">&#123;...&#125;</span><br><span class="hljs-type">set</span> billingPlan(arg) <span class="hljs-meta">&#123;...&#125;</span><br>get paymentHistory() <span class="hljs-meta">&#123;...&#125;</span><br></code></pre></td></tr></table></figure><p>大多数情况下，一个场所会对应一个顾客，但有些场所没有与之对应的顾客，可能是因为之前的住户搬走了，而新搬来的住户我还不知道是谁。这种情况下，数据记录中的 customer 字段会被填充为字符串”unknown”。因为这种情况时有发生，所以 Site 对象的客户端必须有办法处理“顾客未知”的情况。下面是一些示例代码片段。</p><p><strong>客户端 1…</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">const aCustomer <span class="hljs-operator">=</span> site.customer<span class="hljs-comment">;</span><br>// ... lots of intervening code ...<br>let customerName<span class="hljs-comment">;</span><br>if (aCustomer <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-string">&quot;unknown&quot;</span>) customerName <span class="hljs-operator">=</span> <span class="hljs-string">&quot;occupant&quot;</span><span class="hljs-comment">;</span><br>else customerName <span class="hljs-operator">=</span> aCustomer.name<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><strong>客户端 2…</strong></p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-keyword">const</span> plan =<br>  aCustomer === <span class="hljs-string">&quot;unknown&quot;</span> ? registry.billingPlans.<span class="hljs-keyword">basic</span> : aCustomer.billingPlan;<br></code></pre></td></tr></table></figure><p><strong>客户端 3…</strong></p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">if</span> (aCustomer !== <span class="hljs-string">&quot;unknown&quot;</span>) aCustomer.billingPlan = <span class="hljs-keyword">new</span><span class="hljs-type">Plan</span>;<br></code></pre></td></tr></table></figure><p><strong>客户端 4…</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">const</span> weeksDelinquent =<br>  aCustomer === <span class="hljs-string">&quot;unknown&quot;</span><br>    ? <span class="hljs-number">0</span><br>    : aCustomer.paymentHistory.weeksDelinquentInLastYear;<br></code></pre></td></tr></table></figure><p>浏览整个代码库，我看到有很多使用 Site 对象的客户端在处理“顾客未知”的情况，大多数都用了同样的应对方式：用”occupant”（居民）作为顾客名，使用基本的计价套餐，并认为这家顾客没有欠费。到处都在检查这种特例，再加上对特例的处理方式高度一致，这些现象告诉我：是时候使用特例对象（Special Case Object）模式了。</p><p>我首先给 Customer 添加一个函数，用于指示“这个顾客是否未知”。</p><p><strong>class Customer…</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">get</span> <span class="hljs-title">isUnknown</span>()</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<br></code></pre></td></tr></table></figure><p>然后我给“未知的顾客”专门创建一个类。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">UnknownCustomer</span> &#123;<br>  <span class="hljs-function"><span class="hljs-keyword">get</span> <span class="hljs-title">isUnknown</span>()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，我没有把 UnknownCustomer 类声明为 Customer 的子类。在其他编程语言（尤其是静态类型的编程语言）中，我会需要继承关系。但 JavaScript 是一种动态类型语言，按照它的子类化规则，这里不声明继承关系反而更好。</p><p>下面就是麻烦之处了。我必须在所有期望得到”unknown”值的地方返回这个新的特例对象，并修改所有检查”unknown”值的地方，令其使用新的 isUnknown 函数。一般而言，我总是希望细心安排修改过程，使我可以每次做一点小修改，然后马上测试。但如果我修改了 Customer 类，使其返回 UnknownCustomer 对象（而非”unknown”字符串），那么就必须同时修改所有客户端，让它们不要检查”unknown”字符串，而是调用 isUnknown 函数——这两个修改必须一次完成。我感觉这一大步修改就像一大块难吃的食物一样难以下咽。</p><p>还好，遇到这种困境时，有一个常用的技巧可以帮忙。如果有一段代码需要在很多地方做修改（例如我们这里的“与特例做比对”的代码），我会先对其使用提炼函数（106）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isUnknown</span>(<span class="hljs-params">arg</span>) &#123;<br>  <span class="hljs-keyword">if</span> (!(arg <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Customer</span> || arg === <span class="hljs-string">&quot;unknown&quot;</span>))<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`investigate bad value: &lt;<span class="hljs-subst">$&#123;arg&#125;</span>&gt;`</span>);<br>  <span class="hljs-keyword">return</span> arg === <span class="hljs-string">&quot;unknown&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我会放一个陷阱，捕捉意料之外的值。如果在重构过程中我犯了错误，引入了奇怪的行为，这个陷阱会帮我发现。</p><p>现在，凡是检查未知顾客的地方，都可以改用这个函数了。我可以逐一修改这些地方，每次修改之后都可以执行测试。</p><p><strong>客户端 1…</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">let customerName<span class="hljs-comment">;</span><br>if (isUnknown(aCustomer)) customerName <span class="hljs-operator">=</span> <span class="hljs-string">&quot;occupant&quot;</span><span class="hljs-comment">;</span><br>else customerName <span class="hljs-operator">=</span> aCustomer.name<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>没用多久，就全部修改完了。</p><p><strong>客户端 2…</strong></p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-keyword">const</span> plan = isUnknown(aCustomer)<br>  ? registry.billingPlans.<span class="hljs-keyword">basic</span><br>  : aCustomer.billingPlan;<br></code></pre></td></tr></table></figure><p><strong>客户端 3…</strong></p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">if</span> (!isUnknown(aCustomer)) aCustomer.billingPlan = <span class="hljs-keyword">new</span><span class="hljs-type">Plan</span>;<br></code></pre></td></tr></table></figure><p><strong>客户端 4…</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">const weeksDelinquent = is<span class="hljs-constructor">Unknown(<span class="hljs-params">aCustomer</span>)</span><br>  ? <span class="hljs-number">0</span><br>  : aCustomer.paymentHistory.weeksDelinquentInLastYear;<br></code></pre></td></tr></table></figure><p>将所有调用处都改为使用 isUnknown 函数之后，就可以修改 Site 类，令其在顾客未知时返回 UnknownCustomer 对象。</p><p><strong>class Site…</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">get</span> <span class="hljs-title">customer</span>()</span> &#123;<br>  <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>._customer === <span class="hljs-string">&quot;unknown&quot;</span>) ? <span class="hljs-keyword">new</span> UnknownCustomer() : <span class="hljs-keyword">this</span>._customer;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后修改 isUnknown 函数的判断逻辑。做完这步修改之后我可以做一次全文搜索，应该没有任何地方使用”unknown”字符串了。</p><p><strong>客户端 1…</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isUnknown</span>(<span class="hljs-params">arg</span>) &#123;<br>  <span class="hljs-keyword">if</span> (!(arg <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Customer</span> || arg <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">UnknownCustomer</span>))<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`investigate bad value: &lt;<span class="hljs-subst">$&#123;arg&#125;</span>&gt;`</span>);<br>  <span class="hljs-keyword">return</span> arg.<span class="hljs-property">isUnknown</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试，以确保一切运转如常。</p><p>现在，有趣的部分开始了。我可以逐一查看客户端检查特例的代码，看它们处理特例的逻辑，并考虑是否能用函数组合成类（144）将其替换为一个共同的、符合预期的值。此刻，有多处客户端代码用字符串”occupant”来作为未知顾客的名字，就像下面这样。</p><p><strong>客户端 1…</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">let customerName<span class="hljs-comment">;</span><br>if (isUnknown(aCustomer)) customerName <span class="hljs-operator">=</span> <span class="hljs-string">&quot;occupant&quot;</span><span class="hljs-comment">;</span><br>else customerName <span class="hljs-operator">=</span> aCustomer.name<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>我可以在 UnknownCustomer 类中添加一个合适的函数。</p><p><strong>class UnknownCustomer…</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">get</span> <span class="hljs-title">name</span>()</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;occupant&quot;</span>;&#125;<br></code></pre></td></tr></table></figure><p>然后我就可以去掉所有条件代码。</p><p><strong>客户端 1…</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">const customerName <span class="hljs-operator">=</span> aCustomer.name<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>测试通过之后，我可能会用内联变量（123）把 customerName 变量也消除掉。</p><p>接下来处理代表“计价套餐”的 billingPlan 属性。</p><p><strong>客户端 2…</strong></p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-keyword">const</span> plan = isUnknown(aCustomer)<br>  ? registry.billingPlans.<span class="hljs-keyword">basic</span><br>  : aCustomer.billingPlan;<br></code></pre></td></tr></table></figure><p><strong>客户端 3…</strong></p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">if</span> (!isUnknown(aCustomer)) aCustomer.billingPlan = <span class="hljs-keyword">new</span><span class="hljs-type">Plan</span>;<br></code></pre></td></tr></table></figure><p>对于读取该属性的行为，我的处理方法跟前面处理 name 属性一样——找到通用的应对方式，并在 UnknownCustomer 中使用之。至于对该属性的写操作，当前的代码没有对未知顾客调用过设值函数，所以在特例对象中，我会保留设值函数，但其中什么都不做。</p><p><strong>class UnknownCustomer…</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">get</span> <span class="hljs-title">billingPlan</span>()</span>  &#123;<span class="hljs-keyword">return</span> registry.billingPlans.basic;&#125;<br><span class="hljs-function"><span class="hljs-keyword">set</span> <span class="hljs-title">billingPlan</span>(<span class="hljs-params">arg</span>)</span> &#123; <span class="hljs-comment">/* ignore */</span> &#125;<br></code></pre></td></tr></table></figure><p><strong>读取的例子…</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">const plan <span class="hljs-operator">=</span> aCustomer.billingPlan<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><strong>更新的例子…</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">aCustomer.billingPlan</span> = newPlan<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>特例对象是值对象，因此应该始终是不可变的，即便它们替代的原对象本身是可变的。</p><p>最后一个例子则更麻烦一些，因为特例对象需要返回另一个对象，后者又有其自己的属性。</p><p><strong>客户端…</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">const weeksDelinquent = is<span class="hljs-constructor">Unknown(<span class="hljs-params">aCustomer</span>)</span><br>  ? <span class="hljs-number">0</span><br>  : aCustomer.paymentHistory.weeksDelinquentInLastYear;<br></code></pre></td></tr></table></figure><p>一般的原则是：如果特例对象需要返回关联对象，被返回的通常也是特例对象。所以，我需要创建一个代表“空支付记录”的特例类 NullPaymentHistory。</p><p><strong>class UnknownCustomer…</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">get</span> <span class="hljs-title">paymentHistory</span>()</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> NullPaymentHistory();&#125;<br></code></pre></td></tr></table></figure><p><strong>class NullPaymentHistory…</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">get</span> <span class="hljs-title">weeksDelinquentInLastYear</span>()</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br></code></pre></td></tr></table></figure><p><strong>客户端…</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">const weeksDelinquent <span class="hljs-operator">=</span> aCustomer.paymentHistory.weeksDelinquentInLastYear<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>我继续查看客户端代码，寻找是否有能用多态行为取代的地方。但也会有例外情况——客户端不想使用特例对象提供的逻辑，而是想做一些别的处理。我可能有 23 处客户端代码用”occupant”作为未知顾客的名字，但还有一处用了别的值。</p><p><strong>客户端…</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">const <span class="hljs-type">name</span> = !isUnknown(aCustomer) ? aCustomer.name : &quot;unknown occupant&quot;;<br></code></pre></td></tr></table></figure><p>这种情况下，我只能在客户端保留特例检查的逻辑。我会对其做些修改，让它使用 aCustomer 对象身上的 isUnknown 函数，也就是对全局的 isUnknown 函数使用内联函数（115）。</p><p><strong>客户端…</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">const <span class="hljs-type">name</span> = aCustomer.isUnknown ? &quot;unknown occupant&quot; : aCustomer.name;<br></code></pre></td></tr></table></figure><p>处理完所有客户端代码后，全局的 isUnknown 函数应该没人再调用了，可以用移除死代码（237）将其移除。</p><h3 id="范例：使用对象字面量"><a href="#范例：使用对象字面量" class="headerlink" title="范例：使用对象字面量"></a>范例：使用对象字面量</h3><p>我们在上面处理的其实是一些很简单的值，却要创建一个这样的类，未免有点儿大动干戈。但在上面这个例子中，我必须创建这样一个类，因为 Customer 类是允许使用者更新其内容的。但如果面对一个只读的数据结构，我就可以改用字面量对象（literal object）。</p><p>还是前面这个例子——几乎完全一样，除了一件事：这次没有客户端对 Customer 对象做更新操作：</p><p><strong>class Site…</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">get</span> <span class="hljs-title">customer</span>()</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._customer;&#125;<br></code></pre></td></tr></table></figure><p><strong>class Customer…</strong></p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nim">get name()           <span class="hljs-meta">&#123;...&#125;</span><br>get billingPlan()    <span class="hljs-meta">&#123;...&#125;</span><br><span class="hljs-type">set</span> billingPlan(arg) <span class="hljs-meta">&#123;...&#125;</span><br>get paymentHistory() <span class="hljs-meta">&#123;...&#125;</span><br></code></pre></td></tr></table></figure><p><strong>客户端 1…</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">const aCustomer <span class="hljs-operator">=</span> site.customer<span class="hljs-comment">;</span><br>// ... lots of intervening code ...<br>let customerName<span class="hljs-comment">;</span><br>if (aCustomer <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-string">&quot;unknown&quot;</span>) customerName <span class="hljs-operator">=</span> <span class="hljs-string">&quot;occupant&quot;</span><span class="hljs-comment">;</span><br>else customerName <span class="hljs-operator">=</span> aCustomer.name<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><strong>客户端 2…</strong></p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-keyword">const</span> plan =<br>  aCustomer === <span class="hljs-string">&quot;unknown&quot;</span> ? registry.billingPlans.<span class="hljs-keyword">basic</span> : aCustomer.billingPlan;<br></code></pre></td></tr></table></figure><p><strong>客户端 3…</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">const</span> weeksDelinquent =<br>  aCustomer === <span class="hljs-string">&quot;unknown&quot;</span><br>    ? <span class="hljs-number">0</span><br>    : aCustomer.paymentHistory.weeksDelinquentInLastYear;<br></code></pre></td></tr></table></figure><p>和前面的例子一样，我首先在 Customer 中添加 isUnknown 属性，并创建一个包含同名字段的特例对象。这次的区别在于，特例对象是一个字面量。</p><p><strong>class Customer…</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">get</span> <span class="hljs-title">isUnknown</span>()</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<br></code></pre></td></tr></table></figure><p><strong>顶层作用域…</strong></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">createUnknownCustomer</span>() &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">&#123;</span><br>    isUnknown: <span class="hljs-literal">true</span>,<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我对检查特例的条件逻辑运用提炼函数（106）。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">isUnknown</span>(arg) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">arg</span> === <span class="hljs-string">&quot;unknown&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>客户端 1…</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">let customerName<span class="hljs-comment">;</span><br>if (isUnknown(aCustomer)) customerName <span class="hljs-operator">=</span> <span class="hljs-string">&quot;occupant&quot;</span><span class="hljs-comment">;</span><br>else customerName <span class="hljs-operator">=</span> aCustomer.name<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><strong>客户端 2…</strong></p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-keyword">const</span> plan = isUnknown(aCustomer)<br>  ? registry.billingPlans.<span class="hljs-keyword">basic</span><br>  : aCustomer.billingPlan;<br></code></pre></td></tr></table></figure><p><strong>客户端 3…</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">const weeksDelinquent = is<span class="hljs-constructor">Unknown(<span class="hljs-params">aCustomer</span>)</span><br>  ? <span class="hljs-number">0</span><br>  : aCustomer.paymentHistory.weeksDelinquentInLastYear;<br></code></pre></td></tr></table></figure><p>修改 Site 类和做条件判断的 isUnknown 函数，开始使用特例对象。</p><p><strong>class Site…</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">get</span> customer() &#123;<br>  <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>._customer === <span class="hljs-string">&quot;unknown&quot;</span>) ? createUnknownCustomer() : <span class="hljs-keyword">this</span>._customer;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>顶层作用域…</strong></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">isUnknown</span>(arg) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">arg.isUnknown</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后把“以标准方式应对特例”的地方都替换成使用特例字面量的值。首先从“名字”开始：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">createUnknownCustomer</span>() &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">&#123;</span><br>    isUnknown: <span class="hljs-literal">true</span>,<br>    name: <span class="hljs-string">&quot;occupant&quot;</span>,<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>客户端 1…</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">const customerName <span class="hljs-operator">=</span> aCustomer.name<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>接着是“计价套餐”：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">createUnknownCustomer</span>() &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">&#123;</span><br>    isUnknown: <span class="hljs-literal">true</span>,<br>    name: <span class="hljs-string">&quot;occupant&quot;</span>,<br>    billingPlan: registry.billingPlans.basic,<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>客户端 2…</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">const plan <span class="hljs-operator">=</span> aCustomer.billingPlan<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>同样，我可以在字面量对象中创建一个嵌套的空支付记录对象：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">createUnknownCustomer</span>() &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">&#123;</span><br>    isUnknown: <span class="hljs-literal">true</span>,<br>    name: <span class="hljs-string">&quot;occupant&quot;</span>,<br>    billingPlan: registry.billingPlans.basic,<br>    paymentHistory: &#123;<br>      weeksDelinquentInLastYear: <span class="hljs-number">0</span>,<br>    &#125;,<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>客户端 3…</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">const weeksDelinquent <span class="hljs-operator">=</span> aCustomer.paymentHistory.weeksDelinquentInLastYear<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>如果使用了这样的字面量，应该使用诸如 Object.freeze 的方法将其冻结，使其不可变。通常，我还是喜欢用类多一点。</p><h3 id="范例：使用变换"><a href="#范例：使用变换" class="headerlink" title="范例：使用变换"></a>范例：使用变换</h3><p>前面两个例子都涉及了一个类，其实本重构手法也同样适用于记录，只要增加一个变换步骤即可。</p><p>假设我们的输入是一个简单的记录结构，大概像这样：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol"> name:</span> <span class="hljs-string">&quot;Acme Boston&quot;</span>,<br><span class="hljs-symbol"> location:</span> <span class="hljs-string">&quot;Malden MA&quot;</span>,<br> <span class="hljs-comment">// more site details</span><br><span class="hljs-symbol"> customer:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">  name:</span> <span class="hljs-string">&quot;Acme Industries&quot;</span>,<br><span class="hljs-symbol">  billingPlan:</span> <span class="hljs-string">&quot;plan-451&quot;</span>,<br><span class="hljs-symbol">  paymentHistory:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">   weeksDelinquentInLastYear:</span> <span class="hljs-number">7</span><br>   <span class="hljs-comment">//more</span><br>  <span class="hljs-punctuation">&#125;</span>,<br>  <span class="hljs-comment">// more</span><br> <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>有时顾客的名字未知，此时标记的方式与前面一样：将 customer 字段标记为字符串”unknown”。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">name:</span> <span class="hljs-string">&quot;Warehouse Unit 15&quot;</span>,<br><span class="hljs-symbol">location:</span> <span class="hljs-string">&quot;Malden MA&quot;</span>,<br><span class="hljs-comment">// more site details</span><br><span class="hljs-symbol">customer:</span> <span class="hljs-string">&quot;unknown&quot;</span>,<br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>客户端代码也类似，会检查“未知顾客”的情况：</p><p><strong>客户端 1…</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs abnf">const site <span class="hljs-operator">=</span> acquireSiteData()<span class="hljs-comment">;</span><br>const aCustomer <span class="hljs-operator">=</span> site.customer<span class="hljs-comment">;</span><br>// ... lots of intervening code ...<br>let customerName<span class="hljs-comment">;</span><br>if (aCustomer <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-string">&quot;unknown&quot;</span>) customerName <span class="hljs-operator">=</span> <span class="hljs-string">&quot;occupant&quot;</span><span class="hljs-comment">;</span><br>else customerName <span class="hljs-operator">=</span> aCustomer.name<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><strong>客户端 2…</strong></p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-keyword">const</span> plan =<br>  aCustomer === <span class="hljs-string">&quot;unknown&quot;</span> ? registry.billingPlans.<span class="hljs-keyword">basic</span> : aCustomer.billingPlan;<br></code></pre></td></tr></table></figure><p><strong>客户端 3…</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">const</span> weeksDelinquent =<br>  aCustomer === <span class="hljs-string">&quot;unknown&quot;</span><br>    ? <span class="hljs-number">0</span><br>    : aCustomer.paymentHistory.weeksDelinquentInLastYear;<br></code></pre></td></tr></table></figure><p>我首先要让 Site 数据结构经过一次变换，目前变换中只做了深复制，没有对数据做任何处理。</p><p><strong>客户端 1…</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs abnf">const rawSite <span class="hljs-operator">=</span> acquireSiteData()<span class="hljs-comment">;</span><br>const site <span class="hljs-operator">=</span> enrichSite(rawSite)<span class="hljs-comment">;</span><br>const aCustomer <span class="hljs-operator">=</span> site.customer<span class="hljs-comment">;</span><br>// ... lots of intervening code ...<br>let customerName<span class="hljs-comment">;</span><br>if (aCustomer <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-string">&quot;unknown&quot;</span>) customerName <span class="hljs-operator">=</span> <span class="hljs-string">&quot;occupant&quot;</span><span class="hljs-comment">;</span><br>else customerName <span class="hljs-operator">=</span> aCustomer.name<span class="hljs-comment">;</span><br><br>function enrichSite(inputSite) &#123;<br>  return _.cloneDeep(inputSite)<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>然后对“检查未知顾客”的代码运用提炼函数（106）。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">isUnknown</span>(aCustomer) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">aCustomer</span> === <span class="hljs-string">&quot;unknown&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>客户端 1…</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs abnf">const rawSite <span class="hljs-operator">=</span> acquireSiteData()<span class="hljs-comment">;</span><br>const site <span class="hljs-operator">=</span> enrichSite(rawSite)<span class="hljs-comment">;</span><br>const aCustomer <span class="hljs-operator">=</span> site.customer<span class="hljs-comment">;</span><br>// ... lots of intervening code ...<br>let customerName<span class="hljs-comment">;</span><br>if (isUnknown(aCustomer)) customerName <span class="hljs-operator">=</span> <span class="hljs-string">&quot;occupant&quot;</span><span class="hljs-comment">;</span><br>else customerName <span class="hljs-operator">=</span> aCustomer.name<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><strong>客户端 2…</strong></p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-keyword">const</span> plan = isUnknown(aCustomer)<br>  ? registry.billingPlans.<span class="hljs-keyword">basic</span><br>  : aCustomer.billingPlan;<br></code></pre></td></tr></table></figure><p><strong>客户端 3…</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">const weeksDelinquent = is<span class="hljs-constructor">Unknown(<span class="hljs-params">aCustomer</span>)</span><br>  ? <span class="hljs-number">0</span><br>  : aCustomer.paymentHistory.weeksDelinquentInLastYear;<br></code></pre></td></tr></table></figure><p>然后开始对 Site 数据做增强，首先是给 customer 字段加上 isUnknown 属性。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> enrich<span class="hljs-constructor">Site(<span class="hljs-params">aSite</span>)</span> &#123;<br>  const result = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">_</span>.</span></span>clone<span class="hljs-constructor">Deep(<span class="hljs-params">aSite</span>)</span>;<br>  const unknownCustomer = &#123;<br>    isUnknown: <span class="hljs-literal">true</span>,<br>  &#125;;<br><br>  <span class="hljs-keyword">if</span> (is<span class="hljs-constructor">Unknown(<span class="hljs-params">result</span>.<span class="hljs-params">customer</span>)</span>) result.customer = unknownCustomer;<br>  <span class="hljs-keyword">else</span> result.customer.isUnknown = <span class="hljs-literal">false</span>;<br>  return result;<br>&#125;<br></code></pre></td></tr></table></figure><p>随后修改检查特例的条件逻辑，开始使用新的属性。原来的检查逻辑也保留不动，所以现在的检查逻辑应该既能应对原来的 Site 数据，也能应对增强后的 Site 数据。</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-variable">function</span> <span class="hljs-title function_">isUnknown</span>(<span class="hljs-params">aCustomer</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable">aCustomer</span> <span class="hljs-operator">==</span><span class="hljs-operator">=</span> <span class="hljs-string">&quot;unknown&quot;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-variable">aCustomer</span>.<span class="hljs-property">isUnknown</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试，确保一切正常，然后针对特例使用函数组合成变换（149）。首先把“未知顾客的名字”的处理逻辑搬进增强函数。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> enrich<span class="hljs-constructor">Site(<span class="hljs-params">aSite</span>)</span> &#123;<br>  const result = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">_</span>.</span></span>clone<span class="hljs-constructor">Deep(<span class="hljs-params">aSite</span>)</span>;<br>  const unknownCustomer = &#123;<br>    isUnknown: <span class="hljs-literal">true</span>,<br>    name: <span class="hljs-string">&quot;occupant&quot;</span>,<br>  &#125;;<br><br>  <span class="hljs-keyword">if</span> (is<span class="hljs-constructor">Unknown(<span class="hljs-params">result</span>.<span class="hljs-params">customer</span>)</span>) result.customer = unknownCustomer;<br>  <span class="hljs-keyword">else</span> result.customer.isUnknown = <span class="hljs-literal">false</span>;<br>  return result;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>客户端 1…</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">const rawSite <span class="hljs-operator">=</span> acquireSiteData()<span class="hljs-comment">;</span><br>const site <span class="hljs-operator">=</span> enrichSite(rawSite)<span class="hljs-comment">;</span><br>const aCustomer <span class="hljs-operator">=</span> site.customer<span class="hljs-comment">;</span><br>// ... lots of intervening code ...<br>const customerName <span class="hljs-operator">=</span> aCustomer.name<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>测试，然后是“未知顾客的计价套餐”的处理逻辑。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> enrich<span class="hljs-constructor">Site(<span class="hljs-params">aSite</span>)</span> &#123;<br>  const result = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">_</span>.</span></span>clone<span class="hljs-constructor">Deep(<span class="hljs-params">aSite</span>)</span>;<br>  const unknownCustomer = &#123;<br>    isUnknown: <span class="hljs-literal">true</span>,<br>    name: <span class="hljs-string">&quot;occupant&quot;</span>,<br>    billingPlan: registry.billingPlans.basic,<br>  &#125;;<br><br>  <span class="hljs-keyword">if</span> (is<span class="hljs-constructor">Unknown(<span class="hljs-params">result</span>.<span class="hljs-params">customer</span>)</span>) result.customer = unknownCustomer;<br>  <span class="hljs-keyword">else</span> result.customer.isUnknown = <span class="hljs-literal">false</span>;<br>  return result;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>客户端 2…</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">const plan <span class="hljs-operator">=</span> aCustomer.billingPlan<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>再次测试，然后处理最后一处客户端代码。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> enrich<span class="hljs-constructor">Site(<span class="hljs-params">aSite</span>)</span> &#123;<br>  const result = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">_</span>.</span></span>clone<span class="hljs-constructor">Deep(<span class="hljs-params">aSite</span>)</span>;<br>  const unknownCustomer = &#123;<br>    isUnknown: <span class="hljs-literal">true</span>,<br>    name: <span class="hljs-string">&quot;occupant&quot;</span>,<br>    billingPlan: registry.billingPlans.basic,<br>    paymentHistory: &#123;<br>      weeksDelinquentInLastYear: <span class="hljs-number">0</span>,<br>    &#125;,<br>  &#125;;<br><br>  <span class="hljs-keyword">if</span> (is<span class="hljs-constructor">Unknown(<span class="hljs-params">result</span>.<span class="hljs-params">customer</span>)</span>) result.customer = unknownCustomer;<br>  <span class="hljs-keyword">else</span> result.customer.isUnknown = <span class="hljs-literal">false</span>;<br>  return result;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>客户端 3…</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">const weeksDelinquent <span class="hljs-operator">=</span> aCustomer.paymentHistory.weeksDelinquentInLastYear<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h2 id="10-6-引入断言（Introduce-Assertion）"><a href="#10-6-引入断言（Introduce-Assertion）" class="headerlink" title="10.6 引入断言（Introduce Assertion）"></a>10.6 引入断言（Introduce Assertion）</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp">  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.discountRate)<br>  <span class="hljs-keyword">base</span> = <span class="hljs-keyword">base</span> - (<span class="hljs-keyword">this</span>.discountRate * <span class="hljs-keyword">base</span>);<br><br><br>  assert(<span class="hljs-keyword">this</span>.discountRate&gt;= <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.discountRate)<br>  <span class="hljs-keyword">base</span> = <span class="hljs-keyword">base</span> - (<span class="hljs-keyword">this</span>.discountRate * <span class="hljs-keyword">base</span>);<br></code></pre></td></tr></table></figure><h3 id="动机-5"><a href="#动机-5" class="headerlink" title="动机"></a>动机</h3><p>常常会有这样一段代码：只有当某个条件为真时，该段代码才能正常运行。例如，平方根计算只对正值才能进行，又例如，某个对象可能假设一组字段中至少有一个不等于 null。</p><p>这样的假设通常并没有在代码中明确表现出来，你必须阅读整个算法才能看出。有时程序员会以注释写出这样的假设，而我要介绍的是一种更好的技术——使用断言明确标明这些假设。</p><p>断言是一个条件表达式，应该总是为真。如果它失败，表示程序员犯了错误。断言的失败不应该被系统任何地方捕捉。整个程序的行为在有没有断言出现的时候都应该完全一样。实际上，有些编程语言中的断言可以在编译期用一个开关完全禁用掉。</p><p>我常看见有人鼓励用断言来发现程序中的错误。这固然是一件好事，但却不是使用断言的唯一理由。断言是一种很有价值的交流形式——它们告诉阅读者，程序在执行到这一点时，对当前状态做了何种假设。另外断言对调试也很有帮助。而且，因为它们在交流上很有价值，即使解决了当下正在追踪的错误，我还是倾向于把断言留着。自测试的代码降低了断言在调试方面的价值，因为逐步逼近的单元测试通常能更好地帮助调试，但我仍然看重断言在交流方面的价值。</p><h3 id="做法-5"><a href="#做法-5" class="headerlink" title="做法"></a>做法</h3><p>如果你发现代码假设某个条件始终为真，就加入一个断言明确说明这种情况。</p><p>因为断言应该不会对系统运行造成任何影响，所以“加入断言”永远都应该是行为保持的。</p><h3 id="范例-5"><a href="#范例-5" class="headerlink" title="范例"></a>范例</h3><p>下面是一个简单的例子：折扣。顾客（customer）会获得一个折扣率（discount rate），可以用于所有其购买的商品。</p><p><strong>class Customer…</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">applyDiscount(aNumber) &#123;<br>  <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.discountRate)<br>    ? aNumber - (<span class="hljs-keyword">this</span>.discountRate * aNumber)<br>    : aNumber;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里有一个假设：折扣率永远是正数。我可以用断言明确标示出这个假设。但在一个三元表达式中没办法很简单地插入断言，所以我首先要把这个表达式转换成 if-else 的形式。</p><p><strong>class Customer…</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">applyDiscount(aNumber) &#123;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.discountRate) <span class="hljs-keyword">return</span> aNumber;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> aNumber - (<span class="hljs-keyword">this</span>.discountRate * aNumber);<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我就可以轻松地加入断言了。</p><p><strong>class Customer…</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">applyDiscount(aNumber) &#123;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.discountRate) <span class="hljs-keyword">return</span> aNumber;<br>  <span class="hljs-keyword">else</span> &#123;<br>    assert(<span class="hljs-keyword">this</span>.discountRate &gt;= <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> aNumber - (<span class="hljs-keyword">this</span>.discountRate * aNumber);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对这个例子而言，我更愿意把断言放在设值函数上。如果在 applyDiscount 函数处发生断言失败，我还得先费力搞清楚非法的折扣率值起初是从哪儿放进去的。</p><p><strong>class Customer…</strong></p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-variable">set</span> <span class="hljs-title function_">discountRate</span>(<span class="hljs-params">aNumber</span>) &#123;<br>  <span class="hljs-title function_">assert</span>(<span class="hljs-literal">null</span> <span class="hljs-operator">==</span><span class="hljs-operator">=</span> <span class="hljs-variable">aNumber</span> <span class="hljs-operator">||</span> <span class="hljs-variable">aNumber</span> <span class="hljs-operator">&gt;=</span> <span class="hljs-number">0</span>);<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-variable">_discountRate</span> <span class="hljs-operator">=</span> <span class="hljs-variable">aNumber</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>真正引起错误的源头有可能很难发现——也许是输入数据中误写了一个减号，也许是某处代码做数据转换时犯了错误。像这样的断言对于发现错误源头特别有帮助。</p><p>注意，不要滥用断言。我不会使用断言来检查所有“我认为应该为真”的条件，只用来检查“必须为真”的条件。滥用断言可能会造成代码重复，尤其是在处理上面这样的条件逻辑时。所以我发现，很有必要去掉条件逻辑中的重复，通常可以借助提炼函数（106）手法。</p><p>我只用断言预防程序员的错误。如果要从某个外部数据源读取数据，那么所有对输入值的检查都应该是程序的一等公民，而不能用断言实现——除非我对这个外部数据源有绝对的信心。断言是帮助我们跟踪 bug 的最后一招，所以，或许听来讽刺，只有当我认为断言绝对不会失败的时候，我才会使用断言。</p><hr><h1 id="11-重构-API"><a href="#11-重构-API" class="headerlink" title="11.重构 API"></a>11.重构 API</h1><p>模块和函数是软件的骨肉，而 API 则是将骨肉连接起来的关节。易于理解和使用的 API 非常重要，但同时也很难获得。随着对软件理解的加深，我会学到如何改进 API，这时我便需要对 API 进行重构。</p><p>好的 API 会把更新数据的函数与只是读取数据的函数清晰分开。如果我看到这两类操作被混在一起，就会用将查询函数和修改函数分离（306）将它们分开。如果两个函数的功能非常相似、只有一些数值不同，我可以用函数参数化（310）将其统一。但有些参数其实只是一个标记，根据这个标记的不同，函数会有截然不同的行为，此时最好用移除标记参数（314）将不同的行为彻底分开。</p><p>在函数间传递时，数据结构常会毫无必要地被拆开，我更愿意用保持对象完整（319）将其聚拢。函数需要的一份信息，究竟何时应该作为参数传入、何时应该调用一个函数获得，这是一个需要反复推敲的决定，推敲的过程中常常要用到以查询取代参数（324）和以参数取代查询（327）。</p><p>类是一种常见的模块形式。我希望尽可能保持对象不可变，所以只要有可能，我就会使用移除设值函数（331）。当调用者要求一个新对象时，我经常需要比构造函数更多的灵活性，可以借助以工厂函数取代构造函数（334）获得这种灵活性。</p><p>有时你会遇到一个特别复杂的函数，围绕着它传入传出一大堆数据。最后两个重构手法专门用于破解这个难题。我可以用以命令取代函数（337）将这个函数变成对象，这样对函数体使用提炼函数（106）时会更容易。如果稍后我对该函数做了简化，不再需要将其作为命令对象了，可以用以函数取代命令（344）再把它变回函数。</p><h2 id="11-1-将查询函数和修改函数分离（Separate-Query-from-Modifier）"><a href="#11-1-将查询函数和修改函数分离（Separate-Query-from-Modifier）" class="headerlink" title="11.1 将查询函数和修改函数分离（Separate Query from Modifier）"></a>11.1 将查询函数和修改函数分离（Separate Query from Modifier）</h2><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getTotalOutstandingAndSendBill</span>(<span class="hljs-params"></span>) &#123;<br>const result = customer.invoices.<span class="hljs-built_in">reduce</span>(<span class="hljs-function">(<span class="hljs-params">total, each</span>) =&gt;</span> each.amount + total, <span class="hljs-number">0</span>);<br>sendBill();<br><span class="hljs-keyword">return</span> result;<br>&#125;<br><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">totalOutstanding</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">return</span> customer.invoices.<span class="hljs-built_in">reduce</span>(<span class="hljs-function">(<span class="hljs-params">total, each</span>) =&gt;</span> each.amount + total, <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sendBill</span>(<span class="hljs-params"></span>) &#123;<br>emailGateway.send(formatBill(customer));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="动机-6"><a href="#动机-6" class="headerlink" title="动机"></a>动机</h3><p>如果某个函数只是提供一个值，没有任何看得到的副作用，那么这是一个很有价值的东西。我可以任意调用这个函数，也可以把调用动作搬到调用函数的其他地方。这种函数的测试也更容易。简而言之，需要操心的事情少多了。</p><p>明确表现出“有副作用”与“无副作用”两种函数之间的差异，是个很好的想法。下面是一条好规则：任何有返回值的函数，都不应该有看得到的副作用——命令与查询分离（Command-Query Separation）[mf-cqs]。有些程序员甚至将此作为一条必须遵守的规则。就像对待任何东西一样，我并不绝对遵守它，不过我总是尽量遵守，而它也回报我很好的效果。</p><p>如果遇到一个“既有返回值又有副作用”的函数，我就会试着将查询动作从修改动作中分离出来。</p><p>你也许已经注意到了：我使用“看得到的副作用”这种说法。有一种常见的优化办法是：将查询所得结果缓存于某个字段中，这样一来后续的重复查询就可以大大加快速度。虽然这种做法改变了对象中缓存的状态，但这一修改是察觉不到的，因为不论如何查询，总是获得相同结果。</p><h3 id="做法-6"><a href="#做法-6" class="headerlink" title="做法"></a>做法</h3><p>复制整个函数，将其作为一个查询来命名。</p><p>如果想不出好名字，可以看看函数返回的是什么。查询的结果会被填入一个变量，这个变量的名字应该能对函数如何命名有所启发。</p><p>从新建的查询函数中去掉所有造成副作用的语句。</p><p>执行静态检查。</p><p>查找所有调用原函数的地方。如果调用处用到了该函数的返回值，就将其改为调用新建的查询函数，并在下面马上再调用一次原函数。每次修改之后都要测试。</p><p>从原函数中去掉返回值。</p><p>测试。</p><p>完成重构之后，查询函数与原函数之间常会有重复代码，可以做必要的清理。</p><h3 id="范例-6"><a href="#范例-6" class="headerlink" title="范例"></a>范例</h3><p>有这样一个函数：它会遍历一份恶棍（miscreant）名单，检查一群人（people）里是否混进了恶棍。如果发现了恶棍，该函数会返回恶棍的名字，并拉响警报。如果人群中有多名恶棍，该函数也只汇报找出的第一名恶棍（我猜这就已经够了）。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs abnf">function alertForMiscreant(people) &#123;<br>  for (const p of people) &#123;<br>    if (p <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-string">&quot;Don&quot;</span>) &#123;<br>      setOffAlarms()<span class="hljs-comment">;</span><br>      return <span class="hljs-string">&quot;Don&quot;</span><span class="hljs-comment">;</span><br>    &#125;<br>    if (p <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-string">&quot;John&quot;</span>) &#123;<br>      setOffAlarms()<span class="hljs-comment">;</span><br>      return <span class="hljs-string">&quot;John&quot;</span><span class="hljs-comment">;</span><br>    &#125;<br>  &#125;<br>  return <span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>首先我复制整个函数，用它的查询部分功能为其命名。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs abnf">function findMiscreant(people) &#123;<br>  for (const p of people) &#123;<br>    if (p <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-string">&quot;Don&quot;</span>) &#123;<br>      setOffAlarms()<span class="hljs-comment">;</span><br>      return <span class="hljs-string">&quot;Don&quot;</span><span class="hljs-comment">;</span><br>    &#125;<br>    if (p <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-string">&quot;John&quot;</span>) &#123;<br>      setOffAlarms()<span class="hljs-comment">;</span><br>      return <span class="hljs-string">&quot;John&quot;</span><span class="hljs-comment">;</span><br>    &#125;<br>  &#125;<br>  return <span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>然后在新建的查询函数中去掉副作用。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs abnf">function findMiscreant(people) &#123;<br>  for (const p of people) &#123;<br>    if (p <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-string">&quot;Don&quot;</span>) &#123;<br>      setOffAlarms()<span class="hljs-comment">;</span><br>      return <span class="hljs-string">&quot;Don&quot;</span><span class="hljs-comment">;</span><br>    &#125;<br>    if (p <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-string">&quot;John&quot;</span>) &#123;<br>      setOffAlarms()<span class="hljs-comment">;</span><br>      return <span class="hljs-string">&quot;John&quot;</span><span class="hljs-comment">;</span><br>    &#125;<br>  &#125;<br>  return <span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>然后找到所有原函数的调用者，将其改为调用新建的查询函数，并在其后调用一次修改函数（也就是原函数）。于是代码</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">const found <span class="hljs-operator">=</span> alertForMiscreant(people)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>就变成了</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">const found = find<span class="hljs-constructor">Miscreant(<span class="hljs-params">people</span>)</span>;<br>alert<span class="hljs-constructor">ForMiscreant(<span class="hljs-params">people</span>)</span>;<br></code></pre></td></tr></table></figure><p>现在可以从修改函数中去掉所有返回值了。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs abnf">function alertForMiscreant(people) &#123;<br>  for (const p of people) &#123;<br>    if (p <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-string">&quot;Don&quot;</span>) &#123;<br>      setOffAlarms()<span class="hljs-comment">;</span><br>      return<span class="hljs-comment">;</span><br>    &#125;<br>    if (p <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-string">&quot;John&quot;</span>) &#123;<br>      setOffAlarms()<span class="hljs-comment">;</span><br>      return<span class="hljs-comment">;</span><br>    &#125;<br>  &#125;<br>  return<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>现在，原来的修改函数和新建的查询函数之间有大量的重复代码，我可以使用替换算法（195），让修改函数使用查询函数。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> alert<span class="hljs-constructor">ForMiscreant(<span class="hljs-params">people</span>)</span> &#123;<br>  <span class="hljs-keyword">if</span> (find<span class="hljs-constructor">Miscreant(<span class="hljs-params">people</span>)</span> !== <span class="hljs-string">&quot;&quot;</span>) set<span class="hljs-constructor">OffAlarms()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="11-2-函数参数化（Parameterize-Function）"><a href="#11-2-函数参数化（Parameterize-Function）" class="headerlink" title="11.2 函数参数化（Parameterize Function）"></a>11.2 函数参数化（Parameterize Function）</h2><p>曾用名：令函数携带参数（Parameterize Method）</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">tenPercentRaise</span>(aPerson) &#123;<br>  aPerson.salary = aPerson.salary.multiply(1.1);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title">fivePercentRaise</span>(aPerson) &#123;<br>  aPerson.salary = aPerson.salary.multiply(1.05);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title">raise</span>(aPerson, factor) &#123;<br>  aPerson.salary = aPerson.salary.multiply(1 + factor);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="动机-7"><a href="#动机-7" class="headerlink" title="动机"></a>动机</h3><p>如果我发现两个函数逻辑非常相似，只有一些字面量值不同，可以将其合并成一个函数，以参数的形式传入不同的值，从而消除重复。这个重构可以使函数更有用，因为重构后的函数还可以用于处理其他的值。</p><h3 id="做法-7"><a href="#做法-7" class="headerlink" title="做法"></a>做法</h3><p>从一组相似的函数中选择一个。</p><p>运用改变函数声明（124），把需要作为参数传入的字面量添加到参数列表中。</p><p>修改该函数所有的调用处，使其在调用时传入该字面量值。</p><p>测试。</p><p>修改函数体，令其使用新传入的参数。每使用一个新参数都要测试。</p><p>对于其他与之相似的函数，逐一将其调用处改为调用已经参数化的函数。每次修改后都要测试。</p><p>如果第一个函数经过参数化以后不能直接替代另一个与之相似的函数，就先对参数化之后的函数做必要的调整，再做替换。</p><h3 id="范例-7"><a href="#范例-7" class="headerlink" title="范例"></a>范例</h3><p>下面是一个显而易见的例子：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">tenPercentRaise</span>(aPerson) &#123;<br>  aPerson.salary = aPerson.salary.multiply(1.1);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title">fivePercentRaise</span>(aPerson) &#123;<br>  aPerson.salary = aPerson.salary.multiply(1.05);<br>&#125;<br></code></pre></td></tr></table></figure><p>很明显我可以用下面这个函数来替换上面两个：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">raise</span>(aPerson, factor) &#123;<br>  aPerson.salary = aPerson.salary.multiply(1 + factor);<br>&#125;<br></code></pre></td></tr></table></figure><p>情况可能比这个更复杂一些。例如下列代码：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">baseCharge</span>(usage) &#123;<br> if (usage &lt; 0) <span class="hljs-keyword">return</span> <span class="hljs-type">usd(0)</span>;<br> const amount =<br>    bottomBand(usage) * <span class="hljs-number">0.03</span><br>    + middleBand(usage) * <span class="hljs-number">0.05</span><br>    + topBand(usage) * <span class="hljs-number">0.07</span>;<br> <span class="hljs-keyword">return</span> usd(amount);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title">bottomBand</span>(usage) &#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-type">Math.min(usage,</span> <span class="hljs-number">100</span>);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title">middleBand</span>(usage) &#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-type">usage</span> &gt; <span class="hljs-number">100</span> ? Math.min(usage, <span class="hljs-number">200</span>) - <span class="hljs-number">100</span> : 0;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title">topBand</span>(usage) &#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-type">usage</span> &gt; <span class="hljs-number">200</span> ? usage - <span class="hljs-number">200</span> : 0;<br>&#125;<br></code></pre></td></tr></table></figure><p>这几个函数中的逻辑明显很相似，但是不是相似到足以支撑一个参数化的计算“计费档次”（band）的函数？这次就不像前面第一个例子那样一目了然了。</p><p>在尝试对几个相关的函数做参数化操作时，我会先从中挑选一个，在上面添加参数，同时留意其他几种情况。在类似这样处理“范围”的情况下，通常从位于中间的范围开始着手较好。所以我首先选择了 middleBand 函数来添加参数，然后调整其他的调用者来适应它。</p><p>middleBand 使用了两个字面量值，即 100 和 200，分别代表“中间档次”的下界和上界。我首先用改变函数声明（124）加上这两个参数，同时顺手给函数改个名，使其更好地表述参数化之后的含义。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> within<span class="hljs-constructor">Band(<span class="hljs-params">usage</span>, <span class="hljs-params">bottom</span>, <span class="hljs-params">top</span>)</span> &#123;<br> return usage &gt; <span class="hljs-number">100</span> ? <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>min(usage, <span class="hljs-number">200</span>) - <span class="hljs-number">100</span> : <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> base<span class="hljs-constructor">Charge(<span class="hljs-params">usage</span>)</span> &#123;<br> <span class="hljs-keyword">if</span> (usage &lt; <span class="hljs-number">0</span>) return usd(<span class="hljs-number">0</span>);<br> const amount =<br>    bottom<span class="hljs-constructor">Band(<span class="hljs-params">usage</span>)</span><span class="hljs-operator"> * </span><span class="hljs-number">0.03</span><br>    + within<span class="hljs-constructor">Band(<span class="hljs-params">usage</span>, 100, 200)</span><span class="hljs-operator"> * </span><span class="hljs-number">0.05</span><br>    + top<span class="hljs-constructor">Band(<span class="hljs-params">usage</span>)</span><span class="hljs-operator"> * </span><span class="hljs-number">0.07</span>;<br> return usd(amount);<br>&#125;<br></code></pre></td></tr></table></figure><p>在函数体内部，把一个字面量改为使用新传入的参数：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">withinBand</span>(usage, bottom, top) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">usage</span> &amp; gt;<br>  bottom ? Math.min(usage, <span class="hljs-number">200</span>) - bottom : 0;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后是另一个：</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nsis"><span class="hljs-keyword">function</span> <span class="hljs-title function_">withinBand</span>(usage, <span class="hljs-literal">bottom</span>, <span class="hljs-literal">top</span>) &#123;<br>  <span class="hljs-keyword">return</span> usage &amp; gt<span class="hljs-comment">;</span><br>  <span class="hljs-literal">bottom</span> ? Math.min(usage, <span class="hljs-literal">top</span>) - <span class="hljs-literal">bottom</span> : <span class="hljs-number">0</span><span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>对于原本调用 bottomBand 函数的地方，我将其改为调用参数化了的新函数。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> baseCharge(<span class="hljs-keyword">usage</span>) &#123;<br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">usage</span> &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> usd(<span class="hljs-number">0</span>);<br> const amount =<br>    withinBand(<span class="hljs-keyword">usage</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>) * <span class="hljs-number">0.03</span><br>    + withinBand(<span class="hljs-keyword">usage</span>, <span class="hljs-number">100</span>, <span class="hljs-number">200</span>) * <span class="hljs-number">0.05</span><br>    + topBand(<span class="hljs-keyword">usage</span>) * <span class="hljs-number">0.07</span>;<br> <span class="hljs-keyword">return</span> usd(amount);<br>&#125;<br><br><span class="hljs-keyword">function</span> bottomBand(<span class="hljs-keyword">usage</span>) &#123;<br> <span class="hljs-keyword">return</span> Math.min(<span class="hljs-keyword">usage</span>, <span class="hljs-number">100</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>为了替换对 topBand 的调用，我就得用代表“无穷大”的 Infinity 作为这个范围的上界。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> baseCharge(<span class="hljs-keyword">usage</span>) &#123;<br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">usage</span> &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> usd(<span class="hljs-number">0</span>);<br> const amount =<br>    withinBand(<span class="hljs-keyword">usage</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>) * <span class="hljs-number">0.03</span><br>    + withinBand(<span class="hljs-keyword">usage</span>, <span class="hljs-number">100</span>, <span class="hljs-number">200</span>) * <span class="hljs-number">0.05</span><br>    + withinBand(<span class="hljs-keyword">usage</span>, <span class="hljs-number">200</span>, <span class="hljs-keyword">Infinity</span>) * <span class="hljs-number">0.07</span>;<br> <span class="hljs-keyword">return</span> usd(amount);<br>&#125;<br><br><span class="hljs-keyword">function</span> topBand(<span class="hljs-keyword">usage</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">usage</span> &gt; <span class="hljs-number">200</span> ? <span class="hljs-keyword">usage</span> - <span class="hljs-number">200</span> : <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>照现在的逻辑，baseCharge 一开始的卫语句已经可以去掉了。不过，尽管这条语句已经失去了逻辑上的必要性，我还是愿意把它留在原地，因为它阐明了“传入的 usage 参数为负数”这种情况是如何处理的。</p><h2 id="11-3-移除标记参数（Remove-Flag-Argument）"><a href="#11-3-移除标记参数（Remove-Flag-Argument）" class="headerlink" title="11.3 移除标记参数（Remove Flag Argument）"></a>11.3 移除标记参数（Remove Flag Argument）</h2><p>曾用名：以明确函数取代参数（Replace Parameter with Explicit Methods）</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-variable">function</span> <span class="hljs-title function_">setDimension</span>(<span class="hljs-params">name</span>, <span class="hljs-params">value</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable">name</span> <span class="hljs-operator">==</span><span class="hljs-operator">=</span> <span class="hljs-string">&quot;height&quot;</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-variable">_height</span> <span class="hljs-operator">=</span> <span class="hljs-variable">value</span>;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable">name</span> <span class="hljs-operator">==</span><span class="hljs-operator">=</span> <span class="hljs-string">&quot;width&quot;</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-variable">_width</span> <span class="hljs-operator">=</span> <span class="hljs-variable">value</span>;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-variable">function</span> <span class="hljs-title function_">setHeight</span>(<span class="hljs-params">value</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-variable">_height</span> <span class="hljs-operator">=</span> <span class="hljs-variable">value</span>;<br>&#125;<br><span class="hljs-variable">function</span> <span class="hljs-title function_">setWidth</span>(<span class="hljs-params">value</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-variable">_width</span> <span class="hljs-operator">=</span> <span class="hljs-variable">value</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="动机-8"><a href="#动机-8" class="headerlink" title="动机"></a>动机</h3><p>“标记参数”是这样的一种参数：调用者用它来指示被调函数应该执行哪一部分逻辑。例如，我可能有下面这样一个函数：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> book<span class="hljs-constructor">Concert(<span class="hljs-params">aCustomer</span>, <span class="hljs-params">isPremium</span>)</span> &#123;<br>  <span class="hljs-keyword">if</span> (isPremium) &#123;<br>    <span class="hljs-comment">// logic for premium booking</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// logic for regular booking</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>要预订一场高级音乐会（premium concert），就得这样发起调用：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">book<span class="hljs-constructor">Concert(<span class="hljs-params">aCustomer</span>, <span class="hljs-params">true</span>)</span>;<br></code></pre></td></tr></table></figure><p>标记参数也可能以枚举的形式出现：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">book<span class="hljs-constructor">Concert(<span class="hljs-params">aCustomer</span>, CustomerType.PREMIUM)</span>;<br></code></pre></td></tr></table></figure><p>或者是以字符串（或者符号，如果编程语言支持的话）的形式出现：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">book<span class="hljs-constructor">Concert(<span class="hljs-params">aCustomer</span>, <span class="hljs-string">&quot;premium&quot;</span>)</span>;<br></code></pre></td></tr></table></figure><p>我不喜欢标记参数，因为它们让人难以理解到底有哪些函数可以调用、应该怎么调用。拿到一份 API 以后，我首先看到的是一系列可供调用的函数，但标记参数却隐藏了函数调用中存在的差异性。使用这样的函数，我还得弄清标记参数有哪些可用的值。布尔型的标记尤其糟糕，因为它们不能清晰地传达其含义——在调用一个函数时，我很难弄清 true 到底是什么意思。如果明确用一个函数来完成一项单独的任务，其含义会清晰得多。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">premium<span class="hljs-constructor">BookConcert(<span class="hljs-params">aCustomer</span>)</span>;<br></code></pre></td></tr></table></figure><p>并非所有类似这样的参数都是标记参数。如果调用者传入的是程序中流动的数据，这样的参数不算标记参数；只有调用者直接传入字面量值，这才是标记参数。另外，在函数实现内部，如果参数值只是作为数据传给其他函数，这就不是标记参数；只有参数值影响了函数内部的控制流，这才是标记参数。</p><p>移除标记参数不仅使代码更整洁，并且能帮助开发工具更好地发挥作用。去掉标记参数后，代码分析工具能更容易地体现出“高级”和“普通”两种预订逻辑在使用时的区别。</p><p>如果一个函数有多个标记参数，可能就不得不将其保留，否则我就得针对各个参数的各种取值的所有组合情况提供明确函数。不过这也是一个信号，说明这个函数可能做得太多，应该考虑是否能用更简单的函数来组合出完整的逻辑。</p><h3 id="做法-8"><a href="#做法-8" class="headerlink" title="做法"></a>做法</h3><p>针对参数的每一种可能值，新建一个明确函数。</p><p>如果主函数有清晰的条件分发逻辑，可以用分解条件表达式（260）创建明确函数；否则，可以在原函数之上创建包装函数。</p><p>对于“用字面量值作为参数”的函数调用者，将其改为调用新建的明确函数。</p><h3 id="范例-8"><a href="#范例-8" class="headerlink" title="范例"></a>范例</h3><p>在浏览代码时，我发现多处代码在调用一个函数计算物流（shipment）的到货日期（delivery date）。一些调用代码类似这样：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">aShipment.deliveryDate</span> = deliveryDate(anOrder, <span class="hljs-literal">true</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>另一些调用代码则是这样：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">aShipment.deliveryDate</span> = deliveryDate(anOrder, <span class="hljs-literal">false</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>面对这样的代码，我立即开始好奇：参数里这个布尔值是什么意思？是用来干什么的？</p><p>deliveryDate 函数主体如下所示：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deliveryDate</span>(<span class="hljs-params">anOrder, isRush</span>) &#123;<br>  <span class="hljs-keyword">if</span> (isRush) &#123;<br>    let deliveryTime;<br>    <span class="hljs-keyword">if</span> ([<span class="hljs-string">&quot;MA&quot;</span>, <span class="hljs-string">&quot;CT&quot;</span>].<span class="hljs-built_in">includes</span>(anOrder.deliveryState)) deliveryTime = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ([<span class="hljs-string">&quot;NY&quot;</span>, <span class="hljs-string">&quot;NH&quot;</span>].<span class="hljs-built_in">includes</span>(anOrder.deliveryState)) deliveryTime = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">else</span> deliveryTime = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">return</span> anOrder.placedOn.plusDays(<span class="hljs-number">1</span> + deliveryTime);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    let deliveryTime;<br>    <span class="hljs-keyword">if</span> ([<span class="hljs-string">&quot;MA&quot;</span>, <span class="hljs-string">&quot;CT&quot;</span>, <span class="hljs-string">&quot;NY&quot;</span>].<span class="hljs-built_in">includes</span>(anOrder.deliveryState)) deliveryTime = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ([<span class="hljs-string">&quot;ME&quot;</span>, <span class="hljs-string">&quot;NH&quot;</span>].<span class="hljs-built_in">includes</span>(anOrder.deliveryState)) deliveryTime = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">else</span> deliveryTime = <span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">return</span> anOrder.placedOn.plusDays(<span class="hljs-number">2</span> + deliveryTime);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>原来调用者用这个布尔型字面量来判断应该运行哪个分支的代码——典型的标记参数。然而函数的重点就在于要遵循调用者的指令，所以最好是用明确函数的形式明确说出调用者的意图。</p><p>对于这个例子，我可以使用分解条件表达式（260），得到下列代码：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deliveryDate</span>(<span class="hljs-params">anOrder, isRush</span>) &#123;<br>  <span class="hljs-keyword">if</span> (isRush) <span class="hljs-keyword">return</span> rushDeliveryDate(anOrder);<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> regularDeliveryDate(anOrder);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">rushDeliveryDate</span>(<span class="hljs-params">anOrder</span>) &#123;<br>  let deliveryTime;<br>  <span class="hljs-keyword">if</span> ([<span class="hljs-string">&quot;MA&quot;</span>, <span class="hljs-string">&quot;CT&quot;</span>].<span class="hljs-built_in">includes</span>(anOrder.deliveryState)) deliveryTime = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ([<span class="hljs-string">&quot;NY&quot;</span>, <span class="hljs-string">&quot;NH&quot;</span>].<span class="hljs-built_in">includes</span>(anOrder.deliveryState)) deliveryTime = <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">else</span> deliveryTime = <span class="hljs-number">3</span>;<br>  <span class="hljs-keyword">return</span> anOrder.placedOn.plusDays(<span class="hljs-number">1</span> + deliveryTime);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">regularDeliveryDate</span>(<span class="hljs-params">anOrder</span>) &#123;<br>  let deliveryTime;<br>  <span class="hljs-keyword">if</span> ([<span class="hljs-string">&quot;MA&quot;</span>, <span class="hljs-string">&quot;CT&quot;</span>, <span class="hljs-string">&quot;NY&quot;</span>].<span class="hljs-built_in">includes</span>(anOrder.deliveryState)) deliveryTime = <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ([<span class="hljs-string">&quot;ME&quot;</span>, <span class="hljs-string">&quot;NH&quot;</span>].<span class="hljs-built_in">includes</span>(anOrder.deliveryState)) deliveryTime = <span class="hljs-number">3</span>;<br>  <span class="hljs-keyword">else</span> deliveryTime = <span class="hljs-number">4</span>;<br>  <span class="hljs-keyword">return</span> anOrder.placedOn.plusDays(<span class="hljs-number">2</span> + deliveryTime);<br>&#125;<br></code></pre></td></tr></table></figure><p>这两个函数能更好地表达调用者的意图，现在我可以修改调用方代码了。调用代码</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">aShipment.deliveryDate</span> = deliveryDate(anOrder, <span class="hljs-literal">true</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>可以改为</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">aShipment.deliveryDate</span> = rushDeliveryDate(anOrder)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>另一个分支也类似。</p><p>处理完所有调用处，我就可以移除 deliveryDate 函数。</p><p>这个参数是标记参数，不仅因为它是布尔类型，而且还因为调用方以字面量的形式直接设置参数值。如果所有调用 deliveryDate 的代码都像这样：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">const isRush = determine<span class="hljs-constructor">IfRush(<span class="hljs-params">anOrder</span>)</span>;<br>aShipment.deliveryDate = delivery<span class="hljs-constructor">Date(<span class="hljs-params">anOrder</span>, <span class="hljs-params">isRush</span>)</span>;<br></code></pre></td></tr></table></figure><p>那我对这个函数的签名没有任何意见（不过我还是想用分解条件表达式（260）清理其内部实现）。</p><p>可能有一些调用者给这个参数传入的是字面量，将其作为标记参数使用；另一些调用者则传入正常的数据。若果真如此，我还是会使用移除标记参数（314），但不修改传入正常数据的调用者，重构结束时也不删除 deliveryDate 函数。这样我就提供了两套接口，分别支持不同的用途。</p><p>直接拆分条件逻辑是实施本重构的好方法，但只有当“根据参数值做分发”的逻辑发生在函数最外层（或者可以比较容易地将其重构至函数最外层）的时候，这一招才好用。函数内部也有可能以一种更纠结的方式使用标记参数，例如下面这个版本的 deliveryDate 函数：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> delivery<span class="hljs-constructor">Date(<span class="hljs-params">anOrder</span>, <span class="hljs-params">isRush</span>)</span> &#123;<br> <span class="hljs-keyword">let</span> result;<br> <span class="hljs-keyword">let</span> deliveryTime;<br> <span class="hljs-keyword">if</span> (anOrder.deliveryState<span class="hljs-operator"> === </span><span class="hljs-string">&quot;MA&quot;</span><span class="hljs-operator"> || </span>anOrder.deliveryState<span class="hljs-operator"> === </span><span class="hljs-string">&quot;CT&quot;</span>)<br>  deliveryTime = isRush? <span class="hljs-number">1</span> : <span class="hljs-number">2</span>;<br> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (anOrder.deliveryState<span class="hljs-operator"> === </span><span class="hljs-string">&quot;NY&quot;</span><span class="hljs-operator"> || </span>anOrder.deliveryState<span class="hljs-operator"> === </span><span class="hljs-string">&quot;NH&quot;</span>) &#123;<br>  deliveryTime = <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">if</span> (anOrder.deliveryState<span class="hljs-operator"> === </span><span class="hljs-string">&quot;NH&quot;</span> &amp;amp;&amp;amp; !isRush)<br>   deliveryTime = <span class="hljs-number">3</span>;<br> &#125;<br> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isRush)<br>  deliveryTime = <span class="hljs-number">3</span>;<br> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (anOrder.deliveryState<span class="hljs-operator"> === </span><span class="hljs-string">&quot;ME&quot;</span>)<br>  deliveryTime = <span class="hljs-number">3</span>;<br> <span class="hljs-keyword">else</span><br>  deliveryTime = <span class="hljs-number">4</span>;<br> result = anOrder.placedOn.plus<span class="hljs-constructor">Days(2 + <span class="hljs-params">deliveryTime</span>)</span>;<br> <span class="hljs-keyword">if</span> (isRush) result = result.minus<span class="hljs-constructor">Days(1)</span>;<br> return result;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种情况下，想把围绕 isRush 的分发逻辑剥离到顶层，需要的工作量可能会很大。所以我选择退而求其次，在 deliveryDate 之上添加两个函数：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">rushDeliveryDate</span>(anOrder) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">deliveryDate(anOrder,</span> <span class="hljs-literal">true</span>);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title">regularDeliveryDate</span>(anOrder) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">deliveryDate(anOrder,</span> <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>本质上，这两个包装函数分别代表了 deliveryDate 函数一部分的使用方式。不过它们并非从原函数中拆分而来，而是用代码文本强行定义的。</p><p>随后，我同样可以逐一替换原函数的调用者，就跟前面分解条件表达式之后的处理一样。如果没有任何一个调用者向 isRush 参数传入正常的数据，我最后会限制原函数的可见性，或是将其改名（例如改为 deliveryDateHelperOnly），让人一见即知不应直接使用这个函数。</p><h2 id="11-4-保持对象完整（Preserve-Whole-Object）"><a href="#11-4-保持对象完整（Preserve-Whole-Object）" class="headerlink" title="11.4 保持对象完整（Preserve Whole Object）"></a>11.4 保持对象完整（Preserve Whole Object）</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">const low = aRoom.daysTempRange.low;<br>const high = aRoom.daysTempRange.high;<br><span class="hljs-keyword">if</span> (aPlan.within<span class="hljs-constructor">Range(<span class="hljs-params">low</span>, <span class="hljs-params">high</span>)</span>)<br><br><br><span class="hljs-keyword">if</span> (aPlan.within<span class="hljs-constructor">Range(<span class="hljs-params">aRoom</span>.<span class="hljs-params">daysTempRange</span>)</span>)<br></code></pre></td></tr></table></figure><h3 id="动机-9"><a href="#动机-9" class="headerlink" title="动机"></a>动机</h3><p>如果我看见代码从一个记录结构中导出几个值，然后又把这几个值一起传递给一个函数，我会更愿意把整个记录传给这个函数，在函数体内部导出所需的值。</p><p>“传递整个记录”的方式能更好地应对变化：如果将来被调的函数需要从记录中导出更多的数据，我就不用为此修改参数列表。并且传递整个记录也能缩短参数列表，让函数调用更容易看懂。如果有很多函数都在使用记录中的同一组数据，处理这部分数据的逻辑常会重复，此时可以把这些处理逻辑搬移到完整对象中去。</p><p>也有时我不想采用本重构手法，因为我不想让被调函数依赖完整对象，尤其是在两者不在同一个模块中的时候。</p><p>从一个对象中抽取出几个值，单独对这几个值做某些逻辑操作，这是一种代码坏味道（依恋情结），通常标志着这段逻辑应该被搬移到对象中。保持对象完整经常发生在引入参数对象（140）之后，我会搜寻使用原来的数据泥团的代码，代之以使用新的对象。</p><p>如果几处代码都在使用对象的一部分功能，可能意味着应该用提炼类（182）把这一部分功能单独提炼出来。</p><p>还有一种常被忽视的情况：调用者将自己的若干数据作为参数，传递给被调用函数。这种情况下，我可以将调用者的自我引用（在 JavaScript 中就是 this）作为参数，直接传递给目标函数。</p><h3 id="做法-9"><a href="#做法-9" class="headerlink" title="做法"></a>做法</h3><p>新建一个空函数，给它以期望中的参数列表（即传入完整对象作为参数）。</p><p>给这个函数起一个容易搜索的名字，这样到重构结束时方便替换。</p><p>在新函数体内调用旧函数，并把新的参数（即完整对象）映射到旧的参数列表（即来源于完整对象的各项数据）。</p><p>执行静态检查。</p><p>逐一修改旧函数的调用者，令其使用新函数，每次修改之后执行测试。</p><p>修改之后，调用处用于“从完整对象中导出参数值”的代码可能就没用了，可以用移除死代码（237）去掉。</p><p>所有调用处都修改过来之后，使用内联函数（115）把旧函数内联到新函数体内。</p><p>给新函数改名，从重构开始时的容易搜索的临时名字，改为使用旧函数的名字，同时修改所有调用处。</p><h3 id="范例-9"><a href="#范例-9" class="headerlink" title="范例"></a>范例</h3><p>我们想象一个室温监控系统，它负责记录房间一天中的最高温度和最低温度，然后将实际的温度范围与预先规定的温度控制计划（heating plan）相比较，如果当天温度不符合计划要求，就发出警告。</p><p><strong>调用方…</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">const</span> low = aRoom.daysTempRange.low;<br><span class="hljs-attribute">const</span> high = aRoom.daysTempRange.high;<br><span class="hljs-attribute">if</span> (!aPlan.withinRange(low, high))<br>  alerts.push(<span class="hljs-string">&quot;room temperature went outside range&quot;</span>);<br></code></pre></td></tr></table></figure><p><strong>class HeatingPlan…</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">withinRange(bottom, top) &#123;<br> <span class="hljs-keyword">return</span> (bottom &gt;= <span class="hljs-keyword">this</span>._temperatureRange.low) &amp;amp;&amp;amp; (top &lt;= <span class="hljs-keyword">this</span>._temperatureRange.high);<br>&#125;<br></code></pre></td></tr></table></figure><p>其实我不必将“温度范围”的信息拆开来单独传递，只需将整个范围对象传递给 withinRange 函数即可。</p><p>首先，我在 HeatingPlan 类中新添一个空函数，给它赋予我认为合理的参数列表。</p><p><strong>class HeatingPlan…</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">xxNEWwithinRange</span><span class="hljs-params">(aNumberRange)</span></span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为这个函数最终要取代现有的 withinRange 函数，所以它也用了同样的名字，再加上一个容易替换的前缀。</p><p>然后在新函数体内调用现有的 withinRange 函数。因此，新函数体就完成了从新参数列表到旧函数参数列表的映射。</p><p><strong>class HeatingPlan…</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">xx<span class="hljs-constructor">NEWwithinRange(<span class="hljs-params">aNumberRange</span>)</span> &#123;<br>  return this.within<span class="hljs-constructor">Range(<span class="hljs-params">aNumberRange</span>.<span class="hljs-params">low</span>, <span class="hljs-params">aNumberRange</span>.<span class="hljs-params">high</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在开始正式的替换工作了，我要找到调用现有函数的地方，将其改为调用新函数。</p><p><strong>调用方…</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">const</span> low = aRoom.daysTempRange.low;<br><span class="hljs-attribute">const</span> high = aRoom.daysTempRange.high;<br><span class="hljs-attribute">if</span> (!aPlan.xxNEWwithinRange(aRoom.daysTempRange))<br>  alerts.push(<span class="hljs-string">&quot;room temperature went outside range&quot;</span>);<br></code></pre></td></tr></table></figure><p>在修改调用处时，我可能会发现一些代码在修改后已经不再需要，此时可以使用移除死代码（237）。</p><p><strong>调用方…</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">const</span> low = aRoom.daysTempRange.low;<br><span class="hljs-attribute">const</span> high = aRoom.daysTempRange.high;<br><span class="hljs-attribute">if</span> (!aPlan.xxNEWwithinRange(aRoom.daysTempRange))<br>  alerts.push(<span class="hljs-string">&quot;room temperature went outside range&quot;</span>);<br></code></pre></td></tr></table></figure><p>每次替换一处调用代码，每次修改后都要测试。</p><p>调用处全部替换完成后，用内联函数（115）将旧函数内联到新函数体内。</p><p><strong>class HeatingPlan…</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">xxNEWwithinRange(aNumberRange) &#123;<br> <span class="hljs-keyword">return</span> (aNumberRange.low &gt;= <span class="hljs-keyword">this</span>._temperatureRange.low) &amp;amp;&amp;amp;<br>  (aNumberRange.high &lt;= <span class="hljs-keyword">this</span>._temperatureRange.high);<br>&#125;<br></code></pre></td></tr></table></figure><p>终于可以去掉新函数那难看的前缀了，记得同时修改所有调用者。就算我所使用的开发环境不支持可靠的函数改名操作，有这个极具特色的前缀在，我也可以很方便地全局替换。</p><p><strong>class HeatingPlan…</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">withinRange(aNumberRange) &#123;<br> <span class="hljs-keyword">return</span> (aNumberRange.low &gt;= <span class="hljs-keyword">this</span>._temperatureRange.low) &amp;amp;&amp;amp;<br>  (aNumberRange.high &lt;= <span class="hljs-keyword">this</span>._temperatureRange.high);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>调用方…</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">if</span> (!aPlan.within<span class="hljs-constructor">Range(<span class="hljs-params">aRoom</span>.<span class="hljs-params">daysTempRange</span>)</span>)<br>  alerts.push(<span class="hljs-string">&quot;room temperature went outside range&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="范例：换个方式创建新函数"><a href="#范例：换个方式创建新函数" class="headerlink" title="范例：换个方式创建新函数"></a>范例：换个方式创建新函数</h3><p>在上面的示例中，我直接编写了新函数。大多数时候，这一步非常简单，也是创建新函数最容易的方式。不过有时还会用到另一种方式：可以完全通过重构手法的组合来得到新函数。</p><p>我从一处调用现有函数的代码开始。</p><p><strong>调用方…</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">const</span> low = aRoom.daysTempRange.low;<br><span class="hljs-attribute">const</span> high = aRoom.daysTempRange.high;<br><span class="hljs-attribute">if</span> (!aPlan.withinRange(low, high))<br>  alerts.push(<span class="hljs-string">&quot;room temperature went outside range&quot;</span>);<br></code></pre></td></tr></table></figure><p>我要先对代码做一些整理，以便用提炼函数（106）来创建新函数。目前的调用者代码还不具备可提炼的函数雏形，不过我可以先做几次提炼变量（119），使其轮廓显现出来。首先，我要把对旧函数的调用从条件判断中解放出来。</p><p><strong>调用方…</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">const</span> low = aRoom.daysTempRange.low;<br><span class="hljs-attribute">const</span> high = aRoom.daysTempRange.high;<br><span class="hljs-attribute">const</span> isWithinRange = aPlan.withinRange(low, high);<br><span class="hljs-attribute">if</span> (!isWithinRange) alerts.push(<span class="hljs-string">&quot;room temperature went outside range&quot;</span>);<br></code></pre></td></tr></table></figure><p>然后把输入参数也提炼出来。</p><p><strong>调用方…</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">const</span> tempRange = aRoom.daysTempRange;<br><span class="hljs-attribute">const</span> low = tempRange.low;<br><span class="hljs-attribute">const</span> high = tempRange.high;<br><span class="hljs-attribute">const</span> isWithinRange = aPlan.withinRange(low, high);<br><span class="hljs-attribute">if</span> (!isWithinRange) alerts.push(<span class="hljs-string">&quot;room temperature went outside range&quot;</span>);<br></code></pre></td></tr></table></figure><p>完成这一步之后，就可以用提炼函数（106）来创建新函数。</p><p><strong>调用方…</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">const</span> tempRange = aRoom.daysTempRange;<br><span class="hljs-attribute">const</span> isWithinRange = xxNEWwithinRange(aPlan, tempRange);<br><span class="hljs-attribute">if</span> (!isWithinRange) alerts.push(<span class="hljs-string">&quot;room temperature went outside range&quot;</span>);<br></code></pre></td></tr></table></figure><p><strong>顶层作用域…</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> xx<span class="hljs-constructor">NEWwithinRange(<span class="hljs-params">aPlan</span>, <span class="hljs-params">tempRange</span>)</span> &#123;<br>  const low = tempRange.low;<br>  const high = tempRange.high;<br>  const isWithinRange = aPlan.within<span class="hljs-constructor">Range(<span class="hljs-params">low</span>, <span class="hljs-params">high</span>)</span>;<br>  return isWithinRange;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于旧函数属于另一个上下文（HeatingPlan 类），我需要用搬移函数（198）把新函数也搬过去。</p><p><strong>调用方…</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">const</span> tempRange = aRoom.daysTempRange;<br><span class="hljs-attribute">const</span> isWithinRange = aPlan.xxNEWwithinRange(tempRange);<br><span class="hljs-attribute">if</span> (!isWithinRange) alerts.push(<span class="hljs-string">&quot;room temperature went outside range&quot;</span>);<br></code></pre></td></tr></table></figure><p><strong>class HeatingPlan…</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">xxNEWwithinRange</span>(<span class="hljs-params">tempRange</span>) &#123;<br>  <span class="hljs-keyword">const</span> low = tempRange.<span class="hljs-property">low</span>;<br>  <span class="hljs-keyword">const</span> high = tempRange.<span class="hljs-property">high</span>;<br>  <span class="hljs-keyword">const</span> isWithinRange = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">withinRange</span>(low, high);<br>  <span class="hljs-keyword">return</span> isWithinRange;<br>&#125;<br></code></pre></td></tr></table></figure><p>剩下的过程就跟前面一样了：替换其他调用者，然后把旧函数内联到新函数中。重构刚开始的时候，为了清晰分离函数调用，以便提炼出新函数，我提炼了几个变量出来，现在可以把这些变量也内联回去。</p><p>这种方式的好处在于：它完全是由其他重构手法组合而成的。如果我使用的开发工具支持可靠的提炼和内联操作，用这种方式进行本重构会特别流畅。</p><h2 id="11-5-以查询取代参数（Replace-Parameter-with-Query）"><a href="#11-5-以查询取代参数（Replace-Parameter-with-Query）" class="headerlink" title="11.5 以查询取代参数（Replace Parameter with Query）"></a>11.5 以查询取代参数（Replace Parameter with Query）</h2><p>曾用名：以函数取代参数（Replace Parameter with Method）</p><p>反向重构：以参数取代查询（327）</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">available<span class="hljs-constructor">Vacation(<span class="hljs-params">anEmployee</span>, <span class="hljs-params">anEmployee</span>.<span class="hljs-params">grade</span>)</span>;<br><br><span class="hljs-keyword">function</span> available<span class="hljs-constructor">Vacation(<span class="hljs-params">anEmployee</span>, <span class="hljs-params">grade</span>)</span> &#123;<br>  <span class="hljs-comment">// calculate vacation...</span><br><br><br>  available<span class="hljs-constructor">Vacation(<span class="hljs-params">anEmployee</span>)</span><br><br><span class="hljs-keyword">function</span> available<span class="hljs-constructor">Vacation(<span class="hljs-params">anEmployee</span>)</span> &#123;<br>  const grade = anEmployee.grade;<br>  <span class="hljs-comment">// calculate vacation...</span><br></code></pre></td></tr></table></figure><h3 id="动机-10"><a href="#动机-10" class="headerlink" title="动机"></a>动机</h3><p>函数的参数列表应该总结该函数的可变性，标示出函数可能体现出行为差异的主要方式。和任何代码中的语句一样，参数列表应该尽量避免重复，并且参数列表越短就越容易理解。</p><p>如果调用函数时传入了一个值，而这个值由函数自己来获得也是同样容易，这就是重复。这个本不必要的参数会增加调用者的难度，因为它不得不找出正确的参数值，其实原本调用者是不需要费这个力气的。</p><p>“同样容易”四个字，划出了一条判断的界限。去除参数也就意味着“获得正确的参数值”的责任被转移：有参数传入时，调用者需要负责获得正确的参数值；参数去除后，责任就被转移给了函数本身。一般而言，我习惯于简化调用方，因此我愿意把责任移交给函数本身，但如果函数难以承担这份责任，就另当别论了。</p><p>不使用以查询取代参数最常见的原因是，移除参数可能会给函数体增加不必要的依赖关系——迫使函数访问某个程序元素，而我原本不想让函数了解这个元素的存在。这种“不必要的依赖关系”除了新增的以外，也可能是我想要稍后去除的，例如为了去除一个参数，我可能会在函数体内调用一个有问题的函数，或是从一个对象中获取某些原本想要剥离出去的数据。在这些情况下，都应该慎重考虑使用以查询取代参数。</p><p>如果想要去除的参数值只需要向另一个参数查询就能得到，这是使用以查询取代参数最安全的场景。如果可以从一个参数推导出另一个参数，那么几乎没有任何理由要同时传递这两个参数。</p><p>另外有一件事需要留意：如果在处理的函数具有引用透明性（referential transparency，即，不论任何时候，只要传入相同的参数值，该函数的行为永远一致），这样的函数既容易理解又容易测试，我不想使其失去这种优秀品质。我不会去掉它的参数，让它去访问一个可变的全局变量。</p><h3 id="做法-10"><a href="#做法-10" class="headerlink" title="做法"></a>做法</h3><p>如果有必要，使用提炼函数（106）将参数的计算过程提炼到一个独立的函数中。</p><p>将函数体内引用该参数的地方改为调用新建的函数。每次修改后执行测试。</p><p>全部替换完成后，使用改变函数声明（124）将该参数去掉。</p><h3 id="范例-10"><a href="#范例-10" class="headerlink" title="范例"></a>范例</h3><p>某些重构会使参数不再被需要，这是我最常用到以查询取代参数的场合。考虑下列代码。</p><p><strong>class Order…</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">get</span> <span class="hljs-title function_">finalPrice</span>() &#123;<br> <span class="hljs-keyword">const</span> basePrice = <span class="hljs-variable language_">this</span>.<span class="hljs-property">quantity</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">itemPrice</span>;<br> <span class="hljs-keyword">let</span> discountLevel;<br> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">quantity</span> &gt; <span class="hljs-number">100</span>) discountLevel = <span class="hljs-number">2</span>;<br> <span class="hljs-keyword">else</span> discountLevel = <span class="hljs-number">1</span>;<br> <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">discountedPrice</span>(basePrice, discountLevel);<br>&#125;<br><br><span class="hljs-title function_">discountedPrice</span>(<span class="hljs-params">basePrice, discountLevel</span>) &#123;<br> <span class="hljs-keyword">switch</span> (discountLevel) &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> basePrice * <span class="hljs-number">0.95</span>;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-keyword">return</span> basePrice * <span class="hljs-number">0.9</span>;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在简化函数逻辑时，我总是热衷于使用以查询取代临时变量（178），于是就得到了如下代码。</p><p><strong>class Order…</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">get</span> finalPrice() &#123;<br> <span class="hljs-keyword">const</span> basePrice = <span class="hljs-keyword">this</span>.quantity * <span class="hljs-keyword">this</span>.itemPrice;<br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.discountedPrice(basePrice, <span class="hljs-keyword">this</span>.discountLevel);<br>&#125;<br><br><span class="hljs-keyword">get</span> discountLevel() &#123;<br> <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.quantity &gt; <span class="hljs-number">100</span>) ? <span class="hljs-number">2</span> : <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>到这一步，已经不需要再把 discountLevel 的计算结果传给 discountedPrice 了，后者可以自己调用 discountLevel 函数，不会增加任何难度。</p><p>因此，我把 discountedPrice 函数中用到这个参数的地方全都改为直接调用 discountLevel 函数。</p><p><strong>class Order…</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">discountedPrice</span>(<span class="hljs-params">basePrice, discountLevel</span>) &#123;<br> <span class="hljs-keyword">switch</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">discountLevel</span>) &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> basePrice * <span class="hljs-number">0.95</span>;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-keyword">return</span> basePrice * <span class="hljs-number">0.9</span>;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后用改变函数声明（124）手法移除该参数。</p><p><strong>class Order…</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">get</span> finalPrice() &#123;<br> <span class="hljs-keyword">const</span> basePrice = <span class="hljs-keyword">this</span>.quantity * <span class="hljs-keyword">this</span>.itemPrice;<br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.discountedPrice(basePrice, <span class="hljs-keyword">this</span>.discountLevel);<br>&#125;<br><br>discountedPrice(basePrice, discountLevel) &#123;<br> switch (<span class="hljs-keyword">this</span>.discountLevel) &#123;<br>  case <span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> basePrice * <span class="hljs-number">0.95</span>;<br>  case <span class="hljs-number">2</span>: <span class="hljs-keyword">return</span> basePrice * <span class="hljs-number">0.9</span>;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="11-6-以参数取代查询（Replace-Query-with-Parameter）"><a href="#11-6-以参数取代查询（Replace-Query-with-Parameter）" class="headerlink" title="11.6 以参数取代查询（Replace Query with Parameter）"></a>11.6 以参数取代查询（Replace Query with Parameter）</h2><p>反向重构：以查询取代参数（324）</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">  target<span class="hljs-constructor">Temperature(<span class="hljs-params">aPlan</span>)</span><br><br><span class="hljs-keyword">function</span> target<span class="hljs-constructor">Temperature(<span class="hljs-params">aPlan</span>)</span> &#123;<br>  currentTemperature = thermostat.currentTemperature;<br>  <span class="hljs-comment">// rest of function...</span><br><br><br>  target<span class="hljs-constructor">Temperature(<span class="hljs-params">aPlan</span>, <span class="hljs-params">thermostat</span>.<span class="hljs-params">currentTemperature</span>)</span><br><br><span class="hljs-keyword">function</span> target<span class="hljs-constructor">Temperature(<span class="hljs-params">aPlan</span>, <span class="hljs-params">currentTemperature</span>)</span> &#123;<br>  <span class="hljs-comment">// rest of function...</span><br></code></pre></td></tr></table></figure><h3 id="动机-11"><a href="#动机-11" class="headerlink" title="动机"></a>动机</h3><p>在浏览函数实现时，我有时会发现一些令人不快的引用关系，例如，引用一个全局变量，或者引用另一个我想要移除的元素。为了解决这些令人不快的引用，我需要将其替换为函数参数，从而将处理引用关系的责任转交给函数的调用者。</p><p>需要使用本重构的情况大多源于我想要改变代码的依赖关系——为了让目标函数不再依赖于某个元素，我把这个元素的值以参数形式传递给该函数。这里需要注意权衡：如果把所有依赖关系都变成参数，会导致参数列表冗长重复；如果作用域之间的共享太多，又会导致函数间依赖过度。我一向不善于微妙的权衡，所以“能够可靠地改变决定”就显得尤为重要，这样随着我的理解加深，程序也能从中受益。</p><p>如果一个函数用同样的参数调用总是给出同样的结果，我们就说这个函数具有“引用透明性”（referential transparency），这样的函数理解起来更容易。如果一个函数使用了另一个元素，而后者不具引用透明性，那么包含该元素的函数也就失去了引用透明性。只要把“不具引用透明性的元素”变成参数传入，函数就能重获引用透明性。虽然这样就把责任转移给了函数的调用者，但是具有引用透明性的模块能带来很多益处。有一个常见的模式：在负责逻辑处理的模块中只有纯函数，其外再包裹处理 I&#x2F;O 和其他可变元素的逻辑代码。借助以参数取代查询，我可以提纯程序的某些组成部分，使其更容易测试、更容易理解。</p><p>不过以参数取代查询并非只有好处。把查询变成参数以后，就迫使调用者必须弄清如何提供正确的参数值，这会增加函数调用者的复杂度，而我在设计接口时通常更愿意让接口的消费者更容易使用。归根到底，这是关于程序中责任分配的问题，而这方面的决策既不容易，也不会一劳永逸——这就是我需要非常熟悉本重构（及其反向重构）的原因。</p><h3 id="做法-11"><a href="#做法-11" class="headerlink" title="做法"></a>做法</h3><p>对执行查询操作的代码使用提炼变量（119），将其从函数体中分离出来。</p><p>现在函数体代码已经不再执行查询操作（而是使用前一步提炼出的变量），对这部分代码使用提炼函数（106）。</p><p>给提炼出的新函数起一个容易搜索的名字，以便稍后改名。</p><p>使用内联变量（123），消除刚才提炼出来的变量。</p><p>对原来的函数使用内联函数（115）。</p><p>对新函数改名，改回原来函数的名字。</p><h3 id="范例-11"><a href="#范例-11" class="headerlink" title="范例"></a>范例</h3><p>我们想象一个简单却又烦人的温度控制系统。用户可以从一个温控终端（thermostat）指定温度，但指定的目标温度必须在温度控制计划（heating plan）允许的范围内。</p><p><strong>class HeatingPlan…</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">get</span> targetTemperature() &#123;<br>  <span class="hljs-keyword">if</span> (thermostat.selectedTemperature &gt; <span class="hljs-keyword">this</span>._max) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._max;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (thermostat.selectedTemperature &lt; <span class="hljs-keyword">this</span>._min) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._min;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> thermostat.selectedTemperature;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>调用方…</strong></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">if (thePlan.targetTemperature &gt; thermostat.currentTemperature) <span class="hljs-built_in">setToHeat</span>();<br>else if (thePlan.targetTemperature&lt;thermostat.currentTemperature)<span class="hljs-built_in">setToCool</span>();<br>else <span class="hljs-built_in">setOff</span>();<br></code></pre></td></tr></table></figure><p>系统的温控计划规则抑制了我的要求，作为这样一个系统的用户，我可能会感到很烦恼。不过作为程序员，我更担心的是 targetTemperature 函数依赖于全局的 thermostat 对象。我可以把需要这个对象提供的信息作为参数传入，从而打破对该对象的依赖。</p><p>首先，我要用提炼变量（119）把“希望作为参数传入的信息”提炼出来。</p><p><strong>class HeatingPlan…</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">get</span> targetTemperature() &#123;<br> <span class="hljs-keyword">const</span> selectedTemperature = thermostat.selectedTemperature;<br> <span class="hljs-keyword">if</span>      (selectedTemperature &gt; <span class="hljs-keyword">this</span>._max) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._max;<br> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (selectedTemperature &lt; <span class="hljs-keyword">this</span>._min) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._min;<br> <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> selectedTemperature;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样可以比较容易地用提炼函数（106）把整个函数体提炼出来，只剩“计算参数值”的逻辑还在原地。</p><p><strong>class HeatingPlan…</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">get</span> targetTemperature() &#123;<br> <span class="hljs-keyword">const</span> selectedTemperature = thermostat.selectedTemperature;<br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.xxNEWtargetTemperature(selectedTemperature);<br>&#125;<br><br>xxNEWtargetTemperature(selectedTemperature) &#123;<br> <span class="hljs-keyword">if</span>      (selectedTemperature &gt; <span class="hljs-keyword">this</span>._max) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._max;<br> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (selectedTemperature &lt; <span class="hljs-keyword">this</span>._min) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._min;<br> <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> selectedTemperature;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后把刚才提炼出来的变量内联回去，于是旧函数就只剩一个简单的调用。</p><p><strong>class HeatingPlan…</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">get</span> <span class="hljs-title">targetTemperature</span>()</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.xxNEWtargetTemperature(thermostat.selectedTemperature);<br>&#125;<br></code></pre></td></tr></table></figure><p>现在可以对其使用内联函数（115）。</p><p><strong>调用方…</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">if</span> (thePlan.xx<span class="hljs-constructor">NEWtargetTemperature(<span class="hljs-params">thermostat</span>.<span class="hljs-params">selectedTemperature</span>)</span> &gt;<br>   thermostat.currentTemperature)<br> set<span class="hljs-constructor">ToHeat()</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (thePlan.xx<span class="hljs-constructor">NEWtargetTemperature(<span class="hljs-params">thermostat</span>.<span class="hljs-params">selectedTemperature</span>)</span> &lt;<br>     thermostat.currentTemperature)<br> set<span class="hljs-constructor">ToCool()</span>;<br><span class="hljs-keyword">else</span><br> set<span class="hljs-constructor">Off()</span>;<br></code></pre></td></tr></table></figure><p>再把新函数改名，用回旧函数的名字。得益于之前给它起了一个容易搜索的名字，现在只要把前缀去掉就行。</p><p><strong>调用方…</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">if</span> (thePlan.target<span class="hljs-constructor">Temperature(<span class="hljs-params">thermostat</span>.<span class="hljs-params">selectedTemperature</span>)</span> &gt;<br>   thermostat.currentTemperature)<br> set<span class="hljs-constructor">ToHeat()</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (thePlan.target<span class="hljs-constructor">Temperature(<span class="hljs-params">thermostat</span>.<span class="hljs-params">selectedTemperature</span>)</span> &lt;<br>     thermostat.currentTemperature)<br> set<span class="hljs-constructor">ToCool()</span>;<br><span class="hljs-keyword">else</span><br> set<span class="hljs-constructor">Off()</span>;<br></code></pre></td></tr></table></figure><p><strong>class HeatingPlan…</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">targetTemperature(selectedTemperature) &#123;<br> <span class="hljs-keyword">if</span> (selectedTemperature &gt; <span class="hljs-keyword">this</span>._max) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._max;<br> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (selectedTemperature &lt; <span class="hljs-keyword">this</span>._min) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._min;<br> <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> selectedTemperature;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用方的代码看起来比重构之前更笨重了，这是使用本重构手法的常见情况。将一个依赖关系从一个模块中移出，就意味着将处理这个依赖关系的责任推回给调用者。这是为了降低耦合度而付出的代价。</p><p>但是，去除对 thermostat 对象的耦合，并不是本重构带来的唯一收益。HeatingPlan 类本身是不可变的——字段的值都在构造函数中设置，任何函数都不会修改它们。（不用费心去查看整个类的代码，相信我就好。）在不可变的 HeatingPlan 基础上，把对 thermostat 的依赖移出函数体之后，我又使 targetTemperature 函数具备了引用透明性。从此以后，只要在同一个 HeatingPlan 对象上用同样的参数调用 targetTemperature 函数，我会始终得到同样的结果。如果 HeatingPlan 的所有函数都具有引用透明性，这个类会更容易测试，其行为也更容易理解。</p><p>JavaScript 的类模型有一个问题：无法强制要求类的不可变性——始终有办法修改对象的内部数据。尽管如此，在编写一个类的时候明确说明并鼓励不可变性，通常也就足够了。尽量让类保持不可变通常是一个好的策略，以参数取代查询则是达成这一策略的利器。</p><h2 id="11-7-移除设值函数（Remove-Setting-Method）"><a href="#11-7-移除设值函数（Remove-Setting-Method）" class="headerlink" title="11.7 移除设值函数（Remove Setting Method）"></a>11.7 移除设值函数（Remove Setting Method）</h2><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nim">class <span class="hljs-type">Person</span> &#123;<br>get name() <span class="hljs-meta">&#123;...&#125;</span><br><span class="hljs-type">set</span> name(aString) <span class="hljs-meta">&#123;...&#125;</span><br><br><br>class <span class="hljs-type">Person</span> &#123;<br>get name() <span class="hljs-meta">&#123;...&#125;</span><br></code></pre></td></tr></table></figure><h3 id="动机-12"><a href="#动机-12" class="headerlink" title="动机"></a>动机</h3><p>如果为某个字段提供了设值函数，这就暗示这个字段可以被改变。如果不希望在对象创建之后此字段还有机会被改变，那就不要为它提供设值函数（同时将该字段声明为不可变）。这样一来，该字段就只能在构造函数中赋值，我“不想让它被修改”的意图会更加清晰，并且可以排除其值被修改的可能性——这种可能性往往是非常大的。</p><p>有两种常见的情况需要讨论。一种情况是，有些人喜欢始终通过访问函数来读写字段值，包括在构造函数内也是如此。这会导致构造函数成为设值函数的唯一使用者。若果真如此，我更愿意去除设值函数，清晰地表达“构造之后不应该再更新字段值”的意图。</p><p>另一种情况是，对象是由客户端通过创建脚本构造出来，而不是只有一次简单的构造函数调用。所谓“创建脚本”，首先是调用构造函数，然后就是一系列设值函数的调用，共同完成新对象的构造。创建脚本执行完以后，这个新生对象的部分（乃至全部）字段就不应该再被修改。设值函数只应该在起初的对象创建过程中调用。对于这种情况，我也会想办法去除设值函数，更清晰地表达我的意图。</p><h3 id="做法-12"><a href="#做法-12" class="headerlink" title="做法"></a>做法</h3><p>如果构造函数尚无法得到想要设入字段的值，就使用改变函数声明（124）将这个值以参数的形式传入构造函数。在构造函数中调用设值函数，对字段设值。</p><p>如果想移除多个设值函数，可以一次性把它们的值都传入构造函数，这能简化后续步骤。</p><p>移除所有在构造函数之外对设值函数的调用，改为使用新的构造函数。每次修改之后都要测试。</p><p>如果不能把“调用设值函数”替换为“创建一个新对象”（例如你需要更新一个多处共享引用的对象），请放弃本重构。</p><p>使用内联函数（115）消去设值函数。如果可能的话，把字段声明为不可变。</p><p>测试。</p><h3 id="范例-12"><a href="#范例-12" class="headerlink" title="范例"></a>范例</h3><p>我有一个很简单的 Person 类。</p><p><strong>class Person…</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">get</span> <span class="hljs-title">name</span>()</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._name;&#125;<br><span class="hljs-function"><span class="hljs-keyword">set</span> <span class="hljs-title">name</span>(<span class="hljs-params">arg</span>)</span> &#123;<span class="hljs-keyword">this</span>._name = arg;&#125;<br><span class="hljs-function"><span class="hljs-keyword">get</span> <span class="hljs-title">id</span>()</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._id;&#125;<br><span class="hljs-function"><span class="hljs-keyword">set</span> <span class="hljs-title">id</span>(<span class="hljs-params">arg</span>)</span> &#123;<span class="hljs-keyword">this</span>._id = arg;&#125;<br></code></pre></td></tr></table></figure><p>目前我会这样创建新对象：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">const martin <span class="hljs-operator">=</span> new Person()<span class="hljs-comment">;</span><br>martin.name <span class="hljs-operator">=</span> <span class="hljs-string">&quot;martin&quot;</span><span class="hljs-comment">;</span><br>martin.id <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1234&quot;</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>对象创建之后，name 字段可能会改变，但 id 字段不会。为了更清晰地表达这个设计意图，我希望移除对应 id 字段的设值函数。</p><p>但 id 字段还得设置初始值，所以我首先用改变函数声明（124）在构造函数中添加对应的参数。</p><p><strong>class Person…</strong></p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-function"><span class="hljs-keyword">constructor</span><span class="hljs-params">(id)</span> <span class="hljs-comment">&#123;</span></span><br><span class="hljs-comment"><span class="hljs-function">  this.id = id;</span></span><br><span class="hljs-comment"><span class="hljs-function">&#125;</span></span><br></code></pre></td></tr></table></figure><p>然后调整创建脚本，改为从构造函数设值 id 字段值。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">const martin <span class="hljs-operator">=</span> new Person(<span class="hljs-string">&quot;1234&quot;</span>)<span class="hljs-comment">;</span><br>martin.name <span class="hljs-operator">=</span> <span class="hljs-string">&quot;martin&quot;</span><span class="hljs-comment">;</span><br>martin.id <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1234&quot;</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>所有创建 Person 对象的地方都要如此修改，每次修改之后要执行测试。</p><p>全部修改完成后，就可以用内联函数（115）消去设值函数。</p><p><strong>class Person…</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">constructor</span>(id) &#123;<br>  <span class="hljs-keyword">this</span>._id = id;<br>&#125;<br><span class="hljs-keyword">get</span> name() &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._name;&#125;<br><span class="hljs-keyword">set</span> name(arg) &#123;<span class="hljs-keyword">this</span>._name = arg;&#125;<br><span class="hljs-keyword">get</span> id() &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._id;&#125;<br><span class="hljs-keyword">set</span> id(arg) &#123;<span class="hljs-keyword">this</span>._id = arg;&#125;<br></code></pre></td></tr></table></figure><h2 id="11-8-以工厂函数取代构造函数（Replace-Constructor-with-Factory-Function）"><a href="#11-8-以工厂函数取代构造函数（Replace-Constructor-with-Factory-Function）" class="headerlink" title="11.8 以工厂函数取代构造函数（Replace Constructor with Factory Function）"></a>11.8 以工厂函数取代构造函数（Replace Constructor with Factory Function）</h2><p>曾用名：以工厂函数取代构造函数（Replace Constructor with Factory Method）</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">leadEngineer = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Employee(<span class="hljs-params">document</span>.<span class="hljs-params">leadEngineer</span>, <span class="hljs-string">&quot;E&quot;</span>)</span>;<br><br>leadEngineer = create<span class="hljs-constructor">Engineer(<span class="hljs-params">document</span>.<span class="hljs-params">leadEngineer</span>)</span>;<br></code></pre></td></tr></table></figure><h3 id="动机-13"><a href="#动机-13" class="headerlink" title="动机"></a>动机</h3><p>很多面向对象语言都有特别的构造函数，专门用于对象的初始化。需要新建一个对象时，客户端通常会调用构造函数。但与一般的函数相比，构造函数又常有一些丑陋的局限性。例如，Java 的构造函数只能返回当前所调用类的实例，也就是说，我无法根据环境或参数信息返回子类实例或代理对象；构造函数的名字是固定的，因此无法使用比默认名字更清晰的函数名；构造函数需要通过特殊的操作符来调用（在很多语言中是 new 关键字），所以在要求普通函数的场合就难以使用。</p><p>工厂函数就不受这些限制。工厂函数的实现内部可以调用构造函数，但也可以换成别的方式实现。</p><h3 id="做法-13"><a href="#做法-13" class="headerlink" title="做法"></a>做法</h3><p>新建一个工厂函数，让它调用现有的构造函数。</p><p>将调用构造函数的代码改为调用工厂函数。</p><p>每修改一处，就执行测试。</p><p>尽量缩小构造函数的可见范围。</p><h3 id="范例-13"><a href="#范例-13" class="headerlink" title="范例"></a>范例</h3><p>又是那个单调乏味的例子：员工薪资系统。我还是以 Employee 类表示“员工”。</p><p><strong>class Employee…</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">constructor</span> (name, typeCode) &#123;<br>  <span class="hljs-keyword">this</span>._name = name;<br>  <span class="hljs-keyword">this</span>._typeCode = typeCode;<br>&#125;<br><span class="hljs-keyword">get</span> name() &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._name;&#125;<br><span class="hljs-keyword">get</span> type() &#123;<br>  <span class="hljs-keyword">return</span> Employee.legalTypeCodes[<span class="hljs-keyword">this</span>._typeCode];<br>&#125;<br>static <span class="hljs-keyword">get</span> legalTypeCodes() &#123;<br>  <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;E&quot;</span>: <span class="hljs-string">&quot;Engineer&quot;</span>, <span class="hljs-string">&quot;M&quot;</span>: <span class="hljs-string">&quot;Manager&quot;</span>, <span class="hljs-string">&quot;S&quot;</span>: <span class="hljs-string">&quot;Salesman&quot;</span>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用它的代码有这样的：</p><p><strong>调用方…</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">candidate = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Employee(<span class="hljs-params">document</span>.<span class="hljs-params">name</span>, <span class="hljs-params">document</span>.<span class="hljs-params">empType</span>)</span>;<br></code></pre></td></tr></table></figure><p>也有这样的：</p><p><strong>调用方…</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">const leadEngineer = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Employee(<span class="hljs-params">document</span>.<span class="hljs-params">leadEngineer</span>, <span class="hljs-string">&quot;E&quot;</span>)</span>;<br></code></pre></td></tr></table></figure><p>重构的第一步是创建工厂函数，其中把对象创建的责任直接委派给构造函数。</p><p><strong>顶层作用域…</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> create<span class="hljs-constructor">Employee(<span class="hljs-params">name</span>, <span class="hljs-params">typeCode</span>)</span> &#123;<br>  return <span class="hljs-keyword">new</span> <span class="hljs-constructor">Employee(<span class="hljs-params">name</span>, <span class="hljs-params">typeCode</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后找到构造函数的调用者，并逐一修改它们，令其使用工厂函数。</p><p>第一处的修改很简单。</p><p><strong>调用方…</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">candidate = create<span class="hljs-constructor">Employee(<span class="hljs-params">document</span>.<span class="hljs-params">name</span>, <span class="hljs-params">document</span>.<span class="hljs-params">empType</span>)</span>;<br></code></pre></td></tr></table></figure><p>第二处则可以这样使用工厂函数。</p><p><strong>调用方…</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">const leadEngineer = create<span class="hljs-constructor">Employee(<span class="hljs-params">document</span>.<span class="hljs-params">leadEngineer</span>, <span class="hljs-string">&quot;E&quot;</span>)</span>;<br></code></pre></td></tr></table></figure><p>但我不喜欢这里的类型码——以字符串字面量的形式传入类型码，一般来说都是坏味道。所以我更愿意再新建一个工厂函数，把“员工类别”的信息嵌在函数名里体现。</p><p><strong>调用方…</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">const leadEngineer = create<span class="hljs-constructor">Engineer(<span class="hljs-params">document</span>.<span class="hljs-params">leadEngineer</span>)</span>;<br></code></pre></td></tr></table></figure><p><strong>顶层作用域…</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> create<span class="hljs-constructor">Engineer(<span class="hljs-params">name</span>)</span> &#123;<br>  return <span class="hljs-keyword">new</span> <span class="hljs-constructor">Employee(<span class="hljs-params">name</span>, <span class="hljs-string">&quot;E&quot;</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="11-9-以命令取代函数（Replace-Function-with-Command）"><a href="#11-9-以命令取代函数（Replace-Function-with-Command）" class="headerlink" title="11.9 以命令取代函数（Replace Function with Command）"></a>11.9 以命令取代函数（Replace Function with Command）</h2><p>曾用名：以函数对象取代函数（Replace Method with Method Object）</p><p>反向重构：以函数取代命令（344）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">score</span>(<span class="hljs-params">candidate, medicalExam, scoringGuide</span>) &#123;<br>  <span class="hljs-keyword">let</span> result = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> healthLevel = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// long body code</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Scorer</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">candidate, medicalExam, scoringGuide</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_candidate</span> = candidate;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_medicalExam</span> = medicalExam;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_scoringGuide</span> = scoringGuide;<br>  &#125;<br><br>  <span class="hljs-title function_">execute</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_result</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_healthLevel</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// long body code</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="动机-14"><a href="#动机-14" class="headerlink" title="动机"></a>动机</h3><p>函数，不管是独立函数，还是以方法（method）形式附着在对象上的函数，是程序设计的基本构造块。不过，将函数封装成自己的对象，有时也是一种有用的办法。这样的对象我称之为“命令对象”（command object），或者简称“命令”（command）。这种对象大多只服务于单一函数，获得对该函数的请求，执行该函数，就是这种对象存在的意义。</p><p>与普通的函数相比，命令对象提供了更大的控制灵活性和更强的表达能力。除了函数调用本身，命令对象还可以支持附加的操作，例如撤销操作。我可以通过命令对象提供的方法来设值命令的参数值，从而支持更丰富的生命周期管理能力。我可以借助继承和钩子对函数行为加以定制。如果我所使用的编程语言支持对象但不支持函数作为一等公民，通过命令对象就可以给函数提供大部分相当于一等公民的能力。同样，即便编程语言本身并不支持嵌套函数，我也可以借助命令对象的方法和字段把复杂的函数拆解开，而且在测试和调试过程中可以直接调用这些方法。</p><p>所有这些都是使用命令对象的好理由，所以我要做好准备，一旦有需要，就能把函数重构成命令。不过我们不能忘记，命令对象的灵活性也是以复杂性作为代价的。所以，如果要在作为一等公民的函数和命令对象之间做个选择，95%的时候我都会选函数。只有当我特别需要命令对象提供的某种能力而普通的函数无法提供这种能力时，我才会考虑使用命令对象。</p><p>跟软件开发中的很多词汇一样，“命令”这个词承载了太多含义。在这里，“命令”是指一个对象，其中封装了一个函数调用请求。这是遵循《设计模式》[gof]一书中的命令模式（command pattern）。在这个意义上，使用“命令”一词时，我会先用完整的“命令对象”一词设定上下文，然后视情况使用简略的“命令”一词。在命令与查询分离原则（command-query separation principle）中也用到了“命令”一词，此时“命令”是一个对象所拥有的函数，调用该函数可以改变对象可观察的状态。我尽量避免使用这个意义上的“命令”一词，而更愿意称其为“修改函数”（modifier）或者“改变函数”（mutator）。</p><h3 id="做法-14"><a href="#做法-14" class="headerlink" title="做法"></a>做法</h3><p>为想要包装的函数创建一个空的类，根据该函数的名字为其命名。</p><p>使用搬移函数（198）把函数移到空的类里。</p><p>保持原来的函数作为转发函数，至少保留到重构结束之前才删除。</p><p>遵循编程语言的命名规范来给命令对象起名。如果没有合适的命名规范，就给命令对象中负责实际执行命令的函数起一个通用的名字，例如“execute”或者“call”。</p><p>可以考虑给每个参数创建一个字段，并在构造函数中添加对应的参数。</p><h3 id="范例-14"><a href="#范例-14" class="headerlink" title="范例"></a>范例</h3><p>JavaScript 语言有很多缺点，但把函数作为一等公民对待，是它最正确的设计决策之一。在不具备这种能力的编程语言中，我经常要费力为很常见的任务创建命令对象，JavaScript 则省去了这些麻烦。不过，即便在 JavaScript 中，有时也需要用到命令对象。</p><p>一个典型的应用场景就是拆解复杂的函数，以便我理解和修改。要想真正展示这个重构手法的价值，我需要一个长而复杂的函数，但这写起来太费事，你读起来也麻烦。所以我在这里展示的函数其实很短，并不真的需要本重构手法，还望读者权且包涵。下面的函数用于给一份保险申请评分。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">score</span>(<span class="hljs-params">candidate, medicalExam, scoringGuide</span>) &#123;<br>  <span class="hljs-keyword">let</span> result = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> healthLevel = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> highMedicalRiskFlag = <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-keyword">if</span> (medicalExam.<span class="hljs-property">isSmoker</span>) &#123;<br>    healthLevel += <span class="hljs-number">10</span>;<br>    highMedicalRiskFlag = <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-keyword">let</span> certificationGrade = <span class="hljs-string">&quot;regular&quot;</span>;<br>  <span class="hljs-keyword">if</span> (scoringGuide.<span class="hljs-title function_">stateWithLowCertification</span>(candidate.<span class="hljs-property">originState</span>)) &#123;<br>    certificationGrade = <span class="hljs-string">&quot;low&quot;</span>;<br>    result -= <span class="hljs-number">5</span>;<br>  &#125; <span class="hljs-comment">// lots more code like this</span><br>  result -= <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(healthLevel - <span class="hljs-number">5</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>我首先创建一个空的类，用搬移函数（198）把上述函数搬到这个类里去。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">score</span>(<span class="hljs-params">candidate, medicalExam, scoringGuide</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scorer</span>().<span class="hljs-title function_">execute</span>(candidate, medicalExam, scoringGuide);<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Scorer</span> &#123;<br>  <span class="hljs-title function_">execute</span>(<span class="hljs-params">candidate, medicalExam, scoringGuide</span>) &#123;<br>    <span class="hljs-keyword">let</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> healthLevel = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> highMedicalRiskFlag = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">if</span> (medicalExam.<span class="hljs-property">isSmoker</span>) &#123;<br>      healthLevel += <span class="hljs-number">10</span>;<br>      highMedicalRiskFlag = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">let</span> certificationGrade = <span class="hljs-string">&quot;regular&quot;</span>;<br>    <span class="hljs-keyword">if</span> (scoringGuide.<span class="hljs-title function_">stateWithLowCertification</span>(candidate.<span class="hljs-property">originState</span>)) &#123;<br>      certificationGrade = <span class="hljs-string">&quot;low&quot;</span>;<br>      result -= <span class="hljs-number">5</span>;<br>    &#125; <span class="hljs-comment">// lots more code like this</span><br>    result -= <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(healthLevel - <span class="hljs-number">5</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>大多数时候，我更愿意在命令对象的构造函数中传入参数，而不让 execute 函数接收参数。在这样一个简单的拆解场景中，这一点带来的影响不大；但如果我要处理的命令需要更复杂的参数设置周期或者大量定制，上述做法就会带来很多便利：多个命令类可以分别从各自的构造函数中获得各自不同的参数，然后又可以排成队列挨个执行，因为它们的 execute 函数签名都一样。</p><p>我可以每次搬移一个参数到构造函数。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">score</span>(candidate, medicalExam, scoringGuide) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">new</span> Scorer(candidate).execute(candidate, medicalExam, scoringGuide);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>class Scorer…</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">constructor</span>(<span class="hljs-params">candidate</span>)&#123;<br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_candidate</span> = candidate;<br>&#125;<br><br>execute (candidate, medicalExam, scoringGuide) &#123;<br> <span class="hljs-keyword">let</span> result = <span class="hljs-number">0</span>;<br> <span class="hljs-keyword">let</span> healthLevel = <span class="hljs-number">0</span>;<br> <span class="hljs-keyword">let</span> highMedicalRiskFlag = <span class="hljs-literal">false</span>;<br><br> <span class="hljs-keyword">if</span> (medicalExam.<span class="hljs-property">isSmoker</span>) &#123;<br>  healthLevel += <span class="hljs-number">10</span>;<br>  highMedicalRiskFlag = <span class="hljs-literal">true</span>;<br> &#125;<br> <span class="hljs-keyword">let</span> certificationGrade = <span class="hljs-string">&quot;regular&quot;</span>;<br> <span class="hljs-keyword">if</span> (scoringGuide.<span class="hljs-title function_">stateWithLowCertification</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">_candidate</span>.<span class="hljs-property">originState</span>)) &#123;<br>  certificationGrade = <span class="hljs-string">&quot;low&quot;</span>;<br>  result -= <span class="hljs-number">5</span>;<br> &#125;<br> <span class="hljs-comment">// lots more code like this</span><br> result -= <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(healthLevel - <span class="hljs-number">5</span>, <span class="hljs-number">0</span>);<br> <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>继续处理其他参数：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> score(candidate, medicalExam, scoringGuide) &#123;<br>  return <span class="hljs-keyword">new</span> <span class="hljs-constructor">Scorer(<span class="hljs-params">candidate</span>, <span class="hljs-params">medicalExam</span>, <span class="hljs-params">scoringGuide</span>)</span>.execute<span class="hljs-literal">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>class Scorer…</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">constructor</span>(candidate, medicalExam, scoringGuide)&#123;<br> <span class="hljs-keyword">this</span>._candidate = candidate;<br> <span class="hljs-keyword">this</span>._medicalExam = medicalExam;<br> <span class="hljs-keyword">this</span>._scoringGuide = scoringGuide;<br>&#125;<br>execute () &#123;<br> let result = <span class="hljs-number">0</span>;<br> let healthLevel = <span class="hljs-number">0</span>;<br> let highMedicalRiskFlag = <span class="hljs-literal">false</span>;<br><br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._medicalExam.isSmoker) &#123;<br>  healthLevel += <span class="hljs-number">10</span>;<br>  highMedicalRiskFlag = <span class="hljs-literal">true</span>;<br> &#125;<br> let certificationGrade = <span class="hljs-string">&quot;regular&quot;</span>;<br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._scoringGuide.stateWithLowCertification(<span class="hljs-keyword">this</span>._candidate.originState)) &#123;<br>  certificationGrade = <span class="hljs-string">&quot;low&quot;</span>;<br>  result -= <span class="hljs-number">5</span>;<br> &#125;<br> <span class="hljs-comment">// lots more code like this</span><br> result -= Math.max(healthLevel - <span class="hljs-number">5</span>, <span class="hljs-number">0</span>);<br> <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>以命令取代函数的重构到此就结束了，不过之所以要做这个重构，是为了拆解复杂的函数，所以我还是大致展示一下如何拆解。下一步是把所有局部变量都变成字段，我还是每次修改一处。</p><p><strong>class Scorer…</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">constructor</span>(candidate, medicalExam, scoringGuide)&#123;<br> <span class="hljs-keyword">this</span>._candidate = candidate;<br> <span class="hljs-keyword">this</span>._medicalExam = medicalExam;<br> <span class="hljs-keyword">this</span>._scoringGuide = scoringGuide;<br>&#125;<br><br>execute () &#123;<br> <span class="hljs-keyword">this</span>._result = <span class="hljs-number">0</span>;<br> let healthLevel = <span class="hljs-number">0</span>;<br> let highMedicalRiskFlag = <span class="hljs-literal">false</span>;<br><br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._medicalExam.isSmoker) &#123;<br>  healthLevel += <span class="hljs-number">10</span>;<br>  highMedicalRiskFlag = <span class="hljs-literal">true</span>;<br> &#125;<br> let certificationGrade = <span class="hljs-string">&quot;regular&quot;</span>;<br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._scoringGuide.stateWithLowCertification(<span class="hljs-keyword">this</span>._candidate.originState)) &#123;<br>  certificationGrade = <span class="hljs-string">&quot;low&quot;</span>;<br>  <span class="hljs-keyword">this</span>._result -= <span class="hljs-number">5</span>;<br> &#125;<br> <span class="hljs-comment">// lots more code like this</span><br> <span class="hljs-keyword">this</span>._result -= Math.max(healthLevel - <span class="hljs-number">5</span>, <span class="hljs-number">0</span>);<br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._result;<br>&#125;<br></code></pre></td></tr></table></figure><p>重复上述过程，直到所有局部变量都变成字段。（“把局部变量变成字段”这个重构手法是如此简单，以至于我都没有在重构名录中给它一席之地。对此我略感愧疚。）</p><p><strong>class Scorer…</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">constructor</span>(candidate, medicalExam, scoringGuide)&#123;<br> <span class="hljs-keyword">this</span>._candidate = candidate;<br> <span class="hljs-keyword">this</span>._medicalExam = medicalExam;<br> <span class="hljs-keyword">this</span>._scoringGuide = scoringGuide;<br>&#125;<br><br>execute () &#123;<br> <span class="hljs-keyword">this</span>._result = <span class="hljs-number">0</span>;<br> <span class="hljs-keyword">this</span>._healthLevel = <span class="hljs-number">0</span>;<br> <span class="hljs-keyword">this</span>._highMedicalRiskFlag = <span class="hljs-literal">false</span>;<br><br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._medicalExam.isSmoker) &#123;<br>  <span class="hljs-keyword">this</span>._healthLevel += <span class="hljs-number">10</span>;<br>  <span class="hljs-keyword">this</span>._highMedicalRiskFlag = <span class="hljs-literal">true</span>;<br> &#125;<br> <span class="hljs-keyword">this</span>._certificationGrade = <span class="hljs-string">&quot;regular&quot;</span>;<br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._scoringGuide.stateWithLowCertification(<span class="hljs-keyword">this</span>._candidate.originState)) &#123;<br>  <span class="hljs-keyword">this</span>._certificationGrade = <span class="hljs-string">&quot;low&quot;</span>;<br>  <span class="hljs-keyword">this</span>._result -= <span class="hljs-number">5</span>;<br> &#125;<br> <span class="hljs-comment">// lots more code like this</span><br> <span class="hljs-keyword">this</span>._result -= Math.max(<span class="hljs-keyword">this</span>._healthLevel - <span class="hljs-number">5</span>, <span class="hljs-number">0</span>);<br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._result;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在函数的所有状态都已经移到了命令对象中，我可以放心使用提炼函数（106）等重构手法，而不用纠结于局部变量的作用域之类问题。</p><p><strong>class Scorer…</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">execute () &#123;<br> <span class="hljs-keyword">this</span>._result = <span class="hljs-number">0</span>;<br> <span class="hljs-keyword">this</span>._healthLevel = <span class="hljs-number">0</span>;<br> <span class="hljs-keyword">this</span>._highMedicalRiskFlag = <span class="hljs-literal">false</span>;<br><br> <span class="hljs-keyword">this</span>.scoreSmoking();<br> <span class="hljs-keyword">this</span>._certificationGrade = <span class="hljs-string">&quot;regular&quot;</span>;<br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._scoringGuide.stateWithLowCertification(<span class="hljs-keyword">this</span>._candidate.originState)) &#123;<br>  <span class="hljs-keyword">this</span>._certificationGrade = <span class="hljs-string">&quot;low&quot;</span>;<br>  <span class="hljs-keyword">this</span>._result -= <span class="hljs-number">5</span>;<br> &#125;<br> <span class="hljs-comment">// lots more code like this</span><br> <span class="hljs-keyword">this</span>._result -= Math.max(<span class="hljs-keyword">this</span>._healthLevel - <span class="hljs-number">5</span>, <span class="hljs-number">0</span>);<br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._result;<br> &#125;<br>scoreSmoking() &#123;<br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._medicalExam.isSmoker) &#123;<br>  <span class="hljs-keyword">this</span>._healthLevel += <span class="hljs-number">10</span>;<br>  <span class="hljs-keyword">this</span>._highMedicalRiskFlag = <span class="hljs-literal">true</span>;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样我就可以像处理嵌套函数一样处理命令对象。实际上，在 JavaScript 中运用此重构手法时，的确可以考虑用嵌套函数来代替命令对象。不过我还是会使用命令对象，不仅因为我对命令对象更熟悉，而且还因为我可以针对命令对象中任何一个函数进行测试和调试。</p><h2 id="11-10-以函数取代命令（Replace-Command-with-Function）"><a href="#11-10-以函数取代命令（Replace-Command-with-Function）" class="headerlink" title="11.10 以函数取代命令（Replace Command with Function）"></a>11.10 以函数取代命令（Replace Command with Function）</h2><p>反向重构：以命令取代函数（337）</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ChargeCalculator</span> &#123;<br>  <span class="hljs-keyword">constructor</span>(customer, usage) &#123;<br>    <span class="hljs-keyword">this</span>._customer = customer;<br>    <span class="hljs-keyword">this</span>._usage = usage;<br>  &#125;<br>  execute() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._customer.rate * <span class="hljs-keyword">this</span>._usage;<br>  &#125;<br>&#125;<br><br>function charge(customer, usage) &#123;<br>  <span class="hljs-keyword">return</span> customer.rate * usage;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="动机-15"><a href="#动机-15" class="headerlink" title="动机"></a>动机</h3><p>命令对象为处理复杂计算提供了强大的机制。借助命令对象，可以轻松地将原本复杂的函数拆解为多个方法，彼此之间通过字段共享状态；拆解后的方法可以分别调用；开始调用之前的数据状态也可以逐步构建。但这种强大是有代价的。大多数时候，我只是想调用一个函数，让它完成自己的工作就好。如果这个函数不是太复杂，那么命令对象可能显得费而不惠，我就应该考虑将其变回普通的函数。</p><h3 id="做法-15"><a href="#做法-15" class="headerlink" title="做法"></a>做法</h3><p>运用提炼函数（106），把“创建并执行命令对象”的代码单独提炼到一个函数中。</p><p>这一步会新建一个函数，最终这个函数会取代现在的命令对象。</p><p>对命令对象在执行阶段用到的函数，逐一使用内联函数（115）。</p><p>如果被调用的函数有返回值，请先对调用处使用提炼变量（119），然后再使用内联函数（115）。</p><p>使用改变函数声明（124），把构造函数的参数转移到执行函数。</p><p>对于所有的字段，在执行函数中找到引用它们的地方，并改为使用参数。每次修改后都要测试。</p><p>把“调用构造函数”和“调用执行函数”两步都内联到调用方（也就是最终要替换命令对象的那个函数）。</p><p>测试。</p><p>用移除死代码（237）把命令类消去。</p><h3 id="范例-15"><a href="#范例-15" class="headerlink" title="范例"></a>范例</h3><p>假设我有一个很小的命令对象。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ChargeCalculator</span> &#123;<br>  <span class="hljs-keyword">constructor</span>(customer, usage, provider) &#123;<br>    <span class="hljs-keyword">this</span>._customer = customer;<br>    <span class="hljs-keyword">this</span>._usage = usage;<br>    <span class="hljs-keyword">this</span>._provider = provider;<br>  &#125;<br>  <span class="hljs-keyword">get</span> baseCharge() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._customer.baseRate * <span class="hljs-keyword">this</span>._usage;<br>  &#125;<br>  <span class="hljs-keyword">get</span> charge() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.baseCharge + <span class="hljs-keyword">this</span>._provider.connectionCharge;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用方的代码如下。</p><p><strong>调用方…</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">monthCharge = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ChargeCalculator(<span class="hljs-params">customer</span>, <span class="hljs-params">usage</span>, <span class="hljs-params">provider</span>)</span>.charge;<br></code></pre></td></tr></table></figure><p>命令类足够小、足够简单，变成函数更合适。</p><p>首先，我用提炼函数（106）把命令对象的创建与调用过程包装到一个函数中。</p><p><strong>调用方…</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">monthCharge</span> = charge(customer, usage, provider)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><strong>顶层作用域…</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> charge(customer, usage, provider) &#123;<br>  return <span class="hljs-keyword">new</span> <span class="hljs-constructor">ChargeCalculator(<span class="hljs-params">customer</span>, <span class="hljs-params">usage</span>, <span class="hljs-params">provider</span>)</span>.charge;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来要考虑如何处理支持函数（也就是这里的 baseCharge 函数）。对于有返回值的函数，我一般会先用提炼变量（119）把返回值提炼出来。</p><p><strong>class ChargeCalculator…</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">get</span> baseCharge() &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._customer.baseRate * <span class="hljs-keyword">this</span>._usage;<br>&#125;<br><span class="hljs-keyword">get</span> charge() &#123;<br>  <span class="hljs-keyword">const</span> baseCharge = <span class="hljs-keyword">this</span>.baseCharge;<br>  <span class="hljs-keyword">return</span> baseCharge + <span class="hljs-keyword">this</span>._provider.connectionCharge;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后对支持函数使用内联函数（115）。</p><p><strong>class ChargeCalculator…</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">get</span> charge() &#123;<br>  <span class="hljs-keyword">const</span> baseCharge = <span class="hljs-keyword">this</span>._customer.baseRate * <span class="hljs-keyword">this</span>._usage;<br>  <span class="hljs-keyword">return</span> baseCharge + <span class="hljs-keyword">this</span>._provider.connectionCharge;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在所有逻辑处理都集中到一个函数了，下一步是把构造函数传入的数据移到主函数。首先用改变函数声明（124）把构造函数的参数逐一添加到 charge 函数上。</p><p><strong>class ChargeCalculator…</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">constructor</span> (customer, usage, provider)&#123;<br> <span class="hljs-keyword">this</span>._customer = customer;<br> <span class="hljs-keyword">this</span>._usage = usage;<br> <span class="hljs-keyword">this</span>._provider = provider;<br>&#125;<br><br>charge(customer, usage, provider) &#123;<br> <span class="hljs-keyword">const</span> baseCharge = <span class="hljs-keyword">this</span>._customer.baseRate * <span class="hljs-keyword">this</span>._usage;<br> <span class="hljs-keyword">return</span> baseCharge + <span class="hljs-keyword">this</span>._provider.connectionCharge;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>顶层作用域…</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> charge(customer, <span class="hljs-keyword">usage</span>, provider) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span> ChargeCalculator(customer, <span class="hljs-keyword">usage</span>, provider).charge(<br>    customer,<br>    <span class="hljs-keyword">usage</span>,<br>    provider<br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>然后修改 charge 函数的实现，改为使用传入的参数。这个修改可以小步进行，每次使用一个参数。</p><p><strong>class ChargeCalculator…</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">constructor</span> (customer, usage, provider)&#123;<br> <span class="hljs-keyword">this</span>._customer = customer;<br> <span class="hljs-keyword">this</span>._usage = usage;<br> <span class="hljs-keyword">this</span>._provider = provider;<br>&#125;<br><br>charge(customer, usage, provider) &#123;<br> <span class="hljs-keyword">const</span> baseCharge = customer.baseRate * <span class="hljs-keyword">this</span>._usage;<br> <span class="hljs-keyword">return</span> baseCharge + <span class="hljs-keyword">this</span>._provider.connectionCharge;<br>&#125;<br></code></pre></td></tr></table></figure><p>构造函数中对 <code>this._customer</code> 字段的赋值不删除也没关系，因为反正没人使用这个字段。但我更愿意去掉这条赋值语句，因为去掉它以后，如果在函数实现中漏掉了一处对字段的使用没有修改，测试就会失败。（如果我真的犯了这个错误而测试没有失败，我就应该考虑增加测试了。）</p><p>其他参数也如法炮制，直到 charge 函数不再使用任何字段：</p><p><strong>class ChargeCalculator…</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">charge</span>(<span class="hljs-params">customer, usage, provider</span>) &#123;<br>  <span class="hljs-keyword">const</span> baseCharge = customer.<span class="hljs-property">baseRate</span> * usage;<br>  <span class="hljs-keyword">return</span> baseCharge + provider.<span class="hljs-property">connectionCharge</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我就可以把所有逻辑都内联到顶层的 charge 函数中。这是内联函数（115）的一种特殊情况，我需要把构造函数和执行函数一并内联。</p><p><strong>顶层作用域…</strong></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">charge</span>(customer, usage, provider) &#123;<br>  const baseCharge = customer.baseRate * usage;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">baseCharge</span> + provider.connectionCharge;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在命令类已经是死代码了，可以用移除死代码（237）给它一个体面的葬礼。</p>]]></content>
    
    
    <categories>
      
      <category>重构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>重构</tag>
      
      <tag>架构</tag>
      
      <tag>设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重构法则节选(上)</title>
    <link href="/posts/8847ed34/"/>
    <url>/posts/8847ed34/</url>
    
    <content type="html"><![CDATA[<blockquote><p>重构，并不是额外动作，理应伴随开发流程。并不是无意义，如果只是堆积垃圾代码，迭代多次之后，可能原开发人员也会失去本来的方向。作为开发人员理应重视这样的份内之事。最近重读《重构-改善既有代码的设计》。还是觉得需要落到笔端，吃书也是一种学习方式吧，这里节选认为必要的内容，还是需要反复阅读才能理解其真意。学习重构，是为了减少重构。</p></blockquote><hr><h1 id="2-重构的原则"><a href="#2-重构的原则" class="headerlink" title="2.重构的原则"></a>2.重构的原则</h1><p>前一章所举的例子应该已经让你对重构有了一个良好的感觉。现在，我们应该回头看看重构的一些大原则。</p><h2 id="2-1-何谓重构"><a href="#2-1-何谓重构" class="headerlink" title="2.1 何谓重构"></a>2.1 何谓重构</h2><p>一线的实践者们经常很随意地使用“重构”这个词——软件开发领域的很多词汇都有此待遇。我使用这个词的方式比较严谨，并且我发现这种严谨的方式很有好处。（下列定义与本书第 1 版中给出的定义一样。）“重构”这个词既可以用作名词也可以用作动词。名词形式的定义是：</p><p>重构（名词）：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。</p><p>这个定义适用于我在前面的例子中提到的那些有名字的重构，例如提炼函数（106）和以多态取代条件表达式（272）。</p><p>动词形式的定义是：</p><p>重构（动词）：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。</p><p>所以，我可能会花一两个小时进行重构（动词），其间我会使用几十个不同的重构（名词）。</p><p>过去十几年，这个行业里的很多人用“重构”这个词来指代任何形式的代码清理，但上面的定义所指的是一种特定的清理代码的方式。重构的关键在于运用大量微小且保持软件行为的步骤，一步步达成大规模的修改。每个单独的重构要么很小，要么由若干小步骤组合而成。因此，在重构的过程中，我的代码很少进入不可工作的状态，即便重构没有完成，我也可以在任何时刻停下来。</p><blockquote><p><strong>Tip</strong><br>如果有人说他们的代码在重构过程中有一两天时间不可用，基本上可以确定，他们在做的事不是重构。</p></blockquote><p>我会用“结构调整”（restructuring）来泛指对代码库进行的各种形式的重新组织或清理，重构则是特定的一类结构调整。刚接触重构的人看我用很多小步骤完成似乎可以一大步就能做完的事，可能会觉得这样很低效。但小步前进能让我走得更快，因为这些小步骤能完美地彼此组合，而且——更关键的是——整个过程中我不会花任何时间来调试。</p><p>在上述定义中，我用了“可观察行为”的说法。它的意思是，整体而言，经过重构之后的代码所做的事应该与重构之前大致一样。这个说法并非完全严格，并且我是故意保留这点儿空间的：重构之后的代码不一定与重构前行为完全一致。比如说，提炼函数（106）会改变函数调用栈，因此程序的性能就会有所改变；改变函数声明（124）和搬移函数（198）等重构经常会改变模块的接口。不过就用户应该关心的行为而言，不应该有任何改变。如果我在重构过程中发现了任何 bug，重构完成后同样的 bug 应该仍然存在（不过，如果潜在的 bug 还没有被任何人发现，也可以当即把它改掉）。</p><p>重构与性能优化有很多相似之处：两者都需要修改代码，并且两者都不会改变程序的整体功能。两者的差别在于其目的：重构是为了让代码“更容易理解，更易于修改”。这可能使程序运行得更快，也可能使程序运行得更慢。在性能优化时，我只关心让程序运行得更快，最终得到的代码有可能更难理解和维护，对此我有心理准备。</p><h2 id="2-2-两顶帽子"><a href="#2-2-两顶帽子" class="headerlink" title="2.2 两顶帽子"></a>2.2 两顶帽子</h2><p>Kent Beck 提出了“两顶帽子”的比喻。使用重构技术开发软件时，我把自己的时间分配给两种截然不同的行为：添加新功能和重构。添加新功能时，我不应该修改既有代码，只管添加新功能。通过添加测试并让测试正常运行，我可以衡量自己的工作进度。重构时我就不能再添加功能，只管调整代码的结构。此时我不应该添加任何测试（除非发现有先前遗漏的东西），只在绝对必要（用以处理接口变化）时才修改测试。</p><p>软件开发过程中，我可能会发现自己经常变换帽子。首先我会尝试添加新功能，然后会意识到：如果把程序结构改一下，功能的添加会容易得多。于是我换一顶帽子，做一会儿重构工作。程序结构调整好后，我又换上原先的帽子，继续添加新功能。新功能正常工作后，我又发现自己的编码造成程序难以理解，于是又换上重构帽子……整个过程或许只花 10 分钟，但无论何时我都清楚自己戴的是哪一顶帽子，并且明白不同的帽子对编程状态提出的不同要求。</p><h2 id="2-3-为何重构"><a href="#2-3-为何重构" class="headerlink" title="2.3 为何重构"></a>2.3 为何重构</h2><p>我不想把重构说成是包治百病的万灵丹，它绝对不是所谓的“银弹”。不过它的确很有价值，尽管它不是一颗“银弹”，却可以算是一把“银钳子”，可以帮你始终良好地控制自己的代码。重构是一个工具，它可以（并且应该）用于以下几个目的。</p><h3 id="重构改进软件的设计"><a href="#重构改进软件的设计" class="headerlink" title="重构改进软件的设计"></a>重构改进软件的设计</h3><p>如果没有重构，程序的内部设计（或者叫架构）会逐渐腐败变质。当人们只为短期目的而修改代码时，他们经常没有完全理解架构的整体设计，于是代码逐渐失去了自己的结构。程序员越来越难通过阅读源码来理解原来的设计。代码结构的流失有累积效应。越难看出代码所代表的设计意图，就越难保护其设计，于是设计就腐败得越快。经常性的重构有助于代码维持自己该有的形态。</p><p>完成同样一件事，设计欠佳的程序往往需要更多代码，这常常是因为代码在不同的地方使用完全相同的语句做同样的事，因此改进设计的一个重要方向就是消除重复代码。代码量减少并不会使系统运行更快，因为这对程序的资源占用几乎没有任何明显影响。然而代码量减少将使未来可能的程序修改动作容易得多。代码越多，做正确的修改就越困难，因为有更多代码需要理解。我在这里做了点儿修改，系统却不如预期那样工作，因为我没有修改另一处——那里的代码做着几乎完全一样的事情，只是所处环境略有不同。消除重复代码，我就可以确定所有事物和行为在代码中只表述一次，这正是优秀设计的根本。</p><h3 id="重构使软件更容易理解"><a href="#重构使软件更容易理解" class="headerlink" title="重构使软件更容易理解"></a>重构使软件更容易理解</h3><p>所谓程序设计，很大程度上就是与计算机对话：我编写代码告诉计算机做什么事，而它的响应是按照我的指示精确行动。一言以蔽之，我所做的就是填补“我想要它做什么”和“我告诉它做什么”之间的缝隙。编程的核心就在于“准确说出我想要的”。然而别忘了，除了计算机外，源码还有其他读者：几个月之后可能会有另一位程序员尝试读懂我的代码并对其做一些修改。我们很容易忘记这这位读者，但他才是最重要的。计算机是否多花了几个时钟周期来编译，又有什么关系呢？如果一个程序员花费一周时间来修改某段代码，那才要命呢——如果他理解了我的代码，这个修改原本只需一小时。</p><p>问题在于，当我努力让程序运转的时候，我不会想到未来出现的那个开发者。是的，我们应该改变一下开发节奏，让代码变得更易于理解。重构可以帮我让代码更易读。开始进行重构前，代码可以正常运行，但结构不够理想。在重构上花一点点时间，就可以让代码更好地表达自己的意图——更清晰地说出我想要做的。</p><p>关于这一点，我没必要表现得多么无私。很多时候那个未来的开发者就是我自己。此时重构就显得尤其重要了。我是一个很懒惰的程序员，我的懒惰表现形式之一就是：总是记不住自己写过的代码。事实上，对于任何能够立刻查阅的东西，我都故意不去记它，因为我怕把自己的脑袋塞爆。我总是尽量把该记住的东西写进代码里，这样我就不必记住它了。这么一来，下班后我还可以喝上两杯 Maudite 啤酒，不必太担心它杀光我的脑细胞。</p><h3 id="重构帮助找到-bug"><a href="#重构帮助找到-bug" class="headerlink" title="重构帮助找到 bug"></a>重构帮助找到 bug</h3><p>对代码的理解，可以帮我找到 bug。我承认我不太擅长找 bug。有些人只要盯着一大段代码就可以找出里面的 bug，我不行。但我发现，如果对代码进行重构，我就可以深入理解代码的所作所为，并立即把新的理解反映在代码当中。搞清楚程序结构的同时，我也验证了自己所做的一些假设，于是想不把 bug 揪出来都难。</p><p>这让我想起了 Kent Beck 经常形容自己的一句话：“我不是一个特别好的程序员，我只是一个有着一些特别好的习惯的还不错的程序员。”重构能够帮助我更有效地写出健壮的代码。</p><h3 id="重构提高编程速度"><a href="#重构提高编程速度" class="headerlink" title="重构提高编程速度"></a>重构提高编程速度</h3><p>最后，前面的一切都归结到了这一点：重构帮我更快速地开发程序。</p><p>听起来有点儿违反直觉。当我谈到重构时，人们很容易看出它能够提高质量。改善设计、提升可读性、减少 bug，这些都能提高质量。但花在重构上的时间，难道不是在降低开发速度吗？</p><p>当我跟那些在一个系统上工作较长时间的软件开发者交谈时，经常会听到这样的故事：一开始他们进展很快，但如今想要添加一个新功能需要的时间就要长得多。他们需要花越来越多的时间去考虑如何把新功能塞进现有的代码库，不断蹦出来的 bug 修复起来也越来越慢。代码库看起来就像补丁摞补丁，需要细致的考古工作才能弄明白整个系统是如何工作的。这份负担不断拖慢新增功能的速度，到最后程序员恨不得从头开始重写整个系统。</p><p>下面这幅图可以描绘他们经历的困境。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151638297.png"></p><p>但有些团队的境遇则截然不同。他们添加新功能的速度越来越快，因为他们能利用已有的功能，基于已有的功能快速构建新功能。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151638793.png"></p><p>两种团队的区别就在于软件的内部质量。需要添加新功能时，内部质量良好的软件让我可以很容易找到在哪里修改、如何修改。良好的模块划分使我只需要理解代码库的一小部分，就可以做出修改。如果代码很清晰，我引入 bug 的可能性就会变小，即使引入了 bug，调试也会容易得多。理想情况下，我的代码库会逐步演化成一个平台，在其上可以很容易地构造与其领域相关的新功能。</p><p>我把这种现象称为“设计耐久性假说”：通过投入精力改善内部设计，我们增加了软件的耐久性，从而可以更长时间地保持开发的快速。我还无法科学地证明这个理论，所以我说它是一个“假说”。但我的经验，以及我在职业生涯中认识的上百名优秀程序员的经验，都支持这个假说。</p><p>20 年前，行业的陈规认为：良好的设计必须在开始编程之前完成，因为一旦开始编写代码，设计就只会逐渐腐败。重构改变了这个图景。现在我们可以改善已有代码的设计，因此我们可以先做一个设计，然后不断改善它，哪怕程序本身的功能也在不断发生着变化。由于预先做出良好的设计非常困难，想要既体面又快速地开发功能，重构必不可少。</p><h2 id="2-4-何时重构"><a href="#2-4-何时重构" class="headerlink" title="2.4 何时重构"></a>2.4 何时重构</h2><p>在我编程的每个小时，我都会做重构。有几种方式可以把重构融入我的工作过程里。</p><blockquote><p><strong>Tip</strong><br>三次法则</p></blockquote><p>Don Roberts 给了我一条准则：第一次做某件事时只管去做；第二次做类似的事会产生反感，但无论如何还是可以去做；第三次再做类似的事，你就应该重构。</p><p>正如老话说的：事不过三，三则重构。</p><h3 id="预备性重构：让添加新功能更容易"><a href="#预备性重构：让添加新功能更容易" class="headerlink" title="预备性重构：让添加新功能更容易"></a>预备性重构：让添加新功能更容易</h3><p>重构的最佳时机就在添加新功能之前。在动手添加新功能之前，我会看看现有的代码库，此时经常会发现：如果对代码结构做一点微调，我的工作会容易得多。也许已经有个函数提供了我需要的大部分功能，但有几个字面量的值与我的需要略有冲突。如果不做重构，我可能会把整个函数复制过来，修改这几个值，但这就会导致重复代码——如果将来我需要做修改，就必须同时修改两处（更麻烦的是，我得先找到这两处）。而且，如果将来我还需要一个类似又略有不同的功能，就只能再复制粘贴一次，这可不是个好主意。所以我戴上重构的帽子，使用函数参数化（310）。做完这件事以后，接下来我就只需要调用这个函数，传入我需要的参数。</p><blockquote><p><strong>Tip</strong><br>这就好像我要往东去 100 公里。我不会往东一头把车开进树林，而是先往北开 20 公里上高速，然后再向东开 100 公里。后者的速度比前者要快上 3 倍。如果有人催着你“赶快直接去那儿”，有时你需要说：“等等，我要先看看地图，找出最快的路径。”这就是预备性重构于我的意义。</p></blockquote><p>——Jessica Kerr</p><p>修复 bug 时的情况也是一样。在寻找问题根因时，我可能会发现：如果把 3 段一模一样且都会导致错误的代码合并到一处，问题修复起来会容易得多。或者，如果把某些更新数据的逻辑与查询逻辑分开，会更容易避免造成错误的逻辑纠缠。用重构改善这些情况，在同样场合再次出现同样 bug 的概率也会降低。</p><h3 id="帮助理解的重构：使代码更易懂"><a href="#帮助理解的重构：使代码更易懂" class="headerlink" title="帮助理解的重构：使代码更易懂"></a>帮助理解的重构：使代码更易懂</h3><p>我需要先理解代码在做什么，然后才能着手修改。这段代码可能是我写的，也可能是别人写的。一旦我需要思考“这段代码到底在做什么”，我就会自问：能不能重构这段代码，令其一目了然？我可能看见了一段结构糟糕的条件逻辑，也可能希望复用一个函数，但花费了几分钟才弄懂它到底在做什么，因为它的函数命名实在是太糟糕了。这些都是重构的机会。</p><p>看代码时，我会在脑海里形成一些理解，但我的记性不好，记不住那么多细节。正如 Ward Cunningham 所说，通过重构，我就把脑子里的理解转移到了代码本身。随后我运行这个软件，看它是否正常工作，来检查这些理解是否正确。如果把对代码的理解植入代码中，这份知识会保存得更久，并且我的同事也能看到。</p><p>重构带来的帮助不仅发生在将来——常常是立竿见影。我会先在一些小细节上使用重构来帮助理解，给一两个变量改名，让它们更清楚地表达意图，以方便理解，或是将一个长函数拆成几个小函数。当代码变得更清晰一些时，我就会看见之前看不见的设计问题。如果不做前面的重构，我可能永远都看不见这些设计问题，因为我不够聪明，无法在脑海中推演所有这些变化。Ralph Johnson 说，这些初步的重构就像扫去窗上的尘埃，使我们得以看到窗外的风景。在研读代码时，重构会引领我获得更高层面的理解，如果只是阅读代码很难有此领悟。有些人以为这些重构只是毫无意义地把玩代码，他们没有意识到，缺少了这些细微的整理，他们就无法看到隐藏在一片混乱背后的机遇。</p><h3 id="捡垃圾式重构"><a href="#捡垃圾式重构" class="headerlink" title="捡垃圾式重构"></a>捡垃圾式重构</h3><p>帮助理解的重构还有一个变体：我已经理解代码在做什么，但发现它做得不好，例如逻辑不必要地迂回复杂，或者两个函数几乎完全相同，可以用一个参数化的函数取而代之。这里有一个取舍：我不想从眼下正要完成的任务上跑题太多，但我也不想把垃圾留在原地，给将来的修改增加麻烦。如果我发现的垃圾很容易重构，我会马上重构它；如果重构需要花一些精力，我可能会拿一张便笺纸把它记下来，完成当下的任务再回来重构它。</p><p>当然，有时这样的垃圾需要好几个小时才能解决，而我又有更紧急的事要完成。不过即便如此，稍微花一点工夫做一点儿清理，通常都是值得的。正如野营者的老话所说：至少要让营地比你到达时更干净。如果每次经过这段代码时都把它变好一点点，积少成多，垃圾总会被处理干净。重构的妙处就在于，每个小步骤都不会破坏代码——所以，有时一块垃圾在好几个月之后才终于清理干净，但即便每次清理并不完整，代码也不会被破坏。</p><h3 id="有计划的重构和见机行事的重构"><a href="#有计划的重构和见机行事的重构" class="headerlink" title="有计划的重构和见机行事的重构"></a>有计划的重构和见机行事的重构</h3><p>上面的例子——预备性重构、帮助理解的重构、捡垃圾式重构——都是见机行事的：我并不专门安排一段时间来重构，而是在添加功能或修复 bug 的同时顺便重构。这是我自然的编程流的一部分。不管是要添加功能还是修复 bug，重构对我当下的任务有帮助，而且让我未来的工作更轻松。这是一件很重要而又常被误解的事：重构不是与编程割裂的行为。你不会专门安排时间重构，正如你不会专门安排时间写 if 语句。我的项目计划上没有专门留给重构的时间，绝大多数重构都在我做其他事的过程中自然发生。</p><blockquote><p><strong>Tip</strong><br>肮脏的代码必须重构，但漂亮的代码也需要很多重构。</p></blockquote><p>还有一种常见的误解认为，重构就是人们弥补过去的错误或者清理肮脏的代码。当然，如果遇上了肮脏的代码，你必须重构，但漂亮的代码也需要很多重构。在写代码时，我会做出很多权衡取舍：参数化需要做到什么程度？函数之间的边界应该划在哪里？对于昨天的功能完全合理的权衡，在今天要添加新功能时可能就不再合理。好在，当我需要改变这些权衡以反映现实情况的变化时，整洁的代码重构起来会更容易。</p><blockquote><p><strong>Tip</strong><br>每次要修改时，首先令修改很容易（警告：这件事有时会很难），然后再进行这次容易的修改。</p></blockquote><p>——Kent Beck</p><p>长久以来，人们认为编写软件是一个累加的过程：要添加新功能，我们就应该增加新代码。但优秀的程序员知道，添加新功能最快的方法往往是先修改现有的代码，使新功能容易被加入。所以，软件永远不应该被视为“完成”。每当需要新能力时，软件就应该做出相应的改变。越是在已有代码中，这样的改变就越显重要。</p><p>不过，说了这么多，并不表示有计划的重构总是错的。如果团队过去忽视了重构，那么常常会需要专门花一些时间来优化代码库，以便更容易添加新功能。在重构上花一个星期的时间，会在未来几个月里发挥价值。有时，即便团队做了日常的重构，还是会有问题在某个区域逐渐累积长大，最终需要专门花些时间来解决。但这种有计划的重构应该很少，大部分重构应该是不起眼的、见机行事的。</p><p>我听过的一条建议是：将重构与添加新功能在版本控制的提交中分开。这样做的一大好处是可以各自独立地审阅和批准这些提交。但我并不认同这种做法。重构常常与新添功能紧密交织，不值得花工夫把它们分开。并且这样做也使重构脱离了上下文，使人看不出这些“重构提交”的价值。每个团队应该尝试并找出适合自己的工作方式，只是要记住：分离重构提交并不是毋庸置疑的原则，只有当你真的感到有益时，才值得这样做。</p><h3 id="长期重构"><a href="#长期重构" class="headerlink" title="长期重构"></a>长期重构</h3><p>大多数重构可以在几分钟——最多几小时——内完成。但有一些大型的重构可能要花上几个星期，例如要替换一个正在使用的库，或者将整块代码抽取到一个组件中并共享给另一支团队使用，再或者要处理一大堆混乱的依赖关系，等等。</p><p>即便在这样的情况下，我仍然不愿让一支团队专门做重构。可以让整个团队达成共识，在未来几周时间里逐步解决这个问题，这经常是一个有效的策略。每当有人靠近“重构区”的代码，就把它朝想要改进的方向推动一点。这个策略的好处在于，重构不会破坏代码——每次小改动之后，整个系统仍然照常工作。例如，如果想替换掉一个正在使用的库，可以先引入一层新的抽象，使其兼容新旧两个库的接口。一旦调用方已经完全改为使用这层抽象，替换下面的库就会容易得多。（这个策略叫作 Branch By Abstraction[mf-bba]。）</p><h3 id="复审代码时重构"><a href="#复审代码时重构" class="headerlink" title="复审代码时重构"></a>复审代码时重构</h3><p>一些公司会做常规的代码复审（code review），因为这种活动可以改善开发状况。代码复审有助于在开发团队中传播知识，也有助于让较有经验的开发者把知识传递给比较欠缺经验的人，并帮助更多人理解大型软件系统中的更多部分。代码复审对于编写清晰代码也很重要。我的代码也许对我自己来说很清晰，对他人则不然。这是无法避免的，因为要让开发者设身处地为那些不熟悉自己所作所为的人着想，实在太困难了。代码复审也让更多人有机会提出有用的建议，毕竟我在一个星期之内能够想出的好点子很有限。如果能得到别人的帮助，我的生活会滋润得多，所以我总是期待更多复审。</p><p>我发现，重构可以帮助我复审别人的代码。开始重构前我可以先阅读代码，得到一定程度的理解，并提出一些建议。一旦想到一些点子，我就会考虑是否可以通过重构立即轻松地实现它们。如果可以，我就会动手。这样做了几次以后，我可以更清楚地看到，当我的建议被实施以后，代码会是什么样。我不必想象代码应该是什么样，我可以真实看见。于是我可以获得更高层次的认识。如果不进行重构，我永远无法得到这样的认识。</p><p>重构还可以帮助代码复审工作得到更具体的结果。不仅获得建议，而且其中许多建议能够立刻实现。最终你将从实践中得到比以往多得多的成就感。</p><p>至于如何在代码复审的过程中加入重构，这要取决于复审的形式。在常见的 pull request 模式下，复审者独自浏览代码，代码的作者不在旁边，此时进行重构效果并不好。如果代码的原作者在旁边会好很多，因为作者能提供关于代码的上下文信息，并且充分认同复审者进行修改的意图。对我个人而言，与原作者肩并肩坐在一起，一边浏览代码一边重构，体验是最佳的。这种工作方式很自然地导向结对编程：在编程的过程中持续不断地进行代码复审。</p><h3 id="怎么对经理说"><a href="#怎么对经理说" class="headerlink" title="怎么对经理说"></a>怎么对经理说</h3><p>“该怎么跟经理说重构的事?”这是我最常被问到的一个问题。毋庸讳言，我见过一些场合，“重构”被视为一个脏词——经理（和客户）认为重构要么是在弥补过去犯下的错误，要么是不增加价值的无用功。如果团队又计划了几周时间专门做重构，情况就更糟糕了——如果他们做的其实还不是重构，而是不加小心的结构调整，然后又对代码库造成了破坏，那可就真是糟透了。</p><p>如果这位经理懂技术，能理解“设计耐久性假说”，那么向他说明重构的意义应该不会很困难。这样的经理应该会鼓励日常的重构，并主动寻找团队日常重构做得不够的征兆。虽然“团队做了太多重构”的情况确实也发生过，但比起做得不够的情况要罕见得多了。</p><p>当然，很多经理和客户不具备这样的技术意识，他们不理解代码库的健康对生产率的影响。这种情况下我会给团队一个较有争议的建议：不要告诉经理！</p><p>这是在搞破坏吗？我不这样想。软件开发者都是专业人士。我们的工作就是尽可能快速创造出高效软件。我的经验告诉我，对于快速创造软件，重构可带来巨大帮助。如果需要添加新功能，而原本设计却又使我无法方便地修改，我发现先重构再添加新功能会更快些。如果要修补错误，就得先理解软件的工作方式，而我发现重构是理解软件的最快方式。受进度驱动的经理要我尽可能快速完成任务，至于怎么完成，那就是我的事了。我领这份工资，是因为我擅长快速实现新功能；我认为最快的方式就是重构，所以我就重构。</p><h3 id="何时不应该重构"><a href="#何时不应该重构" class="headerlink" title="何时不应该重构"></a>何时不应该重构</h3><p>听起来好像我一直在提倡重构，但确实有一些不值得重构的情况。</p><p>如果我看见一块凌乱的代码，但并不需要修改它，那么我就不需要重构它。如果丑陋的代码能被隐藏在一个 API 之下，我就可以容忍它继续保持丑陋。只有当我需要理解其工作原理时，对其进行重构才有价值。</p><p>另一种情况是，如果重写比重构还容易，就别重构了。这是个困难的决定。如果不花一点儿时间尝试，往往很难真实了解重构一块代码的难度。决定到底应该重构还是重写，需要良好的判断力与丰富的经验，我无法给出一条简单的建议。</p><h2 id="2-5-重构的挑战"><a href="#2-5-重构的挑战" class="headerlink" title="2.5 重构的挑战"></a>2.5 重构的挑战</h2><p>每当有人大力推荐一种技术、工具或者架构时，我总是会观察这东西会遇到哪些挑战，毕竟生活中很少有晴空万里的好事。你需要了解一件事背后的权衡取舍，才能决定何时何地应用它。我认为重构是一种很有价值的技术，大多数团队都应该更多地重构，但它也不是完全没有挑战的。有必要充分了解重构会遇到的挑战，这样才能做出有效应对。</p><h3 id="延缓新功能开发"><a href="#延缓新功能开发" class="headerlink" title="延缓新功能开发"></a>延缓新功能开发</h3><p>如果你读了前面一小节，我对这个挑战的回应便已经很清楚了。尽管重构的目的是加快开发速度，但是，仍旧很多人认为，花在重构的时间是在拖慢新功能的开发进度。“重构会拖慢进度”这种看法仍然很普遍，这可能是导致人们没有充分重构的最大阻力所在。</p><blockquote><p><strong>Tip</strong><br>重构的唯一目的就是让我们开发更快，用更少的工作量创造更大的价值。</p></blockquote><p>有一种情况确实需要权衡取舍。我有时会看到一个（大规模的）重构很有必要进行，而马上要添加的功能非常小，这时我会更愿意先把新功能加上，然后再做这次大规模重构。做这个决定需要判断力——这是我作为程序员的专业能力之一。我很难描述决定的过程，更无法量化决定的依据。</p><p>我清楚地知道，预备性重构常会使修改更容易，所以如果做一点儿重构能让新功能实现更容易，我一定会做。如果一个问题我已经见过，此时我也会更倾向于重构它——有时我就得先看见一块丑陋的代码几次，然后才能提起劲头来重构它。也就是说，如果一块代码我很少触碰，它不会经常给我带来麻烦，那么我就倾向于不去重构它。如果我还没想清楚究竟应该如何优化代码，那么我可能会延迟重构；当然，有的时候，即便没想清楚优化的方向，我也会先做些实验，试试看能否有所改进。</p><p>我从同事那里听到的证据表明，在我们这个行业里，重构不足的情况远多于重构过度的情况。换句话说，绝大多数人应该尝试多做重构。代码库的健康与否，到底会对生产率造成多大的影响，很多人可能说不出来，因为他们没有太多在健康的代码库上工作的经历——轻松地把现有代码组合配置，快速构造出复杂的新功能，这种强大的开发方式他们没有体验过。</p><p>虽然我们经常批评管理者以“保障开发速度”的名义压制重构，其实程序员自己也经常这么干。有时他们自己觉得不应该重构，其实他们的领导还挺希望他们做一些重构的。如果你是一支团队的技术领导，一定要向团队成员表明，你重视改善代码库健康的价值。合理判断何时应该重构、何时应该暂时不重构，这样的判断力需要多年经验积累。对于重构缺乏经验的年轻人需要有意的指导，才能帮助他们加速经验积累的过程。</p><p>有些人试图用“整洁的代码”“良好的工程实践”之类道德理由来论证重构的必要性，我认为这是个陷阱。重构的意义不在于把代码库打磨得闪闪发光，而是纯粹经济角度出发的考量。我们之所以重构，因为它能让我们更快——添加功能更快，修复 bug 更快。一定要随时记住这一点，与别人交流时也要不断强调这一点。重构应该总是由经济利益驱动。程序员、经理和客户越理解这一点，“好的设计”那条曲线就会越经常出现。</p><h3 id="代码所有权"><a href="#代码所有权" class="headerlink" title="代码所有权"></a>代码所有权</h3><p>很多重构手法不仅会影响一个模块内部，还会影响该模块与系统其他部分的关系。比如我想给一个函数改名，并且我也能找到该函数的所有调用者，那么我只需运用改变函数声明（124），在一次重构中修改函数声明和调用者。但即便这么简单的一个重构，有时也无法实施：调用方代码可能由另一支团队拥有，而我没有权限写入他们的代码库；这个函数可能是一个提供给客户的 API，这时我根本无法知道是否有人使用它，至于谁在用、用得有多频繁就更是一无所知。这样的函数属于已发布接口（published interface）：接口的使用者（客户端）与声明者彼此独立，声明者无权修改使用者的代码。</p><p>代码所有权的边界会妨碍重构，因为一旦我自作主张地修改，就一定会破坏使用者的程序。这不会完全阻止重构，我仍然可以做很多重构，但确实会对重构造成约束。为了给一个函数改名，我需要使用函数改名（124），但同时也得保留原来的函数声明，使其把调用传递给新的函数。这会让接口变复杂，但这就是为了避免破坏使用者的系统而不得不付出的代价。我可以把旧的接口标记为“不推荐使用”（deprecated），等一段时间之后最终让其退休；但有些时候，旧的接口必须一直保留下去。</p><p>由于这些复杂性，我建议不要搞细粒度的强代码所有制。有些组织喜欢给每段代码都指定唯一的所有者，只有这个人能修改这段代码。我曾经见过一支只有三个人的团队以这种方式运作，每个程序员都要给另外两人发布接口，随之而来的就是接口维护的种种麻烦。如果这三个人都直接去代码库里做修改，事情会简单得多。我推荐团队代码所有制，这样一支团队里的成员都可以修改这个团队拥有的代码，即便最初写代码的是别人。程序员可能各自分工负责系统的不同区域，但这种责任应该体现为监控自己责任区内发生的修改，而不是简单粗暴地禁止别人修改。</p><p>这种较为宽容的代码所有制甚至可以应用于跨团队的场合。有些团队鼓励类似于开源的模型：B 团队的成员也可以在一个分支上修改 A 团队的代码，然后把提交发送给 A 团队去审核。这样一来，如果团队想修改自己的函数，他们就可以同时修改该函数的客户端的代码；只要客户端接受了他们的修改，就可以删掉旧的函数声明了。对于涉及多个团队的大系统开发，在“强代码所有制”和“混乱修改”两个极端之间，这种类似开源的模式常常是一个合适的折中。</p><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>很多团队采用这样的版本控制实践：每个团队成员各自在代码库的一条分支上工作，进行相当大量的开发之后，才把各自的修改合并回主线分支（这条分支通常叫 master 或 trunk），从而与整个团队分享。常见的做法是在分支上开发完整的功能，直到功能可以发布到生产环境，才把该分支合并回主线。这种做法的拥趸声称，这样能保持主线不受尚未完成的代码侵扰，能保留清晰的功能添加的版本记录，并且在某个功能出问题时能容易地撤销修改。</p><p>这样的特性分支有其缺点。在隔离的分支上工作得越久，将完成的工作集成（integrate）回主线就会越困难。为了减轻集成的痛苦，大多数人的办法是频繁地从主线合并（merge）或者变基（rebase）到分支。但如果有几个人同时在各自的特性分支上工作，这个办法并不能真正解决问题，因为合并与集成是两回事。如果我从主线合并到我的分支，这只是一个单向的代码移动——我的分支发生了修改，但主线并没有。而“集成”是一个双向的过程：不仅要把主线的修改拉（pull）到我的分支上，而且要把我这里修改的结果推（push）回到主线上，两边都会发生修改。假如另一名程序员 Rachel 正在她的分支上开发，我是看不见她的修改的，直到她将自己的修改与主线集成；此时我就必须把她的修改合并到我的特性分支，这可能需要相当的工作量。其中困难的部分是处理语义变化。现代版本控制系统都能很好地合并程序文本的复杂修改，但对于代码的语义它们一无所知。如果我修改了一个函数的名字，版本控制工具可以很轻松地将我的修改与 Rachel 的代码集成。但如果在集成之前，她在自己的分支里新添调用了这个被我改名的函数，集成之后的代码就会被破坏。</p><p>分支合并本来就是一个复杂的问题，随着特性分支存在的时间加长，合并的难度会指数上升。集成一个已经存在了 4 个星期的分支，较之集成存在了 2 个星期的分支，难度可不止翻倍。所以很多人认为，应该尽量缩短特性分支的生存周期，比如只有一两天。还有一些人（比如我本人）认为特性分支的生命还应该更短，我们采用的方法叫作持续集成（Continuous Integration，CI），也叫“基于主干开发”（Trunk-Based Development）。在使用 CI 时，每个团队成员每天至少向主线集成一次。这个实践避免了任何分支彼此差异太大，从而极大地降低了合并的难度。不过 CI 也有其代价：你必须使用相关的实践以确保主线随时处于健康状态，必须学会将大功能拆分成小块，还必须使用特性开关（feature toggle，也叫特性旗标，feature flag）将尚未完成又无法拆小的功能隐藏掉。</p><p>CI 的粉丝之所以喜欢这种工作方式，部分原因是它降低了分支合并的难度，不过最重要的原因还是 CI 与重构能良好配合。重构经常需要对代码库中的很多地方做很小的修改（例如给一个广泛使用的函数改名），这样的修改尤其容易造成合并时的语义冲突。采用特性分支的团队常会发现重构加剧了分支合并的困难，并因此放弃了重构，这种情况我们曾经见过多次。CI 和重构能够良好配合，所以 Kent Beck 在极限编程中同时包含了这两个实践。</p><p>我并不是在说绝不应该使用特性分支。如果特性分支存在的时间足够短，它们就不会造成大问题。（实际上，使用 CI 的团队往往同时也使用分支，但他们会每天将分支与主线合并。）对于开源项目，特性分支可能是合适的做法，因为不时会有你不熟悉（因此也不信任）的程序员偶尔提交修改。但对全职的开发团队而言，特性分支对重构的阻碍太严重了。即便你没有完全采用 CI，我也一定会催促你尽可能频繁地集成。而且，用上 CI 的团队在软件交付上更加高效，我真心希望你认真考虑这个客观事实[Forsgren et al]。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>不会改变程序可观察的行为，这是重构的一个重要特征。如果仔细遵循重构手法的每个步骤，我应该不会破坏任何东西，但万一我犯了个错误怎么办？（呃，就我这个粗心大意的性格来说，请去掉“万一”两字。）人总会有出错的时候，不过只要及时发现，就不会造成大问题。既然每个重构都是很小的修改，即便真的造成了破坏，我也只需要检查最后一步的小修改——就算找不到出错的原因，只要回滚到版本控制中最后一个可用的版本就行了。</p><p>这里的关键就在于“快速发现错误”。要做到这一点，我的代码应该有一套完备的测试套件，并且运行速度要快，否则我会不愿意频繁运行它。也就是说，绝大多数情况下，如果想要重构，我得先有可以自测试的代码[mf-stc]。</p><p>有些读者可能会觉得，“自测试的代码”这个要求太高，根本无法实现。但在过去 20 年中，我看到很多团队以这种方式构造软件。的确，团队必须投入时间与精力在测试上，但收益是绝对划算的。自测试的代码不仅使重构成为可能，而且使添加新功能更加安全，因为我可以很快发现并干掉新近引入的 bug。这里的关键在于，一旦测试失败，我只需要查看上次测试成功运行之后修改的这部分代码；如果测试运行得很频繁，这个查看的范围就只有几行代码。知道必定是这几行代码造成 bug 的话，排查起来会容易得多。</p><p>这也回答了“重构风险太大，可能引入 bug”的担忧。如果没有自测试的代码，这种担忧就是完全合理的，这也是为什么我如此重视可靠的测试。</p><p>缺乏测试的问题可以用另一种方式来解决。如果我的开发环境很好地支持自动化重构，我就可以信任这些重构，不必运行测试。这时即便没有完备的测试套件，我仍然可以重构，前提是仅仅使用那些自动化的、一定安全的重构手法。这会让我损失很多好用的重构手法，不过剩下可用的也不少，我还是能从中获益。当然，我还是更愿意有自测试的代码，但如果没有，自动化重构的工具包也很好。</p><p>缺乏测试的现状还催生了另一种重构的流派：只使用一组经过验证是安全的重构手法。这个流派要求严格遵循重构的每个步骤，并且可用的重构手法是特定于语言的。使用这种方法，团队得以在测试覆盖率很低的大型代码库上开展一些有用的重构。这个重构流派比较新，涉及一些很具体、特定于编程语言的技巧与做法，行业里对这种方法的介绍和了解都还不足，因此本书不对其多做介绍。（不过我希望未来在我自己的网站上多讨论这个主题。感兴趣的读者可以查看 Jay Bazuzi 关于如何在 C++中安全地运用提炼函数（106）的描述[Bazuzi]，借此获得一点儿对这个重构流派的了解。）</p><p>毫不意外，自测试代码与持续集成紧密相关——我们仰赖持续集成来及时捕获分支集成时的语义冲突。自测试代码是极限编程的另一个重要组成部分，也是持续交付的关键环节。</p><h3 id="遗留代码"><a href="#遗留代码" class="headerlink" title="遗留代码"></a>遗留代码</h3><p>大多数人会觉得，有一大笔遗产是件好事，但从程序员的角度来看就不同了。遗留代码往往很复杂，测试又不足，而且最关键的是，是别人写的（瑟瑟发抖）。</p><p>重构可以很好地帮助我们理解遗留系统。引人误解的函数名可以改名，使其更好地反映代码用途；糟糕的程序结构可以慢慢理顺，把程序从一块顽石打磨成美玉。整个故事都很棒，但我们绕不开关底的恶龙：遗留系统多半没测试。如果你面对一个庞大而又缺乏测试的遗留系统，很难安全地重构清理它。</p><p>对于这个问题，显而易见的答案是“没测试就加测试”。这事听起来简单（当然工作量必定很大），操作起来可没那么容易。一般来说，只有在设计系统时就考虑到了测试，这样的系统才容易添加测试——可要是如此，系统早该有测试了，我也不用操这份心了。</p><p>这个问题没有简单的解决办法，我能给出的最好建议就是买一本《修改代码的艺术》[Feathers]，照书里的指导来做。别担心那本书太老，尽管已经出版十多年，其中的建议仍然管用。一言以蔽之，它建议你先找到程序的接缝，在接缝处插入测试，如此将系统置于测试覆盖之下。你需要运用重构手法创造出接缝——这样的重构很危险，因为没有测试覆盖，但这是为了取得进展必要的风险。在这种情况下，安全的自动化重构简直就是天赐福音。如果这一切听起来很困难，因为它确实很困难。很遗憾，一旦跌进这个深坑，没有爬出来的捷径，这也是我强烈倡导从一开始就写能自测试的代码的原因。</p><p>就算有了测试，我也不建议你尝试一鼓作气把复杂而混乱的遗留代码重构成漂亮的代码。我更愿意随时重构相关的代码：每次触碰一块代码时，我会尝试把它变好一点点——至少要让营地比我到达时更干净。如果是一个大系统，越是频繁使用的代码，改善其可理解性的努力就能得到越丰厚的回报。</p><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>在本书的第 1 版中，我说过数据库是“重构经常出问题的一个领域”。然而在第 1 版问世之后仅仅一年，情况就发生了改变：我的同事 Pramod Sadalage 发展出一套渐进式数据库设计[mf-evodb]和数据库重构[Ambler &amp; Sadalage]的办法，如今已经被广泛使用。这项技术的精要在于：借助数据迁移脚本，将数据库结构的修改与代码相结合，使大规模的、涉及数据库的修改可以比较容易地开展。</p><p>假设我们要对一个数据库字段（列）改名。和改变函数声明（124）一样，我要找出结构的声明处和所有调用处，然后一次完成所有修改。但这里的复杂之处在于，原来基于旧字段的数据，也要转为使用新字段。我会写一小段代码来执行数据转化的逻辑，并把这段代码放进版本控制，跟数据结构声明与使用代码的修改一并提交。此后如果我想把数据库迁移到某个版本，只要执行当前数据库版本与目标版本之间的所有迁移脚本即可。</p><p>跟通常的重构一样，数据库重构的关键也是小步修改并且每次修改都应该完整，这样每次迁移之后系统仍然能运行。由于每次迁移涉及的修改都很小，写起来应该容易；将多个迁移串联起来，就能对数据库结构及其中存储的数据做很大的调整。</p><p>与常规的重构不同，很多时候，数据库重构最好是分散到多次生产发布来完成，这样即便某次修改在生产数据库上造成了问题，也比较容易回滚。比如，要改名一个字段，我的第一次提交会新添一个字段，但暂时不使用它。然后我会修改数据写入的逻辑，使其同时写入新旧两个字段。随后我就可以修改读取数据的地方，将它们逐个改为使用新字段。这步修改完成之后，我会暂停一小段时间，看看是否有 bug 冒出来。确定没有 bug 之后，我再删除已经没人使用的旧字段。这种修改数据库的方式是并行修改（Parallel Change，也叫扩展协议&#x2F;expand-contract）[mf-pc]的一个实例。</p><h2 id="2-6-重构、架构和-YAGNI"><a href="#2-6-重构、架构和-YAGNI" class="headerlink" title="2.6 重构、架构和 YAGNI"></a>2.6 重构、架构和 YAGNI</h2><p>重构极大地改变了人们考虑软件架构的方式。在我的职业生涯早期，我被告知：在任何人开始写代码之前，必须先完成软件的设计和架构。一旦代码写出来，架构就固定了，只会因为程序员的草率对待而逐渐腐败。</p><p>重构改变了这种观点。有了重构技术，即便是已经在生产环境中运行了多年的软件，我们也有能力大幅度修改其架构。正如本书的副标题所指出的，重构可以改善既有代码的设计。但我在前面也提到了，修改遗留代码经常很有挑战，尤其当遗留代码缺乏恰当的测试时。</p><p>重构对架构最大的影响在于，通过重构，我们能得到一个设计良好的代码库，使其能够优雅地应对不断变化的需求。“在编码之前先完成架构”这种做法最大的问题在于，它假设了软件的需求可以预先充分理解。但经验显示，这个假设很多时候甚至可以说大多数时候是不切实际的。只有真正使用了软件、看到了软件对工作的影响，人们才会想明白自己到底需要什么，这样的例子不胜枚举。</p><p>应对未来变化的办法之一，就是在软件里植入灵活性机制。在编写一个函数时，我会考虑它是否有更通用的用途。为了应对我预期的应用场景，我预测可以给这个函数加上十多个参数。这些参数就是灵活性机制——跟大多数“机制”一样，它不是免费午餐。把所有这些参数都加上的话，函数在当前的使用场景下就会非常复杂。另外，如果我少考虑了一个参数，已经加上的这一堆参数会使新添参数更麻烦。而且我经常会把灵活性机制弄错——可能是未来的需求变更并非以我期望的方式发生，也可能我对机制的设计不好。考虑到所有这些因素，很多时候这些灵活性机制反而拖慢了我响应变化的速度。</p><p>有了重构技术，我就可以采取不同的策略。与其猜测未来需要哪些灵活性、需要什么机制来提供灵活性，我更愿意只根据当前的需求来构造软件，同时把软件的设计质量做得很高。随着对用户需求的理解加深，我会对架构进行重构，使其能够应对新的需要。如果一种灵活性机制不会增加复杂度（比如添加几个命名良好的小函数），我可以很开心地引入它；但如果一种灵活性会增加软件复杂度，就必须先证明自己值得被引入。如果不同的调用者不会传入不同的参数值，那么就不要添加这个参数。当真的需要添加这个参数时，运用函数参数化（310）也很容易。要判断是否应该为未来的变化添加灵活性，我会评估“如果以后再重构有多困难”，只有当未来重构会很困难时，我才考虑现在就添加灵活性机制。我发现这是一个很有用的决策方法。</p><p>这种设计方法有很多名字：简单设计、增量式设计或者 YAGNI[mf-yagni]——“你不会需要它”（you arenʼt going to need it）的缩写。YAGNI 并不是“不做架构性思考”的意思，不过确实有人以这种欠考虑的方式做事。我把 YAGNI 视为将架构、设计与开发过程融合的一种工作方式，这种工作方式必须有重构作为基础才可靠。</p><p>采用 YAGNI 并不表示完全不用预先考虑架构。总有一些时候，如果缺少预先的思考，重构会难以开展。但两者之间的平衡点已经发生了很大的改变：如今我更倾向于等一等，待到对问题理解更充分，再来着手解决。演进式架构[Ford et al.]是一门仍在不断发展的学科，架构师们在不断探索有用的模式和实践，充分发挥迭代式架构决策的能力。</p><h2 id="2-7-重构与软件开发过程"><a href="#2-7-重构与软件开发过程" class="headerlink" title="2.7 重构与软件开发过程"></a>2.7 重构与软件开发过程</h2><p>读完前面“重构的挑战”一节，你大概已经有这个印象：重构是否有效，与团队采用的其他软件开发实践紧密相关。重构起初是作为极限编程（XP）[mf-xp]的一部分被人们采用的，XP 本身就融合了一组不太常见而又彼此关联的实践，例如持续集成、自测试代码以及重构（后两者融汇成了测试驱动开发）。</p><p>极限编程是最早的敏捷软件开发方法[mf-nm]之一。在一段历史时期，极限编程引领了敏捷的崛起。如今已经有很多项目使用敏捷方法，甚至敏捷的思维已经被视为主流，但实际上大部分“敏捷”项目只是徒有其名。要真正以敏捷的方式运作项目，团队成员必须在重构上有能力、有热情，他们采用的开发过程必须与常规的、持续的重构相匹配。</p><p>重构的第一块基石是自测试代码。我应该有一套自动化的测试，我可以频繁地运行它们，并且我有信心：如果我在编程过程中犯了任何错误，会有测试失败。这块基石如此重要，我会专门用一章篇幅来讨论它。</p><p>如果一支团队想要重构，那么每个团队成员都需要掌握重构技能，能在需要时开展重构，而不会干扰其他人的工作。这也是我鼓励持续集成的原因：有了 CI，每个成员的重构都能快速分享给其他同事，不会发生这边在调用一个接口那边却已把这个接口删掉的情况；如果一次重构会影响别人的工作，我们很快就会知道。自测试的代码也是持续集成的关键环节，所以这三大实践——自测试代码、持续集成、重构——彼此之间有着很强的协同效应。</p><p>有这三大实践在手，我们就能运用前一节介绍的 YAGNI 设计方法。重构和 YAGNI 交相呼应、彼此增效，重构（及其前置实践）是 YAGNI 的基础，YAGNI 又让重构更易于开展：比起一个塞满了想当然的灵活性的系统，当然是修改一个简单的系统要容易得多。在这些实践之间找到合适的平衡点，你就能进入良性循环，你的代码既牢固可靠又能快速响应变化的需求。</p><p>有这三大核心实践打下的基础，才谈得上运用敏捷思想的其他部分。持续交付确保软件始终处于可发布的状态，很多互联网团队能做到一天多次发布，靠的正是持续交付的威力。即便我们不需要如此频繁的发布，持续集成也能帮我们降低风险，并使我们做到根据业务需要随时安排发布，而不受技术的局限。有了可靠的技术根基，我们能够极大地压缩“从好点子到生产代码”的周期时间，从而更好地服务客户。这些技术实践也会增加软件的可靠性，减少耗费在 bug 上的时间。</p><p>这一切说起来似乎很简单，但实际做起来毫不容易。不管采用什么方法，软件开发都是一件复杂而微妙的事，涉及人与人之间、人与机器之间的复杂交互。我在这里描述的方法已经被证明可以应对这些复杂性，但——就跟其他所有方法一样——对使用者的实践和技能有要求。</p><h2 id="2-8-重构与性能"><a href="#2-8-重构与性能" class="headerlink" title="2.8 重构与性能"></a>2.8 重构与性能</h2><p>关于重构，有一个常被提出的问题：它对程序的性能将造成怎样的影响？为了让软件易于理解，我常会做出一些使程序运行变慢的修改。这是一个重要的问题。我并不赞成为了提高设计的纯洁性而忽视性能，把希望寄托于更快的硬件身上也绝非正道。已经有很多软件因为速度太慢而被用户拒绝，日益提高的机器速度也只不过略微放宽了速度方面的限制而已。但是，换个角度说，虽然重构可能使软件运行更慢，但它也使软件的性能优化更容易。除了对性能有严格要求的实时系统，其他任何情况下“编写快速软件”的秘密就是：先写出可调优的软件，然后调优它以求获得足够的速度。</p><p>我看过 3 种编写快速软件的方法。其中最严格的是时间预算法，这通常只用于性能要求极高的实时系统。如果使用这种方法，分解你的设计时就要做好预算，给每个组件预先分配一定资源，包括时间和空间占用。每个组件绝对不能超出自己的预算，就算拥有组件之间调度预配时间的机制也不行。这种方法高度重视性能，对于心律调节器一类的系统是必需的，因为在这样的系统中迟来的数据就是错误的数据。但对其他系统（例如我经常开发的企业信息系统）而言，如此追求高性能就有点儿过分了。</p><p>第二种方法是持续关注法。这种方法要求任何程序员在任何时间做任何事时，都要设法保持系统的高性能。这种方式很常见，感觉上很有吸引力，但通常不会起太大作用。任何修改如果是为了提高性能，通常会使程序难以维护，继而减缓开发速度。如果最终得到的软件的确更快了，那么这点损失尚有所值，可惜通常事与愿违，因为性能改善一旦被分散到程序各个角落，每次改善都只不过是从对程序行为的一个狭隘视角出发而已，而且常常伴随着对编译器、运行时环境和硬件行为的误解。</p><blockquote><p><strong>Tip</strong><br>劳而无获</p></blockquote><p>克莱斯勒综合薪资系统的支付过程太慢了。虽然我们的开发还没结束，这个问题却已经开始困扰我们，因为它已经拖累了测试速度。</p><p>Kent Beck、Martin Fowler 和我决定解决这个问题。等待大伙儿会合的时间里，凭着对这个系统的全盘了解，我开始推测：到底是什么让系统变慢了？我想到数种可能，然后和伙伴们谈了几种可能的修改方案。最后，我们就“如何让这个系统运行更快”，提出了一些真正的好点子。</p><p>然后，我们拿 Kent 的工具度量了系统性能。我一开始所想的可能性竟然全都不是问题肇因。我们发现：系统把一半时间用来创建“日期”实例（instance）。更有趣的是，所有这些实例都有相同的几个值。</p><p>于是我们观察日期对象的创建逻辑，发现有机会将它优化。这些日期对象在创建时都经过了一个字符串转换过程，然而这里并没有任何外部数据输入。之所以使用字符串转换方式，完全只是因为代码写起来简单。好，也许我们可以优化它。</p><p>然后，我们观察这些日期对象是如何被使用的。我们发现，很多日期对象都被用来产生“日期区间”实例——由一个起始日期和一个结束日期组成的对象。仔细追踪下去，我们发现绝大多数日期区间是空的！</p><p>处理日期区间时我们遵循这样一个规则：如果结束日期在起始日期之前，这个日期区间就该是空的。这是一条很好的规则，完全符合这个类的需要。采用此规则后不久，我们意识到，创建一个“起始日期在结束日期之后”的日期区间，仍然不算是清晰的代码，于是我们把这个行为提炼成一个工厂函数，由它专门创建“空的日期区间”。</p><p>我们做了上述修改，使代码更加清晰，也意外得到了一个惊喜：可以创建一个固定不变的“空日期区间”对象，并让上述调整后的工厂函数始终返回该对象，而不再每次都创建新对象。这一修改把系统速度提升了几乎一倍，足以让测试速度达到可接受的程度。这只花了我们大约五分钟。</p><p>我和团队成员（Kent 和 Martin 谢绝参加）认真推测过：我们了若指掌的这个程序中可能有什么错误？我们甚至凭空做了些改进设计，却没有先对系统的真实情况进行度量。</p><p>我们完全错了。除了一场很有趣的交谈，我们什么好事都没做。</p><p>教训是：哪怕你完全了解系统，也请实际度量它的性能，不要臆测。臆测会让你学到一些东西，但十有八九你是错的。</p><p>——Ron Jeffries</p><p>关于性能，一件很有趣的事情是：如果你对大多数程序进行分析，就会发现它把大半时间都耗费在一小半代码身上。如果你一视同仁地优化所有代码，90％的优化工作都是白费劲的，因为被你优化的代码大多很少被执行。你花时间做优化是为了让程序运行更快，但如果因为缺乏对程序的清楚认识而花费时间，那些时间就都被浪费掉了。</p><p>第三种性能提升法就是利用上述的 90%统计数据。采用这种方法时，我编写构造良好的程序，不对性能投以特别的关注，直至进入性能优化阶段——那通常是在开发后期。一旦进入该阶段，我再遵循特定的流程来调优程序性能。</p><p>在性能优化阶段，我首先应该用一个度量工具来监控程序的运行，让它告诉我程序中哪些地方大量消耗时间和空间。这样我就可以找出性能热点所在的一小段代码。然后我应该集中关注这些性能热点，并使用持续关注法中的优化手段来优化它们。由于把注意力都集中在热点上，较少的工作量便可显现较好的成果。即便如此，我还是必须保持谨慎。和重构一样，我会小幅度进行修改。每走一步都需要编译、测试，再次度量。如果没能提高性能，就应该撤销此次修改。我会继续这个“发现热点，去除热点”的过程，直到获得客户满意的性能为止。</p><p>一个构造良好的程序可从两方面帮助这一优化方式。首先，它让我有比较充裕的时间进行性能调整，因为有构造良好的代码在手，我能够更快速地添加功能，也就有更多时间用在性能问题上（准确的度量则保证我把这些时间投在恰当地点）。其次，面对构造良好的程序，我在进行性能分析时便有较细的粒度。度量工具会把我带入范围较小的代码段中，而性能的调整也比较容易些。由于代码更加清晰，因此我能够更好地理解自己的选择，更清楚哪种调整起关键作用。</p><p>我发现重构可以帮助我写出更快的软件。短期看来，重构的确可能使软件变慢，但它使优化阶段的软件性能调优更容易，最终还是会得到好的效果。</p><h2 id="2-9-重构起源何处"><a href="#2-9-重构起源何处" class="headerlink" title="2.9 重构起源何处"></a>2.9 重构起源何处</h2><p>我曾经努力想找出“重构”（refactoring）一词的真正起源，但最终失败了。优秀程序员肯定至少会花一些时间来清理自己的代码。这么做是因为，他们知道整洁的代码比杂乱无章的代码更容易修改，而且他们知道自己几乎无法一开始就写出整洁的代码。</p><p>重构不止如此。本书中我把重构看作整个软件开发过程的一个关键环节。最早认识重构重要性的两个人是 Ward Cunningham 和 Kent Beck，他们早在 20 世纪 80 年代就开始使用 Smalltalk，那是一个特别适合重构的环境。Smalltalk 是一个十分动态的环境，用它可以很快写出功能丰富的软件。Smalltalk 的“编译-链接-执行”周期非常短，因此很容易快速修改代码——要知道，当时很多编程环境做一次编译就需要整晚时间。它支持面向对象，也有强大的工具，最大限度地将修改的影响隐藏于定义良好的接口背后。Ward 和 Kent 努力探索出一套适合这类环境的软件开发过程（如今，Kent 把这种风格叫作极限编程）。他们意识到：重构对于提高生产力非常重要。从那时起他们就一直在工作中运用重构技术，在正式的软件项目中使用它，并不断精炼重构的过程。</p><p>Ward 和 Kent 的思想对 Smalltalk 社区产生了极大影响，重构概念也成为 Smalltalk 文化中的一个重要元素。Smalltalk 社区的另一位领袖是 Ralph Johnson，伊利诺伊大学厄巴纳-香槟分校教授，著名的 GoF[gof]之一。Ralph 最大的兴趣之一就是开发软件框架。他揭示了重构有助于灵活高效框架的开发。</p><p>Bill Opdyke 是 Ralph 的博士研究生，对框架也很感兴趣。他看到了重构的潜在价值，并看到重构应用于 Smalltalk 之外的其他语言的可能性。他的技术背景是电话交换系统的开发。在这种系统中，大量的复杂情况与日俱增，而且非常难以修改。Bill 的博士研究就是从工具构筑者的角度来看待重构。Bill 对 C++的框架开发中用得上的重构手法特别感兴趣。他也研究了极有必要的“语义保持的重构” （semantics-preserving refactoring），并阐明了如何证明这些重构是语义保持的，以及如何用工具实现重构。Bill 的博士论文[Opdyke]是重构领域中第一部丰硕的研究成果。</p><p>我还记得 1992 年 OOPSLA 大会上见到 Bill 的情景。我们坐在一间咖啡厅里，Bill 跟我谈起他的研究成果，我还记得自己当时的想法：“有趣，但并非真的那么重要。”唉，我完全错了。</p><p>John Brant 和 Don Roberts 将“重构工具”的构想发扬光大，开发了一个名为 Refactoring Browser （重构浏览器）的重构工具。这是第一个自动化的重构工具，多亏 Smalltalk 提供了适合重构的编程环境。</p><p>那么，我呢？我一直有清理代码的倾向，但从来没有想到这会如此重要。后来我和 Kent 一起做一个项目，看到他使用重构手法，也看到重构对开发效能和质量带来的影响。这份体验让我相信：重构是一门非常重要的技术。但是，在重构的学习和推广过程中我遇到了挫折，因为我拿不出任何一本书给程序员看，也没有任何一位专家打算写这样一本书。所以，在这些专家的帮助下，我写下了这本书的第 1 版。</p><p>幸运的是，重构的概念被行业广泛接受了。本书第 1 版销量不错，“重构”一词也走进了大多数程序员的词汇库。更多的重构工具涌现出来，尤其是在 Java 世界里。重构的流行也带来了负面效应：很多人随意地使用“重构”这个词，而他们真正做的却是不严谨的结构调整。尽管如此，重构终归成了一项主流的软件开发实践。</p><h2 id="2-10-自动化重构"><a href="#2-10-自动化重构" class="headerlink" title="2.10 自动化重构"></a>2.10 自动化重构</h2><p>过去 10 年中，重构领域最大的变化可能就是出现了一批支持自动化重构的工具。如果我想给一个 Java 的方法改名，在 IntelliJ IDEA 或者 Eclipse 这样的开发环境中，我只需要从菜单里点选对应的选项，工具会帮我完成整个重构过程，而且我通常都可以相信，工具完成的重构是可靠的，所以用不着运行测试套件。</p><p>第一个自动化重构工具是 Smalltalk 的 Refactoring Browser，由 John Brandt 和 Don Roberts 开发。在 21 世纪初，Java 世界的自动化重构工具如雨后春笋般涌现。在 JetBrains 的 IntelliJ IDEA 集成开发环境（IDE）中，自动化重构是最亮眼的特性之一。IBM 也紧随其后，在 VisualAge 的 Java 版中也提供了重构工具。VisualAge 的影响力有限，不过其中很多能力后来被 Eclipse 继承，包括对重构的支持。</p><p>重构也进入了 C#世界，起初是通过 JetBrains 的 Resharper，这是一个 Visual Studio 插件。后来 Visual Studio 团队直接在 IDE 里提供了一些重构能力。</p><p>如今的编辑器和开发工具中常能找到一些对重构的支持，不过真实的重构能力各有高低。重构能力的差异既有工具的原因，也受限于不同语言对自动化重构的支持程度。在这里，我不打算分析各种工具的能力，不过谈谈重构工具背后的原则还是有点儿意思的。</p><p>一种粗糙的自动化重构方式是文本操作，比如用查找&#x2F;替换的方式给函数改名，或者完成提炼变量（119）所需的简单结构调整。这种方法太粗糙了，做完之后必须重新运行测试，否则不能信任。但这可以是一个便捷的起步。在用 Emacs 编程时，没有那些更完善的重构支持，我也会用类似的文本操作宏来加速重构。</p><p>要支持体面的重构，工具只操作代码文本是不行的，必须操作代码的语法树，这样才能更可靠地保持代码行为。所以，今天的大多数重构功能都依附于强大的 IDE，因为这些 IDE 原本就在语法树上实现了代码导航、静态检查等功能，自然也可以用于重构。不仅能处理文本，还能处理语法树，这是 IDE 相比于文本编辑器更先进的地方。</p><p>重构工具不仅需要理解和修改语法树，还要知道如何把修改后的代码写回编辑器视图。总而言之，实现一个体面的自动化重构手法，是一个很有挑战的编程任务。尽管我一直开心地使用重构工具，对它们背后的实现却知之甚少。</p><p>在静态类型语言中，很多重构手法会更加安全。假设我想做一次简单的函数改名（124）：在 Salesman 类和 Server 类中都有一个叫作 addClient 的函数，当然两者各有其用途。我想对 Salesman 中的 addClient 函数改名，Server 类中的函数则保持不变。如果不是静态类型，工具很难识别调用 addClient 的地方到底是在使用哪个类的函数。Smalltalk 的 Refactoring Browser 会列出所有调用点，我需要手工决定修改哪些调用点。这个重构是不安全的，我必须重新运行所有测试。这样的工具仍然有用，但在 Java 中的函数改名（124）重构则可以是完全安全、完全自动的，因为在静态类型的帮助下，工具可以识别函数所属的类，所以它只会修改应该修改的那些函数调用点，对此我可以完全放心。</p><p>一些重构工具走得更远。如果我给一个变量改名，工具会提醒我修改使用了旧名字的注释。如果我使用提炼函数（106），工具会找出与新函数体重复的代码片段，建议代之以对新函数的调用。在编程时可以使用如此强大的重构功能，这就是为什么我们要使用一个体面的 IDE，而不是固执于熟悉的文本编辑器。我个人很喜欢用 Emacs，但在使用 Java 时，我更愿意用 IntelliJ IDEA 或者 Eclipse，很大程度上就是为了获得重构支持。</p><p>尽管这些强大的重构工具有着魔法般的能力，可以安全地重构代码，但还是会有闪失出现。通过反射进行的调用（例如 Java 中的 Method.invoke）会迷惑不够成熟的重构工具，但比较成熟的工具则可以很好地应对。所以，即便是最安全的重构，也应该经常运行测试套件，以确保没有什么东西在不经意间被破坏。我经常会间杂进行自动重构和手动重构，所以运行测试的频度是足够的。</p><p>能借助语法树来分析和重构程序代码，这是 IDE 与普通文本编辑器相比具有的一大优势。但很多程序员又喜欢用得顺手的文本编辑器的灵活性，希望鱼与熊掌兼得。语言服务器（Language Server）是一种正在引起关注的新技术：用软件生成语法树，给文本编辑器提供 API。语言服务器可以支持多种文本编辑器，并且为强大的代码分析和重构操作提供了命令。</p><h1 id="3-代码的坏味道"><a href="#3-代码的坏味道" class="headerlink" title="3.代码的坏味道"></a>3.代码的坏味道</h1><p>——Kent Beck 和 Martin Fowler</p><p>“如果尿布臭了，就换掉它。”</p><p>——语出 Beck 奶奶，论保持小孩清洁的哲学</p><p>现在，对于重构如何运作，你已经有了相当好的理解。但是知道“如何”不代表知道“何时”。决定何时重构及何时停止和知道重构机制如何运转一样重要。</p><p>难题来了！解释“如何删除一个实例变量”或“如何产生一个继承体系”很容易，因为这些都是很简单的事情，但要解释“该在什么时候做这些动作”就没那么顺理成章了。除了露几手含混的编程美学（说实话，这就是咱们这些顾问常做的事），我还希望让某些东西更具说服力一些。</p><p>撰写本书的第 1 版时，我正在为这个微妙的问题大伤脑筋。去苏黎世拜访 Kent Beck 的时候，也许是因为受到刚出生的女儿的气味影响吧，他提出用味道来形容重构的时机。</p><p>“味道，”你可能会说，“真的比含混的美学理论要好吗？”好吧，是的。我们看过很多很多代码，它们所属的项目从大获成功到奄奄一息都有。观察这些代码时，我们学会了从中找寻某些特定结构，这些结构指出（有时甚至就像尖叫呼喊）重构的可能性。（本章主语换成“我们”，是为了反映一个事实：Kent 和我共同撰写本章。你应该可以看出我俩的文笔差异——插科打诨的部分是我写的，其余都是他写的。）</p><p>我们并不试图给你一个何时必须重构的精确衡量标准。从我们的经验看来，没有任何量度规矩比得上见识广博者的直觉。我们只会告诉你一些迹象，它会指出“这里有一个可以用重构解决的问题”。你必须培养自己的判断力，学会判断一个类内有多少实例变量算是太大、一个函数内有多少行代码才算太长。</p><p>如果你无法确定该采用哪一种重构手法，请阅读本章内容和书后附的“重构列表”来寻找灵感。你可以阅读本章或快速浏览书后附的“坏味道与重构手法速查表”来判断自己闻到的是什么味道，然后再看看我们所建议的重构手法能否帮到你。也许这里所列的“坏味道条款”和你所检测的不尽相符，但愿它们能够为你指引正确方向。</p><h2 id="3-1-神秘命名（Mysterious-Name）"><a href="#3-1-神秘命名（Mysterious-Name）" class="headerlink" title="3.1 神秘命名（Mysterious Name）"></a>3.1 神秘命名（Mysterious Name）</h2><p>读侦探小说时，透过一些神秘的文字猜测故事情节是一种很棒的体验；但如果是在阅读代码，这样的体验就不怎么好了。我们也许会幻想自己是《王牌大贱谍》中的国际特工 1，但我们写下的代码应该直观明了。整洁代码最重要的一环就是好的名字，所以我们会深思熟虑如何给函数、模块、变量和类命名，使它们能清晰地表明自己的功能和用法。</p><p>然而，很遗憾，命名是编程中最难的两件事之一[mf-2h]。正因为如此，改名可能是最常用的重构手法，包括改变函数声明（124）（用于给函数改名）、变量改名（137）、字段改名（244）等。很多人经常不愿意给程序元素改名，觉得不值得费这个劲，但好的名字能节省未来用在猜谜上的大把时间。</p><p>改名不仅仅是修改名字而已。如果你想不出一个好名字，说明背后很可能潜藏着更深的设计问题。为一个恼人的名字所付出的纠结，常常能推动我们对代码进行精简。</p><p>1《王牌大贱谍》（International Man of Mystery）是 1997 年杰伊·罗奇执导的一部喜剧谍战片。——译者注</p><h2 id="3-2-重复代码（Duplicated-Code）"><a href="#3-2-重复代码（Duplicated-Code）" class="headerlink" title="3.2 重复代码（Duplicated Code）"></a>3.2 重复代码（Duplicated Code）</h2><p>如果你在一个以上的地点看到相同的代码结构，那么可以肯定：设法将它们合而为一，程序会变得更好。一旦有重复代码存在，阅读这些重复的代码时你就必须加倍仔细，留意其间细微的差异。如果要修改重复代码，你必须找出所有的副本来修改。</p><p>最单纯的重复代码就是“同一个类的两个函数含有相同的表达式”。这时候你需要做的就是采用提炼函数（106）提炼出重复的代码，然后让这两个地点都调用被提炼出来的那一段代码。如果重复代码只是相似而不是完全相同，请首先尝试用移动语句（223）重组代码顺序，把相似的部分放在一起以便提炼。如果重复的代码段位于同一个超类的不同子类中，可以使用函数上移（350）来避免在两个子类之间互相调用。</p><h2 id="3-3-过长函数（Long-Function）"><a href="#3-3-过长函数（Long-Function）" class="headerlink" title="3.3 过长函数（Long Function）"></a>3.3 过长函数（Long Function）</h2><p>据我们的经验，活得最长、最好的程序，其中的函数都比较短。初次接触到这种代码库的程序员常常会觉得“计算都没有发生”——程序里满是无穷无尽的委托调用。但和这样的程序共处几年之后，你就会明白这些小函数的价值所在。间接性带来的好处——更好的阐释力、更易于分享、更多的选择——都是由小函数来支持的。</p><p>早在编程的洪荒年代，程序员们就已认识到：函数越长，就越难理解。在早期的编程语言中，子程序调用需要额外开销，这使得人们不太乐意使用小函数。现代编程语言几乎已经完全免除了进程内的函数调用开销。固然，小函数也会给代码的阅读者带来一些负担，因为你必须经常切换上下文，才能看明白函数在做什么。但现代的开发环境让你可以在函数的调用处与声明处之间快速跳转，或是同时看到这两处，让你根本不用来回跳转。不过说到底，让小函数易于理解的关键还是在于良好的命名。如果你能给函数起个好名字，阅读代码的人就可以通过名字了解函数的作用，根本不必去看其中写了些什么。</p><p>最终的效果是：你应该更积极地分解函数。我们遵循这样一条原则：每当感觉需要以注释来说明点什么的时候，我们就把需要说明的东西写进一个独立函数中，并以其用途（而非实现手法）命名。我们可以对一组甚至短短一行代码做这件事。哪怕替换后的函数调用动作比函数自身还长，只要函数名称能够解释其用途，我们也该毫不犹豫地那么做。关键不在于函数的长度，而在于函数“做什么”和“如何做”之间的语义距离。</p><p>百分之九十九的场合里，要把函数变短，只需使用提炼函数（106）。找到函数中适合集中在一起的部分，将它们提炼出来形成一个新函数。</p><p>如果函数内有大量的参数和临时变量，它们会对你的函数提炼形成阻碍。如果你尝试运用提炼函数（106），最终就会把许多参数传递给被提炼出来的新函数，导致可读性几乎没有任何提升。此时，你可以经常运用以查询取代临时变量（178）来消除这些临时元素。引入参数对象（140）和保持对象完整（319）则可以将过长的参数列表变得更简洁一些。</p><p>如果你已经这么做了，仍然有太多临时变量和参数，那就应该使出我们的杀手锏——以命令取代函数（337）。</p><p>如何确定该提炼哪一段代码呢？一个很好的技巧是：寻找注释。它们通常能指出代码用途和实现手法之间的语义距离。如果代码前方有一行注释，就是在提醒你：可以将这段代码替换成一个函数，而且可以在注释的基础上给这个函数命名。就算只有一行代码，如果它需要以注释来说明，那也值得将它提炼到独立函数中去。</p><p>条件表达式和循环常常也是提炼的信号。你可以使用分解条件表达式（260）处理条件表达式。对于庞大的 switch 语句，其中的每个分支都应该通过提炼函数（106）变成独立的函数调用。如果有多个 switch 语句基于同一个条件进行分支选择，就应该使用以多态取代条件表达式（272）。</p><p>至于循环，你应该将循环和循环内的代码提炼到一个独立的函数中。如果你发现提炼出的循环很难命名，可能是因为其中做了几件不同的事。如果是这种情况，请勇敢地使用拆分循环（227）将其拆分成各自独立的任务。</p><h2 id="3-4-过长参数列表（Long-Parameter-List）"><a href="#3-4-过长参数列表（Long-Parameter-List）" class="headerlink" title="3.4 过长参数列表（Long Parameter List）"></a>3.4 过长参数列表（Long Parameter List）</h2><p>刚开始学习编程的时候，老师教我们：把函数所需的所有东西都以参数的形式传递进去。这可以理解，因为除此之外就只能选择全局数据，而全局数据很快就会变成邪恶的东西。但过长的参数列表本身也经常令人迷惑。</p><p>如果可以向某个参数发起查询而获得另一个参数的值，那么就可以使用以查询取代参数（324）去掉这第二个参数。如果你发现自己正在从现有的数据结构中抽出很多数据项，就可以考虑使用保持对象完整（319）手法，直接传入原来的数据结构。如果有几项参数总是同时出现，可以用引入参数对象（140）将其合并成一个对象。如果某个参数被用作区分函数行为的标记（flag），可以使用移除标记参数（314）。</p><p>使用类可以有效地缩短参数列表。如果多个函数有同样的几个参数，引入一个类就尤为有意义。你可以使用函数组合成类（144），将这些共同的参数变成这个类的字段。如果戴上函数式编程的帽子，我们会说，这个重构过程创造了一组部分应用函数（partially applied function）。</p><h2 id="3-5-全局数据（Global-Data）"><a href="#3-5-全局数据（Global-Data）" class="headerlink" title="3.5 全局数据（Global Data）"></a>3.5 全局数据（Global Data）</h2><p>刚开始学软件开发时，我们就听说过关于全局数据的惊悚故事——它们是如何被来自地狱第四层的恶魔发明出来，胆敢使用它们的程序员如今在何处安息。就算这些烈焰与硫黄的故事不那么可信，全局数据仍然是最刺鼻的坏味道之一。全局数据的问题在于，从代码库的任何一个角落都可以修改它，而且没有任何机制可以探测出到底哪段代码做出了修改。一次又一次，全局数据造成了那些诡异的 bug，而问题的根源却在遥远的别处，想要找到出错的代码难于登天。全局数据最显而易见的形式就是全局变量，但类变量和单例（singleton）也有这样的问题。</p><p>首要的防御手段是封装变量（132），每当我们看到可能被各处的代码污染的数据，这总是我们应对的第一招。你把全局数据用一个函数包装起来，至少你就能看见修改它的地方，并开始控制对它的访问。随后，最好将这个函数（及其封装的数据）搬移到一个类或模块中，只允许模块内的代码使用它，从而尽量控制其作用域。</p><p>可以被修改的全局数据尤其可憎。如果能保证在程序启动之后就不再修改，这样的全局数据还算相对安全，不过得有编程语言提供这样的保证才行。</p><p>全局数据印证了帕拉塞尔斯的格言：良药与毒药的区别在于剂量。有少量的全局数据或许无妨，但数量越多，处理的难度就会指数上升。即便只是少量的数据，我们也愿意将它封装起来，这是在软件演进过程中应对变化的关键所在。</p><h2 id="3-6-可变数据（Mutable-Data）"><a href="#3-6-可变数据（Mutable-Data）" class="headerlink" title="3.6 可变数据（Mutable Data）"></a>3.6 可变数据（Mutable Data）</h2><p>对数据的修改经常导致出乎意料的结果和难以发现的 bug。我在一处更新数据，却没有意识到软件中的另一处期望着完全不同的数据，于是一个功能失效了——如果故障只在很罕见的情况下发生，要找出故障原因就会更加困难。因此，有一整个软件开发流派——函数式编程——完全建立在“数据永不改变”的概念基础上：如果要更新一个数据结构，就返回一份新的数据副本，旧的数据仍保持不变。</p><p>不过这样的编程语言仍然相对小众，大多数程序员使用的编程语言还是允许修改变量值的。即便如此，我们也不应该忽视不可变性带来的优势——仍然有很多办法可以用于约束对数据的更新，降低其风险。</p><p>可以用封装变量（132）来确保所有数据更新操作都通过很少几个函数来进行，使其更容易监控和演进。如果一个变量在不同时候被用于存储不同的东西，可以使用拆分变量（240）将其拆分为各自不同用途的变量，从而避免危险的更新操作。使用移动语句（223）和提炼函数（106）尽量把逻辑从处理更新操作的代码中搬移出来，将没有副作用的代码与执行数据更新操作的代码分开。设计 API 时，可以使用将查询函数和修改函数分离（306）确保调用者不会调到有副作用的代码，除非他们真的需要更新数据。我们还乐于尽早使用移除设值函数（331）——有时只是把设值函数的使用者找出来看看，就能帮我们发现缩小变量作用域的机会。</p><p>如果可变数据的值能在其他地方计算出来，这就是一个特别刺鼻的坏味道。它不仅会造成困扰、bug 和加班，而且毫无必要。消除这种坏味道的办法很简单，使用以查询取代派生变量（248）即可。</p><p>如果变量作用域只有几行代码，即使其中的数据可变，也不是什么大问题；但随着变量作用域的扩展，风险也随之增大。可以用函数组合成类（144）或者函数组合成变换（149）来限制需要对变量进行修改的代码量。如果一个变量在其内部结构中包含了数据，通常最好不要直接修改其中的数据，而是用将引用对象改为值对象（252）令其直接替换整个数据结构。</p><h2 id="3-7-发散式变化（Divergent-Change）"><a href="#3-7-发散式变化（Divergent-Change）" class="headerlink" title="3.7 发散式变化（Divergent Change）"></a>3.7 发散式变化（Divergent Change）</h2><p>我们希望软件能够更容易被修改——毕竟软件本来就该是“软”的。一旦需要修改，我们希望能够跳到系统的某一点，只在该处做修改。如果不能做到这一点，你就嗅出两种紧密相关的刺鼻味道中的一种了。</p><p>如果某个模块经常因为不同的原因在不同的方向上发生变化，发散式变化就出现了。当你看着一个类说：“呃，如果新加入一个数据库，我必须修改这 3 个函数；如果新出现一种金融工具，我必须修改这 4 个函数。”这就是发散式变化的征兆。数据库交互和金融逻辑处理是两个不同的上下文，将它们分别搬移到各自独立的模块中，能让程序变得更好：每当要对某个上下文做修改时，我们只需要理解这个上下文，而不必操心另一个。“每次只关心一个上下文”这一点一直很重要，在如今这个信息爆炸、脑容量不够用的年代就愈发紧要。当然，往往只有在加入新数据库或新金融工具后，你才能发现这个坏味道。在程序刚开发出来还在随着软件系统的能力不断演进时，上下文边界通常不是那么清晰。</p><p>如果发生变化的两个方向自然地形成了先后次序（比如说，先从数据库取出数据，再对其进行金融逻辑处理），就可以用拆分阶段（154）将两者分开，两者之间通过一个清晰的数据结构进行沟通。如果两个方向之间有更多的来回调用，就应该先创建适当的模块，然后用搬移函数（198）把处理逻辑分开。如果函数内部混合了两类处理逻辑，应该先用提炼函数（106）将其分开，然后再做搬移。如果模块是以类的形式定义的，就可以用提炼类（182）来做拆分。</p><h2 id="3-8-霰弹式修改（Shotgun-Surgery）"><a href="#3-8-霰弹式修改（Shotgun-Surgery）" class="headerlink" title="3.8 霰弹式修改（Shotgun Surgery）"></a>3.8 霰弹式修改（Shotgun Surgery）</h2><p>霰弹式修改类似于发散式变化，但又恰恰相反。如果每遇到某种变化，你都必须在许多不同的类内做出许多小修改，你所面临的坏味道就是霰弹式修改。如果需要修改的代码散布四处，你不但很难找到它们，也很容易错过某个重要的修改。</p><p>这种情况下，你应该使用搬移函数（198）和搬移字段（207）把所有需要修改的代码放进同一个模块里。如果有很多函数都在操作相似的数据，可以使用函数组合成类（144）。如果有些函数的功能是转化或者充实数据结构，可以使用函数组合成变换（149）。如果一些函数的输出可以组合后提供给一段专门使用这些计算结果的逻辑，这种时候常常用得上拆分阶段（154）。</p><p>面对霰弹式修改，一个常用的策略就是使用与内联（inline）相关的重构——如内联函数（115）或是内联类（186）——把本不该分散的逻辑拽回一处。完成内联之后，你可能会闻到过长函数或者过大的类的味道，不过你总可以用与提炼相关的重构手法将其拆解成更合理的小块。即便如此钟爱小型的函数和类，我们也并不担心在重构的过程中暂时创建一些较大的程序单元。</p><h2 id="3-9-依恋情结（Feature-Envy）"><a href="#3-9-依恋情结（Feature-Envy）" class="headerlink" title="3.9 依恋情结（Feature Envy）"></a>3.9 依恋情结（Feature Envy）</h2><p>所谓模块化，就是力求将代码分出区域，最大化区域内部的交互、最小化跨区域的交互。但有时你会发现，一个函数跟另一个模块中的函数或者数据交流格外频繁，远胜于在自己所处模块内部的交流，这就是依恋情结的典型情况。无数次经验里，我们看到某个函数为了计算某个值，从另一个对象那儿调用几乎半打的取值函数。疗法显而易见：这个函数想跟这些数据待在一起，那就使用搬移函数（198）把它移过去。有时候，函数中只有一部分受这种依恋之苦，这时候应该使用提炼函数（106）把这一部分提炼到独立的函数中，再使用搬移函数（198）带它去它的梦想家园。</p><p>当然，并非所有情况都这么简单。一个函数往往会用到几个模块的功能，那么它究竟该被置于何处呢？我们的原则是：判断哪个模块拥有的此函数使用的数据最多，然后就把这个函数和那些数据摆在一起。如果先以提炼函数（106）将这个函数分解为数个较小的函数并分别置放于不同地点，上述步骤也就比较容易完成了。</p><p>有几个复杂精巧的模式破坏了这条规则。说起这个话题，GoF[gof]的策略（Strategy）模式和访问者（Visitor）模式立刻跳入我的脑海，Kent Beck 的 Self Delegation 模式[Beck SBPP]也在此列。使用这些模式是为了对抗发散式变化这一坏味道。最根本的原则是：将总是一起变化的东西放在一块儿。数据和引用这些数据的行为总是一起变化的，但也有例外。如果例外出现，我们就搬移那些行为，保持变化只在一地发生。策略模式和和访问者模式使你得以轻松修改函数的行为，因为它们将少量需被覆写的行为隔离开来——当然也付出了“多一层间接性”的代价。</p><h2 id="3-10-数据泥团（Data-Clumps）"><a href="#3-10-数据泥团（Data-Clumps）" class="headerlink" title="3.10 数据泥团（Data Clumps）"></a>3.10 数据泥团（Data Clumps）</h2><p>数据项就像小孩子，喜欢成群结队地待在一块儿。你常常可以在很多地方看到相同的三四项数据：两个类中相同的字段、许多函数签名中相同的参数。这些总是绑在一起出现的数据真应该拥有属于它们自己的对象。首先请找出这些数据以字段形式出现的地方，运用提炼类（182）将它们提炼到一个独立对象中。然后将注意力转移到函数签名上，运用引入参数对象（140）或保持对象完整（319）为它瘦身。这么做的直接好处是可以将很多参数列表缩短，简化函数调用。是的，不必在意数据泥团只用上新对象的一部分字段，只要以新对象取代两个（或更多）字段，就值得这么做。</p><p>一个好的评判办法是：删掉众多数据中的一项。如果这么做，其他数据有没有因而失去意义？如果它们不再有意义，这就是一个明确信号：你应该为它们产生一个新对象。</p><p>我们在这里提倡新建一个类，而不是简单的记录结构，因为一旦拥有新的类，你就有机会让程序散发出一种芳香。得到新的类以后，你就可以着手寻找“依恋情结”，这可以帮你指出能够移至新类中的种种行为。这是一种强大的动力：有用的类被创建出来，大量的重复被消除，后续开发得以加速，原来的数据泥团终于在它们的小社会中充分发挥价值。</p><h2 id="3-11-基本类型偏执（Primitive-Obsession）"><a href="#3-11-基本类型偏执（Primitive-Obsession）" class="headerlink" title="3.11 基本类型偏执（Primitive Obsession）"></a>3.11 基本类型偏执（Primitive Obsession）</h2><p>大多数编程环境都大量使用基本类型，即整数、浮点数和字符串等。一些库会引入一些小对象，如日期。但我们发现一个很有趣的现象：很多程序员不愿意创建对自己的问题域有用的基本类型，如钱、坐标、范围等。于是，我们看到了把钱当作普通数字来计算的情况、计算物理量时无视单位（如把英寸与毫米相加）的情况以及大量类似 if (a &lt; upper &amp;&amp; a &gt; lower)这样的代码。</p><p>字符串是这种坏味道的最佳培养皿，比如，电话号码不只是一串字符。一个体面的类型，至少能包含一致的显示逻辑，在用户界面上需要显示时可以使用。“用字符串来代表类似这样的数据”是如此常见的臭味，以至于人们给这类变量专门起了一个名字，叫它们“类字符串类型”（stringly typed）变量。</p><p>你可以运用以对象取代基本类型（174）将原本单独存在的数据值替换为对象，从而走出传统的洞窟，进入炙手可热的对象世界。如果想要替换的数据值是控制条件行为的类型码，则可以运用以子类取代类型码（362）加上以多态取代条件表达式（272）的组合将它换掉。</p><p>如果你有一组总是同时出现的基本类型数据，这就是数据泥团的征兆，应该运用提炼类（182）和引入参数对象（140）来处理。</p><h2 id="3-12-重复的-switch-（Repeated-Switches）"><a href="#3-12-重复的-switch-（Repeated-Switches）" class="headerlink" title="3.12 重复的 switch （Repeated Switches）"></a>3.12 重复的 switch （Repeated Switches）</h2><p>如果你跟真正的面向对象布道者交谈，他们很快就会谈到 switch 语句的邪恶。在他们看来，任何 switch 语句都应该用以多态取代条件表达式（272）消除掉。我们甚至还听过这样的观点：所有条件逻辑都应该用多态取代，绝大多数 if 语句都应该被扫进历史的垃圾桶。</p><p>即便在不知天高地厚的青年时代，我们也从未无条件地反对条件语句。在本书第 1 版中，这种坏味道被称为“switch 语句”（Switch Statements），那是因为在 20 世纪 90 年代末期，程序员们太过于忽视多态的价值，我们希望矫枉过正。</p><p>如今的程序员已经更多地使用多态，switch 语句也不再像 15 年前那样有害无益，很多语言支持更复杂的 switch 语句，而不只是根据基本类型值来做条件判断。因此，我们现在更关注重复的 switch：在不同的地方反复使用同样的 switch 逻辑（可能是以 switch&#x2F;case 语句的形式，也可能是以连续的 if&#x2F;else 语句的形式）。重复的 switch 的问题在于：每当你想增加一个选择分支时，必须找到所有的 switch，并逐一更新。多态给了我们对抗这种黑暗力量的武器，使我们得到更优雅的代码库。</p><h2 id="3-13-循环语句（Loops）"><a href="#3-13-循环语句（Loops）" class="headerlink" title="3.13 循环语句（Loops）"></a>3.13 循环语句（Loops）</h2><p>从最早的编程语言开始，循环就一直是程序设计的核心要素。但我们感觉如今循环已经有点儿过时，就像喇叭裤和植绒壁纸那样。其实在撰写本书第 1 版的时候，我们就已经开始鄙视循环语句，但和当时的大多数编程语言一样，当时的 Java 还没有提供更好的替代品。如今，函数作为一等公民已经得到了广泛的支持，因此我们可以使用以管道取代循环（231）来让这些老古董退休。我们发现，管道操作（如 filter 和 map）可以帮助我们更快地看清被处理的元素以及处理它们的动作。</p><h2 id="3-14-冗赘的元素（Lazy-Element）"><a href="#3-14-冗赘的元素（Lazy-Element）" class="headerlink" title="3.14 冗赘的元素（Lazy Element）"></a>3.14 冗赘的元素（Lazy Element）</h2><p>程序元素（如类和函数）能给代码增加结构，从而支持变化、促进复用或者哪怕只是提供更好的名字也好，但有时我们真的不需要这层额外的结构。可能有这样一个函数，它的名字就跟实现代码看起来一模一样；也可能有这样一个类，根本就是一个简单的函数。这可能是因为，起初在编写这个函数时，程序员也许期望它将来有一天会变大、变复杂，但那一天从未到来；也可能是因为，这个类原本是有用的，但随着重构的进行越变越小，最后只剩了一个函数。不论上述哪一种原因，请让这样的程序元素庄严赴义吧。通常你只需要使用内联函数（115）或是内联类（186）。如果这个类处于一个继承体系中，可以使用折叠继承体系（380）。</p><h2 id="3-15-夸夸其谈通用性（Speculative-Generality）"><a href="#3-15-夸夸其谈通用性（Speculative-Generality）" class="headerlink" title="3.15 夸夸其谈通用性（Speculative Generality）"></a>3.15 夸夸其谈通用性（Speculative Generality）</h2><p>这个令我们十分敏感的坏味道，命名者是 Brian Foote。当有人说“噢，我想我们总有一天需要做这事”，并因而企图以各式各样的钩子和特殊情况来处理一些非必要的事情，这种坏味道就出现了。这么做的结果往往造成系统更难理解和维护。如果所有装置都会被用到，就值得那么做；如果用不到，就不值得。用不上的装置只会挡你的路，所以，把它搬开吧。</p><p>如果你的某个抽象类其实没有太大作用，请运用折叠继承体系（380）。不必要的委托可运用内联函数（115）和内联类（186）除掉。如果函数的某些参数未被用上，可以用改变函数声明（124）去掉这些参数。如果有并非真正需要、只是为不知远在何处的将来而塞进去的参数，也应该用改变函数声明（124）去掉。</p><p>如果函数或类的唯一用户是测试用例，这就飘出了坏味道“夸夸其谈通用性”。如果你发现这样的函数或类，可以先删掉测试用例，然后使用移除死代码（237）。</p><h2 id="3-16-临时字段（Temporary-Field）"><a href="#3-16-临时字段（Temporary-Field）" class="headerlink" title="3.16 临时字段（Temporary Field）"></a>3.16 临时字段（Temporary Field）</h2><p>有时你会看到这样的类：其内部某个字段仅为某种特定情况而设。这样的代码让人不易理解，因为你通常认为对象在所有时候都需要它的所有字段。在字段未被使用的情况下猜测当初设置它的目的，会让你发疯。</p><p>请使用提炼类（182）给这个可怜的孤儿创造一个家，然后用搬移函数（198）把所有和这些字段相关的代码都放进这个新家。也许你还可以使用引入特例（289）在“变量不合法”的情况下创建一个替代对象，从而避免写出条件式代码。</p><h2 id="3-17-过长的消息链（Message-Chains）"><a href="#3-17-过长的消息链（Message-Chains）" class="headerlink" title="3.17 过长的消息链（Message Chains）"></a>3.17 过长的消息链（Message Chains）</h2><p>如果你看到用户向一个对象请求另一个对象，然后再向后者请求另一个对象，然后再请求另一个对象……这就是消息链。在实际代码中你看到的可能是一长串取值函数或一长串临时变量。采取这种方式，意味客户端代码将与查找过程中的导航结构紧密耦合。一旦对象间的关系发生任何变化，客户端就不得不做出相应修改。</p><p>这时候应该使用隐藏委托关系（189）。你可以在消息链的不同位置采用这种重构手法。理论上，你可以重构消息链上的所有对象，但这么做就会把所有中间对象都变成“中间人”。通常更好的选择是：先观察消息链最终得到的对象是用来干什么的，看看能否以提炼函数（106）把使用该对象的代码提炼到一个独立的函数中，再运用搬移函数（198）把这个函数推入消息链。如果还有许多客户端代码需要访问链上的其他对象，同样添加一个函数来完成此事。</p><p>有些人把任何函数链都视为坏东西，我们不这样想。我们的冷静镇定是出了名的，起码在这件事上是这样的。</p><h2 id="3-18-中间人（Middle-Man）"><a href="#3-18-中间人（Middle-Man）" class="headerlink" title="3.18 中间人（Middle Man）"></a>3.18 中间人（Middle Man）</h2><p>对象的基本特征之一就是封装——对外部世界隐藏其内部细节。封装往往伴随着委托。比如，你问主管是否有时间参加一个会议，他就把这个消息“委托”给他的记事簿，然后才能回答你。很好，你没必要知道这位主管到底使用传统记事簿还是使用电子记事簿抑或是秘书来记录自己的约会。</p><p>但是人们可能过度运用委托。你也许会看到某个类的接口有一半的函数都委托给其他类，这样就是过度运用。这时应该使用移除中间人（192），直接和真正负责的对象打交道。如果这样“不干实事”的函数只有少数几个，可以运用内联函数（115）把它们放进调用端。如果这些中间人还有其他行为，可以运用以委托取代超类（399）或者以委托取代子类（381）把它变成真正的对象，这样你既可以扩展原对象的行为，又不必负担那么多的委托动作。</p><h2 id="3-19-内幕交易（Insider-Trading）"><a href="#3-19-内幕交易（Insider-Trading）" class="headerlink" title="3.19 内幕交易（Insider Trading）"></a>3.19 内幕交易（Insider Trading）</h2><p>软件开发者喜欢在模块之间建起高墙，极其反感在模块之间大量交换数据，因为这会增加模块间的耦合。在实际情况里，一定的数据交换不可避免，但我们必须尽量减少这种情况，并把这种交换都放到明面上来。</p><p>如果两个模块总是在咖啡机旁边窃窃私语，就应该用搬移函数（198）和搬移字段（207）减少它们的私下交流。如果两个模块有共同的兴趣，可以尝试再新建一个模块，把这些共用的数据放在一个管理良好的地方；或者用隐藏委托关系（189），把另一个模块变成两者的中介。</p><p>继承常会造成密谋，因为子类对超类的了解总是超过后者的主观愿望。如果你觉得该让这个孩子独立生活了，请运用以委托取代子类（381）或以委托取代超类（399）让它离开继承体系。</p><h2 id="3-20-过大的类（Large-Class）"><a href="#3-20-过大的类（Large-Class）" class="headerlink" title="3.20 过大的类（Large Class）"></a>3.20 过大的类（Large Class）</h2><p>如果想利用单个类做太多事情，其内往往就会出现太多字段。一旦如此，重复代码也就接踵而至了。</p><p>你可以运用提炼类（182）将几个变量一起提炼至新类内。提炼时应该选择类内彼此相关的变量，将它们放在一起。例如，depositAmount 和 depositCurrency 可能应该隶属同一个类。通常，如果类内的数个变量有着相同的前缀或后缀，这就意味着有机会把它们提炼到某个组件内。如果这个组件适合作为一个子类，你会发现提炼超类（375）或者以子类取代类型码（362）（其实就是提炼子类）往往比较简单。</p><p>有时候类并非在所有时刻都使用所有字段。若果真如此，你或许可以进行多次提炼。</p><p>和“太多实例变量”一样，类内如果有太多代码，也是代码重复、混乱并最终走向死亡的源头。最简单的解决方案（还记得吗，我们喜欢简单的解决方案）是把多余的东西消弭于类内部。如果有 5 个“百行函数”，它们之中很多代码都相同，那么或许你可以把它们变成 5 个“十行函数”和 10 个提炼出来的“双行函数”。</p><p>观察一个大类的使用者，经常能找到如何拆分类的线索。看看使用者是否只用到了这个类所有功能的一个子集，每个这样的子集都可能拆分成一个独立的类。一旦识别出一个合适的功能子集，就试用提炼类（182）、提炼超类（375）或是以子类取代类型码（362）将其拆分出来。</p><h2 id="3-21-异曲同工的类（Alternative-Classes-with-Different-Interfaces）"><a href="#3-21-异曲同工的类（Alternative-Classes-with-Different-Interfaces）" class="headerlink" title="3.21 异曲同工的类（Alternative Classes with Different Interfaces）"></a>3.21 异曲同工的类（Alternative Classes with Different Interfaces）</h2><p>使用类的好处之一就在于可以替换：今天用这个类，未来可以换成用另一个类。但只有当两个类的接口一致时，才能做这种替换。可以用改变函数声明（124）将函数签名变得一致。但这往往还不够，请反复运用搬移函数（198）将某些行为移入类中，直到两者的协议一致为止。如果搬移过程造成了重复代码，或许可运用提炼超类（375）补偿一下。</p><h2 id="3-22-纯数据类（Data-Class）"><a href="#3-22-纯数据类（Data-Class）" class="headerlink" title="3.22 纯数据类（Data Class）"></a>3.22 纯数据类（Data Class）</h2><p>所谓纯数据类是指：它们拥有一些字段，以及用于访问（读写）这些字段的函数，除此之外一无长物。这样的类只是一种不会说话的数据容器，它们几乎一定被其他类过分细琐地操控着。这些类早期可能拥有 public 字段，若果真如此，你应该在别人注意到它们之前，立刻运用封装记录（162）将它们封装起来。对于那些不该被其他类修改的字段，请运用移除设值函数（331）。</p><p>然后，找出这些取值&#x2F;设值函数被其他类调用的地点。尝试以搬移函数（198）把那些调用行为搬移到纯数据类里来。如果无法搬移整个函数，就运用提炼函数（106）产生一个可被搬移的函数。</p><p>纯数据类常常意味着行为被放在了错误的地方。也就是说，只要把处理数据的行为从客户端搬移到纯数据类里来，就能使情况大为改观。但也有例外情况，一个最好的例外情况就是，纯数据记录对象被用作函数调用的返回结果，比如使用拆分阶段（154）之后得到的中转数据结构就是这种情况。这种结果数据对象有一个关键的特征：它是不可修改的（至少在拆分阶段（154）的实际操作中是这样）。不可修改的字段无须封装，使用者可以直接通过字段取得数据，无须通过取值函数。</p><h2 id="3-23-被拒绝的遗赠（Refused-Bequest）"><a href="#3-23-被拒绝的遗赠（Refused-Bequest）" class="headerlink" title="3.23 被拒绝的遗赠（Refused Bequest）"></a>3.23 被拒绝的遗赠（Refused Bequest）</h2><p>子类应该继承超类的函数和数据。但如果它们不想或不需要继承，又该怎么办呢？它们得到所有礼物，却只从中挑选几样来玩！</p><p>按传统说法，这就意味着继承体系设计错误。你需要为这个子类新建一个兄弟类，再运用函数下移（359）和字段下移（361）把所有用不到的函数下推给那个兄弟。这样一来，超类就只持有所有子类共享的东西。你常常会听到这样的建议：所有超类都应该是抽象（abstract）的。</p><p>既然使用“传统说法”这个略带贬义的词，你就可以猜到，我们不建议你这么做，起码不建议你每次都这么做。我们经常利用继承来复用一些行为，并发现这可以很好地应用于日常工作。这也是一种坏味道，我们不否认，但气味通常并不强烈，所以我们说，如果“被拒绝的遗赠”正在引起困惑和问题，请遵循传统忠告。但不必认为你每次都得那么做。十有八九这种坏味道很淡，不值得理睬。</p><p>如果子类复用了超类的行为（实现），却又不愿意支持超类的接口，“被拒绝的遗赠”的坏味道就会变得很浓烈。拒绝继承超类的实现，这一点我们不介意；但如果拒绝支持超类的接口，这就难以接受了。既然不愿意支持超类的接口，就不要虚情假意地糊弄继承体系，应该运用以委托取代子类（381）或者以委托取代超类（399）彻底划清界限。</p><h2 id="3-24-注释（Comments）"><a href="#3-24-注释（Comments）" class="headerlink" title="3.24 注释（Comments）"></a>3.24 注释（Comments）</h2><p>别担心，我们并不是说你不该写注释。从嗅觉上说，注释不但不是一种坏味道，事实上它们还是一种香味呢。我们之所以要在这里提到注释，是因为人们常把它当作“除臭剂”来使用。常常会有这样的情况：你看到一段代码有着长长的注释，然后发现，这些注释之所以存在乃是因为代码很糟糕。这种情况的发生次数之多，实在令人吃惊。</p><p>注释可以带我们找到本章先前提到的各种坏味道。找到坏味道后，我们首先应该以各种重构手法把坏味道去除。完成之后我们常常会发现：注释已经变得多余了，因为代码已经清楚地说明了一切。</p><p>如果你需要注释来解释一块代码做了什么，试试提炼函数（106）；如果函数已经提炼出来，但还是需要注释来解释其行为，试试用改变函数声明（124）为它改名；如果你需要注释说明某些系统的需求规格，试试引入断言（302）。</p><blockquote><p><strong>Tip</strong><br>当你感觉需要撰写注释时，请先尝试重构，试着让所有注释都变得多余。</p></blockquote><p>如果你不知道该做什么，这才是注释的良好运用时机。除了用来记述将来的打算之外，注释还可以用来标记你并无十足把握的区域。你可以在注释里写下自己“为什么做某某事”。这类信息可以帮助将来的修改者，尤其是那些健忘的家伙。</p>]]></content>
    
    
    <categories>
      
      <category>重构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>重构</tag>
      
      <tag>架构</tag>
      
      <tag>设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker</title>
    <link href="/posts/14e7ef72/"/>
    <url>/posts/14e7ef72/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是-Docker"><a href="#什么是-Docker" class="headerlink" title="什么是 Docker"></a>什么是 Docker</h1><p><strong>Docker</strong> 使用 <code>Google</code> 公司推出的 <a href="https://golang.google.cn/">Go 语言</a> 进行开发实现，基于 <code>Linux</code> 内核的 <a href="https://zh.wikipedia.org/wiki/Cgroups">cgroup</a>，<a href="https://en.wikipedia.org/wiki/Linux_namespaces">namespace</a>，以及 <a href="https://docs.docker.com/storage/storagedriver/overlayfs-driver/">OverlayFS</a> 类的 <a href="https://en.wikipedia.org/wiki/Union_mount">Union FS</a> 等技术，对进程进行封装隔离，属于 <a href="https://en.wikipedia.org/wiki/Operating-system-level_virtualization">操作系统层面的虚拟化技术</a>。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151505744.png"></p><p><strong>Docker</strong> 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 <code>Docker</code> 技术比虚拟机技术更为轻便、快捷。</p><p>下面的图片比较了 <strong>Docker</strong> 和传统虚拟化方式的不同之处。传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151505428.png"></p><h1 id="为什么要用-Docker"><a href="#为什么要用-Docker" class="headerlink" title="为什么要用 Docker"></a>为什么要用 Docker</h1><h2 id="更高效的利用系统资源"><a href="#更高效的利用系统资源" class="headerlink" title="更高效的利用系统资源"></a>更高效的利用系统资源</h2><p>由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，<code>Docker</code> 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。</p><h2 id="更快速的启动时间"><a href="#更快速的启动时间" class="headerlink" title="更快速的启动时间"></a>更快速的启动时间</h2><p>传统的虚拟机技术启动应用服务往往需要数分钟，而 <code>Docker</code> 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。</p><h2 id="一致的运行环境"><a href="#一致的运行环境" class="headerlink" title="一致的运行环境"></a>一致的运行环境</h2><p>开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 <code>Docker</code> 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 <em>「这段代码在我机器上没问题啊」</em> 这类问题。</p><h2 id="持续交付和部署"><a href="#持续交付和部署" class="headerlink" title="持续交付和部署"></a>持续交付和部署</h2><p>对开发和运维（<a href="https://zh.wikipedia.org/wiki/DevOps">DevOps</a>）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。</p><p>使用 <code>Docker</code> 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 <a href="https://yeasy.gitbook.io/docker_practice/image/dockerfile">Dockerfile</a> 来进行镜像构建，并结合 <a href="https://en.wikipedia.org/wiki/Continuous_integration">持续集成(Continuous Integration)</a> 系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 <a href="https://en.wikipedia.org/wiki/Continuous_delivery">持续部署(Continuous Delivery&#x2F;Deployment)</a> 系统进行自动部署。</p><p>而且使用 <a href="https://yeasy.gitbook.io/docker_practice/image/build"><code>Dockerfile</code></a> 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。</p><h2 id="更轻松的迁移"><a href="#更轻松的迁移" class="headerlink" title="更轻松的迁移"></a>更轻松的迁移</h2><p>由于 <code>Docker</code> 确保了执行环境的一致性，使得应用的迁移更加容易。<code>Docker</code> 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。</p><h2 id="更轻松的维护和扩展"><a href="#更轻松的维护和扩展" class="headerlink" title="更轻松的维护和扩展"></a>更轻松的维护和扩展</h2><p><code>Docker</code> 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，<code>Docker</code> 团队同各个开源项目团队一起维护了一大批高质量的 <a href="https://hub.docker.com/search/?type=image&image_filter=official">官方镜像</a>，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。</p><h2 id="对比传统虚拟机总结"><a href="#对比传统虚拟机总结" class="headerlink" title="对比传统虚拟机总结"></a>对比传统虚拟机总结</h2><table><thead><tr><th>特性</th><th>容器</th><th>虚拟机</th></tr></thead><tbody><tr><td>启动</td><td>秒级</td><td>分钟级</td></tr><tr><td>硬盘使用</td><td>一般为 <code>MB</code></td><td>一般为 <code>GB</code></td></tr><tr><td>性能</td><td>接近原生</td><td>弱于</td></tr><tr><td>系统支持量</td><td>单机支持上千个容器</td><td>一般几十个</td></tr></tbody></table><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><strong>Docker</strong> 包括三个基本概念</p><ul><li><p><strong>镜像</strong>（<code>Image</code>）</p></li><li><p><strong>容器</strong>（<code>Container</code>）</p></li><li><p><strong>仓库</strong>（<code>Repository</code>）</p></li></ul><h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><p>我们都知道，操作系统分为 <strong>内核</strong> 和 <strong>用户空间</strong>。对于 <code>Linux</code> 而言，内核启动后，会挂载 <code>root</code> 文件系统为其提供用户空间支持。而 <strong>Docker 镜像</strong>（<code>Image</code>），就相当于是一个 <code>root</code> 文件系统。比如官方镜像 <code>ubuntu:18.04</code> 就包含了完整的一套 Ubuntu 18.04 最小系统的 <code>root</code> 文件系统。</p><p><strong>Docker 镜像</strong> 是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像 <strong>不包含</strong> 任何动态数据，其内容在构建之后也不会被改变。</p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>镜像（<code>Image</code>）和容器（<code>Container</code>）的关系，就像是面向对象程序设计中的 <code>类</code> 和 <code>实例</code> 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p><p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。因此容器可以拥有自己的 <code>root</code> 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学 Docker 时常常会混淆容器和虚拟机。</p><p>前面讲过镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为 <strong>容器存储层</strong>。</p><p>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</p><h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><p>镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry 就是这样的服务。</p><p>一个 <strong>Docker Registry</strong> 中可以包含多个 <strong>仓库</strong>（<code>Repository</code>）；每个仓库可以包含多个 <strong>标签</strong>（<code>Tag</code>）；每个标签对应一个镜像。</p><p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 <code>&lt;仓库名&gt;:&lt;标签&gt;</code> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 <code>latest</code> 作为默认标签。</p><p>以 <a href="https://hub.docker.com/_/ubuntu">Ubuntu 镜像</a> 为例，<code>ubuntu</code> 是仓库的名字，其内包含有不同的版本标签，如，<code>16.04</code>, <code>18.04</code>。我们可以通过 <code>ubuntu:16.04</code>，或者 <code>ubuntu:18.04</code> 来具体指定所需哪个版本的镜像。如果忽略了标签，比如 <code>ubuntu</code>，那将视为 <code>ubuntu:latest</code>。</p><p>仓库名经常以 <em>两段式路径</em> 形式出现，比如 <code>jwilder/nginx-proxy</code>，前者往往意味着 Docker Registry 多用户环境下的用户名，后者则往往是对应的软件名。但这并非绝对，取决于所使用的具体 Docker Registry 的软件或服务。</p><h3 id="Docker-Registry-公开服务"><a href="#Docker-Registry-公开服务" class="headerlink" title="Docker Registry 公开服务"></a>Docker Registry 公开服务</h3><p>Docker Registry 公开服务是开放给用户使用、允许用户管理镜像的 Registry 服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。</p><p>最常使用的 Registry 公开服务是官方的 <a href="https://hub.docker.com/">Docker Hub</a>，这也是默认的 Registry，并拥有大量的高质量的 <a href="https://hub.docker.com/search?q=&type=image&image_filter=official">官方镜像</a>。除此以外，还有 Red Hat 的 <a href="https://quay.io/repository/">Quay.io</a>；Google 的 <a href="https://cloud.google.com/container-registry/">Google Container Registry</a>，<a href="https://kubernetes.io/">Kubernetes</a> 的镜像使用的就是这个服务；代码托管平台 <a href="https://github.com/">GitHub</a> 推出的 <a href="https://docs.github.com/cn/packages/working-with-a-github-packages-registry/working-with-the-container-registry">ghcr.io</a>。</p><p>由于某些原因，在国内访问这些服务可能会比较慢。国内的一些云服务商提供了针对 Docker Hub 的镜像服务（<code>Registry Mirror</code>），这些镜像服务被称为 <strong>加速器</strong>。常见的有 <a href="https://www.aliyun.com/product/acr?source=5176.11533457&userCode=8lx5zmtu">阿里云加速器</a>、<a href="https://www.daocloud.io/mirror#accelerator-doc">DaoCloud 加速器</a> 等。使用加速器会直接从国内的地址下载 Docker Hub 的镜像，比直接从 Docker Hub 下载速度会提高很多。在 <a href="https://yeasy.gitbook.io/docker_practice/install/mirror">安装 Docker</a> 一节中有详细的配置方法。</p><p>国内也有一些云服务商提供类似于 Docker Hub 的公开服务。比如 <a href="https://c.163.com/hub#/m/library/">网易云镜像服务</a>、<a href="https://hub.daocloud.io/">DaoCloud 镜像市场</a>、<a href="https://www.aliyun.com/product/acr?source=5176.11533457&userCode=8lx5zmtu">阿里云镜像库</a> 等。</p><h3 id="私有Docker-Registry"><a href="#私有Docker-Registry" class="headerlink" title="私有Docker Registry"></a>私有Docker Registry</h3><p>除了使用公开服务外，用户还可以在本地搭建私有 Docker Registry。Docker 官方提供了 <a href="https://hub.docker.com/_/registry/">Docker Registry</a> 镜像，可以直接使用做为私有 Registry 服务。在 <a href="https://yeasy.gitbook.io/docker_practice/repository/registry">私有仓库</a> 一节中，会有进一步的搭建私有 Registry 服务的讲解。</p><p>开源的 Docker Registry 镜像只提供了 <a href="https://docs.docker.com/registry/spec/api/">Docker Registry API</a> 的服务端实现，足以支持 <code>docker</code> 命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。</p><p>除了官方的 Docker Registry 外，还有第三方软件实现了 Docker Registry API，甚至提供了用户界面以及一些高级功能。比如，<a href="https://github.com/goharbor/harbor">Harbor</a> 和 <a href="https://yeasy.gitbook.io/docker_practice/repository/nexus3_registry">Sonatype Nexus</a>。</p><h1 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h1><p>Docker 分为 <code>stable</code> <code>test</code> 和 <code>nightly</code> 三个更新频道。</p><p>官方网站上有各种环境下的 <a href="https://docs.docker.com/get-docker/">安装指南</a>，这里主要介绍 Docker 在 <code>Windows 10</code> 上的安装。</p><p><strong>手动下载安装</strong></p><p>点击以下 <a href="https://desktop.docker.com/win/main/amd64/Docker%20Desktop%20Installer.exe">链接</a> 下载 Docker Desktop for Windows。</p><p>下载好之后双击 <code>Docker Desktop Installer.exe</code> 开始安装。</p><p><strong>使用</strong> <a href="https://docs.microsoft.com/zh-cn/windows/package-manager/"><strong>winget</strong></a> <strong>安装</strong></p><p>复制</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">$ winget <span class="hljs-keyword">install</span> Docker.DockerDesktop<br></code></pre></td></tr></table></figure><h2 id="在-WSL2-运行-Docker"><a href="#在-WSL2-运行-Docker" class="headerlink" title="在 WSL2 运行 Docker"></a>在 WSL2 运行 Docker</h2><p>若你的 Windows 版本为 Windows 10 专业版或家庭版 v1903 及以上版本可以使用 WSL2 运行 Docker，具体请查看 <a href="https://docs.docker.com/docker-for-windows/wsl/">Docker Desktop WSL 2 backend</a>。</p><p>在 Windows 搜索栏输入 <strong>Docker</strong> 点击 <strong>Docker Desktop</strong> 开始运行。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151514091.png"></p><p>Docker 启动之后会在 Windows 任务栏出现鲸鱼图标。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151514645.png"></p><p>等待片刻，当鲸鱼图标静止时，说明 Docker 启动成功，之后你可以打开 PowerShell 使用 Docker。</p><h1 id="使用镜像"><a href="#使用镜像" class="headerlink" title="使用镜像"></a>使用镜像</h1><h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><p>之前提到过，<a href="https://hub.docker.com/search?q=&type=image">Docker Hub</a> 上有大量的高质量的镜像可以用，这里我们就说一下怎么获取这些镜像。</p><p>从 Docker 镜像仓库获取镜像的命令是 <code>docker pull</code>。其命令格式为：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">$ docker pull <span class="hljs-comment">[选项]</span> <span class="hljs-comment">[Docker Registry 地址<span class="hljs-comment">[:端口号]</span>/]</span>仓库名<span class="hljs-comment">[:标签]</span><br></code></pre></td></tr></table></figure><p>具体的选项可以通过 <code>docker pull --help</code> 命令看到，这里我们说一下镜像名称的格式。</p><ul><li>Docker 镜像仓库地址：地址的格式一般是 <code>&lt;域名/IP&gt;[:端口号]</code>。默认地址是 Docker Hub(<code>docker.io</code>)。</li><li>仓库名：如之前所说，这里的仓库名是两段式名称，即 <code>&lt;用户名&gt;/&lt;软件名&gt;</code>。对于 Docker Hub，如果不给出用户名，则默认为 <code>library</code>，也就是官方镜像。</li></ul><p>比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker pull ubuntu:18.04<br><br>18.04: Pulling from library/ubuntu<br>92dc2a97ff99: Pull complete<br>be13a9d27eb8: Pull complete<br>c8299583700a: Pull complete<br>Digest: sha256:4bc3ae6596938cb0d9e5ac51a1152ec9dcac2a1c50829c74abd9c4361e321b26<br>Status: Downloaded newer image <span class="hljs-keyword">for</span> ubuntu:18.04<br>docker.io/library/ubuntu:18.04<br></code></pre></td></tr></table></figure><p>上面的命令中没有给出 Docker 镜像仓库地址，因此将会从 Docker Hub （<code>docker.io</code>）获取镜像。而镜像名称是 <code>ubuntu:18.04</code>，因此将会获取官方镜像 <code>library/ubuntu</code> 仓库中标签为 <code>18.04</code> 的镜像。<code>docker pull</code> 命令的输出结果最后一行给出了镜像的完整名称，即： <code>docker.io/library/ubuntu:18.04</code>。</p><p>从下载过程中可以看到我们之前提及的分层存储的概念，镜像是由多层存储所构成。下载也是一层层的去下载，并非单一文件。下载过程中给出了每一层的 ID 的前 12 位。并且下载结束后，给出该镜像完整的 <code>sha256</code> 的摘要，以确保下载一致性。</p><p>在使用上面命令的时候，你可能会发现，你所看到的层 ID 以及 <code>sha256</code> 的摘要和这里的不一样。这是因为官方镜像是一直在维护的，有任何新的 bug，或者版本更新，都会进行修复再以原来的标签发布，这样可以确保任何使用这个标签的用户可以获得更安全、更稳定的镜像。</p><p>如果从 Docker Hub 下载镜像非常缓慢，可以使用镜像加速器 配置加速器。</p><h2 id="运行镜像"><a href="#运行镜像" class="headerlink" title="运行镜像"></a>运行镜像</h2><p>有了镜像后，我们就能够以这个镜像为基础启动并运行一个容器。以上面的 <code>ubuntu:18.04</code> 为例，如果我们打算启动里面的 <code>bash</code> 并且进行交互式操作的话，可以执行下面的命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -it --<span class="hljs-built_in">rm</span> ubuntu:18.04 bash<br><br>root@e7009c6ce357:/<span class="hljs-comment"># cat /etc/os-release</span><br>NAME=<span class="hljs-string">&quot;Ubuntu&quot;</span><br>VERSION=<span class="hljs-string">&quot;18.04.1 LTS (Bionic Beaver)&quot;</span><br>ID=ubuntu<br>ID_LIKE=debian<br>PRETTY_NAME=<span class="hljs-string">&quot;Ubuntu 18.04.1 LTS&quot;</span><br>VERSION_ID=<span class="hljs-string">&quot;18.04&quot;</span><br>HOME_URL=<span class="hljs-string">&quot;https://www.ubuntu.com/&quot;</span><br>SUPPORT_URL=<span class="hljs-string">&quot;https://help.ubuntu.com/&quot;</span><br>BUG_REPORT_URL=<span class="hljs-string">&quot;https://bugs.launchpad.net/ubuntu/&quot;</span><br>PRIVACY_POLICY_URL=<span class="hljs-string">&quot;https://www.ubuntu.com/legal/terms-and-policies/privacy-policy&quot;</span><br>VERSION_CODENAME=bionic<br>UBUNTU_CODENAME=bionic<br></code></pre></td></tr></table></figure><p><code>docker run</code> 就是运行容器的命令，这里简要的说明一下上面用到的参数。</p><ul><li><code>-it</code>：这是两个参数，一个是 <code>-i</code>：交互式操作，一个是 <code>-t</code> 终端。我们这里打算进入 <code>bash</code> 执行一些命令并查看返回结果，因此我们需要交互式终端。</li><li><code>--rm</code>：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 <code>docker rm</code>。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 <code>--rm</code> 可以避免浪费空间。</li><li><code>ubuntu:18.04</code>：这是指用 <code>ubuntu:18.04</code> 镜像为基础来启动容器。</li><li><code>bash</code>：放在镜像名后的是 <strong>命令</strong>，这里我们希望有个交互式 Shell，因此用的是 <code>bash</code>。</li></ul><p>进入容器后，我们可以在 Shell 下操作，执行任何所需的命令。这里，我们执行了 <code>cat /etc/os-release</code>，这是 Linux 常用的查看当前系统版本的命令，从返回的结果可以看到容器内是 <code>Ubuntu 18.04.1 LTS</code> 系统。</p><p>最后通过 <code>exit</code> 退出了这个容器。</p><h2 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h2><p>要想列出已经下载下来的镜像，可以使用 <code>docker image ls</code> 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker image <span class="hljs-built_in">ls</span><br><br>REPOSITORY           TAG                 IMAGE ID            CREATED             SIZE<br>redis                latest              5f515359c7f8        5 days ago          183 MB<br>nginx                latest              05a60462f8ba        5 days ago          181 MB<br>mongo                3.2                 fe9198c04d62        5 days ago          342 MB<br>&lt;none&gt;               &lt;none&gt;              00285df0df87        5 days ago          342 MB<br>ubuntu               18.04               329ed837d508        3 days ago          63.3MB<br>ubuntu               bionic              329ed837d508        3 days ago          63.3MB<br></code></pre></td></tr></table></figure><p>列表包含了 <code>仓库名</code>、<code>标签</code>、<code>镜像 ID</code>、<code>创建时间</code> 以及 <code>所占用的空间</code>。</p><p>其中仓库名、标签在之前的基础概念章节已经介绍过了。<strong>镜像 ID</strong> 则是镜像的唯一标识，一个镜像可以对应多个 <strong>标签</strong>。因此，在上面的例子中，我们可以看到 <code>ubuntu:18.04</code> 和 <code>ubuntu:bionic</code> 拥有相同的 ID，因为它们对应的是同一个镜像。</p><h2 id="删除本地镜像"><a href="#删除本地镜像" class="headerlink" title="删除本地镜像"></a>删除本地镜像</h2><p>如果要删除本地的镜像，可以使用 <code>docker image rm</code> 命令，其格式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker image <span class="hljs-built_in">rm</span> [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]<br></code></pre></td></tr></table></figure><p><strong>用 ID、镜像名、摘要删除镜像</strong></p><p>其中，<code>&lt;镜像&gt;</code> 可以是 <code>镜像短 ID</code>、<code>镜像长 ID</code>、<code>镜像名</code> 或者 <code>镜像摘要</code>。</p><p>比如我们有这么一些镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker image <span class="hljs-built_in">ls</span><br>REPOSITORY                  TAG                 IMAGE ID            CREATED             SIZE<br>centos                      latest              0584b3d2cf6d        3 weeks ago         196.5 MB<br>redis                       alpine              501ad78535f0        3 weeks ago         21.03 MB<br>docker                      latest              cf693ec9b5c7        3 weeks ago         105.1 MB<br>nginx                       latest              e43d811ce2f4        5 weeks ago         181.5 MB<br></code></pre></td></tr></table></figure><p>我们可以用镜像的完整 ID，也称为 <code>长 ID</code>，来删除镜像。使用脚本的时候可能会用长 ID，但是人工输入就太累了，所以更多的时候是用 <code>短 ID</code> 来删除镜像。<code>docker image ls</code> 默认列出的就已经是短 ID 了，一般取前3个字符以上，只要足够区分于别的镜像就可以了。</p><p>比如这里，如果我们要删除 <code>redis:alpine</code> 镜像，可以执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker image <span class="hljs-built_in">rm</span> 501<br><br>Untagged: redis:alpine<br>Untagged: redis@sha256:f1ed3708f538b537eb9c2a7dd50dc90a706f7debd7e1196c9264edeea521a86d<br>Deleted: sha256:501ad78535f015d88872e13fa87a828425117e3d28075d0c117932b05bf189b7<br>Deleted: sha256:96167737e29ca8e9d74982ef2a0dda76ed7b430da55e321c071f0dbff8c2899b<br>Deleted: sha256:32770d1dcf835f192cafd6b9263b7b597a1778a403a109e2cc2ee866f74adf23<br>Deleted: sha256:127227698ad74a5846ff5153475e03439d96d4b1c7f2a449c7a826ef74a2d2fa<br>Deleted: sha256:1333ecc582459bac54e1437335c0816bc17634e131ea0cc48daa27d32c75eab3<br>Deleted: sha256:4fc455b921edf9c4aea207c51ab39b10b06540c8b4825ba57b3feed1668fa7c7<br></code></pre></td></tr></table></figure><p>我们也可以用<code>镜像名</code>，也就是 <code>&lt;仓库名&gt;:&lt;标签&gt;</code>，来删除镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker image <span class="hljs-built_in">rm</span> centos<br><br>Untagged: centos:latest<br>Untagged: centos@sha256:b2f9d1c0ff5f87a4743104d099a3d561002ac500db1b9bfa02a783a46e0d366c<br>Deleted: sha256:0584b3d2cf6d235ee310cf14b54667d889887b838d3f3d3033acd70fc3c48b8a<br>Deleted: sha256:97ca462ad9eeae25941546209454496e1d66749d53dfa2ee32bf1faabd239d38<br></code></pre></td></tr></table></figure><p>当然，更精确的是使用 <code>镜像摘要</code> 删除镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker image <span class="hljs-built_in">ls</span> --digests<br>REPOSITORY                  TAG                 DIGEST                                                                    IMAGE ID            CREATED             SIZE<br>node                        slim                sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228   6e0c4c8e3913        3 weeks ago         214 MB<br><br>$ docker image <span class="hljs-built_in">rm</span> node@sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228<br>Untagged: node@sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228<br></code></pre></td></tr></table></figure><h2 id="Untagged-和-Deleted"><a href="#Untagged-和-Deleted" class="headerlink" title="Untagged 和 Deleted"></a>Untagged 和 Deleted</h2><p>如果观察上面这几个命令的运行输出信息的话，你会注意到删除行为分为两类，一类是 <code>Untagged</code>，另一类是 <code>Deleted</code>。我们之前介绍过，镜像的唯一标识是其 ID 和摘要，而一个镜像可以有多个标签。</p><p>因此当我们使用上面命令删除镜像的时候，实际上是在要求删除某个标签的镜像。所以首先需要做的是将满足我们要求的所有镜像标签都取消，这就是我们看到的 <code>Untagged</code> 的信息。因为一个镜像可以对应多个标签，因此当我们删除了所指定的标签后，可能还有别的标签指向了这个镜像，如果是这种情况，那么 <code>Delete</code> 行为就不会发生。所以并非所有的 <code>docker image rm</code> 都会产生删除镜像的行为，有可能仅仅是取消了某个标签而已。</p><p>当该镜像所有的标签都被取消了，该镜像很可能会失去了存在的意义，因此会触发删除行为。镜像是多层存储结构，因此在删除的时候也是从上层向基础层方向依次进行判断删除。镜像的多层结构让镜像复用变得非常容易，因此很有可能某个其它镜像正依赖于当前镜像的某一层。这种情况，依旧不会触发删除该层的行为。直到没有任何层依赖当前层时，才会真实的删除当前层。这就是为什么，有时候会奇怪，为什么明明没有别的标签指向这个镜像，但是它还是存在的原因，也是为什么有时候会发现所删除的层数和自己 <code>docker pull</code> 看到的层数不一样的原因。</p><h2 id="使用Dockerfile定制镜像"><a href="#使用Dockerfile定制镜像" class="headerlink" title="使用Dockerfile定制镜像"></a>使用Dockerfile定制镜像</h2><p>镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。</p><p>Dockerfile 是一个文本文件，其内包含了一条条的 **指令(Instruction)**，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p><p>以定制 <code>nginx</code> 镜像为例，这次我们使用 Dockerfile 来定制。</p><p>在一个空白目录中，建立一个文本文件，并命名为 <code>Dockerfile</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">mkdir</span> mynginx<br>$ <span class="hljs-built_in">cd</span> mynginx<br>$ <span class="hljs-built_in">touch</span> Dockerfile<br></code></pre></td></tr></table></figure><p>其内容为：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Dockerfile"><span class="hljs-keyword">FROM</span> nginx<br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27;</span> &gt; /usr/share/nginx/html/index.html</span><br></code></pre></td></tr></table></figure><p>这个 Dockerfile 很简单，一共就两行。涉及到了两条指令，<code>FROM</code> 和 <code>RUN</code>。</p><h3 id="FROM指定基础镜像"><a href="#FROM指定基础镜像" class="headerlink" title="FROM指定基础镜像"></a>FROM指定基础镜像</h3><p>所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。就像我们之前运行了一个 <code>nginx</code> 镜像的容器，再进行修改一样，基础镜像是必须指定的。而 <code>FROM</code> 就是指定 <strong>基础镜像</strong>，因此一个 <code>Dockerfile</code> 中 <code>FROM</code> 是必备的指令，并且必须是第一条指令。</p><p>在 <a href="https://hub.docker.com/search?q=&type=image&image_filter=official">Docker Hub</a> 上有非常多的高质量的官方镜像，有可以直接拿来使用的服务类的镜像，如 <a href="https://hub.docker.com/_/nginx/"><code>nginx</code></a>、<a href="https://hub.docker.com/_/redis/"><code>redis</code></a>、<a href="https://hub.docker.com/_/mongo/"><code>mongo</code></a>、<a href="https://hub.docker.com/_/mysql/"><code>mysql</code></a>、<a href="https://hub.docker.com/_/httpd/"><code>httpd</code></a>、<a href="https://hub.docker.com/_/php/"><code>php</code></a>、<a href="https://hub.docker.com/_/tomcat/"><code>tomcat</code></a> 等；也有一些方便开发、构建、运行各种语言应用的镜像，如 <a href="https://hub.docker.com/_/node"><code>node</code></a>、<a href="https://hub.docker.com/_/openjdk/"><code>openjdk</code></a>、<a href="https://hub.docker.com/_/python/"><code>python</code></a>、<a href="https://hub.docker.com/_/ruby/"><code>ruby</code></a>、<a href="https://hub.docker.com/_/golang/"><code>golang</code></a> 等。可以在其中寻找一个最符合我们最终目标的镜像为基础镜像进行定制。</p><h3 id="RUN执行命令"><a href="#RUN执行命令" class="headerlink" title="RUN执行命令"></a>RUN执行命令</h3><p><code>RUN</code> 指令是用来执行命令行命令的。由于命令行的强大能力，<code>RUN</code> 指令在定制镜像时是最常用的指令之一。其格式有两种：</p><ul><li><em>shell</em> 格式：<code>RUN &lt;命令&gt;</code>，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 <code>RUN</code> 指令就是这种格式。</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">RUN echo <span class="hljs-string">&#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27;</span> &gt; <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/nginx/</span>html/index.html<br></code></pre></td></tr></table></figure><ul><li><em>exec</em> 格式：<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code>，这更像是函数调用中的格式。</li></ul><p>既然 <code>RUN</code> 就像 Shell 脚本一样可以执行命令，那么我们是否就可以像 Shell 脚本一样把每个命令对应一个 RUN 呢？比如这样：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Dockerfile"><span class="hljs-keyword">FROM</span> debian:stretch<br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get update</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get install -y gcc libc6-dev make wget</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> wget -O redis.tar.gz <span class="hljs-string">&quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span></span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">mkdir</span> -p /usr/src/redis</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> make -C /usr/src/redis</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> make -C /usr/src/redis install</span><br></code></pre></td></tr></table></figure><p>之前说过，Dockerfile 中每一个指令都会建立一层，<code>RUN</code> 也不例外。每一个 <code>RUN</code> 的行为，就和刚才我们手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，<code>commit</code> 这一层的修改，构成新的镜像。</p><p>上面的这种写法，创建了 7 层镜像。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。 这是很多初学 Docker 的人常犯的一个错误。</p><p><em>Union FS 是有最大层数限制的，比如 AUFS，曾经是最大不得超过 42 层，现在是不得超过 127 层。</em></p><p>上面的 <code>Dockerfile</code> 正确的写法应该是这样：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Dockerfile"><span class="hljs-keyword">FROM</span> debian:stretch<br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">set</span> -x; buildDeps=<span class="hljs-string">&#x27;gcc libc6-dev make wget&#x27;</span> \</span><br><span class="language-bash">    &amp;&amp; apt-get update \</span><br><span class="language-bash">    &amp;&amp; apt-get install -y <span class="hljs-variable">$buildDeps</span> \</span><br><span class="language-bash">    &amp;&amp; wget -O redis.tar.gz <span class="hljs-string">&quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span> \</span><br><span class="language-bash">    &amp;&amp; <span class="hljs-built_in">mkdir</span> -p /usr/src/redis \</span><br><span class="language-bash">    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \</span><br><span class="language-bash">    &amp;&amp; make -C /usr/src/redis \</span><br><span class="language-bash">    &amp;&amp; make -C /usr/src/redis install \</span><br><span class="language-bash">    &amp;&amp; <span class="hljs-built_in">rm</span> -rf /var/lib/apt/lists/* \</span><br><span class="language-bash">    &amp;&amp; <span class="hljs-built_in">rm</span> redis.tar.gz \</span><br><span class="language-bash">    &amp;&amp; <span class="hljs-built_in">rm</span> -r /usr/src/redis \</span><br><span class="language-bash">    &amp;&amp; apt-get purge -y --auto-remove <span class="hljs-variable">$buildDeps</span></span><br></code></pre></td></tr></table></figure><p>首先，之前所有的命令只有一个目的，就是编译、安装 redis 可执行文件。因此没有必要建立很多层，这只是一层的事情。因此，这里没有使用很多个 <code>RUN</code> 一一对应不同的命令，而是仅仅使用一个 <code>RUN</code> 指令，并使用 <code>&amp;&amp;</code> 将各个所需命令串联起来。将之前的 7 层，简化为了 1 层。在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建。</p><p>并且，这里为了格式化还进行了换行。Dockerfile 支持 Shell 类的行尾添加 <code>\</code> 的命令换行方式，以及行首 <code>#</code> 进行注释的格式。良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。</p><p>此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 <code>apt</code> 缓存文件。这是很重要的一步，我们之前说过，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。</p><h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><p>回到之前定制的 nginx 镜像的 Dockerfile 来。现在我们明白了这个 Dockerfile 的内容，那么让我们来构建这个镜像吧。</p><p>在 <code>Dockerfile</code> 文件所在目录执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker build -t nginx:v3 .<br>Sending build context to Docker daemon 2.048 kB<br>Step 1 : FROM nginx<br> ---&gt; e43d811ce2f4<br>Step 2 : RUN <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27;</span> &gt; /usr/share/nginx/html/index.html<br> ---&gt; Running <span class="hljs-keyword">in</span> 9cdc27646c7b<br> ---&gt; 44aa4490ce2c<br>Removing intermediate container 9cdc27646c7b<br>Successfully built 44aa4490ce2c<br></code></pre></td></tr></table></figure><p>从命令的输出结果中，我们可以清晰的看到镜像的构建过程。在 <code>Step 2</code> 中，如同我们之前所说的那样，<code>RUN</code> 指令启动了一个容器 <code>9cdc27646c7b</code>，执行了所要求的命令，并最后提交了这一层 <code>44aa4490ce2c</code>，随后删除了所用到的这个容器 <code>9cdc27646c7b</code>。</p><p>这里我们使用了 <code>docker build</code> 命令进行镜像构建。其格式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker build [选项] &lt;上下文路径/URL/-&gt;<br></code></pre></td></tr></table></figure><h3 id="镜像构建上下文"><a href="#镜像构建上下文" class="headerlink" title="镜像构建上下文"></a>镜像构建上下文</h3><p>如果注意，会看到 <code>docker build</code> 命令最后有一个 <code>.</code>。<code>.</code> 表示当前目录，而 <code>Dockerfile</code> 就在当前目录，因此不少初学者以为这个路径是在指定 <code>Dockerfile</code> 所在路径，这么理解其实是不准确的。如果对应上面的命令格式，你可能会发现，这是在指定 <strong>上下文路径</strong>。那么什么是上下文呢？</p><p>首先我们要理解 <code>docker build</code> 的工作原理。Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。Docker 的引擎提供了一组 REST API，被称为 <a href="https://docs.docker.com/develop/sdk/">Docker Remote API</a>，而如 <code>docker</code> 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 <code>docker</code> 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C&#x2F;S 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。</p><p>当我们进行镜像构建的时候，并非所有定制都会通过 <code>RUN</code> 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 <code>COPY</code> 指令、<code>ADD</code> 指令等。而 <code>docker build</code> 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种客户端&#x2F;服务端的架构中，如何才能让服务端获得本地文件呢？</p><p>这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，<code>docker build</code> 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p><h2 id="其他制作镜像的方式"><a href="#其他制作镜像的方式" class="headerlink" title="其他制作镜像的方式"></a>其他制作镜像的方式</h2><p>Docker 还提供了 <code>docker save</code> 和 <code>docker load</code> 命令，用以将镜像保存为一个文件，然后传输到另一个位置上，再加载进来。这是在没有 Docker Registry 时的做法，现在已经不推荐，镜像迁移应该直接使用 Docker Registry，无论是直接使用 Docker Hub 还是使用内网私有 Registry 都可以。</p><p>使用 <code>docker save</code> 命令可以将镜像保存为归档文件。</p><p>比如我们希望保存这个 <code>alpine</code> 镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker image <span class="hljs-built_in">ls</span> alpine<br>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE<br>alpine              latest              baa5d63471ea        5 weeks ago         4.803 MB<br></code></pre></td></tr></table></figure><p>保存镜像的命令为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker save alpine -o filename<br>$ file filename<br>filename: POSIX tar archive<br></code></pre></td></tr></table></figure><p>这里的 filename 可以为任意名称甚至任意后缀名，但文件的本质都是归档文件</p><p>若使用 <code>gzip</code> 压缩：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker save alpine | gzip &gt; alpine-latest.tar.gz<br></code></pre></td></tr></table></figure><p>然后我们将 <code>alpine-latest.tar.gz</code> 文件复制到了到了另一个机器上，可以用下面这个命令加载镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker load -i alpine-latest.tar.gz<br>Loaded image: alpine:latest<br></code></pre></td></tr></table></figure><h1 id="操作容器"><a href="#操作容器" class="headerlink" title="操作容器"></a>操作容器</h1><p>容器是 Docker 又一核心概念。</p><p>简单的说，容器是独立运行的一个或一组应用，以及它们的运行态环境。对应的，虚拟机可以理解为模拟运行的一整套操作系统（提供了运行态环境和其他系统环境）和跑在上面的应用。</p><p>具体介绍如何来管理一个容器，包括创建、启动和停止等。</p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（<code>exited</code>）的容器重新启动。</p><p>因为 Docker 的容器实在太轻量级了，很多时候用户都是随时删除和新创建容器。</p><h3 id="新建并启动"><a href="#新建并启动" class="headerlink" title="新建并启动"></a>新建并启动</h3><p>所需要的命令主要为 <code>docker run</code>。</p><p>例如，下面的命令输出一个 “Hello World”，之后终止容器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run ubuntu:18.04 /bin/echo <span class="hljs-string">&#x27;Hello world&#x27;</span><br>Hello world<br></code></pre></td></tr></table></figure><p>下面的命令则启动一个 bash 终端，允许用户进行交互。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -t -i ubuntu:18.04 /bin/bash<br>root@af8bae53bdd3:/<span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure><p>其中，<code>-t</code> 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， <code>-i</code> 则让容器的标准输入保持打开。</p><p>在交互模式下，用户可以通过所创建的终端来输入命令，例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@af8bae53bdd3:/<span class="hljs-comment"># pwd</span><br>/<br>root@af8bae53bdd3:/<span class="hljs-comment"># ls</span><br>bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var<br></code></pre></td></tr></table></figure><p>当利用 <code>docker run</code> 来创建容器时，Docker 在后台运行的标准操作包括：</p><ul><li>检查本地是否存在指定的镜像，不存在就从 <a href="https://yeasy.gitbook.io/docker_practice/repository">registry</a> 下载</li><li>利用镜像创建并启动一个容器</li><li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li><li>从地址池配置一个 ip 地址给容器</li><li>执行用户指定的应用程序</li><li>执行完毕后容器被终止</li></ul><h3 id="启动已终止容器"><a href="#启动已终止容器" class="headerlink" title="启动已终止容器"></a>启动已终止容器</h3><p>可以利用 <code>docker container start</code> 命令，直接将一个已经终止（<code>exited</code>）的容器启动运行。</p><p>容器的核心为所执行的应用程序，所需要的资源都是应用程序运行所必需的。除此之外，并没有其它的资源。可以在伪终端中利用 <code>ps</code> 或 <code>top</code> 来查看进程信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@ba267838cc1b:/<span class="hljs-comment"># ps</span><br>  PID TTY          TIME CMD<br>    1 ?        00:00:00 bash<br>   11 ?        00:00:00 ps<br></code></pre></td></tr></table></figure><p>可见，容器中仅运行了指定的 bash 应用。这种特点使得 Docker 对资源的利用率极高，是货真价实的轻量级虚拟化。</p><h2 id="守护态运行"><a href="#守护态运行" class="headerlink" title="守护态运行"></a>守护态运行</h2><p>多的时候，需要让 Docker 在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 <code>-d</code> 参数来实现。</p><p>下面举两个例子来说明一下。</p><p>如果不使用 <code>-d</code> 参数运行容器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run ubuntu:18.04 /bin/sh -c <span class="hljs-string">&quot;while true; do echo hello world; sleep 1; done&quot;</span><br>hello world<br>hello world<br>hello world<br>hello world<br></code></pre></td></tr></table></figure><p>容器会把输出的结果 (STDOUT) 打印到宿主机上面</p><p>如果使用了 <code>-d</code> 参数运行容器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -d ubuntu:18.04 /bin/sh -c <span class="hljs-string">&quot;while true; do echo hello world; sleep 1; done&quot;</span><br>77b2dc01fe0f3f1265df143181e7b9af5e05279a884f4776ee75350ea9d8017a<br></code></pre></td></tr></table></figure><p>此时容器会在后台运行并不会把输出的结果 (STDOUT) 打印到宿主机上面(输出结果可以用 <code>docker logs</code> 查看)。</p><p><strong>注：</strong> 容器是否会长久运行，是和 <code>docker run</code> 指定的命令有关，和 <code>-d</code> 参数无关。</p><p>使用 <code>-d</code> 参数启动后会返回一个唯一的 id，也可以通过 <code>docker container ls</code> 命令来查看容器信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container <span class="hljs-built_in">ls</span><br>CONTAINER ID  IMAGE         COMMAND               CREATED        STATUS       PORTS NAMES<br>77b2dc01fe0f  ubuntu:18.04  /bin/sh -c <span class="hljs-string">&#x27;while tr  2 minutes ago  Up 1 minute        agitated_wright</span><br></code></pre></td></tr></table></figure><p>要获取容器的输出信息，可以通过 <code>docker container logs</code> 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container logs [container ID or NAMES]<br>hello world<br>hello world<br>hello world<br>. . .<br></code></pre></td></tr></table></figure><h2 id="终止"><a href="#终止" class="headerlink" title="终止"></a>终止</h2><p>可以使用 <code>docker container stop</code> 来终止一个运行中的容器。</p><p>此外，当 Docker 容器中指定的应用终结时，容器也自动终止。</p><p>例如对于上一章节中只启动了一个终端的容器，用户通过 <code>exit</code> 命令或 <code>Ctrl+d</code> 来退出终端时，所创建的容器立刻终止。</p><p>终止状态的容器可以用 <code>docker container ls -a</code> 命令看到。例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container <span class="hljs-built_in">ls</span> -a<br>CONTAINER ID        IMAGE                    COMMAND                CREATED             STATUS                          PORTS               NAMES<br>ba267838cc1b        ubuntu:18.04             <span class="hljs-string">&quot;/bin/bash&quot;</span>            30 minutes ago      Exited (0) About a minute ago                       trusting_newton<br></code></pre></td></tr></table></figure><p>处于终止状态的容器，可以通过 <code>docker container start</code> 命令来重新启动。</p><p>此外，<code>docker container restart</code> 命令会将一个运行态的容器终止，然后再重新启动它。</p><h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><p>在使用 <code>-d</code> 参数时，容器启动后会进入后台。</p><p>某些时候需要进入容器进行操作，包括使用 <code>docker attach</code> 命令或 <code>docker exec</code> 命令，推荐大家使用 <code>docker exec</code> 命令，原因会在下面说明。</p><h3 id="attach"><a href="#attach" class="headerlink" title="attach"></a>attach</h3><p>下面示例如何使用 <code>docker attach</code> 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -dit ubuntu<br>243c32535da7d142fb0e6df616a3c3ada0b8ab417937c853a9e1c251f499f550<br><br>$ docker container <span class="hljs-built_in">ls</span><br>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES<br>243c32535da7        ubuntu:latest       <span class="hljs-string">&quot;/bin/bash&quot;</span>         18 seconds ago      Up 17 seconds                           nostalgic_hypatia<br><br>$ docker attach 243c<br>root@243c32535da7:/<span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure><p><em>注意：</em> 如果从这个 stdin 中 exit，会导致容器的停止。</p><h3 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h3><p><code>docker exec</code> 后边可以跟多个参数，这里主要说明 <code>-i</code> <code>-t</code> 参数。</p><p>只用 <code>-i</code> 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。</p><p>当 <code>-i</code> <code>-t</code> 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -dit ubuntu<br>69d137adef7a8a689cbcb059e94da5489d3cddd240ff675c640c8d96e84fe1f6<br><br>$ docker container <span class="hljs-built_in">ls</span><br>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES<br>69d137adef7a        ubuntu:latest       <span class="hljs-string">&quot;/bin/bash&quot;</span>         18 seconds ago      Up 17 seconds                           zealous_swirles<br><br>$ docker <span class="hljs-built_in">exec</span> -i 69d1 bash<br><span class="hljs-built_in">ls</span><br>bin<br>boot<br>dev<br>...<br><br>$ docker <span class="hljs-built_in">exec</span> -it 69d1 bash<br>root@69d137adef7a:/<span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure><p>如果从这个 stdin 中 exit，不会导致容器的停止。这就是为什么推荐大家使用 <code>docker exec</code> 的原因。</p><h2 id="导入和导出"><a href="#导入和导出" class="headerlink" title="导入和导出"></a>导入和导出</h2><h3 id="导出容器"><a href="#导出容器" class="headerlink" title="导出容器"></a>导出容器</h3><p>如果要导出本地某个容器，可以使用 <code>docker export</code> 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container <span class="hljs-built_in">ls</span> -a<br>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                    PORTS               NAMES<br>7691a814370e        ubuntu:18.04        <span class="hljs-string">&quot;/bin/bash&quot;</span>         36 hours ago        Exited (0) 21 hours ago                       <span class="hljs-built_in">test</span><br>$ docker <span class="hljs-built_in">export</span> 7691a814370e &gt; ubuntu.tar<br></code></pre></td></tr></table></figure><p>这样将导出容器快照到本地文件。</p><h3 id="导入容器快照"><a href="#导入容器快照" class="headerlink" title="导入容器快照"></a>导入容器快照</h3><p>可以使用 <code>docker import</code> 从容器快照文件中再导入为镜像，例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> ubuntu.tar | docker import - <span class="hljs-built_in">test</span>/ubuntu:v1.0<br>$ docker image <span class="hljs-built_in">ls</span><br>REPOSITORY          TAG                 IMAGE ID            CREATED              VIRTUAL SIZE<br><span class="hljs-built_in">test</span>/ubuntu         v1.0                9d37a6082e97        About a minute ago   171.3 MB<br></code></pre></td></tr></table></figure><p>此外，也可以通过指定 URL 或者某个目录来导入，例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker import http://example.com/exampleimage.tgz example/imagerepo<br></code></pre></td></tr></table></figure><p><em>注：用户既可以使用</em> <code>_docker load_</code> <em>来导入镜像存储文件到本地镜像库，也可以使用</em> <code>_docker import_</code> <em>来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</em></p><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><p>可以使用 <code>docker container rm</code> 来删除一个处于终止状态的容器。例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container <span class="hljs-built_in">rm</span> trusting_newton<br>trusting_newton<br></code></pre></td></tr></table></figure><p>如果要删除一个运行中的容器，可以添加 <code>-f</code> 参数。Docker 会发送 <code>SIGKILL</code> 信号给容器。</p><h3 id="清除所有处于终止状态的容器"><a href="#清除所有处于终止状态的容器" class="headerlink" title="清除所有处于终止状态的容器"></a>清除所有处于终止状态的容器</h3><p>用 <code>docker container ls -a</code> 命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用下面的命令可以清理掉所有处于终止状态的容器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container prune<br></code></pre></td></tr></table></figure><h1 id="访问仓库"><a href="#访问仓库" class="headerlink" title="访问仓库"></a>访问仓库</h1><h2 id="Docker-Hub"><a href="#Docker-Hub" class="headerlink" title="Docker Hub"></a>Docker Hub</h2><p>目前 Docker 官方维护了一个公共仓库 <a href="https://hub.docker.com/">Docker Hub</a>，其中已经包括了数量超过 <a href="https://hub.docker.com/search/?type=image">2,650,000</a> 的镜像。大部分需求都可以通过在 Docker Hub 中直接下载镜像来实现。</p><p>你可以在 <a href="https://hub.docker.com/">https://hub.docker.com</a> 免费注册一个 Docker 账号。</p><p>你可以通过 <code>docker search</code> 命令来查找官方仓库中的镜像，并利用 <code>docker pull</code> 命令来将它下载到本地。</p><p>例如以 <code>centos</code> 为关键词进行搜索：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker search centos<br>NAME                               DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED<br>centos                             The official build of CentOS.                   6449      [OK]<br>ansible/centos7-ansible            Ansible on Centos7                              132                  [OK]<br>consol/centos-xfce-vnc             Centos container with <span class="hljs-string">&quot;headless&quot;</span> VNC session…   126                  [OK]<br>jdeathe/centos-ssh                 OpenSSH / Supervisor / EPEL/IUS/SCL Repos - …   117                  [OK]<br>centos/systemd                     systemd enabled base container.                 96                   [OK]<br></code></pre></td></tr></table></figure><p>可以看到返回了很多包含关键字的镜像，其中包括镜像名字、描述、收藏数（表示该镜像的受关注程度）、是否官方创建（<code>OFFICIAL</code>）、是否自动构建 （<code>AUTOMATED</code>）。</p><p>根据是否是官方提供，可将镜像分为两类。</p><p>一种是类似 <code>centos</code> 这样的镜像，被称为基础镜像或根镜像。这些基础镜像由 Docker 公司创建、验证、支持、提供。这样的镜像往往使用单个单词作为名字。</p><p>还有一种类型，比如 <code>ansible/centos7-ansible</code> 镜像，它是由 Docker Hub 的注册用户创建并维护的，往往带有用户名称前缀。可以通过前缀 <code>username/</code> 来指定使用某个用户提供的镜像，比如 ansible 用户。</p><p>另外，在查找的时候通过 <code>--filter=stars=N</code> 参数可以指定仅显示收藏数量为 <code>N</code> 以上的镜像。</p><p>下载官方 <code>centos</code> 镜像到本地。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker pull centos<br>Using default tag: latest<br>latest: Pulling from library/centos<br>7a0437f04f83: Pull complete<br>Digest: sha256:5528e8b1b1719d34604c87e11dcd1c0a20bedf46e83b5632cdeac91b8c04efc1<br>Status: Downloaded newer image <span class="hljs-keyword">for</span> centos:latest<br>docker.io/library/centos:latest<br></code></pre></td></tr></table></figure><h3 id="推送镜像"><a href="#推送镜像" class="headerlink" title="推送镜像"></a>推送镜像</h3><p>用户也可以在登录后通过 <code>docker push</code> 命令来将自己的镜像推送到 Docker Hub。</p><p>以下命令中的 <code>username</code> 请替换为你的 Docker 账号用户名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker tag ubuntu:18.04 username/ubuntu:18.04<br><br>$ docker image <span class="hljs-built_in">ls</span><br><br>REPOSITORY                                               TAG                    IMAGE ID            CREATED             SIZE<br>ubuntu                                                   18.04                  275d79972a86        6 days ago          94.6MB<br>username/ubuntu                                          18.04                  275d79972a86        6 days ago          94.6MB<br><br>$ docker push username/ubuntu:18.04<br><br>$ docker search username<br><br>NAME                      DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED<br>username/ubuntu<br></code></pre></td></tr></table></figure><h2 id="私有仓库"><a href="#私有仓库" class="headerlink" title="私有仓库"></a>私有仓库</h2><p>有时候使用 Docker Hub 这样的公共仓库可能不方便，用户可以创建一个本地仓库供私人使用。</p><p>本节介绍如何使用本地仓库。</p><p><a href="https://docs.docker.com/registry/"><code>docker-registry</code></a> 是官方提供的工具，可以用于构建私有的镜像仓库。本文内容基于 <a href="https://github.com/docker/distribution"><code>docker-registry</code></a> v2.x 版本。</p><h3 id="安装运行-docker-registry"><a href="#安装运行-docker-registry" class="headerlink" title="安装运行 docker-registry"></a>安装运行 docker-registry</h3><p><strong>容器运行</strong></p><p>你可以使用官方 <code>registry</code> 镜像来运行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -d -p 5000:5000 --restart=always --name registry registry<br></code></pre></td></tr></table></figure><p>这将使用官方的 <code>registry</code> 镜像来启动私有仓库。默认情况下，仓库会被创建在容器的 <code>/var/lib/registry</code> 目录下。你可以通过 <code>-v</code> 参数来将镜像文件存放在本地的指定路径。例如下面的例子将上传的镜像放到本地的 <code>/opt/data/registry</code> 目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -d \<br>    -p 5000:5000 \<br>    -v /opt/data/registry:/var/lib/registry \<br>    registry<br></code></pre></td></tr></table></figure><h3 id="在私有仓库上传、搜索、下载镜像"><a href="#在私有仓库上传、搜索、下载镜像" class="headerlink" title="在私有仓库上传、搜索、下载镜像"></a>在私有仓库上传、搜索、下载镜像</h3><p>创建好私有仓库之后，就可以使用 <code>docker tag</code> 来标记一个镜像，然后推送它到仓库。例如私有仓库地址为 <code>127.0.0.1:5000</code>。</p><p>先在本机查看已有的镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker image <span class="hljs-built_in">ls</span><br>REPOSITORY                        TAG                 IMAGE ID            CREATED             VIRTUAL SIZE<br>ubuntu                            latest              ba5877dc9bec        6 weeks ago         192.7 MB<br></code></pre></td></tr></table></figure><p>使用 <code>docker tag</code> 将 <code>ubuntu:latest</code> 这个镜像标记为 <code>127.0.0.1:5000/ubuntu:latest</code>。</p><p>格式为 <code>docker tag IMAGE[:TAG] [REGISTRY_HOST[:REGISTRY_PORT]/]REPOSITORY[:TAG]</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker tag ubuntu:latest 127.0.0.1:5000/ubuntu:latest<br>$ docker image <span class="hljs-built_in">ls</span><br>REPOSITORY                        TAG                 IMAGE ID            CREATED             VIRTUAL SIZE<br>ubuntu                            latest              ba5877dc9bec        6 weeks ago         192.7 MB<br>127.0.0.1:5000/ubuntu:latest      latest              ba5877dc9bec        6 weeks ago         192.7 MB<br></code></pre></td></tr></table></figure><p>使用 <code>docker push</code> 上传标记的镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker push 127.0.0.1:5000/ubuntu:latest<br>The push refers to repository [127.0.0.1:5000/ubuntu]<br>373a30c24545: Pushed<br>a9148f5200b0: Pushed<br>cdd3de0940ab: Pushed<br>fc56279bbb33: Pushed<br>b38367233d37: Pushed<br>2aebd096e0e2: Pushed<br>latest: digest: sha256:fe4277621f10b5026266932ddf760f5a756d2facd505a94d2da12f4f52f71f5a size: 1568<br></code></pre></td></tr></table></figure><p>用 <code>curl</code> 查看仓库中的镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ curl 127.0.0.1:5000/v2/_catalog<br>&#123;<span class="hljs-string">&quot;repositories&quot;</span>:[<span class="hljs-string">&quot;ubuntu&quot;</span>]&#125;<br><br></code></pre></td></tr></table></figure><p>这里可以看到 <code>&#123;&quot;repositories&quot;:[&quot;ubuntu&quot;]&#125;</code>，表明镜像已经被成功上传了。</p><p>先删除已有镜像，再尝试从私有仓库中下载这个镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>$ docker image <span class="hljs-built_in">rm</span> 127.0.0.1:5000/ubuntu:latest<br><br>$ docker pull 127.0.0.1:5000/ubuntu:latest<br>Pulling repository 127.0.0.1:5000/ubuntu:latest<br>ba5877dc9bec: Download complete<br>511136ea3c5a: Download complete<br>9bad880da3d2: Download complete<br>25f11f5fb0cb: Download complete<br>ebc34468f71d: Download complete<br>2318d26665ef: Download complete<br><br>$ docker image <span class="hljs-built_in">ls</span><br>REPOSITORY                         TAG                 IMAGE ID            CREATED             VIRTUAL SIZE<br>127.0.0.1:5000/ubuntu:latest       latest              ba5877dc9bec        6 weeks ago         192.7 MB<br></code></pre></td></tr></table></figure><h3 id="配置非-https-仓库地址"><a href="#配置非-https-仓库地址" class="headerlink" title="配置非 https 仓库地址"></a>配置非 https 仓库地址</h3><p>如果你不想使用 <code>127.0.0.1:5000</code> 作为仓库地址，比如想让本网段的其他主机也能把镜像推送到私有仓库。你就得把例如 <code>192.168.199.100:5000</code> 这样的内网地址作为私有仓库地址，这时你会发现无法成功推送镜像。</p><p>这是因为 Docker 默认不允许非 <code>HTTPS</code> 方式推送镜像。我们可以通过 Docker 的配置选项来取消这个限制，或者查看下一节配置能够通过 <code>HTTPS</code> 访问的私有仓库。</p><p>对于使用 <code>systemd</code> 的系统，请在 <code>/etc/docker/daemon.json</code> 中写入如下内容（如果文件不存在请新建该文件）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">&#123;<br>  <span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<br>    <span class="hljs-string">&quot;https://hub-mirror.c.163.com&quot;</span>,<br>    <span class="hljs-string">&quot;https://mirror.baidubce.com&quot;</span><br>  ],<br>  <span class="hljs-string">&quot;insecure-registries&quot;</span>: [<br>    <span class="hljs-string">&quot;192.168.199.100:5000&quot;</span><br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：该文件必须符合 <code>json</code> 规范，否则 Docker 将不能启动。</p></blockquote><h2 id="Nexus-3"><a href="#Nexus-3" class="headerlink" title="Nexus 3"></a>Nexus 3</h2><p>使用 Docker 官方的 Registry 创建的仓库面临一些维护问题。比如某些镜像删除以后空间默认是不会回收的，需要一些命令去回收空间然后重启 Registry。在企业中把内部的一些工具包放入 <code>Nexus</code> 中是比较常见的做法，最新版本 <code>Nexus3.x</code> 全面支持 Docker 的私有镜像。所以使用 <a href="https://www.sonatype.com/product/repository-oss-download"><code>Nexus3.x</code></a> 一个软件来管理 <code>Docker</code> , <code>Maven</code> , <code>Yum</code> , <code>PyPI</code> 等是一个明智的选择。</p><h3 id="启动Nexus容器"><a href="#启动Nexus容器" class="headerlink" title="启动Nexus容器"></a>启动Nexus容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -d --name nexus3 --restart=always \<br>    -p 8081:8081 \<br>    --mount src=nexus-data,target=/nexus-data \<br>    sonatype/nexus3<br></code></pre></td></tr></table></figure><p>首次运行需等待 3-5 分钟，你可以使用 <code>docker logs nexus3 -f</code> 查看日志：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker logs nexus3 -f<br><br>2021-03-11 15:31:21,990+0000 INFO  [jetty-main-1] *SYSTEM org.sonatype.nexus.bootstrap.jetty.JettyServer -<br>-------------------------------------------------<br><br>Started Sonatype Nexus OSS 3.30.0-01<br><br>-------------------------------------------------<br></code></pre></td></tr></table></figure><p>如果你看到以上内容，说明 <code>Nexus</code> 已经启动成功，你可以使用浏览器打开 <code>http://YourIP:8081</code> 访问 <code>Nexus</code> 了。</p><p>首次运行请通过以下命令获取初始密码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker <span class="hljs-built_in">exec</span> nexus3 <span class="hljs-built_in">cat</span> /nexus-data/admin.password<br><br>9266139e-41a2-4abb-92ec-e4142a3532cb<br></code></pre></td></tr></table></figure><p>首次启动 Nexus 的默认帐号是 <code>admin</code> ，密码则是上边命令获取到的，点击右上角登录，首次登录需更改初始密码。</p><p>登录之后可以点击页面上方的齿轮按钮按照下面的方法进行设置。</p><h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><p>创建一个私有仓库的方法： <code>Repository-&gt;Repositories</code> 点击右边菜单 <code>Create repository</code> 选择 <code>docker (hosted)</code></p><ul><li><strong>Name</strong>: 仓库的名称</li><li><strong>HTTP</strong>: 仓库单独的访问端口（例如：<strong>5001</strong>）</li><li><strong>Hosted -&gt; Deployment pollcy</strong>: 请选择 <strong>Allow redeploy</strong> 否则无法上传 Docker 镜像。</li></ul><p>其它的仓库创建方法请各位自己摸索，还可以创建一个 <code>docker (proxy)</code> 类型的仓库链接到 DockerHub 上。再创建一个 <code>docker (group)</code> 类型的仓库把刚才的 <code>hosted</code> 与 <code>proxy</code> 添加在一起。主机在访问的时候默认下载私有仓库中的镜像，如果没有将链接到 DockerHub 中下载并缓存到 Nexus 中。</p><h3 id="添加访问权限"><a href="#添加访问权限" class="headerlink" title="添加访问权限"></a>添加访问权限</h3><p>菜单 <code>Security-&gt;Realms</code> 把 Docker Bearer Token Realm 移到右边的框中保存。</p><p>添加用户规则：菜单 <code>Security-&gt;Roles</code>-&gt;<code>Create role</code> 在 <code>Privlleges</code> 选项搜索 docker 把相应的规则移动到右边的框中然后保存。</p><p>添加用户：菜单 <code>Security-&gt;Users</code>-&gt;<code>Create local user</code> 在 <code>Roles</code> 选项中选中刚才创建的规则移动到右边的窗口保存。</p><h3 id="Nginx加密代理"><a href="#Nginx加密代理" class="headerlink" title="Nginx加密代理"></a>Nginx加密代理</h3><p>NGINX 示例配置如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs nginx.conf">upstream register<br>&#123;<br>    server &quot;YourHostName OR IP&quot;:5001; #端口为上面添加私有镜像仓库时设置的 HTTP 选项的端口号<br>    check interval=3000 rise=2 fall=10 timeout=1000 type=http;<br>    check_http_send &quot;HEAD / HTTP/1.0\r\n\r\n&quot;;<br>    check_http_expect_alive http_4xx;<br>&#125;<br><br>server &#123;<br>    server_name YourDomainName;#如果没有 DNS 服务器做解析，请删除此选项使用本机 IP 地址访问<br>    listen       443 ssl;<br><br>    ssl_certificate key/example.crt;<br>    ssl_certificate_key key/example.key;<br><br>    ssl_session_timeout  5m;<br>    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;<br>    ssl_ciphers  HIGH:!aNULL:!MD5;<br>    ssl_prefer_server_ciphers   on;<br>    large_client_header_buffers 4 32k;<br>    client_max_body_size 300m;<br>    client_body_buffer_size 512k;<br>    proxy_connect_timeout 600;<br>    proxy_read_timeout   600;<br>    proxy_send_timeout   600;<br>    proxy_buffer_size    128k;<br>    proxy_buffers       4 64k;<br>    proxy_busy_buffers_size 128k;<br>    proxy_temp_file_write_size 512k;<br><br>    location / &#123;<br>        proxy_set_header Host $host;<br>        proxy_set_header X-Forwarded-Proto $scheme;<br>        proxy_set_header X-Forwarded-Port $server_port;<br>        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;<br>        proxy_http_version 1.1;<br>        proxy_set_header Upgrade $http_upgrade;<br>        proxy_set_header Connection $connection_upgrade;<br>        proxy_redirect off;<br>        proxy_set_header X-Real-IP $remote_addr;<br>        proxy_pass http://register;<br>        proxy_read_timeout 900s;<br><br>    &#125;<br>    error_page   500 502 503 504  /50x.html;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="数据管理"><a href="#数据管理" class="headerlink" title="数据管理"></a>数据管理</h1><h2 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h2><p><code>数据卷</code> 是一个可供一个或多个容器使用的特殊目录，它绕过 UnionFS，可以提供很多有用的特性：</p><ul><li><code>数据卷</code> 可以在容器之间共享和重用</li><li>对 <code>数据卷</code> 的修改会立马生效</li><li>对 <code>数据卷</code> 的更新，不会影响镜像</li><li><code>数据卷</code> 默认会一直存在，即使容器被删除</li></ul><blockquote><p>注意：<code>数据卷</code> 的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会复制到数据卷中（仅数据卷为空时会复制）。</p></blockquote><h3 id="创建数据卷"><a href="#创建数据卷" class="headerlink" title="创建数据卷"></a>创建数据卷</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker volume create my-vol<br></code></pre></td></tr></table></figure><p>查看所有的 <code>数据卷</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker volume <span class="hljs-built_in">ls</span><br><br>DRIVER              VOLUME NAME<br><span class="hljs-built_in">local</span>               my-vol<br></code></pre></td></tr></table></figure><p>在主机里使用以下命令可以查看指定 <code>数据卷</code> 的信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker volume inspect my-vol<br>[<br>    &#123;<br>        <span class="hljs-string">&quot;Driver&quot;</span>: <span class="hljs-string">&quot;local&quot;</span>,<br>        <span class="hljs-string">&quot;Labels&quot;</span>: &#123;&#125;,<br>        <span class="hljs-string">&quot;Mountpoint&quot;</span>: <span class="hljs-string">&quot;/var/lib/docker/volumes/my-vol/_data&quot;</span>,<br>        <span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;my-vol&quot;</span>,<br>        <span class="hljs-string">&quot;Options&quot;</span>: &#123;&#125;,<br>        <span class="hljs-string">&quot;Scope&quot;</span>: <span class="hljs-string">&quot;local&quot;</span><br>    &#125;<br>]<br></code></pre></td></tr></table></figure><h3 id="启动一个挂载数据卷的容器"><a href="#启动一个挂载数据卷的容器" class="headerlink" title="启动一个挂载数据卷的容器"></a>启动一个挂载数据卷的容器</h3><p>在用 <code>docker run</code> 命令的时候，使用 <code>--mount</code> 标记来将 <code>数据卷</code> 挂载到容器里。在一次 <code>docker run</code> 中可以挂载多个 <code>数据卷</code>。</p><p>下面创建一个名为 <code>web</code> 的容器，并加载一个 <code>数据卷</code> 到容器的 <code>/usr/share/nginx/html</code> 目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -d -P \<br>    --name web \<br>    <span class="hljs-comment"># -v my-vol:/usr/share/nginx/html \</span><br>    --mount <span class="hljs-built_in">source</span>=my-vol,target=/usr/share/nginx/html \<br>    nginx:alpine<br></code></pre></td></tr></table></figure><h3 id="查看数据卷信息"><a href="#查看数据卷信息" class="headerlink" title="查看数据卷信息"></a>查看数据卷信息</h3><p>在主机里使用以下命令可以查看 <code>web</code> 容器的信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker inspect web<br></code></pre></td></tr></table></figure><p><code>数据卷</code> 信息在 “Mounts” Key 下面</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-string">&quot;Mounts&quot;</span>: [<br>    &#123;<br>        <span class="hljs-string">&quot;Type&quot;</span>: <span class="hljs-string">&quot;volume&quot;</span>,<br>        <span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;my-vol&quot;</span>,<br>        <span class="hljs-string">&quot;Source&quot;</span>: <span class="hljs-string">&quot;/var/lib/docker/volumes/my-vol/_data&quot;</span>,<br>        <span class="hljs-string">&quot;Destination&quot;</span>: <span class="hljs-string">&quot;/usr/share/nginx/html&quot;</span>,<br>        <span class="hljs-string">&quot;Driver&quot;</span>: <span class="hljs-string">&quot;local&quot;</span>,<br>        <span class="hljs-string">&quot;Mode&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>        <span class="hljs-string">&quot;RW&quot;</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-string">&quot;Propagation&quot;</span>: <span class="hljs-string">&quot;&quot;</span><br>    &#125;<br>],<br></code></pre></td></tr></table></figure><h3 id="删除数据卷"><a href="#删除数据卷" class="headerlink" title="删除数据卷"></a>删除数据卷</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker volume <span class="hljs-built_in">rm</span> my-vol<br></code></pre></td></tr></table></figure><p><code>数据卷</code> 是被设计用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除 <code>数据卷</code>，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的 <code>数据卷</code>。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 <code>docker rm -v</code> 这个命令。</p><p>无主的数据卷可能会占据很多空间，要清理请使用以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker volume prune<br></code></pre></td></tr></table></figure><h2 id="挂载主机目录"><a href="#挂载主机目录" class="headerlink" title="挂载主机目录"></a>挂载主机目录</h2><h3 id="挂载主机目录作为数据卷"><a href="#挂载主机目录作为数据卷" class="headerlink" title="挂载主机目录作为数据卷"></a>挂载主机目录作为数据卷</h3><p>使用 <code>--mount</code> 标记可以指定挂载一个本地主机的目录到容器中去。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -d -P \<br>    --name web \<br>    <span class="hljs-comment"># -v /src/webapp:/usr/share/nginx/html \</span><br>    --mount <span class="hljs-built_in">type</span>=<span class="hljs-built_in">bind</span>,<span class="hljs-built_in">source</span>=/src/webapp,target=/usr/share/nginx/html \<br>    nginx:alpine<br></code></pre></td></tr></table></figure><p>上面的命令加载主机的 <code>/src/webapp</code> 目录到容器的 <code>/usr/share/nginx/html</code>目录。这个功能在进行测试的时候十分方便，比如用户可以放置一些程序到本地目录中，来查看容器是否正常工作。本地目录的路径必须是绝对路径，以前使用 <code>-v</code> 参数时如果本地目录不存在 Docker 会自动为你创建一个文件夹，现在使用 <code>--mount</code> 参数时如果本地目录不存在，Docker 会报错。</p><p>Docker 挂载主机目录的默认权限是 <code>读写</code>，用户也可以通过增加 <code>readonly</code> 指定为 <code>只读</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -d -P \<br>    --name web \<br>    <span class="hljs-comment"># -v /src/webapp:/usr/share/nginx/html:ro \</span><br>    --mount <span class="hljs-built_in">type</span>=<span class="hljs-built_in">bind</span>,<span class="hljs-built_in">source</span>=/src/webapp,target=/usr/share/nginx/html,<span class="hljs-built_in">readonly</span> \<br>    nginx:alpine<br></code></pre></td></tr></table></figure><p>加了 <code>readonly</code> 之后，就挂载为 <code>只读</code> 了。如果你在容器内 <code>/usr/share/nginx/html</code> 目录新建文件，会显示如下错误</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">/usr/share/nginx/html <span class="hljs-comment"># touch new.txt</span><br><span class="hljs-built_in">touch</span>: new.txt: Read-only file system<br></code></pre></td></tr></table></figure><h3 id="查看数据卷具体信息"><a href="#查看数据卷具体信息" class="headerlink" title="查看数据卷具体信息"></a>查看数据卷具体信息</h3><p>在主机里使用以下命令可以查看 <code>web</code> 容器的信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker inspect web<br></code></pre></td></tr></table></figure><p><code>挂载主机目录</code> 的配置信息在 “Mounts” Key 下面</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-string">&quot;Mounts&quot;</span>: [<br>    &#123;<br>        <span class="hljs-string">&quot;Type&quot;</span>: <span class="hljs-string">&quot;bind&quot;</span>,<br>        <span class="hljs-string">&quot;Source&quot;</span>: <span class="hljs-string">&quot;/src/webapp&quot;</span>,<br>        <span class="hljs-string">&quot;Destination&quot;</span>: <span class="hljs-string">&quot;/usr/share/nginx/html&quot;</span>,<br>        <span class="hljs-string">&quot;Mode&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>        <span class="hljs-string">&quot;RW&quot;</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-string">&quot;Propagation&quot;</span>: <span class="hljs-string">&quot;rprivate&quot;</span><br>    &#125;<br>],<br></code></pre></td></tr></table></figure><h3 id="挂载一个本地主机文件作为数据卷"><a href="#挂载一个本地主机文件作为数据卷" class="headerlink" title="挂载一个本地主机文件作为数据卷"></a>挂载一个本地主机文件作为数据卷</h3><p><code>--mount</code> 标记也可以从主机挂载单个文件到容器中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run --<span class="hljs-built_in">rm</span> -it \<br>   <span class="hljs-comment"># -v $HOME/.bash_history:/root/.bash_history \</span><br>   --mount <span class="hljs-built_in">type</span>=<span class="hljs-built_in">bind</span>,<span class="hljs-built_in">source</span>=<span class="hljs-variable">$HOME</span>/.bash_history,target=/root/.bash_history \<br>   ubuntu:18.04 \<br>   bash<br><br>root@2affd44b4667:/<span class="hljs-comment"># history</span><br>1  <span class="hljs-built_in">ls</span><br>2  diskutil list<br></code></pre></td></tr></table></figure><p>这样就可以记录在容器输入过的命令了。</p><h1 id="使用网络"><a href="#使用网络" class="headerlink" title="使用网络"></a>使用网络</h1><h2 id="外部访问容器"><a href="#外部访问容器" class="headerlink" title="外部访问容器"></a>外部访问容器</h2><p>容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 <code>-P</code> 或 <code>-p</code> 参数来指定端口映射。</p><p>当使用 <code>-P</code> 标记时，Docker 会随机映射一个端口到内部容器开放的网络端口。</p><p>使用 <code>docker container ls</code> 可以看到，本地主机的 32768 被映射到了容器的 80 端口。此时访问本机的 32768 端口即可访问容器内 NGINX 默认页面。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -d -P nginx:alpine<br><br>$ docker container <span class="hljs-built_in">ls</span> -l<br>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                   NAMES<br>fae320d08268        nginx:alpine        <span class="hljs-string">&quot;/docker-entrypoint.…&quot;</span>   24 seconds ago      Up 20 seconds       0.0.0.0:32768-&gt;80/tcp   bold_mcnulty<br></code></pre></td></tr></table></figure><p>同样的，可以通过 <code>docker logs</code> 命令来查看访问记录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker logs fa<br>172.17.0.1 - - [25/Aug/2020:08:34:04 +0000] <span class="hljs-string">&quot;GET / HTTP/1.1&quot;</span> 200 612 <span class="hljs-string">&quot;-&quot;</span> <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:80.0) Gecko/20100101 Firefox/80.0&quot;</span> <span class="hljs-string">&quot;-&quot;</span><br></code></pre></td></tr></table></figure><p><code>-p</code> 则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有 <code>ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort</code>。</p><h3 id="映射所有接口地址"><a href="#映射所有接口地址" class="headerlink" title="映射所有接口地址"></a>映射所有接口地址</h3><p>使用 <code>hostPort:containerPort</code> 格式本地的 80 端口映射到容器的 80 端口，可以执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -d -p 80:80 nginx:alpine<br></code></pre></td></tr></table></figure><p>此时默认会绑定本地所有接口上的所有地址。</p><h3 id="映射到指定地址的指定端口"><a href="#映射到指定地址的指定端口" class="headerlink" title="映射到指定地址的指定端口"></a>映射到指定地址的指定端口</h3><p>可以使用 <code>ip:hostPort:containerPort</code> 格式指定映射使用一个特定地址，比如 localhost 地址 127.0.0.1</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -d -p 127.0.0.1:80:80 nginx:alpine<br></code></pre></td></tr></table></figure><h3 id="映射到指定地址的任意端口"><a href="#映射到指定地址的任意端口" class="headerlink" title="映射到指定地址的任意端口"></a>映射到指定地址的任意端口</h3><p>使用 <code>ip::containerPort</code> 绑定 localhost 的任意端口到容器的 80 端口，本地主机会自动分配一个端口。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -d -p 127.0.0.1::80 nginx:alpine<br></code></pre></td></tr></table></figure><p>还可以使用 <code>udp</code> 标记来指定 <code>udp</code> 端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -d -p 127.0.0.1:80:80/udp nginx:alpine<br></code></pre></td></tr></table></figure><h3 id="查看映射端口配置"><a href="#查看映射端口配置" class="headerlink" title="查看映射端口配置"></a>查看映射端口配置</h3><p>使用 <code>docker port</code> 来查看当前映射的端口配置，也可以查看到绑定的地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker port fa 80<br>0.0.0.0:32768<br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>容器有自己的内部网络和 ip 地址（使用 <code>docker inspect</code> 查看，Docker 还可以有一个可变的网络配置。）</li><li><code>-p</code> 标记可以多次使用来绑定多个端口</li></ul><p>例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -d \<br>    -p 80:80 \<br>    -p 443:443 \<br>    nginx:alpine<br></code></pre></td></tr></table></figure><h2 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h2><p>如果你之前有 <code>Docker</code> 使用经验，你可能已经习惯了使用 <code>--link</code> 参数来使容器互联。</p><p>随着 Docker 网络的完善，强烈建议大家将容器加入自定义的 Docker 网络来连接多个容器，而不是使用 <code>--link</code> 参数。</p><h3 id="新建网络"><a href="#新建网络" class="headerlink" title="新建网络"></a>新建网络</h3><p>下面先创建一个新的 Docker 网络。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker network create -d bridge my-net<br></code></pre></td></tr></table></figure><p><code>-d</code> 参数指定 Docker 网络类型，有 <code>bridge</code> <code>overlay</code>。其中 <code>overlay</code> 网络类型用于 <a href="https://yeasy.gitbook.io/docker_practice/swarm_mode">Swarm mode</a>，在本小节中你可以忽略它。</p><h3 id="连接容器"><a href="#连接容器" class="headerlink" title="连接容器"></a>连接容器</h3><p>运行一个容器并连接到新建的 <code>my-net</code> 网络</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -it --<span class="hljs-built_in">rm</span> --name busybox1 --network my-net busybox sh<br></code></pre></td></tr></table></figure><p>打开新的终端，再运行一个容器并加入到 <code>my-net</code> 网络</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -it --<span class="hljs-built_in">rm</span> --name busybox2 --network my-net busybox sh<br></code></pre></td></tr></table></figure><p>再打开一个新的终端查看容器信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container <span class="hljs-built_in">ls</span><br><br>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES<br>b47060aca56b        busybox             <span class="hljs-string">&quot;sh&quot;</span>                11 minutes ago      Up 11 minutes                           busybox2<br>8720575823ec        busybox             <span class="hljs-string">&quot;sh&quot;</span>                16 minutes ago      Up 16 minutes                           busybox1<br></code></pre></td></tr></table></figure><p>下面通过 <code>ping</code> 来证明 <code>busybox1</code> 容器和 <code>busybox2</code> 容器建立了互联关系。</p><p>在 <code>busybox1</code> 容器输入以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">/ <span class="hljs-comment"># ping busybox2</span><br>PING busybox2 (172.19.0.3): 56 data bytes<br>64 bytes from 172.19.0.3: <span class="hljs-built_in">seq</span>=0 ttl=64 time=0.072 ms<br>64 bytes from 172.19.0.3: <span class="hljs-built_in">seq</span>=1 ttl=64 time=0.118 ms<br></code></pre></td></tr></table></figure><p>用 ping 来测试连接 <code>busybox2</code> 容器，它会解析成 <code>172.19.0.3</code>。</p><p>同理在 <code>busybox2</code> 容器执行 <code>ping busybox1</code>，也会成功连接到。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">/ <span class="hljs-comment"># ping busybox1</span><br>PING busybox1 (172.19.0.2): 56 data bytes<br>64 bytes from 172.19.0.2: <span class="hljs-built_in">seq</span>=0 ttl=64 time=0.064 ms<br>64 bytes from 172.19.0.2: <span class="hljs-built_in">seq</span>=1 ttl=64 time=0.143 ms<br></code></pre></td></tr></table></figure><p>这样，<code>busybox1</code> 容器和 <code>busybox2</code> 容器建立了互联关系。</p><h3 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h3><p>如果你有多个容器之间需要互相连接，推荐使用 Docker Compose。不过目前够用了，后期有需要再详细研究。</p><h2 id="配置DNS"><a href="#配置DNS" class="headerlink" title="配置DNS"></a>配置DNS</h2><p>如何自定义配置容器的主机名和 DNS 呢？秘诀就是 Docker 利用虚拟文件来挂载容器的 3 个相关配置文件。</p><p>在容器中使用 <code>mount</code> 命令可以看到挂载信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ mount<br>/dev/disk/by-uuid/1fec...ebdf on /etc/hostname <span class="hljs-built_in">type</span> ext4 ...<br>/dev/disk/by-uuid/1fec...ebdf on /etc/hosts <span class="hljs-built_in">type</span> ext4 ...<br>tmpfs on /etc/resolv.conf <span class="hljs-built_in">type</span> tmpfs ...<br></code></pre></td></tr></table></figure><p>这种机制可以让宿主主机 DNS 信息发生更新后，所有 Docker 容器的 DNS 配置通过 <code>/etc/resolv.conf</code> 文件立刻得到更新。</p><p>配置全部容器的 DNS ，也可以在 <code>/etc/docker/daemon.json</code> 文件中增加以下内容来设置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">&#123;<br>  <span class="hljs-string">&quot;dns&quot;</span> : [<br>    <span class="hljs-string">&quot;114.114.114.114&quot;</span>,<br>    <span class="hljs-string">&quot;8.8.8.8&quot;</span><br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p>这样每次启动的容器 DNS 自动配置为 <code>114.114.114.114</code> 和 <code>8.8.8.8</code>。使用以下命令来证明其已经生效。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -it --<span class="hljs-built_in">rm</span> ubuntu:18.04  <span class="hljs-built_in">cat</span> etc/resolv.conf<br><br>nameserver 114.114.114.114<br>nameserver 8.8.8.8<br></code></pre></td></tr></table></figure><p>如果用户想要手动指定容器的配置，可以在使用 <code>docker run</code> 命令启动容器时加入如下参数：</p><p><code>-h HOSTNAME</code> 或者 <code>--hostname=HOSTNAME</code> 设定容器的主机名，它会被写到容器内的 <code>/etc/hostname</code> 和 <code>/etc/hosts</code>。但它在容器外部看不到，既不会在 <code>docker container ls</code> 中显示，也不会在其他的容器的 <code>/etc/hosts</code> 看到。</p><p><code>--dns=IP_ADDRESS</code> 添加 DNS 服务器到容器的 <code>/etc/resolv.conf</code> 中，让容器用这个服务器来解析所有不在 <code>/etc/hosts</code> 中的主机名。</p><p><code>--dns-search=DOMAIN</code> 设定容器的搜索域，当设定搜索域为 <code>.example.com</code> 时，在搜索一个名为 host 的主机时，DNS 不仅搜索 host，还会搜索 <code>host.example.com</code>。</p><blockquote><p>注意：如果在容器启动时没有指定最后两个参数，Docker 会默认用主机上的 <code>/etc/resolv.conf</code> 来配置容器。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>maven使用教程</title>
    <link href="/posts/cc2d81c9/"/>
    <url>/posts/cc2d81c9/</url>
    
    <content type="html"><![CDATA[<h1 id="下载maven"><a href="#下载maven" class="headerlink" title="下载maven"></a>下载maven</h1><p>1.进入<a href="https://maven.apache.org/download.cgi">官网</a>下载需要的版本 </p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151402306.png"></p><h1 id="安装maven"><a href="#安装maven" class="headerlink" title="安装maven"></a>安装maven</h1><p>将下载的压缩包解压到<strong>非中文、没有空格</strong>的目录 , 在解压目录中，我们需要着重关注Maven的核心配置文件：conf&#x2F;settings.xml</p><h1 id="创建本地仓库"><a href="#创建本地仓库" class="headerlink" title="创建本地仓库"></a>创建本地仓库</h1><p>本地仓库这个目录，我们手动创建一个空的目录即可。</p><h1 id="指定本地仓库"><a href="#指定本地仓库" class="headerlink" title="指定本地仓库"></a>指定本地仓库</h1><p>本地仓库默认值：用户家目录&#x2F;.m2&#x2F;repository。由于本地仓库的默认位置是在用户的家目录下，而家目录往往是在C盘，也就是系统盘。将来Maven仓库中jar包越来越多，仓库体积越来越大，可能会拖慢C盘运行速度，影响系统性能。所以建议将Maven的本地仓库放在其他盘符下。</p><p>配置方式如下：<br>打开maven里的conf文件，打开setings.xml文件，配置本地仓库文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- localRepository</span><br><span class="hljs-comment">| The path to the local repository maven will use to store artifacts.</span><br><span class="hljs-comment">|</span><br><span class="hljs-comment">| Default: $&#123;user.home&#125;/.m2/repository</span><br><span class="hljs-comment">&lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">localRepository</span>&gt;</span>D:\mavenRepository<span class="hljs-tag">&lt;/<span class="hljs-name">localRepository</span>&gt;</span><br><span class="hljs-comment">&lt;!--mavenRepository是自己创建的仓库名--&gt;</span><br></code></pre></td></tr></table></figure><p><strong>记住</strong>：一定要把localRepository标签<strong>从注释中拿出来</strong>。</p><p><strong>注意</strong>：本地仓库本身也需要使用一个<strong>非中文、没有空格</strong>的目录。</p><h1 id="配置镜像仓库"><a href="#配置镜像仓库" class="headerlink" title="配置镜像仓库"></a>配置镜像仓库</h1><blockquote><p>为什么要配置阿里云提供的镜像仓库？</p></blockquote><p>Maven下载jar包默认访问境外的中央仓库，速度很慢。改成阿里云提供的镜像仓库，访问国内网站，可以让Maven下载jar包的时候速度更快。</p><p>配置的方式是：</p><p>打开maven里的conf文件，打开setings.xml文件，</p><p>将下面mirror标签整体复制到mirrors标签的内部。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mirrors</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>nexus-aliyun<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>central<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Nexus aliyun<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mirrors</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="配置maven工厂的基础JDK版本"><a href="#配置maven工厂的基础JDK版本" class="headerlink" title="配置maven工厂的基础JDK版本"></a>配置maven工厂的基础JDK版本</h1><blockquote><p>如果按照默认配置运行，Java工程使用的JDK版本是1.5。</p></blockquote><p>配置的方式是：</p><p>打开maven里的conf文件，打开setings.xml文件，</p><p>将profile标签整个复制到profiles标签内。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">profiles</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>jdk-1.8<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">activation</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">activeByDefault</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">activeByDefault</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">jdk</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">jdk</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">activation</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.compilerVersion</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">profiles</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h1><blockquote><p>Maven是一个用Java语言开发的程序，它必须基于JDK来运行，需要通过JAVA_HOME来找到JDK的安装位置。</p></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151405660.png"></p><p>可以使用下面的命令验证：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">C:\Users\Administrator&gt;echo %JAVA_HOME%<br>D:\software\Java<br>C:\Users\Administrator&gt;java -version<br>java version &quot;1.8.0_141&quot;<br>Java(TM) SE Runtime Environment (build 1.8.0_141-b15)<br>Java HotSpot(TM) 64-Bit Server VM (build 25.141-b15, mixed mode)<br></code></pre></td></tr></table></figure><h1 id="配置MAVEN-HOME"><a href="#配置MAVEN-HOME" class="headerlink" title="配置MAVEN_HOME"></a>配置MAVEN_HOME</h1><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151406492.png"></p><p>配置环境变量的规律：</p><p>XXX_HOME指向的是bin目录的上一级</p><p>PATH指向的是bin目录</p><p><strong>配置path：</strong></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151406834.png"></p><p><strong>验证：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">C:\Users\Administrator&gt;mvn -v<br>Apache Maven 3.5.4 (1edded0938998edf8bf061f1ceb3cfdeccf443fe; 2018-06-18T02:33:14+08:00)<br>Maven home: D:\software\apache-maven-3.5.4\bin\..<br>Java version: 1.8.0_141, vendor: Oracle Corporation, runtime: D:\software\Java\jre<br>Default locale: zh_CN, platform encoding: GBK<br>OS name: &quot;windows 10&quot;, version: &quot;10.0&quot;, arch: &quot;amd64&quot;, family: &quot;windows&quot;<br></code></pre></td></tr></table></figure><h1 id="仓库和坐标"><a href="#仓库和坐标" class="headerlink" title="仓库和坐标"></a>仓库和坐标</h1><h2 id="maven仓库"><a href="#maven仓库" class="headerlink" title="maven仓库"></a>maven仓库</h2><p>maven的仓库就是maven存放jar包的位置，主要分为如下三类仓库</p><table><thead><tr><th>仓库名称</th><th>作用</th></tr></thead><tbody><tr><td>本地仓库</td><td>相当于缓存，工程第一次会从远程仓库（互联网）去下载jar 包，将jar包存在本地仓库（在程序员的电脑上）。第二次不需要从远程仓库去下载。先从本地仓库找，如果找不到才会去远程仓库找。</td></tr><tr><td>中央仓库</td><td>仓库中jar由专业团队（maven团队）统一维护。中央仓库的地址：<a href="https://link.zhihu.com/?target=https://repo1.maven.org/maven2/">https://repo1.maven.org/maven2/</a></td></tr><tr><td>远程仓库</td><td>在公司内部架设一台私服，其它公司架设一台仓库，对外公开。</td></tr></tbody></table><h2 id="maven坐标"><a href="#maven坐标" class="headerlink" title="maven坐标"></a>maven坐标</h2><p>Maven的一个核心的作用就是管理项目的依赖，引入我们所需的各种jar包等。为了能自动化的解析任何一个Java构件，Maven必须将这些Jar包或者其他资源进行唯一标识，这是管理项目的依赖的基础，也就是我们要说的坐标。包括我们自己开发的项目，也是要通过坐标进行唯一标识的，这样才能在其它项目中进行依赖引用。坐标的定义元素如下：</p><ul><li>groupId:项目组织唯一的标识符，实际对应JAVA的包的结构 (一般写公司的组织名称 eg:com.itee,com.alibaba)</li><li>artifactId: 项目的名称</li><li>version：定义项目的当前版本</li></ul><p>例如：要引入druid，只需要在pom.xml配置文件中配置引入druid的坐标即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependecies</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--druid连接池--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.9<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastjson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.39<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependecies</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="在idea中集成maven"><a href="#在idea中集成maven" class="headerlink" title="在idea中集成maven"></a>在idea中集成maven</h1><p><strong>1. 配置maven软件的安装路径和本地仓库路径</strong></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151408008.png"></p><p><strong>配置Maven的Runner参数</strong></p><p>参数一: -DarchetypeCatalog&#x3D;internal 解决使用骨架构建Maven项目时候会卡住的问题</p><p>参数二: -Dfile.encoding&#x3D;GB2312 解决Maven工程中控制台输出中文乱码的问题</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151408832.png"></p><p><strong>注意事项:</strong></p><p>上述配置如果是在settings中进行配置则只会对当前Project生效，后续创建的新的Project不会生效</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151409913.png"></p><p>如果是在New Projects Setup里面的setting for new projects中配置，则会对后续创建的所有新的Project都生效，但是无法对当前项目生效。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151409245.png"></p><h1 id="maven构建命令"><a href="#maven构建命令" class="headerlink" title="maven构建命令"></a>maven构建命令</h1><p>执行Maven构建命令有两种方式:</p><ol><li>如果是自己使用IDEA创建的Maven工程，可以自己直接在IDEA的Maven面板上执行相应的构建命令</li><li>如果是该项目是从其它地方拷贝过来的，并且没有在IDEA上打开，则可以使用命令行来进行Maven构建</li></ol><p><strong>注意事项:</strong></p><p>运行Maven中和构建操作相关的命令时，必须进入到pom.xml所在的目录。如果没有在pom.xml所在的目录运行Maven的构建命令，那么会看到下面的错误信息：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">The goal you specified requires a project to execute but there is no POM in this directory<br></code></pre></td></tr></table></figure><h2 id="清理-clean"><a href="#清理-clean" class="headerlink" title="清理 clean"></a>清理 clean</h2><p>mvn clean命令是清除项目的编译内容，具体的效果是删除target目录</p><h2 id="编译-compile"><a href="#编译-compile" class="headerlink" title="编译 compile"></a>编译 compile</h2><p>compile命令是对工程进行编译，具体效果是产生target目录，而编译又分为: 编译主程序和编译测试程序</p><h3 id="编译主程序"><a href="#编译主程序" class="headerlink" title="编译主程序"></a>编译主程序</h3><p>mvn compile 命令是编译主程序，主程序编译之后的文件会生成在 target&#x2F;classes 目录中</p><h3 id="编译测试程序"><a href="#编译测试程序" class="headerlink" title="编译测试程序"></a>编译测试程序</h3><p>mvn test-compile 命令是编译测试程序，测试程序编译之后的文件会生成在 target&#x2F;test-classes 目录中</p><h2 id="执行测试-test"><a href="#执行测试-test" class="headerlink" title="执行测试 test"></a>执行测试 test</h2><p>mvn test会执行测试程序中的所有测试用例，并且将生成的测试报告存放在target&#x2F;surefire-reports目录下。</p><p>在执行mvn test命令的过程中，会自动先执行mvn clean、mvn compile、mvn test-compile，然后再执行mvn test进行测试</p><h2 id="打包-package"><a href="#打包-package" class="headerlink" title="打包 package"></a>打包 package</h2><p>mvn package命令会对程序进行打包，如果是javase工程会打成jar包，而javaweb工程则会打成war包，打包得到的结果会生成在target目录中</p><p>在执行mvn package命令的过程中，会自动先执行mvn clean、mvn compile、mvn test-compile、mvn test，然后再执行mvn package进行打包</p><h2 id="安装-install"><a href="#安装-install" class="headerlink" title="安装 install"></a>安装 install</h2><p>mvn install 命令会将程序打成的包安装到本地仓库(针对jar包，war包安装到本地仓库意义不大)</p><p>在执行mvn install命令的过程中，会自动先执行mvn clean、mvn compile、mvn test-compile、mvn test、mvn package，然后再执行mvn package进行打包</p><p>安装的效果是将本地构建过程中生成的jar包存入Maven本地仓库。这个jar包在Maven仓库中的路径是根据它的坐标生成的。</p><p>坐标信息如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fm.maven<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>pro01-maven-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在Maven仓库中生成的路径如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">D:\mavenRepository\com\fm\maven\pro01-maven-java\1.0-SNAPSHOT\pro01-maven-java-1.0-SNAPSHOT.jar<br></code></pre></td></tr></table></figure><p>另外，安装操作还会将pom.xml文件转换为XXX.pom文件一起存入本地仓库。所以我们在Maven的本地仓库中想看一个jar包原始的pom.xml文件时，查看对应XXX.pom文件即可，它们是名字发生了改变，本质上是同一个文件。</p><h1 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h1><h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><p>在maven项目中，我们只需要通过jar包的maven坐标去引入jar包就可以了，而不需要像之前一样手动导入jar包。至于每一个jar包的坐标到底怎么写，我们不需要记忆，写代码的时候可以直接复制，如果需要查找则可以到<a href="https://link.zhihu.com/?target=http://mvnrepository.com/">http://mvnrepository.com/</a>网站查找即可</p><p>例如，引入单元测试的依赖:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>      <br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>       <br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>    <br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>当前项目的所有依赖都是放在<code>&lt;dependencies&gt;</code>标签里面，而具体每一个jar包的坐标则是放在一个<code>&lt;dependency&gt;</code>标签中</p><h2 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h2><p><code>&lt;scope&gt;</code>标签表示依赖的范围，它的位置是在dependencies&#x2F;dependency&#x2F;scope，该标签中的值可以是compile、test、provided、runtime这四个值中的一个，如果没有手动指定依赖范围，那么依赖范围默认是compile</p><p><strong>四种依赖范围的对比</strong></p><table><thead><tr><th>依赖范围</th><th>main目录（空间）</th><th>test目录（空间）</th><th>编译阶段（时间）</th><th>运行阶段（时间）</th></tr></thead><tbody><tr><td>compile</td><td>有效</td><td>有效</td><td>有效</td><td>有效</td></tr><tr><td>test</td><td>无效</td><td>有效</td><td>有效</td><td>无效</td></tr><tr><td>provided</td><td>有效</td><td>有效</td><td>有效</td><td>无效</td></tr><tr><td>runtime</td><td>无效</td><td>无效</td><td>无效</td><td>有效</td></tr></tbody></table><ol><li>compile: 该范围的依赖既可以在main目录使用，又可以在test目录使用，即在编译阶段使用，又在实际运行阶段使用(会打到war&#x2F;jar包中)，通常使用的第三方框架的jar包这样在项目实际运行时真正要用到的jar包都是以compile范围进行依赖的。比如SSM框架所需jar包。</li><li>test: 该范围的依赖只能在test目录中使用，不能在main目录中使用，只能在编译阶段使用，无法在项目运行阶段使用(不会打到war&#x2F;jar包中)，引入junit单元测试依赖的时候会使用该范围</li><li>provided: 该范围的依赖即可在main目录使用，又可以在test目录使用，但是它只能在编译阶段使用，无法在项目运行阶段使用(不会打到war&#x2F;jar包中)。比如说Tomcat服务器中内置有servlet-api、jsp-api等等依赖，所以我们在项目中引入这些依赖的时候的目标仅仅是<strong>让我们的代码编译通过</strong>， 为了避免和服务器上已有的同类jar包产生冲突，同时减轻服务器的负担我们<strong>不会选择将这些依赖打到war包中</strong>。说白了就是：“服务器上已经有了，你就别带啦！”</li><li>runtime: 该范围的依赖既不可在main目录使用，又不可在test目录使用，说白了就是它无法在编译阶段使用，只能在项目运行阶段使用(会打到war&#x2F;jar包中)。比如说MySQL驱动的依赖，我们在开发(写代码)的过程中根本不需要使用MySQL驱动中的任何类(因为都是直接用的JDBC接口)，只在运行阶段需要MySQL驱动的依赖，所以我们就可以将MySQL驱动的范围指定为runtime这样能有助于提升编译效率</li></ol><h2 id="依赖的传递性和排除"><a href="#依赖的传递性和排除" class="headerlink" title="依赖的传递性和排除"></a>依赖的传递性和排除</h2><h3 id="依赖的传递性"><a href="#依赖的传递性" class="headerlink" title="依赖的传递性"></a>依赖的传递性</h3><p>依赖的传递性指的是: A依赖B，B依赖C，那么在A没有配置对C的依赖的情况下，A里面能不能直接使用C。 在A依赖B，B依赖C的前提下，C是否能够传递到A，取决于B依赖C时使用的依赖范围。</p><ul><li>B依赖C时使用compile范围：可以传递</li><li>B依赖C时使用test或provided范围：不能传递，所以需要这样的jar包时，就必须在需要的地方明确配置依赖才可以。</li></ul><h3 id="依赖的排除"><a href="#依赖的排除" class="headerlink" title="依赖的排除"></a>依赖的排除</h3><p>当A依赖B，B依赖C而且C可以传递到A的时候，但是A不想要C，需要在A里面把C排除掉。而往往这种情况都是为了避免jar包之间的冲突。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151412051.png"></p><p>所以配置依赖的排除其实就是阻止某些jar包的传递。因为这样的jar包传递过来会和其他jar包冲突。</p><p><strong>如何排除</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-beans<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.2.4.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br>  <span class="hljs-comment">&lt;!--直接排除--&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>     <br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>   <br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>     <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>   <br>  <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="自定义属性"><a href="#自定义属性" class="headerlink" title="自定义属性"></a>自定义属性</h1><p>在pom.xml文件中的<code>&lt;properties&gt;</code>标签中添加子标签进行自定义属性，子标签的标签名就是属性名，子标签的标签体的内容就是属性值，例如:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">fm.username</span>&gt;</span>tom<span class="hljs-tag">&lt;/<span class="hljs-name">fm.username</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br></code></pre></td></tr></table></figure><p>那么我们在pom.xml中就可以使用${属性名}来获取属性值</p><h1 id="版本锁定"><a href="#版本锁定" class="headerlink" title="版本锁定"></a>版本锁定</h1><p>因为父工程在管理项目依赖的时候，需要管理非常多的依赖，而有很多依赖的版本都应该是相同的，比如spring框架的相关依赖都需要统一版本。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span>   <br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>     <br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>     <br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span> <br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>   <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>      <br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-beans<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>     <br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>   <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>      <br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>     <br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>      <br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>     <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>   <br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>       <br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>     <br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-expression<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>     <br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>   <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>   <br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>   <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果未进行版本锁定的话，我们修改spring框架的版本的时候，就需要手动将每一个依赖的版本都进行修改，这无疑是非常麻烦而且容易出错的操作</p><p>所谓版本锁定就是自定义一个属性，属性值就是要统一的版本，然后在<code>&lt;version&gt;</code>标签体中引入该属性值就行了。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">fm.spring.version</span>&gt;</span>4.0.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">fm.username</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;fm.spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-beans<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;fm.spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;fm.spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-expression<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;fm.spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;fm.spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br><span class="hljs-comment">&lt;!--进行版本锁定之后，如果有修改依赖版本的需求，则只需要取修改自定义属性的值就可以了--&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>maven</category>
      
    </categories>
    
    
    <tags>
      
      <tag>maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git使用指北</title>
    <link href="/posts/2581ce52/"/>
    <url>/posts/2581ce52/</url>
    
    <content type="html"><![CDATA[<blockquote><p>日常工作中，git操作不可或缺，一些常用命令已经充分熟练使用，不过一些配置还是需要用到的时候在看一眼，所幸就自己记录下来，再过一遍，加深印象。</p></blockquote><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="什么是git"><a href="#什么是git" class="headerlink" title="什么是git"></a>什么是git</h2><p>Git（读音为&#x2F;gɪt&#x2F;）是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。也是Linus Torvalds为了帮助管理Linux内核开发而开发的一个开放源码的版本控制软件。</p><h2 id="使用git能做什么"><a href="#使用git能做什么" class="headerlink" title="使用git能做什么"></a>使用git能做什么</h2><p>代码回溯：Git在管理文件过程中会记录日志，方便回退到历史版本。<br>版本切换：Git存在分支的概念，一个项目可以有多个分支（版本），可以任意切换。<br>多人协作：Git支持多人协作，即一个团队共同开发一个项目，每个团队成员负责一部分代码，通过Git就可以管理和协调。<br>远程备份：Git通过仓库管理文件，在Git中存在远程仓库，如果本地文件丢失还可以从远程仓库获取。</p><h2 id="git常用命令汇总"><a href="#git常用命令汇总" class="headerlink" title="git常用命令汇总"></a>git常用命令汇总</h2><p>git status查看文件状态<br>git add 文件名称将文件的修改加入暂存区<br>①git reset 文件名将暂存区的文件取消暂存<br>②git reset –hard “版本号”将暂存区的文件切换到指定版本<br>git commit -m “备注信息” 文件名将暂存区的文件修改提交到版本库<br>git log查看日志<br>git remote查看远程仓库<br>git remote add 远程仓库简称 远程仓库地址把本地仓库添加到远程<br>git clone “远程仓库地址”从远程仓库克隆<br>git push 远程仓库简称 分支名称将分支推送到远程<br>git pull从远程仓库拉取<br>git branch列出所有本地分支<br>git branch -r列出所有远程分支<br>git branch -a列出所有本地分支和远程分支<br>git checkout 分支名称切换分支<br>git merge 分支名称将两个分支文件进行合并<br>git tag查看标签<br>git tag 标签名称创建标签<br>git push origin 分支名称将标签推送到远程仓库<br>git checkout -b 分支名 标签名检出标签</p><h1 id="git概述"><a href="#git概述" class="headerlink" title="git概述"></a>git概述</h1><h2 id="git简介"><a href="#git简介" class="headerlink" title="git简介"></a>git简介</h2><p>Git 是一个分布式版本控制工具，通常用来对软件开发过程中的源代码文件进行管理。通过Git 仓库来存储和管理这些文件，Git仓库分为两种：</p><ul><li>本地仓库：开发人员自己电脑上的 Git 仓库</li><li>远程仓库：远程服务器上的 Git 仓库</li><li><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151114525.png"></li></ul><p>commit：提交,将本地文件和版本信息保存到本地仓库<br>push：推送,将本地仓库文件和版本信息上传到远程仓库<br>pull：拉取,将远程仓库文件和版本信息下载到本地仓库</p><h1 id="git常用命令"><a href="#git常用命令" class="headerlink" title="git常用命令"></a>git常用命令</h1><h2 id="git全局设置"><a href="#git全局设置" class="headerlink" title="git全局设置"></a>git全局设置</h2><p>当安装Git后首先要做的事情是设置用户名称和email地址。这是非常重要的，因为每次Git提交都会使用该用户信息。在Git 命令行中执行下面命令：  </p><p>设置用户信息</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.name</span> <span class="hljs-string">&quot;aaa&quot;</span> <br>git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.email</span> <span class="hljs-string">&quot;aaa.email&quot;</span><br></code></pre></td></tr></table></figure><p>查看配置信息</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">git <span class="hljs-built_in">config</span> <span class="hljs-comment">--list</span><br></code></pre></td></tr></table></figure><h2 id="获取git仓库"><a href="#获取git仓库" class="headerlink" title="获取git仓库"></a>获取git仓库</h2><p>要使用Git对我们的代码进行管理，首先需要获得Git仓库。<br>获取Git仓库通常有两种方式：  </p><ul><li>在本地初始化Git仓库（不常用）  </li><li>从远程仓库克隆（常用）</li></ul><h3 id="在本地初始化仓库"><a href="#在本地初始化仓库" class="headerlink" title="在本地初始化仓库"></a>在本地初始化仓库</h3><p>操作步骤如下：<br>在任意目录下创建一个空目录（例如gitTest）作为我们的本地Git仓库<br>进入这个目录中，点击右键打开Git bash窗口  </p><p>执行命令</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">git <span class="hljs-keyword">init</span><br></code></pre></td></tr></table></figure><p>如果在当前目录中看到.git文件夹（此文件夹为隐藏文件夹）则说明Git仓库创建成功</p><h3 id="从远程仓库克隆"><a href="#从远程仓库克隆" class="headerlink" title="从远程仓库克隆"></a>从远程仓库克隆</h3><p>可以通过Git提供的命令从远程仓库进行克隆，将远程仓库克隆到本地<br>命令格式：git clone 远程仓库地址</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151117285.png"></p><h2 id="工作区、暂存区、版本库"><a href="#工作区、暂存区、版本库" class="headerlink" title="工作区、暂存区、版本库"></a>工作区、暂存区、版本库</h2><p>为了更好的学习Git，我们需要了解Git相关的一些概念，这些概念在后面的学习中会经常提到。<br><strong>版本库</strong>：前面看到的.git隐藏文件夹就是版本库，版本库中存储了很多配置信息、日志信息和文件版本信息等<br><strong>工作区</strong>：包含.git文件夹的目录就是工作区，也称为工作目录，主要用于存放开发的代码<br><strong>暂存区</strong>：.git文件夹中有很多文件，其中有一个index文件就是暂存区，也可以叫做stage。暂存区是一个临时保存修改文件的地方。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151118350.png"></p><h2 id="git工作区中文件的状态"><a href="#git工作区中文件的状态" class="headerlink" title="git工作区中文件的状态"></a>git工作区中文件的状态</h2><p>Git工作区中的文件存在两种状态：<br>untracked 未跟踪（未被纳入版本控制）：文件是新创建的，git没有去管理它<br>tracked 已跟踪（被纳入版本控制）<br>（1）Unmodified 未修改状态<br>（2）Modified 已修改状态<br>（3）Staged 已暂存状态</p><p>注意：文件的状态会随着我们执行Git的命令发生变化</p><h2 id="本地仓库操作"><a href="#本地仓库操作" class="headerlink" title="本地仓库操作"></a>本地仓库操作</h2><h3 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h3><p>此时远程克隆仓库的文件状态（我们新建了user.java与user.xml文件）：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151120980.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151120790.png"></p><h3 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h3><p>git add 命令的作用是将文件的修改加入暂存区。<br>命令格式：git add fileName<br>加入暂存区后再执行 git status 命令，可以发现文件的状态已经发生变化。<br>执行add命令后查看状态：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151121480.png"></p><h3 id="取消暂存"><a href="#取消暂存" class="headerlink" title="取消暂存"></a>取消暂存</h3><p>git reset 命令的作用是将暂存区的文件取消暂存或者是切换到指定版本<br>取消暂存命令格式：<code>git reset 文件名</code></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151122824.png"></p><h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h3><p>git commit 命令的作用是将暂存区的文件修改提交到版本库<br>命令格式：git commit -m “备注信息” 文件名<br>提交了user.java文件之后，就只剩下了一个未暂存的user.xml</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151123519.png"></p><h3 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h3><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151124372.png"></p><p>通过git log命令查看日志，可以发现每次提交都会产生一个版本号，提交时设置的message、提交人、邮箱、提交时间等信息都会记录到日志中</p><h3 id="切换版本"><a href="#切换版本" class="headerlink" title="切换版本"></a>切换版本</h3><p>每次提交到版本库，都会生成对应的版本号，可以根据版本号切换到指定版本。</p><p>切换到指定版本命令格式：<code>git reset --hard 版本号</code></p><h2 id="远程仓库操作"><a href="#远程仓库操作" class="headerlink" title="远程仓库操作"></a>远程仓库操作</h2><h3 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h3><p>如果要查看已经配置的远程仓库服务器，可以执行 git remote 命令，它会列出每一个远程服务器的简称。<br>如果已经克隆了远程仓库， 至少能够看到origin，这是Git克隆的仓库服务器的默认名字。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151127586.png"></p><h3 id="git-remote-add"><a href="#git-remote-add" class="headerlink" title="git remote add"></a>git remote add</h3><p>添加远程仓库命令格式：git remote add 简称 远程仓库地址<br>把本地仓库添加到远程，远程仓库的默认名称为origin</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151127673.png"></p><h3 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h3><p>就是克隆远端仓库。</p><h3 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h3><p>将本地仓库内容推送到远程仓库。<br>命令格式：<code>git push 远程仓库简称 分支名称</code></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151128020.png"></p><h3 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h3><p>git pull 命令的作用是从远程仓库获取最新版本并合并到本地仓库<br>命令格式：git pull 远程仓库简称 分支名称<br>在本地初始化一个新的repo仓库，并在此仓库中创建new.java文件。然后把此仓库添加到远程仓库（远程仓库依然是我们上文中用到的ceshi仓库）。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151129048.png"></p><h2 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h2><p>分支是Git 使用过程中非常重要的概念。使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。<br>本地仓库和远程仓库中都有分支，同一个仓库可以有多个分支，各个分支相互独立，互不干扰。<br>通过git init 命令创建本地仓库时默认会创建一个master分支。</p><h3 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h3><p>查看分支命令：git branch<br>git branch 列出所有本地分支<br>git branch -r 列出所有远程分支<br>git branch -a 列出所有本地分支和远程分支<br>此时再回到我们的ceshi文件夹（也就是从远程拉取下来的ceshi仓库）</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151129272.png"></p><h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><p>创建分支命令格式：<code>git branch 分支名称</code></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151130249.png"></p><h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><p>一个仓库中可以有多个分支。<br>切换分支命令格式：<code>git checkout 分支名称</code></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151130374.png"></p><h3 id="推送至远程仓库分支"><a href="#推送至远程仓库分支" class="headerlink" title="推送至远程仓库分支"></a>推送至远程仓库分支</h3><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151131849.png"></p><h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><p>合并分支就是将两个分支的文件进行合并处理。<br>令格式：&#96;git merge 分支名称  &#96;&#96;<br>此时我们把user.java中的文件修改为(此时我们已经切换到b1分支)并把b1分支提交推送至远程仓库:</p><p>如果要做的是把b1合并到master，需要先切换到master分支</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151132755.png"></p><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>Git 中的标签，指的是某个分支某个特定时间点的状态。通过标签，可以很方便的切换到标记时的状态。</p><h3 id="查看标签"><a href="#查看标签" class="headerlink" title="查看标签"></a>查看标签</h3><p>查看标签命令：<code>git tag</code></p><h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3><p>命令格式: <code>git tag 标签名称</code></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151133424.png"></p><h3 id="将标签推送到远程仓库"><a href="#将标签推送到远程仓库" class="headerlink" title="将标签推送到远程仓库"></a>将标签推送到远程仓库</h3><p>命令格式：<code>git push origin 标签名称</code></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151134365.png"></p><h3 id="检出标签"><a href="#检出标签" class="headerlink" title="检出标签"></a>检出标签</h3><p>检出标签时需要新建一个分支来指向某个标签，<br>检出标签的命令格式：<code>git checkout -b 分支名 标签名  </code><br>标签完成之后，就不会再修改了。</p><p>检出标签就是在这个标签的基础上进行其他的开发或操作。<br>检出标签的操作实质 ： 就是以标签指定的版本为基础版本，新建一个分支，继续其他的操作。因此 ，就是新建分支的操作了。</p>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jenkins自动化与持续集成</title>
    <link href="/posts/aeac244/"/>
    <url>/posts/aeac244/</url>
    
    <content type="html"><![CDATA[<blockquote><p>最近因为工作需要接触了jenkins这个东西，所以花点时间了解了下。它可以在代码上传仓库（如github,gitee，gitlab）后，在jenkins（一个网站界面）中通过获取代码仓库中最新代码，进行自动化部署，而省去手动打包、上传服务器、部署这一系列步骤，非常方便。</p></blockquote><hr><h2 id="一、jenkins"><a href="#一、jenkins" class="headerlink" title="一、jenkins"></a>一、jenkins</h2><p>Jenkins是一个开源的、提供友好操作界面的持续集成(CI)工具，起源于Hudson（Hudson是商用的），主要用于持续、自动的构建&#x2F;测试软件项目、监控外部任务的运行（这个比较抽象，暂且写上，不做解释）。Jenkins用Java语言编写，可在Tomcat等流行的servlet容器中运行，也可独立运行。通常与版本管理工具(SCM)、构建工具结合使用。常用的版本控制工具有SVN、GIT，构建工具有Maven、Ant、Gradle。</p><h2 id="二、CI-x2F-CD"><a href="#二、CI-x2F-CD" class="headerlink" title="二、CI&#x2F;CD"></a>二、CI&#x2F;CD</h2><p><strong>CI</strong>(Continuous integration，中文意思是<strong>持续集成</strong>)是一种软件开发时间。持续集成强调开发人员提交了新代码之后，立刻进行构建、（单元）测试。根据测试结果，我们可以确定新代码和原有代码能否正确地集成在一起。借用网络图片对CI加以理解。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142245060.png"></p><p><strong>CD</strong>(Continuous Delivery， 中文意思<strong>持续交付</strong>)是在持续集成的基础上，将集成后的代码部署到更贴近真实运行环境(类生产环境)中。比如，我们完成单元测试后，可以把代码部署到连接数据库的Staging环境中更多的测试。如果代码没有问题，可以继续手动部署到生产环境。下图反应的是CI&#x2F;CD 的大概工作模式。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142247157.png"></p><h2 id="三、使用Jenkins进行PHP代码-单元-测试、打包。"><a href="#三、使用Jenkins进行PHP代码-单元-测试、打包。" class="headerlink" title="三、使用Jenkins进行PHP代码(单元)测试、打包。"></a>三、使用Jenkins进行PHP代码(单元)测试、打包。</h2><p>Jenkins是一个强大的CI工具，虽然本身使用Java开发，但也能用来做其他语言开发的项目CI。下面讲解如何使用Jenkins创建一个构建任务。</p><p>登录Jenkins， 点击左侧的新建，创建新的构建任务。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142254198.png"></p><p>跳转到如下界面。任务名称可以自行设定，但需要全局唯一。输入名称后选择构建一个自由风格的软件项目(其他选项不作介绍)。并点击下方的确定按钮即创建了一个构建任务。之后会自动跳转到该job的配置页面。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142255408.png"></p><p>下图是构建任务设置界面，可以看到上方的几个选项**”General”, “源码管理”， “构建触发器”，”构建环境”， “构建”， “构建后操作”**。下面逐一介绍。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142255825.png"></p><h3 id="1-General"><a href="#1-General" class="headerlink" title="1.General"></a>1.General</h3><p>General是构建任务的一些基本配置。名称，描述之类的。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151036745.png"></p><p><strong>项目名称:</strong> 是刚才创建构建任务步骤设置的，当然在这里也可以更改。</p><p><strong>描述:</strong> 对构建任务的描述。</p><p><strong>丢弃旧的构建：</strong> 服务器资源是有限的，有时候保存了太多的历史构建，会导致Jenkins速度变慢，并且服务器硬盘资源也会被占满。当然下方的”保持构建天数” 和 保持构建的最大个数是可以自定义的，需要根据实际情况确定一个合理的值。</p><p>其他几个选项在这里不做介绍，有兴趣的可以查看Jenkins”帮助信息”， 会有一个大概的介绍。</p><h3 id="2-源码管理"><a href="#2-源码管理" class="headerlink" title="2.源码管理"></a>2.源码管理</h3><p>源码管理就是配置你代码的存放位置。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151037862.png"></p><p><strong>Git:</strong> 支持主流的github 和gitlab代码仓库。因我们的研发团队使用的是gitlab，所以下面我只会对该项进行介绍。</p><p><strong>Repository URL</strong>：仓库地址</p><p><strong>Credentials</strong>：凭证。可以使用HTTP方式的用户名密码，也可以是RSA文件。 但要通过后面的”ADD”按钮添加凭证。</p><p><strong>Branches to build</strong>：构建的分支。*&#x2F;master表示master分支，也可以设置为其他分支。</p><p><strong>源码浏览器</strong>：你所使用的代码仓库管理工具，如github, gitlab.</p><p><strong>URL</strong>：填入上方的仓库地址即可。</p><p><strong>Version: 8.7</strong> 这个是我们gitlab服务器的版本。</p><p><strong>Subversion：</strong>就是SVN，这里不作介绍。</p><h3 id="3-构建触发器"><a href="#3-构建触发器" class="headerlink" title="3.构建触发器"></a><strong>3.构建触发器</strong></h3><p>构建触发器，顾名思义，就是构建任务的触发器。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151038908.png"></p><p><strong>触发远程构建(例如，使用脚本):</strong> 该选项会提供一个接口，可以用来在代码层面触发构建。这里不做介绍，后期可能会用到。</p><p><strong>Build after other projects are built：</strong> 该选项意思是”在其他projects构建后构建”。这里不作介绍，后期可能会用到该选项。</p><p><strong>Build periodically：</strong> 周期性的构建。很好理解，就是每隔一段时间进行构建。日程表类似 linux crontab书写格式。如下图的设置，表示每隔30分钟进行一次构建。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151039022.png"></p><p><strong>Build when a change is pushed to GitLab：</strong>当有更改push到gitlab代码仓库，即触发构建。后面会有一个触发构建的地址，一般被称为webhooks。需要将这个地址配置到gitlab中，webhooks如何配置后面介绍。这个是常用的构建触发器。</p><p><strong>Poll SCM：</strong>该选项是配合上面这个选项使用的。当代码仓库发生改动，jenkins并不知道。需要配置这个选项，周期性的去检查代码仓库是否发生改动。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151039070.png"></p><h3 id="4-构建环境"><a href="#4-构建环境" class="headerlink" title="4.构建环境"></a>4.构建环境</h3><p>构建环境就是构建之前的一些准备工作，如指定构建工具(在这里我使用ant)。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151040319.png"></p><p>构建环境中的构建工具</p><p><strong>With Ant：</strong>选择这个工具，并指定ant版本和jdk版本。这两个工具的版本我都事先在服务器上安装，并且在jenkins全局工具中配置好了。</p><p>其他选项不作介绍，同样可以查看”帮助信息” 获得使用帮助。</p><h3 id="5-构建"><a href="#5-构建" class="headerlink" title="5.构建"></a>5.构建</h3><p>选择下方的增加构建步骤。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151041108.png"></p><p>增加构建步骤</p><p>可以选择的项很多。这里就介绍”Invoke Ant” 和”Execute shell”.</p><p><strong>Eexcute shell</strong>： 执行shell命令，该工具是针对linux环境的，windows环境也有对应的工 具”Execute Windows batch command”。 在构建之前，可能我们需要执行一些命令，比如压缩包的解压之类的。为了演示，我就简单的执行 “echo $RANDOM” 这样的linux shell下生产随机数命令。</p><p><strong>Invoke Ant</strong>：Ant是一款java项目构建工具，当然也能用来构建php。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151041091.png"></p><p><strong>Ant Version</strong>： 选择Ant版本。这个ant版本是安装在jenkins服务器上的版本，并且需要在jenkins”系统工具”中设置好。</p><p><strong>Targets</strong>：要执行的操作，一行一个操作任务。以上图为例，build是构建，tar是打包。</p><p><strong>Build File:</strong> 是Ant构建的配置文件，如果不指定，则是在项目路径下的workspace目录中的build.xml。build.xml文件具体怎么配置，后面再细讲。</p><p><strong>properties:</strong> 设定一些变量，这些变量可以在build.xml 中被引用。</p><p><strong>Send files or execute commands over SSH：</strong>发送文件到远程主机或执行命令(脚本)</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151042528.png"></p><p><strong>Name</strong>: SSH Server的名称。SSH Server可以在jenkins-系统设置中配置。</p><p><strong>source files</strong>: 需要发送给远程主机的源文件。</p><p><strong>Remove prefix:</strong> 移除前面的路径。如果不设置这个参数，则远程主机会自动创建构建源 source files 包含的那个路径。</p><p><strong>Remote directory</strong>: 远程主机目录。</p><p><strong>Exec command</strong>：在远程主机上执行的命令，或者执行的脚本。</p><h3 id="6-构建后操作"><a href="#6-构建后操作" class="headerlink" title="6.构建后操作"></a><strong>6.构建后操作</strong></h3><p>构建后操作，就是对project构建完成后的一些后续操作，比如生成相应的代码测试报告。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151042195.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151042087.png"></p><p>邮件通知</p><p><strong>Publish Clover PHP Coverage Report：</strong>发布代码覆盖率xml格式的文件报告。路径会在”build.xml”文件中定义</p><p><strong>Publish HTML reports</strong>：发布代码覆盖率的HTML报告。</p><p><strong>Report Crap:</strong> 发布crap报告<strong>。</strong></p><p><strong>E-mail Notification:</strong> 邮件通知，构建完成后发邮件到指定的邮箱。</p><p><strong>以上配置完成后，点击保存。</strong></p><h3 id="7-其他相关配置"><a href="#7-其他相关配置" class="headerlink" title="7.其他相关配置"></a><strong>7.其他相关配置</strong></h3><p><strong>SSH Server配置</strong></p><p>登录jenkins – 系统管理 – 系统设置</p><p>配置请看下图</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151043329.png"></p><p>SSH SERVER</p><p><strong>SSH Servers:</strong> 由于jenkins服务器公钥文件我已经配置好，所以之后新增SSH Servers 只需要配置这一项即可。</p><p><strong>Name：</strong> 自定义，需要全局唯一。</p><p><strong>HostName:</strong> 主机名，直接用ip地址即可。</p><p><strong>Username:</strong> 新增Server的用户名，这里配置的是root。</p><p><strong>Remote Directory:</strong> 远程目录。jenkins服务器发送文件给新增的server默认是在这个目录。</p><h2 id="四、进行jenkins-project-构建"><a href="#四、进行jenkins-project-构建" class="headerlink" title="四、进行jenkins project 构建"></a>四、进行jenkins project 构建</h2><p>第一次配置好jenkins project之后，会自动触发一次构建。此后，每当有commit 提交到master分支（前面设置的是master分支，也可以设置为其他分支），就会触发一次构建。当然也可以在project页面手动触发构建。点击左边的”立即构建” 手动触发构建。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151044656.png"></p><h2 id="五、构建结果说明"><a href="#五、构建结果说明" class="headerlink" title="五、构建结果说明"></a>五、构建结果说明</h2><h3 id="构建状态"><a href="#构建状态" class="headerlink" title="构建状态"></a>构建状态</h3><p><strong>Successful蓝色</strong>：构建完成，并且被认为是稳定的。</p><p><strong>Unstable黄色</strong>：构建完成，但被认为是不稳定的。</p><p><strong>Failed红色</strong>：构建失败。</p><p><strong>Disable灰色</strong>：构建已禁用</p><h3 id="构建稳定性"><a href="#构建稳定性" class="headerlink" title="构建稳定性"></a>构建稳定性</h3><p>构建稳定性用天气表示：<strong>晴、晴转多云、多云、小雨、雷阵雨</strong>。天气越好表示构建越稳定，反之亦然。</p><h3 id="构建历史界面"><a href="#构建历史界面" class="headerlink" title="构建历史界面"></a>构建历史界面</h3><p><strong>console output：</strong> 输出构建的日志信息</p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jenkins</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mybatis and plus</title>
    <link href="/posts/85fa2e33/"/>
    <url>/posts/85fa2e33/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是mybatis"><a href="#什么是mybatis" class="headerlink" title="什么是mybatis"></a>什么是mybatis</h1><blockquote><p>它是一款持久层框架，用于简化JDBC开发。</p></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141840885.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141841587.png"></p><h1 id="mybatis快速入门"><a href="#mybatis快速入门" class="headerlink" title="mybatis快速入门"></a>mybatis快速入门</h1><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141841896.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141841285.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141842111.png"></p><h1 id="mybatis代理开发"><a href="#mybatis代理开发" class="headerlink" title="mybatis代理开发"></a>mybatis代理开发</h1><p>搞一个mapper接口</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141843057.png"></p><p>把UserMapper.xml放在同样包结构目录下</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141843579.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141843679.png"></p><h1 id="mybatis核心配置文件"><a href="#mybatis核心配置文件" class="headerlink" title="mybatis核心配置文件"></a>mybatis核心配置文件</h1><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141844577.png"></p><p>比如配置别名，就不需要填写前面的包名</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141844851.png"></p><h1 id="配置文件完成增删改查"><a href="#配置文件完成增删改查" class="headerlink" title="配置文件完成增删改查"></a>配置文件完成增删改查</h1><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141845271.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141845376.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141845963.png"></p><p>多条件的可以看图，可以三种。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141845216.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141846686.png"></p><p><strong>单条件动态查询</strong></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141846009.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141847577.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141847212.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141847396.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141847217.png"></p><h1 id="注解完成增删改查"><a href="#注解完成增删改查" class="headerlink" title="注解完成增删改查"></a>注解完成增删改查</h1><p>就是把sql从xml换到注解里面书写。不过复杂的sql还是是推荐用xml来写。</p><h2 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h2><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141848767.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141849250.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141849832.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141849711.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141849859.png"></p><h1 id="什么是mybatis-plus"><a href="#什么是mybatis-plus" class="headerlink" title="什么是mybatis-plus"></a>什么是mybatis-plus</h1><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142159798.png"></p><p>其实工作中，大多数情况都是单表的CRUD简单查询，借助Mybatis-Plus可以通过简单配置，即可快速进行单表CRUD操作，从而节省大量时间。功能丰富，分页就是一个 插件。代码生成也很优秀。</p><h1 id="mp快速入门"><a href="#mp快速入门" class="headerlink" title="mp快速入门"></a>mp快速入门</h1><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142200669.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142200352.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142200893.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142200088.png"></p><blockquote><p>然后把xml里面的sql全部干掉，mapper里面的方法也不需要了，有爹了（BaseMapper）！</p></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142201487.png"></p><h1 id="常见注解"><a href="#常见注解" class="headerlink" title="常见注解"></a>常见注解</h1><p><strong>约定大于配置</strong></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142202253.png"></p><p>但有时候，名字不一致不符合约定，就需要一些注解来标柱。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142202647.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142202927.png"></p><h1 id="常见配置"><a href="#常见配置" class="headerlink" title="常见配置"></a>常见配置</h1><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142203813.png"></p><p>一般不需要配置，都走默认，需要的话看官网。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142203718.png"></p><h1 id="核心功能-条件构造器"><a href="#核心功能-条件构造器" class="headerlink" title="核心功能-条件构造器"></a>核心功能-条件构造器</h1><p>前面经历的都是通过主键id进行的CRUD，但是真是业务中，很多都是通过各种条件来CRUD，所以MP提供了条件构造器。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142204175.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142204733.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142205586.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142205232.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142206514.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142206748.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142206390.png"></p><p>为什么有了QueryWrapper、UpdateWrapper还需要Lambda~Wrapper呢，是因为，目前写的代码还存在硬编码，它基于lambda语法，能避免硬编码！</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142206898.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142206839.png"></p><h1 id="核心功能-自定义SQL"><a href="#核心功能-自定义SQL" class="headerlink" title="核心功能-自定义SQL"></a>核心功能-自定义SQL</h1><p>Mp已经提供了便捷的增删改查，并且提供了各种条件构造器，为什么还要自定义呢？</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142207991.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142207626.png"></p><p>纯xml还好，如果用mp的UpdateWrapper实现，”balance &#x3D; balance - 200”相当于业务代码，在<strong>业务代码中有sql操作是不合理的</strong>。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142208123.png"></p><p>这种也是，select中 count还起<strong>别名</strong>，如果还是<strong>硬编码</strong>就违背了开发规范。要是不用mp的话又会很麻烦，那就没有俩全的方案吗，答案就是自定义SQL。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142210892.png"></p><p><strong>保证了不在业务层编写sql 遵循了开发规范，同时又享受到了MP生成sql条件的便捷的特性。</strong></p><h1 id="核心功能-Service接口"><a href="#核心功能-Service接口" class="headerlink" title="核心功能-Service接口"></a>核心功能-Service接口</h1><p>UserMapper继承了MP提供的BaseMapper，dao层的CRUD代码不用写了，很爽。<br>现在还有一个Service接口，有了它，Service层的代码也不用写了！！！</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142212532.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142212376.png"></p><p><strong>其实就是service调用mapper里面的实现。</strong></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142214968.png"></p><h1 id="Service开发业务接口"><a href="#Service开发业务接口" class="headerlink" title="Service开发业务接口"></a>Service开发业务接口</h1><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142215893.png"></p><h1 id="扩展功能-代码生成"><a href="#扩展功能-代码生成" class="headerlink" title="扩展功能-代码生成"></a>扩展功能-代码生成</h1><p>现在使用MP需要一下这些步骤，是相对固定的</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142216921.png"></p><p>如果不是User表，而是Order表，是可以自动生成的。可以使用<strong>MyBatisPlus插件，它是Idea插件</strong>，很好用。</p><p><strong>第一步</strong>，连接数据库</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142217696.png"></p><p><strong>第二步</strong>，配置生成代码的配置</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142217225.png"></p><p><strong>cool</strong></p><h1 id="扩展功能-DB静态工具"><a href="#扩展功能-DB静态工具" class="headerlink" title="扩展功能-DB静态工具"></a>扩展功能-DB静态工具</h1><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142218597.png"></p><p>IService里面的方法都是非静态的，DB静态工具都是静态的，没有泛型。所以会多一个参数，就是Class字节码，它得知道是什么类型。需要告诉他实体类类型，其他与IService接口无区别。  但是还是有应用场景的。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142218714.png"></p><blockquote><p>有些业务，需要在UserService里面查Address，就需要注入AddressService，有些业务需要在AddressService中注入UserService，就会产生循环依赖。就可以通过静态工具来解决，不需要注入。</p></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142219561.png"></p><h1 id="扩展功能-逻辑删除"><a href="#扩展功能-逻辑删除" class="headerlink" title="扩展功能-逻辑删除"></a>扩展功能-逻辑删除</h1><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142220735.png"></p><p>那每个语句都要改么，不用，他会<strong>自动修改CRUD语句</strong>。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142221812.png"></p><p>配置之后，即便是remove删除方法，它也会自动转换成update语句，把逻辑删除自动置位已删除。</p><h1 id="扩展功能-JSON处理器"><a href="#扩展功能-JSON处理器" class="headerlink" title="扩展功能-JSON处理器"></a>扩展功能-JSON处理器</h1><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142224983.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142224473.png"></p><p><strong>开启自动的实体与java对象的映射。</strong></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142224075.png"></p><h1 id="扩展功能-分页插件"><a href="#扩展功能-分页插件" class="headerlink" title="扩展功能-分页插件"></a>扩展功能-分页插件</h1><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142225156.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142225480.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142225835.png"></p><p><strong>核心代码实现如下</strong></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142226782.png"></p>]]></content>
    
    
    <categories>
      
      <category>mybatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mybatis</tag>
      
      <tag>mybatis-plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring深入理解</title>
    <link href="/posts/8358769a/"/>
    <url>/posts/8358769a/</url>
    
    <content type="html"><![CDATA[<h2 id="Spring基础"><a href="#Spring基础" class="headerlink" title="Spring基础"></a>Spring基础</h2><h3 id="什么是spring框架"><a href="#什么是spring框架" class="headerlink" title="什么是spring框架"></a>什么是spring框架</h3><p>Spring 是一款开源的轻量级 Java 开发框架，旨在提高开发人员的开发效率以及系统的可维护性。</p><p>我们一般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发，比如说 Spring 支持 IoC（Inverse of Control:控制反转） 和 AOP(Aspect-Oriented Programming:面向切面编程)、可以很方便地对数据库进行访问、可以很方便地集成第三方组件（电子邮件，任务，调度，缓存等等）、对单元测试支持比较好、支持 RESTful Java 应用程序的开发。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141045694.png"></p><p>Spring 最核心的思想就是不重新造轮子，开箱即用，提高开发效率。<br>Spring 提供的核心功能主要是 IoC 和 AOP。学习 Spring ，一定要把 IoC 和 AOP 的核心思想搞懂！</p><h3 id="Spring-主要模块"><a href="#Spring-主要模块" class="headerlink" title="Spring 主要模块"></a>Spring 主要模块</h3><p>Spring4.x版本</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141046323.png"></p><p>spring5.x版本</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141047202.png"></p><p>Spring5.x 版本中 Web 模块的 Portlet 组件已经被废弃掉，同时增加了用于异步响应式处理的 WebFlux 组件。</p><p>Spring 各个模块的依赖关系</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141047722.png"></p><h3 id="Core-Container"><a href="#Core-Container" class="headerlink" title="Core Container"></a>Core Container</h3><p>Spring 框架的核心模块，也可以说是基础模块，主要提供 IoC 依赖注入功能的支持。Spring 其他所有的功能基本都需要依赖于该模块，我们从上面那张 Spring 各个模块的依赖关系图就可以看出来。</p><ul><li><strong>spring-core</strong> ：Spring 框架基本的核心工具类。</li><li><strong>spring-beans</strong> ：提供对 bean 的创建、配置和管理等功能的支持。</li><li><strong>spring-context</strong> ：提供对国际化、事件传播、资源加载等功能的支持。</li><li><strong>spring-expression</strong> ：提供对表达式语言（Spring Expression Language） SpEL 的支持，只依赖于 core 模块，不依赖于其他模块，可以单独使用。</li></ul><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><ul><li><strong>spring-aspects</strong> ：该模块为与 AspectJ 的集成提供支持。</li><li><strong>spring-aop</strong> ：提供了面向切面的编程实现。</li><li><strong>spring-instrument</strong> ：提供了为 JVM 添加代理（agent）的功能。 具体来讲，它为 Tomcat 提供了一个织入代理，能够为 Tomcat 传递类文 件，就像这些文件是被类加载器加载的一样。没有理解也没关系，这个模块的使用场景非常有限。</li></ul><h3 id="Data-Access-x2F-Integration"><a href="#Data-Access-x2F-Integration" class="headerlink" title="Data Access&#x2F;Integration"></a>Data Access&#x2F;Integration</h3><ul><li><strong>spring-jdbc</strong> ：提供了对数据库访问的抽象 JDBC。不同的数据库都有自己独立的 API 用于操作数据库，而 Java 程序只需要和 JDBC API 交互，这样就屏蔽了数据库的影响。</li><li><strong>spring-tx</strong> ：提供对事务的支持。</li><li><strong>spring-orm</strong> ： 提供对 Hibernate、JPA 、iBatis 等 ORM 框架的支持。</li><li><strong>spring-oxm</strong> ：提供一个抽象层支撑 OXM(Object-to-XML-Mapping)，例如：JAXB、Castor、XMLBeans、JiBX 和 XStream 等。</li><li><strong>spring-jms</strong> : 消息服务。自 Spring Framework 4.1 以后，它还提供了对 spring-messaging 模块的继承。</li></ul><h3 id="Spring-Web"><a href="#Spring-Web" class="headerlink" title="Spring Web"></a>Spring Web</h3><ul><li><strong>spring-web</strong> ：对 Web 功能的实现提供一些最基础的支持。</li><li><strong>spring-webmvc</strong> ： 提供对 Spring MVC 的实现。</li><li><strong>spring-websocket</strong> ： 提供了对 WebSocket 的支持，WebSocket 可以让客户端和服务端进行双向通信。</li><li><strong>spring-webflux</strong> ：提供对 WebFlux 的支持。WebFlux 是 Spring Framework 5.0 中引入的新的响应式框架。与 Spring MVC 不同，它不需要 Servlet API，是完全异步。</li></ul><h3 id="Messaging"><a href="#Messaging" class="headerlink" title="Messaging"></a>Messaging</h3><p><strong>spring-messaging</strong> 是从 Spring4.0 开始新加入的一个模块，主要职责是为 Spring 框架集成一些基础的报文传送应用。</p><h3 id="Spring-Test"><a href="#Spring-Test" class="headerlink" title="Spring Test"></a>Spring Test</h3><p>Spring 团队提倡测试驱动开发（TDD）。有了控制反转 (IoC)的帮助，单元测试和集成测试变得更简单。</p><p>Spring 的测试模块对 JUnit（单元测试框架）、TestNG（类似 JUnit）、Mockito（主要用来 Mock 对象）、PowerMock（解决 Mockito 的问题比如无法模拟 final, static， private 方法）等等常用的测试框架支持的都比较好。</p><h3 id="Spring-Spring-MVC-Spring-Boot-之间的关系"><a href="#Spring-Spring-MVC-Spring-Boot-之间的关系" class="headerlink" title="Spring,Spring MVC,Spring Boot 之间的关系"></a>Spring,Spring MVC,Spring Boot 之间的关系</h3><p>很多人对 Spring,Spring MVC,Spring Boot 这三者傻傻分不清楚！这里简单介绍一下这三者，其实很简单，没有什么高深的东西。</p><p>Spring 包含了多个功能模块（上面刚刚提高过），其中最重要的是 Spring-Core（主要提供 IoC 依赖注入功能的支持） 模块， Spring 中的其他模块（比如 Spring MVC）的功能实现基本都需要依赖于该模块。</p><p>Spring MVC 是 Spring 中的一个很重要的模块，主要赋予 Spring 快速构建 MVC 架构的 Web 程序的能力。MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141053129.png"></p><p>使用 Spring 进行开发各种配置过于麻烦比如开启某些 Spring 特性时，需要用 XML 或 Java 进行显式配置。于是，Spring Boot 诞生了！</p><p>Spring 旨在简化 J2EE 企业应用程序开发。Spring Boot 旨在简化 Spring 开发（减少配置文件，开箱即用！）。</p><p>Spring Boot 只是简化了配置，如果你需要构建 MVC 架构的 Web 程序，你还是需要使用 Spring MVC 作为 MVC 框架，只是说 Spring Boot 帮你简化了 Spring MVC 的很多配置，真正做到开箱即用！</p><h2 id="Spring-IOC"><a href="#Spring-IOC" class="headerlink" title="Spring IOC"></a>Spring IOC</h2><h3 id="对Spring-IOC-的了解"><a href="#对Spring-IOC-的了解" class="headerlink" title="对Spring IOC 的了解"></a>对Spring IOC 的了解</h3><p><strong>IoC（Inverse of Control:控制反转）</strong> 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。不过， IoC 并非 Spring 特有，在其他语言中也有应用。</p><p><strong>为什么叫控制反转？</strong></p><ul><li><strong>控制</strong> ：指的是对象创建（实例化、管理）的权力</li><li><strong>反转</strong> ：控制权交给外部环境（Spring 框架、IoC 容器）</li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141054462.png"></p><p>将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件&#x2F;注解即可，完全不用考虑对象是如何被创建出来的。</p><p>在实际项目中一个 Service 类可能依赖了很多其他的类，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IoC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。</p><p>在 Spring 中， IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个 Map（key，value），Map 中存放的是各种对象。</p><p>Spring 时代我们一般通过 XML 文件来配置 Bean，后来开发人员觉得 XML 文件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流行起来。</p><h3 id="IOC容器启动流程"><a href="#IOC容器启动流程" class="headerlink" title="IOC容器启动流程"></a>IOC容器启动流程</h3><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403171310656.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403171311724.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403171311253.png"></p><h3 id="什么是-Spring-Bean？"><a href="#什么是-Spring-Bean？" class="headerlink" title="什么是 Spring Bean？"></a>什么是 Spring Bean？</h3><p>简单来说，Bean 代指的就是那些被 IoC 容器所管理的对象。</p><p>我们需要告诉 IoC 容器帮助我们管理哪些对象，这个是通过配置元数据来定义的。配置元数据可以是 XML 文件、注解或者 Java 配置类。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- Constructor-arg with &#x27;value&#x27; attribute --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;...&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;...&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>下图简单地展示了 IoC 容器如何使用配置元数据来管理对象。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141056861.png"></p><p>org.springframework.beans和 org.springframework.context 这两个包是 IoC 实现的基础，如果想要研究 IoC 相关的源码的话，可以去看看</p><h3 id="将一个类声明为-Bean-的注解有哪些"><a href="#将一个类声明为-Bean-的注解有哪些" class="headerlink" title="将一个类声明为 Bean 的注解有哪些?"></a>将一个类声明为 Bean 的注解有哪些?</h3><ul><li>@Component ：通用的注解，可标注任意类为 Spring 组件。如果一个 Bean 不知道属于哪个层，可以使用@Component 注解标注。</li><li>@Repository : 对应持久层即 Dao 层，主要用于数据库相关操作。</li><li>@Service : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。</li><li>@Controller : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。</li></ul><h3 id="Component-和-Bean-的区别是什么？"><a href="#Component-和-Bean-的区别是什么？" class="headerlink" title="@Component 和 @Bean 的区别是什么？"></a>@Component 和 @Bean 的区别是什么？</h3><ul><li>@Component 注解作用于类，而@Bean注解作用于方法。</li><li>@Component通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中（我们可以使用 @ComponentScan 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。@Bean 注解通常是我们在标有该注解的方法中定义产生这个 bean,@Bean告诉了 Spring 这是某个类的实例，当我需要用它的时候还给我。</li><li>@Bean 注解比 @Component 注解的自定义性更强，而且很多地方我们只能通过 @Bean 注解来注册 bean。比如当我们引用第三方库中的类需要装配到 Spring容器时，则只能通过 @Bean来实现。</li></ul><p>@Bean注解使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> TransferService <span class="hljs-title function_">transferService</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransferServiceImpl</span>();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码相当于下面的 xml 配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transferService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.acme.TransferServiceImpl&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>下面这个例子是通过 @Component 无法实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> OneService <span class="hljs-title function_">getService</span><span class="hljs-params">(status)</span> &#123;<br>    <span class="hljs-keyword">case</span> (status)  &#123;<br>        when <span class="hljs-number">1</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">serviceImpl1</span>();<br>        when <span class="hljs-number">2</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">serviceImpl2</span>();<br>        when <span class="hljs-number">3</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">serviceImpl3</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="注入-Bean-的注解有哪些？"><a href="#注入-Bean-的注解有哪些？" class="headerlink" title="注入 Bean 的注解有哪些？"></a>注入 Bean 的注解有哪些？</h3><p>Spring 内置的 <code>@Autowired</code> 以及 JDK 内置的 <code>@Resource</code> 和 <code>@Inject</code> 都可以用于注入 Bean。</p><table><thead><tr><th>Annotaion</th><th>Package</th><th>Source</th></tr></thead><tbody><tr><td>@Autowired</td><td>org.springframework.bean.factory</td><td>Spring 2.5+</td></tr><tr><td>@Resource</td><td>javax.annotation</td><td>Java JSR-250</td></tr><tr><td>@Inject</td><td>javax.inject</td><td>Java JSR-330</td></tr></tbody></table><p>@Autowired 和@Resource使用的比较多一些。</p><h3 id="Autowired-和-Resource-的区别是什么？"><a href="#Autowired-和-Resource-的区别是什么？" class="headerlink" title="@Autowired 和 @Resource 的区别是什么？"></a>@Autowired 和 @Resource 的区别是什么？</h3><p>Autowired 属于 Spring 内置的注解，默认的注入方式为byType（根据类型进行匹配），也就是说会优先根据接口类型去匹配并注入 Bean （接口的实现类）。</p><p><strong>这会有什么问题呢？</strong> 当一个接口存在多个实现类的话，byType这种方式就无法正确注入对象了，因为这个时候 Spring 会同时找到多个满足条件的选择，默认情况下它自己不知道选择哪一个。</p><p>这种情况下，注入方式会变为 byName（根据名称进行匹配），这个名称通常就是类名（首字母小写）。就比如说下面代码中的 smsService 就是我这里所说的名称，这样应该比较好理解了吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// smsService 就是我们上面所说的名称</span><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> SmsService smsService;<br></code></pre></td></tr></table></figure><p>举个例子，SmsService 接口有两个实现类: SmsServiceImpl1和 SmsServiceImpl2，且它们都已经被 Spring 容器所管理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 报错，byName 和 byType 都无法匹配到 bean</span><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> SmsService smsService;<br><br><span class="hljs-comment">// 正确注入 SmsServiceImpl1 对象对应的 bean</span><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> SmsService smsServiceImpl1;<br><br><span class="hljs-comment">// 正确注入  SmsServiceImpl1 对象对应的 bean</span><br><span class="hljs-comment">// smsServiceImpl1 就是我们上面所说的名称</span><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-meta">@Qualifier(value = &quot;smsServiceImpl1&quot;)</span><br><span class="hljs-keyword">private</span> SmsService smsService;<br></code></pre></td></tr></table></figure><p>还是建议通过 @Qualifier 注解来显示指定名称而不是依赖变量的名称。</p><p>@Resource属于 JDK 提供的注解，默认注入方式为 byName。如果无法通过名称匹配到对应的 Bean 的话，注入方式会变为byType。</p><p>@Resource 有两个比较重要且日常开发常用的属性：name（名称）、type（类型）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Resource &#123;<br>    String <span class="hljs-title function_">name</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>    Class&lt;?&gt; type() <span class="hljs-keyword">default</span> Object.class;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果仅指定 name 属性则注入方式为byName，如果仅指定type属性则注入方式为byType，如果同时指定name 和type属性（不建议这么做）则注入方式为byType+byName。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 报错，byName 和 byType 都无法匹配到 bean</span><br><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> SmsService smsService;<br><br><span class="hljs-comment">// 正确注入 SmsServiceImpl1 对象对应的 bean</span><br><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> SmsService smsServiceImpl1;<br><br><span class="hljs-comment">// 正确注入 SmsServiceImpl1 对象对应的 bean（比较推荐这种方式）</span><br><span class="hljs-meta">@Resource(name = &quot;smsServiceImpl1&quot;)</span><br><span class="hljs-keyword">private</span> SmsService smsService;<br></code></pre></td></tr></table></figure><p>简单总结一下：</p><ul><li>@Autowired 是 Spring 提供的注解，@Resource 是 JDK 提供的注解。</li><li>Autowired 默认的注入方式为byType（根据类型进行匹配），@Resource默认注入方式为 byName（根据名称进行匹配）。</li><li>当一个接口存在多个实现类的情况下，@Autowired 和@Resource都需要通过名称才能正确匹配到对应的 Bean。Autowired 可以通过 @Qualifier 注解来显示指定名称，@Resource可以通过 name 属性来显示指定名称。</li></ul><h3 id="Bean-的作用域有哪些"><a href="#Bean-的作用域有哪些" class="headerlink" title="Bean 的作用域有哪些?"></a>Bean 的作用域有哪些?</h3><p>Spring 中 Bean 的作用域通常有下面几种：</p><ul><li><strong>singleton</strong> : IoC 容器中只有唯一的 bean 实例。Spring 中的 bean 默认都是单例的，是对单例设计模式的应用。</li><li><strong>prototype</strong> : 每次获取都会创建一个新的 bean 实例。也就是说，连续 getBean() 两次，得到的是不同的 Bean 实例。</li><li><strong>request</strong> （仅 Web 应用可用）: 每一次 HTTP 请求都会产生一个新的 bean（请求 bean），该 bean 仅在当前 HTTP request 内有效。</li><li><strong>session</strong> （仅 Web 应用可用） : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean（会话 bean），该 bean 仅在当前 HTTP session 内有效。</li><li><strong>application&#x2F;global-session</strong> （仅 Web 应用可用）： 每个 Web 应用在启动时创建一个 Bean（应用 Bean），，该 bean 仅在当前应用启动时间内有效。</li><li><strong>websocket</strong> （仅 Web 应用可用）：每一次 WebSocket 会话产生一个新的 bean。</li></ul><p><strong>如何配置 bean 的作用域呢？</strong></p><p>xml方式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;singleton&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注解方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span><br><span class="hljs-keyword">public</span> Person <span class="hljs-title function_">personPrototype</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="单例-Bean-的线程安全问题了解吗？"><a href="#单例-Bean-的线程安全问题了解吗？" class="headerlink" title="单例 Bean 的线程安全问题了解吗？"></a>单例 Bean 的线程安全问题了解吗？</h3><p>大部分时候我们并没有在项目中使用多线程，所以很少有人会关注这个问题。单例 Bean 存在线程问题，主要是因为当多个线程操作同一个对象的时候是存在资源竞争的。</p><p>常见的有两种解决办法：</p><ol><li>在 Bean 中尽量避免定义可变的成员变量。</li><li>在类中定义一个 ThreadLocal 成员变量，将需要的可变成员变量保存在 ThreadLocal 中（推荐的一种方式）。</li></ol><p>不过，大部分 Bean 实际都是无状态（没有实例变量）的（比如 Dao、Service），这种情况下， Bean 是线程安全的。</p><h3 id="Bean-的生命周期了解么"><a href="#Bean-的生命周期了解么" class="headerlink" title="Bean 的生命周期了解么?"></a>Bean 的生命周期了解么?</h3><ul><li>Bean 容器找到配置文件中 Spring Bean 的定义。</li><li>Bean 容器利用 Java Reflection API 创建一个 Bean 的实例。</li><li>如果涉及到一些属性值 利用 set()方法设置一些属性值。</li><li>如果 Bean 实现了 BeanNameAware 接口，调用 setBeanName()方法，传入 Bean 的名字。</li><li>如果 Bean 实现了 BeanClassLoaderAware 接口，调用 setBeanClassLoader()方法，传入 ClassLoader对象的实例。</li><li>如果 Bean 实现了 BeanFactoryAware 接口，调用 setBeanFactory()方法，传入 BeanFactory对象的实例。</li><li>与上面的类似，如果实现了其他 *.Aware接口，就调用相应的方法。</li><li>如果有和加载这个 Bean 的 Spring 容器相关的 BeanPostProcessor 对象，执行postProcessBeforeInitialization() 方法</li><li>如果 Bean 实现了InitializingBean接口，执行afterPropertiesSet()方法。</li><li>如果 Bean 在配置文件中的定义包含 init-method 属性，执行指定的方法。</li><li>如果有和加载这个 Bean 的 Spring 容器相关的 BeanPostProcessor 对象，执行postProcessAfterInitialization() 方法</li><li>当要销毁 Bean 的时候，如果 Bean 实现了 DisposableBean 接口，执行 destroy() 方法。</li><li>当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含 destroy-method 属性，执行指定的方法。</li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141107712.png"></p><h3 id="Bean循环依赖"><a href="#Bean循环依赖" class="headerlink" title="Bean循环依赖"></a>Bean循环依赖</h3><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403171312607.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403171312858.png"></p><p>spring默认是不让循环依赖的，但也可以增加配置，让spring解决循环依赖的问题。这里的核心就是了解掌握spring是如何解决循环依赖的。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403171313094.png"></p><p>增加这个配置，就解决了，AB互相依赖的问题。<br>先说结论，DefaultSingletonBeanRegistry是解决循环依赖的核心。<strong>核心就是三个缓存区</strong>。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403171313983.png"><br>第三个缓存器其实也是为了解决动态代理的问题，不然两层缓存就可以了。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403171314890.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403171314672.png"></p><h2 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h2><h3 id="对Spring-AOP-的了解"><a href="#对Spring-AOP-的了解" class="headerlink" title="对Spring AOP 的了解"></a>对Spring AOP 的了解</h3><p>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p><p>Spring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 <strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理，如下图所示：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141510921.png"></p><p>当然你也可以使用 <strong>AspectJ</strong> ！Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。</p><p>AOP 切面编程设计到的一些专业术语</p><table><thead><tr><th>术语</th><th>含义</th></tr></thead><tbody><tr><td>目标(Target)</td><td>被通知的对象</td></tr><tr><td>代理(Proxy)</td><td>向目标对象应用通知之后创建的代理对象</td></tr><tr><td>连接点(JoinPoint)</td><td>目标对象的所属类中，定义的所有方法均为连接点</td></tr><tr><td>切入点(Pointcut)</td><td>被切面拦截 &#x2F; 增强的连接点（切入点一定是连接点，连接点不一定是切入点）</td></tr><tr><td>通知(Advice)</td><td>增强的逻辑 &#x2F; 代码，也即拦截到目标对象的连接点之后要做的事情</td></tr><tr><td>切面(Aspect)</td><td>切入点(Pointcut)+通知(Advice)</td></tr><tr><td>Weaving(织入)</td><td>将通知应用到目标对象，进而生成代理对象的过程动作</td></tr></tbody></table><h3 id="Spring-AOP-和-AspectJ-AOP-的区别"><a href="#Spring-AOP-和-AspectJ-AOP-的区别" class="headerlink" title="Spring AOP 和 AspectJ AOP 的区别"></a>Spring AOP 和 AspectJ AOP 的区别</h3><p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong> Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</p><p>Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，</p><p>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比 Spring AOP 快很多。</p><h3 id="AspectJ-定义的通知类型有哪些？"><a href="#AspectJ-定义的通知类型有哪些？" class="headerlink" title="AspectJ 定义的通知类型有哪些？"></a>AspectJ 定义的通知类型有哪些？</h3><ul><li><strong>Before</strong>（前置通知）：目标对象的方法调用之前触发</li><li><strong>After</strong> （后置通知）：目标对象的方法调用之后触发</li><li><strong>AfterReturning</strong>（返回通知）：目标对象的方法调用完成，在返回结果值之后触发</li><li><strong>AfterThrowing</strong>（异常通知） ：目标对象的方法运行中抛出 &#x2F; 触发异常后触发。AfterReturning 和 AfterThrowing 两者互斥。如果方法调用成功无异常，则会有返回值；如果方法抛出了异常，则不会有返回值。</li><li><strong>Around</strong>： （环绕通知）编程式控制目标对象的方法调用。环绕通知是所有通知类型中可操作范围最大的一种，因为它可以直接拿到目标对象，以及要执行的方法，所以环绕通知可以任意的在目标对象的方法调用前后搞事，甚至不调用目标对象的方法。</li></ul><h3 id="多个切面的执行顺序如何控制？"><a href="#多个切面的执行顺序如何控制？" class="headerlink" title="多个切面的执行顺序如何控制？"></a>多个切面的执行顺序如何控制？</h3><p>1、通常使用@Order 注解直接定义切面顺序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 值越小优先级越高</span><br><span class="hljs-meta">@Order(3)</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggingAspect</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Ordered</span> &#123;<br><br></code></pre></td></tr></table></figure><p><strong>2、实现Ordered 接口重写 getOrder 方法。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggingAspect</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Ordered</span> &#123;<br><br>    <span class="hljs-comment">// ....</span><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getOrder</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 返回值越小优先级越高</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h2><h3 id="对-Spring-MVC的了解"><a href="#对-Spring-MVC的了解" class="headerlink" title="对 Spring MVC的了解"></a>对 Spring MVC的了解</h3><p>MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141512947.png"></p><p><strong>Spring MVC 时代</strong></p><p>随着 Spring 轻量级开发框架的流行，Spring 生态圈出现了 Spring MVC 框架， Spring MVC 是当前最优秀的 MVC 框架。相比于 Struts2 ， Spring MVC 使用更加简单和方便，开发效率更高，并且 Spring MVC 运行速度更快。</p><p>MVC 是一种设计模式，Spring MVC 是一款很优秀的 MVC 框架。Spring MVC 可以帮助我们进行更简洁的 Web 层的开发，并且它天生与 Spring 框架集成。Spring MVC 下我们一般把后端项目分为 Service 层（处理业务）、Dao 层（数据库操作）、Entity 层（实体类）、Controller 层(控制层，返回数据给前台页面)。</p><h3 id="Spring-MVC-的核心组件有哪些？"><a href="#Spring-MVC-的核心组件有哪些？" class="headerlink" title="Spring MVC 的核心组件有哪些？"></a><strong>Spring MVC 的核心组件有哪些？</strong></h3><p>记住了下面这些组件，也就记住了 SpringMVC 的工作原理。</p><ul><li><strong>DispatcherServlet</strong> ：<strong>核心的中央处理器</strong>，负责接收请求、分发，并给予客户端响应。</li><li><strong>HandlerMapping</strong> ：<strong>处理器映射器</strong>，根据 uri 去匹配查找能处理的 Handler ，并会将请求涉及到的拦截器和 Handler 一起封装。</li><li><strong>HandlerAdapter</strong> ：<strong>处理器适配器</strong>，根据 HandlerMapping 找到的 Handler ，适配执行对应的 Handler；</li><li><strong>Handler</strong> ：<strong>请求处理器</strong>，处理实际请求的处理器。</li><li><strong>ViewResolver</strong> ：<strong>视图解析器</strong>，根据 Handler 返回的逻辑视图 &#x2F; 视图，解析并渲染真正的视图，并传递给 DispatcherServlet 响应客户端</li></ul><h3 id="SpringMVC-工作原理了解吗"><a href="#SpringMVC-工作原理了解吗" class="headerlink" title="SpringMVC 工作原理了解吗?"></a><strong>SpringMVC 工作原理了解吗?</strong></h3><p><strong>Spring MVC 原理如下图所示：</strong></p><blockquote><p>SpringMVC 工作原理的图解我没有自己画，直接图省事在网上找了一个非常清晰直观的，原出处不明。</p></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141513812.png"></p><p><strong>流程说明（重要）：</strong></p><ol><li>客户端（浏览器）发送请求， DispatcherServlet拦截请求。</li><li>DispatcherServlet 根据请求信息调用 HandlerMapping 。HandlerMapping 根据 uri 去匹配查找能处理的 Handler（也就是我们平常说的 Controller 控制器） ，并会将请求涉及到的拦截器和 Handler 一起封装。</li><li>DispatcherServlet 调用 HandlerAdapter适配执行 Handler 。</li><li>Handler 完成对用户请求的处理后，会返回一个 ModelAndView 对象给DispatcherServlet，ModelAndView 顾名思义，包含了数据模型以及相应的视图的信息。Model 是返回的数据对象，View 是个逻辑上的 View。</li><li>ViewResolver 会根据逻辑 View 查找实际的 View。</li><li>DispaterServlet 把返回的 Model 传给 View（视图渲染）。</li><li>把 View 返回给请求者（浏览器）</li></ol><h3 id="统一异常处理怎么做？"><a href="#统一异常处理怎么做？" class="headerlink" title="统一异常处理怎么做？"></a><strong>统一异常处理怎么做？</strong></h3><p>推荐使用注解的方式统一异常处理，具体会使用到 @ControllerAdvice + @ExceptionHandler 这两个注解 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ControllerAdvice</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GlobalExceptionHandler</span> &#123;<br><br>    <span class="hljs-meta">@ExceptionHandler(BaseException.class)</span><br>    <span class="hljs-keyword">public</span> ResponseEntity&lt;?&gt; handleAppException(BaseException ex, HttpServletRequest request) &#123;<br>      <span class="hljs-comment">//......</span><br>    &#125;<br><br>    <span class="hljs-meta">@ExceptionHandler(value = ResourceNotFoundException.class)</span><br>    <span class="hljs-keyword">public</span> ResponseEntity&lt;ErrorReponse&gt; <span class="hljs-title function_">handleResourceNotFoundException</span><span class="hljs-params">(ResourceNotFoundException ex, HttpServletRequest request)</span> &#123;<br>      <span class="hljs-comment">//......</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这种异常处理方式下，会给所有或者指定的 Controller 织入异常处理的逻辑（AOP），当 Controller 中的方法抛出异常的时候，由被@ExceptionHandler 注解修饰的方法进行处理。</p><p>ExceptionHandlerMethodResolver 中 getMappedMethod 方法决定了异常具体被哪个被 @ExceptionHandler 注解修饰的方法处理异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Nullable</span><br> <span class="hljs-keyword">private</span> Method <span class="hljs-title function_">getMappedMethod</span><span class="hljs-params">(Class&lt;? extends Throwable&gt; exceptionType)</span> &#123;<br>  List&lt;Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Throwable</span>&gt;&gt; matches = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-comment">//找到可以处理的所有异常信息。mappedMethods 中存放了异常和处理异常的方法的对应关系</span><br>  <span class="hljs-keyword">for</span> (Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Throwable</span>&gt; mappedException : <span class="hljs-built_in">this</span>.mappedMethods.keySet()) &#123;<br>   <span class="hljs-keyword">if</span> (mappedException.isAssignableFrom(exceptionType)) &#123;<br>    matches.add(mappedException);<br>   &#125;<br>  &#125;<br>    <span class="hljs-comment">// 不为空说明有方法处理异常</span><br>  <span class="hljs-keyword">if</span> (!matches.isEmpty()) &#123;<br>      <span class="hljs-comment">// 按照匹配程度从小到大排序</span><br>   matches.sort(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExceptionDepthComparator</span>(exceptionType));<br>      <span class="hljs-comment">// 返回处理异常的方法</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.mappedMethods.get(matches.get(<span class="hljs-number">0</span>));<br>  &#125;<br>  <span class="hljs-keyword">else</span> &#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br> &#125;<br><br></code></pre></td></tr></table></figure><p>从源代码看出：getMappedMethod()会首先找到可以匹配处理异常的所有方法信息，然后对其进行从小到大的排序，最后取最小的那一个匹配的方法(即匹配度最高的那个)。</p><h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><h3 id="SpringBoot自动配置原理"><a href="#SpringBoot自动配置原理" class="headerlink" title="SpringBoot自动配置原理"></a>SpringBoot自动配置原理</h3><p>Spring Boot 的核心理念是约定优于配置（Convention over Configuration），旨在通过提供一系列默认配置来简化应用程序的开发和部署。其中最重要的一个特性是自动配置（Auto-configuration）。</p><p>Spring Boot 的自动配置是基于 Spring 的条件化配置（Conditional Configuration）功能实现的。Spring Boot 会根据应用程序的依赖关系和其他一些因素来决定需要自动配置哪些组件，以及如何配置这些组件。</p><p>@EnableAutoConfiguration是Spring Boot自动配置的核心，其实现原理主要包括以下几个步骤：</p><p>Spring Boot在启动时，会扫描classpath下的META-INF&#x2F;spring.factories文件，并解析其中的EnableAutoConfiguration实现类。</p><p>Spring Boot将自动配置实现类加载到容器中，并对自动配置进行条件判断。条件不满足的自动配置将被过滤掉，只有满足条件的自动配置才会生效。</p><p>Spring Boot会根据当前应用所依赖的jar包，自动配置需要的Bean，如DataSource、JdbcTemplate等。</p><p>Spring Boot还提供了一些默认的配置，如端口号、上下文路径等，这些配置也是通过自动配置实现的。</p><p>总的来说，Spring Boot自动配置的原理就是利用@EnableAutoConfiguration和条件注解实现了对Bean的自动配置，并且提供了默认的配置，可以帮助开发者快速搭建一个基于Spring Boot的Web应用程序。</p><h3 id="Spring-Boot的核心注解是哪些"><a href="#Spring-Boot的核心注解是哪些" class="headerlink" title="Spring Boot的核心注解是哪些"></a>Spring Boot的核心注解是哪些</h3><p>Spring Boot 的核心注解主要包括：</p><p>@SpringBootApplication：一个复合注解，包括了@Configuration、@EnableAutoConfiguration 和 @ComponentScan 三个注解，用于标识 Spring Boot 应用的主类。</p><p>@Configuration：表明该类是一个 Java 配置类，用于定义 Spring Bean 的配置信息。</p><p>@EnableAutoConfiguration：自动配置注解，用于开启 Spring Boot 的自动配置功能。</p><p>@ComponentScan：用于自动扫描和注册 Spring Bean。</p><p>除此之外，还有一些常用的注解，如：</p><p>@RestController：用于定义 RESTful 接口，相当于 @Controller 和 @ResponseBody 的组合。</p><p>@RequestMapping：用于定义 HTTP 请求的映射，用于处理 HTTP 请求。</p><p>@Autowired：自动注入注解，用于自动装配 Spring Bean。</p><p>@Value：属性注入注解，用于注入配置文件中的属性值。</p><p>这些注解共同组成了 Spring Boot 应用的核心框架。</p><h3 id="SpringBoot的核心配置文件有哪几个"><a href="#SpringBoot的核心配置文件有哪几个" class="headerlink" title="SpringBoot的核心配置文件有哪几个"></a>SpringBoot的核心配置文件有哪几个</h3><p>Spring Boot的核心配置文件有以下几个：</p><p>application.properties</p><p>application.yml</p><p>bootstrap.properties</p><p>bootstrap.yml</p><p>其中，application.properties和application.yml是应用程序的配置文件，而bootstrap.properties和bootstrap.yml是用于Spring Boot上下文的配置文件。它们之间的区别在于加载的优先级不同，bootstrap配置文件的优先级更高，可以用于设置一些比较敏感和重要的配置信息。</p><p>application.properties是以键值对的形式进行配置的，例如</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">server.port=8080<br>spring.datasource.url=jdbc:mysql://localhost:3306/test<br></code></pre></td></tr></table></figure><p>application.yml则采用缩进的方式进行配置，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">server:<br>port: <span class="hljs-number">8080</span><br>spring:<br>datasource:<br>url: jdbc:mysql:<span class="hljs-comment">//localhost:3306/test</span><br><br></code></pre></td></tr></table></figure><p>在Spring Boot应用程序中，我们可以使用这些配置文件来配置应用程序、数据库、日志等方面的配置信息，简化了应用程序的配置过程。在Spring Boot中，这些配置文件的属性可以通过注解@Value注入到Java类中，并且可以通过@ConfigurationProperties注解来将一组属性绑定到一个类中。</p><h3 id="什么是Spring-Boot-Starter？有哪些常用的"><a href="#什么是Spring-Boot-Starter？有哪些常用的" class="headerlink" title="什么是Spring Boot Starter？有哪些常用的"></a>什么是Spring Boot Starter？有哪些常用的</h3><p>Spring Boot Starter是一种特殊的依赖关系，它是为了方便Spring Boot应用程序的快速启动和集成而设计的。一个Starter通常会包含多个相关的依赖库，以及自动配置和其他必要的配置文件，使得我们只需引入一个Starter依赖，即可快速地集成相关的技术或库。</p><p>常用的Spring Boot Starter包括：</p><p>spring-boot-starter-web：适用于开发Web应用程序的Starter，包含Spring MVC、Tomcat和Spring Boot Web自动配置等。</p><p>spring-boot-starter-data-jpa：适用于使用JPA的Starter，包含Hibernate、Spring Data JPA、Spring ORM等依赖。</p><p>spring-boot-starter-data-redis：适用于使用Redis的Starter，包含Jedis客户端和Spring Data Redis等依赖。</p><p>spring-boot-starter-test：适用于测试的Starter，包含JUnit、Mockito、Hamcrest、Spring Test等依赖。</p><p>spring-boot-starter-actuator：适用于监控和管理Spring Boot应用程序的Starter，包含Spring Boot Actuator和Spring Boot Web等依赖。</p><p>通过使用Spring Boot Starter，我们可以非常方便地集成常用的技术和库，大大提高了开发效率和便捷性。</p><h3 id="SpringBoot-打成jar和普通的jar有什么区别"><a href="#SpringBoot-打成jar和普通的jar有什么区别" class="headerlink" title="SpringBoot 打成jar和普通的jar有什么区别"></a>SpringBoot 打成jar和普通的jar有什么区别</h3><p>Spring Boot应用打成的jar和普通的jar包在打包的方式和使用方式上有一些区别。</p><p>首先，Spring Boot打成的jar包是一种可执行的jar包，包含了内嵌的Tomcat、Jetty等Web服务器，可以直接运行。而普通的jar包只包含类、资源等，需要在外部环境中手动配置Web服务器才能运行。</p><p>其次，Spring Boot打成的jar包中包含了启动类的main方法，可以直接运行该jar包来启动应用程序。而普通的jar包中没有默认的main方法，需要手动指定启动类来运行应用程序。</p><p>此外，Spring Boot打成的jar包还包含了一些默认的配置文件，例如application.properties或application.yml，这些文件可以用于配置应用程序的属性、数据源等信息。而普通的jar包不包含这些默认的配置文件。</p><p>最后，Spring Boot打成的jar包可以使用spring-boot-maven-plugin插件来打包，该插件可以帮助我们将应用程序的依赖项、配置文件等全部打包进一个可执行的jar包中，方便部署和运行。而普通的jar包需要手动处理依赖项、配置文件等，比较繁琐。</p><h3 id="springboot启动流程"><a href="#springboot启动流程" class="headerlink" title="springboot启动流程"></a>springboot启动流程</h3><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403171309407.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403171309936.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403171309299.png"></p>]]></content>
    
    
    <categories>
      
      <category>spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于Spring</title>
    <link href="/posts/ed0120ab/"/>
    <url>/posts/ed0120ab/</url>
    
    <content type="html"><![CDATA[<h2 id="一-Spring是什么"><a href="#一-Spring是什么" class="headerlink" title="一.Spring是什么"></a>一.Spring是什么</h2><p>Spring是一个开源的轻量级Java SE（Java 标准版本）&#x2F;Java EE（Java 企业版本）开发应用框架，其目的是用于简化企业级应用程序开发。</p><p>应用程序是由一组相互协作的对象组成。而在传统应用程序开发中，一个完整的应用是由一组相互协作的对象组成。</p><p>所以开发一个应用除了要开发业务逻辑之外，最多的是关注如何使这些对象协作来完成所需功能，而且要低耦合、高内聚。</p><p>业务逻辑开发是不可避免的，那如果有个框架出来帮我们来创建对象及管理这些对象之间的依赖关系。</p><p>可能有人说了，比如“抽象工厂、工厂方法设计模式”不也可以帮我们创建对象，“生成器模式”帮我们处理对象间的依赖关系，不也能完成这些功能吗？</p><p>可是这些又需要我们创建另一些工厂类、生成器类，我们又要而外管理这些类，增加了我们的负担，如果能有种通过配置方式来创建对象，管理对象之间依赖关系，</p><p>我们不需要通过工厂和生成器来创建及管理对象之间的依赖关系，这样我们是不是减少了许多工作，加速了开发，能节省出很多时间来干其他事。</p><p>Spring框架刚出来时主要就是来完成这个功能。</p><p>Spring框架除了帮我们管理对象及其依赖关系，还提供像通用日志记录、性能统计、安全控制、异常处理等面向切面的能力，还能帮我管理最头疼的数据库事务，</p><p>本身提供了一套简单的JDBC访问实现，提供与第三方数据访问框架集成（如Hibernate、JPA），与各种Java EE技术整合（如Java Mail、任务调度等等）。</p><p>提供一套自己的web层框架Spring MVC、而且还能非常简单的与第三方web框架集成。而且不管是JAVA SE（C&#x2F;S架构）应用程序还是JAVA EE（B&#x2F;S架构）应用程序都可以使用这个平台进行开发。</p><p>从这里可以认为Spring是一个超级粘合平台，除了自己提供功能外，还提供粘合其他技术和框架的能力，从而使可以更自由的选择到底使用什么技术进行开发。</p><h2 id="二-Spring能帮我们做什么"><a href="#二-Spring能帮我们做什么" class="headerlink" title="二.Spring能帮我们做什么"></a>二.Spring能帮我们做什么</h2><p>Spring除了不能帮助写业务逻辑，其余的几乎什么都能帮助简化开发：</p><h3 id="1、传统程序开发"><a href="#1、传统程序开发" class="headerlink" title="1、传统程序开发"></a>1、传统程序开发</h3><p>创建对象及组装对象间依赖关系由我们在程序内部进行控制，这样会加大各个对象间的耦合，如果我们要修改对象间的依赖关系就必须修改源代码，重新编译、部署；而如果采用Spring，</p><p>则由Spring根据配置文件来进行创建及组装对象间依赖关系，只需要改配置文件即可，无需重新编译。所以，<strong>Spring能帮我们根据配置文件创建及组装对象之间的依赖关系。</strong></p><h3 id="2、实现日志记录，性能统计，安全控制"><a href="#2、实现日志记录，性能统计，安全控制" class="headerlink" title="2、实现日志记录，性能统计，安全控制"></a><strong>2</strong>、<strong>实现日志记录，性能统计，安全控制</strong></h3><p>当进行一些日志记录、权限控制、性能统计等时，在传统应用程序当中我们可能在需要的对象或方法中进行，而且比如权限控制、性能统计大部分是重复的，</p><p>这样代码中就存在大量重复代码，即使有人说我把通用部分提取出来，那必然存在调用还是存在重复，像性能统计我们可能只是在必要时才进行，在诊断完毕后要删除这些代码；</p><p>还有日志记录，比如记录一些方法访问日志、数据访问日志等等，这些都会渗透到各个要访问方法中；</p><p>还有权限控制，必须在方法执行开始进行审核，想想这些是多么可怕而且是多么无聊的工作。</p><p>如果采用Spring，这些日志记录、权限控制、性能统计从业务逻辑中分离出来，通过Spring支持的面向切面编程，在需要这些功能的地方动态添加这些功能，</p><p>无需渗透到各个需要的方法或对象中；有人可能说了，我们可以使用“代理设计模式”或“包装器设计模式”，你可以使用这些，</p><p>但还是需要通过编程方式来创建代理对象，还是要耦合这些代理对象，而采用Spring 面向切面编程能提供一种更好的方式来完成上述功能，</p><p>一般通过配置方式，而且不需要在现有代码中添加任何额外代码，现有代码专注业务逻辑。</p><h3 id="3、管理数据库事务"><a href="#3、管理数据库事务" class="headerlink" title="3、管理数据库事务"></a><strong>3</strong>、<strong>管理数据库事务</strong></h3><p>在传统应用程序当中，我们如何来完成数据库事务管理？需要一系列“获取连接，执行SQL，提交或回滚事务，关闭连接”，</p><p>而且还要保证在最后一定要关闭连接，多么可怕的事情，而且也很无聊；如果采用Spring，我们只需获取连接，执行SQL，其他的都交给Spring来管理了。</p><p>4、Spring还提供了与第三方数据访问框架（如Hibernate、JPA）无缝集成，而且自己也提供了一套JDBC访问模板，来方便数据库访问。</p><p>5、Spring还提供与第三方Web（如Struts、JSF）框架无缝集成，而且自己也提供了一套Spring MVC框架，来方便web层搭建。</p><p>6、Spring能方便的与Java EE（如Java Mail、任务调度）整合，与更多技术整合（比如缓存框架）。</p><p>总结：</p><p>Spring能帮我们做这么多事情，提供这么多功能和与那么多主流技术整合，而且是帮我们做了开发中比较头疼和困难的事情，那可能有人会问，</p><p>难道只有Spring这一个框架，没有其他选择？当然有，比如EJB需要依赖应用服务器、开发效率低。</p><p>在开发中小型项目是宰鸡拿牛刀，虽然发展到现在EJB比较好用了，但还是比较笨重还需要依赖应用服务器等。</p><h2 id="三-为何需要Spring"><a href="#三-为何需要Spring" class="headerlink" title="三.为何需要Spring"></a>三.为何需要Spring</h2><h3 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h3><p><strong>（1）应用程序</strong>：是能完成我们所需要功能的成品，比如购物网站、OA系统。</p><p><strong>（2）框架</strong>：是能完成一定功能的半成品，比如我们可以使用框架进行购物网站开发；框架做一部分功能，我们自己做一部分功能，这样应用程序就创建出来了。</p><p>而且框架规定了你在开发应用程序时的整体架构，提供了一些基础功能，还规定了类和对象的如何创建、如何协作等，从而简化我们开发，让我们专注于业务逻辑开发。</p><p><strong>（3）非侵入式设计</strong>：从框架角度可以这样理解，无需继承框架提供的类，这种设计就可以看作是非侵入式设计，如果继承了这些框架类，就是侵入设计，</p><p>如果以后想更换框架之前写过的代码几乎无法重用，如果非侵入式设计则之前写过的代码仍然可以继续使用。</p><p><strong>（4）轻量级及重量级</strong>：轻量级是相对于重量级而言的，轻量级一般就是非入侵性的、所依赖的东西非常少、资源占用非常少、部署简单等等，其实就是比较容易使用，而重量级正好相反。</p><p><strong>（5）POJO</strong>：POJO（Plain Old Java Objects）简单的Java对象，它可以包含业务逻辑或持久化逻辑，但不担当任何特殊角色且不继承或不实现任何其它Java框架的类或接口。</p><p><strong>（6）容器</strong>：在日常生活中容器就是一种盛放东西的器具，从程序设计角度看就是装对象的的对象，因为存在放入、拿出等操作，所以容器还要管理对象的生命周期。</p><p><strong>（7）控制反转：</strong>即Inversion of Control，缩写为IoC，控制反转还有一个名字叫做依赖注入（Dependency Injection），就是由容器控制程序之间的关系，而非传统实现中，由程序代码直接操控。</p><p><strong>（8）Bean：</strong>一般指容器管理对象，在Spring中指Spring IoC容器管理对象。</p><h3 id="2、Spring的优点"><a href="#2、Spring的优点" class="headerlink" title="2、Spring的优点"></a>2、Spring的优点</h3><p><strong>（1）非常轻量级的容器</strong>：</p><p>以集中的、自动化的方式进行应用程序对象创建和装配，负责对象创建和装配，管理对象生命周期，能组合成复杂的应用程序。</p><p>Spring容器是非侵入式的（不需要依赖任何Spring特定类），而且完全采用POJOs进行开发，使应用程序更容易测试、更容易管理。</p><p>而且核心JAR包非常小，Spring 3.0.5不到1M，而且不需要依赖任何应用服务器，可以部署在任何环境（Java SE或Java EE）。</p><p><strong>（2）AOP</strong>：</p><p>AOP是Aspect Oriented Programming的缩写，意思是面向切面编程，提供从另一个角度来考虑程序结构以完善面向对象编程（相对于OOP），</p><p>即可以通过在编译期间、装载期间或运行期间实现在不修改源代码的情况下给程序动态添加功能的一种技术。通俗点说就是把可重用的功能提取出来，</p><p>然后将这些通用功能在合适的时候织入到应用程序中；比如安全，日记记录，这些都是通用的功能，我们可以把它们提取出来，</p><p>然后在程序执行的合适地方织入这些代码并执行它们，从而完成需要的功能并复用了这些功能。</p><p><strong>（3）简单的数据库事务管理</strong>：</p><p>在使用数据库的应用程序当中，自己管理数据库事务是一项很让人头疼的事，而且很容易出现错误，Spring支持可插入的事务管理支持，</p><p>而且无需JEE环境支持，通过Spring管理事务可以把我们从事务管理中解放出来来专注业务逻辑。</p><p><strong>（4）JDBC<strong><strong>抽象及ORM</strong></strong>框架支持</strong>：</p><p>Spring使JDBC更加容易使用；提供DAO（数据访问对象）支持，非常方便集成第三方ORM框架，比如Hibernate等；</p><p>并且完全支持Spring事务和使用Spring提供的一致的异常体系。</p><p><strong>（5）灵活的Web****层支持</strong>：Spring本身提供一套非常强大的MVC框架，而且可以非常容易的与第三方MVC框架集成，比如Struts等。</p><p><strong>（6）简化各种技术集成</strong>：</p><p>提供对Java Mail、任务调度、JMX、JMS、JNDI、EJB、动态语言、远程访问、Web Service等的集成。</p><p>Spring能帮助我们简化应用程序开发，帮助我们创建和组装对象，为我们管理事务，简单的MVC框架，可以把Spring看作是一个超级粘合平台，</p><p>能把很多技术整合在一起，形成一个整体，使系统结构更优良、性能更出众，从而加速我们程序开发，有如上优点，我们没有理由不考虑使用它。</p><h2 id="四-如何学好Spring"><a href="#四-如何学好Spring" class="headerlink" title="四.如何学好Spring"></a>四.如何学好Spring</h2><p>要学好Spring，首先要明确Spring是个什么东西，能帮我们做些什么事情，知道了这些然后做个简单的例子，这样就基本知道怎么使用Spring了。</p><p>Spring核心是IoC容器，所以一定要透彻理解什么是IoC容器，以及如何配置及使用容器，其他所有技术都是基于容器实现的；</p><p>理解好IoC后，接下来是面向切面编程，首先还是明确概念，基本配置，最后是实现原理，接下来就是数据库事务管理，其实Spring管理事务是通过面向切面编程实现的，</p><p>所以基础很重要，IoC容器和面向切面编程搞定后，其余都是基于这俩东西的实现，学起来就更加轻松了。要学好Spring不能急，一定要把基础打牢，基础牢固了，这就是磨刀不误砍柴工。</p><h2 id="五-Spring架构图"><a href="#五-Spring架构图" class="headerlink" title="五.Spring架构图"></a>五.Spring架构图</h2><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403042119818.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403042120161.png"></p><h3 id="1、核心容器"><a href="#1、核心容器" class="headerlink" title="1、核心容器"></a>1、核心容器</h3><p>包括Core、Beans、Context、EL模块。</p><p><strong>（1）Core模块：</strong>封装了框架依赖的最底层部分，包括资源访问、类型转换及一些常用工具类。</p><p><strong>（2）Beans模块：</strong></p><p>提供了框架的基础部分，包括反转控制和依赖注入。其中Bean Factory是容器核心，本质是“工厂设计模式”的实现，而且无需编程实现“单例设计模式”，</p><p>单例完全由容器控制，而且提倡面向接口编程，而非面向实现编程；所有应用程序对象及对象间关系由框架管理，</p><p>从而真正把你从程序逻辑中把维护对象之间的依赖关系提取出来，所有这些依赖关系都由BeanFactory来维护。</p><p><strong><strong><strong>（3）</strong></strong>Context</strong><strong>模块：</strong>以Core和Beans为基础，集成Beans模块功能并添加资源绑定、数据验证、国际化<strong>、</strong>Java EE支持、容器生命周期、事件传播等；核心接口是ApplicationContext。</p><p><strong><strong><strong>（4）</strong></strong>EL</strong><strong>模块：</strong>提供强大的表达式语言支持，支持访问和修改属性值，方法调用，支持访问及修改数组、容器和索引器，命名变量，支持算数和逻辑运算，</p><p>                         支持从Spring 容器获取Bean，它也支持列表投影、选择和一般的列表聚合等。</p><h3 id="2、AOP、Aspects模块"><a href="#2、AOP、Aspects模块" class="headerlink" title="2、AOP、Aspects模块"></a><strong>2、AOP、Aspects模块</strong></h3><p><strong>（1）AOP模块：</strong></p><p>Spring AOP模块提供了符合 AOP Alliance规范的面向方面的编程（aspect-oriented programming）实现，提供比如日志记录、权限控制、</p><p>性能统计等通用功能和业务逻辑分离的技术，并且能动态的把这些功能添加到需要的代码中；这样各专其职，降低业务逻辑和通用功能的耦合。</p><p>（2）Aspects模块：提供了对AspectJ的集成，AspectJ提供了比Spring ASP更强大的功能。</p><h3 id="3、数据访问-x2F-集成模块"><a href="#3、数据访问-x2F-集成模块" class="headerlink" title="3、数据访问&#x2F;集成模块"></a><strong>3、数据访问&#x2F;集成模块</strong></h3><p>该模块包括了JDBC、ORM、OXM、JMS和事务管理。</p><p>（1）事务模块：该模块用于Spring管理事务，只要是Spring管理对象都能得到Spring管理事务的好处，无需在代码中进行事务控制了，而且支持编程和声明性的事物管理。</p><p>（2）JDBC模块：提供了一个JBDC的样例模板，使用这些模板能消除传统冗长的JDBC编码还有必须的事务控制，而且能享受到Spring管理事务的好处。</p><p>（3）ORM模块：提供与流行的“对象-关系”映射框架的无缝集成，包括Hibernate、JPA、Ibatiss等。而且可以使用Spring事务管理，无需额外控制事务。</p><p>（4）OXM模块：提供了一个对Object&#x2F;XML映射实现，将java对象映射成XML数据，或者将XML数据映射成java对象，Object&#x2F;XML映射实现包括JAXB、Castor、XMLBeans和XStream。</p><p>（6）JMS模块：用于JMS(Java Messaging Service)，提供一套 “消息生产者、消息消费者”模板用于更加简单的使用JMS，JMS用于用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。</p><h3 id="4、Web-x2F-Remoting模块"><a href="#4、Web-x2F-Remoting模块" class="headerlink" title="4、Web&#x2F;Remoting模块"></a><strong>4、Web&#x2F;Remoting模块</strong></h3><p>Web&#x2F;Remoting模块包含了Web、Web-Servlet、Web-Struts、Web-Porlet模块。</p><p>（1）Web模块：提供了基础的web功能。例如多文件上传、集成IoC容器、远程过程访问（RMI、Hessian、Burlap）以及Web Service支持，并提供一个RestTemplate类来提供方便的Restful services访问。</p><p>（2）Web-Servlet模块：提供了一个Spring MVC Web框架实现。</p><p>         Spring MVC框架提供了基于注解的请求资源注入、更简单的数据绑定、数据验证等及一套非常易用的JSP标签，完全无缝与Spring其他技术协作。</p><p>（3）Web-Struts模块：提供了与Struts无缝集成，Struts1.x 和Struts2.x都支持。</p><h3 id="5、Test模块"><a href="#5、Test模块" class="headerlink" title="5、Test模块"></a><strong>5、Test模块</strong></h3><p>Spring支持Junit和TestNG测试框架，而且还额外提供了一些基于Spring的测试功能，比如在测试Web框架时，模拟Http请求的功能。</p><h2 id="六-典型应用场景"><a href="#六-典型应用场景" class="headerlink" title="六.典型应用场景"></a>六.典型应用场景</h2><p>Spring可以应用到许多场景，从最简单的标准Java SE程序到企业级应用程序都能使用Spring来构建。以下介绍几个比较流行的应用场景：</p><h3 id="1、典型Web应用程序应用场景："><a href="#1、典型Web应用程序应用场景：" class="headerlink" title="1、典型Web应用程序应用场景："></a><strong>1、典型Web应用程序应用场景：</strong></h3><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403042121681.png"></p><p>在Web应用程序应用场景中，典型的三层架构：数据模型层实现域对象；数据访问层实现数据访问；逻辑层实现业务逻辑；</p><p>web层提供页面展示；所有这些层组件都由Spring进行管理，享受到Spring事务管理、AOP等好处，</p><p>而且请求唯一入口就是DispachterServlet，它通过把请求映射为相应web层组件来实现相应请求功能。</p><h3 id="2、远程访问应用场景"><a href="#2、远程访问应用场景" class="headerlink" title="2、远程访问应用场景"></a><strong>2、远程访问应用场景</strong></h3><p>Spring能非常方便的提供暴露RMI服务，远程访问服务如Hessian、Burlap等，实现非常简单只需通过在Spring中配置相应的地址及需要暴露的服务即可轻松实现；</p><h3 id="3、EJB应用场景："><a href="#3、EJB应用场景：" class="headerlink" title="3、EJB应用场景："></a><strong>3、EJB应用场景：</strong></h3><p>Spring也可以与EJB轻松集成。</p>]]></content>
    
    
    <categories>
      
      <category>spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于并发编程（下）</title>
    <link href="/posts/a4f048b3/"/>
    <url>/posts/a4f048b3/</url>
    
    <content type="html"><![CDATA[<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402211423293.png"></p><hr><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><h3 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h3><h4 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h4><p>Java 内存模型是 Java Memory Model（JMM），本身是一种<strong>抽象的概念</strong>，实际上并不存在，描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式</p><p>JMM 作用：</p><ul><li><p>屏蔽各种硬件和操作系统的内存访问差异，实现让 Java 程序在各种平台下都能达到一致的内存访问效果</p></li><li><p>规定了线程和内存之间的一些关系</p></li></ul><p>根据 JMM 的设计，系统存在一个主内存（Main Memory），Java 中所有变量都存储在主存中，对于所有线程都是共享的；每条线程都有自己的工作内存（Working Memory），工作内存中保存的是主存中某些<strong>变量的拷贝</strong>，线程对所有变量的操作都是先对变量进行拷贝，然后在工作内存中进行，不能直接操作主内存中的变量；线程之间无法相互直接访问，线程间的通信（传递）必须通过主内存来完成</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041651883.png"></p><p>主内存和工作内存：</p><ul><li><p>主内存：计算机的内存，也就是经常提到的 8G 内存，16G 内存，存储所有共享变量的值</p></li><li><p>工作内存：存储该线程使用到的共享变量在主内存的的值的副本拷贝</p></li></ul><p><strong>JVM 和 JMM 之间的关系</strong>：JMM 中的主内存、工作内存与 JVM 中的 Java 堆、栈、方法区等并不是同一个层次的内存划分，这两者基本上是没有关系的，如果两者一定要勉强对应起来：</p><ul><li><p>主内存主要对应于 Java 堆中的对象实例数据部分，而工作内存则对应于虚拟机栈中的部分区域</p></li><li><p>从更低层次上说，主内存直接对应于物理硬件的内存，工作内存对应寄存器和高速缓存</p></li></ul><hr><h4 id="内存交互"><a href="#内存交互" class="headerlink" title="内存交互"></a>内存交互</h4><p>Java 内存模型定义了 8 个操作来完成主内存和工作内存的交互操作，每个操作都是<strong>原子</strong>的</p><p>非原子协定：没有被 volatile 修饰的 long、double 外，默认按照两次 32 位的操作</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041652749.png"></p><ul><li><p>lock：作用于主内存，将一个变量标识为被一个线程独占状态（对应 monitorenter）</p></li><li><p>unclock：作用于主内存，将一个变量从独占状态释放出来，释放后的变量才可以被其他线程锁定（对应 monitorexit）</p></li><li><p>read：作用于主内存，把一个变量的值从主内存传输到工作内存中</p></li><li><p>load：作用于工作内存，在 read 之后执行，把 read 得到的值放入工作内存的变量副本中</p></li><li><p>use：作用于工作内存，把工作内存中一个变量的值传递给<strong>执行引擎</strong>，每当遇到一个使用到变量的操作时都要使用该指令</p></li><li><p>assign：作用于工作内存，把从执行引擎接收到的一个值赋给工作内存的变量</p></li><li><p>store：作用于工作内存，把工作内存的一个变量的值传送到主内存中</p></li><li><p>write：作用于主内存，在 store 之后执行，把 store 得到的值放入主内存的变量中</p></li></ul><hr><h4 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h4><h5 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h5><p>可见性：是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值</p><p>存在不可见问题的根本原因是由于缓存的存在，线程持有的是共享变量的副本，无法感知其他线程对于共享变量的更改，导致读取的值不是最新的。但是 final 修饰的变量是<strong>不可变</strong>的，就算有缓存，也不会存在不可见的问题</p><p>main 线程对 run 变量的修改对于 t 线程不可见，导致了 t 线程无法停止：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">run</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">//添加volatile  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;  <br>        <span class="hljs-keyword">while</span>(run)&#123;  <br>        <span class="hljs-comment">// ....  </span><br>        &#125;  <br>&#125;);  <br>    t.start();  <br>    sleep(<span class="hljs-number">1</span>);  <br>    run = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 线程t不会如预想的停下来  </span><br>&#125;<br></code></pre></td></tr></table></figure><p>原因：</p><ul><li><p>初始状态， t 线程刚开始从主内存读取了 run 的值到工作内存</p></li><li><p>因为 t 线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值缓存至自己工作内存中的高速缓存中，减少对主存中 run 的访问，提高效率</p></li><li><p>1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量的值，结果永远是旧值</p></li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041653387.png"></p><hr><h5 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h5><p>原子性：不可分割，完整性，也就是说某个线程正在做某个具体业务时，中间不可以被分割，需要具体完成，要么同时成功，要么同时失败，保证指令不会受到线程上下文切换的影响</p><p>定义原子操作的使用规则：</p><ol><li><p>不允许 read 和 load、store 和 write 操作之一单独出现，必须顺序执行，但是不要求连续</p></li><li><p>不允许一个线程丢弃 assign 操作，必须同步回主存</p></li><li><p>不允许一个线程无原因地（没有发生过任何 assign 操作）把数据从工作内存同步会主内存中</p></li><li><p>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（assign 或者 load）的变量，即对一个变量实施 use 和 store 操作之前，必须先自行 assign 和 load 操作</p></li><li><p>一个变量在同一时刻只允许一条线程对其进行 lock 操作，但 lock 操作可以被同一线程重复执行多次，多次执行 lock 后，只有<strong>执行相同次数的 unlock</strong> 操作，变量才会被解锁，<strong>lock 和 unlock 必须成对出现</strong></p></li><li><p>如果对一个变量执行 lock 操作，将会<strong>清空工作内存中此变量的值</strong>，在执行引擎使用这个变量之前需要重新从主存加载</p></li><li><p>如果一个变量事先没有被 lock 操作锁定，则不允许执行 unlock 操作，也不允许去 unlock 一个被其他线程锁定的变量</p></li><li><p>对一个变量执行 unlock 操作之前，必须<strong>先把此变量同步到主内存</strong>中（执行 store 和 write 操作）</p></li></ol><hr><h5 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h5><p>有序性：在本线程内观察，所有操作都是有序的；在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序</p><p>CPU 的基本工作是执行存储的指令序列，即程序，程序的执行过程实际上是不断地取出指令、分析指令、执行指令的过程，为了提高性能，编译器和处理器会对指令重排，一般分为以下三种：</p><p>源代码 -&gt; 编译器优化的重排 -&gt; 指令并行的重排 -&gt; 内存系统的重排 -&gt; 最终执行指令</p><p>现代 CPU 支持多级指令流水线，几乎所有的冯•诺伊曼型计算机的 CPU，其工作都可以分为 5 个阶段：取指令、指令译码、执行指令、访存取数和结果写回，可以称之为<strong>五级指令流水线</strong>。CPU 可以在一个时钟周期内，同时运行五条指令的<strong>不同阶段</strong>（每个线程不同的阶段），本质上流水线技术并不能缩短单条指令的执行时间，但变相地提高了指令地吞吐率</p><p>处理器在进行重排序时，必须要考虑<strong>指令之间的数据依赖性</strong></p><ul><li><p>单线程环境也存在指令重排，由于存在依赖性，最终执行结果和代码顺序的结果一致</p></li><li><p>多线程环境中线程交替执行，由于编译器优化重排，会获取其他线程处在不同阶段的指令同时执行</p></li></ul><p>补充知识：</p><ul><li><p>指令周期是取出一条指令并执行这条指令的时间，一般由若干个机器周期组成</p></li><li><p>机器周期也称为 CPU 周期，一条指令的执行过程划分为若干个阶段（如取指、译码、执行等），每一阶段完成一个基本操作，完成一个基本操作所需要的时间称为机器周期</p></li><li><p>振荡周期指周期性信号作周期性重复变化的时间间隔</p></li></ul><hr><h3 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h3><h4 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h4><h5 id="缓存结构"><a href="#缓存结构" class="headerlink" title="缓存结构"></a>缓存结构</h5><p>在计算机系统中，CPU 高速缓存（CPU Cache，简称缓存）是用于减少处理器访问内存所需平均时间的部件；在存储体系中位于自顶向下的第二层，仅次于 CPU 寄存器；其容量远小于内存，但速度却可以接近处理器的频率</p><p>CPU 处理器速度远远大于在主内存中的，为了解决速度差异，在它们之间架设了多级缓存，如 L1、L2、L3 级别的缓存，这些缓存离 CPU 越近就越快，将频繁操作的数据缓存到这里，加快访问速度</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041653288.png"></p><table><thead><tr><th>从 CPU 到</th><th>大约需要的时钟周期</th></tr></thead><tbody><tr><td>寄存器</td><td>1 cycle (4GHz 的 CPU 约为 0.25ns)</td></tr><tr><td>L1</td><td>3~4 cycle</td></tr><tr><td>L2</td><td>10~20 cycle</td></tr><tr><td>L3</td><td>40~45 cycle</td></tr><tr><td>内存</td><td>120~240 cycle</td></tr></tbody></table><h5 id="缓存使用"><a href="#缓存使用" class="headerlink" title="缓存使用"></a>缓存使用</h5><p>当处理器发出内存访问请求时，会先查看缓存内是否有请求数据，如果存在（命中），则不用访问内存直接返回该数据；如果不存在（失效），则要先把内存中的相应数据载入缓存，再将其返回处理器</p><p>缓存之所以有效，主要因为程序运行时对内存的访问呈现局部性（Locality）特征。既包括空间局部性（Spatial Locality），也包括时间局部性（Temporal Locality），有效利用这种局部性，缓存可以达到极高的命中率</p><hr><h4 id="伪共享"><a href="#伪共享" class="headerlink" title="伪共享"></a>伪共享</h4><p><strong>缓存以缓存行 cache line 为单位</strong>，每个缓存行对应着一块内存，一般是 64 byte（8 个 long），在 CPU 从主存获取数据时，以 cache line 为单位加载，于是相邻的数据会一并加载到缓存中</p><p>缓存会造成数据副本的产生，即同一份数据会缓存在不同核心的缓存行中，CPU 要保证数据的一致性，需要做到某个 CPU 核心更改了数据，其它 CPU 核心对应的<strong>整个缓存行必须失效</strong>，这就是伪共享</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041653250.png"></p><p>解决方法：</p><ul><li><p>padding：通过填充，让数据落在不同的 cache line 中</p></li><li><p>@Contended：原理参考 无锁 → Adder → 优化机制 → 伪共享</p></li></ul><p>Linux 查看 CPU 缓存行：</p><ul><li><p>命令：<code>cat /sys/devices/system/cpu/cpu0/cache/index0/coherency_line_size64</code></p></li><li><p>内存地址格式： [ 高位组标记 ] [ 低位索引 ] [ 偏移量 ]</p></li></ul><hr><h4 id="缓存一致"><a href="#缓存一致" class="headerlink" title="缓存一致"></a>缓存一致</h4><p>缓存一致性：当多个处理器运算任务都涉及到同一块主内存区域的时候，将可能导致各自的缓存数据不一样</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041655075.png"></p><p>MESI（Modified Exclusive Shared Or Invalid）是一种广泛使用的<strong>支持写回策略的缓存一致性协议</strong>，CPU 中每个缓存行（caceh line）使用 4 种状态进行标记（使用额外的两位 bit 表示)：</p><ul><li><p>M：被修改（Modified）</p><p>  该缓存行只被缓存在该 CPU 的缓存中，并且是被修改过的，与主存中的数据不一致 (dirty)，该缓存行中的内存需要写回 (write back) 主存。该状态的数据再次被修改不会发送广播，因为其他核心的数据已经在第一次修改时失效一次</p><p>  当被写回主存之后，该缓存行的状态会变成独享 (exclusive) 状态</p></li><li><p>E：独享的（Exclusive）</p><p>  该缓存行只被缓存在该 CPU 的缓存中，是未被修改过的 (clear)，与主存中数据一致，修改数据不需要通知其他 CPU 核心，该状态可以在任何时刻有其它 CPU 读取该内存时变成共享状态 (shared)</p><p>  当 CPU 修改该缓存行中内容时，该状态可以变成 Modified 状态</p></li><li><p>S：共享的（Shared）</p><p>  该状态意味着该缓存行可能被多个 CPU 缓存，并且各个缓存中的数据与主存数据一致，当 CPU 修改该缓存行中，会向其它 CPU 核心广播一个请求，使该缓存行变成无效状态 (Invalid)，然后再更新当前 Cache 里的数据</p></li><li><p>I：无效的（Invalid）</p><p>  该缓存是无效的，可能有其它 CPU 修改了该缓存行</p></li></ul><p>解决方法：各个处理器访问缓存时都遵循一些协议，在读写时要根据协议进行操作，协议主要有 MSI、MESI 等</p><hr><h4 id="处理机制"><a href="#处理机制" class="headerlink" title="处理机制"></a>处理机制</h4><p>单核 CPU 处理器会自动保证基本内存操作的原子性</p><p>多核 CPU 处理器，每个 CPU 处理器内维护了一块内存，每个内核内部维护着一块缓存，当多线程并发读写时，就会出现缓存数据不一致的情况。处理器提供：</p><ul><li><p>总线锁定：当处理器要操作共享变量时，在 BUS 总线上发出一个 LOCK 信号，其他处理器就无法操作这个共享变量，该操作会导致大量阻塞，从而增加系统的性能开销（<strong>平台级别的加锁</strong>）</p></li><li><p>缓存锁定：当处理器对缓存中的共享变量进行了操作，其他处理器有嗅探机制，将各自缓存中的该共享变量的失效，读取时会重新从主内存中读取最新的数据，基于 MESI 缓存一致性协议来实现</p></li></ul><p>有如下两种情况处理器不会使用缓存锁定：</p><ul><li><p>当操作的数据跨多个缓存行，或没被缓存在处理器内部，则处理器会使用总线锁定</p></li><li><p>有些处理器不支持缓存锁定，比如：Intel 486 和 Pentium 处理器也会调用总线锁定</p></li></ul><p>总线机制：</p><ul><li><p>总线嗅探：每个处理器通过嗅探在总线上传播的数据来检查自己缓存值是否过期了，当处理器发现自己的缓存对应的内存地址的数据被修改，就<strong>将当前处理器的缓存行设置为无效状态</strong>，当处理器对这个数据进行操作时，会重新从内存中把数据读取到处理器缓存中</p></li><li><p>总线风暴：当某个 CPU 核心更新了 Cache 中的数据，要把该事件广播通知到其他核心（<strong>写传播</strong>），CPU 需要每时每刻监听总线上的一切活动，但是不管别的核心的 Cache 是否缓存相同的数据，都需要发出一个广播事件，不断的从主内存嗅探和 CAS 循环，无效的交互会导致总线带宽达到峰值；因此不要大量使用 volatile 关键字，使用 volatile、syschonized 都需要根据实际场景</p></li></ul><hr><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><h4 id="同步机制"><a href="#同步机制" class="headerlink" title="同步机制"></a>同步机制</h4><p>volatile 是 Java 虚拟机提供的<strong>轻量级</strong>的同步机制（三大特性）</p><ul><li><p>保证可见性</p></li><li><p>不保证原子性</p></li><li><p>保证有序性（禁止指令重排）</p></li></ul><p>性能：volatile 修饰的变量进行读操作与普通变量几乎没什么差别，但是写操作相对慢一些，因为需要在本地代码中插入很多内存屏障来保证指令不会发生乱序执行，但是开销比锁要小</p><p>synchronized 无法禁止指令重排和处理器优化，为什么可以保证有序性可见性</p><ul><li><p>加了锁之后，只能有一个线程获得到了锁，获得不到锁的线程就要阻塞，所以同一时间只有一个线程执行，相当于单线程，由于数据依赖性的存在，单线程的指令重排是没有问题的</p></li><li><p>线程加锁前，将<strong>清空工作内存</strong>中共享变量的值，使用共享变量时需要从主内存中重新读取最新的值；线程解锁前，必须把共享变量的最新值<strong>刷新到主内存</strong>中（JMM 内存交互章节有讲）</p></li></ul><hr><h4 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h4><p>volatile 修饰的变量，可以禁用指令重排</p><p>指令重排实例：</p><ul><li><p>example 1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mySort</span><span class="hljs-params">()</span> &#123;  <br><span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">11</span>;<span class="hljs-comment">//语句1  </span><br><span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> <span class="hljs-number">12</span>;<span class="hljs-comment">//语句2  谁先执行效果一样  </span><br>x = x + <span class="hljs-number">5</span>;<span class="hljs-comment">//语句3  </span><br>y = x * x;<span class="hljs-comment">//语句4  </span><br>&#125;<br>    <br>执行顺序是：<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>、<span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>、<span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span><br><br>指令重排也有限制不会出现：<span class="hljs-number">4321</span>，语句 <span class="hljs-number">4</span> 需要依赖于 y 以及 x 的申明，因为存在数据依赖，无法首先执行<br></code></pre></td></tr></table></figure></li><li><p>example 2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br><span class="hljs-type">boolean</span> <span class="hljs-variable">ready</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;  <br><span class="hljs-comment">// 线程1 执行此方法  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor1</span><span class="hljs-params">(I_Result r)</span> &#123;  <br><span class="hljs-keyword">if</span>(ready) &#123;  <br>r.r1 = num + num;  <br>&#125; <span class="hljs-keyword">else</span> &#123;  <br>r.r1 = <span class="hljs-number">1</span>;  <br>&#125;  <br>&#125;  <br><span class="hljs-comment">// 线程2 执行此方法  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor2</span><span class="hljs-params">(I_Result r)</span> &#123;  <br>num = <span class="hljs-number">2</span>;  <br>ready = <span class="hljs-literal">true</span>;  <br>&#125;<br><br>情况一：线程 <span class="hljs-number">1</span> 先执行，ready = <span class="hljs-literal">false</span>，结果为 r.r1 = <span class="hljs-number">1</span><br><br>情况二：线程 <span class="hljs-number">2</span> 先执行 num = <span class="hljs-number">2</span>，但还没执行 ready = <span class="hljs-literal">true</span>，线程 <span class="hljs-number">1</span> 执行，结果为 r.r1 = <span class="hljs-number">1</span><br><br>情况三：线程 <span class="hljs-number">2</span> 先执行 ready = <span class="hljs-literal">true</span>，线程 <span class="hljs-number">1</span> 执行，进入 <span class="hljs-keyword">if</span> 分支结果为 r.r1 = <span class="hljs-number">4</span><br><br>情况四：线程 <span class="hljs-number">2</span> 执行 ready = <span class="hljs-literal">true</span>，切换到线程 <span class="hljs-number">1</span>，进入 <span class="hljs-keyword">if</span> 分支为 r.r1 = <span class="hljs-number">0</span>，再切回线程 <span class="hljs-number">2</span> 执行 num = <span class="hljs-number">2</span>，发生指令重排<br></code></pre></td></tr></table></figure></li></ul><hr><h4 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h4><h5 id="缓存一致-1"><a href="#缓存一致-1" class="headerlink" title="缓存一致"></a>缓存一致</h5><p>使用 volatile 修饰的共享变量，底层通过汇编 lock 前缀指令进行缓存锁定，在线程修改完共享变量后写回主存，其他的 CPU 核心上运行的线程通过 CPU 总线嗅探机制会修改其共享变量为失效状态，读取时会重新从主内存中读取最新的数据</p><p>lock 前缀指令就相当于内存屏障，Memory Barrier（Memory Fence）</p><ul><li><p>对 volatile 变量的写指令后会加入写屏障</p></li><li><p>对 volatile 变量的读指令前会加入读屏障</p></li></ul><p>内存屏障有三个作用：</p><ul><li><p>确保对内存的读-改-写操作原子执行</p></li><li><p>阻止屏障两侧的指令重排序</p></li><li><p>强制把缓存中的脏数据写回主内存，让缓存行中相应的数据失效</p></li></ul><hr><h5 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h5><p>保证<strong>可见性</strong>：</p><ul><li><p>写屏障（sfence，Store Barrier）保证在该屏障之前的，对共享变量的改动，都同步到主存当中</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor2</span><span class="hljs-params">(I_Result r)</span> &#123;  <br>num = <span class="hljs-number">2</span>;  <br>ready = <span class="hljs-literal">true</span>; <span class="hljs-comment">// ready 是 volatile 赋值带写屏障  </span><br><span class="hljs-comment">// 写屏障  </span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>读屏障（lfence，Load Barrier）保证在该屏障之后的，对共享变量的读取，从主存刷新变量值，加载的是主存中最新数据</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor1</span><span class="hljs-params">(I_Result r)</span> &#123;  <br><span class="hljs-comment">// 读屏障  </span><br><span class="hljs-comment">// ready 是 volatile 读取值带读屏障  </span><br><span class="hljs-keyword">if</span>(ready) &#123;  <br>r.r1 = num + num;  <br>&#125; <span class="hljs-keyword">else</span> &#123;  <br>r.r1 = <span class="hljs-number">1</span>;  <br>&#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041658375.png"></p></li><li><p>全能屏障：mfence（modify&#x2F;mix Barrier），兼具 sfence 和 lfence 的功能</p></li></ul><p>保证<strong>有序性</strong>：</p><ul><li><p>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</p></li><li><p>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</p></li></ul><p>不能解决指令交错：</p><ul><li><p>写屏障仅仅是保证之后的读能够读到最新的结果，但不能保证其他线程的读跑到写屏障之前</p></li><li><p>有序性的保证也只是保证了本线程内相关代码不被重排序</p><p>  volatile i &#x3D; 0;<br>  new Thread(() -&gt; {i++});<br>  new Thread(() -&gt; {i–});</p><p>  i++ 反编译后的指令：</p><p>  0: iconst_1&#x2F;&#x2F; 当int取值 -1~5 时，JVM采用iconst指令将常量压入栈中<br>  1: istore_1&#x2F;&#x2F; 将操作数栈顶数据弹出，存入局部变量表的 slot 1<br>  2: iinc1, 1</p><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041659289.png"></p></li></ul><hr><h5 id="交互规则"><a href="#交互规则" class="headerlink" title="交互规则"></a>交互规则</h5><p>对于 volatile 修饰的变量：</p><ul><li><p>线程对变量的 use 与 load、read 操作是相关联的，所以变量使用前必须先从主存加载</p></li><li><p>线程对变量的 assign 与 store、write 操作是相关联的，所以变量使用后必须同步至主存</p></li><li><p>线程 1 和线程 2 谁先对变量执行 read 操作，就会先进行 write 操作，防止指令重排</p></li></ul><hr><h4 id="双端检锁"><a href="#双端检锁" class="headerlink" title="双端检锁"></a>双端检锁</h4><h5 id="检锁机制"><a href="#检锁机制" class="headerlink" title="检锁机制"></a>检锁机制</h5><p>Double-Checked Locking：双端检锁机制</p><p>DCL（双端检锁）机制不一定是线程安全的，原因是有指令重排的存在，加入 volatile 可以禁止指令重排</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123; &#125;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;  <br>      <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">if</span>(INSTANCE == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// t2，这里的判断不是线程安全的  </span><br>            <span class="hljs-comment">// 首次访问会同步，而之后的使用没有 synchronized  </span><br>            <span class="hljs-keyword">synchronized</span>(Singleton.class) &#123;  <br>                <span class="hljs-comment">// 这里是线程安全的判断，防止其他线程在当前线程等待锁的期间完成了初始化  </span><br>                <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-literal">null</span>) &#123;   <br>                    INSTANCE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();  <br>                &#125;  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> INSTANCE;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>不锁 INSTANCE 的原因：</p><ul><li><p>INSTANCE 要重新赋值</p></li><li><p>INSTANCE 是 null，线程加锁之前需要获取对象的引用，设置对象头，null 没有引用</p></li></ul><p>实现特点：</p><ul><li><p>懒惰初始化</p></li><li><p>首次使用 getInstance() 才使用 synchronized 加锁，后续使用时无需加锁</p></li><li><p>第一个 if 使用了 INSTANCE 变量，是在同步块之外，但在多线程环境下会产生问题</p></li></ul><hr><h5 id="DCL问题"><a href="#DCL问题" class="headerlink" title="DCL问题"></a>DCL问题</h5><p>getInstance 方法对应的字节码为：</p><figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs ldif"><br><span class="hljs-attribute">0</span>: getstatic <span class="hljs-comment">#2 // Field INSTANCE:Ltest/Singleton;  </span><br><span class="hljs-attribute">3</span>: ifnonnull 37  <br><span class="hljs-attribute">6</span>: ldc <span class="hljs-comment">#3 // class test/Singleton  </span><br><span class="hljs-attribute">8</span>: dup  <br><span class="hljs-attribute">9</span>: astore_0  <br><span class="hljs-attribute">10</span>: monitorenter  <br><span class="hljs-attribute">11</span>: getstatic <span class="hljs-comment">#2 // Field INSTANCE:Ltest/Singleton;  </span><br><span class="hljs-attribute">14</span>: ifnonnull 27  <br><span class="hljs-attribute">17</span>: new <span class="hljs-comment">#3 // class test/Singleton  </span><br><span class="hljs-attribute">20</span>: dup  <br><span class="hljs-attribute">21</span>: invokespecial <span class="hljs-comment">#4 // Method &quot;&lt;init&gt;&quot;:()V  </span><br><span class="hljs-attribute">24</span>: putstatic <span class="hljs-comment">#2 // Field INSTANCE:Ltest/Singleton;  </span><br><span class="hljs-attribute">27</span>: aload_0  <br><span class="hljs-attribute">28</span>: monitorexit  <br><span class="hljs-attribute">29</span>: goto 37  <br><span class="hljs-attribute">32</span>: astore_1  <br><span class="hljs-attribute">33</span>: aload_0  <br><span class="hljs-attribute">34</span>: monitorexit  <br><span class="hljs-attribute">35</span>: aload_1  <br><span class="hljs-attribute">36</span>: athrow  <br><span class="hljs-attribute">37</span>: getstatic <span class="hljs-comment">#2 // Field INSTANCE:Ltest/Singleton;  </span><br><span class="hljs-attribute">40</span>: areturn<br></code></pre></td></tr></table></figure><ul><li><p>17 表示创建对象，将对象引用入栈</p></li><li><p>20 表示复制一份对象引用，引用地址</p></li><li><p>21 表示利用一个对象引用，调用构造方法初始化对象</p></li><li><p>24 表示利用一个对象引用，赋值给 static INSTANCE</p></li></ul><p><strong>步骤 21 和 24 之间不存在数据依赖关系</strong>，而且无论重排前后，程序的执行结果在单线程中并没有改变，因此这种重排优化是允许的</p><ul><li><p>关键在于 0:getstatic 这行代码在 monitor 控制之外，可以越过 monitor 读取 INSTANCE 变量的值</p></li><li><p>当其他线程访问 INSTANCE 不为 null 时，由于 INSTANCE 实例未必已初始化，那么 t2 拿到的是将是一个未初始化完毕的单例返回，这就造成了线程安全的问题</p></li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041700443.png"></p><hr><h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><p>指令重排只会保证串行语义的执行一致性（单线程），但并不会关系多线程间的语义一致性</p><p>引入 volatile，来保证出现指令重排的问题，从而保证单例模式的线程安全性：</p><p><code>private static volatile SingletonDemo INSTANCE = null;</code></p><hr><h3 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h3><p>happens-before 先行发生</p><p>Java 内存模型具备一些先天的“有序性”，即不需要通过任何同步手段（volatile、synchronized 等）就能够得到保证的安全，这个通常也称为 happens-before 原则，它是可见性与有序性的一套规则总结</p><p>不符合 happens-before 规则，JMM 并不能保证一个线程的可见性和有序性</p><ol><li><p>程序次序规则 (Program Order Rule)：一个线程内，逻辑上书写在前面的操作先行发生于书写在后面的操作 ，因为多个操作之间有先后依赖关系，则不允许对这些操作进行重排序</p></li><li><p>锁定规则 (Monitor Lock Rule)：一个 unlock 操作先行发生于后面（时间的先后）对同一个锁的 lock 操作，所以线程解锁 m 之前对变量的写（解锁前会刷新到主内存中），对于接下来对 m 加锁的其它线程对该变量的读可见</p></li><li><p><strong>volatile 变量规则</strong> (Volatile Variable Rule)：对 volatile 变量的写操作先行发生于后面对这个变量的读</p></li><li><p>传递规则 (Transitivity)：具有传递性，如果操作 A 先行发生于操作 B，而操作 B 又先行发生于操作 C，则可以得出操作 A 先行发生于操作 C</p></li><li><p>线程启动规则 (Thread Start Rule)：Thread 对象的 start()方 法先行发生于此线程中的每一个操作</p><p> static int x &#x3D; 10;&#x2F;&#x2F;线程 start 前对变量的写，对该线程开始后对该变量的读可见<br> new Thread(()-&gt;{System.out.println(x);},”t1”).start();</p></li><li><p>线程中断规则 (Thread Interruption Rule)：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生</p></li><li><p>线程终止规则 (Thread Termination Rule)：线程中所有的操作都先行发生于线程的终止检测，可以通过 Thread.join() 方法结束、Thread.isAlive() 的返回值手段检测到线程已经终止执行</p></li><li><p>对象终结规则（Finaizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始</p></li></ol><hr><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><h4 id="终止模式"><a href="#终止模式" class="headerlink" title="终止模式"></a>终止模式</h4><p>终止模式之两阶段终止模式：停止标记用 volatile 是为了保证该变量在多个线程之间的可见性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TwoPhaseTermination</span> &#123;  <br>    <span class="hljs-comment">// 监控线程  </span><br>    <span class="hljs-keyword">private</span> Thread monitor;  <br>    <span class="hljs-comment">// 停止标记  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">stop</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;;  <br>  <br>    <span class="hljs-comment">// 启动监控线程  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;  <br>        monitor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;  <br>                <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> Thread.currentThread();  <br>                <span class="hljs-keyword">if</span> (stop) &#123;  <br>                    System.out.println(<span class="hljs-string">&quot;后置处理&quot;</span>);  <br>                    <span class="hljs-keyword">break</span>;  <br>                &#125;  <br>                <span class="hljs-keyword">try</span> &#123;  <br>                    Thread.sleep(<span class="hljs-number">1000</span>);<span class="hljs-comment">// 睡眠  </span><br>                    System.out.println(thread.getName() + <span class="hljs-string">&quot;执行监控记录&quot;</span>);  <br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>                   System.out.println(<span class="hljs-string">&quot;被打断，退出睡眠&quot;</span>);  <br>                &#125;  <br>            &#125;  <br>        &#125;);  <br>        monitor.start();  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 停止监控线程  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">()</span> &#123;  <br>        stop = <span class="hljs-literal">true</span>;  <br>        monitor.interrupt();<span class="hljs-comment">// 让线程尽快退出Timed Waiting  </span><br>    &#125;  <br>&#125;  <br><span class="hljs-comment">// 测试  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>    <span class="hljs-type">TwoPhaseTermination</span> <span class="hljs-variable">tpt</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TwoPhaseTermination</span>();  <br>    tpt.start();  <br>    Thread.sleep(<span class="hljs-number">3500</span>);  <br>    System.out.println(<span class="hljs-string">&quot;停止监控&quot;</span>);  <br>    tpt.stop();  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="Balking"><a href="#Balking" class="headerlink" title="Balking"></a>Balking</h4><p>Balking （犹豫）模式用在一个线程发现另一个线程或本线程已经做了某一件相同的事，那么本线程就无需再做了，直接结束返回</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MonitorService</span> </span>&#123;  <br>    <span class="hljs-comment">// 用来表示是否已经有线程已经在执行启动了  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> starting = <span class="hljs-keyword">false</span>;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;  <br>        System.out.println(<span class="hljs-string">&quot;尝试启动监控线程...&quot;</span>);  <br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;  <br>            <span class="hljs-keyword">if</span> (starting) &#123;  <br>            <span class="hljs-keyword">return</span>;  <br>            &#125;  <br>            starting = <span class="hljs-keyword">true</span>;  <br>        &#125;  <br>        <span class="hljs-comment">// 真正启动监控线程...  </span><br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>对比保护性暂停模式：保护性暂停模式用在一个线程等待另一个线程的执行结果，当条件不满足时线程等待</p><p>例子：希望 doInit() 方法仅被调用一次，下面的实现出现的问题：</p><ul><li><p>当 t1 线程进入 init() 准备 doInit()，t2 线程进来，initialized 还为f alse，则 t2 就又初始化一次</p></li><li><p>volatile 适合一个线程写，其他线程读的情况，这个代码需要加锁</p></li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TestVolatile</span> &#123;  <br>    <span class="hljs-keyword">volatile</span> boolean initialized = <span class="hljs-literal">false</span>;  <br>      <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span>()</span> &#123;  <br>        <span class="hljs-keyword">if</span> (initialized) &#123;  <br>            <span class="hljs-keyword">return</span>;  <br>        &#125;  <br>    doInit();  <br>    initialized = <span class="hljs-literal">true</span>;  <br>    &#125;  <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doInit</span>()</span> &#123;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h2><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>无锁编程：Lock Free</p><p>CAS 的全称是 Compare-And-Swap，是 <strong>CPU 并发原语</strong></p><ul><li><p>CAS 并发原语体现在 Java 语言中就是 sun.misc.Unsafe 类的各个方法，调用 UnSafe 类中的 CAS 方法，JVM 会实现出 CAS 汇编指令，这是一种完全依赖于硬件的功能，实现了原子操作</p></li><li><p>CAS 是一种系统原语，原语属于操作系统范畴，是由若干条指令组成 ，用于完成某个功能的一个过程，并且原语的执行必须是连续的，执行过程中不允许被中断，所以 CAS 是一条 CPU 的原子指令，不会造成数据不一致的问题，是线程安全的</p></li></ul><p>底层原理：CAS 的底层是 <code>lock cmpxchg</code> 指令（X86 架构），在单核和多核 CPU 下都能够保证比较交换的原子性</p><ul><li><p>程序是在单核处理器上运行，会省略 lock 前缀，单处理器自身会维护处理器内的顺序一致性，不需要 lock 前缀的内存屏障效果</p></li><li><p>程序是在多核处理器上运行，会为 cmpxchg 指令加上 lock 前缀。当某个核执行到带 lock 的指令时，CPU 会执行<strong>总线锁定或缓存锁定</strong>，将修改的变量写入到主存，这个过程不会被线程的调度机制所打断，保证了多个线程对内存操作的原子性</p></li></ul><p>作用：比较当前工作内存中的值和主物理内存中的值，如果相同则执行规定操作，否则继续比较直到主内存和工作内存的值一致为止</p><p>CAS 特点：</p><ul><li><p>CAS 体现的是<strong>无锁并发、无阻塞并发</strong>，线程不会陷入阻塞，线程不需要频繁切换状态（上下文切换，系统调用）</p></li><li><p>CAS 是基于乐观锁的思想</p></li></ul><p>CAS 缺点：</p><ul><li><p>执行的是循环操作，如果比较不成功一直在循环，最差的情况某个线程一直取到的值和预期值都不一样，就会无限循环导致饥饿，<strong>使用 CAS 线程数不要超过 CPU 的核心数</strong>，采用分段 CAS 和自动迁移机制</p></li><li><p>只能保证一个共享变量的原子操作</p><ul><li><p>对于一个共享变量执行操作时，可以通过循环 CAS 的方式来保证原子操作</p></li><li><p>对于多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候<strong>只能用锁来保证原子性</strong></p></li></ul></li><li><p>引出来 ABA 问题</p></li></ul><hr><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>CAS 与 synchronized 总结：</p><ul><li><p>synchronized 是从悲观的角度出发：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程），因此 synchronized 也称之为悲观锁，ReentrantLock 也是一种悲观锁，性能较差</p></li><li><p>CAS 是从乐观的角度出发：总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据。<strong>如果别人修改过，则获取现在最新的值，如果别人没修改过，直接修改共享数据的值</strong>，CAS 这种机制也称之为乐观锁，综合性能较好</p></li></ul><hr><h3 id="Atomic"><a href="#Atomic" class="headerlink" title="Atomic"></a>Atomic</h3><h4 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h4><p>常见原子类：AtomicInteger、AtomicBoolean、AtomicLong</p><p>构造方法：</p><ul><li><p><code>public AtomicInteger()</code>：初始化一个默认值为 0 的原子型 Integer</p></li><li><p><code>public AtomicInteger(int initialValue)</code>：初始化一个指定值的原子型 Integer</p></li></ul><p>常用API：</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>public final int get()</td><td>获取 AtomicInteger 的值</td></tr><tr><td>public final int getAndIncrement()</td><td>以原子方式将当前值加 1，返回的是自增前的值</td></tr><tr><td>public final int incrementAndGet()</td><td>以原子方式将当前值加 1，返回的是自增后的值</td></tr><tr><td>public final int getAndSet(int value)</td><td>以原子方式设置为 newValue 的值，返回旧值</td></tr><tr><td>public final int addAndGet(int data)</td><td>以原子方式将输入的数值与实例中的值相加并返回 实例：AtomicInteger 里的 value</td></tr></tbody></table><hr><h4 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h4><p><strong>AtomicInteger 原理</strong>：自旋锁 + CAS 算法</p><p>CAS 算法：有 3 个操作数（内存值 V， 旧的预期值 A，要修改的值 B）</p><ul><li><p>当旧的预期值 A &#x3D;&#x3D; 内存值 V 此时可以修改，将 V 改为 B</p></li><li><p>当旧的预期值 A !&#x3D; 内存值 V 此时不能修改，并重新获取现在的最新值，重新获取的动作就是自旋</p></li></ul><p>分析 getAndSet 方法：</p><ul><li><p>AtomicInteger：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public final <span class="hljs-built_in">int</span> get<span class="hljs-constructor">AndSet(<span class="hljs-params">int</span> <span class="hljs-params">newValue</span>)</span> &#123;  <br><span class="hljs-comment">/**  </span><br><span class="hljs-comment">* this: 当前对象  </span><br><span class="hljs-comment">* valueOffset:内存偏移量，内存地址  </span><br><span class="hljs-comment">*/</span>  <br>return unsafe.get<span class="hljs-constructor">AndSetInt(<span class="hljs-params">this</span>, <span class="hljs-params">valueOffset</span>, <span class="hljs-params">newValue</span>)</span>;  <br>&#125;<br>valueOffset：偏移量表示该变量值相对于当前对象地址的偏移，Unsafe 就是根据内存偏移地址获取数据<br><br>valueOffset = unsafe.objectFieldOffset  <br>(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AtomicInteger</span>.</span></span><span class="hljs-keyword">class</span>.get<span class="hljs-constructor">DeclaredField(<span class="hljs-string">&quot;value&quot;</span>)</span>);  <br><span class="hljs-comment">//调用本地方法   --&gt;  </span><br>public native long <span class="hljs-keyword">object</span><span class="hljs-constructor">FieldOffset(Field <span class="hljs-params">var1</span>)</span>;<br></code></pre></td></tr></table></figure></li><li><p>unsafe 类：</p></li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// val1: AtomicInteger对象本身，var2: 该对象值得引用地址，var4: 需要变动的数  </span><br>public final <span class="hljs-built_in">int</span> get<span class="hljs-constructor">AndSetInt(Object <span class="hljs-params">var1</span>, <span class="hljs-params">long</span> <span class="hljs-params">var2</span>, <span class="hljs-params">int</span> <span class="hljs-params">var4</span>)</span> &#123;  <br><span class="hljs-built_in">int</span> var5;  <br><span class="hljs-keyword">do</span> &#123;  <br><span class="hljs-comment">// var5: 用 var1 和 var2 找到的内存中的真实值  </span><br>var5 = this.get<span class="hljs-constructor">IntVolatile(<span class="hljs-params">var1</span>, <span class="hljs-params">var2</span>)</span>;  <br>&#125; <span class="hljs-keyword">while</span>(!this.compare<span class="hljs-constructor">AndSwapInt(<span class="hljs-params">var1</span>, <span class="hljs-params">var2</span>, <span class="hljs-params">var5</span>, <span class="hljs-params">var4</span>)</span>);  <br>return var5;  <br>&#125;<br><br><br>var5：从主内存中拷贝到工作内存中的值（每次都要从主内存拿到最新的值到本地内存），然后执行 `compare<span class="hljs-constructor">AndSwapInt()</span>` 再和主内存的值进行比较，假设方法返回 <span class="hljs-literal">false</span>，那么就一直执行 <span class="hljs-keyword">while</span> 方法，直到期望的值和真实值一样，修改数据<br></code></pre></td></tr></table></figure><ul><li><p>变量 value 用 volatile 修饰，保证了多线程之间的内存可见性，避免线程从工作缓存中获取失效的变量</p><p>  private volatile int value</p><p>  <strong>CAS 必须借助 volatile 才能读取到共享变量的最新值来实现比较并交换的效果</strong></p></li></ul><p>分析 getAndUpdate 方法：</p><ul><li><p>getAndUpdate：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndUpdate</span><span class="hljs-params">(IntUnaryOperator updateFunction)</span> &#123;  <br><span class="hljs-type">int</span> prev, next;  <br><span class="hljs-keyword">do</span> &#123;  <br>prev = get();<span class="hljs-comment">//当前值，cas的期望值  </span><br>next = updateFunction.applyAsInt(prev);<span class="hljs-comment">//期望值更新到该值  </span><br>&#125; <span class="hljs-keyword">while</span> (!compareAndSet(prev, next));<span class="hljs-comment">//自旋  </span><br><span class="hljs-keyword">return</span> prev;  <br>&#125;<br>    <br>函数式接口：可以自定义操作逻辑<br><br><span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();  <br>a.getAndUpdate(i -&gt; i + <span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure></li><li><p>compareAndSet：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSet</span><span class="hljs-params">(<span class="hljs-type">int</span> expect, <span class="hljs-type">int</span> update)</span> &#123;  <br><span class="hljs-comment">/**  </span><br><span class="hljs-comment">* this: 当前对象  </span><br><span class="hljs-comment">* valueOffset:内存偏移量，内存地址  </span><br><span class="hljs-comment">* expect:期望的值  </span><br><span class="hljs-comment">* update: 更新的值  </span><br><span class="hljs-comment">*/</span>  <br><span class="hljs-keyword">return</span> unsafe.compareAndSwapInt(<span class="hljs-built_in">this</span>, valueOffset, expect, update);  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h4 id="原子引用"><a href="#原子引用" class="headerlink" title="原子引用"></a>原子引用</h4><p>原子引用：对 Object 进行原子操作，提供一种读和写都是原子性的对象引用变量</p><p>原子引用类：AtomicReference、AtomicStampedReference、AtomicMarkableReference</p><p>AtomicReference 类：</p><ul><li><p>构造方法：<code>AtomicReference&lt;T&gt; atomicReference = new AtomicReference&lt;T&gt;()</code></p></li><li><p>常用 API：</p><ul><li><p><code>public final boolean compareAndSet(V expectedValue, V newValue)</code>：CAS 操作</p></li><li><p><code>public final void set(V newValue)</code>：将值设置为 newValue</p></li><li><p><code>public final V get()</code>：返回当前值</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicReferenceDemo</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-number">33</span>, <span class="hljs-string">&quot;z3&quot;</span>);  <br>          <br>        <span class="hljs-comment">// 创建原子引用包装类  </span><br>        AtomicReference&lt;Student&gt; atomicReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>&lt;&gt;();  <br>        <span class="hljs-comment">// 设置主内存共享变量为s1  </span><br>        atomicReference.set(s1);  <br>  <br>        <span class="hljs-comment">// 比较并交换，如果现在主物理内存的值为 z3，那么交换成 l4  </span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;  <br>            <span class="hljs-type">Student</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-number">44</span>, <span class="hljs-string">&quot;l4&quot;</span>);  <br>            <span class="hljs-keyword">if</span> (atomicReference.compareAndSet(s1, s2)) &#123;  <br>                <span class="hljs-keyword">break</span>;  <br>            &#125;  <br>        &#125;  <br>        System.out.println(atomicReference.get());  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;  <br>    <span class="hljs-keyword">private</span> String name;  <br>    <span class="hljs-comment">//。。。。  </span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="原子数组"><a href="#原子数组" class="headerlink" title="原子数组"></a>原子数组</h4><p>原子数组类：AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray</p><p>AtomicIntegerArray 类方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">/**  </span><br><span class="hljs-comment">*   ithe index  </span><br><span class="hljs-comment">* expect the expected value  </span><br><span class="hljs-comment">* update the new value  </span><br><span class="hljs-comment">*/</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSet</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> expect, <span class="hljs-type">int</span> update)</span> &#123;  <br>    <span class="hljs-keyword">return</span> compareAndSetRaw(checkedByteOffset(i), expect, update);  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="原子更新器"><a href="#原子更新器" class="headerlink" title="原子更新器"></a>原子更新器</h4><p>原子更新器类：AtomicReferenceFieldUpdater、AtomicIntegerFieldUpdater、AtomicLongFieldUpdater</p><p>利用字段更新器，可以针对对象的某个域（Field）进行原子操作，只能配合 volatile 修饰的字段使用，否则会出现异常 <code>IllegalArgumentException: Must be volatile type</code></p><p>常用 API：</p><ul><li><p><code>static &lt;U&gt; AtomicIntegerFieldUpdater&lt;U&gt; newUpdater(Class&lt;U&gt; c, String fieldName)</code>：构造方法</p></li><li><p><code>abstract boolean compareAndSet(T obj, int expect, int update)</code>：CAS</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UpdateDemo</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> field;  <br>      <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">AtomicIntegerFieldUpdater</span> <span class="hljs-variable">fieldUpdater</span> <span class="hljs-operator">=</span> AtomicIntegerFieldUpdater  <br>            .newUpdater(UpdateDemo.class, <span class="hljs-string">&quot;field&quot;</span>);  <br>        <span class="hljs-type">UpdateDemo</span> <span class="hljs-variable">updateDemo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UpdateDemo</span>();  <br>        fieldUpdater.compareAndSet(updateDemo, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>);  <br>        System.out.println(updateDemo.field);<span class="hljs-comment">//10  </span><br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="原子累加器"><a href="#原子累加器" class="headerlink" title="原子累加器"></a>原子累加器</h4><p>原子累加器类：LongAdder、DoubleAdder、LongAccumulator、DoubleAccumulator</p><p>LongAdder 和 LongAccumulator 区别：</p><p>相同点：</p><ul><li><p>LongAddr 与 LongAccumulator 类都是使用非阻塞算法 CAS 实现的</p></li><li><p>LongAddr 类是 LongAccumulator 类的一个特例，只是 LongAccumulator 提供了更强大的功能，可以自定义累加规则，当accumulatorFunction 为 null 时就等价于 LongAddr</p></li></ul><p>不同点：</p><ul><li><p>调用 casBase 时，LongAccumulator 使用 function.applyAsLong(b &#x3D; base, x) 来计算，LongAddr 使用 casBase(b &#x3D; base, b + x)</p></li><li><p>LongAccumulator 类功能更加强大，构造方法参数中</p><ul><li><p>accumulatorFunction 是一个双目运算器接口，可以指定累加规则，比如累加或者相乘，其根据输入的两个参数返回一个计算值，LongAdder 内置累加规则</p></li><li><p>identity 则是 LongAccumulator 累加器的初始值，LongAccumulator 可以为累加器提供非0的初始值，而 LongAdder 只能提供默认的 0</p></li></ul></li></ul><hr><h3 id="Adder"><a href="#Adder" class="headerlink" title="Adder"></a>Adder</h3><h4 id="优化机制"><a href="#优化机制" class="headerlink" title="优化机制"></a>优化机制</h4><p>LongAdder 是 Java8 提供的类，跟 AtomicLong 有相同的效果，但对 CAS 机制进行了优化，尝试使用分段 CAS 以及自动分段迁移的方式来大幅度提升多线程高并发执行 CAS 操作的性能</p><p>CAS 底层实现是在一个循环中不断地尝试修改目标值，直到修改成功。如果竞争不激烈修改成功率很高，否则失败率很高，失败后这些重复的原子性操作会耗费性能（导致大量线程<strong>空循环，自旋转</strong>）</p><p>优化核心思想：数据分离，将 AtomicLong 的<strong>单点的更新压力分担到各个节点，空间换时间</strong>，在低并发的时候直接更新，可以保障和 AtomicLong 的性能基本一致，而在高并发的时候通过分散减少竞争，提高了性能</p><p><strong>分段 CAS 机制</strong>：</p><ul><li><p>在发生竞争时，创建 Cell 数组用于将不同线程的操作离散（通过 hash 等算法映射）到不同的节点上</p></li><li><p>设置多个累加单元（会根据需要扩容，最大为 CPU 核数），Therad-0 累加 Cell[0]，而 Thread-1 累加 Cell[1] 等，最后将结果汇总</p></li><li><p>在累加时操作的不同的 Cell 变量，因此减少了 CAS 重试失败，从而提高性能</p></li></ul><p><strong>自动分段迁移机制</strong>：某个 Cell 的 value 执行 CAS 失败，就会自动寻找另一个 Cell 分段内的 value 值进行 CAS 操作</p><hr><h4 id="伪共享-1"><a href="#伪共享-1" class="headerlink" title="伪共享"></a>伪共享</h4><p>Cell 为累加单元：数组访问索引是通过 Thread 里的 threadLocalRandomProbe 域取模实现的，这个域是 ThreadLocalRandom 更新的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Striped64.Cell  </span><br><span class="hljs-meta">@sun</span>.misc.Contended <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cell</span> &#123;  <br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> value;  <br>    Cell(<span class="hljs-type">long</span> x) &#123; value = x; &#125;  <br>    <span class="hljs-comment">// 用 cas 方式进行累加, prev 表示旧值, next 表示新值  </span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">cas</span><span class="hljs-params">(<span class="hljs-type">long</span> prev, <span class="hljs-type">long</span> next)</span> &#123;  <br>    <span class="hljs-keyword">return</span> UNSAFE.compareAndSwapLong(<span class="hljs-built_in">this</span>, valueOffset, prev, next);  <br>    &#125;  <br>    <span class="hljs-comment">// 省略不重要代码  </span><br>&#125;<br></code></pre></td></tr></table></figure><p>Cell 是数组形式，<strong>在内存中是连续存储的</strong>，64 位系统中，一个 Cell 为 24 字节（16 字节的对象头和 8 字节的 value），每一个 cache line 为 64 字节，因此缓存行可以存下 2 个的 Cell 对象，当 Core-0 要修改 Cell[0]、Core-1 要修改 Cell[1]，无论谁修改成功都会导致当前缓存行失效，从而导致对方的数据失效，需要重新去主存获取，影响效率</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041706137.png"></p><p>@sun.misc.Contended：防止缓存行伪共享，在使用此注解的对象或字段的前后各增加 128 字节大小的 padding，使用 2 倍于大多数硬件缓存行让 CPU 将对象预读至缓存时<strong>占用不同的缓存行</strong>，这样就不会造成对方缓存行的失效</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041706578.png"></p><hr><h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h4><p>Striped64 类成员属性：</p><p>&#x2F;&#x2F; 表示当前计算机CPU数量<br>static final int NCPU &#x3D; Runtime.getRuntime().availableProcessors()<br>&#x2F;&#x2F; 累加单元数组, 懒惰初始化<br>transient volatile Cell[] cells;<br>&#x2F;&#x2F; 基础值, 如果没有竞争, 则用 cas 累加这个域，当 cells 扩容时，也会将数据写到 base 中<br>transient volatile long base;<br>&#x2F;&#x2F; 在 cells 初始化或扩容时只能有一个线程执行, 通过 CAS 更新 cellsBusy 置为 1 来实现一个锁<br>transient volatile int cellsBusy;</p><p>工作流程：</p><ul><li><p>cells 占用内存是相对比较大的，是惰性加载的，在无竞争或者其他线程正在初始化 cells 数组的情况下，直接更新 base 域</p></li><li><p>在第一次发生竞争时（casBase 失败）会创建一个大小为 2 的 cells 数组，将当前累加的值包装为 Cell 对象，放入映射的槽位上</p></li><li><p>分段累加的过程中，如果当前线程对应的 cells 槽位为空，就会新建 Cell 填充，如果出现竞争，就会重新计算线程对应的槽位，继续自旋尝试修改</p></li><li><p>分段迁移后还出现竞争就会扩容 cells 数组长度为原来的两倍，然后 rehash，<strong>数组长度总是 2 的 n 次幂</strong>，默认最大为 CPU 核数，但是可以超过，如果核数是 6 核，数组最长是 8</p></li></ul><p>方法分析：</p><p><strong>LongAdder#add：累加方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">long</span> x)</span> &#123;  <br>    <span class="hljs-comment">// as 为累加单元数组的引用，b 为基础值，v 表示期望值  </span><br>    <span class="hljs-comment">// m 表示 cells 数组的长度 - 1，a 表示当前线程命中的 cell 单元格  </span><br>    Cell[] as; <span class="hljs-type">long</span> b, v; <span class="hljs-type">int</span> m; Cell a;  <br>      <br>    <span class="hljs-comment">// cells 不为空说明 cells 已经被初始化，线程发生了竞争，去更新对应的 cell 槽位  </span><br>    <span class="hljs-comment">// 进入 || 后的逻辑去更新 base 域，更新失败表示发生竞争进入条件  </span><br>    <span class="hljs-keyword">if</span> ((as = cells) != <span class="hljs-literal">null</span> || !casBase(b = base, b + x)) &#123;  <br>        <span class="hljs-comment">// uncontended 为 true 表示 cell 没有竞争  </span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">uncontended</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;  <br>          <br>        <span class="hljs-comment">// 条件一: true 说明 cells 未初始化，多线程写 base 发生竞争需要进行初始化 cells 数组  </span><br>        <span class="hljs-comment">//  fasle 说明 cells 已经初始化，进行下一个条件寻找自己的 cell 去累加  </span><br>        <span class="hljs-comment">// 条件二: getProbe() 获取 hash 值，&amp; m 的逻辑和 HashMap 的逻辑相同，保证散列的均匀性  </span><br>        <span class="hljs-comment">//   true 说明当前线程对应下标的 cell 为空，需要创建 cell  </span><br>        <span class="hljs-comment">//        false 说明当前线程对应的 cell 不为空，进行下一个条件【将 x 值累加到对应的 cell 中】  </span><br>        <span class="hljs-comment">// 条件三: 有取反符号，false 说明 cas 成功，直接返回，true 说明失败，当前线程对应的 cell 有竞争  </span><br>        <span class="hljs-keyword">if</span> (as == <span class="hljs-literal">null</span> || (m = as.length - <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span> ||  <br>            (a = as[getProbe() &amp; m]) == <span class="hljs-literal">null</span> ||  <br>            !(uncontended = a.cas(v = a.value, v + x)))  <br>            longAccumulate(x, <span class="hljs-literal">null</span>, uncontended);  <br>        <span class="hljs-comment">// 【uncontended 在对应的 cell 上累加失败的时候才为 false，其余情况均为 true】  </span><br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Striped64#longAccumulate：cell 数组创建</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// x  null false | true  </span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">longAccumulate</span><span class="hljs-params">(<span class="hljs-type">long</span> x, LongBinaryOperator fn, <span class="hljs-type">boolean</span> wasUncontended)</span> &#123;  <br><span class="hljs-type">int</span> h;  <br><span class="hljs-comment">// 当前线程还没有对应的 cell, 需要随机生成一个 hash 值用来将当前线程绑定到 cell  </span><br><span class="hljs-keyword">if</span> ((h = getProbe()) == <span class="hljs-number">0</span>) &#123;  <br><span class="hljs-comment">// 初始化 probe，获取 hash 值  </span><br>ThreadLocalRandom.current();   <br>h = getProbe();  <br><span class="hljs-comment">// 默认情况下 当前线程肯定是写入到了 cells[0] 位置，不把它当做一次真正的竞争  </span><br>wasUncontended = <span class="hljs-literal">true</span>;  <br>&#125;  <br><span class="hljs-comment">// 表示【扩容意向】，false 一定不会扩容，true 可能会扩容  </span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">collide</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;   <br><span class="hljs-comment">//自旋  </span><br><span class="hljs-keyword">for</span> (;;) &#123;  <br><span class="hljs-comment">// as 表示cells引用，a 表示当前线程命中的 cell，n 表示 cells 数组长度，v 表示 期望值  </span><br>Cell[] as; Cell a; <span class="hljs-type">int</span> n; <span class="hljs-type">long</span> v;  <br><span class="hljs-comment">// 【CASE1】: 表示 cells 已经初始化了，当前线程应该将数据写入到对应的 cell 中  </span><br><span class="hljs-keyword">if</span> ((as = cells) != <span class="hljs-literal">null</span> &amp;&amp; (n = as.length) &gt; <span class="hljs-number">0</span>) &#123;  <br><span class="hljs-comment">// CASE1.1: true 表示当前线程对应的索引下标的 Cell 为 null，需要创建 new Cell  </span><br><span class="hljs-keyword">if</span> ((a = as[(n - <span class="hljs-number">1</span>) &amp; h]) == <span class="hljs-literal">null</span>) &#123;  <br><span class="hljs-comment">// 判断 cellsBusy 是否被锁  </span><br><span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span>) &#123;     <br><span class="hljs-comment">// 创建 cell, 初始累加值为 x  </span><br><span class="hljs-type">Cell</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cell</span>(x);    <br><span class="hljs-comment">// 加锁  </span><br><span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp; casCellsBusy()) &#123;  <br><span class="hljs-comment">// 创建成功标记，进入【创建 cell 逻辑】  </span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">created</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;  <br><span class="hljs-keyword">try</span> &#123;  <br>Cell[] rs; <span class="hljs-type">int</span> m, j;  <br><span class="hljs-comment">// 把当前 cells 数组赋值给 rs，并且不为 null  </span><br><span class="hljs-keyword">if</span> ((rs = cells) != <span class="hljs-literal">null</span> &amp;&amp;  <br>(m = rs.length) &gt; <span class="hljs-number">0</span> &amp;&amp;  <br><span class="hljs-comment">// 再次判断防止其它线程初始化过该位置，当前线程再次初始化该位置会造成数据丢失  </span><br><span class="hljs-comment">// 因为这里是线程安全的判断，进行的逻辑不会被其他线程影响  </span><br>rs[j = (m - <span class="hljs-number">1</span>) &amp; h] == <span class="hljs-literal">null</span>) &#123;  <br><span class="hljs-comment">// 把新创建的 cell 填充至当前位置  </span><br>rs[j] = r;  <br>created = <span class="hljs-literal">true</span>;<span class="hljs-comment">// 表示创建完成  </span><br>&#125;  <br>&#125; <span class="hljs-keyword">finally</span> &#123;  <br>cellsBusy = <span class="hljs-number">0</span>;<span class="hljs-comment">// 解锁  </span><br>&#125;  <br><span class="hljs-keyword">if</span> (created)<span class="hljs-comment">// true 表示创建完成，可以推出循环了  </span><br><span class="hljs-keyword">break</span>;  <br><span class="hljs-keyword">continue</span>;  <br>&#125;  <br>&#125;  <br>collide = <span class="hljs-literal">false</span>;  <br>&#125;  <br><span class="hljs-comment">// CASE1.2: 条件成立说明线程对应的 cell 有竞争, 改变线程对应的 cell 来重试 cas  </span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!wasUncontended)  <br>wasUncontended = <span class="hljs-literal">true</span>;  <br><span class="hljs-comment">// CASE 1.3: 当前线程 rehash 过，如果新命中的 cell 不为空，就尝试累加，false 说明新命中也有竞争  </span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a.cas(v = a.value, ((fn == <span class="hljs-literal">null</span>) ? v + x : fn.applyAsLong(v, x))))  <br><span class="hljs-keyword">break</span>;  <br><span class="hljs-comment">// CASE 1.4: cells 长度已经超过了最大长度 CPU 内核的数量或者已经扩容  </span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n &gt;= NCPU || cells != as)  <br>collide = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 扩容意向改为false，【表示不能扩容了】  </span><br><span class="hljs-comment">// CASE 1.5: 更改扩容意向，如果 n &gt;= NCPU，这里就永远不会执行到，case1.4 永远先于 1.5 执行  </span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!collide)  <br>collide = <span class="hljs-literal">true</span>;  <br><span class="hljs-comment">// CASE 1.6: 【扩容逻辑】，进行加锁  </span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp; casCellsBusy()) &#123;  <br><span class="hljs-keyword">try</span> &#123;  <br><span class="hljs-comment">// 线程安全的检查，防止期间被其他线程扩容了  </span><br><span class="hljs-keyword">if</span> (cells == as) &#123;       <br><span class="hljs-comment">// 扩容为以前的 2 倍  </span><br>Cell[] rs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cell</span>[n &lt;&lt; <span class="hljs-number">1</span>];  <br><span class="hljs-comment">// 遍历移动值  </span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)  <br>rs[i] = as[i];  <br><span class="hljs-comment">// 把扩容后的引用给 cells  </span><br>cells = rs;  <br>&#125;  <br>&#125; <span class="hljs-keyword">finally</span> &#123;  <br>cellsBusy = <span class="hljs-number">0</span>;<span class="hljs-comment">// 解锁  </span><br>&#125;  <br>collide = <span class="hljs-literal">false</span>;<span class="hljs-comment">// 扩容意向改为 false，表示不扩容了  </span><br><span class="hljs-keyword">continue</span>;  <br>&#125;  <br><span class="hljs-comment">// 重置当前线程 Hash 值，这就是【分段迁移机制】  </span><br>h = advanceProbe(h);  <br>&#125;  <br>  <br><span class="hljs-comment">// 【CASE2】: 运行到这说明 cells 还未初始化，as 为null  </span><br><span class="hljs-comment">// 判断是否没有加锁，没有加锁就用 CAS 加锁  </span><br><span class="hljs-comment">// 条件二判断是否其它线程在当前线程给 as 赋值之后修改了 cells，这里不是线程安全的判断  </span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;  <br><span class="hljs-comment">// 初始化标志，开始 【初始化 cells 数组】  </span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">init</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;  <br><span class="hljs-keyword">try</span> &#123;   <br><span class="hljs-comment">// 再次判断 cells == as 防止其它线程已经提前初始化了，当前线程再次初始化导致丢失数据  </span><br><span class="hljs-comment">// 因为这里是【线程安全的，重新检查，经典 DCL】  </span><br><span class="hljs-keyword">if</span> (cells == as) &#123;  <br>Cell[] rs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cell</span>[<span class="hljs-number">2</span>];<span class="hljs-comment">// 初始化数组大小为2  </span><br>rs[h &amp; <span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cell</span>(x);<span class="hljs-comment">// 填充线程对应的cell  </span><br>cells = rs;  <br>init = <span class="hljs-literal">true</span>;<span class="hljs-comment">// 初始化成功，标记置为 true  </span><br>&#125;  <br>&#125; <span class="hljs-keyword">finally</span> &#123;  <br>cellsBusy = <span class="hljs-number">0</span>;<span class="hljs-comment">// 解锁啊  </span><br>&#125;  <br><span class="hljs-keyword">if</span> (init)  <br><span class="hljs-keyword">break</span>;<span class="hljs-comment">// 初始化成功直接跳出自旋  </span><br>&#125;  <br><span class="hljs-comment">// 【CASE3】: 运行到这说明其他线程在初始化 cells，当前线程将值累加到 base，累加成功直接结束自旋  </span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (casBase(v = base, ((fn == <span class="hljs-literal">null</span>) ? v + x :  <br>fn.applyAsLong(v, x))))  <br><span class="hljs-keyword">break</span>;   <br>&#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>sum：获取最终结果通过 sum 整合，保证最终一致性，不保证强一致性</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">sum</span><span class="hljs-params">()</span> &#123;  <br>Cell[] as = cells; Cell a;  <br><span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> base;  <br><span class="hljs-keyword">if</span> (as != <span class="hljs-literal">null</span>) &#123;  <br><span class="hljs-comment">// 遍历 累加  </span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; as.length; ++i) &#123;  <br><span class="hljs-keyword">if</span> ((a = as[i]) != <span class="hljs-literal">null</span>)  <br>sum += a.value;  <br>&#125;  <br>&#125;  <br><span class="hljs-keyword">return</span> sum;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="ABA"><a href="#ABA" class="headerlink" title="ABA"></a>ABA</h3><p>ABA 问题：当进行获取主内存值时，该内存值在写入主内存时已经被修改了 N 次，但是最终又改成原来的值</p><p>其他线程先把 A 改成 B 又改回 A，主线程<strong>仅能判断出共享变量的值与最初值 A 是否相同</strong>，不能感知到这种从 A 改为 B 又 改回 A 的情况，这时 CAS 虽然成功，但是过程存在问题</p><ul><li><p>构造方法：</p><ul><li><code>public AtomicStampedReference(V initialRef, int initialStamp)</code>：初始值和初始版本号</li></ul></li><li><p>常用API：</p><ul><li><p><code>public boolean compareAndSet(V expectedReference, V newReference, int expectedStamp, int newStamp)</code>：<strong>期望引用和期望版本号都一致</strong>才进行 CAS 修改数据</p></li><li><p><code>public void set(V newReference, int newStamp)</code>：设置值和版本号</p></li><li><p><code>public V getReference()</code>：返回引用的值</p></li><li><p><code>public int getStamp()</code>：返回当前版本号</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    AtomicStampedReference&lt;Integer&gt; atomicReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicStampedReference</span>&lt;&gt;(<span class="hljs-number">100</span>,<span class="hljs-number">1</span>);  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">startStamp</span> <span class="hljs-operator">=</span> atomicReference.getStamp();  <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt;&#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> atomicReference.getStamp();  <br>        atomicReference.compareAndSet(<span class="hljs-number">100</span>, <span class="hljs-number">101</span>, stamp, stamp + <span class="hljs-number">1</span>);  <br>        stamp = atomicReference.getStamp();  <br>        atomicReference.compareAndSet(<span class="hljs-number">101</span>, <span class="hljs-number">100</span>, stamp, stamp + <span class="hljs-number">1</span>);  <br>    &#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();  <br>  <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt;&#123;  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            Thread.sleep(<span class="hljs-number">1000</span>);  <br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>            e.printStackTrace();  <br>        &#125;  <br>        <span class="hljs-keyword">if</span> (!atomicReference.compareAndSet(<span class="hljs-number">100</span>, <span class="hljs-number">200</span>, startStamp, startStamp + <span class="hljs-number">1</span>)) &#123;  <br>            System.out.println(atomicReference.getReference());<span class="hljs-comment">//100  </span><br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;线程修改失败&quot;</span>);  <br>        &#125;  <br>    &#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();  <br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h3 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h3><p>Unsafe 是 CAS 的核心类，由于 Java 无法直接访问底层系统，需要通过本地（Native）方法来访问</p><p>Unsafe 类存在 sun.misc 包，其中所有方法都是 native 修饰的，都是直接调用<strong>操作系统底层资源</strong>执行相应的任务，基于该类可以直接操作特定的内存数据，其内部方法操作类似 C 的指针</p><p>模拟实现原子整数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    <span class="hljs-type">MyAtomicInteger</span> <span class="hljs-variable">atomicInteger</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyAtomicInteger</span>(<span class="hljs-number">10</span>);  <br>    <span class="hljs-keyword">if</span> (atomicInteger.compareAndSwap(<span class="hljs-number">20</span>)) &#123;  <br>        System.out.println(atomicInteger.getValue());  <br>    &#125;  <br>&#125;  <br>​  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAtomicInteger</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Unsafe UNSAFE;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> VALUE_OFFSET;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> value;  <br>​  <br>    <span class="hljs-keyword">static</span> &#123;  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            <span class="hljs-comment">//Unsafe unsafe = Unsafe.getUnsafe()这样会报错，需要反射获取  </span><br>            <span class="hljs-type">Field</span> <span class="hljs-variable">theUnsafe</span> <span class="hljs-operator">=</span> Unsafe.class.getDeclaredField(<span class="hljs-string">&quot;theUnsafe&quot;</span>);  <br>            theUnsafe.setAccessible(<span class="hljs-literal">true</span>);  <br>            UNSAFE = (Unsafe) theUnsafe.get(<span class="hljs-literal">null</span>);  <br>            <span class="hljs-comment">// 获取 value 属性的内存地址，value 属性指向该地址，直接设置该地址的值可以修改 value 的值  </span><br>            VALUE_OFFSET = UNSAFE.objectFieldOffset(  <br>                           MyAtomicInteger.class.getDeclaredField(<span class="hljs-string">&quot;value&quot;</span>));  <br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;  <br>            e.printStackTrace();  <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>();  <br>        &#125;  <br>    &#125;  <br>​  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyAtomicInteger</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.value = value;  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> value;  <br>    &#125;  <br>​  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSwap</span><span class="hljs-params">(<span class="hljs-type">int</span> update)</span> &#123;  <br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;  <br>            <span class="hljs-type">int</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.value;  <br>            <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> update;  <br>            <span class="hljs-comment">//  当前对象  内存偏移量    期望值 更新值  </span><br>            <span class="hljs-keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="hljs-built_in">this</span>, VALUE_OFFSET, prev, update)) &#123;  <br>                System.out.println(<span class="hljs-string">&quot;CAS成功&quot;</span>);  <br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestFinal</span> &#123;  <br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;  <br>&#125;<br><br>字节码：<br><br><span class="hljs-number">0</span>: aload_0  <br><span class="hljs-number">1</span>: invokespecial #<span class="hljs-number">1</span> <span class="hljs-comment">// Method java/lang/Object.&quot;&lt; init&gt;&quot;:()V  </span><br><span class="hljs-number">4</span>: aload_0  <br><span class="hljs-number">5</span>: bipush <span class="hljs-number">20</span><span class="hljs-comment">// 将值直接放入栈中  </span><br><span class="hljs-number">7</span>: putfield #<span class="hljs-number">2</span> <span class="hljs-comment">// Field a:I  </span><br>&lt;-- 写屏障  <br><span class="hljs-number">10</span>: <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><p>final 变量的赋值通过 putfield 指令来完成，在这条指令之后也会加入写屏障，保证在其它线程读到它的值时不会出现为 0 的情况</p><p>其他线程访问 final 修饰的变量</p><ul><li><p><strong>复制一份放入栈中</strong>直接访问，效率高</p></li><li><p>大于 short 最大值会将其复制到类的常量池，访问时从常量池获取</p></li></ul><hr><h4 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h4><p>不可变：如果一个对象不能够修改其内部状态（属性），那么就是不可变对象</p><p>不可变对象线程安全的，不存在并发修改和可见性问题，是另一种避免竞争的方式</p><p>String 类也是不可变的，该类和类中所有属性都是 final 的</p><ul><li><p>类用 final 修饰保证了该类中的方法不能被覆盖，防止子类无意间破坏不可变性</p></li><li><p>无写入方法（set）确保外部不能对内部属性进行修改</p></li><li><p>属性用 final 修饰保证了该属性是只读的，不能修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span>  <br><span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;  <br><span class="hljs-comment">/** The value is used for character storage. */</span>  <br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span> value[];  <br><span class="hljs-comment">//....  </span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>更改 String 类数据时，会构造新字符串对象，生成新的 char[] value，通过<strong>创建副本对象来避免共享的方式称之为保护性拷贝</strong></p></li></ul><hr><h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p>无状态：成员变量保存的数据也可以称为状态信息，无状态就是没有成员变量</p><p>Servlet 为了保证其线程安全，一般不为 Servlet 设置成员变量，这种没有任何成员变量的类是线程安全的</p><hr><h3 id="Local"><a href="#Local" class="headerlink" title="Local"></a>Local</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>ThreadLocal 类用来提供线程内部的局部变量，这种变量在多线程环境下访问（通过 get 和 set 方法访问）时能保证各个线程的变量相对独立于其他线程内的变量，分配在堆内的 <strong>TLAB</strong> 中</p><p>ThreadLocal 实例通常来说都是 <code>private static</code> 类型的，属于一个线程的本地变量，用于关联线程和线程上下文。每个线程都会在 ThreadLocal 中保存一份该线程独有的数据，所以是线程安全的</p><p>ThreadLocal 作用：</p><ul><li><p>线程并发：应用在多线程并发的场景下</p></li><li><p>传递数据：通过 ThreadLocal 实现在同一线程不同函数或组件中传递公共变量，减少传递复杂度</p></li><li><p>线程隔离：每个线程的变量都是独立的，不会互相影响</p></li></ul><p>对比 synchronized：</p><table><thead><tr><th></th><th>synchronized</th><th>ThreadLocal</th></tr></thead><tbody><tr><td>原理</td><td>同步机制采用<strong>以时间换空间</strong>的方式，只提供了一份变量，让不同的线程排队访问</td><td>ThreadLocal 采用<strong>以空间换时间</strong>的方式，为每个线程都提供了一份变量的副本，从而实现同时访问而相不干扰</td></tr><tr><td>侧重点</td><td>多个线程之间访问资源的同步</td><td>多线程中让每个线程之间的数据相互隔离</td></tr></tbody></table><hr><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><h5 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h5><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>ThreadLocal&lt;&gt;()</td><td>创建 ThreadLocal 对象</td></tr><tr><td>protected T initialValue()</td><td>返回当前线程局部变量的初始值</td></tr><tr><td>public void set( T value)</td><td>设置当前线程绑定的局部变量</td></tr><tr><td>public T get()</td><td>获取当前线程绑定的局部变量</td></tr><tr><td>public void remove()</td><td>移除当前线程绑定的局部变量</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyDemo</span> &#123;  <br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;String&gt; tl = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();  <br>  <br>    <span class="hljs-keyword">private</span> String content;  <br>  <br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getContent</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-comment">// 获取当前线程绑定的变量  </span><br>        <span class="hljs-keyword">return</span> tl.get();  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setContent</span><span class="hljs-params">(String content)</span> &#123;  <br>        <span class="hljs-comment">// 变量content绑定到当前线程  </span><br>        tl.set(content);  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">MyDemo</span> <span class="hljs-variable">demo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyDemo</span>();  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;  <br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;  <br>                <span class="hljs-meta">@Override</span>  <br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>                    <span class="hljs-comment">// 设置数据  </span><br>                    demo.setContent(Thread.currentThread().getName() + <span class="hljs-string">&quot;的数据&quot;</span>);  <br>                    System.out.println(<span class="hljs-string">&quot;-----------------------&quot;</span>);  <br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;---&gt;&quot;</span> + demo.getContent());  <br>                &#125;  <br>            &#125;);  <br>            thread.setName(<span class="hljs-string">&quot;线程&quot;</span> + i);  <br>            thread.start();  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h5><p>ThreadLocal 适用于下面两种场景：</p><ul><li><p>每个线程需要有自己单独的实例</p></li><li><p>实例需要在多个方法中共享，但不希望被多线程共享</p></li></ul><p>ThreadLocal 方案有两个突出的优势：</p><ol><li><p>传递数据：保存每个线程绑定的数据，在需要的地方可以直接获取，避免参数直接传递带来的代码耦合问题</p></li><li><p>线程隔离：各线程之间的数据相互隔离却又具备并发性，避免同步方式带来的性能损失</p></li></ol><p>ThreadLocal 用于数据连接的事务管理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JdbcUtils</span> &#123;  <br>    <span class="hljs-comment">// ThreadLocal对象，将connection绑定在当前线程中  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;Connection&gt; tl = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>();  <br>    <span class="hljs-comment">// c3p0 数据库连接池对象属性  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ComboPooledDataSource</span> <span class="hljs-variable">ds</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ComboPooledDataSource</span>();  <br>    <span class="hljs-comment">// 获取连接  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;  <br>        <span class="hljs-comment">//取出当前线程绑定的connection对象  </span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> tl.get();  <br>        <span class="hljs-keyword">if</span> (conn == <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-comment">//如果没有，则从连接池中取出  </span><br>            conn = ds.getConnection();  <br>            <span class="hljs-comment">//再将connection对象绑定到当前线程中，非常重要的操作  </span><br>            tl.set(conn);  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> conn;  <br>    &#125;  <br><span class="hljs-comment">// ...  </span><br>&#125;<br></code></pre></td></tr></table></figure><p>用 ThreadLocal 使 SimpleDateFormat 从独享变量变成单个线程变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalDateUtil</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;DateFormat&gt; threadLocal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;DateFormat&gt;() &#123;  <br>        <span class="hljs-meta">@Override</span>  <br>        <span class="hljs-keyword">protected</span> DateFormat <span class="hljs-title function_">initialValue</span><span class="hljs-params">()</span> &#123;  <br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);  <br>        &#125;  <br>    &#125;;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Date <span class="hljs-title function_">parse</span><span class="hljs-params">(String dateStr)</span> <span class="hljs-keyword">throws</span> ParseException &#123;  <br>        <span class="hljs-keyword">return</span> threadLocal.get().parse(dateStr);  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">format</span><span class="hljs-params">(Date date)</span> &#123;  <br>        <span class="hljs-keyword">return</span> threadLocal.get().format(date);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><h5 id="底层结构"><a href="#底层结构" class="headerlink" title="底层结构"></a>底层结构</h5><p>JDK8 以前：每个 ThreadLocal 都创建一个 Map，然后用线程作为 Map 的 key，要存储的局部变量作为 Map 的 value，达到各个线程的局部变量隔离的效果。这种结构会造成 Map 结构过大和内存泄露，因为 Thread 停止后无法通过 key 删除对应的数据</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041721661.png"></p><p>JDK8 以后：每个 Thread 维护一个 ThreadLocalMap，这个 Map 的 key 是 ThreadLocal 实例本身，value 是真正要存储的值</p><ul><li><p><strong>每个 Thread 线程内部都有一个 Map (ThreadLocalMap)</strong></p></li><li><p>Map 里面存储 ThreadLocal 对象（key）和线程的私有变量（value）</p></li><li><p>Thread 内部的 Map 是由 ThreadLocal 维护的，由 ThreadLocal 负责向 map 获取和设置线程的变量值</p></li><li><p>对于不同的线程，每次获取副本值时，别的线程并不能获取到当前线程的副本值，形成副本的隔离，互不干扰</p></li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041722540.png"></p><p>JDK8 前后对比：</p><ul><li><p>每个 Map 存储的 Entry 数量会变少，因为之前的存储数量由 Thread 的数量决定，现在由 ThreadLocal 的数量决定，在实际编程当中，往往 ThreadLocal 的数量要少于 Thread 的数量</p></li><li><p>当 Thread 销毁之后，对应的 ThreadLocalMap 也会随之销毁，能减少内存的使用，<strong>防止内存泄露</strong></p></li></ul><hr><h5 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h5><ul><li><p>Thread 类的相关属性：<strong>每一个线程持有一个 ThreadLocalMap 对象</strong>，存放由 ThreadLocal 和数据组成的 Entry 键值对</p><p>  ThreadLocal.ThreadLocalMap threadLocals &#x3D; null</p></li><li><p>计算 ThreadLocal 对象的哈希值：</p><p>  private final int threadLocalHashCode &#x3D; nextHashCode()</p><p>  使用 <code>threadLocalHashCode &amp; (table.length - 1)</code> 计算当前 entry 需要存放的位置</p></li><li><p>每创建一个 ThreadLocal 对象就会使用 nextHashCode 分配一个 hash 值给这个对象：</p><p>  private static AtomicInteger nextHashCode &#x3D; new AtomicInteger()</p></li><li><p>斐波那契数也叫黄金分割数，hash 的<strong>增量</strong>就是这个数字，带来的好处是 hash 分布非常均匀：</p><p>  private static final int HASH_INCREMENT &#x3D; 0x61c88647</p></li></ul><hr><h5 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h5><p>方法都是线程安全的，因为 ThreadLocal 属于一个线程的，ThreadLocal 中的方法，逻辑都是获取当前线程维护的 ThreadLocalMap 对象，然后进行数据的增删改查，没有指定初始值的 threadlcoal 对象默认赋值为 null</p><ul><li><p>initialValue()：返回该线程局部变量的初始值</p><ul><li><p>延迟调用的方法，在执行 get 方法时才执行</p></li><li><p>该方法缺省（默认）实现直接返回一个 null</p></li><li><p>如果想要一个初始值，可以重写此方法， 该方法是一个 <code>protected</code> 的方法，为了让子类覆盖而设计的</p></li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> T <span class="hljs-title function_">initialValue</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>nextHashCode()：计算哈希值，ThreadLocal 的散列方式称之为<strong>斐波那契散列</strong>，每次获取哈希值都会加上 HASH_INCREMENT，这样做可以尽量避免 hash 冲突，让哈希值能均匀的分布在 2 的 n 次方的数组中</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nextHashCode</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">// 哈希值自增一个 HASH_INCREMENT 数值  </span><br>    <span class="hljs-keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>set()：修改当前线程与当前 threadlocal 对象相关联的线程局部变量</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;  <br>    <span class="hljs-comment">// 获取当前线程对象  </span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();  <br>    <span class="hljs-comment">// 获取此线程对象中维护的 ThreadLocalMap 对象  </span><br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);  <br>    <span class="hljs-comment">// 判断 map 是否存在  </span><br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>)  <br>        <span class="hljs-comment">// 调用 threadLocalMap.set 方法进行重写或者添加  </span><br>        map.set(<span class="hljs-built_in">this</span>, value);  <br>    <span class="hljs-keyword">else</span>  <br>        <span class="hljs-comment">// map 为空，调用 createMap 进行 ThreadLocalMap 对象的初始化。参数1是当前线程，参数2是局部变量  </span><br>        createMap(t, value);  <br>&#125;<br><br><span class="hljs-comment">// 获取当前线程 Thread 对应维护的 ThreadLocalMap   </span><br>ThreadLocalMap <span class="hljs-title function_">getMap</span><span class="hljs-params">(Thread t)</span> &#123;  <br>    <span class="hljs-keyword">return</span> t.threadLocals;  <br>&#125;  <br><span class="hljs-comment">// 创建当前线程Thread对应维护的ThreadLocalMap   </span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> &#123;  <br>    <span class="hljs-comment">// 【这里的 this 是调用此方法的 threadLocal】，创建一个新的 Map 并设置第一个数据  </span><br>    t.threadLocals = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalMap</span>(<span class="hljs-built_in">this</span>, firstValue);  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>get()：获取当前线程与当前 ThreadLocal 对象相关联的线程局部变量</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();  <br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);  <br>    <span class="hljs-comment">// 如果此map存在  </span><br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;  <br>        <span class="hljs-comment">// 以当前的 ThreadLocal 为 key，调用 getEntry 获取对应的存储实体 e  </span><br>        ThreadLocalMap.<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> map.getEntry(<span class="hljs-built_in">this</span>);  <br>        <span class="hljs-comment">// 对 e 进行判空   </span><br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-comment">// 获取存储实体 e 对应的 value值  </span><br>            <span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (T)e.value;  <br>            <span class="hljs-keyword">return</span> result;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-comment">/*有两种情况有执行当前代码  </span><br><span class="hljs-comment">      第一种情况: map 不存在，表示此线程没有维护的 ThreadLocalMap 对象  </span><br><span class="hljs-comment">      第二种情况: map 存在, 但是【没有与当前 ThreadLocal 关联的 entry】，就会设置为默认值 */</span>  <br>    <span class="hljs-comment">// 初始化当前线程与当前 threadLocal 对象相关联的 value  </span><br>    <span class="hljs-keyword">return</span> setInitialValue();  <br>&#125;<br><br><span class="hljs-keyword">private</span> T <span class="hljs-title function_">setInitialValue</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">// 调用initialValue获取初始化的值，此方法可以被子类重写, 如果不重写默认返回 null  </span><br>    <span class="hljs-type">T</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> initialValue();  <br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();  <br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);  <br>    <span class="hljs-comment">// 判断 map 是否初始化过  </span><br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>)  <br>        <span class="hljs-comment">// 存在则调用 map.set 设置此实体 entry，value 是默认的值  </span><br>        map.set(<span class="hljs-built_in">this</span>, value);  <br>    <span class="hljs-keyword">else</span>  <br>        <span class="hljs-comment">// 调用 createMap 进行 ThreadLocalMap 对象的初始化中  </span><br>        createMap(t, value);  <br>    <span class="hljs-comment">// 返回线程与当前 threadLocal 关联的局部变量  </span><br>    <span class="hljs-keyword">return</span> value;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>remove()：移除当前线程与当前 threadLocal 对象相关联的线程局部变量</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">// 获取当前线程对象中维护的 ThreadLocalMap 对象  </span><br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> getMap(Thread.currentThread());  <br>    <span class="hljs-keyword">if</span> (m != <span class="hljs-literal">null</span>)  <br>        <span class="hljs-comment">// map 存在则调用 map.remove，this时当前ThreadLocal，以this为key删除对应的实体  </span><br>        m.remove(<span class="hljs-built_in">this</span>);  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h4 id="LocalMap"><a href="#LocalMap" class="headerlink" title="LocalMap"></a>LocalMap</h4><h5 id="成员属性"><a href="#成员属性" class="headerlink" title="成员属性"></a>成员属性</h5><p>ThreadLocalMap 是 ThreadLocal 的内部类，没有实现 Map 接口，用独立的方式实现了 Map 的功能，其内部 Entry 也是独立实现</p><p>&#x2F;&#x2F; 初始化当前 map 内部散列表数组的初始长度 16<br>private static final int INITIAL_CAPACITY &#x3D; 16;  </p><p>&#x2F;&#x2F; 存放数据的table，数组长度必须是2的整次幂。<br>private Entry[] table;  </p><p>&#x2F;&#x2F; 数组里面 entrys 的个数，可以用于判断 table 当前使用量是否超过阈值<br>private int size &#x3D; 0;  </p><p>&#x2F;&#x2F; 进行扩容的阈值，表使用量大于它的时候进行扩容。<br>private int threshold;</p><p>存储结构 Entry：</p><ul><li><p>Entry 继承 WeakReference，key 是弱引用，目的是将 ThreadLocal 对象的生命周期和线程生命周期解绑</p></li><li><p>Entry 限制只能用 ThreadLocal 作为 key，key 为 null (entry.get() &#x3D;&#x3D; null) 意味着 key 不再被引用，entry 也可以从 table 中清除</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;  <br>    Object value;  <br>    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;  <br>        <span class="hljs-comment">// this.referent = referent = key;  </span><br>        <span class="hljs-built_in">super</span>(k);  <br>        value = v;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>构造方法：延迟初始化的，线程第一次存储 threadLocal - value 时才会创建 threadLocalMap 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;  <br>    <span class="hljs-comment">// 初始化table，创建一个长度为16的Entry数组  </span><br>    table = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[INITIAL_CAPACITY];  <br>    <span class="hljs-comment">// 【寻址算法】计算索引  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="hljs-number">1</span>);  <br>    <span class="hljs-comment">// 创建 entry 对象，存放到指定位置的 slot 中  </span><br>    table[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(firstKey, firstValue);  <br>    <span class="hljs-comment">// 数据总量是 1  </span><br>    size = <span class="hljs-number">1</span>;  <br>    <span class="hljs-comment">// 将阈值设置为 （当前数组长度 * 2）/ 3。  </span><br>    setThreshold(INITIAL_CAPACITY);  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="成员方法-1"><a href="#成员方法-1" class="headerlink" title="成员方法"></a>成员方法</h5><ul><li><p>set()：添加数据，ThreadLocalMap 使用<strong>线性探测法来解决哈希冲突</strong></p><ul><li><p>该方法会一直探测下一个地址，直到有空的地址后插入，若插入后 Map 数量超过阈值，数组会扩容为原来的 2 倍</p><p>  假设当前 table 长度为16，计算出来 key 的 hash 值为 14，如果 table[14] 上已经有值，并且其 key 与当前 key 不一致，那么就发生了 hash 冲突，这个时候将 14 加 1 得到 15，取 table[15] 进行判断，如果还是冲突会回到 0，取 table[0]，以此类推，直到可以插入，可以把 Entry[] table 看成一个<strong>环形数组</strong></p></li><li><p>线性探测法会出现<strong>堆积问题</strong>，可以采取平方探测法解决</p></li><li><p>在探测过程中 ThreadLocal 会复用 key 为 null 的脏 Entry 对象，并进行垃圾清理，防止出现内存泄漏</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;  <br>    <span class="hljs-comment">// 获取散列表  </span><br>    ThreadLocal.ThreadLocalMap.Entry[] tab = table;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;  <br>    <span class="hljs-comment">// 哈希寻址  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (len-<span class="hljs-number">1</span>);  <br>    <span class="hljs-comment">// 使用线性探测法向后查找元素，碰到 entry 为空时停止探测  </span><br>    <span class="hljs-keyword">for</span> (ThreadLocal.ThreadLocalMap.<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[i]; e != <span class="hljs-literal">null</span>; e = tab[i = nextIndex(i, len)]) &#123;  <br>        <span class="hljs-comment">// 获取当前元素 key  </span><br>        ThreadLocal&lt;?&gt; k = e.get();  <br>        <span class="hljs-comment">// ThreadLocal 对应的 key 存在，【直接覆盖之前的值】  </span><br>        <span class="hljs-keyword">if</span> (k == key) &#123;  <br>            e.value = value;  <br>            <span class="hljs-keyword">return</span>;  <br>        &#125;  <br>        <span class="hljs-comment">// 【这两个条件谁先成立不一定，所以 replaceStaleEntry 中还需要判断 k == key 的情况】  </span><br>          <br>        <span class="hljs-comment">// key 为 null，但是值不为 null，说明之前的 ThreadLocal 对象已经被回收了，当前是【过期数据】  </span><br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-comment">// 【碰到一个过期的 slot，当前数据复用该槽位，替换过期数据】  </span><br>            <span class="hljs-comment">// 这个方法还进行了垃圾清理动作，防止内存泄漏  </span><br>            replaceStaleEntry(key, value, i);  <br>            <span class="hljs-keyword">return</span>;  <br>        &#125;  <br>    &#125;  <br><span class="hljs-comment">// 逻辑到这说明碰到 slot == null 的位置，则在空元素的位置创建一个新的 Entry  </span><br>    tab[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(key, value);  <br>    <span class="hljs-comment">// 数量 + 1  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">sz</span> <span class="hljs-operator">=</span> ++size;  <br>      <br>    <span class="hljs-comment">// 【做一次启发式清理】，如果没有清除任何 entry 并且【当前使用量达到了负载因子所定义，那么进行 rehash  </span><br>    <span class="hljs-keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)  <br>        <span class="hljs-comment">// 扩容  </span><br>        rehash();  <br>&#125;<br><br><span class="hljs-comment">// 获取【环形数组】的下一个索引  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nextIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> len)</span> &#123;  <br>    <span class="hljs-comment">// 索引越界后从 0 开始继续获取  </span><br>    <span class="hljs-keyword">return</span> ((i + <span class="hljs-number">1</span> &lt; len) ? i + <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);  <br>&#125;<br><br><span class="hljs-comment">// 在指定位置插入指定的数据  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">replaceStaleEntry</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, Object value, <span class="hljs-type">int</span> staleSlot)</span> &#123;  <br>    <span class="hljs-comment">// 获取散列表  </span><br>    Entry[] tab = table;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;  <br>    Entry e;  <br><span class="hljs-comment">// 探测式清理的开始下标，默认从当前 staleSlot 开始  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">slotToExpunge</span> <span class="hljs-operator">=</span> staleSlot;  <br>    <span class="hljs-comment">// 以当前 staleSlot 开始【向前迭代查找】，找到索引靠前过期数据，找到以后替换 slotToExpunge 值  </span><br>    <span class="hljs-comment">// 【保证在一个区间段内，从最前面的过期数据开始清理】  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> prevIndex(staleSlot, len); (e = tab[i]) != <span class="hljs-literal">null</span>; i = prevIndex(i, len))  <br>        <span class="hljs-keyword">if</span> (e.get() == <span class="hljs-literal">null</span>)  <br>            slotToExpunge = i;  <br>  <br><span class="hljs-comment">// 以 staleSlot 【向后去查找】，直到碰到 null 为止，还是线性探测  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> nextIndex(staleSlot, len); (e = tab[i]) != <span class="hljs-literal">null</span>; i = nextIndex(i, len)) &#123;  <br>        <span class="hljs-comment">// 获取当前节点的 key  </span><br>        ThreadLocal&lt;?&gt; k = e.get();  <br><span class="hljs-comment">// 条件成立说明是【替换逻辑】  </span><br>        <span class="hljs-keyword">if</span> (k == key) &#123;  <br>            e.value = value;  <br>            <span class="hljs-comment">// 因为本来要在 staleSlot 索引处插入该数据，现在找到了i索引处的key与数据一致  </span><br>            <span class="hljs-comment">// 但是 i 位置距离正确的位置更远，因为是向后查找，所以还是要在 staleSlot 位置插入当前 entry  </span><br>            <span class="hljs-comment">// 然后将 table[staleSlot] 这个过期数据放到当前循环到的 table[i] 这个位置，  </span><br>            tab[i] = tab[staleSlot];  <br>            tab[staleSlot] = e;  <br>  <br>            <span class="hljs-comment">// 条件成立说明向前查找过期数据并未找到过期的 entry，但 staleSlot 位置已经不是过期数据了，i 位置才是  </span><br>            <span class="hljs-keyword">if</span> (slotToExpunge == staleSlot)  <br>                slotToExpunge = i;  <br>              <br>            <span class="hljs-comment">// 【清理过期数据，expungeStaleEntry 探测式清理，cleanSomeSlots 启发式清理】  </span><br>            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);  <br>            <span class="hljs-keyword">return</span>;  <br>        &#125;  <br><span class="hljs-comment">// 条件成立说明当前遍历的 entry 是一个过期数据，并且该位置前面也没有过期数据  </span><br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span> &amp;&amp; slotToExpunge == staleSlot)  <br>            <span class="hljs-comment">// 探测式清理过期数据的开始下标修改为当前循环的 index，因为 staleSlot 会放入要添加的数据  </span><br>            slotToExpunge = i;  <br>    &#125;  <br><span class="hljs-comment">// 向后查找过程中并未发现 k == key 的 entry，说明当前是一个【取代过期数据逻辑】  </span><br>    <span class="hljs-comment">// 删除原有的数据引用，防止内存泄露  </span><br>    tab[staleSlot].value = <span class="hljs-literal">null</span>;  <br>    <span class="hljs-comment">// staleSlot 位置添加数据，【上面的所有逻辑都不会更改 staleSlot 的值】  </span><br>    tab[staleSlot] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(key, value);  <br>  <br>    <span class="hljs-comment">// 条件成立说明除了 staleSlot 以外，还发现其它的过期 slot，所以要【开启清理数据的逻辑】  </span><br>    <span class="hljs-keyword">if</span> (slotToExpunge != staleSlot)  <br>        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);  <br>&#125;<br><br></code></pre></td></tr></table></figure><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041727787.png"></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">prevIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> len)</span> &#123;  <br>    <span class="hljs-comment">// 形成一个环绕式的访问，头索引越界后置为尾索引  </span><br>    <span class="hljs-keyword">return</span> ((i - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>) ? i - <span class="hljs-number">1</span> : len - <span class="hljs-number">1</span>);  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>getEntry()：ThreadLocal 的 get 方法以当前的 ThreadLocal 为 key，调用 getEntry 获取对应的存储实体 e</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> Entry <span class="hljs-title function_">getEntry</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key)</span> &#123;  <br>    <span class="hljs-comment">// 哈希寻址  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (table.length - <span class="hljs-number">1</span>);  <br>    <span class="hljs-comment">// 访问散列表中指定指定位置的 slot   </span><br>    <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> table[i];  <br>    <span class="hljs-comment">// 条件成立，说明 slot 有值并且 key 就是要寻找的 key，直接返回  </span><br>    <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span> &amp;&amp; e.get() == key)  <br>        <span class="hljs-keyword">return</span> e;  <br>    <span class="hljs-keyword">else</span>  <br>        <span class="hljs-comment">// 进行线性探测  </span><br>        <span class="hljs-keyword">return</span> getEntryAfterMiss(key, i, e);  <br>&#125;  <br><span class="hljs-comment">// 线性探测寻址  </span><br><span class="hljs-keyword">private</span> Entry <span class="hljs-title function_">getEntryAfterMiss</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, <span class="hljs-type">int</span> i, Entry e)</span> &#123;  <br>    <span class="hljs-comment">// 获取散列表  </span><br>    Entry[] tab = table;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;  <br>  <br>    <span class="hljs-comment">// 开始遍历，碰到 slot == null 的情况，搜索结束  </span><br>    <span class="hljs-keyword">while</span> (e != <span class="hljs-literal">null</span>) &#123;  <br><span class="hljs-comment">// 获取当前 slot 中 entry 对象的 key  </span><br>        ThreadLocal&lt;?&gt; k = e.get();  <br>        <span class="hljs-comment">// 条件成立说明找到了，直接返回  </span><br>        <span class="hljs-keyword">if</span> (k == key)  <br>            <span class="hljs-keyword">return</span> e;  <br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>)  <br>             <span class="hljs-comment">// 过期数据，【探测式过期数据回收】  </span><br>            expungeStaleEntry(i);  <br>        <span class="hljs-keyword">else</span>  <br>            <span class="hljs-comment">// 更新 index 继续向后走  </span><br>            i = nextIndex(i, len);  <br>        <span class="hljs-comment">// 获取下一个槽位中的 entry  </span><br>        e = tab[i];  <br>    &#125;  <br>    <span class="hljs-comment">// 说明当前区段没有找到相应数据  </span><br>    <span class="hljs-comment">// 【因为存放数据是线性的向后寻找槽位，都是紧挨着的，不可能越过一个 空槽位 在后面放】，可以减少遍历的次数  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>rehash()：触发一次全量清理，如果数组长度大于等于长度的 <code>2/3 * 3/4 = 1/2</code>，则进行 resize</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rehash</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">// 清楚当前散列表内的【所有】过期的数据  </span><br>    expungeStaleEntries();  <br>      <br>    <span class="hljs-comment">// threshold = len * 2 / 3，就是 2/3 * (1 - 1/4)  </span><br>    <span class="hljs-keyword">if</span> (size &gt;= threshold - threshold / <span class="hljs-number">4</span>)  <br>        resize();  <br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">expungeStaleEntries</span><span class="hljs-params">()</span> &#123;  <br>    Entry[] tab = table;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;  <br>    <span class="hljs-comment">// 【遍历所有的槽位，清理过期数据】  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; len; j++) &#123;  <br>        <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[j];  <br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span> &amp;&amp; e.get() == <span class="hljs-literal">null</span>)  <br>            expungeStaleEntry(j);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>  Entry <strong>数组为扩容为原来的 2 倍</strong> ，重新计算 key 的散列值，如果遇到 key 为 null 的情况，会将其 value 也置为 null，帮助 GC</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">resize</span><span class="hljs-params">()</span> &#123;  <br>    Entry[] oldTab = table;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldLen</span> <span class="hljs-operator">=</span> oldTab.length;  <br>    <span class="hljs-comment">// 新数组的长度是老数组的二倍  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">newLen</span> <span class="hljs-operator">=</span> oldLen * <span class="hljs-number">2</span>;  <br>    Entry[] newTab = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[newLen];  <br>    <span class="hljs-comment">// 统计新table中的entry数量  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br><span class="hljs-comment">// 遍历老表，进行【数据迁移】  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; oldLen; ++j) &#123;  <br>        <span class="hljs-comment">// 访问老表的指定位置的 entry  </span><br>        <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> oldTab[j];  <br>        <span class="hljs-comment">// 条件成立说明老表中该位置有数据，可能是过期数据也可能不是  </span><br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;  <br>            ThreadLocal&lt;?&gt; k = e.get();  <br>            <span class="hljs-comment">// 过期数据  </span><br>            <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>) &#123;  <br>                e.value = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Help the GC  </span><br>            &#125; <span class="hljs-keyword">else</span> &#123;  <br>                <span class="hljs-comment">// 非过期数据，在新表中进行哈希寻址  </span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> k.threadLocalHashCode &amp; (newLen - <span class="hljs-number">1</span>);  <br>                <span class="hljs-comment">// 【线程探测】  </span><br>                <span class="hljs-keyword">while</span> (newTab[h] != <span class="hljs-literal">null</span>)  <br>                    h = nextIndex(h, newLen);  <br>                <span class="hljs-comment">// 将数据存放到新表合适的 slot 中  </span><br>                newTab[h] = e;  <br>                count++;  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br><span class="hljs-comment">// 设置下一次触发扩容的指标：threshold = len * 2 / 3;  </span><br>    setThreshold(newLen);  <br>    size = count;  <br>    <span class="hljs-comment">// 将扩容后的新表赋值给 threadLocalMap 内部散列表数组引用  </span><br>    table = newTab;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>remove()：删除 Entry</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key)</span> &#123;  <br>    Entry[] tab = table;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;  <br>    <span class="hljs-comment">// 哈希寻址  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (len-<span class="hljs-number">1</span>);  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[i]; e != <span class="hljs-literal">null</span>; e = tab[i = nextIndex(i, len)]) &#123;  <br>        <span class="hljs-comment">// 找到了对应的 key  </span><br>        <span class="hljs-keyword">if</span> (e.get() == key) &#123;  <br>            <span class="hljs-comment">// 设置 key 为 null  </span><br>            e.clear();  <br>            <span class="hljs-comment">// 探测式清理  </span><br>            expungeStaleEntry(i);  <br>            <span class="hljs-keyword">return</span>;  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h5 id="清理方法"><a href="#清理方法" class="headerlink" title="清理方法"></a>清理方法</h5><ul><li><p>探测式清理：沿着开始位置向后探测清理过期数据，沿途中碰到未过期数据则将此数据 rehash 在 table 数组中的定位，重定位后的元素理论上更接近 <code>i = entry.key &amp; (table.length - 1)</code>，让<strong>数据的排列更紧凑</strong>，会优化整个散列表查询性能</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// table[staleSlot] 是一个过期数据，以这个位置开始继续向后查找过期数据  </span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">expungeStaleEntry</span><span class="hljs-params">(<span class="hljs-type">int</span> staleSlot)</span> &#123;  <br>    <span class="hljs-comment">// 获取散列表和数组长度  </span><br>    Entry[] tab = table;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;  <br>  <br>    <span class="hljs-comment">// help gc，先把当前过期的 entry 置空，在取消对 entry 的引用  </span><br>    tab[staleSlot].value = <span class="hljs-literal">null</span>;  <br>    tab[staleSlot] = <span class="hljs-literal">null</span>;  <br>    <span class="hljs-comment">// 数量-1  </span><br>    size--;  <br>  <br>    Entry e;  <br>    <span class="hljs-type">int</span> i;  <br>    <span class="hljs-comment">// 从 staleSlot 开始向后遍历，直到碰到 slot == null 结束，【区间内清理过期数据】  </span><br>    <span class="hljs-keyword">for</span> (i = nextIndex(staleSlot, len); (e = tab[i]) != <span class="hljs-literal">null</span>; i = nextIndex(i, len)) &#123;  <br>        ThreadLocal&lt;?&gt; k = e.get();  <br>        <span class="hljs-comment">// 当前 entry 是过期数据  </span><br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-comment">// help gc  </span><br>            e.value = <span class="hljs-literal">null</span>;  <br>            tab[i] = <span class="hljs-literal">null</span>;  <br>            size--;  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            <span class="hljs-comment">// 当前 entry 不是过期数据的逻辑，【rehash】  </span><br>            <span class="hljs-comment">// 重新计算当前 entry 对应的 index  </span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> k.threadLocalHashCode &amp; (len - <span class="hljs-number">1</span>);  <br>            <span class="hljs-comment">// 条件成立说明当前 entry 存储时发生过 hash 冲突，向后偏移过了  </span><br>            <span class="hljs-keyword">if</span> (h != i) &#123;  <br>                <span class="hljs-comment">// 当前位置置空  </span><br>                tab[i] = <span class="hljs-literal">null</span>;  <br>                <span class="hljs-comment">// 以正确位置 h 开始，向后查找第一个可以存放 entry 的位置  </span><br>                <span class="hljs-keyword">while</span> (tab[h] != <span class="hljs-literal">null</span>)  <br>                    h = nextIndex(h, len);  <br>                <span class="hljs-comment">// 将当前元素放入到【距离正确位置更近的位置，有可能就是正确位置】  </span><br>                tab[h] = e;  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-comment">// 返回 slot = null 的槽位索引，图例是 7，这个索引代表【索引前面的区间已经清理完成垃圾了】  </span><br>    <span class="hljs-keyword">return</span> i;  <br>&#125;<br></code></pre></td></tr></table></figure><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041729624.png"></p><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041729128.png"></p></li><li><p>启发式清理：向后循环扫描过期数据，发现过期数据调用探测式清理方法，如果连续几次的循环都没有发现过期数据，就停止扫描</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">//  i 表示启发式清理工作开始位置，一般是空 slot，n 一般传递的是 table.length   </span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">cleanSomeSlots</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> n)</span> &#123;  <br>    <span class="hljs-comment">// 表示启发式清理工作是否清除了过期数据  </span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">removed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;  <br>    <span class="hljs-comment">// 获取当前 map 的散列表引用  </span><br>    Entry[] tab = table;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;  <br>    <span class="hljs-keyword">do</span> &#123;  <br>        <span class="hljs-comment">// 获取下一个索引，因为探测式返回的 slot 为 null  </span><br>        i = nextIndex(i, len);  <br>        <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[i];  <br>        <span class="hljs-comment">// 条件成立说明是过期的数据，key 被 gc 了  </span><br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span> &amp;&amp; e.get() == <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-comment">// 【发现过期数据重置 n 为数组的长度】  </span><br>            n = len;  <br>            <span class="hljs-comment">// 表示清理过过期数据  </span><br>            removed = <span class="hljs-literal">true</span>;  <br>            <span class="hljs-comment">// 以当前过期的 slot 为开始节点 做一次探测式清理工作  </span><br>            i = expungeStaleEntry(i);  <br>        &#125;  <br>        <span class="hljs-comment">// 假设 table 长度为 16  </span><br>        <span class="hljs-comment">// 16 &gt;&gt;&gt; 1 ==&gt; 8，8 &gt;&gt;&gt; 1 ==&gt; 4，4 &gt;&gt;&gt; 1 ==&gt; 2，2 &gt;&gt;&gt; 1 ==&gt; 1，1 &gt;&gt;&gt; 1 ==&gt; 0  </span><br>        <span class="hljs-comment">// 连续经过这么多次循环【没有扫描到过期数据】，就停止循环，扫描到空 slot 不算，因为不是过期数据  </span><br>    &#125; <span class="hljs-keyword">while</span> ((n &gt;&gt;&gt;= <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>);  <br>      <br>    <span class="hljs-comment">// 返回清除标记  </span><br>    <span class="hljs-keyword">return</span> removed;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h4><p>Memory leak：内存泄漏是指程序中动态分配的堆内存由于某种原因未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果，内存泄漏的堆积终将导致内存溢出</p><ul><li><p>如果 key 使用强引用：使用完 ThreadLocal ，threadLocal Ref 被回收，但是 threadLocalMap 的 Entry 强引用了 threadLocal，造成 threadLocal 无法被回收，无法完全避免内存泄漏</p><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041730276.png"></p></li><li><p>如果 key 使用弱引用：使用完 ThreadLocal ，threadLocal Ref 被回收，ThreadLocalMap 只持有 ThreadLocal 的弱引用，所以threadlocal 也可以被回收，此时 Entry 中的 key &#x3D; null。但没有手动删除这个 Entry 或者 CurrentThread 依然运行，依然存在强引用链，value 不会被回收，而这块 value 永远不会被访问到，也会导致 value 内存泄漏</p><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041730339.png"></p></li><li><p>两个主要原因：</p><ul><li><p>没有手动删除这个 Entry</p></li><li><p>CurrentThread 依然运行</p></li></ul></li></ul><p>根本原因：ThreadLocalMap 是 Thread的一个属性，<strong>生命周期跟 Thread 一样长</strong>，如果没有手动删除对应 Entry 就会导致内存泄漏</p><p>解决方法：使用完 ThreadLocal 中存储的内容后将它 remove 掉就可以</p><p>ThreadLocal 内部解决方法：在 ThreadLocalMap 中的 set&#x2F;getEntry 方法中，通过线性探测法对 key 进行判断，如果 key 为 null（ThreadLocal 为 null）会对 Entry 进行垃圾回收。所以<strong>使用弱引用比强引用多一层保障</strong>，就算不调用 remove，也有机会进行 GC</p><hr><h4 id="变量传递"><a href="#变量传递" class="headerlink" title="变量传递"></a>变量传递</h4><h5 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h5><p>父子线程：创建子线程的线程是父线程，比如实例中的 main 线程就是父线程</p><p>ThreadLocal 中存储的是线程的局部变量，如果想<strong>实现线程间局部变量传递</strong>可以使用 InheritableThreadLocal 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    ThreadLocal&lt;String&gt; threadLocal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InheritableThreadLocal</span>&lt;&gt;();  <br>    threadLocal.set(<span class="hljs-string">&quot;父线程设置的值&quot;</span>);  <br>  <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; System.out.println(<span class="hljs-string">&quot;子线程输出：&quot;</span> + threadLocal.get())).start();  <br>&#125;  <br><span class="hljs-comment">// 子线程输出：父线程设置的值</span><br></code></pre></td></tr></table></figure><hr><h5 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h5><p>InheritableThreadLocal 源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InheritableThreadLocal</span>&lt;T&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ThreadLocal</span>&lt;T&gt; &#123;  <br>    <span class="hljs-keyword">protected</span> T <span class="hljs-title function_">childValue</span><span class="hljs-params">(T parentValue)</span> &#123;  <br>        <span class="hljs-keyword">return</span> parentValue;  <br>    &#125;  <br>    ThreadLocalMap <span class="hljs-title function_">getMap</span><span class="hljs-params">(Thread t)</span> &#123;  <br>       <span class="hljs-keyword">return</span> t.inheritableThreadLocals;  <br>    &#125;  <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> &#123;  <br>        t.inheritableThreadLocals = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalMap</span>(<span class="hljs-built_in">this</span>, firstValue);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>实现父子线程间的局部变量共享需要追溯到 Thread 对象的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(ThreadGroup g, Runnable target, String name, <span class="hljs-type">long</span> stackSize, AccessControlContext acc,  </span><br><span class="hljs-params">                  // 该参数默认是 <span class="hljs-literal">true</span>  </span><br><span class="hljs-params">                  <span class="hljs-type">boolean</span> inheritThreadLocals)</span> &#123;  <br>  <span class="hljs-comment">// ...  </span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> currentThread();  <br>  <br>    <span class="hljs-comment">// 判断父线程（创建子线程的线程）的 inheritableThreadLocals 属性不为 null  </span><br>    <span class="hljs-keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="hljs-literal">null</span>) &#123;  <br>        <span class="hljs-comment">// 复制父线程的 inheritableThreadLocals 属性，实现父子线程局部变量共享  </span><br>        <span class="hljs-built_in">this</span>.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);   <br>    &#125;  <br>    <span class="hljs-comment">// ..  </span><br>&#125;  <br><span class="hljs-comment">// 【本质上还是创建 ThreadLocalMap，只是把父类中的可继承数据设置进去了】  </span><br><span class="hljs-keyword">static</span> ThreadLocalMap <span class="hljs-title function_">createInheritedMap</span><span class="hljs-params">(ThreadLocalMap parentMap)</span> &#123;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalMap</span>(parentMap);  <br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-title function_">ThreadLocalMap</span><span class="hljs-params">(ThreadLocalMap parentMap)</span> &#123;  <br>    <span class="hljs-comment">// 获取父线程的哈希表  </span><br>    Entry[] parentTable = parentMap.table;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> parentTable.length;  <br>    setThreshold(len);  <br>    table = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[len];  <br><span class="hljs-comment">// 【逐个复制父线程 ThreadLocalMap 中的数据】  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; len; j++) &#123;  <br>        <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> parentTable[j];  <br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;  <br>            ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();  <br>            <span class="hljs-keyword">if</span> (key != <span class="hljs-literal">null</span>) &#123;  <br>                <span class="hljs-comment">// 调用的是 InheritableThreadLocal#childValue(T parentValue)  </span><br>                <span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> key.childValue(e.value);  <br>                <span class="hljs-type">Entry</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(key, value);  <br>                <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (len - <span class="hljs-number">1</span>);  <br>                <span class="hljs-comment">// 线性探测  </span><br>                <span class="hljs-keyword">while</span> (table[h] != <span class="hljs-literal">null</span>)  <br>                    h = nextIndex(h, len);  <br>                table[h] = c;  <br>                size++;  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h3><p>线程池：一个容纳多个线程的容器，容器中的线程可以重复使用，省去了频繁创建和销毁线程对象的操作</p><p>线程池作用：</p><ol><li><p>降低资源消耗，减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务</p></li><li><p>提高响应速度，当任务到达时，如果有线程可以直接用，不会出现系统僵死</p></li><li><p>提高线程的可管理性，如果无限制的创建线程，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控</p></li></ol><p>线程池的核心思想：<strong>线程复用</strong>，同一个线程可以被重复使用，来处理多个任务</p><p>池化技术 (Pool) ：一种编程技巧，核心思想是资源复用，在请求量大时能优化应用性能，降低系统频繁建连的资源开销</p><hr><h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><h4 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>有界队列和无界队列：</p><ul><li><p>有界队列：有固定大小的队列，比如设定了固定大小的 LinkedBlockingQueue，又或者大小为 0</p></li><li><p>无界队列：没有设置固定大小的队列，这些队列可以直接入队，直到溢出（超过 Integer.MAX_VALUE），所以相当于无界</p></li></ul><p>java.util.concurrent.BlockingQueue 接口有以下阻塞队列的实现：<strong>FIFO 队列</strong></p><ul><li><p>ArrayBlockQueue：由数组结构组成的有界阻塞队列</p></li><li><p>LinkedBlockingQueue：由链表结构组成的无界（默认大小 Integer.MAX_VALUE）的阻塞队列</p></li><li><p>PriorityBlockQueue：支持优先级排序的无界阻塞队列</p></li><li><p>DelayedWorkQueue：使用优先级队列实现的延迟无界阻塞队列</p></li><li><p>SynchronousQueue：不存储元素的阻塞队列，每一个生产线程会阻塞到有一个 put 的线程放入元素为止</p></li><li><p>LinkedTransferQueue：由链表结构组成的无界阻塞队列</p></li><li><p>LinkedBlockingDeque：由链表结构组成的<strong>双向</strong>阻塞队列</p></li></ul><p>与普通队列（LinkedList、ArrayList等）的不同点在于阻塞队列中阻塞添加和阻塞删除方法，以及线程安全：</p><ul><li><p>阻塞添加 put()：当阻塞队列元素已满时，添加队列元素的线程会被阻塞，直到队列元素不满时才重新唤醒线程执行</p></li><li><p>阻塞删除 take()：在队列元素为空时，删除队列元素的线程将被阻塞，直到队列不为空再执行删除操作（一般会返回被删除的元素)</p></li></ul><hr><h4 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h4><table><thead><tr><th>方法类型</th><th>抛出异常</th><th>特殊值</th><th>阻塞</th><th>超时</th></tr></thead><tbody><tr><td>插入（尾）</td><td>add(e)</td><td>offer(e)</td><td>put(e)</td><td>offer(e,time,unit)</td></tr><tr><td>移除（头）</td><td>remove()</td><td>poll()</td><td>take()</td><td>poll(time,unit)</td></tr><tr><td>检查（队首元素）</td><td>element()</td><td>peek()</td><td>不可用</td><td>不可用</td></tr></tbody></table><ul><li><p>抛出异常组：</p><ul><li><p>当阻塞队列满时：在往队列中 add 插入元素会抛出 IIIegalStateException: Queue full</p></li><li><p>当阻塞队列空时：再往队列中 remove 移除元素，会抛出 NoSuchException</p></li></ul></li><li><p>特殊值组：</p><ul><li><p>插入方法：成功 true，失败 false</p></li><li><p>移除方法：成功返回出队列元素，队列没有就返回 null</p></li></ul></li><li><p>阻塞组：</p><ul><li><p>当阻塞队列满时，生产者继续往队列里 put 元素，队列会一直阻塞生产线程直到队列有空间 put 数据或响应中断退出</p></li><li><p>当阻塞队列空时，消费者线程试图从队列里 take 元素，队列会一直阻塞消费者线程直到队列中有可用元素</p></li></ul></li><li><p>超时退出：当阻塞队列满时，队里会阻塞生产者线程一定时间，超过限时后生产者线程会退出</p></li></ul><hr><h4 id="链表队列"><a href="#链表队列" class="headerlink" title="链表队列"></a>链表队列</h4><h5 id="入队出队"><a href="#入队出队" class="headerlink" title="入队出队"></a>入队出队</h5><p>LinkedBlockingQueue 源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueue</span>&lt;E&gt;  <br><span class="hljs-keyword">implements</span> <span class="hljs-title class_">BlockingQueue</span>&lt;E&gt;, java.io.Serializable &#123;  <br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;E&gt; &#123;  <br>        E item;  <br>        <span class="hljs-comment">/**  </span><br><span class="hljs-comment">        * 下列三种情况之一  </span><br><span class="hljs-comment">        * - 真正的后继节点  </span><br><span class="hljs-comment">        * - 自己, 发生在出队时  </span><br><span class="hljs-comment">        * - null, 表示是没有后继节点, 是尾节点了  </span><br><span class="hljs-comment">        */</span>  <br>        Node&lt;E&gt; next;  <br>  <br>        Node(E x) &#123; item = x; &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>入队：<strong>尾插法</strong></p><ul><li><p>初始化链表 <code>last = head = new Node&lt;E&gt;(null)</code>，<strong>Dummy 节点用来占位</strong>，item 为 null</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedBlockingQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;  <br>    <span class="hljs-comment">// 默认是 Integer.MAX_VALUE  </span><br>    <span class="hljs-keyword">if</span> (capacity &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();  <br>    <span class="hljs-built_in">this</span>.capacity = capacity;  <br>    last = head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;E&gt;(<span class="hljs-literal">null</span>);  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>当一个节点入队：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">enqueue</span><span class="hljs-params">(Node&lt;E&gt; node)</span> &#123;  <br>    <span class="hljs-comment">// 从右向左计算  </span><br>    last = last.next = node;  <br>&#125;<br></code></pre></td></tr></table></figure><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041733155.png"></p></li><li><p>再来一个节点入队 <code>last = last.next = node</code></p></li></ul><p>出队：<strong>出队头节点</strong>，FIFO</p><ul><li><p>出队源码：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> E <span class="hljs-title function_">dequeue</span><span class="hljs-params">()</span> &#123;  <br>    Node&lt;E&gt; h = head;  <br>    <span class="hljs-comment">// 获取临头节点  </span><br>    Node&lt;E&gt; first = h.next;  <br>    <span class="hljs-comment">// 自己指向自己，help GC  </span><br>    h.next = h;  <br>    head = first;  <br>    <span class="hljs-comment">// 出队的元素  </span><br>    <span class="hljs-type">E</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> first.item;  <br>    <span class="hljs-comment">// 【当前节点置为 Dummy 节点】  </span><br>    first.item = <span class="hljs-literal">null</span>;  <br>    <span class="hljs-keyword">return</span> x;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>h = head</code> → <code>first = h.next</code></p><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041734054.png"></p></li><li><p><code>h.next = h</code> → <code>head = first</code></p><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041734203.png"></p><ul><li><code>first.item = null</code>：当前节点置为 Dummy 节点</li></ul></li></ul><hr><h5 id="加锁分析"><a href="#加锁分析" class="headerlink" title="加锁分析"></a>加锁分析</h5><p>用了两把锁和 dummy 节点：</p><ul><li><p>用一把锁，同一时刻，最多只允许有一个线程（生产者或消费者，二选一）执行</p></li><li><p>用两把锁，同一时刻，可以允许两个线程同时（一个生产者与一个消费者）执行</p><ul><li><p>消费者与消费者线程仍然串行</p></li><li><p>生产者与生产者线程仍然串行</p></li></ul></li></ul><p>线程安全分析：</p><ul><li><p>当节点总数大于 2 时（包括 dummy 节点），<strong>putLock 保证的是 last 节点的线程安全，takeLock 保证的是 head 节点的线程安全</strong>，两把锁保证了入队和出队没有竞争</p></li><li><p>当节点总数等于 2 时（即一个 dummy 节点，一个正常节点）这时候，仍然是两把锁锁两个对象，不会竞争</p></li><li><p>当节点总数等于 1 时（就一个 dummy 节点）这时 take 线程会被 notEmpty 条件阻塞，有竞争，会阻塞</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// 用于 put(阻塞) offer(非阻塞)  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">putLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();  <br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">notFull</span> <span class="hljs-operator">=</span> putLock.newCondition();<span class="hljs-comment">// 阻塞等待不满，说明已经满了  </span><br>  <br><span class="hljs-comment">// 用于 take(阻塞) poll(非阻塞)  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">takeLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();  <br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">notEmpty</span> <span class="hljs-operator">=</span> takeLock.newCondition();<span class="hljs-comment">// 阻塞等待不空，说明已经是空的</span><br></code></pre></td></tr></table></figure></li></ul><p>入队出队：</p><ul><li><p>put 操作：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(E e)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>    <span class="hljs-comment">// 空指针异常  </span><br>    <span class="hljs-keyword">if</span> (e == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;  <br>    <span class="hljs-comment">// 把待添加的元素封装为 node 节点  </span><br>    Node&lt;E&gt; node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;E&gt;(e);  <br>    <span class="hljs-comment">// 获取全局生产锁  </span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">putLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.putLock;  <br>    <span class="hljs-comment">// count 用来维护元素计数  </span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.count;  <br>    <span class="hljs-comment">// 获取可打断锁，会抛出异常  </span><br>    putLock.lockInterruptibly();  <br>    <span class="hljs-keyword">try</span> &#123;  <br>    <span class="hljs-comment">// 队列满了等待  </span><br>        <span class="hljs-keyword">while</span> (count.get() == capacity) &#123;  <br>            <span class="hljs-comment">// 【等待队列不满时，就可以生产数据】，线程处于 Waiting  </span><br>            notFull.await();  <br>        &#125;  <br>        <span class="hljs-comment">// 有空位, 入队且计数加一，尾插法  </span><br>        enqueue(node);  <br>        <span class="hljs-comment">// 返回自增前的数字  </span><br>        c = count.getAndIncrement();  <br>        <span class="hljs-comment">// put 完队列还有空位, 唤醒其他生产 put 线程，唤醒一个减少竞争  </span><br>        <span class="hljs-keyword">if</span> (c + <span class="hljs-number">1</span> &lt; capacity)  <br>            notFull.signal();  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        <span class="hljs-comment">// 解锁  </span><br>        putLock.unlock();  <br>    &#125;  <br>    <span class="hljs-comment">// c自增前是0，说明生产了一个元素，唤醒一个 take 线程  </span><br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>)  <br>        signalNotEmpty();  <br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">signalNotEmpty</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">takeLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.takeLock;  <br>    takeLock.lock();  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-comment">// 调用 notEmpty.signal()，而不是 notEmpty.signalAll() 是为了减少竞争，因为只剩下一个元素  </span><br>        notEmpty.signal();  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        takeLock.unlock();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>take 操作：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>    E x;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;  <br>    <span class="hljs-comment">// 元素个数  </span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.count;  <br>    <span class="hljs-comment">// 获取全局消费锁  </span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">takeLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.takeLock;  <br>    <span class="hljs-comment">// 可打断锁  </span><br>    takeLock.lockInterruptibly();  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-comment">// 没有元素可以出队  </span><br>        <span class="hljs-keyword">while</span> (count.get() == <span class="hljs-number">0</span>) &#123;  <br>            <span class="hljs-comment">// 【阻塞等待队列不空，就可以消费数据】，线程处于 Waiting  </span><br>            notEmpty.await();  <br>        &#125;  <br>        <span class="hljs-comment">// 出队，计数减一，FIFO，出队头节点  </span><br>        x = dequeue();  <br>        <span class="hljs-comment">// 返回自减前的数字  </span><br>        c = count.getAndDecrement();  <br>        <span class="hljs-comment">// 队列还有元素  </span><br>        <span class="hljs-keyword">if</span> (c &gt; <span class="hljs-number">1</span>)  <br>            <span class="hljs-comment">// 唤醒一个消费take线程  </span><br>            notEmpty.signal();  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        takeLock.unlock();  <br>    &#125;  <br>    <span class="hljs-comment">// c 是消费前的数据，消费前满了，消费一个后还剩一个空位，唤醒生产线程  </span><br>    <span class="hljs-keyword">if</span> (c == capacity)  <br>        <span class="hljs-comment">// 调用的是 notFull.signal() 而不是 notFull.signalAll() 是为了减少竞争  </span><br>        signalNotFull();  <br>    <span class="hljs-keyword">return</span> x;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h5 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h5><p>主要列举 LinkedBlockingQueue 与 ArrayBlockingQueue 的性能比较：</p><ul><li><p>Linked 支持有界，Array 强制有界</p></li><li><p>Linked 实现是链表，Array 实现是数组</p></li><li><p>Linked 是懒惰的，而 Array 需要提前初始化 Node 数组</p></li><li><p>Linked 每次入队会生成新 Node，而 Array 的 Node 是提前创建好的</p></li><li><p>Linked 两把锁，Array 一把锁</p></li></ul><hr><h4 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h4><h5 id="成员属性-1"><a href="#成员属性-1" class="headerlink" title="成员属性"></a>成员属性</h5><p>SynchronousQueue 是一个不存储元素的 BlockingQueue，<strong>每一个生产者必须阻塞匹配到一个消费者</strong></p><p>成员变量：</p><ul><li><p>运行当前程序的平台拥有 CPU 的数量：</p><p>  <code>static final int NCPUS = Runtime.getRuntime().availableProcessors()</code></p></li><li><p>指定超时时间后，当前线程最大自旋次数：</p><p>  &#x2F;&#x2F; 只有一个 CPU 时自旋次数为 0，所有程序都是串行执行，多核 CPU 时自旋 32 次是一个经验值<br>  <code>static final int maxTimedSpins = (NCPUS &lt; 2) ? 0 : 32;</code></p><p>  自旋的原因：线程挂起唤醒需要进行上下文切换，涉及到用户态和内核态的转变，是非常消耗资源的。自旋期间线程会一直检查自己的状态是否被匹配到，如果自旋期间被匹配到，那么直接就返回了，如果自旋次数达到某个指标后，还是会将当前线程挂起</p></li><li><p>未指定超时时间，当前线程最大自旋次数：</p><p>  <code>static final int maxUntimedSpins = maxTimedSpins * 16;// maxTimedSpins 的 16 倍</code></p></li><li><p>指定超时限制的阈值，小于该值的线程不会被挂起：</p><p>  <code>static final long spinForTimeoutThreshold = 1000L;// 纳秒</code></p><p>  超时时间设置的小于该值，就会被禁止挂起，阻塞再唤醒的成本太高，不如选择自旋空转</p></li><li><p>转换器：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Transferer&lt;E&gt; transferer;  <br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Transferer</span>&lt;E&gt; &#123;  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">    * 参数一：可以为 null，null 时表示这个请求是一个 REQUEST 类型的请求，反之是一个 DATA 类型的请求  </span><br><span class="hljs-comment">    * 参数二：如果为 true 表示指定了超时时间，如果为 false 表示不支持超时，会一直阻塞到匹配或者被打断  </span><br><span class="hljs-comment">    * 参数三：超时时间限制，单位是纳秒  </span><br><span class="hljs-comment">      </span><br><span class="hljs-comment">    * 返回值：返回值如果不为 null 表示匹配成功，DATA 类型的请求返回当前线程 put 的数据  </span><br><span class="hljs-comment">    *      如果返回 null，表示请求超时或被中断  </span><br><span class="hljs-comment">    */</span>  <br>    <span class="hljs-keyword">abstract</span> E <span class="hljs-title function_">transfer</span><span class="hljs-params">(E e, <span class="hljs-type">boolean</span> timed, <span class="hljs-type">long</span> nanos)</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>构造方法：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">SynchronousQueue</span><span class="hljs-params">(<span class="hljs-type">boolean</span> fair)</span> &#123;  <br>    <span class="hljs-comment">// fair 默认 false  </span><br>    <span class="hljs-comment">// 非公平模式实现的数据结构是栈，公平模式的数据结构是队列  </span><br>    transferer = fair ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransferQueue</span>&lt;E&gt;() : <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransferStack</span>&lt;E&gt;();  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>成员方法：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e)</span> &#123;  <br>    <span class="hljs-keyword">if</span> (e == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();  <br>    <span class="hljs-keyword">return</span> transferer.transfer(e, <span class="hljs-literal">true</span>, <span class="hljs-number">0</span>) != <span class="hljs-literal">null</span>;  <br>&#125;  <br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">return</span> transferer.transfer(<span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>, <span class="hljs-number">0</span>);  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h5 id="非公实现"><a href="#非公实现" class="headerlink" title="非公实现"></a>非公实现</h5><p>TransferStack 是非公平的同步队列，因为所有的请求都被压入栈中，栈顶的元素会最先得到匹配，造成栈底的等待线程饥饿</p><p>TransferStack 类成员变量：</p><ul><li><p>请求类型：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// 表示 Node 类型为请求类型  </span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">REQUEST</span>    <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br><span class="hljs-comment">// 表示 Node类 型为数据类型  </span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DATA</span>       <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;  <br><span class="hljs-comment">// 表示 Node 类型为匹配中类型  </span><br><span class="hljs-comment">// 假设栈顶元素为 REQUEST-NODE，当前请求类型为 DATA，入栈会修改类型为 FULFILLING 【栈顶 &amp; 栈顶之下的一个node】  </span><br><span class="hljs-comment">// 假设栈顶元素为 DATA-NODE，当前请求类型为 REQUEST，入栈会修改类型为 FULFILLING 【栈顶 &amp; 栈顶之下的一个node】  </span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">FULFILLING</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure></li><li><p>栈顶元素：</p><p>  <code>volatile SNode head;</code></p></li></ul><p>内部类 SNode：</p><ul><li><p>成员变量：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SNode</span> &#123;  <br>    <span class="hljs-comment">// 指向下一个栈帧  </span><br>    <span class="hljs-keyword">volatile</span> SNode next;   <br>    <span class="hljs-comment">// 与当前 node 匹配的节点  </span><br>    <span class="hljs-keyword">volatile</span> SNode match;  <br>    <span class="hljs-comment">// 假设当前node对应的线程自旋期间未被匹配成功，那么node对应的线程需要挂起，  </span><br>    <span class="hljs-comment">// 挂起前 waiter 保存对应的线程引用，方便匹配成功后，被唤醒。  </span><br>    <span class="hljs-keyword">volatile</span> Thread waiter;  <br>      <br>    <span class="hljs-comment">// 数据域，不为空表示当前 Node 对应的请求类型为 DATA 类型，反之则表示 Node 为 REQUEST 类型  </span><br>    Object item;   <br>    <span class="hljs-comment">// 表示当前Node的模式 【DATA/REQUEST/FULFILLING】  </span><br>    <span class="hljs-type">int</span> mode;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>构造方法：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><br>SNode(Object item) &#123;  <br>    <span class="hljs-built_in">this</span>.item = item;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>设置方法：设置 Node 对象的 next 字段，此处<strong>对 CAS 进行了优化</strong>，提升了 CAS 的效率</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">casNext</span><span class="hljs-params">(SNode cmp, SNode val)</span> &#123;  <br>    <span class="hljs-comment">//【优化：cmp == next】，可以提升一部分性能。 cmp == next 不相等，就没必要走 cas指令。  </span><br>    <span class="hljs-keyword">return</span> cmp == next &amp;&amp; UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, nextOffset, cmp, val);  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>匹配方法：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">tryMatch</span><span class="hljs-params">(SNode s)</span> &#123;  <br>    <span class="hljs-comment">// 当前 node 尚未与任何节点发生过匹配，CAS 设置 match 字段为 s 节点，表示当前 node 已经被匹配  </span><br>    <span class="hljs-keyword">if</span> (match == <span class="hljs-literal">null</span> &amp;&amp; UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, matchOffset, <span class="hljs-literal">null</span>, s)) &#123;  <br>        <span class="hljs-comment">// 当前 node 如果自旋结束，会 park 阻塞，阻塞前将 node 对应的 Thread 保留到 waiter 字段  </span><br>        <span class="hljs-comment">// 获取当前 node 对应的阻塞线程  </span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> waiter;  <br>        <span class="hljs-comment">// 条件成立说明 node 对应的 Thread 正在阻塞  </span><br>        <span class="hljs-keyword">if</span> (w != <span class="hljs-literal">null</span>) &#123;  <br>            waiter = <span class="hljs-literal">null</span>;  <br>            <span class="hljs-comment">// 使用 unpark 方式唤醒线程  </span><br>            LockSupport.unpark(w);  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    &#125;  <br>    <span class="hljs-comment">// 匹配成功返回 true  </span><br>    <span class="hljs-keyword">return</span> match == s;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>取消方法：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// 取消节点的方法  </span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">tryCancel</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">// match 字段指向自己，表示这个 node 是取消状态，取消状态的 node，最终会被强制移除出栈  </span><br>    UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, matchOffset, <span class="hljs-literal">null</span>, <span class="hljs-built_in">this</span>);  <br>&#125;  <br>  <br><span class="hljs-type">boolean</span> <span class="hljs-title function_">isCancelled</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">return</span> match == <span class="hljs-built_in">this</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>TransferStack 类成员方法：</p><ul><li><p>snode()：填充节点方法</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">static</span> SNode <span class="hljs-title function_">snode</span><span class="hljs-params">(SNode s, Object e, SNode next, <span class="hljs-type">int</span> mode)</span> &#123;  <br>    <span class="hljs-comment">// 引用指向空时，snode 方法会创建一个 SNode 对象   </span><br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span>) s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SNode</span>(e);  <br>    <span class="hljs-comment">// 填充数据  </span><br>    s.mode = mode;  <br>    s.next = next;  <br>    <span class="hljs-keyword">return</span> s;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>transfer()：核心方法，请求匹配出栈，不匹配阻塞</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs java"><br>E <span class="hljs-title function_">transfer</span><span class="hljs-params">(E e, <span class="hljs-type">boolean</span> timed, <span class="hljs-type">long</span> nanos)</span> &#123;  <br><span class="hljs-comment">// 包装当前线程的 node  </span><br>    <span class="hljs-type">SNode</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;  <br>    <span class="hljs-comment">// 根据元素判断当前的请求类型  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">mode</span> <span class="hljs-operator">=</span> (e == <span class="hljs-literal">null</span>) ? REQUEST : DATA;  <br><span class="hljs-comment">// 自旋  </span><br>    <span class="hljs-keyword">for</span> (;;) &#123;  <br>        <span class="hljs-comment">// 获取栈顶指针  </span><br>        <span class="hljs-type">SNode</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;  <br>       <span class="hljs-comment">// 【CASE1】：当前栈为空或者栈顶 node 模式与当前请求模式一致无法匹配，做入栈操作  </span><br>        <span class="hljs-keyword">if</span> (h == <span class="hljs-literal">null</span> || h.mode == mode) &#123;  <br>            <span class="hljs-comment">// 当前请求是支持超时的，但是 nanos &lt;= 0 说明这个请求不支持 “阻塞等待”  </span><br>            <span class="hljs-keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="hljs-number">0</span>) &#123;   <br>                <span class="hljs-comment">// 栈顶元素是取消状态  </span><br>                <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h.isCancelled())  <br>                    <span class="hljs-comment">// 栈顶出栈，设置新的栈顶  </span><br>                    casHead(h, h.next);  <br>                <span class="hljs-keyword">else</span>  <br>                    <span class="hljs-comment">// 表示【匹配失败】  </span><br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>            <span class="hljs-comment">// 入栈  </span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (casHead(h, s = snode(s, e, h, mode))) &#123;  <br>                <span class="hljs-comment">// 等待被匹配的逻辑，正常情况返回匹配的节点；取消情况返回当前节点，就是 s  </span><br>                <span class="hljs-type">SNode</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> awaitFulfill(s, timed, nanos);  <br>                <span class="hljs-comment">// 说明当前 node 是【取消状态】  </span><br>                <span class="hljs-keyword">if</span> (m == s) &#123;   <br>                    <span class="hljs-comment">// 将取消节点出栈  </span><br>                    clean(s);  <br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>                &#125;  <br>                <span class="hljs-comment">// 执行到这说明【匹配成功】了  </span><br>                <span class="hljs-comment">// 栈顶有节点并且 匹配节点还未出栈，需要协助出栈  </span><br>                <span class="hljs-keyword">if</span> ((h = head) != <span class="hljs-literal">null</span> &amp;&amp; h.next == s)  <br>                    casHead(h, s.next);  <br>                <span class="hljs-comment">// 当前 node 模式为 REQUEST 类型，返回匹配节点的 m.item 数据域  </span><br>                <span class="hljs-comment">// 当前 node 模式为 DATA 类型：返回 node.item 数据域，当前请求提交的数据 e  </span><br>                <span class="hljs-keyword">return</span> (E) ((mode == REQUEST) ? m.item : s.item);  <br>            &#125;  <br>        <span class="hljs-comment">// 【CASE2】：逻辑到这说明请求模式不一致，如果栈顶不是 FULFILLING 说明没被其他节点匹配，【当前可以匹配】  </span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!isFulfilling(h.mode)) &#123;  <br>            <span class="hljs-comment">// 头节点是取消节点，match 指向自己，协助出栈  </span><br>            <span class="hljs-keyword">if</span> (h.isCancelled())  <br>                casHead(h, h.next);  <br>            <span class="hljs-comment">// 入栈当前请求的节点  </span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (casHead(h, s=snode(s, e, h, FULFILLING|mode))) &#123;  <br>                <span class="hljs-keyword">for</span> (;;) &#123;   <br>                    <span class="hljs-comment">// m 是 s 的匹配的节点  </span><br>                    <span class="hljs-type">SNode</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> s.next;  <br>                    <span class="hljs-comment">// m 节点在 awaitFulfill 方法中被中断，clean 了自己  </span><br>                    <span class="hljs-keyword">if</span> (m == <span class="hljs-literal">null</span>) &#123;  <br>                        <span class="hljs-comment">// 清空栈  </span><br>                        casHead(s, <span class="hljs-literal">null</span>);  <br>                        s = <span class="hljs-literal">null</span>;  <br>                        <span class="hljs-comment">// 返回到外层自旋中  </span><br>                        <span class="hljs-keyword">break</span>;  <br>                    &#125;  <br>                    <span class="hljs-comment">// 获取匹配节点的下一个节点  </span><br>                    <span class="hljs-type">SNode</span> <span class="hljs-variable">mn</span> <span class="hljs-operator">=</span> m.next;  <br>                    <span class="hljs-comment">// 尝试匹配，【匹配成功】，则将 fulfilling 和 m 一起出栈，并且唤醒被匹配的节点的线程  </span><br>                    <span class="hljs-keyword">if</span> (m.tryMatch(s)) &#123;  <br>                        casHead(s, mn);  <br>                        <span class="hljs-keyword">return</span> (E) ((mode == REQUEST) ? m.item : s.item);  <br>                    &#125; <span class="hljs-keyword">else</span>  <br>                        <span class="hljs-comment">// 匹配失败，出栈 m  </span><br>                        s.casNext(m, mn);  <br>                &#125;  <br>            &#125;  <br>        <span class="hljs-comment">// 【CASE3】：栈顶模式为 FULFILLING 模式，表示【栈顶和栈顶下面的节点正在发生匹配】，当前请求需要做协助工作  </span><br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            <span class="hljs-comment">// h 表示的是 fulfilling 节点，m 表示 fulfilling 匹配的节点  </span><br>            <span class="hljs-type">SNode</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> h.next;  <br>            <span class="hljs-keyword">if</span> (m == <span class="hljs-literal">null</span>)  <br>                <span class="hljs-comment">// 清空栈  </span><br>                casHead(h, <span class="hljs-literal">null</span>);  <br>            <span class="hljs-keyword">else</span> &#123;  <br>                <span class="hljs-type">SNode</span> <span class="hljs-variable">mn</span> <span class="hljs-operator">=</span> m.next;  <br>                <span class="hljs-comment">// m 和 h 匹配，唤醒 m 中的线程  </span><br>                <span class="hljs-keyword">if</span> (m.tryMatch(h))  <br>                    casHead(h, mn);  <br>                <span class="hljs-keyword">else</span>  <br>                    h.casNext(m, mn);  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>awaitFulfill()：阻塞当前线程等待被匹配，返回匹配的节点，或者被取消的节点</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><br>SNode <span class="hljs-title function_">awaitFulfill</span><span class="hljs-params">(SNode s, <span class="hljs-type">boolean</span> timed, <span class="hljs-type">long</span> nanos)</span> &#123;  <br>    <span class="hljs-comment">// 等待的截止时间  </span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> timed ? System.nanoTime() + nanos : <span class="hljs-number">0L</span>;  <br>    <span class="hljs-comment">// 当前线程  </span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> Thread.currentThread();  <br>    <span class="hljs-comment">// 表示当前请求线程在下面的 for(;;) 自旋检查的次数  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">spins</span> <span class="hljs-operator">=</span> (shouldSpin(s) ? (timed ? maxTimedSpins : maxUntimedSpins) : <span class="hljs-number">0</span>);  <br>    <span class="hljs-comment">// 自旋检查逻辑：是否匹配、是否超时、是否被中断  </span><br>    <span class="hljs-keyword">for</span> (;;) &#123;  <br>        <span class="hljs-comment">// 当前线程收到中断信号，需要设置 node 状态为取消状态  </span><br>        <span class="hljs-keyword">if</span> (w.isInterrupted())  <br>            s.tryCancel();  <br>        <span class="hljs-comment">// 获取与当前 s 匹配的节点  </span><br>        <span class="hljs-type">SNode</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> s.match;  <br>        <span class="hljs-keyword">if</span> (m != <span class="hljs-literal">null</span>)  <br>            <span class="hljs-comment">// 可能是正常的匹配的，也可能是取消的  </span><br>            <span class="hljs-keyword">return</span> m;  <br>        <span class="hljs-comment">// 执行了超时限制就判断是否超时  </span><br>        <span class="hljs-keyword">if</span> (timed) &#123;  <br>            nanos = deadline - System.nanoTime();  <br>            <span class="hljs-comment">// 【超时了，取消节点】  </span><br>            <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0L</span>) &#123;  <br>                s.tryCancel();  <br>                <span class="hljs-keyword">continue</span>;  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-comment">// 说明当前线程还可以进行自旋检查  </span><br>        <span class="hljs-keyword">if</span> (spins &gt; <span class="hljs-number">0</span>)  <br>            <span class="hljs-comment">// 自旋一次 递减 1  </span><br>            spins = shouldSpin(s) ? (spins - <span class="hljs-number">1</span>) : <span class="hljs-number">0</span>;  <br>        <span class="hljs-comment">// 说明没有自旋次数了  </span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.waiter == <span class="hljs-literal">null</span>)  <br>            <span class="hljs-comment">//【把当前 node 对应的 Thread 保存到 node.waiter 字段中，要阻塞了】  </span><br>            s.waiter = w;  <br>        <span class="hljs-comment">// 没有超时限制直接阻塞  </span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!timed)  <br>            LockSupport.park(<span class="hljs-built_in">this</span>);  <br>        <span class="hljs-comment">// nanos &gt; 1000 纳秒的情况下，才允许挂起当前线程  </span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nanos &gt; spinForTimeoutThreshold)  <br>            LockSupport.parkNanos(<span class="hljs-built_in">this</span>, nanos);  <br>    &#125;  <br>&#125;<br><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">shouldSpin</span><span class="hljs-params">(SNode s)</span> &#123;  <br>    <span class="hljs-comment">// 获取栈顶  </span><br>    <span class="hljs-type">SNode</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;  <br>    <span class="hljs-comment">// 条件一成立说明当前 s 就是栈顶，允许自旋检查  </span><br>    <span class="hljs-comment">// 条件二成立说明当前 s 节点自旋检查期间，又来了一个与当前 s 节点匹配的请求，双双出栈后条件会成立  </span><br>    <span class="hljs-comment">// 条件三成立前提当前 s 不是栈顶元素，并且当前栈顶正在匹配中，这种状态栈顶下面的元素，都允许自旋检查  </span><br>    <span class="hljs-keyword">return</span> (h == s || h == <span class="hljs-literal">null</span> || isFulfilling(h.mode));  <br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>clear()：指定节点出栈</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">clean</span><span class="hljs-params">(SNode s)</span> &#123;  <br>    <span class="hljs-comment">// 清空数据域和关联线程  </span><br>    s.item = <span class="hljs-literal">null</span>;  <br>    s.waiter = <span class="hljs-literal">null</span>;  <br>      <br><span class="hljs-comment">// 获取取消节点的下一个节点  </span><br>    <span class="hljs-type">SNode</span> <span class="hljs-variable">past</span> <span class="hljs-operator">=</span> s.next;  <br>    <span class="hljs-comment">// 判断后继节点是不是取消节点，是就更新 past  </span><br>    <span class="hljs-keyword">if</span> (past != <span class="hljs-literal">null</span> &amp;&amp; past.isCancelled())  <br>        past = past.next;  <br>  <br>    SNode p;  <br>    <span class="hljs-comment">// 从栈顶开始向下检查，【将栈顶开始向下的 取消状态 的节点全部清理出去】，直到碰到 past 或者不是取消状态为止  </span><br>    <span class="hljs-keyword">while</span> ((p = head) != <span class="hljs-literal">null</span> &amp;&amp; p != past &amp;&amp; p.isCancelled())  <br>        <span class="hljs-comment">// 修改的是内存地址对应的值，p 指向该内存地址所以数据一直在变化  </span><br>        casHead(p, p.next);  <br><span class="hljs-comment">// 说明中间遇到了不是取消状态的节点，继续迭代下去  </span><br>    <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span> &amp;&amp; p != past) &#123;  <br>        <span class="hljs-type">SNode</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> p.next;  <br>        <span class="hljs-keyword">if</span> (n != <span class="hljs-literal">null</span> &amp;&amp; n.isCancelled())  <br>            p.casNext(n, n.next);  <br>        <span class="hljs-keyword">else</span>  <br>            p = n;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h5 id="公平实现"><a href="#公平实现" class="headerlink" title="公平实现"></a>公平实现</h5><p>TransferQueue 是公平的同步队列，采用 FIFO 的队列实现，请求节点与队尾模式不同，需要与队头发生匹配</p><p>TransferQueue 类成员变量：</p><ul><li><p>指向队列的 dummy 节点：</p><p>  <code>transient volatile QNode head;</code></p></li><li><p>指向队列的尾节点：</p><p>  <code>transient volatile QNode tail;</code></p></li><li><p>被清理节点的前驱节点：</p><p>  <code>transient volatile QNode cleanMe;</code></p><p>  入队操作是两步完成的，第一步是 t.next &#x3D; newNode，第二步是 tail &#x3D; newNode，所以队尾节点出队，是一种非常特殊的情况</p></li></ul><p>TransferQueue 内部类：</p><ul><li>QNode：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">QNode</span> &#123;  <br>    <span class="hljs-comment">// 指向当前节点的下一个节点  </span><br>    <span class="hljs-keyword">volatile</span> QNode next;  <br>    <span class="hljs-comment">// 数据域，Node 代表的是 DATA 类型 item 表示数据，否则 Node 代表的 REQUEST 类型，item == null  </span><br>    <span class="hljs-keyword">volatile</span> Object item;  <br>    <span class="hljs-comment">// 假设当前 node 对应的线程自旋期间未被匹配成功，那么 node 对应的线程需要挂起，  </span><br>    <span class="hljs-comment">// 挂起前 waiter 保存对应的线程引用，方便匹配成功后被唤醒。  </span><br>    <span class="hljs-keyword">volatile</span> Thread waiter;  <br>    <span class="hljs-comment">// true 当前 Node 是一个 DATA 类型，false 表示当前 Node 是一个 REQUEST 类型  </span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> isData;  <br>  <br><span class="hljs-comment">// 构建方法  </span><br>    QNode(Object item, <span class="hljs-type">boolean</span> isData) &#123;  <br>        <span class="hljs-built_in">this</span>.item = item;  <br>        <span class="hljs-built_in">this</span>.isData = isData;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 尝试取消当前 node，取消状态的 node 的 item 域指向自己  </span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">tryCancel</span><span class="hljs-params">(Object cmp)</span> &#123;  <br>        UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, itemOffset, cmp, <span class="hljs-built_in">this</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 判断当前 node 是否为取消状态  </span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isCancelled</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> item == <span class="hljs-built_in">this</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 判断当前节点是否 “不在” 队列内，当 next 指向自己时，说明节点已经出队。  </span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isOffList</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> next == <span class="hljs-built_in">this</span>;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>TransferQueue 类成员方法：</p><ul><li><p>设置头尾节点：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">advanceHead</span><span class="hljs-params">(QNode h, QNode nh)</span> &#123;  <br>    <span class="hljs-comment">// 设置头指针指向新的节点，  </span><br>    <span class="hljs-keyword">if</span> (h == head &amp;&amp; UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, headOffset, h, nh))  <br>        <span class="hljs-comment">// 老的头节点出队  </span><br>        h.next = h;  <br>&#125;  <br><span class="hljs-keyword">void</span> <span class="hljs-title function_">advanceTail</span><span class="hljs-params">(QNode t, QNode nt)</span> &#123;  <br>    <span class="hljs-keyword">if</span> (tail == t)  <br>        <span class="hljs-comment">// 更新队尾节点为新的队尾  </span><br>        UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, tailOffset, t, nt);  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>transfer()：核心方法</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java"><br>E <span class="hljs-title function_">transfer</span><span class="hljs-params">(E e, <span class="hljs-type">boolean</span> timed, <span class="hljs-type">long</span> nanos)</span> &#123;  <br>    <span class="hljs-comment">// s 指向当前请求对应的 node  </span><br>    <span class="hljs-type">QNode</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;  <br>    <span class="hljs-comment">// 是否是 DATA 类型的请求  </span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">isData</span> <span class="hljs-operator">=</span> (e != <span class="hljs-literal">null</span>);  <br><span class="hljs-comment">// 自旋  </span><br>    <span class="hljs-keyword">for</span> (;;) &#123;  <br>        <span class="hljs-type">QNode</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail;  <br>        <span class="hljs-type">QNode</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;  <br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span> || h == <span class="hljs-literal">null</span>)  <br>            <span class="hljs-keyword">continue</span>;  <br><span class="hljs-comment">// head 和 tail 同时指向 dummy 节点，说明是空队列  </span><br>        <span class="hljs-comment">// 队尾节点与当前请求类型是一致的情况，说明阻塞队列中都无法匹配，  </span><br>        <span class="hljs-keyword">if</span> (h == t || t.isData == isData) &#123;  <br>            <span class="hljs-comment">// 获取队尾 t 的 next 节点  </span><br>            <span class="hljs-type">QNode</span> <span class="hljs-variable">tn</span> <span class="hljs-operator">=</span> t.next;  <br>            <span class="hljs-comment">// 多线程环境中其他线程可能修改尾节点  </span><br>            <span class="hljs-keyword">if</span> (t != tail)  <br>                <span class="hljs-keyword">continue</span>;  <br>            <span class="hljs-comment">// 已经有线程入队了，更新 tail  </span><br>            <span class="hljs-keyword">if</span> (tn != <span class="hljs-literal">null</span>) &#123;  <br>                advanceTail(t, tn);  <br>                <span class="hljs-keyword">continue</span>;  <br>            &#125;  <br>            <span class="hljs-comment">// 允许超时，超时时间小于 0，这种方法不支持阻塞等待  </span><br>            <span class="hljs-keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="hljs-number">0</span>)  <br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>            <span class="hljs-comment">// 创建 node 的逻辑  </span><br>            <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span>)  <br>                s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QNode</span>(e, isData);  <br>            <span class="hljs-comment">// 将 node 添加到队尾  </span><br>            <span class="hljs-keyword">if</span> (!t.casNext(<span class="hljs-literal">null</span>, s))  <br>                <span class="hljs-keyword">continue</span>;  <br><span class="hljs-comment">// 更新队尾指针  </span><br>            advanceTail(t, s);  <br>              <br>            <span class="hljs-comment">// 当前节点 等待匹配....  </span><br>            <span class="hljs-type">Object</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> awaitFulfill(s, e, timed, nanos);  <br>              <br>            <span class="hljs-comment">// 说明【当前 node 状态为 取消状态】，需要做出队逻辑  </span><br>            <span class="hljs-keyword">if</span> (x == s) &#123;  <br>                clean(t, s);  <br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>            &#125;  <br><span class="hljs-comment">// 说明当前 node 仍然在队列内，匹配成功，需要做出队逻辑  </span><br>            <span class="hljs-keyword">if</span> (!s.isOffList()) &#123;  <br>                <span class="hljs-comment">// t 是当前 s 节点的前驱节点，判断 t 是不是头节点，是就更新 dummy 节点为 s 节点  </span><br>                advanceHead(t, s);  <br>                <span class="hljs-comment">// s 节点已经出队，所以需要把它的 item 域设置为它自己，表示它是个取消状态  </span><br>                <span class="hljs-keyword">if</span> (x != <span class="hljs-literal">null</span>)  <br>                    s.item = s;  <br>                s.waiter = <span class="hljs-literal">null</span>;  <br>            &#125;  <br>            <span class="hljs-keyword">return</span> (x != <span class="hljs-literal">null</span>) ? (E)x : e;  <br><span class="hljs-comment">// 队尾节点与当前请求节点【互补匹配】  </span><br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            <span class="hljs-comment">// h.next 节点，【请求节点与队尾模式不同，需要与队头发生匹配】，TransferQueue 是一个【公平模式】  </span><br>            <span class="hljs-type">QNode</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> h.next;  <br>            <span class="hljs-comment">// 并发导致其他线程修改了队尾节点，或者已经把 head.next 匹配走了  </span><br>            <span class="hljs-keyword">if</span> (t != tail || m == <span class="hljs-literal">null</span> || h != head)  <br>                <span class="hljs-keyword">continue</span>;  <br><span class="hljs-comment">// 获取匹配节点的数据域保存到 x  </span><br>            <span class="hljs-type">Object</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> m.item;  <br>            <span class="hljs-comment">// 判断是否匹配成功  </span><br>            <span class="hljs-keyword">if</span> (isData == (x != <span class="hljs-literal">null</span>) ||  <br>                x == m ||  <br>                !m.casItem(x, e)) &#123;  <br>                advanceHead(h, m);  <br>                <span class="hljs-keyword">continue</span>;  <br>            &#125;  <br><span class="hljs-comment">// 【匹配完成】，将头节点出队，让这个新的头结点成为 dummy 节点  </span><br>            advanceHead(h, m);  <br>            <span class="hljs-comment">// 唤醒该匹配节点的线程  </span><br>            LockSupport.unpark(m.waiter);  <br>            <span class="hljs-keyword">return</span> (x != <span class="hljs-literal">null</span>) ? (E)x : e;  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>awaitFulfill()：阻塞当前线程等待被匹配</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><br>Object <span class="hljs-title function_">awaitFulfill</span><span class="hljs-params">(QNode s, E e, <span class="hljs-type">boolean</span> timed, <span class="hljs-type">long</span> nanos)</span> &#123;  <br>    <span class="hljs-comment">// 表示等待截止时间  </span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> timed ? System.nanoTime() + nanos : <span class="hljs-number">0L</span>;  <br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> Thread.currentThread();  <br>    <span class="hljs-comment">// 自选检查的次数  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">spins</span> <span class="hljs-operator">=</span> ((head.next == s) ? (timed ? maxTimedSpins : maxUntimedSpins) : <span class="hljs-number">0</span>);  <br>    <span class="hljs-keyword">for</span> (;;) &#123;  <br>        <span class="hljs-comment">// 被打断就取消节点  </span><br>        <span class="hljs-keyword">if</span> (w.isInterrupted())  <br>            s.tryCancel(e);  <br>        <span class="hljs-comment">// 获取当前 Node 数据域  </span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> s.item;  <br>          <br>        <span class="hljs-comment">// 当前请求为 DATA 模式时：e 请求带来的数据  </span><br>        <span class="hljs-comment">// s.item 修改为 this，说明当前 QNode 对应的线程 取消状态  </span><br>        <span class="hljs-comment">// s.item 修改为 null 表示已经有匹配节点了，并且匹配节点拿走了 item 数据  </span><br>  <br>        <span class="hljs-comment">// 当前请求为 REQUEST 模式时：e == null  </span><br>        <span class="hljs-comment">// s.item 修改为 this，说明当前 QNode 对应的线程 取消状态  </span><br>        <span class="hljs-comment">// s.item != null 且 item != this  表示当前 REQUEST 类型的 Node 已经匹配到 DATA 了   </span><br>        <span class="hljs-keyword">if</span> (x != e)  <br>            <span class="hljs-keyword">return</span> x;  <br>        <span class="hljs-comment">// 超时检查  </span><br>        <span class="hljs-keyword">if</span> (timed) &#123;  <br>            nanos = deadline - System.nanoTime();  <br>            <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0L</span>) &#123;  <br>                s.tryCancel(e);  <br>                <span class="hljs-keyword">continue</span>;  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-comment">// 自旋次数减一  </span><br>        <span class="hljs-keyword">if</span> (spins &gt; <span class="hljs-number">0</span>)  <br>            --spins;  <br>        <span class="hljs-comment">// 没有自旋次数了，把当前线程封装进去 waiter  </span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.waiter == <span class="hljs-literal">null</span>)  <br>            s.waiter = w;  <br>        <span class="hljs-comment">// 阻塞  </span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!timed)  <br>            LockSupport.park(<span class="hljs-built_in">this</span>);  <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nanos &gt; spinForTimeoutThreshold)  <br>            LockSupport.parkNanos(<span class="hljs-built_in">this</span>, nanos);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><p>TODO HERE</p><h3 id="操作Pool"><a href="#操作Pool" class="headerlink" title="操作Pool"></a>操作Pool</h3><h4 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h4><h5 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h5><p>存放线程的容器：</p><p><code>private final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;();</code></p><p>构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,  </span><br><span class="hljs-params">                          <span class="hljs-type">int</span> maximumPoolSize,  </span><br><span class="hljs-params">                          <span class="hljs-type">long</span> keepAliveTime,  </span><br><span class="hljs-params">                          TimeUnit unit,  </span><br><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue,  </span><br><span class="hljs-params">                          ThreadFactory threadFactory,  </span><br><span class="hljs-params">                          RejectedExecutionHandler handler)</span><br></code></pre></td></tr></table></figure><p>参数介绍：</p><ul><li><p>corePoolSize：核心线程数，定义了最小可以同时运行的线程数量</p></li><li><p>maximumPoolSize：最大线程数，当队列中存放的任务达到队列容量时，当前可以同时运行的数量变为最大线程数，创建线程并立即执行最新的任务，与核心线程数之间的差值又叫救急线程数</p></li><li><p>keepAliveTime：救急线程最大存活时间，当线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等到 <code>keepAliveTime</code> 时间超过销毁</p></li><li><p>unit：<code>keepAliveTime</code> 参数的时间单位</p></li><li><p>workQueue：阻塞队列，存放被提交但尚未被执行的任务</p></li><li><p>threadFactory：线程工厂，创建新线程时用到，可以为线程创建时起名字</p></li><li><p>handler：拒绝策略，线程到达最大线程数仍有新任务时会执行拒绝策略</p><p>  RejectedExecutionHandler 下有 4 个实现类：</p><ul><li><p>AbortPolicy：让调用者抛出 RejectedExecutionException 异常，<strong>默认策略</strong></p></li><li><p>CallerRunsPolicy：让调用者运行的调节机制，将某些任务回退到调用者，从而降低新任务的流量</p></li><li><p>DiscardPolicy：直接丢弃任务，不予任何处理也不抛出异常</p></li><li><p>DiscardOldestPolicy：放弃队列中最早的任务，把当前任务加入队列中尝试再次提交当前任务</p></li></ul><p>  补充：其他框架拒绝策略</p><ul><li><p>Dubbo：在抛出 RejectedExecutionException 异常前记录日志，并 dump 线程栈信息，方便定位问题</p></li><li><p>Netty：创建一个新线程来执行任务</p></li><li><p>ActiveMQ：带超时等待（60s）尝试放入队列</p></li><li><p>PinPoint：它使用了一个拒绝策略链，会逐一尝试策略链中每种拒绝策略</p></li></ul></li></ul><p>工作原理：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041808994.png"></p><ol><li><p>创建线程池，这时没有创建线程（<strong>懒惰</strong>），等待提交过来的任务请求，调用 execute 方法才会创建线程</p></li><li><p>当调用 execute() 方法添加一个请求任务时，线程池会做如下判断：</p><ul><li><p>如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务</p></li><li><p>如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列</p></li><li><p>如果这时队列满了且正在运行的线程数量还小于 maximumPoolSize，那么会创建非核心线程<strong>立刻运行这个任务</strong>，对于阻塞队列中的任务不公平。这是因为创建每个 Worker（线程）对象会绑定一个初始任务，启动 Worker 时会优先执行</p></li><li><p>如果队列满了且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会启动饱和<strong>拒绝策略</strong>来执行</p></li></ul></li><li><p>当一个线程完成任务时，会从队列中取下一个任务来执行</p></li><li><p>当一个线程空闲超过一定的时间（keepAliveTime）时，线程池会判断：如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉，所以线程池的所有任务完成后最终会收缩到 corePoolSize 大小</p></li></ol><hr><h5 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h5><p>Executors 提供了四种线程池的创建：newCachedThreadPool、newFixedThreadPool、newSingleThreadExecutor、newScheduledThreadPool</p><ul><li><p>newFixedThreadPool：创建一个拥有 n 个线程的线程池</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> nThreads)</span> &#123;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(nThreads, nThreads, <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,  <br>                                  <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>核心线程数 &#x3D;&#x3D; 最大线程数（没有救急线程被创建），因此也无需超时时间</p></li><li><p>LinkedBlockingQueue 是一个单向链表实现的阻塞队列，默认大小为 <code>Integer.MAX_VALUE</code>，也就是无界队列，可以放任意数量的任务，在任务比较多的时候会导致 OOM（内存溢出）</p></li><li><p>适用于任务量已知，相对耗时的长期任务</p></li></ul></li><li><p>newCachedThreadPool：创建一个可扩容的线程池</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newCachedThreadPool</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">0</span>, Integer.MAX_VALUE, <span class="hljs-number">60L</span>, TimeUnit.SECONDS,  <br>                                  <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;Runnable&gt;());  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>核心线程数是 0， 最大线程数是 29 个 1，全部都是救急线程（60s 后可以回收），可能会创建大量线程，从而导致 <strong>OOM</strong></p></li><li><p>SynchronousQueue 作为阻塞队列，没有容量，对于每一个 take 的线程会阻塞直到有一个 put 的线程放入元素为止（类似一手交钱、一手交货）</p></li><li><p>适合任务数比较密集，但每个任务执行时间较短的情况</p></li></ul></li><li><p>newSingleThreadExecutor：创建一个只有 1 个线程的单线程池</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newSingleThreadExecutor</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FinalizableDelegatedExecutorService</span>  <br>        (<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,  <br>                                <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>保证所有任务按照<strong>指定顺序执行</strong>，线程数固定为 1，任务数多于 1 时会放入无界队列排队，任务执行完毕，这唯一的线程也不会被释放</li></ul></li></ul><p>对比：</p><ul><li><p>创建一个单线程串行执行任务，如果任务执行失败而终止那么没有任何补救措施，线程池会新建一个线程，保证池的正常工作</p></li><li><p>Executors.newSingleThreadExecutor() 线程个数始终为 1，不能修改。FinalizableDelegatedExecutorService 应用的是装饰器模式，只对外暴露了 ExecutorService 接口，因此不能调用 ThreadPoolExecutor 中特有的方法</p><p>  原因：父类不能直接调用子类中的方法，需要反射或者创建对象的方式，可以调用子类静态方法</p></li><li><p>Executors.newFixedThreadPool(1) 初始时为 1，可以修改。对外暴露的是 ThreadPoolExecutor 对象，可以强转后调用 setCorePoolSize 等方法进行修改</p></li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041812233.png"></p><hr><h5 id="开发要求"><a href="#开发要求" class="headerlink" title="开发要求"></a>开发要求</h5><p>阿里巴巴 Java 开发手册要求：</p><ul><li><p><strong>线程资源必须通过线程池提供，不允许在应用中自行显式创建线程</strong></p><ul><li><p>使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源的开销，解决资源不足的问题</p></li><li><p>如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者过度切换的问题</p></li></ul></li><li><p>线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式更加明确线程池的运行规则，规避资源耗尽的风险</p><p>  Executors 返回的线程池对象弊端如下：</p><ul><li><p>FixedThreadPool 和 SingleThreadPool：请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM</p></li><li><p>CacheThreadPool 和 ScheduledThreadPool：允许创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，导致 OOM</p></li></ul></li></ul><p>创建多大容量的线程池合适？</p><ul><li><p>一般来说池中<strong>总线程数是核心池线程数量两倍</strong>，确保当核心池有线程停止时，核心池外有线程进入核心池</p></li><li><p>过小会导致程序不能充分地利用系统资源、容易导致饥饿</p></li><li><p>过大会导致更多的线程上下文切换，占用更多内存</p><p>  上下文切换：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态，任务从保存到再加载的过程就是一次上下文切换</p></li></ul><p>核心线程数常用公式：</p><ul><li><p><strong>CPU 密集型任务 (N+1)：</strong> 这种任务消耗的是 CPU 资源，可以将核心线程数设置为 N (CPU 核心数) + 1，比 CPU 核心数多出来的一个线程是为了防止线程发生缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 某个核心就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间</p><p>  CPU 密集型简单理解就是利用 CPU 计算能力的任务比如在内存中对大量数据进行分析</p></li><li><p><strong>I&#x2F;O 密集型任务：</strong> 这种系统 CPU 处于阻塞状态，用大部分的时间来处理 I&#x2F;O 交互，而线程在处理 I&#x2F;O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用，因此在 I&#x2F;O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N 或 CPU 核数&#x2F; (1-阻塞系数)，阻塞系数在 0.8~0.9 之间</p><p>  IO 密集型就是涉及到网络读取，文件读取此类任务 ，特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上</p></li></ul><hr><h4 id="提交方法"><a href="#提交方法" class="headerlink" title="提交方法"></a>提交方法</h4><p>ExecutorService 类 API：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//执行任务（Executor 类 API）</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> <br><br><span class="hljs-comment">//提交任务 task()</span><br>Future&lt; ?&gt; submit(Runnable task) <br><br><span class="hljs-comment">//提交任务 task，用返回值 Future 获得任务执行结果</span><br>Future <span class="hljs-title function_">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span> <br><br><span class="hljs-comment">//提交 tasks 中所有任务</span><br>List&lt;Future&lt;T&gt;&gt; <span class="hljs-title function_">invokeAll</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span> <br><br><span class="hljs-comment">//提交 tasks 中所有任务，超时时间针对所有task，超时会取消没有执行完的任务，并抛出超时异常</span><br>List&lt;Future&lt;T&gt;&gt; <span class="hljs-title function_">invokeAll</span><span class="hljs-params">(Collection&lt; ? extends Callable&lt;T&gt;&gt; tasks, <span class="hljs-type">long</span> timeout, TimeUnit unit)</span> <br><br><span class="hljs-comment">//提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消</span><br>T <span class="hljs-title function_">invokeAny</span><span class="hljs-params">(Collection&lt; ? extends Callable&lt;T&gt;&gt; tasks)</span> <br></code></pre></td></tr></table></figure><p>execute 和 submit 都属于线程池的方法，对比：</p><ul><li><p>execute 只能执行 Runnable 类型的任务，没有返回值； submit 既能提交 Runnable 类型任务也能提交 Callable 类型任务，底层是<strong>封装成 FutureTask，然后调用 execute 执行</strong></p></li><li><p>execute 会直接抛出任务执行时的异常，submit 会吞掉异常，可通过 Future 的 get 方法将任务执行时的异常重新抛出</p></li></ul><hr><h4 id="关闭方法"><a href="#关闭方法" class="headerlink" title="关闭方法"></a>关闭方法</h4><p>ExecutorService 类 API：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">//线程池状态变为 SHUTDOWN，等待任务执行完后关闭线程池，不会接收新任务，但已提交任务会执行完，而且也可以添加线程（不绑定任务）</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">()</span><br><br><span class="hljs-comment">//线程池状态变为 STOP，用 interrupt 中断正在执行的任务，直接关闭线程池，不会接收新任务，会将队列中的任务返回</span><br>List&lt;Runnable&gt; <span class="hljs-title function_">shutdownNow</span><span class="hljs-params">()</span><br><br><span class="hljs-comment">//不在 RUNNING 状态的线程池，此执行者已被关闭，方法返回 true</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">isShutdown</span><span class="hljs-params">()</span><br><br><span class="hljs-comment">//线程池状态是否是 TERMINATED，如果所有任务在关闭后完成，返回 true</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">isTerminated</span><span class="hljs-params">()</span><br><br><span class="hljs-comment">//调用 shutdown 后，由于调用线程不会等待所有任务运行结束，如果它想在线程池 TERMINATED 后做些事情，可以利用此方法等待</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">awaitTermination</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br><br></code></pre></td></tr></table></figure><hr><h4 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h4><p>execute 会直接抛出任务执行时的异常，submit 会吞掉异常，有两种处理方法</p><p>方法 1：主动捉异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">1</span>);  <br>pool.submit(() -&gt; &#123;  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;task1&quot;</span>);  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> / <span class="hljs-number">0</span>;  <br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;  <br>        e.printStackTrace();  <br>    &#125;  <br>&#125;);<br></code></pre></td></tr></table></figure><p>方法 2：使用 Future 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">1</span>);  <br>Future&lt;?&gt; future = pool.submit(() -&gt; &#123;  <br>    System.out.println(<span class="hljs-string">&quot;task1&quot;</span>);  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> / <span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>&#125;);  <br>System.out.println(future.get());<br></code></pre></td></tr></table></figure><hr><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><h4 id="状态信息"><a href="#状态信息" class="headerlink" title="状态信息"></a>状态信息</h4><p>ThreadPoolExecutor 使用 int 的<strong>高 3 位来表示线程池状态，低 29 位表示线程数量</strong>。这些信息存储在一个原子变量 ctl 中，目的是将线程池状态与线程个数合二为一，这样就可以用一次 CAS 原子操作进行赋值</p><ul><li><p>状态表示：</p><p>  &#x2F;&#x2F; 高3位：表示当前线程池运行状态，除去高3位之后的低位：表示当前线程池中所拥有的线程数量<br>  <code>private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));  </code><br>  &#x2F;&#x2F; 表示在 ctl 中，低 COUNT_BITS 位，是用于存放当前线程数量的位<br>  <code>private static final int COUNT_BITS = Integer.SIZE - 3;  </code><br>  &#x2F;&#x2F; 低 COUNT_BITS 位所能表达的最大数值，000 11111111111111111111 &#x3D;&gt; 5亿多<br>  <code>private static final int CAPACITY   = (1 &lt;&lt; COUNT_BITS) - 1;</code></p><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041822556.png"></p></li><li><p>四种状态：</p><p>  &#x2F;&#x2F; 111 000000000000000000，转换成整数后其实就是一个【负数】<br>  private static final int RUNNING    &#x3D; -1 &lt;&lt; COUNT_BITS;<br>  &#x2F;&#x2F; 000 000000000000000000<br>  private static final int SHUTDOWN   &#x3D;  0 &lt;&lt; COUNT_BITS;<br>  &#x2F;&#x2F; 001 000000000000000000<br>  private static final int STOP       &#x3D;  1 &lt;&lt; COUNT_BITS;<br>  &#x2F;&#x2F; 010 000000000000000000<br>  private static final int TIDYING    &#x3D;  2 &lt;&lt; COUNT_BITS;<br>  &#x2F;&#x2F; 011 000000000000000000<br>  private static final int TERMINATED &#x3D;  3 &lt;&lt; COUNT_BITS;</p><table><thead><tr><th>状态</th><th>高3位</th><th>接收新任务</th><th>处理阻塞任务队列</th><th>说明</th></tr></thead><tbody><tr><td>RUNNING</td><td>111</td><td>Y</td><td>Y</td><td></td></tr><tr><td>SHUTDOWN</td><td>000</td><td>N</td><td>Y</td><td>不接收新任务，但处理阻塞队列剩余任务</td></tr><tr><td>STOP</td><td>001</td><td>N</td><td>N</td><td>中断正在执行的任务，并抛弃阻塞队列任务</td></tr><tr><td>TIDYING</td><td>010</td><td>-</td><td>-</td><td>任务全执行完毕，活动线程为 0 即将进入终结</td></tr><tr><td>TERMINATED</td><td>011</td><td>-</td><td>-</td><td>终止状态</td></tr></tbody></table></li><li><p>获取当前线程池运行状态：</p><p>  &#x2F;&#x2F; ~CAPACITY &#x3D; ~000 11111111111111111111 &#x3D; 111 000000000000000000000（取反）<br>  &#x2F;&#x2F; c &#x3D;&#x3D; ctl &#x3D; 111 000000000000000000111<br>  &#x2F;&#x2F; 111 000000000000000000111<br>  &#x2F;&#x2F; 111 000000000000000000000<br>  &#x2F;&#x2F; 111 000000000000000000000获取到了运行状态<br>  <code>private static int runStateOf(int c)     &#123; return c &amp; ~CAPACITY; &#125;</code></p></li><li><p>获取当前线程池线程数量：</p><p>  &#x2F;&#x2F;        c &#x3D; 111 000000000000000000111<br>  &#x2F;&#x2F; CAPACITY &#x3D; 000 111111111111111111111<br>  &#x2F;&#x2F;            000 000000000000000000111 &#x3D;&gt; 7<br>  <code>private static int workerCountOf(int c)  &#123; return c &amp; CAPACITY; &#125;</code></p></li><li><p>重置当前线程池状态 ctl：</p><p>  &#x2F;&#x2F; rs 表示线程池状态，wc 表示当前线程池中 worker（线程）数量，相与以后就是合并后的状态<br>  <code>private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125;</code></p></li><li><p>比较当前线程池 ctl 所表示的状态：</p><p>  &#x2F;&#x2F; 比较当前线程池 ctl 所表示的状态，是否小于某个状态 s<br>  &#x2F;&#x2F; 状态对比：RUNNING &lt; SHUTDOWN &lt; STOP &lt; TIDYING &lt; TERMINATED<br>  <code>private static boolean runStateLessThan(int c, int s) &#123; return c &lt; s; &#125;  </code><br>  &#x2F;&#x2F; 比较当前线程池 ctl 所表示的状态，是否大于等于某个状态s<br>  <code>private static boolean runStateAtLeast(int c, int s) &#123; return c &gt;= s; &#125;  </code><br>  &#x2F;&#x2F; 小于 SHUTDOWN 的一定是 RUNNING，SHUTDOWN &#x3D;&#x3D; 0<br>  <code>private static boolean isRunning(int c) &#123; return c &lt; SHUTDOWN; &#125;</code></p></li><li><p>设置线程池 ctl：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用 CAS 方式 让 ctl 值 +1 ，成功返回 true, 失败返回 false  </span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndIncrementWorkerCount</span><span class="hljs-params">(<span class="hljs-type">int</span> expect)</span> &#123;  <br>    <span class="hljs-keyword">return</span> ctl.compareAndSet(expect, expect + <span class="hljs-number">1</span>);  <br>&#125;  <br><span class="hljs-comment">// 使用 CAS 方式 让 ctl 值 -1 ，成功返回 true, 失败返回 false  </span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndDecrementWorkerCount</span><span class="hljs-params">(<span class="hljs-type">int</span> expect)</span> &#123;  <br>    <span class="hljs-keyword">return</span> ctl.compareAndSet(expect, expect - <span class="hljs-number">1</span>);  <br>&#125;  <br><span class="hljs-comment">// 将 ctl 值减一，do while 循环会一直重试，直到成功为止  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decrementWorkerCount</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">do</span> &#123;&#125; <span class="hljs-keyword">while</span> (!compareAndDecrementWorkerCount(ctl.get()));  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h4 id="成员属性-2"><a href="#成员属性-2" class="headerlink" title="成员属性"></a>成员属性</h4><p>成员变量</p><ul><li><p><strong>线程池中存放 Worker 的容器</strong>：线程池没有初始化，直接往池中加线程即可</p><p>  <code>private final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;();</code></p></li><li><p>线程全局锁：</p><p>  &#x2F;&#x2F; 增加减少 worker 或者时修改线程池运行状态需要持有 mainLock<br>  <code>private final ReentrantLock mainLock = new ReentrantLock();</code></p></li><li><p>可重入锁的条件变量：</p><p>  &#x2F;&#x2F; 当外部线程调用 awaitTermination() 方法时，会等待当前线程池状态为 Termination 为止<br>  <code>private final Condition termination = mainLock.newCondition()</code></p></li><li><p>线程池相关参数：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> corePoolSize;<span class="hljs-comment">// 核心线程数量  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> maximumPoolSize;<span class="hljs-comment">// 线程池最大线程数量  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> keepAliveTime;<span class="hljs-comment">// 空闲线程存活时间  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> ThreadFactory threadFactory;<span class="hljs-comment">// 创建线程时使用的线程工厂，默认是 DefaultThreadFactory  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;<span class="hljs-comment">// 【超过核心线程提交任务就放入 阻塞队列】</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> RejectedExecutionHandler handler;<span class="hljs-comment">// 拒绝策略，juc包提供了4中方式  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">RejectedExecutionHandler</span> <span class="hljs-variable">defaultHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbortPolicy</span>();<span class="hljs-comment">// 默认策略</span><br></code></pre></td></tr></table></figure></li><li><p>记录线程池相关属性的数值：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> largestPoolSize;<span class="hljs-comment">// 记录线程池生命周期内线程数最大值  </span><br><span class="hljs-keyword">private</span> <span class="hljs-type">long</span> completedTaskCount;<span class="hljs-comment">// 记录线程池所完成任务总数，当某个 worker 退出时将完成的任务累加到该属性</span><br></code></pre></td></tr></table></figure></li><li><p>控制<strong>核心线程数量内的线程是否可以被回收</strong>：</p><p>  &#x2F;&#x2F; false（默认）代表不可以，为 true 时核心线程空闲超过 keepAliveTime 也会被回收<br>  &#x2F;&#x2F; allowCoreThreadTimeOut(boolean value) 方法可以设置该值<br>  <code>private volatile boolean allowCoreThreadTimeOut;</code></p></li></ul><p>内部类：</p><ul><li><p>Worker 类：<strong>每个 Worker 对象会绑定一个初始任务</strong>，启动 Worker 时优先执行，这也是造成线程池不公平的原因。Worker 继承自 AQS，本身具有锁的特性，采用独占锁模式，state &#x3D; 0 表示未被占用，&gt; 0 表示被占用，&lt; 0 表示初始状态不能被抢锁</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;  <br><span class="hljs-keyword">final</span> Thread thread;<span class="hljs-comment">// worker 内部封装的工作线程  </span><br>    Runnable firstTask;<span class="hljs-comment">// worker 第一个执行的任务，普通的 Runnable 实现类或者是 FutureTask  </span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> completedTasks;<span class="hljs-comment">// 记录当前 worker 所完成任务数量  </span><br>      <br>    <span class="hljs-comment">// 构造方法  </span><br>    Worker(Runnable firstTask) &#123;  <br>        <span class="hljs-comment">// 设置AQS独占模式为初始化中状态，这个状态不能被抢占锁  </span><br>       setState(-<span class="hljs-number">1</span>);  <br>        <span class="hljs-comment">// firstTask不为空时，当worker启动后，内部线程会优先执行firstTask，执行完后会到queue中去获取下个任务  </span><br>        <span class="hljs-built_in">this</span>.firstTask = firstTask;  <br>        <span class="hljs-comment">// 使用线程工厂创建一个线程，并且【将当前worker指定为Runnable】，所以thread启动时会调用 worker.run()  </span><br>        <span class="hljs-built_in">this</span>.thread = getThreadFactory().newThread(<span class="hljs-built_in">this</span>);  <br>    &#125;  <br>    <span class="hljs-comment">// 【不可重入锁】  </span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> unused)</span> &#123;  <br>        <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;  <br>            setExclusiveOwnerThread(Thread.currentThread());  <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>    &#125;  <br>&#125;<br><br><span class="hljs-keyword">public</span> Thread <span class="hljs-title function_">newThread</span><span class="hljs-params">(Runnable r)</span> &#123;  <br>    <span class="hljs-comment">// 将当前 worker 指定为 thread 的执行方法，线程调用 start 会调用 r.run()  </span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(group, r, namePrefix + threadNumber.getAndIncrement(), <span class="hljs-number">0</span>);  <br>    <span class="hljs-keyword">if</span> (t.isDaemon())  <br>        t.setDaemon(<span class="hljs-literal">false</span>);  <br>    <span class="hljs-keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)  <br>        t.setPriority(Thread.NORM_PRIORITY);  <br>    <span class="hljs-keyword">return</span> t;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>拒绝策略相关的内部类</p></li></ul><hr><h4 id="成员方法-2"><a href="#成员方法-2" class="headerlink" title="成员方法"></a>成员方法</h4><h5 id="提交方法-1"><a href="#提交方法-1" class="headerlink" title="提交方法"></a>提交方法</h5><ul><li><p>AbstractExecutorService#submit()：提交任务，<strong>把 Runnable 或 Callable 任务封装成 FutureTask 执行</strong>，可以通过方法返回的任务对象，调用 get 阻塞获取任务执行的结果或者异常，源码分析在笔记的 Future 部分</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;  <br>    <span class="hljs-comment">// 空指针异常  </span><br>    <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();  <br>    <span class="hljs-comment">// 把 Runnable 封装成未来任务对象，执行结果就是 null，也可以通过参数指定 FutureTask#get 返回数据  </span><br>    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="hljs-literal">null</span>);  <br>    <span class="hljs-comment">// 执行方法  </span><br>    execute(ftask);  <br>    <span class="hljs-keyword">return</span> ftask;  <br>&#125;  <br><span class="hljs-keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span> &#123;  <br>    <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();  <br>    <span class="hljs-comment">// 把 Callable 封装成未来任务对象  </span><br>    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);  <br>    <span class="hljs-comment">// 执行方法  </span><br>    execute(ftask);  <br>    <span class="hljs-comment">// 返回未来任务对象，用来获取返回值  </span><br>    <span class="hljs-keyword">return</span> ftask;  <br>&#125;<br><br><span class="hljs-keyword">protected</span> &lt;T&gt; RunnableFuture&lt;T&gt; <span class="hljs-title function_">newTaskFor</span><span class="hljs-params">(Runnable runnable, T value)</span> &#123;  <br>    <span class="hljs-comment">// Runnable 封装成 FutureTask，【指定返回值】  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;T&gt;(runnable, value);  <br>&#125;  <br><span class="hljs-keyword">protected</span> &lt;T&gt; RunnableFuture&lt;T&gt; <span class="hljs-title function_">newTaskFor</span><span class="hljs-params">(Callable&lt;T&gt; callable)</span> &#123;  <br>    <span class="hljs-comment">// Callable 直接封装成 FutureTask  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;T&gt;(callable);  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>execute()：执行任务，<strong>但是没有返回值，没办法获取任务执行结果</strong>，出现异常会直接抛出任务执行时的异常。根据线程池中的线程数，选择添加任务时的处理方式</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// command 可以是普通的 Runnable 实现类，也可以是 FutureTask，不能是 Callable  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> &#123;  <br>    <span class="hljs-comment">// 非空判断  </span><br>    <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span>)  <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();  <br>  <span class="hljs-comment">// 获取 ctl 最新值赋值给 c，ctl 高 3 位表示线程池状态，低位表示当前线程池线程数量。  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();  <br>    <span class="hljs-comment">// 【1】当前线程数量小于核心线程数，此次提交任务直接创建一个新的 worker，线程池中多了一个新的线程  </span><br>    <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;  <br>        <span class="hljs-comment">// addWorker 为创建线程的过程，会创建 worker 对象并且将 command 作为 firstTask，优先执行  </span><br>        <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-literal">true</span>))  <br>            <span class="hljs-keyword">return</span>;  <br>          <br>        <span class="hljs-comment">// 执行到这条语句，说明 addWorker 一定是失败的，存在并发现象或者线程池状态被改变，重新获取状态  </span><br>        <span class="hljs-comment">// SHUTDOWN 状态下也有可能创建成功，前提 firstTask == null 而且当前 queue 不为空（特殊情况）  </span><br>        c = ctl.get();  <br>    &#125;  <br>    <span class="hljs-comment">// 【2】执行到这说明当前线程数量已经达到核心线程数量 或者 addWorker 失败  </span><br>    <span class="hljs-comment">// 判断当前线程池是否处于running状态，成立就尝试将 task 放入到 workQueue 中  </span><br>    <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">recheck</span> <span class="hljs-operator">=</span> ctl.get();  <br>        <span class="hljs-comment">// 条件一成立说明线程池状态被外部线程给修改了，可能是执行了 shutdown() 方法，该状态不能接收新提交的任务  </span><br>        <span class="hljs-comment">// 所以要把刚提交的任务删除，删除成功说明提交之后线程池中的线程还未消费（处理）该任务  </span><br>        <span class="hljs-keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))  <br>            <span class="hljs-comment">// 任务出队成功，走拒绝策略  </span><br>            reject(command);  <br>        <span class="hljs-comment">// 执行到这说明线程池是 running 状态，获取线程池中的线程数量，判断是否是 0  </span><br>        <span class="hljs-comment">// 【担保机制】，保证线程池在 running 状态下，最起码得有一个线程在工作  </span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)  <br>            addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);  <br>    &#125;  <br>    <span class="hljs-comment">// 【3】offer失败说明queue满了  </span><br>    <span class="hljs-comment">// 如果线程数量尚未达到 maximumPoolSize，会创建非核心 worker 线程直接执行 command，【这也是不公平的原因】  </span><br>    <span class="hljs-comment">// 如果当前线程数量达到 maximumPoolSiz，这里 addWorker 也会失败，走拒绝策略  </span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-literal">false</span>))  <br>        reject(command);  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h5 id="添加线程"><a href="#添加线程" class="headerlink" title="添加线程"></a>添加线程</h5><ul><li><p>prestartAllCoreThreads()：<strong>提前预热</strong>，创建所有的核心线程</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">prestartAllCoreThreads</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">while</span> (addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>))  <br>        ++n;  <br>    <span class="hljs-keyword">return</span> n;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>addWorker()：<strong>添加线程到线程池</strong>，返回 true 表示创建 Worker 成功，且线程启动。首先判断线程池是否允许添加线程，允许就让线程数量 + 1，然后去创建 Worker 加入线程池</p><p>  注意：SHUTDOWN 状态也能添加线程，但是要求新加的 Woker 没有 firstTask，而且当前 queue 不为空，所以创建一个线程来帮助线程池执行队列中的任务</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// core == true 表示采用核心线程数量限制，false 表示采用 maximumPoolSize  </span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addWorker</span><span class="hljs-params">(Runnable firstTask, <span class="hljs-type">boolean</span> core)</span> &#123;  <br>    <span class="hljs-comment">// 自旋【判断当前线程池状态是否允许创建线程】，允许就设置线程数量 + 1  </span><br>    retry:  <br>    <span class="hljs-keyword">for</span> (;;) &#123;  <br>        <span class="hljs-comment">// 获取 ctl 的值  </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();  <br>        <span class="hljs-comment">// 获取当前线程池运行状态  </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(c);  <br>          <br>        <span class="hljs-comment">// 判断当前线程池状态【是否允许添加线程】  </span><br>          <br>        <span class="hljs-comment">// 当前线程池是 SHUTDOWN 状态，但是队列里面还有任务尚未处理完，需要处理完 queue 中的任务  </span><br>        <span class="hljs-comment">// 【不允许再提交新的 task，所以 firstTask 为空，但是可以继续添加 worker】  </span><br>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; !(rs == SHUTDOWN &amp;&amp; firstTask == <span class="hljs-literal">null</span> &amp;&amp; !workQueue.isEmpty()))  <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>        <span class="hljs-keyword">for</span> (;;) &#123;  <br>            <span class="hljs-comment">// 获取线程池中线程数量  </span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">wc</span> <span class="hljs-operator">=</span> workerCountOf(c);  <br>            <span class="hljs-comment">// 条件一一般不成立，CAPACITY是5亿多，根据 core 判断使用哪个大小限制线程数量，超过了返回 false  </span><br>            <span class="hljs-keyword">if</span> (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize))  <br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>            <span class="hljs-comment">// 记录线程数量已经加 1，类比于申请到了一块令牌，条件失败说明其他线程修改了数量  </span><br>            <span class="hljs-keyword">if</span> (compareAndIncrementWorkerCount(c))  <br>                <span class="hljs-comment">// 申请成功，跳出了 retry 这个 for 自旋  </span><br>                <span class="hljs-keyword">break</span> retry;  <br>            <span class="hljs-comment">// CAS 失败，没有成功的申请到令牌  </span><br>            c = ctl.get();  <br>            <span class="hljs-comment">// 判断当前线程池状态是否发生过变化，被其他线程修改了，可能其他线程调用了 shutdown() 方法  </span><br>            <span class="hljs-keyword">if</span> (runStateOf(c) != rs)  <br>                <span class="hljs-comment">// 返回外层循环检查是否能创建线程，在 if 语句中返回 false  </span><br>                <span class="hljs-keyword">continue</span> retry;  <br>             <br>        &#125;  <br>    &#125;  <br>      <br>    <span class="hljs-comment">//【令牌申请成功，开始创建线程】  </span><br>      <br><span class="hljs-comment">// 运行标记，表示创建的 worker 是否已经启动，false未启动  true启动  </span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">workerStarted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;  <br>    <span class="hljs-comment">// 添加标记，表示创建的 worker 是否添加到池子中了，默认false未添加，true是添加。  </span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">workerAdded</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;  <br>    <span class="hljs-type">Worker</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-comment">// 【创建 Worker，底层通过线程工厂 newThread 方法创建执行线程，指定了首先执行的任务】  </span><br>        w = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(firstTask);  <br>        <span class="hljs-comment">// 将新创建的 worker 节点中的线程赋值给 t  </span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> w.thread;  <br>        <span class="hljs-comment">// 这里的判断为了防止 程序员自定义的 ThreadFactory 实现类有 bug，创造不出线程  </span><br>        <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;  <br>            <span class="hljs-comment">// 加互斥锁，要添加 worker 了  </span><br>            mainLock.lock();  <br>            <span class="hljs-keyword">try</span> &#123;  <br>                <span class="hljs-comment">// 获取最新线程池运行状态保存到 rs  </span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(ctl.get());  <br><span class="hljs-comment">// 判断线程池是否为RUNNING状态，不是再【判断当前是否为SHUTDOWN状态且firstTask为空，特殊情况】  </span><br>                <span class="hljs-keyword">if</span> (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == <span class="hljs-literal">null</span>)) &#123;  <br>                    <span class="hljs-comment">// 当线程start后，线程isAlive会返回true，这里还没开始启动线程，如果被启动了就需要报错  </span><br>                    <span class="hljs-keyword">if</span> (t.isAlive())  <br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalThreadStateException</span>();  <br>                      <br>                    <span class="hljs-comment">//【将新建的 Worker 添加到线程池中】  </span><br>                    workers.add(w);  <br>                    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> workers.size();  <br><span class="hljs-comment">// 当前池中的线程数量是一个新高，更新 largestPoolSize  </span><br>                    <span class="hljs-keyword">if</span> (s &gt; largestPoolSize)  <br>                        largestPoolSize = s;  <br>                    <span class="hljs-comment">// 添加标记置为 true  </span><br>                    workerAdded = <span class="hljs-literal">true</span>;  <br>                &#125;  <br>            &#125; <span class="hljs-keyword">finally</span> &#123;  <br>                <span class="hljs-comment">// 解锁啊  </span><br>                mainLock.unlock();  <br>            &#125;  <br>            <span class="hljs-comment">// 添加成功就【启动线程执行任务】  </span><br>            <span class="hljs-keyword">if</span> (workerAdded) &#123;  <br>                <span class="hljs-comment">// Thread 类中持有 Runnable 任务对象，调用的是 Runnable 的 run ，也就是 FutureTask  </span><br>                t.start();  <br>                <span class="hljs-comment">// 运行标记置为 true  </span><br>                workerStarted = <span class="hljs-literal">true</span>;  <br>            &#125;  <br>        &#125;  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        <span class="hljs-comment">// 如果启动线程失败，做清理工作  </span><br>        <span class="hljs-keyword">if</span> (! workerStarted)  <br>            addWorkerFailed(w);  <br>    &#125;  <br>    <span class="hljs-comment">// 返回新创建的线程是否启动  </span><br>    <span class="hljs-keyword">return</span> workerStarted;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>addWorkerFailed()：清理任务</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addWorkerFailed</span><span class="hljs-params">(Worker w)</span> &#123;  <br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;  <br>    <span class="hljs-comment">// 持有线程池全局锁，因为操作的是线程池相关的东西  </span><br>    mainLock.lock();  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-comment">//条件成立需要将 worker 在 workers 中清理出去。  </span><br>        <span class="hljs-keyword">if</span> (w != <span class="hljs-literal">null</span>)  <br>            workers.remove(w);  <br>        <span class="hljs-comment">// 将线程池计数 -1，相当于归还令牌。  </span><br>        decrementWorkerCount();  <br>        <span class="hljs-comment">// 尝试停止线程池  </span><br>        tryTerminate();  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        <span class="hljs-comment">//释放线程池全局锁。  </span><br>        mainLock.unlock();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h5 id="运行方法"><a href="#运行方法" class="headerlink" title="运行方法"></a>运行方法</h5><ul><li><p>Worker#run：Worker 实现了 Runnable 接口，当线程启动时，会调用 Worker 的 run() 方法</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">// ThreadPoolExecutor#runWorker()  </span><br>    runWorker(<span class="hljs-built_in">this</span>);  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>runWorker()：线程启动就要<strong>执行任务</strong>，会一直 while 循环获取任务并执行</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">runWorker</span><span class="hljs-params">(Worker w)</span> &#123;  <br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">wt</span> <span class="hljs-operator">=</span> Thread.currentThread();  <br>    <span class="hljs-comment">// 获取 worker 的 firstTask  </span><br>    <span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> w.firstTask;  <br>    <span class="hljs-comment">// 引用置空，【防止复用该线程时重复执行该任务】  </span><br>    w.firstTask = <span class="hljs-literal">null</span>;  <br>    <span class="hljs-comment">// 初始化 worker 时设置 state = -1，表示不允许抢占锁  </span><br>    <span class="hljs-comment">// 这里需要设置 state = 0 和 exclusiveOwnerThread = null，开始独占模式抢锁  </span><br>    w.unlock();  <br>    <span class="hljs-comment">// true 表示发生异常退出，false 表示正常退出。  </span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">completedAbruptly</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-comment">// firstTask 不是 null 就直接运行，否则去 queue 中获取任务  </span><br>        <span class="hljs-comment">// 【getTask 如果是阻塞获取任务，会一直阻塞在take方法，直到获取任务，不会走返回null的逻辑】  </span><br>        <span class="hljs-keyword">while</span> (task != <span class="hljs-literal">null</span> || (task = getTask()) != <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-comment">// worker 加锁，shutdown 时会判断当前 worker 状态，【根据独占锁状态判断是否空闲】  </span><br>            w.lock();  <br>              <br><span class="hljs-comment">// 说明线程池状态大于 STOP，目前处于 STOP/TIDYING/TERMINATION，此时给线程一个中断信号  </span><br>            <span class="hljs-keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||  <br>                 <span class="hljs-comment">// 说明线程处于 RUNNING 或者 SHUTDOWN 状态，清除打断标记  </span><br>                 (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted())  <br>                <span class="hljs-comment">// 中断线程，设置线程的中断标志位为 true  </span><br>                wt.interrupt();  <br>            <span class="hljs-keyword">try</span> &#123;  <br>                <span class="hljs-comment">// 钩子方法，【任务执行的前置处理】  </span><br>                beforeExecute(wt, task);  <br>                <span class="hljs-type">Throwable</span> <span class="hljs-variable">thrown</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;  <br>                <span class="hljs-keyword">try</span> &#123;  <br>                    <span class="hljs-comment">// 【执行任务】  </span><br>                    task.run();  <br>                &#125; <span class="hljs-keyword">catch</span> (Exception x) &#123;  <br>                 <span class="hljs-comment">//.....  </span><br>                &#125; <span class="hljs-keyword">finally</span> &#123;  <br>                    <span class="hljs-comment">// 钩子方法，【任务执行的后置处理】  </span><br>                    afterExecute(task, thrown);  <br>                &#125;  <br>            &#125; <span class="hljs-keyword">finally</span> &#123;  <br>                task = <span class="hljs-literal">null</span>;<span class="hljs-comment">// 将局部变量task置为null，代表任务执行完成  </span><br>                w.completedTasks++;<span class="hljs-comment">// 更新worker完成任务数量  </span><br>                w.unlock();<span class="hljs-comment">// 解锁  </span><br>            &#125;  <br>        &#125;  <br>        <span class="hljs-comment">// getTask()方法返回null时会走到这里，表示queue为空并且线程空闲超过保活时间，【当前线程执行退出逻辑】  </span><br>        completedAbruptly = <span class="hljs-literal">false</span>;  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        <span class="hljs-comment">// 正常退出 completedAbruptly = false  </span><br>       <span class="hljs-comment">// 异常退出 completedAbruptly = true，【从 task.run() 内部抛出异常】时，跳到这一行  </span><br>        processWorkerExit(w, completedAbruptly);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>unlock()：重置锁</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123; release(<span class="hljs-number">1</span>); &#125;  <br><span class="hljs-comment">// 外部不会直接调用这个方法 这个方法是 AQS 内调用的，外部调用 unlock 时触发此方法  </span><br><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> unused)</span> &#123;  <br>    setExclusiveOwnerThread(<span class="hljs-literal">null</span>);<span class="hljs-comment">// 设置持有者为 null  </span><br>    setState(<span class="hljs-number">0</span>);<span class="hljs-comment">// 设置 state = 0  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>getTask()：获取任务，线程空闲时间超过 keepAliveTime 就会被回收，判断的依据是<strong>当前线程阻塞获取任务超过保活时间</strong>，方法返回 null 就代表当前线程要被回收了，返回到 runWorker 执行线程退出逻辑。线程池具有担保机制，对于 RUNNING 状态下的超时回收，要保证线程池中最少有一个线程运行，或者任务阻塞队列已经是空</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> Runnable <span class="hljs-title function_">getTask</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">// 超时标记，表示当前线程获取任务是否超时，true 表示已超时  </span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">timedOut</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;   <br>    <span class="hljs-keyword">for</span> (;;) &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();  <br>        <span class="hljs-comment">// 获取线程池当前运行状态  </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(c);  <br>  <br>        <span class="hljs-comment">// 【tryTerminate】打断线程后执行到这，此时线程池状态为STOP或者线程池状态为SHUTDOWN并且队列已经是空  </span><br>        <span class="hljs-comment">// 所以下面的 if 条件一定是成立的，可以直接返回 null，线程就应该退出了  </span><br>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;  <br>            <span class="hljs-comment">// 使用 CAS 自旋的方式让 ctl 值 -1  </span><br>            decrementWorkerCount();  <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>        &#125;  <br>          <br><span class="hljs-comment">// 获取线程池中的线程数量  </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">wc</span> <span class="hljs-operator">=</span> workerCountOf(c);  <br>  <br>        <span class="hljs-comment">// 线程没有明确的区分谁是核心或者非核心线程，是根据当前池中的线程数量判断  </span><br>          <br>        <span class="hljs-comment">// timed = false 表示当前这个线程 获取task时不支持超时机制的，当前线程会使用 queue.take() 阻塞获取  </span><br>        <span class="hljs-comment">// timed = true 表示当前这个线程 获取task时支持超时机制，使用 queue.poll(xxx,xxx) 超时获取  </span><br>        <span class="hljs-comment">// 条件一代表允许回收核心线程，那就无所谓了，全部线程都执行超时回收  </span><br>        <span class="hljs-comment">// 条件二成立说明线程数量大于核心线程数，当前线程认为是非核心线程，有保活时间，去超时获取任务  </span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">timed</span> <span class="hljs-operator">=</span> allowCoreThreadTimeOut || wc &gt; corePoolSize;  <br>          <br><span class="hljs-comment">// 如果线程数量是否超过最大线程数，直接回收  </span><br>        <span class="hljs-comment">// 如果当前线程【允许超时回收并且已经超时了】，就应该被回收了，由于【担保机制】还要做判断：  </span><br>        <span class="hljs-comment">//   wc &gt; 1 说明线程池还用其他线程，当前线程可以直接回收  </span><br>        <span class="hljs-comment">//    workQueue.isEmpty() 前置条件是 wc = 1，【如果当前任务队列也是空了，最后一个线程就可以退出】  </span><br>        <span class="hljs-keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) &amp;&amp; (wc &gt; <span class="hljs-number">1</span> || workQueue.isEmpty())) &#123;  <br>            <span class="hljs-comment">// 使用 CAS 机制将 ctl 值 -1 ,减 1 成功的线程，返回 null，代表可以退出  </span><br>            <span class="hljs-keyword">if</span> (compareAndDecrementWorkerCount(c))  <br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>            <span class="hljs-keyword">continue</span>;  <br>        &#125;  <br>  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            <span class="hljs-comment">// 根据当前线程是否需要超时回收，【选择从队列获取任务的方法】是超时获取或者阻塞获取  </span><br>            <span class="hljs-type">Runnable</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> timed ?  <br>                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take();  <br>            <span class="hljs-comment">// 获取到任务返回任务，【阻塞获取会阻塞到获取任务为止】，不会返回 null  </span><br>            <span class="hljs-keyword">if</span> (r != <span class="hljs-literal">null</span>)  <br>                <span class="hljs-keyword">return</span> r;  <br>            <span class="hljs-comment">// 获取任务为 null 说明超时了，将超时标记设置为 true，下次自旋时返 null  </span><br>            timedOut = <span class="hljs-literal">true</span>;  <br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException retry) &#123;  <br>            <span class="hljs-comment">// 阻塞线程被打断后超时标记置为 false，【说明被打断不算超时】，要继续获取，直到超时或者获取到任务  </span><br>            <span class="hljs-comment">// 如果线程池 SHUTDOWN 状态下的打断，会在循环获取任务前判断，返回 null  </span><br>            timedOut = <span class="hljs-literal">false</span>;  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>processWorkerExit()：<strong>线程退出线程池</strong>，也有担保机制，保证队列中的任务被执行</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// 正常退出 completedAbruptly = false，异常退出为 true  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processWorkerExit</span><span class="hljs-params">(Worker w, <span class="hljs-type">boolean</span> completedAbruptly)</span> &#123;  <br>    <span class="hljs-comment">// 条件成立代表当前 worker 是发生异常退出的，task 任务执行过程中向上抛出异常了  </span><br>    <span class="hljs-keyword">if</span> (completedAbruptly)   <br>        <span class="hljs-comment">// 从异常时到这里 ctl 一直没有 -1，需要在这里 -1  </span><br>        decrementWorkerCount();  <br>  <br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;  <br>    <span class="hljs-comment">// 加锁  </span><br>    mainLock.lock();  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-comment">// 将当前 worker 完成的 task 数量，汇总到线程池的 completedTaskCount  </span><br>        completedTaskCount += w.completedTasks;  <br><span class="hljs-comment">// 将 worker 从线程池中移除  </span><br>        workers.remove(w);  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        mainLock.unlock();<span class="hljs-comment">// 解锁  </span><br>    &#125;  <br><span class="hljs-comment">// 尝试停止线程池，唤醒下一个线程  </span><br>    tryTerminate();  <br>  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();  <br>    <span class="hljs-comment">// 线程池不是停止状态就应该有线程运行【担保机制】  </span><br>    <span class="hljs-keyword">if</span> (runStateLessThan(c, STOP)) &#123;  <br>        <span class="hljs-comment">// 正常退出的逻辑，是对空闲线程回收，不是执行出错  </span><br>        <span class="hljs-keyword">if</span> (!completedAbruptly) &#123;  <br>            <span class="hljs-comment">// 根据是否回收核心线程确定【线程池中的线程数量最小值】  </span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> allowCoreThreadTimeOut ? <span class="hljs-number">0</span> : corePoolSize;  <br>            <span class="hljs-comment">// 最小值为 0，但是线程队列不为空，需要一个线程来完成任务担保机制  </span><br>            <span class="hljs-keyword">if</span> (min == <span class="hljs-number">0</span> &amp;&amp; !workQueue.isEmpty())  <br>                min = <span class="hljs-number">1</span>;  <br>            <span class="hljs-comment">// 线程池中的线程数量大于最小值可以直接返回  </span><br>            <span class="hljs-keyword">if</span> (workerCountOf(c) &gt;= min)  <br>                <span class="hljs-keyword">return</span>;  <br>        &#125;  <br>        <span class="hljs-comment">// 执行 task 时发生异常，有个线程因为异常终止了，需要添加  </span><br>        <span class="hljs-comment">// 或者线程池中的数量小于最小值，这里要创建一个新 worker 加进线程池  </span><br>        addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h5 id="停止方法"><a href="#停止方法" class="headerlink" title="停止方法"></a>停止方法</h5><ul><li><p>shutdown()：停止线程池</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;  <br>    <span class="hljs-comment">// 获取线程池全局锁  </span><br>    mainLock.lock();  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        checkShutdownAccess();  <br>        <span class="hljs-comment">// 设置线程池状态为 SHUTDOWN，如果线程池状态大于 SHUTDOWN，就不会设置直接返回  </span><br>        advanceRunState(SHUTDOWN);  <br>        <span class="hljs-comment">// 中断空闲线程  </span><br>        interruptIdleWorkers();  <br>        <span class="hljs-comment">// 空方法，子类可以扩展  </span><br>        onShutdown();   <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        <span class="hljs-comment">// 释放线程池全局锁  </span><br>        mainLock.unlock();  <br>    &#125;  <br>    tryTerminate();  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>interruptIdleWorkers()：shutdown 方法会<strong>中断所有空闲线程</strong>，根据是否可以获取 AQS 独占锁判断是否处于工作状态。线程之所以空闲是因为阻塞队列没有任务，不会中断正在运行的线程，所以 shutdown 方法会让所有的任务执行完毕</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// onlyOne == true 说明只中断一个线程 ，false 则中断所有线程  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">interruptIdleWorkers</span><span class="hljs-params">(<span class="hljs-type">boolean</span> onlyOne)</span> &#123;  <br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;  <br>    / /持有全局锁  <br>    mainLock.lock();  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-comment">// 遍历所有 worker  </span><br>        <span class="hljs-keyword">for</span> (Worker w : workers) &#123;  <br>            <span class="hljs-comment">// 获取当前 worker 的线程  </span><br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> w.thread;  <br>            <span class="hljs-comment">// 条件一成立：说明当前迭代的这个线程尚未中断  </span><br>            <span class="hljs-comment">// 条件二成立：说明【当前worker处于空闲状态】，阻塞在poll或者take，因为worker执行task时是要加锁的  </span><br>            <span class="hljs-comment">//           每个worker有一个独占锁，w.tryLock()尝试加锁，加锁成功返回 true  </span><br>            <span class="hljs-keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;  <br>                <span class="hljs-keyword">try</span> &#123;  <br>                    <span class="hljs-comment">// 中断线程，处于 queue 阻塞的线程会被唤醒，进入下一次自旋，返回 null，执行退出相逻辑  </span><br>                    t.interrupt();  <br>                &#125; <span class="hljs-keyword">catch</span> (SecurityException ignore) &#123;  <br>                &#125; <span class="hljs-keyword">finally</span> &#123;  <br>                    <span class="hljs-comment">// 释放worker的独占锁  </span><br>                    w.unlock();  <br>                &#125;  <br>            &#125;  <br>            <span class="hljs-comment">// false，代表中断所有的线程  </span><br>            <span class="hljs-keyword">if</span> (onlyOne)  <br>                <span class="hljs-keyword">break</span>;  <br>        &#125;  <br>  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        <span class="hljs-comment">// 释放全局锁  </span><br>        mainLock.unlock();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>shutdownNow()：直接关闭线程池，不会等待任务执行完成</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> List&lt;Runnable&gt; <span class="hljs-title function_">shutdownNow</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">// 返回值引用  </span><br>    List&lt;Runnable&gt; tasks;  <br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;  <br>    <span class="hljs-comment">// 获取线程池全局锁  </span><br>    mainLock.lock();  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        checkShutdownAccess();  <br>        <span class="hljs-comment">// 设置线程池状态为STOP  </span><br>        advanceRunState(STOP);  <br>        <span class="hljs-comment">// 中断线程池中【所有线程】  </span><br>        interruptWorkers();  <br>        <span class="hljs-comment">// 从阻塞队列中导出未处理的task  </span><br>        tasks = drainQueue();  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        mainLock.unlock();  <br>    &#125;  <br>  <br>    tryTerminate();  <br>    <span class="hljs-comment">// 返回当前任务队列中 未处理的任务。  </span><br>    <span class="hljs-keyword">return</span> tasks;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>tryTerminate()：设置为 TERMINATED 状态 if either (SHUTDOWN and pool and queue empty) or (STOP and pool empty)</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tryTerminate</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">for</span> (;;) &#123;  <br>        <span class="hljs-comment">// 获取 ctl 的值  </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();  <br>        <span class="hljs-comment">// 线程池正常，或者有其他线程执行了状态转换的方法，当前线程直接返回  </span><br>        <span class="hljs-keyword">if</span> (isRunning(c) || runStateAtLeast(c, TIDYING) ||  <br>            <span class="hljs-comment">// 线程池是 SHUTDOWN 并且任务队列不是空，需要去处理队列中的任务  </span><br>            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))  <br>            <span class="hljs-keyword">return</span>;  <br>          <br>        <span class="hljs-comment">// 执行到这里说明线程池状态为 STOP 或者线程池状态为 SHUTDOWN 并且队列已经是空  </span><br>        <span class="hljs-comment">// 判断线程池中线程的数量  </span><br>        <span class="hljs-keyword">if</span> (workerCountOf(c) != <span class="hljs-number">0</span>) &#123;  <br>            <span class="hljs-comment">// 【中断一个空闲线程】，在 queue.take() | queue.poll() 阻塞空闲  </span><br>            <span class="hljs-comment">// 唤醒后的线程会在getTask()方法返回null，  </span><br>            <span class="hljs-comment">// 执行 processWorkerExit 退出逻辑时会再次调用 tryTerminate() 唤醒下一个空闲线程  </span><br>            interruptIdleWorkers(ONLY_ONE);  <br>            <span class="hljs-keyword">return</span>;  <br>        &#125;  <br><span class="hljs-comment">// 池中的线程数量为 0 来到这里  </span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;  <br>        <span class="hljs-comment">// 加全局锁  </span><br>        mainLock.lock();  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            <span class="hljs-comment">// 设置线程池状态为 TIDYING 状态，线程数量为 0  </span><br>            <span class="hljs-keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="hljs-number">0</span>))) &#123;  <br>                <span class="hljs-keyword">try</span> &#123;  <br>                    <span class="hljs-comment">// 结束线程池  </span><br>                    terminated();  <br>                &#125; <span class="hljs-keyword">finally</span> &#123;  <br>                    <span class="hljs-comment">// 设置线程池状态为TERMINATED状态。  </span><br>                    ctl.set(ctlOf(TERMINATED, <span class="hljs-number">0</span>));  <br>                    <span class="hljs-comment">// 【唤醒所有调用 awaitTermination() 方法的线程】  </span><br>                    termination.signalAll();  <br>                &#125;  <br>                <span class="hljs-keyword">return</span>;  <br>            &#125;  <br>        &#125; <span class="hljs-keyword">finally</span> &#123;  <br><span class="hljs-comment">// 释放线程池全局锁  </span><br>            mainLock.unlock();  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h4 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h4><h5 id="线程使用"><a href="#线程使用" class="headerlink" title="线程使用"></a>线程使用</h5><p>FutureTask 未来任务对象，继承 Runnable、Future 接口，用于包装 Callable 对象，实现任务的提交</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;  <br>    FutureTask&lt;String&gt; task = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Callable</span>&lt;String&gt;() &#123;  <br>        <span class="hljs-meta">@Override</span>  <br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;  <br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello World&quot;</span>;  <br>        &#125;  <br>    &#125;);  <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task).start();<span class="hljs-comment">//启动线程  </span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> task.get();<span class="hljs-comment">//获取返回任务数据  </span><br>    System.out.println(msg);  <br>&#125;<br></code></pre></td></tr></table></figure><p>构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">FutureTask</span><span class="hljs-params">(Callable&lt;V&gt; callable)</span>&#123;  <br><span class="hljs-built_in">this</span>.callable = callable;<span class="hljs-comment">// 属性注入  </span><br>    <span class="hljs-built_in">this</span>.state = NEW; <span class="hljs-comment">// 任务状态设置为 new  </span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">FutureTask</span><span class="hljs-params">(Runnable runnable, V result)</span> &#123;  <br>    <span class="hljs-comment">// 适配器模式  </span><br>    <span class="hljs-built_in">this</span>.callable = Executors.callable(runnable, result);  <br>    <span class="hljs-built_in">this</span>.state = NEW;         <br>&#125;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Callable&lt;T&gt; <span class="hljs-title function_">callable</span><span class="hljs-params">(Runnable task, T result)</span> &#123;  <br>    <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();  <br>    <span class="hljs-comment">// 使用装饰者模式将 runnable 转换成 callable 接口，外部线程通过 get 获取  </span><br>    <span class="hljs-comment">// 当前任务执行结果时，结果可能为 null 也可能为传进来的值，【传进来什么返回什么】  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RunnableAdapter</span>&lt;T&gt;(task, result);  <br>&#125;  <br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RunnableAdapter</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;T&gt; &#123;  <br>    <span class="hljs-keyword">final</span> Runnable task;  <br>    <span class="hljs-keyword">final</span> T result;  <br>    <span class="hljs-comment">// 构造方法  </span><br>    RunnableAdapter(Runnable task, T result) &#123;  <br>        <span class="hljs-built_in">this</span>.task = task;  <br>        <span class="hljs-built_in">this</span>.result = result;  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">call</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-comment">// 实则调用 Runnable#run 方法  </span><br>        task.run();  <br>        <span class="hljs-comment">// 返回值为构造 FutureTask 对象时传入的返回值或者是 null  </span><br>        <span class="hljs-keyword">return</span> result;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="成员属性-3"><a href="#成员属性-3" class="headerlink" title="成员属性"></a>成员属性</h5><p>FutureTask 类的成员属性：</p><ul><li><p>任务状态：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// 表示当前task状态  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> state;  <br><span class="hljs-comment">// 当前任务尚未执行  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NEW</span>          <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br><span class="hljs-comment">// 当前任务正在结束，尚未完全结束，一种临界状态  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">COMPLETING</span>   <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;  <br><span class="hljs-comment">// 当前任务正常结束  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NORMAL</span>       <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;  <br><span class="hljs-comment">// 当前任务执行过程中发生了异常，内部封装的 callable.run() 向上抛出异常了  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">EXCEPTIONAL</span>  <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;  <br><span class="hljs-comment">// 当前任务被取消  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CANCELLED</span>    <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;  <br><span class="hljs-comment">// 当前任务中断中  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INTERRUPTING</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;  <br><span class="hljs-comment">// 当前任务已中断  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INTERRUPTED</span>  <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;<br></code></pre></td></tr></table></figure></li><li><p>任务对象：</p><p>  <code>private Callable&lt;V&gt; callable;// Runnable 使用装饰者模式伪装成 Callable</code></p></li><li><p><strong>存储任务执行的结果</strong>，这是 run 方法返回值是 void 也可以获取到执行结果的原因：</p><p>  &#x2F;&#x2F; 正常情况下：任务正常执行结束，outcome 保存执行结果，callable 返回值<br>  &#x2F;&#x2F; 非正常情况：callable 向上抛出异常，outcome 保存异常<br>  <code>private Object outcome; </code></p></li><li><p>执行当前任务的线程对象：</p><p>  <code>private volatile Thread runner;// 当前任务被线程执行期间，保存当前执行任务的线程对象引用</code></p></li><li><p><strong>线程阻塞队列的头节点</strong>：</p><p>  &#x2F;&#x2F; 会有很多线程去 get 当前任务的结果，这里使用了一种数据结构头插头取（类似栈）的一个队列来保存所有的 get 线程<br>  <code>private volatile WaitNode waiters;</code></p></li><li><p>内部类：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WaitNode</span> &#123;  <br>    <span class="hljs-comment">// 单向链表  </span><br>    <span class="hljs-keyword">volatile</span> Thread thread;  <br>    <span class="hljs-keyword">volatile</span> WaitNode next;  <br>    WaitNode() &#123; thread = Thread.currentThread(); &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h5 id="成员方法-3"><a href="#成员方法-3" class="headerlink" title="成员方法"></a>成员方法</h5><p>FutureTask 类的成员方法：</p><ul><li><p><strong>FutureTask#run</strong>：任务执行入口</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">//条件一：成立说明当前 task 已经被执行过了或者被 cancel 了，非 NEW 状态的任务，线程就不需要处理了  </span><br>    <span class="hljs-comment">//条件二：线程是 NEW 状态，尝试设置当前任务对象的线程是当前线程，设置失败说明其他线程抢占了该任务，直接返回  </span><br>    <span class="hljs-keyword">if</span> (state != NEW ||  <br>        !UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, runnerOffset, <span class="hljs-literal">null</span>, Thread.currentThread()))  <br>        <span class="hljs-keyword">return</span>;  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-comment">// 执行到这里，当前 task 一定是 NEW 状态，而且【当前线程也抢占 task 成功】  </span><br>        Callable&lt;V&gt; c = callable;  <br>        <span class="hljs-comment">// 判断任务是否为空，防止空指针异常；判断 state 状态，防止外部线程在此期间 cancel 掉当前任务  </span><br>        <span class="hljs-comment">// 【因为 task 的执行者已经设置为当前线程，所以这里是线程安全的】  </span><br>        <span class="hljs-keyword">if</span> (c != <span class="hljs-literal">null</span> &amp;&amp; state == NEW) &#123;  <br>            V result;  <br>            <span class="hljs-comment">// true 表示 callable.run 代码块执行成功 未抛出异常  </span><br>            <span class="hljs-comment">// false 表示 callable.run 代码块执行失败 抛出异常  </span><br>            <span class="hljs-type">boolean</span> ran;  <br>            <span class="hljs-keyword">try</span> &#123;  <br><span class="hljs-comment">// 【调用自定义的方法，执行结果赋值给 result】  </span><br>                result = c.call();  <br>                <span class="hljs-comment">// 没有出现异常  </span><br>                ran = <span class="hljs-literal">true</span>;  <br>            &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;  <br>                <span class="hljs-comment">// 出现异常，返回值置空，ran 置为 false  </span><br>                result = <span class="hljs-literal">null</span>;  <br>                ran = <span class="hljs-literal">false</span>;  <br>                <span class="hljs-comment">// 设置返回的异常  </span><br>                setException(ex);  <br>            &#125;  <br>            <span class="hljs-comment">// 代码块执行正常  </span><br>            <span class="hljs-keyword">if</span> (ran)  <br>                <span class="hljs-comment">// 设置返回的结果  </span><br>                set(result);  <br>        &#125;  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        <span class="hljs-comment">// 任务执行完成，取消线程的引用，help GC  </span><br>        runner = <span class="hljs-literal">null</span>;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;  <br>        <span class="hljs-comment">// 判断任务是不是被中断  </span><br>        <span class="hljs-keyword">if</span> (s &gt;= INTERRUPTING)  <br>            <span class="hljs-comment">// 执行中断处理方法  </span><br>            handlePossibleCancellationInterrupt(s);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>  FutureTask#set：设置正常返回值，首先将任务状态设置为 COMPLETING 状态代表完成中，逻辑执行完设置为 NORMAL 状态代表任务正常执行完成，最后唤醒 get() 阻塞线程</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(V v)</span> &#123;  <br>    <span class="hljs-comment">// CAS 方式设置当前任务状态为完成中，设置失败说明其他线程取消了该任务  </span><br>    <span class="hljs-keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="hljs-built_in">this</span>, stateOffset, NEW, COMPLETING)) &#123;  <br>        <span class="hljs-comment">// 【将结果赋值给 outcome】  </span><br>        outcome = v;  <br>        <span class="hljs-comment">// 将当前任务状态修改为 NORMAL 正常结束状态。  </span><br>        UNSAFE.putOrderedInt(<span class="hljs-built_in">this</span>, stateOffset, NORMAL);  <br>        finishCompletion();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>  FutureTask#setException：设置异常返回值</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setException</span><span class="hljs-params">(Throwable t)</span> &#123;  <br>    <span class="hljs-keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="hljs-built_in">this</span>, stateOffset, NEW, COMPLETING)) &#123;  <br>        <span class="hljs-comment">// 赋值给返回结果，用来向上层抛出来的异常  </span><br>        outcome = t;  <br>        <span class="hljs-comment">// 将当前任务的状态 修改为 EXCEPTIONAL  </span><br>        UNSAFE.putOrderedInt(<span class="hljs-built_in">this</span>, stateOffset, EXCEPTIONAL);  <br>        finishCompletion();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>  FutureTask#finishCompletion：<strong>唤醒 get() 阻塞线程</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finishCompletion</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">// 遍历所有的等待的节点，q 指向头节点  </span><br>    <span class="hljs-keyword">for</span> (WaitNode q; (q = waiters) != <span class="hljs-literal">null</span>;) &#123;  <br>        <span class="hljs-comment">// 使用cas设置 waiters 为 null，防止外部线程使用cancel取消当前任务，触发finishCompletion方法重复执行  </span><br>        <span class="hljs-keyword">if</span> (UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, waitersOffset, q, <span class="hljs-literal">null</span>)) &#123;  <br>            <span class="hljs-comment">// 自旋  </span><br>            <span class="hljs-keyword">for</span> (;;) &#123;  <br>                <span class="hljs-comment">// 获取当前 WaitNode 节点封装的 thread  </span><br>                <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> q.thread;  <br>                <span class="hljs-comment">// 当前线程不为 null，唤醒当前 get() 等待获取数据的线程  </span><br>                <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>) &#123;  <br>                    q.thread = <span class="hljs-literal">null</span>;  <br>                    LockSupport.unpark(t);  <br>                &#125;  <br>                <span class="hljs-comment">// 获取当前节点的下一个节点  </span><br>                <span class="hljs-type">WaitNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> q.next;  <br>                <span class="hljs-comment">// 当前节点是最后一个节点了  </span><br>                <span class="hljs-keyword">if</span> (next == <span class="hljs-literal">null</span>)  <br>                    <span class="hljs-keyword">break</span>;  <br>                <span class="hljs-comment">// 断开链表  </span><br>                q.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help gc  </span><br>                q = next;  <br>            &#125;  <br>            <span class="hljs-keyword">break</span>;  <br>        &#125;  <br>    &#125;  <br>    done();  <br>    callable = <span class="hljs-literal">null</span>;<span class="hljs-comment">// help GC  </span><br>&#125;<br></code></pre></td></tr></table></figure><p>  FutureTask#handlePossibleCancellationInterrupt：任务中断处理</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handlePossibleCancellationInterrupt</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> &#123;  <br>    <span class="hljs-keyword">if</span> (s == INTERRUPTING)  <br>        <span class="hljs-comment">// 中断状态中  </span><br>        <span class="hljs-keyword">while</span> (state == INTERRUPTING)  <br>            <span class="hljs-comment">// 等待中断完成  </span><br>            Thread.yield();  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>FutureTask#get</strong>：获取任务执行的返回值，执行 run 和 get 的不是同一个线程，一般有多个线程 get，只有一个线程 run</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException &#123;  <br>    <span class="hljs-comment">// 获取当前任务状态  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;  <br>    <span class="hljs-comment">// 条件成立说明任务还没执行完成  </span><br>    <span class="hljs-keyword">if</span> (s &lt;= COMPLETING)  <br>        <span class="hljs-comment">// 返回 task 当前状态，可能当前线程在里面已经睡了一会  </span><br>        s = awaitDone(<span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);  <br>    <span class="hljs-keyword">return</span> report(s);  <br>&#125;<br></code></pre></td></tr></table></figure><p>  FutureTask#awaitDone：<strong>get 线程封装成 WaitNode 对象进入阻塞队列阻塞等待</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">awaitDone</span><span class="hljs-params">(<span class="hljs-type">boolean</span> timed, <span class="hljs-type">long</span> nanos)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>    <span class="hljs-comment">// 0 不带超时  </span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> timed ? System.nanoTime() + nanos : <span class="hljs-number">0L</span>;  <br>    <span class="hljs-comment">// 引用当前线程，封装成 WaitNode 对象  </span><br>    <span class="hljs-type">WaitNode</span> <span class="hljs-variable">q</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;  <br>    <span class="hljs-comment">// 表示当前线程 waitNode 对象，是否进入阻塞队列  </span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">queued</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;  <br>    <span class="hljs-comment">// 【三次自旋开始休眠】  </span><br>    <span class="hljs-keyword">for</span> (;;) &#123;  <br>        <span class="hljs-comment">// 判断当前 get() 线程是否被打断，打断返回 true，清除打断标记  </span><br>        <span class="hljs-keyword">if</span> (Thread.interrupted()) &#123;  <br>            <span class="hljs-comment">// 当前线程对应的等待 node 出队，  </span><br>            removeWaiter(q);  <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();  <br>        &#125;  <br><span class="hljs-comment">// 获取任务状态  </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;  <br>        <span class="hljs-comment">// 条件成立说明当前任务执行完成已经有结果了  </span><br>        <span class="hljs-keyword">if</span> (s &gt; COMPLETING) &#123;  <br>            <span class="hljs-comment">// 条件成立说明已经为当前线程创建了 WaitNode，置空 help GC  </span><br>            <span class="hljs-keyword">if</span> (q != <span class="hljs-literal">null</span>)  <br>                q.thread = <span class="hljs-literal">null</span>;  <br>            <span class="hljs-comment">// 返回当前的状态  </span><br>            <span class="hljs-keyword">return</span> s;  <br>        &#125;  <br>        <span class="hljs-comment">// 条件成立说明当前任务接近完成状态，这里让当前线程释放一下 cpu ，等待进行下一次抢占 cpu  </span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s == COMPLETING)   <br>            Thread.yield();  <br>        <span class="hljs-comment">// 【第一次自旋】，当前线程还未创建 WaitNode 对象，此时为当前线程创建 WaitNode对象  </span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (q == <span class="hljs-literal">null</span>)  <br>            q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WaitNode</span>();  <br>        <span class="hljs-comment">// 【第二次自旋】，当前线程已经创建 WaitNode 对象了，但是node对象还未入队  </span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!queued)  <br>            <span class="hljs-comment">// waiters 指向队首，让当前 WaitNode 成为新的队首，【头插法】，失败说明其他线程修改了新的队首  </span><br>            queued = UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, waitersOffset, q.next = waiters, q);  <br>        <span class="hljs-comment">// 【第三次自旋】，会到这里，或者 else 内  </span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (timed) &#123;  <br>            nanos = deadline - System.nanoTime();  <br>            <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0L</span>) &#123;  <br>                removeWaiter(q);  <br>                <span class="hljs-keyword">return</span> state;  <br>            &#125;  <br>            <span class="hljs-comment">// 阻塞指定的时间  </span><br>            LockSupport.parkNanos(<span class="hljs-built_in">this</span>, nanos);  <br>        &#125;  <br>        <span class="hljs-comment">// 条件成立：说明需要阻塞  </span><br>        <span class="hljs-keyword">else</span>  <br>            <span class="hljs-comment">// 【当前 get 操作的线程被 park 阻塞】，除非有其它线程将唤醒或者将当前线程中断  </span><br>            LockSupport.park(<span class="hljs-built_in">this</span>);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>  FutureTask#report：封装运行结果，可以获取 run() 方法中设置的成员变量 outcome，<strong>这是 run 方法的返回值是 void 也可以获取到任务执行的结果的原因</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> V <span class="hljs-title function_">report</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> <span class="hljs-keyword">throws</span> ExecutionException &#123;  <br>    <span class="hljs-comment">// 获取执行结果，是在一个 futuretask 对象中的属性，可以直接获取  </span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> outcome;  <br>    <span class="hljs-comment">// 当前任务状态正常结束  </span><br>    <span class="hljs-keyword">if</span> (s == NORMAL)  <br>        <span class="hljs-keyword">return</span> (V)x;<span class="hljs-comment">// 直接返回 callable 的逻辑结果  </span><br>    <span class="hljs-comment">// 当前任务被取消或者中断  </span><br>    <span class="hljs-keyword">if</span> (s &gt;= CANCELLED)  <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CancellationException</span>();<span class="hljs-comment">// 抛出异常  </span><br>    <span class="hljs-comment">// 执行到这里说明自定义的 callable 中的方法有异常，使用 outcome 上层抛出异常  </span><br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExecutionException</span>((Throwable)x);  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>FutureTask#cancel：任务取消，打断正在执行该任务的线程</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">cancel</span><span class="hljs-params">(<span class="hljs-type">boolean</span> mayInterruptIfRunning)</span> &#123;  <br>    <span class="hljs-comment">// 条件一：表示当前任务处于运行中或者处于线程池任务队列中  </span><br>    <span class="hljs-comment">// 条件二：表示修改状态，成功可以去执行下面逻辑，否则返回 false 表示 cancel 失败  </span><br>    <span class="hljs-keyword">if</span> (!(state == NEW &amp;&amp;  <br>          UNSAFE.compareAndSwapInt(<span class="hljs-built_in">this</span>, stateOffset, NEW,  <br>                                   mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-comment">// 如果任务已经被执行，是否允许打断  </span><br>        <span class="hljs-keyword">if</span> (mayInterruptIfRunning) &#123;  <br>            <span class="hljs-keyword">try</span> &#123;  <br>                <span class="hljs-comment">// 获取执行当前 FutureTask 的线程  </span><br>                <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> runner;  <br>                <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>)  <br>                    <span class="hljs-comment">// 打断执行的线程  </span><br>                    t.interrupt();  <br>            &#125; <span class="hljs-keyword">finally</span> &#123;  <br>                <span class="hljs-comment">// 设置任务状态为【中断完成】  </span><br>                UNSAFE.putOrderedInt(<span class="hljs-built_in">this</span>, stateOffset, INTERRUPTED);  <br>            &#125;  <br>        &#125;  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        <span class="hljs-comment">// 唤醒所有 get() 阻塞的线程  </span><br>        finishCompletion();  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h3><h4 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h4><p>Timer 实现定时功能，Timer 的优点在于简单易用，但由于所有任务都是由同一个线程来调度，因此所有任务都是串行执行的，同一时间只能有一个任务在执行，前一个任务的延迟或异常都将会影响到之后的任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-type">Timer</span> <span class="hljs-variable">timer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Timer</span>();  <br>    <span class="hljs-type">TimerTask</span> <span class="hljs-variable">task1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerTask</span>() &#123;  <br>        <span class="hljs-meta">@Override</span>  <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>            System.out.println(<span class="hljs-string">&quot;task 1&quot;</span>);  <br>            <span class="hljs-comment">//int i = 1 / 0;//任务一的出错会导致任务二无法执行  </span><br>            Thread.sleep(<span class="hljs-number">2000</span>);  <br>        &#125;  <br>    &#125;;  <br>    <span class="hljs-type">TimerTask</span> <span class="hljs-variable">task2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerTask</span>() &#123;  <br>        <span class="hljs-meta">@Override</span>  <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>            System.out.println(<span class="hljs-string">&quot;task 2&quot;</span>);  <br>        &#125;  <br>    &#125;;  <br>    <span class="hljs-comment">// 使用 timer 添加两个任务，希望它们都在 1s 后执行  </span><br><span class="hljs-comment">// 但由于 timer 内只有一个线程来顺序执行队列中的任务，因此任务1的延时，影响了任务2的执行  </span><br>    timer.schedule(task1, <span class="hljs-number">1000</span>);<span class="hljs-comment">//17:45:56 c.ThreadPool [Timer-0] - task 1  </span><br>    timer.schedule(task2, <span class="hljs-number">1000</span>);<span class="hljs-comment">//17:45:58 c.ThreadPool [Timer-0] - task 2  </span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="Scheduled"><a href="#Scheduled" class="headerlink" title="Scheduled"></a>Scheduled</h4><p>任务调度线程池 ScheduledThreadPoolExecutor 继承 ThreadPoolExecutor：</p><ul><li><p>使用内部类 ScheduledFutureTask 封装任务</p></li><li><p>使用内部类 DelayedWorkQueue 作为线程池队列</p></li><li><p>重写 onShutdown 方法去处理 shutdown 后的任务</p></li><li><p>提供 decorateTask 方法作为 ScheduledFutureTask 的修饰方法，以便开发者进行扩展</p></li></ul><p>构造方法：<code>Executors.newScheduledThreadPool(int corePoolSize)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize)</span> &#123;  <br>    <span class="hljs-comment">// 最大线程数固定为 Integer.MAX_VALUE，保活时间 keepAliveTime 固定为 0  </span><br>    <span class="hljs-built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="hljs-number">0</span>, NANOSECONDS,  <br>          <span class="hljs-comment">// 阻塞队列是 DelayedWorkQueue  </span><br>          <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayedWorkQueue</span>());  <br>&#125;<br><br></code></pre></td></tr></table></figure><p>常用 API：</p><ul><li><p><code>ScheduledFuture&lt;?&gt; schedule(Runnable/Callable&lt;V&gt;, long delay, TimeUnit u)</code>：延迟执行任务</p></li><li><p><code>ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable/Callable&lt;V&gt;, long initialDelay, long period, TimeUnit unit)</code>：定时执行周期任务，不考虑执行的耗时，参数为初始延迟时间、间隔时间、单位</p></li><li><p><code>ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable/Callable&lt;V&gt;, long initialDelay, long delay, TimeUnit unit)</code>：定时执行周期任务，考虑执行的耗时，参数为初始延迟时间、间隔时间、单位</p></li></ul><p>基本使用：</p><ul><li><p>延迟任务，但是出现异常并不会在控制台打印，也不会影响其他线程的执行</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;  <br>    <span class="hljs-comment">// 线程池大小为1时也是串行执行  </span><br>    <span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newScheduledThreadPool(<span class="hljs-number">2</span>);  <br>    <span class="hljs-comment">// 添加两个任务，都在 1s 后同时执行  </span><br>    executor.schedule(() -&gt; &#123;  <br>    System.out.println(<span class="hljs-string">&quot;任务1，执行时间：&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());  <br>        <span class="hljs-comment">//int i = 1 / 0;  </span><br>    <span class="hljs-keyword">try</span> &#123; Thread.sleep(<span class="hljs-number">2000</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; &#125;  <br>    &#125;, <span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS);  <br>      <br>    executor.schedule(() -&gt; &#123;  <br>    System.out.println(<span class="hljs-string">&quot;任务2，执行时间：&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());  <br>    &#125;, <span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS);  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>定时任务 scheduleAtFixedRate：<strong>一次任务的启动到下一次任务的启动</strong>之间只要大于等于间隔时间，抢占到 CPU 就会立即执行</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    <span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> Executors.newScheduledThreadPool(<span class="hljs-number">1</span>);  <br>    System.out.println(<span class="hljs-string">&quot;start...&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());  <br>      <br>    pool.scheduleAtFixedRate(() -&gt; &#123;  <br>        System.out.println(<span class="hljs-string">&quot;running...&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());  <br>        Thread.sleep(<span class="hljs-number">2000</span>);  <br>    &#125;, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);  <br>&#125;  <br>  <br><span class="hljs-comment">/*start...Sat Apr 24 18:08:12 CST 2021  </span><br><span class="hljs-comment">running...Sat Apr 24 18:08:13 CST 2021  </span><br><span class="hljs-comment">running...Sat Apr 24 18:08:15 CST 2021  </span><br><span class="hljs-comment">running...Sat Apr 24 18:08:17 CST 2021*/</span><br></code></pre></td></tr></table></figure></li><li><p>定时任务 scheduleWithFixedDelay：<strong>一次任务的结束到下一次任务的启动之间</strong>等于间隔时间，抢占到 CPU 就会立即执行，这个方法才是真正的设置两个任务之间的间隔</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;  <br>    <span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> Executors.newScheduledThreadPool(<span class="hljs-number">3</span>);  <br>    System.out.println(<span class="hljs-string">&quot;start...&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());  <br>      <br>    pool.scheduleWithFixedDelay(() -&gt; &#123;  <br>        System.out.println(<span class="hljs-string">&quot;running...&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());  <br>        Thread.sleep(<span class="hljs-number">2000</span>);  <br>    &#125;, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);  <br>&#125;  <br><span class="hljs-comment">/*start...Sat Apr 24 18:11:41 CST 2021  </span><br><span class="hljs-comment">running...Sat Apr 24 18:11:42 CST 2021  </span><br><span class="hljs-comment">running...Sat Apr 24 18:11:45 CST 2021  </span><br><span class="hljs-comment">running...Sat Apr 24 18:11:48 CST 2021*/</span><br></code></pre></td></tr></table></figure></li></ul><hr><h4 id="成员属性-4"><a href="#成员属性-4" class="headerlink" title="成员属性"></a>成员属性</h4><h5 id="成员变量-1"><a href="#成员变量-1" class="headerlink" title="成员变量"></a>成员变量</h5><ul><li><p>shutdown 后是否继续执行周期任务：</p><p>  <code>private volatile boolean continueExistingPeriodicTasksAfterShutdown;</code></p></li><li><p>shutdown 后是否继续执行延迟任务：</p><p>  <code>private volatile boolean executeExistingDelayedTasksAfterShutdown = true;</code></p></li><li><p>取消方法是否将该任务从队列中移除：</p><p>  &#x2F;&#x2F; 默认 false，不移除，等到线程拿到任务之后抛弃<br>  <code>private volatile boolean removeOnCancel = false;</code></p></li><li><p>任务的序列号，可以用来比较优先级：</p><p>  <code>private static final AtomicLong sequencer = new AtomicLong();</code></p></li></ul><hr><h5 id="延迟任务"><a href="#延迟任务" class="headerlink" title="延迟任务"></a>延迟任务</h5><p>ScheduledFutureTask 继承 FutureTask，实现 RunnableScheduledFuture 接口，具有延迟执行的特点，覆盖 FutureTask 的 run 方法来实现对<strong>延时执行、周期执行</strong>的支持。对于延时任务调用 FutureTask#run，而对于周期性任务则调用 FutureTask#runAndReset 并且在成功之后根据 fixed-delay&#x2F;fixed-rate 模式来设置下次执行时间并重新将任务塞到工作队列</p><p>在调度线程池中无论是 runnable 还是 callable，无论是否需要延迟和定时，所有的任务都会被封装成 ScheduledFutureTask</p><p>成员变量：</p><ul><li><p>任务序列号：</p><p>  <code>private final long sequenceNumber;</code></p></li><li><p>执行时间：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">long</span> time;<span class="hljs-comment">// 任务可以被执行的时间，交付时间，以纳秒表示  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> period;<span class="hljs-comment">// 0 表示非周期任务，正数表示 fixed-rate 模式的周期，负数表示 fixed-delay 模式</span><br><br>fixed-rate：两次开始启动的间隔，fixed-delay：一次执行结束到下一次开始启动<br></code></pre></td></tr></table></figure></li><li><p>实际的任务对象：</p><p>  <code>RunnableScheduledFuture&lt;V&gt; outerTask = this;</code></p></li><li><p>任务在队列数组中的索引下标：</p><p>  &#x2F;&#x2F; DelayedWorkQueue 底层使用的数据结构是最小堆，记录当前任务在堆中的索引，-1 代表删除<br>  <code>int heapIndex;</code></p></li></ul><p>成员方法：</p><ul><li><p>构造方法：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">ScheduledFutureTask(Runnable r, V result, <span class="hljs-type">long</span> ns, <span class="hljs-type">long</span> period) &#123;  <br>    <span class="hljs-built_in">super</span>(r, result);  <br>    <span class="hljs-comment">// 任务的触发时间  </span><br>    <span class="hljs-built_in">this</span>.time = ns;  <br>    <span class="hljs-comment">// 任务的周期，多长时间执行一次  </span><br>    <span class="hljs-built_in">this</span>.period = period;  <br>    <span class="hljs-comment">// 任务的序号  </span><br>    <span class="hljs-built_in">this</span>.sequenceNumber = sequencer.getAndIncrement();  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>compareTo()：ScheduledFutureTask 根据执行时间 time 正序排列，如果执行时间相同，在按照序列号 sequenceNumber 正序排列，任务需要放入 DelayedWorkQueue，延迟队列中使用该方法按照从小到大进行排序</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Delayed other)</span> &#123;  <br>    <span class="hljs-keyword">if</span> (other == <span class="hljs-built_in">this</span>) <span class="hljs-comment">// compare zero if same object  </span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">if</span> (other <span class="hljs-keyword">instanceof</span> ScheduledFutureTask) &#123;  <br>        <span class="hljs-comment">// 类型强转  </span><br>        ScheduledFutureTask&lt;?&gt; x = (ScheduledFutureTask&lt;?&gt;)other;  <br>        <span class="hljs-comment">// 比较者 - 被比较者的执行时间  </span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">diff</span> <span class="hljs-operator">=</span> time - x.time;  <br>        <span class="hljs-comment">// 比较者先执行  </span><br>        <span class="hljs-keyword">if</span> (diff &lt; <span class="hljs-number">0</span>)  <br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;  <br>        <span class="hljs-comment">// 被比较者先执行  </span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (diff &gt; <span class="hljs-number">0</span>)  <br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <br>        <span class="hljs-comment">// 比较者的序列号小  </span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sequenceNumber &lt; x.sequenceNumber)  <br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;  <br>        <span class="hljs-keyword">else</span>  <br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <br>    &#125;  <br>    <span class="hljs-comment">// 不是 ScheduledFutureTask 类型时，根据延迟时间排序  </span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">diff</span> <span class="hljs-operator">=</span> getDelay(NANOSECONDS) - other.getDelay(NANOSECONDS);  <br>    <span class="hljs-keyword">return</span> (diff &lt; <span class="hljs-number">0</span>) ? -<span class="hljs-number">1</span> : (diff &gt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>run()：执行任务，非周期任务直接完成直接结束，<strong>周期任务执行完后会设置下一次的执行时间，重新放入线程池的阻塞队列</strong>，如果线程池中的线程数量少于核心线程，就会添加 Worker 开启新线程</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">// 是否周期性，就是判断 period 是否为 0  </span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">periodic</span> <span class="hljs-operator">=</span> isPeriodic();  <br>    <span class="hljs-comment">// 根据是否是周期任务检查当前状态能否执行任务，不能执行就取消任务  </span><br>    <span class="hljs-keyword">if</span> (!canRunInCurrentRunState(periodic))  <br>        cancel(<span class="hljs-literal">false</span>);  <br>    <span class="hljs-comment">// 非周期任务，直接调用 FutureTask#run 执行  </span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!periodic)  <br>        ScheduledFutureTask.<span class="hljs-built_in">super</span>.run();  <br>    <span class="hljs-comment">// 周期任务的执行，返回 true 表示执行成功  </span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ScheduledFutureTask.<span class="hljs-built_in">super</span>.runAndReset()) &#123;  <br>        <span class="hljs-comment">// 设置周期任务的下一次执行时间  </span><br>        setNextRunTime();  <br>        <span class="hljs-comment">// 任务的下一次执行安排，如果当前线程池状态可以执行周期任务，加入队列，并开启新线程  </span><br>        reExecutePeriodic(outerTask);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>  周期任务正常完成后<strong>任务的状态不会变化</strong>，依旧是 NEW，不会设置 outcome 属性。但是如果本次任务执行出现异常，会进入 setException 方法将任务状态置为异常，把异常保存在 outcome 中，方法返回 false，后续的该任务将不会再周期的执行</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">runAndReset</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">// 任务不是新建的状态了，或者被别的线程执行了，直接返回 false  </span><br>    <span class="hljs-keyword">if</span> (state != NEW ||  <br>        !UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, runnerOffset, <span class="hljs-literal">null</span>, Thread.currentThread()))  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">ran</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        Callable&lt;V&gt; c = callable;  <br>        <span class="hljs-keyword">if</span> (c != <span class="hljs-literal">null</span> &amp;&amp; s == NEW) &#123;  <br>            <span class="hljs-keyword">try</span> &#123;  <br>                <span class="hljs-comment">// 执行方法，没有返回值  </span><br>                c.call();  <br>                ran = <span class="hljs-literal">true</span>;  <br>            &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;  <br>                <span class="hljs-comment">// 出现异常，把任务设置为异常状态，唤醒所有的 get 阻塞线程  </span><br>                setException(ex);  <br>            &#125;  <br>        &#125;  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br><span class="hljs-comment">// 执行完成把执行线程引用置为 null  </span><br>        runner = <span class="hljs-literal">null</span>;  <br>        s = state;  <br>        <span class="hljs-comment">// 如果线程被中断进行中断处理  </span><br>        <span class="hljs-keyword">if</span> (s &gt;= INTERRUPTING)  <br>            handlePossibleCancellationInterrupt(s);  <br>    &#125;  <br>    <span class="hljs-comment">// 如果正常执行，返回 true，并且任务状态没有被取消  </span><br>    <span class="hljs-keyword">return</span> ran &amp;&amp; s == NEW;  <br>&#125;<br><br><span class="hljs-comment">// 任务下一次的触发时间  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNextRunTime</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-type">long</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> period;  <br>    <span class="hljs-keyword">if</span> (p &gt; <span class="hljs-number">0</span>)  <br>        <span class="hljs-comment">// fixed-rate 模式，【时间设置为上一次执行任务的时间 + p】，两次任务执行的时间差  </span><br>        time += p;  <br>    <span class="hljs-keyword">else</span>  <br>        <span class="hljs-comment">// fixed-delay 模式，下一次执行时间是【当前这次任务结束的时间（就是现在） + delay 值】  </span><br>        time = triggerTime(-p);  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>reExecutePeriodic()<strong>：准备任务的下一次执行，重新放入阻塞任务队列</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// ScheduledThreadPoolExecutor#reExecutePeriodic  </span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">reExecutePeriodic</span><span class="hljs-params">(RunnableScheduledFuture&lt;?&gt; task)</span> &#123;  <br>    <span class="hljs-keyword">if</span> (canRunInCurrentRunState(<span class="hljs-literal">true</span>)) &#123;  <br>        <span class="hljs-comment">// 【放入任务队列】  </span><br>        <span class="hljs-built_in">super</span>.getQueue().add(task);  <br>        <span class="hljs-comment">// 如果提交完任务之后，线程池状态变为了 shutdown 状态，需要再次检查是否可以执行，  </span><br>        <span class="hljs-comment">// 如果不能执行且任务还在队列中未被取走，则取消任务  </span><br>        <span class="hljs-keyword">if</span> (!canRunInCurrentRunState(<span class="hljs-literal">true</span>) &amp;&amp; remove(task))  <br>            task.cancel(<span class="hljs-literal">false</span>);  <br>        <span class="hljs-keyword">else</span>  <br>            <span class="hljs-comment">// 当前线程池状态可以执行周期任务，加入队列，并【根据线程数量是否大于核心线程数确定是否开启新线程】  </span><br>            ensurePrestart();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>cancel()：取消任务</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">cancel</span><span class="hljs-params">(<span class="hljs-type">boolean</span> mayInterruptIfRunning)</span> &#123;  <br>    <span class="hljs-comment">// 调用父类 FutureTask#cancel 来取消任务  </span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">cancelled</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">super</span>.cancel(mayInterruptIfRunning);  <br>    <span class="hljs-comment">// removeOnCancel 用于控制任务取消后是否应该从阻塞队列中移除  </span><br>    <span class="hljs-keyword">if</span> (cancelled &amp;&amp; removeOnCancel &amp;&amp; heapIndex &gt;= <span class="hljs-number">0</span>)  <br>        <span class="hljs-comment">// 从等待队列中删除该任务，并调用 tryTerminate() 判断是否需要停止线程池  </span><br>        remove(<span class="hljs-built_in">this</span>);  <br>    <span class="hljs-keyword">return</span> cancelled;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h5 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h5><p>DelayedWorkQueue 是支持延时获取元素的阻塞队列，内部采用优先队列 PriorityQueue（小根堆、满二叉树）存储元素</p><p>其他阻塞队列存储节点的数据结构大都是链表，<strong>延迟队列是数组</strong>，所以延迟队列出队头元素后需要<strong>让其他元素（尾）替换到头节点</strong>，防止空指针异常</p><p>成员变量：</p><ul><li><p>容量：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;<span class="hljs-comment">// 初始容量  </span><br>   <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">// 节点数量  </span><br>   <br>   <span class="hljs-keyword">private</span> RunnableScheduledFuture&lt;?&gt;[] queue =   <br>       <span class="hljs-keyword">new</span> <span class="hljs-title class_">RunnableScheduledFuture</span>&lt;?&gt;[INITIAL_CAPACITY];<span class="hljs-comment">// 存放节点</span><br></code></pre></td></tr></table></figure></li><li><p>锁：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<span class="hljs-comment">// 控制并发  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">available</span> <span class="hljs-operator">=</span> lock.newCondition();<span class="hljs-comment">// 条件队列</span><br></code></pre></td></tr></table></figure></li><li><p>阻塞等待头节点的线程：线程池内的某个线程去 take() 获取任务时，如果延迟队列顶层节点不为 null（队列内有任务），但是节点任务还不到触发时间，线程就去检查<strong>队列的 leader字段</strong>是否被占用</p><ul><li><p>如果未被占用，则当前线程占用该字段，然后当前线程到 available 条件队列指定超时时间 <code>堆顶任务.time - now()</code> 挂起</p></li><li><p>如果被占用，当前线程直接到 available 条件队列不指定超时时间的挂起</p></li></ul><p>  &#x2F;&#x2F; leader 在 available 条件队列内是首元素，它超时之后会醒过来，然后再次将堆顶元素获取走，获取走之后，take()结束之前，会调用是 available.signal() 唤醒下一个条件队列内的等待者，然后释放 lock，下一个等待者被唤醒后去到 AQS 队列，做 acquireQueue(node) 逻辑<br>  <code>private Thread leader = null;</code></p></li></ul><p>成员方法</p><ul><li><p>offer()：插入节点</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(Runnable x)</span> &#123;  <br>    <span class="hljs-comment">// 判空  </span><br>    <span class="hljs-keyword">if</span> (x == <span class="hljs-literal">null</span>)  <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();  <br>    RunnableScheduledFuture&lt;?&gt; e = (RunnableScheduledFuture&lt;?&gt;)x;  <br>    <span class="hljs-comment">// 队列锁，增加删除数据时都要加锁  </span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;  <br>    lock.lock();  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> size;  <br>        <span class="hljs-comment">// 队列数量大于存放节点的数组长度，需要扩容  </span><br>        <span class="hljs-keyword">if</span> (i &gt;= queue.length)  <br>            <span class="hljs-comment">// 扩容为原来长度的 1.5 倍  </span><br>            grow();  <br>        size = i + <span class="hljs-number">1</span>;  <br>        <span class="hljs-comment">// 当前是第一个要插入的节点  </span><br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;  <br>            queue[<span class="hljs-number">0</span>] = e;  <br>            <span class="hljs-comment">// 修改 ScheduledFutureTask 的 heapIndex 属性，表示该对象在队列里的下标  </span><br>            setIndex(e, <span class="hljs-number">0</span>);  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            <span class="hljs-comment">// 向上调整元素的位置，并更新 heapIndex   </span><br>            siftUp(i, e);  <br>        &#125;  <br>        <span class="hljs-comment">// 情况1：当前任务是第一个加入到 queue 内的任务，所以在当前任务加入到 queue 之前，take() 线程会直接  </span><br>        <span class="hljs-comment">//到 available 队列不设置超时的挂起，并不会去占用 leader 字段，这时需会唤醒一个线程 让它去消费  </span><br>       <span class="hljs-comment">// 情况2：当前任务【优先级最高】，原堆顶任务可能还未到触发时间，leader 线程设置超时的在 available 挂起  </span><br>        <span class="hljs-comment">//原先的 leader 等待的是原先的头节点，所以 leader 已经无效，需要将 leader 线程唤醒，  </span><br>        <span class="hljs-comment">//唤醒之后它会检查堆顶，如果堆顶任务可以被消费，则直接获取走，否则继续成为 leader 等待新堆顶任务  </span><br>        <span class="hljs-keyword">if</span> (queue[<span class="hljs-number">0</span>] == e) &#123;  <br>            <span class="hljs-comment">// 将 leader 设置为 null  </span><br>            leader = <span class="hljs-literal">null</span>;  <br>            <span class="hljs-comment">// 直接随便唤醒等待头结点的阻塞线程  </span><br>            available.signal();  <br>        &#125;  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        lock.unlock();  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>  &#x2F;&#x2F; 插入新节点后对堆进行调整，进行节点上移，保持其特性【节点的值小于子节点的值】，小顶堆  </p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">siftUp</span><span class="hljs-params">(<span class="hljs-type">int</span> k, RunnableScheduledFuture&lt;?&gt; key)</span> &#123;  <br>    <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">0</span>) &#123;  <br>        <span class="hljs-comment">// 父节点，就是堆排序  </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> (k - <span class="hljs-number">1</span>) &gt;&gt;&gt; <span class="hljs-number">1</span>;  <br>        RunnableScheduledFuture&lt;?&gt; e = queue[parent];  <br>        <span class="hljs-comment">// key 和父节点比，如果大于父节点可以直接返回，否则就继续上浮  </span><br>        <span class="hljs-keyword">if</span> (key.compareTo(e) &gt;= <span class="hljs-number">0</span>)  <br>            <span class="hljs-keyword">break</span>;  <br>        queue[k] = e;  <br>        setIndex(e, k);  <br>        k = parent;  <br>    &#125;  <br>    queue[k] = key;  <br>    setIndex(key, k);  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>poll()：非阻塞获取头结点，<strong>获取执行时间最近并且可以执行的</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// 非阻塞获取  </span><br><span class="hljs-keyword">public</span> RunnableScheduledFuture&lt;?&gt; poll() &#123;  <br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;  <br>    lock.lock();  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-comment">// 获取队头节点，因为是小顶堆  </span><br>        RunnableScheduledFuture&lt;?&gt; first = queue[<span class="hljs-number">0</span>];  <br>        <span class="hljs-comment">// 头结点为空或者的延迟时间没到返回 null  </span><br>        <span class="hljs-keyword">if</span> (first == <span class="hljs-literal">null</span> || first.getDelay(NANOSECONDS) &gt; <span class="hljs-number">0</span>)  <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>        <span class="hljs-keyword">else</span>  <br>            <span class="hljs-comment">// 头结点达到延迟时间，【尾节点成为替代节点下移调整堆结构】，返回头结点  </span><br>            <span class="hljs-keyword">return</span> finishPoll(first);  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        lock.unlock();  <br>    &#125;  <br>&#125;<br><br><span class="hljs-keyword">private</span> RunnableScheduledFuture&lt;?&gt; finishPoll(RunnableScheduledFuture&lt;?&gt; f) &#123;  <br>    <span class="hljs-comment">// 获取尾索引  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> --size;  <br>    <span class="hljs-comment">// 获取尾节点  </span><br>    RunnableScheduledFuture&lt;?&gt; x = queue[s];  <br>    <span class="hljs-comment">// 将堆结构最后一个节点占用的 slot 设置为 null，因为该节点要尝试升级成堆顶，会根据特性下调  </span><br>    queue[s] = <span class="hljs-literal">null</span>;  <br>    <span class="hljs-comment">// s == 0 说明 当前堆结构只有堆顶一个节点，此时不需要做任何的事情  </span><br>    <span class="hljs-keyword">if</span> (s != <span class="hljs-number">0</span>)  <br>        <span class="hljs-comment">// 从索引处 0 开始向下调整  </span><br>        siftDown(<span class="hljs-number">0</span>, x);  <br>    <span class="hljs-comment">// 出队的元素索引设置为 -1  </span><br>    setIndex(f, -<span class="hljs-number">1</span>);  <br>    <span class="hljs-keyword">return</span> f;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>take()：阻塞获取头节点，读取当前堆中最小的也就是触发时间最近的任务</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> RunnableScheduledFuture&lt;?&gt; take() <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;  <br>    <span class="hljs-comment">// 保证线程安全  </span><br>    lock.lockInterruptibly();  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-keyword">for</span> (;;) &#123;  <br>            <span class="hljs-comment">// 头节点  </span><br>            RunnableScheduledFuture&lt;?&gt; first = queue[<span class="hljs-number">0</span>];  <br>            <span class="hljs-keyword">if</span> (first == <span class="hljs-literal">null</span>)  <br>                <span class="hljs-comment">// 等待队列不空，直至有任务通过 offer 入队并唤醒  </span><br>                available.await();  <br>            <span class="hljs-keyword">else</span> &#123;  <br>                <span class="hljs-comment">// 获取头节点的延迟时间是否到时  </span><br>                <span class="hljs-type">long</span> <span class="hljs-variable">delay</span> <span class="hljs-operator">=</span> first.getDelay(NANOSECONDS);  <br>                <span class="hljs-keyword">if</span> (delay &lt;= <span class="hljs-number">0</span>)  <br>                    <span class="hljs-comment">// 到达触发时间，获取头节点并调整堆，重新选择延迟时间最小的节点放入头部  </span><br>                    <span class="hljs-keyword">return</span> finishPoll(first);  <br>                  <br>                <span class="hljs-comment">// 逻辑到这说明头节点的延迟时间还没到  </span><br>                first = <span class="hljs-literal">null</span>;  <br>                <span class="hljs-comment">// 说明有 leader 线程在等待获取头节点，当前线程直接去阻塞等待  </span><br>                <span class="hljs-keyword">if</span> (leader != <span class="hljs-literal">null</span>)  <br>                    available.await();  <br>                <span class="hljs-keyword">else</span> &#123;  <br>                    <span class="hljs-comment">// 没有 leader 线程，【当前线程作为leader线程，并设置头结点的延迟时间作为阻塞时间】  </span><br>                    <span class="hljs-type">Thread</span> <span class="hljs-variable">thisThread</span> <span class="hljs-operator">=</span> Thread.currentThread();  <br>                    leader = thisThread;  <br>                    <span class="hljs-keyword">try</span> &#123;  <br>                        <span class="hljs-comment">// 在条件队列 available 使用带超时的挂起（堆顶任务.time - now() 纳秒值..）  </span><br>                        available.awaitNanos(delay);  <br>                        <span class="hljs-comment">// 到达阻塞时间时，当前线程会从这里醒来来  </span><br>                    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>                        <span class="hljs-comment">// t堆顶更新，leader 置为 null，offer 方法释放锁后，  </span><br>                        <span class="hljs-comment">// 有其它线程通过 take/poll 拿到锁,读到 leader == null，然后将自身更新为leader。  </span><br>                        <span class="hljs-keyword">if</span> (leader == thisThread)  <br>                            <span class="hljs-comment">// leader 置为 null 用以接下来判断是否需要唤醒后继线程  </span><br>                            leader = <span class="hljs-literal">null</span>;  <br>                    &#125;  <br>                &#125;  <br>            &#125;  <br>        &#125;  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        <span class="hljs-comment">// 没有 leader 线程，头结点不为 null，唤醒阻塞获取头节点的线程，  </span><br>        <span class="hljs-comment">// 【如果没有这一步，就会出现有了需要执行的任务，但是没有线程去执行】  </span><br>        <span class="hljs-keyword">if</span> (leader == <span class="hljs-literal">null</span> &amp;&amp; queue[<span class="hljs-number">0</span>] != <span class="hljs-literal">null</span>)  <br>            available.signal();  <br>        lock.unlock();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>remove()：删除节点，堆移除一个元素的时间复杂度是 O(log n)，<strong>延迟任务维护了 heapIndex</strong>，直接访问的时间复杂度是 O(1)，从而可以更快的移除元素，任务在队列中被取消后会进入该逻辑</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object x)</span> &#123;  <br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;  <br>    lock.lock();  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-comment">// 查找对象在队列数组中的下标  </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> indexOf(x);  <br>        <span class="hljs-comment">// 节点不存在，返回 false  </span><br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>)  <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br><span class="hljs-comment">// 修改元素的 heapIndex，-1 代表删除  </span><br>        setIndex(queue[i], -<span class="hljs-number">1</span>);  <br>        <span class="hljs-comment">// 尾索引是长度-1  </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> --size;  <br>        <span class="hljs-comment">// 尾节点作为替代节点  </span><br>        RunnableScheduledFuture&lt;?&gt; replacement = queue[s];  <br>        queue[s] = <span class="hljs-literal">null</span>;  <br>        <span class="hljs-comment">// s == i 说明头节点就是尾节点，队列空了  </span><br>        <span class="hljs-keyword">if</span> (s != i) &#123;  <br>            <span class="hljs-comment">// 向下调整  </span><br>            siftDown(i, replacement);  <br>            <span class="hljs-comment">// 说明没发生调整  </span><br>            <span class="hljs-keyword">if</span> (queue[i] == replacement)  <br>                <span class="hljs-comment">// 上移和下移不可能同时发生，替代节点大于子节点时下移，否则上移  </span><br>                siftUp(i, replacement);  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        lock.unlock();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h4 id="成员方法-4"><a href="#成员方法-4" class="headerlink" title="成员方法"></a>成员方法</h4><h5 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a>提交任务</h5><ul><li><p>schedule()：延迟执行方法，并指定执行的时间，默认是当前时间</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> &#123;  <br>    <span class="hljs-comment">// 以零延时任务的形式实现  </span><br>    schedule(command, <span class="hljs-number">0</span>, NANOSECONDS);  <br>&#125;<br><br><span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command, <span class="hljs-type">long</span> delay, TimeUnit unit) &#123;  <br>    <span class="hljs-comment">// 判空  </span><br>    <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span> || unit == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();  <br>    <span class="hljs-comment">// 没有做任何操作，直接将 task 返回，该方法主要目的是用于子类扩展，并且【根据延迟时间设置任务触发的时间点】  </span><br>    RunnableScheduledFuture&lt;?&gt; t = decorateTask(command, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledFutureTask</span>&lt;Void&gt;(  <br>        command, <span class="hljs-literal">null</span>, triggerTime(delay, unit)));  <br>    <span class="hljs-comment">// 延迟执行  </span><br>    delayedExecute(t);  <br>    <span class="hljs-keyword">return</span> t;  <br>&#125;<br><br><span class="hljs-comment">// 返回【当前时间 + 延迟时间】，就是触发当前任务执行的时间  </span><br><span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-title function_">triggerTime</span><span class="hljs-params">(<span class="hljs-type">long</span> delay, TimeUnit unit)</span> &#123;  <br>    <span class="hljs-comment">// 设置触发的时间  </span><br>    <span class="hljs-keyword">return</span> triggerTime(unit.toNanos((delay &lt; <span class="hljs-number">0</span>) ? <span class="hljs-number">0</span> : delay));  <br>&#125;  <br><span class="hljs-type">long</span> <span class="hljs-title function_">triggerTime</span><span class="hljs-params">(<span class="hljs-type">long</span> delay)</span> &#123;  <br>    <span class="hljs-comment">// 如果 delay &lt; Long.Max_VALUE/2，则下次执行时间为当前时间 +delay  </span><br>    <span class="hljs-comment">// 否则为了避免队列中出现由于溢出导致的排序紊乱,需要调用overflowFree来修正一下delay  </span><br>    <span class="hljs-keyword">return</span> now() + ((delay &lt; (Long.MAX_VALUE &gt;&gt; <span class="hljs-number">1</span>)) ? delay : overflowFree(delay));  <br>&#125;<br></code></pre></td></tr></table></figure><p>  overflowFree 的原因：如果某个任务的 delay 为负数，说明当前可以执行（其实早该执行了）。阻塞队列中维护任务顺序是基于 compareTo 比较的，比较两个任务的顺序会用 time 相减。那么可能出现一个 delay 为正数减去另一个为负数的 delay，结果上溢为负数，则会导致 compareTo 产生错误的结果</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-title function_">overflowFree</span><span class="hljs-params">(<span class="hljs-type">long</span> delay)</span> &#123;  <br>    <span class="hljs-type">Delayed</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> (Delayed) <span class="hljs-built_in">super</span>.getQueue().peek();  <br>    <span class="hljs-keyword">if</span> (head != <span class="hljs-literal">null</span>) &#123;  <br>        <span class="hljs-type">long</span> <span class="hljs-variable">headDelay</span> <span class="hljs-operator">=</span> head.getDelay(NANOSECONDS);  <br>        <span class="hljs-comment">// 判断一下队首的delay是不是负数，如果是正数就不用管，怎么减都不会溢出  </span><br>        <span class="hljs-comment">// 否则拿当前 delay 减去队首的 delay 来比较看，如果不出现上溢，排序不会乱  </span><br><span class="hljs-comment">// 不然就把当前 delay 值给调整为 Long.MAX_VALUE + 队首 delay  </span><br>        <span class="hljs-keyword">if</span> (headDelay &lt; <span class="hljs-number">0</span> &amp;&amp; (delay - headDelay &lt; <span class="hljs-number">0</span>))  <br>            delay = Long.MAX_VALUE + headDelay;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> delay;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>scheduleAtFixedRate()：定时执行，一次任务的启动到下一次任务的启动的间隔</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, <span class="hljs-type">long</span> initialDelay, <span class="hljs-type">long</span> period,  <br>                                              TimeUnit unit) &#123;  <br>    <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span> || unit == <span class="hljs-literal">null</span>)  <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();  <br>    <span class="hljs-keyword">if</span> (period &lt;= <span class="hljs-number">0</span>)  <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();  <br>    <span class="hljs-comment">// 任务封装，【指定初始的延迟时间和周期时间】  </span><br>    ScheduledFutureTask&lt;Void&gt; sft =<span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledFutureTask</span>&lt;Void&gt;(command, <span class="hljs-literal">null</span>,  <br>                                      triggerTime(initialDelay, unit), unit.toNanos(period));  <br>    <span class="hljs-comment">// 默认返回本身  </span><br>    RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command, sft);  <br>    sft.outerTask = t;  <br>    <span class="hljs-comment">// 开始执行这个任务  </span><br>    delayedExecute(t);  <br>    <span class="hljs-keyword">return</span> t;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>scheduleWithFixedDelay()：定时执行，一次任务的结束到下一次任务的启动的间隔</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, <span class="hljs-type">long</span> initialDelay, <span class="hljs-type">long</span> delay,  <br>                                                 TimeUnit unit) &#123;  <br>    <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span> || unit == <span class="hljs-literal">null</span>)   <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();  <br>    <span class="hljs-keyword">if</span> (delay &lt;= <span class="hljs-number">0</span>)  <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();  <br>    <span class="hljs-comment">// 任务封装，【指定初始的延迟时间和周期时间】，周期时间为 - 表示是 fixed-delay 模式  </span><br>    ScheduledFutureTask&lt;Void&gt; sft = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledFutureTask</span>&lt;Void&gt;(command, <span class="hljs-literal">null</span>,  <br>                                      triggerTime(initialDelay, unit), unit.toNanos(-delay));  <br>    RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command, sft);  <br>    sft.outerTask = t;  <br>    delayedExecute(t);  <br>    <span class="hljs-keyword">return</span> t;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h5 id="运行任务"><a href="#运行任务" class="headerlink" title="运行任务"></a>运行任务</h5><ul><li><p>delayedExecute()：<strong>校验线程池状态</strong>，延迟或周期性任务的主要执行方法</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delayedExecute</span><span class="hljs-params">(RunnableScheduledFuture&lt;?&gt; task)</span> &#123;  <br>    <span class="hljs-comment">// 线程池是 SHUTDOWN 状态，需要执行拒绝策略  </span><br>    <span class="hljs-keyword">if</span> (isShutdown())  <br>        reject(task);  <br>    <span class="hljs-keyword">else</span> &#123;  <br>        <span class="hljs-comment">// 把当前任务放入阻塞队列，因为需要【获取执行时间最近的】，当前任务需要比较  </span><br>        <span class="hljs-built_in">super</span>.getQueue().add(task);  <br>        <span class="hljs-comment">// 线程池状态为 SHUTDOWN 并且不允许执行任务了，就从队列删除该任务，并设置任务的状态为取消状态  </span><br>        <span class="hljs-keyword">if</span> (isShutdown() &amp;&amp; !canRunInCurrentRunState(task.isPeriodic()) &amp;&amp; remove(task))  <br>            task.cancel(<span class="hljs-literal">false</span>);  <br>        <span class="hljs-keyword">else</span>  <br>            <span class="hljs-comment">// 可以执行  </span><br>            ensurePrestart();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>ensurePrestart()：<strong>开启线程执行任务</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// ThreadPoolExecutor#ensurePrestart  </span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">ensurePrestart</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">wc</span> <span class="hljs-operator">=</span> workerCountOf(ctl.get());  <br>    <span class="hljs-comment">// worker数目小于corePoolSize，则添加一个worker。  </span><br>    <span class="hljs-keyword">if</span> (wc &lt; corePoolSize)  <br>        <span class="hljs-comment">// 第二个参数 true 表示采用核心线程数量限制，false 表示采用 maximumPoolSize  </span><br>        addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>);  <br>    <span class="hljs-comment">// corePoolSize = 0的情况，至少开启一个线程，【担保机制】  </span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (wc == <span class="hljs-number">0</span>)  <br>        addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>canRunInCurrentRunState()：任务运行时都会被调用以校验当前状态是否可以运行任务</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">canRunInCurrentRunState</span><span class="hljs-params">(<span class="hljs-type">boolean</span> periodic)</span> &#123;  <br>    <span class="hljs-comment">// 根据是否是周期任务判断，在线程池 shutdown 后是否继续执行该任务，默认非周期任务是继续执行的  </span><br>    <span class="hljs-keyword">return</span> isRunningOrShutdown(periodic ? continueExistingPeriodicTasksAfterShutdown :  <br>                               executeExistingDelayedTasksAfterShutdown);  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>onShutdown()：删除并取消工作队列中的不需要再执行的任务</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">onShutdown</span><span class="hljs-params">()</span> &#123;  <br>    BlockingQueue&lt;Runnable&gt; q = <span class="hljs-built_in">super</span>.getQueue();  <br>    <span class="hljs-comment">// shutdown 后是否仍然执行延时任务  </span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">keepDelayed</span> <span class="hljs-operator">=</span> getExecuteExistingDelayedTasksAfterShutdownPolicy();  <br>    <span class="hljs-comment">// shutdown 后是否仍然执行周期任务  </span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">keepPeriodic</span> <span class="hljs-operator">=</span> getContinueExistingPeriodicTasksAfterShutdownPolicy();  <br>    <span class="hljs-comment">// 如果两者皆不可，则对队列中【所有任务】调用 cancel 取消并清空队列  </span><br>    <span class="hljs-keyword">if</span> (!keepDelayed &amp;&amp; !keepPeriodic) &#123;  <br>        <span class="hljs-keyword">for</span> (Object e : q.toArray())  <br>            <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> RunnableScheduledFuture&lt;?&gt;)  <br>                ((RunnableScheduledFuture&lt;?&gt;) e).cancel(<span class="hljs-literal">false</span>);  <br>        q.clear();  <br>    &#125;  <br>    <span class="hljs-keyword">else</span> &#123;  <br>        <span class="hljs-keyword">for</span> (Object e : q.toArray()) &#123;  <br>            <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> RunnableScheduledFuture) &#123;  <br>                RunnableScheduledFuture&lt;?&gt; t = (RunnableScheduledFuture&lt;?&gt;)e;  <br>                <span class="hljs-comment">// 不需要执行的任务删除并取消，已经取消的任务也需要从队列中删除  </span><br>                <span class="hljs-keyword">if</span> ((t.isPeriodic() ? !keepPeriodic : !keepDelayed) ||  <br>                    t.isCancelled()) &#123;  <br>                    <span class="hljs-keyword">if</span> (q.remove(t))  <br>                        t.cancel(<span class="hljs-literal">false</span>);  <br>                &#125;  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-comment">// 因为任务被从队列中清理掉，所以需要调用 tryTerminate 尝试【改变线程池的状态】  </span><br>    tryTerminate();  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="ForkJoin"><a href="#ForkJoin" class="headerlink" title="ForkJoin"></a>ForkJoin</h3><p>Fork&#x2F;Join：线程池的实现，体现是分治思想，适用于能够进行任务拆分的 CPU 密集型运算，用于<strong>并行计算</strong></p><p>任务拆分：将一个大任务拆分为算法上相同的小任务，直至不能拆分可以直接求解。跟递归相关的一些计算，如归并排序、斐波那契数列都可以用分治思想进行求解</p><ul><li><p>Fork&#x2F;Join 在<strong>分治的基础上加入了多线程</strong>，把每个任务的分解和合并交给不同的线程来完成，提升了运算效率</p></li><li><p>ForkJoin 使用 ForkJoinPool 来启动，是一个特殊的线程池，默认会创建与 CPU 核心数大小相同的线程池</p></li><li><p>任务有返回值继承 RecursiveTask，没有返回值继承 RecursiveAction</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    <span class="hljs-type">ForkJoinPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>(<span class="hljs-number">4</span>);  <br>    System.out.println(pool.invoke(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyTask</span>(<span class="hljs-number">5</span>)));  <br>    <span class="hljs-comment">//拆分  5 + MyTask(4) --&gt; 4 + MyTask(3) --&gt;  </span><br>&#125;  <br>  <br><span class="hljs-comment">// 1~ n 之间整数的和  </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RecursiveTask</span>&lt;Integer&gt; &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> n;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyTask</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.n = n;  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;MyTask&#123;&quot;</span> + <span class="hljs-string">&quot;n=&quot;</span> + n + <span class="hljs-string">&#x27;&#125;&#x27;</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">protected</span> Integer <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-comment">// 如果 n 已经为 1，可以求得结果了  </span><br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;  <br>            <span class="hljs-keyword">return</span> n;  <br>        &#125;  <br>        <span class="hljs-comment">// 将任务进行拆分(fork)  </span><br>        <span class="hljs-type">MyTask</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyTask</span>(n - <span class="hljs-number">1</span>);  <br>        t1.fork();  <br>        <span class="hljs-comment">// 合并(join)结果  </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> n + t1.join();  <br>        <span class="hljs-keyword">return</span> result;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>继续拆分优化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RecursiveTask</span>&lt;Integer&gt; &#123;  <br>    <span class="hljs-type">int</span> begin;  <br>    <span class="hljs-type">int</span> end;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AddTask</span><span class="hljs-params">(<span class="hljs-type">int</span> begin, <span class="hljs-type">int</span> end)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.begin = begin;  <br>        <span class="hljs-built_in">this</span>.end = end;  <br>    &#125;  <br>      <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&quot;</span> + begin + <span class="hljs-string">&quot;,&quot;</span> + end + <span class="hljs-string">&#x27;&#125;&#x27;</span>;  <br>    &#125;  <br>      <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">protected</span> Integer <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-comment">// 5, 5  </span><br>        <span class="hljs-keyword">if</span> (begin == end) &#123;  <br>            <span class="hljs-keyword">return</span> begin;  <br>        &#125;  <br>        <span class="hljs-comment">// 4, 5  防止多余的拆分  提高效率  </span><br>        <span class="hljs-keyword">if</span> (end - begin == <span class="hljs-number">1</span>) &#123;  <br>            <span class="hljs-keyword">return</span> end + begin;  <br>        &#125;  <br>        <span class="hljs-comment">// 1 5  </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (end + begin) / <span class="hljs-number">2</span>; <span class="hljs-comment">// 3  </span><br>        <span class="hljs-type">AddTask</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AddTask</span>(begin, mid); <span class="hljs-comment">// 1,3  </span><br>        t1.fork();  <br>        <span class="hljs-type">AddTask</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AddTask</span>(mid + <span class="hljs-number">1</span>, end); <span class="hljs-comment">// 4,5  </span><br>        t2.fork();  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> t1.join() + t2.join();  <br>        <span class="hljs-keyword">return</span> result;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>ForkJoinPool 实现了<strong>工作窃取算法</strong>来提高 CPU 的利用率：</p><ul><li><p>每个线程都维护了一个<strong>双端队列</strong>，用来存储需要执行的任务</p></li><li><p>工作窃取算法允许空闲的线程从其它线程的双端队列中窃取一个任务来执行</p></li><li><p>窃取的必须是<strong>最晚的任务</strong>，避免和队列所属线程发生竞争，但是队列中只有一个任务时还是会发生竞争</p></li></ul><hr><h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><p>享元模式（Flyweight pattern）： 用于减少创建对象的数量，以减少内存占用和提高性能，这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式</p><p>异步模式：让有限的工作线程（Worker Thread）来轮流异步处理无限多的任务，也可将其归类为分工模式，典型实现就是线程池</p><p>工作机制：享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象</p><p>自定义连接池：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    <span class="hljs-type">Pool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pool</span>(<span class="hljs-number">2</span>);  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;  <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>            <span class="hljs-type">Connection</span> <span class="hljs-variable">con</span> <span class="hljs-operator">=</span> pool.borrow();  <br>            <span class="hljs-keyword">try</span> &#123;  <br>                Thread.sleep(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">1000</span>));  <br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>                e.printStackTrace();  <br>            &#125;  <br>            pool.free(con);  <br>        &#125;).start();  <br>    &#125;  <br>&#125;  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pool</span> &#123;  <br>    <span class="hljs-comment">//连接池的大小  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> poolSize;  <br>    <span class="hljs-comment">//连接对象的数组  </span><br>    <span class="hljs-keyword">private</span> Connection[] connections;  <br>    <span class="hljs-comment">//连接状态数组 0表示空闲  1表示繁忙  </span><br>    <span class="hljs-keyword">private</span> AtomicIntegerArray states;  <span class="hljs-comment">//int[] -&gt; AtomicIntegerArray  </span><br>  <br>    <span class="hljs-comment">//构造方法  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Pool</span><span class="hljs-params">(<span class="hljs-type">int</span> poolSize)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.poolSize = poolSize;  <br>        <span class="hljs-built_in">this</span>.connections = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Connection</span>[poolSize];  <br>        <span class="hljs-built_in">this</span>.states = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicIntegerArray</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[poolSize]);  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;  <br>            connections[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MockConnection</span>(<span class="hljs-string">&quot;连接&quot;</span> + (i + <span class="hljs-number">1</span>));  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//使用连接  </span><br>    <span class="hljs-keyword">public</span> Connection <span class="hljs-title function_">borrow</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;  <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;  <br>                <span class="hljs-keyword">if</span> (states.get(i) == <span class="hljs-number">0</span>) &#123;  <br>                    <span class="hljs-keyword">if</span> (states.compareAndSet(i, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;  <br>                        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; borrow &quot;</span> +  connections[i]);  <br>                        <span class="hljs-keyword">return</span> connections[i];  <br>                    &#125;  <br>                &#125;  <br>            &#125;  <br>            <span class="hljs-comment">//如果没有空闲连接，当前线程等待  </span><br>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;  <br>                <span class="hljs-keyword">try</span> &#123;  <br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; wait...&quot;</span>);  <br>                    <span class="hljs-built_in">this</span>.wait();  <br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>                    e.printStackTrace();  <br>                &#125;  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//归还连接  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">free</span><span class="hljs-params">(Connection con)</span> &#123;  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;  <br>            <span class="hljs-keyword">if</span> (connections[i] == con) &#123;<span class="hljs-comment">//判断是否是同一个对象  </span><br>                states.set(i, <span class="hljs-number">0</span>);<span class="hljs-comment">//不用cas的原因是只会有一个线程使用该连接  </span><br>                <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;  <br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; free &quot;</span> + con);  <br>                    <span class="hljs-built_in">this</span>.notifyAll();  <br>                &#125;  <br>                <span class="hljs-keyword">break</span>;  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>  <br>&#125;  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MockConnection</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Connection</span> &#123;  <br>    <span class="hljs-keyword">private</span> String name;  <br>    <span class="hljs-comment">//.....  </span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="同步器"><a href="#同步器" class="headerlink" title="同步器"></a>同步器</h2><h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><h4 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h4><p>AQS：AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架，许多同步类实现都依赖于该同步器</p><p>AQS 用状态属性来表示资源的状态（分<strong>独占模式和共享模式</strong>），子类需要定义如何维护这个状态，控制如何获取锁和释放锁</p><ul><li><p>独占模式是只有一个线程能够访问资源，如 ReentrantLock</p></li><li><p>共享模式允许多个线程访问资源，如 Semaphore，ReentrantReadWriteLock 是组合式</p></li></ul><p>AQS 核心思想：</p><ul><li><p>如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置锁定状态</p></li><li><p>请求的共享资源被占用，AQS 用队列实现线程阻塞等待以及被唤醒时锁分配的机制，将暂时获取不到锁的线程加入到队列中</p><p>  CLH 是一种基于单向链表的<strong>高性能、公平的自旋锁</strong>，AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配</p><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041843050.png"></p></li></ul><hr><h4 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h4><p>设计原理：</p><ul><li><p>获取锁：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(state 状态不允许获取) &#123;<span class="hljs-comment">// tryAcquire(arg)  </span><br>       <span class="hljs-keyword">if</span>(队列中还没有此线程) &#123;  <br>           入队并阻塞 park  <br>       &#125;  <br>   &#125;  <br>   当前线程出队<br></code></pre></td></tr></table></figure></li><li><p>释放锁：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">if</span>(state 状态允许了) &#123;<span class="hljs-comment">// tryRelease(arg)  </span><br>恢复阻塞的线程(s) unpark  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>AbstractQueuedSynchronizer 中 state 设计：</p><ul><li><p>state 使用了 32bit int 来维护同步状态，独占模式 0 表示未加锁状态，大于 0 表示已经加锁状态</p><p>  <code>private volatile int state;</code></p></li><li><p>state <strong>使用 volatile 修饰配合 cas</strong> 保证其修改时的原子性</p></li><li><p>state 表示<strong>线程重入的次数（独占模式）或者剩余许可数（共享模式）</strong></p></li><li><p>state API：</p><ul><li><p><code>protected final int getState()</code>：获取 state 状态</p></li><li><p><code>protected final void setState(int newState)</code>：设置 state 状态</p></li><li><p><code>protected final boolean compareAndSetState(int expect,int update)</code>：<strong>CAS</strong> 安全设置 state</p></li></ul></li></ul><p>封装线程的 Node 节点中 waitstate 设计：</p><ul><li><p>使用 <strong>volatile 修饰配合 CAS</strong> 保证其修改时的原子性</p></li><li><p>表示 Node 节点的状态，有以下几种状态：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// 默认为 0  </span><br><span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> waitStatus;  <br><span class="hljs-comment">// 由于超时或中断，此节点被取消，不会再改变状态  </span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CANCELLED</span> <span class="hljs-operator">=</span>  <span class="hljs-number">1</span>;  <br><span class="hljs-comment">// 此节点后面的节点已（或即将）被阻止（通过park），【当前节点在释放或取消时必须唤醒后面的节点】  </span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SIGNAL</span>    <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;  <br><span class="hljs-comment">// 此节点当前在条件队列中  </span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CONDITION</span> <span class="hljs-operator">=</span> -<span class="hljs-number">2</span>;  <br><span class="hljs-comment">// 将releaseShared传播到其他节点  </span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PROPAGATE</span> <span class="hljs-operator">=</span> -<span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure></li></ul><p>阻塞恢复设计：</p><ul><li><p>使用 park &amp; unpark 来实现线程的暂停和恢复，因为命令的先后顺序不影响结果</p></li><li><p>park &amp; unpark 是针对线程的，而不是针对同步器的，因此控制粒度更为精细</p></li><li><p>park 线程可以通过 interrupt 打断</p></li></ul><p>队列设计：</p><ul><li><p>使用了 FIFO 先入先出队列，并不支持优先级队列，<strong>同步队列是双向链表，便于出队入队</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// 头结点，指向哑元节点  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node head;  <br><span class="hljs-comment">// 阻塞队列的尾节点，阻塞队列不包含头结点，从 head.next → tail 认为是阻塞队列  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node tail;  <br>  <br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;  <br>    <span class="hljs-comment">// 枚举：共享模式  </span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">SHARED</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();  <br>    <span class="hljs-comment">// 枚举：独占模式  </span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">EXCLUSIVE</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;  <br>    <span class="hljs-comment">// node 需要构建成 FIFO 队列，prev 指向前继节点  </span><br>    <span class="hljs-keyword">volatile</span> Node prev;  <br>    <span class="hljs-comment">// next 指向后继节点  </span><br>    <span class="hljs-keyword">volatile</span> Node next;  <br>    <span class="hljs-comment">// 当前 node 封装的线程  </span><br>    <span class="hljs-keyword">volatile</span> Thread thread;  <br>    <span class="hljs-comment">// 条件队列是单向链表，只有后继指针，条件队列使用该属性  </span><br>    Node nextWaiter;  <br>&#125;<br></code></pre></td></tr></table></figure><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041846265.png"></p></li><li><p>条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet，<strong>条件队列是单向链表</strong></p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConditionObject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Condition</span>, java.io.Serializable &#123;  <br>    <span class="hljs-comment">// 指向条件队列的第一个 node 节点  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node firstWaiter;  <br>    <span class="hljs-comment">// 指向条件队列的最后一个 node 节点  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node lastWaiter;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h4 id="模板对象"><a href="#模板对象" class="headerlink" title="模板对象"></a>模板对象</h4><p>同步器的设计是基于模板方法模式，该模式是基于继承的，主要是为了在不改变模板结构的前提下在子类中重新定义模板中的内容以实现复用代码</p><ul><li><p>使用者继承 <code>AbstractQueuedSynchronizer</code> 并重写指定的方法</p></li><li><p>将 AQS 组合在自定义同步组件的实现中，并调用其模板方法，这些模板方法会调用使用者重写的方法</p></li></ul><p>AQS 使用了模板方法模式，自定义同步器时需要重写下面几个 AQS 提供的模板方法：</p><p>isHeldExclusively()&#x2F;&#x2F;该线程是否正在独占资源。只有用到condition才需要去实现它<br>tryAcquire(int)&#x2F;&#x2F;独占方式。尝试获取资源，成功则返回true，失败则返回false<br>tryRelease(int)&#x2F;&#x2F;独占方式。尝试释放资源，成功则返回true，失败则返回false<br>tryAcquireShared(int)&#x2F;&#x2F;共享方式。尝试获取资源。负数表示失败；0表示成功但没有剩余可用资源；正数表示成功且有剩余资源<br>tryReleaseShared(int)&#x2F;&#x2F;共享方式。尝试释放资源，成功则返回true，失败则返回false</p><ul><li><p>默认情况下，每个方法都抛出 <code>UnsupportedOperationException</code></p></li><li><p>这些方法的实现必须是内部线程安全的</p></li><li><p>AQS 类中的其他方法都是 final ，所以无法被其他类使用，只有这几个方法可以被其他类使用</p></li></ul><hr><h4 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h4><p>自定义一个不可重入锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Lock</span> &#123;  <br>    <span class="hljs-comment">//独占锁 不可重入  </span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">MySync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;  <br>        <span class="hljs-meta">@Override</span>  <br>        <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;  <br>            <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;  <br>                <span class="hljs-comment">// 加上锁 设置 owner 为当前线程  </span><br>                setExclusiveOwnerThread(Thread.currentThread());  <br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>            &#125;  <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>        &#125;  <br>        <span class="hljs-meta">@Override</span>   <span class="hljs-comment">//解锁  </span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;  <br>            setExclusiveOwnerThread(<span class="hljs-literal">null</span>);  <br>            setState(<span class="hljs-number">0</span>);<span class="hljs-comment">//volatile 修饰的变量放在后面，防止指令重排  </span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>        &#125;  <br>        <span class="hljs-meta">@Override</span>   <span class="hljs-comment">//是否持有独占锁  </span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHeldExclusively</span><span class="hljs-params">()</span> &#123;  <br>            <span class="hljs-keyword">return</span> getState() == <span class="hljs-number">1</span>;  <br>        &#125;  <br>        <span class="hljs-keyword">public</span> Condition <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span> &#123;  <br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConditionObject</span>();  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">MySync</span> <span class="hljs-variable">sync</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MySync</span>();  <br>  <br>    <span class="hljs-meta">@Override</span>   <span class="hljs-comment">//加锁（不成功进入等待队列等待）  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;  <br>        sync.acquire(<span class="hljs-number">1</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>   <span class="hljs-comment">//加锁 可打断  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>        sync.acquireInterruptibly(<span class="hljs-number">1</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>   <span class="hljs-comment">//尝试加锁，尝试一次  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> sync.tryAcquire(<span class="hljs-number">1</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>   <span class="hljs-comment">//尝试加锁，带超时  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>        <span class="hljs-keyword">return</span> sync.tryAcquireNanos(<span class="hljs-number">1</span>, unit.toNanos(time));  <br>    &#125;  <br>      <br>    <span class="hljs-meta">@Override</span>   <span class="hljs-comment">//解锁  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;  <br>        sync.release(<span class="hljs-number">1</span>);  <br>    &#125;  <br>      <br>    <span class="hljs-meta">@Override</span>   <span class="hljs-comment">//条件变量  </span><br>    <span class="hljs-keyword">public</span> Condition <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> sync.newCondition();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><h4 id="锁对比"><a href="#锁对比" class="headerlink" title="锁对比"></a>锁对比</h4><p>ReentrantLock 相对于 synchronized 具备如下特点：</p><ol><li><p>锁的实现：synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的</p></li><li><p>性能：新版本 Java 对 synchronized 进行了很多优化，synchronized 与 ReentrantLock 大致相同</p></li><li><p>使用：ReentrantLock 需要手动解锁，synchronized 执行完代码块自动解锁</p></li><li><p><strong>可中断</strong>：ReentrantLock 可中断，而 synchronized 不行</p></li><li><p><strong>公平锁</strong>：公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁</p><ul><li><p>ReentrantLock 可以设置公平锁，synchronized 中的锁是非公平的</p></li><li><p>不公平锁的含义是阻塞队列内公平，队列外非公平</p></li></ul></li><li><p>锁超时：尝试获取锁，超时获取不到直接放弃，不进入阻塞队列</p><ul><li>ReentrantLock 可以设置超时时间，synchronized 会一直等待</li></ul></li><li><p>锁绑定多个条件：一个 ReentrantLock 可以同时绑定多个 Condition 对象，更细粒度的唤醒线程</p></li><li><p>两者都是可重入锁</p></li></ol><hr><h4 id="使用锁"><a href="#使用锁" class="headerlink" title="使用锁"></a>使用锁</h4><p>构造方法：<code>ReentrantLock lock = new ReentrantLock();</code></p><p>ReentrantLock 类 API：</p><ul><li><p><code>public void lock()</code>：获得锁</p><ul><li><p>如果锁没有被另一个线程占用，则将锁定计数设置为 1</p></li><li><p>如果当前线程已经保持锁定，则保持计数增加 1</p></li><li><p>如果锁被另一个线程保持，则当前线程被禁用线程调度，并且在锁定已被获取之前处于休眠状态</p></li></ul></li><li><p><code>public void unlock()</code>：尝试释放锁</p><ul><li><p>如果当前线程是该锁的持有者，则保持计数递减</p></li><li><p>如果保持计数现在为零，则锁定被释放</p></li><li><p>如果当前线程不是该锁的持有者，则抛出异常</p></li></ul></li></ul><p>基本语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取锁  </span><br>reentrantLock.lock();  <br><span class="hljs-keyword">try</span> &#123;  <br>    <span class="hljs-comment">// 临界区  </span><br>&#125; <span class="hljs-keyword">finally</span> &#123;  <br><span class="hljs-comment">// 释放锁  </span><br>reentrantLock.unlock();  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><h5 id="基本使用-2"><a href="#基本使用-2" class="headerlink" title="基本使用"></a>基本使用</h5><p>构造方法：<code>ReentrantLock lock = new ReentrantLock(true)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">(<span class="hljs-type">boolean</span> fair)</span> &#123;  <br>    sync = fair ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">FairSync</span>() : <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();  <br>&#125;<br><br><span class="hljs-comment">//ReentrantLock 默认是不公平的：</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">()</span> &#123;  <br>    sync = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();  <br>&#125;<br><br><span class="hljs-comment">//说明：公平锁一般没有必要，会降低并发度</span><br></code></pre></td></tr></table></figure><hr><h5 id="非公原理"><a href="#非公原理" class="headerlink" title="非公原理"></a>非公原理</h5><h6 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h6><p>NonfairSync 继承自 AQS</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;  <br>    sync.lock();  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>没有竞争：ExclusiveOwnerThread 属于 Thread-0，state 设置为 1</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// ReentrantLock.NonfairSync#lock  </span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">// 用 cas 尝试（仅尝试一次）将 state 从 0 改为 1, 如果成功表示【获得了独占锁】  </span><br>    <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))  <br>        <span class="hljs-comment">// 设置当前线程为独占线程  </span><br>        setExclusiveOwnerThread(Thread.currentThread());  <br>    <span class="hljs-keyword">else</span>  <br>        acquire(<span class="hljs-number">1</span>);<span class="hljs-comment">//失败进入  </span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>第一个竞争出现：Thread-1 执行，CAS 尝试将 state 由 0 改为 1，结果失败（第一次），进入 acquire 逻辑</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// AbstractQueuedSynchronizer#acquire  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;  <br>    <span class="hljs-comment">// tryAcquire 尝试获取锁失败时, 会调用 addWaiter 将当前线程封装成node入队，acquireQueued 阻塞当前线程，  </span><br>    <span class="hljs-comment">// acquireQueued 返回 true 表示挂起过程中线程被中断唤醒过，false 表示未被中断过  </span><br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))  <br>        <span class="hljs-comment">// 如果线程被中断了逻辑来到这，完成一次真正的打断效果  </span><br>        selfInterrupt();  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041851334.png"></p><ul><li><p>进入 tryAcquire 尝试获取锁逻辑，这时 state 已经是1，结果仍然失败（第二次），加锁成功有两种情况：</p><ul><li><p>当前 AQS 处于无锁状态</p></li><li><p>加锁线程就是当前线程，说明发生了锁重入</p></li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// ReentrantLock.NonfairSync#tryAcquire  </span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;  <br>    <span class="hljs-keyword">return</span> nonfairTryAcquire(acquires);  <br>&#125;  <br><span class="hljs-comment">// 抢占成功返回 true，抢占失败返回 false  </span><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">nonfairTryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;  <br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();  <br>    <span class="hljs-comment">// state 值  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();  <br>    <span class="hljs-comment">// 条件成立说明当前处于【无锁状态】  </span><br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;  <br>        <span class="hljs-comment">//如果还没有获得锁，尝试用cas获得，这里体现非公平性: 不去检查 AQS 队列是否有阻塞线程直接获取锁          </span><br>    <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;  <br>            <span class="hljs-comment">// 获取锁成功设置当前线程为独占锁线程。  </span><br>            setExclusiveOwnerThread(current);  <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>         &#125;      <br>&#125;      <br>   <span class="hljs-comment">// 如果已经有线程获得了锁, 独占锁线程还是当前线程, 表示【发生了锁重入】  </span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;  <br>        <span class="hljs-comment">// 更新锁重入的值  </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c + acquires;  <br>        <span class="hljs-comment">// 越界判断，当重入的深度很深时，会导致 nextc &lt; 0，int值达到最大之后再 + 1 变负数  </span><br>        <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow  </span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);  <br>        <span class="hljs-comment">// 更新 state 的值，这里不使用 cas 是因为当前线程正在持有锁，所以这里的操作相当于在一个管程内  </span><br>        setState(nextc);  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    &#125;  <br>    <span class="hljs-comment">// 获取失败  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>接下来进入 addWaiter 逻辑，构造 Node 队列（不是阻塞队列），前置条件是当前线程获取锁失败，说明有线程占用了锁</p><ul><li><p>图中黄色三角表示该 Node 的 waitStatus 状态，其中 0 为默认<strong>正常状态</strong></p></li><li><p>Node 的创建是懒惰的，其中第一个 Node 称为 <strong>Dummy（哑元）或哨兵</strong>，用来占位，并不关联线程</p></li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// AbstractQueuedSynchronizer#addWaiter，返回当前线程的 node 节点  </span><br><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">addWaiter</span><span class="hljs-params">(Node mode)</span> &#123;  <br>    <span class="hljs-comment">// 将当前线程关联到一个 Node 对象上, 模式为独占模式     </span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Thread.currentThread(), mode);  <br>    <span class="hljs-type">Node</span> <span class="hljs-variable">pred</span> <span class="hljs-operator">=</span> tail;  <br>    <span class="hljs-comment">// 快速入队，如果 tail 不为 null，说明存在队列  </span><br>    <span class="hljs-keyword">if</span> (pred != <span class="hljs-literal">null</span>) &#123;  <br>        <span class="hljs-comment">// 将当前节点的前驱节点指向 尾节点  </span><br>        node.prev = pred;  <br>        <span class="hljs-comment">// 通过 cas 将 Node 对象加入 AQS 队列，成为尾节点，【尾插法】  </span><br>        <span class="hljs-keyword">if</span> (compareAndSetTail(pred, node)) &#123;  <br>            pred.next = node;<span class="hljs-comment">// 双向链表  </span><br>            <span class="hljs-keyword">return</span> node;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-comment">// 初始时队列为空，或者 CAS 失败进入这里  </span><br>    enq(node);  <br>    <span class="hljs-keyword">return</span> node;  <br>&#125;<br><br><span class="hljs-comment">// AbstractQueuedSynchronizer#enq  </span><br><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">enq</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node)</span> &#123;  <br>    <span class="hljs-comment">// 自旋入队，必须入队成功才结束循环  </span><br>    <span class="hljs-keyword">for</span> (;;) &#123;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail;  <br>        <span class="hljs-comment">// 说明当前锁被占用，且当前线程可能是【第一个获取锁失败】的线程，【还没有建立队列】  </span><br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-comment">// 设置一个【哑元节点】，头尾指针都指向该节点  </span><br>            <span class="hljs-keyword">if</span> (compareAndSetHead(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>()))  <br>                tail = head;  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            <span class="hljs-comment">// 自旋到这，普通入队方式，首先赋值尾节点的前驱节点【尾插法】  </span><br>            node.prev = t;  <br>            <span class="hljs-comment">// 【在设置完尾节点后，才更新的原始尾节点的后继节点，所以此时从前往后遍历会丢失尾节点】  </span><br>            <span class="hljs-keyword">if</span> (compareAndSetTail(t, node)) &#123;  <br>                <span class="hljs-comment">//【此时 t.next  = null，并且这里已经 CAS 结束，线程并不是安全的】  </span><br>                t.next = node;  <br>                <span class="hljs-keyword">return</span> t;<span class="hljs-comment">// 返回当前 node 的前驱节点  </span><br>            &#125;  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041853324.png">  </p></li><li><p>线程节点加入队列成功，进入 AbstractQueuedSynchronizer#acquireQueued 逻辑阻塞线程</p><ul><li><p>acquireQueued 会在一个自旋中不断尝试获得锁，失败后进入 park 阻塞</p></li><li><p>如果当前线程是在 head 节点后，会再次 tryAcquire 尝试获取锁，state 仍为 1 则失败（第三次）</p></li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-type">int</span> arg)</span> &#123;  <br>    <span class="hljs-comment">// true 表示当前线程抢占锁失败，false 表示成功  </span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-comment">// 中断标记，表示当前线程是否被中断  </span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;  <br>        <span class="hljs-keyword">for</span> (;;) &#123;  <br>            <span class="hljs-comment">// 获得当前线程节点的前驱节点  </span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();  <br>            <span class="hljs-comment">// 前驱节点是 head, FIFO 队列的特性表示轮到当前线程可以去获取锁  </span><br>            <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;  <br>                <span class="hljs-comment">// 获取成功, 设置当前线程自己的 node 为 head  </span><br>                setHead(node);  <br>                p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC  </span><br>                <span class="hljs-comment">// 表示抢占锁成功  </span><br>                failed = <span class="hljs-literal">false</span>;  <br>                <span class="hljs-comment">// 返回当前线程是否被中断  </span><br>                <span class="hljs-keyword">return</span> interrupted;  <br>            &#125;  <br>            <span class="hljs-comment">// 判断是否应当 park，返回 false 后需要新一轮的循环，返回 true 进入条件二阻塞线程  </span><br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())  <br>                <span class="hljs-comment">// 条件二返回结果是当前线程是否被打断，没有被打断返回 false 不进入这里的逻辑  </span><br>                <span class="hljs-comment">// 【就算被打断了，也会继续循环，并不会返回】  </span><br>                interrupted = <span class="hljs-literal">true</span>;  <br>        &#125;  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        <span class="hljs-comment">// 【可打断模式下才会进入该逻辑】  </span><br>        <span class="hljs-keyword">if</span> (failed)  <br>            cancelAcquire(node);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>进入 shouldParkAfterFailedAcquire 逻辑，<strong>将前驱 node 的 waitStatus 改为 -1</strong>，返回 false；waitStatus 为 -1 的节点用来唤醒下一个节点</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">shouldParkAfterFailedAcquire</span><span class="hljs-params">(Node pred, Node node)</span> &#123;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> pred.waitStatus;  <br>    <span class="hljs-comment">// 表示前置节点是个可以唤醒当前节点的节点，返回 true  </span><br>    <span class="hljs-keyword">if</span> (ws == Node.SIGNAL)  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    <span class="hljs-comment">// 前置节点的状态处于取消状态，需要【删除前面所有取消的节点】, 返回到外层循环重试  </span><br>    <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span>) &#123;  <br>        <span class="hljs-keyword">do</span> &#123;  <br>            node.prev = pred = pred.prev;  <br>        &#125; <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>);  <br>        <span class="hljs-comment">// 获取到非取消的节点，连接上当前节点  </span><br>        pred.next = node;  <br>    <span class="hljs-comment">// 默认情况下 node 的 waitStatus 是 0，进入这里的逻辑  </span><br>    &#125; <span class="hljs-keyword">else</span> &#123;  <br>        <span class="hljs-comment">// 【设置上一个节点状态为 Node.SIGNAL】，返回外层循环重试  </span><br>        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);  <br>    &#125;  <br>    <span class="hljs-comment">// 返回不应该 park，再次尝试一次  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>shouldParkAfterFailedAcquire 执行完毕回到 acquireQueued ，再次 tryAcquire 尝试获取锁，这时 state 仍为 1 获取失败（第四次）</p></li><li><p>当再次进入 shouldParkAfterFailedAcquire 时，这时其前驱 node 的 waitStatus 已经是 -1 了，返回 true</p></li><li><p>进入 parkAndCheckInterrupt， Thread-1 park（灰色表示）</p></li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">parkAndCheckInterrupt</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">// 阻塞当前线程，如果打断标记已经是 true, 则 park 会失效  </span><br>    LockSupport.park(<span class="hljs-built_in">this</span>);  <br>    <span class="hljs-comment">// 判断当前线程是否被打断，清除打断标记  </span><br>    <span class="hljs-keyword">return</span> Thread.interrupted();  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>再有多个线程经历竞争失败后：</p><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041853649.png"></p></li></ul><hr><h6 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h6><p>ReentrantLock#unlock：释放锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;  <br>    sync.release(<span class="hljs-number">1</span>);  <br>&#125;<br></code></pre></td></tr></table></figure><p>Thread-0 释放锁，进入 release 流程</p><ul><li><p>进入 tryRelease，设置 exclusiveOwnerThread 为 null，state &#x3D; 0</p></li><li><p>当前队列不为 null，并且 head 的 waitStatus &#x3D; -1，进入 unparkSuccessor</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// AbstractQueuedSynchronizer#release  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;  <br>    <span class="hljs-comment">// 尝试释放锁，tryRelease 返回 true 表示当前线程已经【完全释放锁，重入的释放了】  </span><br>    <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;  <br>        <span class="hljs-comment">// 队列头节点  </span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;  <br>        <span class="hljs-comment">// 头节点什么时候是空？没有发生锁竞争，没有竞争线程创建哑元节点  </span><br>        <span class="hljs-comment">// 条件成立说明阻塞队列有等待线程，需要唤醒 head 节点后面的线程  </span><br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)  <br>            unparkSuccessor(h);  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    &#125;      <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>  &#x2F;&#x2F; ReentrantLock.Sync#tryRelease  </p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;  <br>    <span class="hljs-comment">// 减去释放的值，可能重入  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState() - releases;  <br>    <span class="hljs-comment">// 如果当前线程不是持有锁的线程直接报错  </span><br>    <span class="hljs-keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())  <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();  <br>    <span class="hljs-comment">// 是否已经完全释放锁  </span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">free</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;  <br>    <span class="hljs-comment">// 支持锁重入, 只有 state 减为 0, 才完全释放锁成功  </span><br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;  <br>        free = <span class="hljs-literal">true</span>;  <br>        setExclusiveOwnerThread(<span class="hljs-literal">null</span>);  <br>    &#125;  <br>    <span class="hljs-comment">// 当前线程就是持有锁线程，所以可以直接更新锁，不需要使用 CAS  </span><br>    setState(c);  <br>    <span class="hljs-keyword">return</span> free;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>进入 AbstractQueuedSynchronizer#unparkSuccessor 方法，唤醒当前节点的后继节点</p><ul><li><p>找到队列中距离 head 最近的一个没取消的 Node，unpark 恢复其运行，本例中即为 Thread-1</p></li><li><p>回到 Thread-1 的 acquireQueued 流程</p></li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unparkSuccessor</span><span class="hljs-params">(Node node)</span> &#123;  <br>    <span class="hljs-comment">// 当前节点的状态  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> node.waitStatus;      <br>    <span class="hljs-keyword">if</span> (ws &lt; <span class="hljs-number">0</span>)          <br>        <span class="hljs-comment">// 【尝试重置状态为 0】，因为当前节点要完成对后续节点的唤醒任务了，不需要 -1 了  </span><br>        compareAndSetWaitStatus(node, ws, <span class="hljs-number">0</span>);      <br>    <span class="hljs-comment">// 找到需要 unpark 的节点，当前节点的下一个      </span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;      <br>    <span class="hljs-comment">// 已取消的节点不能唤醒，需要找到距离头节点最近的非取消的节点  </span><br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.waitStatus &gt; <span class="hljs-number">0</span>) &#123;  <br>        s = <span class="hljs-literal">null</span>;  <br>        <span class="hljs-comment">// AQS 队列【从后至前】找需要 unpark 的节点，直到 t == 当前的 node 为止，找不到就不唤醒了  </span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail; t != <span class="hljs-literal">null</span> &amp;&amp; t != node; t = t.prev)  <br>            <span class="hljs-comment">// 说明当前线程状态需要被唤醒  </span><br>            <span class="hljs-keyword">if</span> (t.waitStatus &lt;= <span class="hljs-number">0</span>)  <br>                <span class="hljs-comment">// 置换引用  </span><br>                s = t;  <br>    &#125;  <br>    <span class="hljs-comment">// 【找到合适的可以被唤醒的 node，则唤醒线程】  </span><br>    <span class="hljs-keyword">if</span> (s != <span class="hljs-literal">null</span>)  <br>        LockSupport.unpark(s.thread);  <br>&#125;<br></code></pre></td></tr></table></figure><p>  <strong>从后向前的唤醒的原因</strong>：enq 方法中，节点是尾插法，首先赋值的是尾节点的前驱节点，此时前驱节点的 next 并没有指向尾节点，从前遍历会丢失尾节点  </p></li><li><p>唤醒的线程会从 park 位置开始执行，如果加锁成功（没有竞争），会设置</p><ul><li><p>exclusiveOwnerThread 为 Thread-1，state &#x3D; 1</p></li><li><p>head 指向刚刚 Thread-1 所在的 Node，该 Node 会清空 Thread</p></li><li><p>原本的 head 因为从链表断开，而可被垃圾回收（图中有错误，原来的头节点的 waitStatus 被改为 0 了）</p></li></ul><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041855500.png">  </p></li><li><p>如果这时有其它线程来竞争<strong>（非公平）</strong>，例如这时有 Thread-4 来了并抢占了锁</p><ul><li><p>Thread-4 被设置为 exclusiveOwnerThread，state &#x3D; 1</p></li><li><p>Thread-1 再次进入 acquireQueued 流程，获取锁失败，重新进入 park 阻塞</p></li></ul><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041856156.png"></p></li></ul><hr><h5 id="公平原理"><a href="#公平原理" class="headerlink" title="公平原理"></a>公平原理</h5><p>与非公平锁主要区别在于 tryAcquire 方法：先检查 AQS 队列中是否有前驱节点，没有才去 CAS 竞争</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> -<span class="hljs-number">3000897897090466540L</span>;  <br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;  <br>        acquire(<span class="hljs-number">1</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;  <br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();  <br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;  <br>            <span class="hljs-comment">// 先检查 AQS 队列中是否有前驱节点, 没有(false)才去竞争  </span><br>            <span class="hljs-keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;  <br>                compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;  <br>                setExclusiveOwnerThread(current);  <br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-comment">// 锁重入  </span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>    &#125;  <br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasQueuedPredecessors</span><span class="hljs-params">()</span> &#123;      <br>    <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail;  <br>    <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;  <br>    Node s;      <br>    <span class="hljs-comment">// 头尾指向一个节点，链表为空，返回false  </span><br>    <span class="hljs-keyword">return</span> h != t &amp;&amp;  <br>        <span class="hljs-comment">// 头尾之间有节点，判断头节点的下一个是不是空  </span><br>        <span class="hljs-comment">// 不是空进入最后的判断，第二个节点的线程是否是本线程，不是返回 true，表示当前节点有前驱节点  </span><br>        ((s = h.next) == <span class="hljs-literal">null</span> || s.thread != Thread.currentThread());  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h4><p>可重入是指同一个线程如果首次获得了这把锁，那么它是这把锁的拥有者，因此有权利再次获取这把锁，如果不可重入锁，那么第二次获得锁时，自己也会被锁挡住，直接造成死锁</p><p>源码解析参考：<code>nonfairTryAcquire(int acquires))</code> 和 <code>tryRelease(int releases)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">static</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    method1();  <br>&#125;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span> &#123;  <br>    lock.lock();  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; execute method1&quot;</span>);  <br>        method2();  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        lock.unlock();  <br>    &#125;  <br>&#125;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span> &#123;  <br>    lock.lock();  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; execute method2&quot;</span>);  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        lock.unlock();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>在 Lock 方法加两把锁会是什么情况呢？</p><ul><li><p>加锁两次解锁两次：正常执行</p></li><li><p>加锁两次解锁一次：程序直接卡死，线程不能出来，也就说明<strong>申请几把锁，最后需要解除几把锁</strong></p></li><li><p>加锁一次解锁两次：运行程序会直接报错</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getLock</span><span class="hljs-params">()</span> &#123;  <br>    lock.lock();  <br>    lock.lock();  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t get Lock&quot;</span>);  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        lock.unlock();  <br>        <span class="hljs-comment">//lock.unlock();  </span><br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="可打断"><a href="#可打断" class="headerlink" title="可打断"></a>可打断</h4><h5 id="基本使用-3"><a href="#基本使用-3" class="headerlink" title="基本使用"></a>基本使用</h5><p><code>public void lockInterruptibly()</code>：获得可打断的锁</p><ul><li><p>如果没有竞争此方法就会获取 lock 对象锁</p></li><li><p>如果有竞争就进入阻塞队列，可以被其他线程用 interrupt 打断</p></li></ul><p>注意：如果是不可中断模式，那么即使使用了 interrupt 也不会让等待状态中的线程中断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;      <br>    <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();      <br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;          <br>        <span class="hljs-keyword">try</span> &#123;              <br>            System.out.println(<span class="hljs-string">&quot;尝试获取锁&quot;</span>);              <br>            lock.lockInterruptibly();          <br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;              <br>            System.out.println(<span class="hljs-string">&quot;没有获取到锁，被打断，直接返回&quot;</span>);              <br>            <span class="hljs-keyword">return</span>;          <br>        &#125;          <br>        <span class="hljs-keyword">try</span> &#123;              <br>            System.out.println(<span class="hljs-string">&quot;获取到锁&quot;</span>);          <br>        &#125; <span class="hljs-keyword">finally</span> &#123;              <br>            lock.unlock();          <br>        &#125;      <br>    &#125;, <span class="hljs-string">&quot;t1&quot;</span>);      <br>    lock.lock();      <br>    t1.start();      <br>    Thread.sleep(<span class="hljs-number">2000</span>);      <br>    System.out.println(<span class="hljs-string">&quot;主线程进行打断锁&quot;</span>);      <br>    t1.interrupt();  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="实现原理-2"><a href="#实现原理-2" class="headerlink" title="实现原理"></a>实现原理</h5><ul><li><p>不可打断模式：即使它被打断，仍会驻留在 AQS 阻塞队列中，一直要<strong>等到获得锁后才能得知自己被打断</strong>了</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;      <br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<span class="hljs-comment">//阻塞等待          </span><br>        <span class="hljs-comment">// 如果acquireQueued返回true，打断状态 interrupted = true          </span><br>        selfInterrupt();  <br>&#125;  <br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">selfInterrupt</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">// 知道自己被打断了，需要重新产生一次中断完成中断效果  </span><br>    Thread.currentThread().interrupt();  <br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-type">int</span> arg)</span> &#123;      <br>    <span class="hljs-keyword">try</span> &#123;          <br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;          <br>        <span class="hljs-keyword">for</span> (;;) &#123;              <br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();              <br>            <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;                  <br>                setHead(node);                  <br>                p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC                  </span><br>                failed = <span class="hljs-literal">false</span>;                  <br>                <span class="hljs-comment">// 还是需要获得锁后, 才能返回打断状态  </span><br>                <span class="hljs-keyword">return</span> interrupted;              <br>            &#125;              <br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())&#123;  <br>                <span class="hljs-comment">// 条件二中判断当前线程是否被打断，被打断返回true，设置中断标记为 true，【获取锁后返回】  </span><br>                interrupted = <span class="hljs-literal">true</span>;    <br>            &#125;                    <br>        &#125;   <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        <span class="hljs-keyword">if</span> (failed)  <br>            cancelAcquire(node);  <br>    &#125;  <br>&#125;  <br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">parkAndCheckInterrupt</span><span class="hljs-params">()</span> &#123;      <br>     <span class="hljs-comment">// 阻塞当前线程，如果打断标记已经是 true, 则 park 会失效  </span><br>     LockSupport.park(<span class="hljs-built_in">this</span>);      <br>     <span class="hljs-comment">// 判断当前线程是否被打断，清除打断标记，被打断返回true  </span><br>     <span class="hljs-keyword">return</span> Thread.interrupted();  <br> &#125;<br></code></pre></td></tr></table></figure></li><li><p>可打断模式：AbstractQueuedSynchronizer#acquireInterruptibly，<strong>被打断后会直接抛出异常</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;      <br>    sync.acquireInterruptibly(<span class="hljs-number">1</span>);  <br>&#125;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireInterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;  <br>    <span class="hljs-comment">// 被其他线程打断了直接返回 false  </span><br>    <span class="hljs-keyword">if</span> (Thread.interrupted())  <br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();  <br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg))  <br>        <span class="hljs-comment">// 没获取到锁，进入这里  </span><br>        doAcquireInterruptibly(arg);  <br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAcquireInterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>    <span class="hljs-comment">// 返回封装当前线程的节点  </span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addWaiter(Node.EXCLUSIVE);  <br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-keyword">for</span> (;;) &#123;  <br>            <span class="hljs-comment">//...  </span><br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())  <br>                <span class="hljs-comment">// 【在 park 过程中如果被 interrupt 会抛出异常】, 而不会再次进入循环获取锁后才完成打断效果  </span><br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();  <br>        &#125;      <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        <span class="hljs-comment">// 抛出异常前会进入这里  </span><br>        <span class="hljs-keyword">if</span> (failed)  <br>            <span class="hljs-comment">// 取消当前线程的节点  </span><br>            cancelAcquire(node);  <br>    &#125;  <br>&#125;<br><br><span class="hljs-comment">// 取消节点出队的逻辑  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cancelAcquire</span><span class="hljs-params">(Node node)</span> &#123;  <br>    <span class="hljs-comment">// 判空  </span><br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>)  <br>        <span class="hljs-keyword">return</span>;  <br><span class="hljs-comment">// 把当前节点封装的 Thread 置为空  </span><br>    node.thread = <span class="hljs-literal">null</span>;  <br><span class="hljs-comment">// 获取当前取消的 node 的前驱节点  </span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">pred</span> <span class="hljs-operator">=</span> node.prev;  <br>    <span class="hljs-comment">// 前驱节点也被取消了，循环找到前面最近的没被取消的节点  </span><br>    <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>)  <br>        node.prev = pred = pred.prev;  <br>      <br><span class="hljs-comment">// 获取前驱节点的后继节点，可能是当前 node，也可能是 waitStatus &gt; 0 的节点  </span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">predNext</span> <span class="hljs-operator">=</span> pred.next;  <br>      <br><span class="hljs-comment">// 把当前节点的状态设置为 【取消状态 1】  </span><br>    node.waitStatus = Node.CANCELLED;  <br>      <br><span class="hljs-comment">// 条件成立说明当前节点是尾节点，把当前节点的前驱节点设置为尾节点  </span><br>    <span class="hljs-keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;  <br>        <span class="hljs-comment">// 把前驱节点的后继节点置空，这里直接把所有的取消节点出队  </span><br>        compareAndSetNext(pred, predNext, <span class="hljs-literal">null</span>);  <br>    &#125; <span class="hljs-keyword">else</span> &#123;  <br>        <span class="hljs-comment">// 说明当前节点不是 tail 节点  </span><br>        <span class="hljs-type">int</span> ws;  <br>        <span class="hljs-comment">// 条件一成立说明当前节点不是 head.next 节点  </span><br>        <span class="hljs-keyword">if</span> (pred != head &amp;&amp;  <br>            <span class="hljs-comment">// 判断前驱节点的状态是不是 -1，不成立说明前驱状态可能是 0 或者刚被其他线程取消排队了  </span><br>            ((ws = pred.waitStatus) == Node.SIGNAL ||  <br>             <span class="hljs-comment">// 如果状态不是 -1，设置前驱节点的状态为 -1  </span><br>             (ws &lt;= <span class="hljs-number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;  <br>            <span class="hljs-comment">// 前驱节点的线程不为null  </span><br>            pred.thread != <span class="hljs-literal">null</span>) &#123;  <br>              <br>            <span class="hljs-type">Node</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> node.next;  <br>            <span class="hljs-comment">// 当前节点的后继节点是正常节点  </span><br>            <span class="hljs-keyword">if</span> (next != <span class="hljs-literal">null</span> &amp;&amp; next.waitStatus &lt;= <span class="hljs-number">0</span>)  <br>                <span class="hljs-comment">// 把 前驱节点的后继节点 设置为 当前节点的后继节点，【从队列中删除了当前节点】  </span><br>                compareAndSetNext(pred, predNext, next);  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            <span class="hljs-comment">// 当前节点是 head.next 节点，唤醒当前节点的后继节点  </span><br>            unparkSuccessor(node);  <br>        &#125;  <br>        node.next = node; <span class="hljs-comment">// help GC  </span><br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h4 id="锁超时"><a href="#锁超时" class="headerlink" title="锁超时"></a>锁超时</h4><h5 id="基本使用-4"><a href="#基本使用-4" class="headerlink" title="基本使用"></a>基本使用</h5><p><code>public boolean tryLock()</code>：尝试获取锁，获取到返回 true，获取不到直接放弃，不进入阻塞队列</p><p><code>public boolean tryLock(long timeout, TimeUnit unit)</code>：在给定时间内获取锁，获取不到就退出</p><p>注意：tryLock 期间也可以被打断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();  <br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            <span class="hljs-keyword">if</span> (!lock.tryLock(<span class="hljs-number">2</span>, TimeUnit.SECONDS)) &#123;  <br>                System.out.println(<span class="hljs-string">&quot;获取不到锁&quot;</span>);  <br>                <span class="hljs-keyword">return</span>;  <br>            &#125;  <br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>            System.out.println(<span class="hljs-string">&quot;被打断，获取不到锁&quot;</span>);  <br>            <span class="hljs-keyword">return</span>;  <br>        &#125;  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            log.debug(<span class="hljs-string">&quot;获取到锁&quot;</span>);  <br>        &#125; <span class="hljs-keyword">finally</span> &#123;  <br>            lock.unlock();  <br>        &#125;  <br>    &#125;, <span class="hljs-string">&quot;t1&quot;</span>);  <br>    lock.lock();  <br>    System.out.println(<span class="hljs-string">&quot;主线程获取到锁&quot;</span>);  <br>    t1.start();  <br>      <br>    Thread.sleep(<span class="hljs-number">1000</span>);  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;主线程释放了锁&quot;</span>);  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        lock.unlock();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="实现原理-3"><a href="#实现原理-3" class="headerlink" title="实现原理"></a>实现原理</h5><ul><li><p>成员变量：指定超时限制的阈值，小于该值的线程不会被挂起</p><p>  <code>static final long spinForTimeoutThreshold = 1000L;</code></p><p>  超时时间设置的小于该值，就会被禁止挂起，因为阻塞在唤醒的成本太高，不如选择自旋空转</p></li><li><p>tryLock()</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span> &#123;     <br>    <span class="hljs-comment">// 只尝试一次  </span><br>    <span class="hljs-keyword">return</span> sync.nonfairTryAcquire(<span class="hljs-number">1</span>);  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>tryLock(long timeout, TimeUnit unit)</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquireNanos</span><span class="hljs-params">(<span class="hljs-type">int</span> arg, <span class="hljs-type">long</span> nanosTimeout)</span> &#123;  <br>    <span class="hljs-keyword">if</span> (Thread.interrupted())          <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();      <br>    <span class="hljs-comment">// tryAcquire 尝试一次  </span><br>    <span class="hljs-keyword">return</span> tryAcquire(arg) || doAcquireNanos(arg, nanosTimeout);  <br>&#125;  <br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;      <br>    <span class="hljs-keyword">return</span> nonfairTryAcquire(acquires);  <br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">doAcquireNanos</span><span class="hljs-params">(<span class="hljs-type">int</span> arg, <span class="hljs-type">long</span> nanosTimeout)</span> &#123;      <br>    <span class="hljs-keyword">if</span> (nanosTimeout &lt;= <span class="hljs-number">0L</span>)  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>    <span class="hljs-comment">// 获取最后期限的时间戳  </span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> System.nanoTime() + nanosTimeout;  <br>    <span class="hljs-comment">//...  </span><br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-keyword">for</span> (;;) &#123;  <br>            <span class="hljs-comment">//...  </span><br>            <span class="hljs-comment">// 计算还需等待的时间  </span><br>            nanosTimeout = deadline - System.nanoTime();  <br>            <span class="hljs-keyword">if</span> (nanosTimeout &lt;= <span class="hljs-number">0L</span>)<span class="hljs-comment">//时间已到       </span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;  <br>                <span class="hljs-comment">// 如果 nanosTimeout 大于该值，才有阻塞的意义，否则直接自旋会好点  </span><br>                nanosTimeout &gt; spinForTimeoutThreshold)  <br>                LockSupport.parkNanos(<span class="hljs-built_in">this</span>, nanosTimeout);  <br>            <span class="hljs-comment">// 【被打断会报异常】  </span><br>            <span class="hljs-keyword">if</span> (Thread.interrupted())  <br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();  <br>        &#125;      <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h5 id="哲学家就餐"><a href="#哲学家就餐" class="headerlink" title="哲学家就餐"></a>哲学家就餐</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-string">&quot;1&quot;</span>);<span class="hljs-comment">//...  </span><br>    <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-string">&quot;5&quot;</span>);  <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;苏格拉底&quot;</span>, c1, c2).start();  <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;柏拉图&quot;</span>, c2, c3).start();  <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;亚里士多德&quot;</span>, c3, c4).start();  <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;赫拉克利特&quot;</span>, c4, c5).start();      <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;阿基米德&quot;</span>, c5, c1).start();  <br>&#125;  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Philosopher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;  <br>    Chopstick left;  <br>    Chopstick right;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;  <br>            <span class="hljs-comment">// 尝试获得左手筷子  </span><br>            <span class="hljs-keyword">if</span> (left.tryLock()) &#123;  <br>                <span class="hljs-keyword">try</span> &#123;  <br>                    <span class="hljs-comment">// 尝试获得右手筷子  </span><br>                    <span class="hljs-keyword">if</span> (right.tryLock()) &#123;  <br>                        <span class="hljs-keyword">try</span> &#123;  <br>                            System.out.println(<span class="hljs-string">&quot;eating...&quot;</span>);  <br>                            Thread.sleep(<span class="hljs-number">1000</span>);  <br>                        &#125; <span class="hljs-keyword">finally</span> &#123;  <br>                            right.unlock();  <br>                        &#125;  <br>                    &#125;  <br>                &#125; <span class="hljs-keyword">finally</span> &#123;  <br>                    left.unlock();  <br>                &#125;  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>&#125;  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Chopstick</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ReentrantLock</span> &#123;  <br>    String name;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Chopstick</span><span class="hljs-params">(String name)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.name = name;  <br>    &#125;  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;筷子&#123;&quot;</span> + name + <span class="hljs-string">&#x27;&#125;&#x27;</span>;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><h5 id="基本使用-5"><a href="#基本使用-5" class="headerlink" title="基本使用"></a>基本使用</h5><p>synchronized 的条件变量，是当条件不满足时进入 WaitSet 等待；ReentrantLock 的条件变量比 synchronized 强大之处在于支持多个条件变量</p><p>ReentrantLock 类获取 Condition 对象：<code>public Condition newCondition()</code></p><p>Condition 类 API：</p><ul><li><p><code>void await()</code>：当前线程从运行状态进入等待状态，释放锁</p></li><li><p><code>void signal()</code>：唤醒一个等待在 Condition 上的线程，但是必须获得与该 Condition 相关的锁</p></li></ul><p>使用流程：</p><ul><li><p><strong>await &#x2F; signal 前需要获得锁</strong></p></li><li><p>await 执行后，会释放锁进入 ConditionObject 等待</p></li><li><p>await 的线程被唤醒去重新竞争 lock 锁</p></li><li><p><strong>线程在条件队列被打断会抛出中断异常</strong></p></li><li><p>竞争 lock 锁成功后，从 await 后继续执行</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;      <br>    <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();  <br>    <span class="hljs-comment">//创建一个新的条件变量  </span><br>    <span class="hljs-type">Condition</span> <span class="hljs-variable">condition1</span> <span class="hljs-operator">=</span> lock.newCondition();  <br>    <span class="hljs-type">Condition</span> <span class="hljs-variable">condition2</span> <span class="hljs-operator">=</span> lock.newCondition();  <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            lock.lock();  <br>            System.out.println(<span class="hljs-string">&quot;进入等待&quot;</span>);  <br>            <span class="hljs-comment">//进入休息室等待  </span><br>            condition1.await();  <br>            System.out.println(<span class="hljs-string">&quot;被唤醒了&quot;</span>);  <br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>            e.printStackTrace();  <br>        &#125; <span class="hljs-keyword">finally</span> &#123;  <br>            lock.unlock();  <br>        &#125;      <br>    &#125;).start();  <br>    Thread.sleep(<span class="hljs-number">1000</span>);  <br>    <span class="hljs-comment">//叫醒  </span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>        <span class="hljs-keyword">try</span> &#123;              <br>            lock.lock();  <br>            <span class="hljs-comment">//唤醒  </span><br>            condition2.signal();  <br>        &#125; <span class="hljs-keyword">finally</span> &#123;  <br>            lock.unlock();  <br>        &#125;  <br>    &#125;).start();  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="实现原理-4"><a href="#实现原理-4" class="headerlink" title="实现原理"></a>实现原理</h5><h6 id="await"><a href="#await" class="headerlink" title="await"></a>await</h6><p>总体流程是将 await 线程包装成 node 节点放入 ConditionObject 的条件队列，如果被唤醒就将 node 转移到 AQS 的执行阻塞队列，等待获取锁，<strong>每个 Condition 对象都包含一个等待队列</strong></p><ul><li><p>开始 Thread-0 持有锁，调用 await，线程进入 ConditionObject 等待，直到被唤醒或打断，调用 await 方法的线程都是持锁状态的，所以说逻辑里<strong>不存在并发</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>     <span class="hljs-comment">// 判断当前线程是否是中断状态，是就直接给个中断异常  </span><br>    <span class="hljs-keyword">if</span> (Thread.interrupted())  <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();  <br>    <span class="hljs-comment">// 将调用 await 的线程包装成 Node，添加到条件队列并返回  </span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addConditionWaiter();  <br>    <span class="hljs-comment">// 完全释放节点持有的锁，因为其他线程唤醒当前线程的前提是【持有锁】  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> fullyRelease(node);  <br>      <br>    <span class="hljs-comment">// 设置打断模式为没有被打断，状态码为 0  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">interruptMode</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br>      <br>    <span class="hljs-comment">// 如果该节点还没有转移至 AQS 阻塞队列, park 阻塞，等待进入阻塞队列  </span><br>    <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;  <br>        LockSupport.park(<span class="hljs-built_in">this</span>);  <br>        <span class="hljs-comment">// 如果被打断，退出等待队列，对应的 node 【也会被迁移到阻塞队列】尾部，状态设置为 0  </span><br>        <span class="hljs-keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number">0</span>)  <br>            <span class="hljs-keyword">break</span>;  <br>    &#125;  <br>    <span class="hljs-comment">// 逻辑到这说明当前线程退出等待队列，进入【阻塞队列】  </span><br>      <br>    <span class="hljs-comment">// 尝试枪锁，释放了多少锁就【重新获取多少锁】，获取锁成功判断打断模式  </span><br>    <span class="hljs-keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)  <br>        interruptMode = REINTERRUPT;  <br>      <br>    <span class="hljs-comment">// node 在条件队列时 如果被外部线程中断唤醒，会加入到阻塞队列，但是并未设 nextWaiter = null  </span><br>    <span class="hljs-keyword">if</span> (node.nextWaiter != <span class="hljs-literal">null</span>)  <br>        <span class="hljs-comment">// 清理条件队列内所有已取消的 Node  </span><br>        unlinkCancelledWaiters();  <br>    <span class="hljs-comment">// 条件成立说明挂起期间发生过中断  </span><br>    <span class="hljs-keyword">if</span> (interruptMode != <span class="hljs-number">0</span>)  <br>        <span class="hljs-comment">// 应用打断模式  </span><br>        reportInterruptAfterWait(interruptMode);  <br>&#125;<br><br><span class="hljs-comment">// 打断模式 - 在退出等待时重新设置打断状态  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">REINTERRUPT</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;  <br><span class="hljs-comment">// 打断模式 - 在退出等待时抛出异常  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">THROW_IE</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041900663.png"></p></li><li><p><strong>创建新的 Node 状态为 -2（Node.CONDITION）</strong>，关联 Thread-0，加入等待队列尾部</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">addConditionWaiter</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">// 获取当前条件队列的尾节点的引用，保存到局部变量 t 中  </span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> lastWaiter;  <br>    <span class="hljs-comment">// 当前队列中不是空，并且节点的状态不是 CONDITION（-2），说明当前节点发生了中断  </span><br>    <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;  <br>        <span class="hljs-comment">// 清理条件队列内所有已取消的 Node  </span><br>        unlinkCancelledWaiters();  <br>        <span class="hljs-comment">// 清理完成重新获取 尾节点 的引用  </span><br>        t = lastWaiter;  <br>    &#125;  <br>    <span class="hljs-comment">// 创建一个关联当前线程的新 node, 设置状态为 CONDITION(-2)，添加至队列尾部  </span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Thread.currentThread(), Node.CONDITION);  <br>    <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>)  <br>        firstWaiter = node;<span class="hljs-comment">// 空队列直接放在队首【不用CAS因为执行线程是持锁线程，并发安全】  </span><br>    <span class="hljs-keyword">else</span>  <br>        t.nextWaiter = node;<span class="hljs-comment">// 非空队列队尾追加  </span><br>    lastWaiter = node;<span class="hljs-comment">// 更新队尾的引用  </span><br>    <span class="hljs-keyword">return</span> node;  <br>&#125;<br><br><span class="hljs-comment">// 清理条件队列内所有已取消（不是CONDITION）的 node，【链表删除的逻辑】  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlinkCancelledWaiters</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">// 从头节点开始遍历【FIFO】  </span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> firstWaiter;  <br>    <span class="hljs-comment">// 指向正常的 CONDITION 节点  </span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">trail</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;  <br>    <span class="hljs-comment">// 等待队列不空  </span><br>    <span class="hljs-keyword">while</span> (t != <span class="hljs-literal">null</span>) &#123;  <br>        <span class="hljs-comment">// 获取当前节点的后继节点  </span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> t.nextWaiter;  <br>        <span class="hljs-comment">// 判断 t 节点是不是 CONDITION 节点，条件队列内不是 CONDITION 就不是正常的  </span><br>        <span class="hljs-keyword">if</span> (t.waitStatus != Node.CONDITION) &#123;   <br>            <span class="hljs-comment">// 不是正常节点，需要 t 与下一个节点断开  </span><br>            t.nextWaiter = <span class="hljs-literal">null</span>;  <br>            <span class="hljs-comment">// 条件成立说明遍历到的节点还未碰到过正常节点  </span><br>            <span class="hljs-keyword">if</span> (trail == <span class="hljs-literal">null</span>)  <br>                <span class="hljs-comment">// 更新 firstWaiter 指针为下个节点  </span><br>                firstWaiter = next;  <br>            <span class="hljs-keyword">else</span>  <br>                <span class="hljs-comment">// 让上一个正常节点指向 当前取消节点的 下一个节点，【删除非正常的节点】  </span><br>                trail.nextWaiter = next;  <br>            <span class="hljs-comment">// t 是尾节点了，更新 lastWaiter 指向最后一个正常节点  </span><br>            <span class="hljs-keyword">if</span> (next == <span class="hljs-literal">null</span>)  <br>                lastWaiter = trail;  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            <span class="hljs-comment">// trail 指向的是正常节点   </span><br>            trail = t;  <br>        &#125;  <br>        <span class="hljs-comment">// 把 t.next 赋值给 t，循环遍历  </span><br>        t = next;   <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>接下来 Thread-0 进入 AQS 的 fullyRelease 流程，释放同步器上的锁</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// 线程可能重入，需要将 state 全部释放  </span><br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fullyRelease</span><span class="hljs-params">(Node node)</span> &#123;  <br>    <span class="hljs-comment">// 完全释放锁是否成功，false 代表成功  </span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-comment">// 获取当前线程所持有的 state 值总数  </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> getState();  <br>        <span class="hljs-comment">// release -&gt; tryRelease 解锁重入锁  </span><br>        <span class="hljs-keyword">if</span> (release(savedState)) &#123;  <br>            <span class="hljs-comment">// 释放成功  </span><br>            failed = <span class="hljs-literal">false</span>;  <br>            <span class="hljs-comment">// 返回解锁的深度  </span><br>            <span class="hljs-keyword">return</span> savedState;  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            <span class="hljs-comment">// 解锁失败抛出异常  </span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();  <br>        &#125;  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        <span class="hljs-comment">// 没有释放成功，将当前 node 设置为取消状态  </span><br>        <span class="hljs-keyword">if</span> (failed)  <br>            node.waitStatus = Node.CANCELLED;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>fullyRelease 中会 unpark AQS 队列中的下一个节点竞争锁，假设 Thread-1 竞争成功</p><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041901643.png"></p></li><li><p>Thread-0 进入 isOnSyncQueue 逻辑判断节点<strong>是否移动到阻塞队列</strong>，没有就 park 阻塞 Thread-0</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isOnSyncQueue</span><span class="hljs-params">(Node node)</span> &#123;  <br>    <span class="hljs-comment">// node 的状态是 CONDITION，signal 方法是先修改状态再迁移，所以前驱节点为空证明还【没有完成迁移】  </span><br>    <span class="hljs-keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="hljs-literal">null</span>)  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>    <span class="hljs-comment">// 说明当前节点已经成功入队到阻塞队列，且当前节点后面已经有其它 node，因为条件队列的 next 指针为 null  </span><br>    <span class="hljs-keyword">if</span> (node.next != <span class="hljs-literal">null</span>)  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br><span class="hljs-comment">// 说明【可能在阻塞队列，但是是尾节点】  </span><br>    <span class="hljs-comment">// 从阻塞队列的尾节点开始向前【遍历查找 node】，如果查找到返回 true，查找不到返回 false  </span><br>    <span class="hljs-keyword">return</span> findNodeFromTail(node);  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>await 线程 park 后如果被 unpark 或者被打断，都会进入 checkInterruptWhileWaiting 判断线程是否被打断：<strong>在条件队列被打断的线程需要抛出异常</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">checkInterruptWhileWaiting</span><span class="hljs-params">(Node node)</span> &#123;  <br>    <span class="hljs-comment">// Thread.interrupted() 返回当前线程中断标记位，并且重置当前标记位 为 false  </span><br>    <span class="hljs-comment">// 如果被中断了，根据是否在条件队列被中断的，设置中断状态码  </span><br>    <span class="hljs-keyword">return</span> Thread.interrupted() ?(transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) : <span class="hljs-number">0</span>;  <br>&#125;<br><br><span class="hljs-comment">// 这个方法只有在线程是被打断唤醒时才会调用  </span><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">transferAfterCancelledWait</span><span class="hljs-params">(Node node)</span> &#123;  <br>    <span class="hljs-comment">// 条件成立说明当前node一定是在条件队列内，因为 signal 迁移节点到阻塞队列时，会将节点的状态修改为 0  </span><br>    <span class="hljs-keyword">if</span> (compareAndSetWaitStatus(node, Node.CONDITION, <span class="hljs-number">0</span>)) &#123;  <br>        <span class="hljs-comment">// 把【中断唤醒的 node 加入到阻塞队列中】  </span><br>        enq(node);  <br>        <span class="hljs-comment">// 表示是在条件队列内被中断了，设置为 THROW_IE 为 -1  </span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//执行到这里的情况：  </span><br>    <span class="hljs-comment">//1.当前node已经被外部线程调用 signal 方法将其迁移到 阻塞队列 内了  </span><br>    <span class="hljs-comment">//2.当前node正在被外部线程调用 signal 方法将其迁移至 阻塞队列 进行中状态  </span><br>      <br>    <span class="hljs-comment">// 如果当前线程还没到阻塞队列，一直释放 CPU  </span><br>    <span class="hljs-keyword">while</span> (!isOnSyncQueue(node))  <br>        Thread.yield();  <br>  <br>    <span class="hljs-comment">// 表示当前节点被中断唤醒时不在条件队列了，设置为 REINTERRUPT 为 1  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>最后开始处理中断状态：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reportInterruptAfterWait</span><span class="hljs-params">(<span class="hljs-type">int</span> interruptMode)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>    <span class="hljs-comment">// 条件成立说明【在条件队列内发生过中断，此时 await 方法抛出中断异常】  </span><br>    <span class="hljs-keyword">if</span> (interruptMode == THROW_IE)  <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();  <br>  <br>    <span class="hljs-comment">// 条件成立说明【在条件队列外发生的中断，此时设置当前线程的中断标记位为 true】  </span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (interruptMode == REINTERRUPT)  <br>        <span class="hljs-comment">// 进行一次自己打断，产生中断的效果  </span><br>        selfInterrupt();  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h6 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h6><ul><li><p>假设 Thread-1 要来唤醒 Thread-0，进入 ConditionObject 的 doSignal 流程，<strong>取得等待队列中第一个 Node</strong>，即 Thread-0 所在 Node，必须持有锁才能唤醒, 因此 doSignal 内线程安全</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">signal</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">// 判断调用 signal 方法的线程是否是独占锁持有线程  </span><br>    <span class="hljs-keyword">if</span> (!isHeldExclusively())  <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();  <br>    <span class="hljs-comment">// 获取条件队列中第一个 Node  </span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> firstWaiter;  <br>    <span class="hljs-comment">// 不为空就将第该节点【迁移到阻塞队列】  </span><br>    <span class="hljs-keyword">if</span> (first != <span class="hljs-literal">null</span>)  <br>        doSignal(first);  <br>&#125;<br><br><span class="hljs-comment">// 唤醒 - 【将没取消的第一个节点转移至 AQS 队列尾部】  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSignal</span><span class="hljs-params">(Node first)</span> &#123;  <br>    <span class="hljs-keyword">do</span> &#123;  <br>        <span class="hljs-comment">// 成立说明当前节点的下一个节点是 null，当前节点是尾节点了，队列中只有当前一个节点了  </span><br>        <span class="hljs-keyword">if</span> ((firstWaiter = first.nextWaiter) == <span class="hljs-literal">null</span>)  <br>            lastWaiter = <span class="hljs-literal">null</span>;  <br>        first.nextWaiter = <span class="hljs-literal">null</span>;  <br>    <span class="hljs-comment">// 将等待队列中的 Node 转移至 AQS 队列，不成功且还有节点则继续循环  </span><br>    &#125; <span class="hljs-keyword">while</span> (!transferForSignal(first) &amp;&amp; (first = firstWaiter) != <span class="hljs-literal">null</span>);  <br>&#125;  <br>  <br><span class="hljs-comment">// signalAll() 会调用这个函数，唤醒所有的节点  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSignalAll</span><span class="hljs-params">(Node first)</span> &#123;  <br>    lastWaiter = firstWaiter = <span class="hljs-literal">null</span>;  <br>    <span class="hljs-keyword">do</span> &#123;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> first.nextWaiter;  <br>        first.nextWaiter = <span class="hljs-literal">null</span>;  <br>        transferForSignal(first);  <br>        first = next;  <br>    <span class="hljs-comment">// 唤醒所有的节点，都放到阻塞队列中  </span><br>    &#125; <span class="hljs-keyword">while</span> (first != <span class="hljs-literal">null</span>);  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>执行 transferForSignal，<strong>先将节点的 waitStatus 改为 0，然后加入 AQS 阻塞队列尾部</strong>，将 Thread-3 的 waitStatus 改为 -1</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// 如果节点状态是取消, 返回 false 表示转移失败, 否则转移成功  </span><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">transferForSignal</span><span class="hljs-params">(Node node)</span> &#123;  <br>    <span class="hljs-comment">// CAS 修改当前节点的状态，修改为 0，因为当前节点马上要迁移到阻塞队列了  </span><br>    <span class="hljs-comment">// 如果状态已经不是 CONDITION, 说明线程被取消（await 释放全部锁失败）或者被中断（可打断 cancelAcquire）  </span><br>    <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="hljs-number">0</span>))  <br>        <span class="hljs-comment">// 返回函数调用处继续寻找下一个节点  </span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>      <br>    <span class="hljs-comment">// 【先改状态，再进行迁移】  </span><br>    <span class="hljs-comment">// 将当前 node 入阻塞队列，p 是当前节点在阻塞队列的【前驱节点】  </span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> enq(node);  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> p.waitStatus;  <br>      <br>    <span class="hljs-comment">// 如果前驱节点被取消或者不能设置状态为 Node.SIGNAL，就 unpark 取消当前节点线程的阻塞状态,   </span><br>    <span class="hljs-comment">// 让 thread-0 线程竞争锁，重新同步状态  </span><br>    <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))  <br>        LockSupport.unpark(node.thread);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041902380.png"></p></li><li><p>Thread-1 释放锁，进入 unlock 流程</p></li></ul><hr><h3 id="ReadWrite"><a href="#ReadWrite" class="headerlink" title="ReadWrite"></a>ReadWrite</h3><h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><p>独占锁：指该锁一次只能被一个线程所持有，对 ReentrantLock 和 Synchronized 而言都是独占锁</p><p>共享锁：指该锁可以被多个线程锁持有</p><p>ReentrantReadWriteLock 其<strong>读锁是共享锁，写锁是独占锁</strong></p><p>作用：多个线程同时读一个资源类没有任何问题，为了满足并发量，读取共享资源应该同时进行，但是如果一个线程想去写共享资源，就不应该再有其它线程可以对该资源进行读或写</p><p>使用规则：</p><ul><li><p>加锁解锁格式：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">r.lock();  <br><span class="hljs-keyword">try</span> &#123;  <br>    <span class="hljs-comment">// 临界区  </span><br>&#125; <span class="hljs-keyword">finally</span> &#123;  <br>r.unlock();  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>读-读能共存、读-写不能共存、写-写不能共存</p></li><li><p>读锁不支持条件变量</p></li><li><p><strong>重入时升级不支持</strong>：持有读锁的情况下去获取写锁会导致获取写锁永久等待，需要先释放读，再去获得写</p></li><li><p><strong>重入时降级支持</strong>：持有写锁的情况下去获取读锁，造成只有当前线程会持有读锁，因为写锁会互斥其他的锁</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><br>w.lock();  <br><span class="hljs-keyword">try</span> &#123;  <br>    r.lock();<span class="hljs-comment">// 降级为读锁, 释放写锁, 这样能够让其它线程读取缓存  </span><br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-comment">// ...  </span><br>    &#125; <span class="hljs-keyword">finally</span>&#123;  <br>    w.unlock();<span class="hljs-comment">// 要在写锁释放之前获取读锁  </span><br>    &#125;  <br>&#125; <span class="hljs-keyword">finally</span>&#123;  <br>r.unlock();  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>构造方法：</p><ul><li><p><code>public ReentrantReadWriteLock()</code>：默认构造方法，非公平锁</p></li><li><p><code>public ReentrantReadWriteLock(boolean fair)</code>：true 为公平锁</p></li></ul><p>常用API：</p><ul><li><p><code>public ReentrantReadWriteLock.ReadLock readLock()</code>：返回读锁</p></li><li><p><code>public ReentrantReadWriteLock.WriteLock writeLock()</code>：返回写锁</p></li><li><p><code>public void lock()</code>：加锁</p></li><li><p><code>public void unlock()</code>：解锁</p></li><li><p><code>public boolean tryLock()</code>：尝试获取锁</p></li></ul><p>读读并发：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    <span class="hljs-type">ReentrantReadWriteLock</span> <span class="hljs-variable">rw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantReadWriteLock</span>();  <br>    ReentrantReadWriteLock.<span class="hljs-type">ReadLock</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> rw.readLock();  <br>    ReentrantReadWriteLock.<span class="hljs-type">WriteLock</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> rw.writeLock();  <br>  <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>        r.lock();  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            Thread.sleep(<span class="hljs-number">2000</span>);  <br>            System.out.println(<span class="hljs-string">&quot;Thread 1 running &quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());  <br>        &#125; <span class="hljs-keyword">finally</span> &#123;  <br>            r.unlock();  <br>        &#125;  <br>    &#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();  <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>        r.lock();  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            Thread.sleep(<span class="hljs-number">2000</span>);  <br>            System.out.println(<span class="hljs-string">&quot;Thread 2 running &quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());  <br>        &#125; <span class="hljs-keyword">finally</span> &#123;  <br>            r.unlock();  <br>        &#125;  <br>    &#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="缓存应用"><a href="#缓存应用" class="headerlink" title="缓存应用"></a>缓存应用</h4><p>缓存更新时，是先清缓存还是先更新数据库</p><ul><li><p>先清缓存：可能造成刚清理缓存还没有更新数据库，线程直接查询了数据库更新过期数据到缓存</p></li><li><p>先更新据库：可能造成刚更新数据库，还没清空缓存就有线程从缓存拿到了旧数据</p></li><li><p>补充情况：查询线程 A 查询数据时恰好缓存数据由于时间到期失效，或是第一次查询</p><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041905401.png"></p></li></ul><p>可以使用读写锁进行操作</p><hr><h4 id="实现原理-5"><a href="#实现原理-5" class="headerlink" title="实现原理"></a>实现原理</h4><h5 id="成员属性-5"><a href="#成员属性-5" class="headerlink" title="成员属性"></a>成员属性</h5><p>读写锁用的是同一个 Sycn 同步器，因此等待队列、state 等也是同一个，原理与 ReentrantLock 加锁相比没有特殊之处，不同是<strong>写锁状态占了 state 的低 16 位，而读锁使用的是 state 的高 16 位</strong></p><ul><li><p>读写锁：</p><p>  <code>private final ReentrantReadWriteLock.ReadLock readerLock;</code><br>  <code>private final ReentrantReadWriteLock.WriteLock writerLock;</code></p></li><li><p>构造方法：默认是非公平锁，可以指定参数创建公平锁</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantReadWriteLock</span><span class="hljs-params">(<span class="hljs-type">boolean</span> fair)</span> &#123;  <br>    <span class="hljs-comment">// true 为公平锁  </span><br>    sync = fair ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">FairSync</span>() : <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();  <br>    <span class="hljs-comment">// 这两个 lock 共享同一个 sync 实例，都是由 ReentrantReadWriteLock 的 sync 提供同步实现  </span><br>    readerLock = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReadLock</span>(<span class="hljs-built_in">this</span>);  <br>    writerLock = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WriteLock</span>(<span class="hljs-built_in">this</span>);  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>Sync 类的属性：</p><ul><li><p>统计变量：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// 用来移位  </span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SHARED_SHIFT</span>   <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;  <br><span class="hljs-comment">// 高16位的1  </span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SHARED_UNIT</span>    <span class="hljs-operator">=</span> (<span class="hljs-number">1</span> &lt;&lt; SHARED_SHIFT);  <br><span class="hljs-comment">// 65535，16个1，代表写锁的最大重入次数  </span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_COUNT</span>      <span class="hljs-operator">=</span> (<span class="hljs-number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="hljs-number">1</span>;  <br><span class="hljs-comment">// 低16位掩码：0b 1111 1111 1111 1111，用来获取写锁重入的次数  </span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">EXCLUSIVE_MASK</span> <span class="hljs-operator">=</span> (<span class="hljs-number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure></li><li><p>获取读写锁的次数：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// 获取读写锁的读锁分配的总次数  </span><br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sharedCount</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>    &#123; <span class="hljs-keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;  <br><span class="hljs-comment">// 写锁（独占）锁的重入次数  </span><br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">exclusiveCount</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span> &#123; <span class="hljs-keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;<br></code></pre></td></tr></table></figure></li><li><p>内部类：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// 记录读锁线程自己的持有读锁的数量（重入次数），因为 state 高16位记录的是全局范围内所有的读线程获取读锁的总量  </span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HoldCounter</span> &#123;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br>    <span class="hljs-comment">// Use id, not reference, to avoid garbage retention  </span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">tid</span> <span class="hljs-operator">=</span> getThreadId(Thread.currentThread());  <br>&#125;  <br><span class="hljs-comment">// 线程安全的存放线程各自的 HoldCounter 对象  </span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalHoldCounter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ThreadLocal</span>&lt;HoldCounter&gt; &#123;  <br>    <span class="hljs-keyword">public</span> HoldCounter <span class="hljs-title function_">initialValue</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HoldCounter</span>();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>内部类实例：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// 当前线程持有的可重入读锁的数量，计数为 0 时删除  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> ThreadLocalHoldCounter readHolds;  <br><span class="hljs-comment">// 记录最后一个获取【读锁】线程的 HoldCounter 对象  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> HoldCounter cachedHoldCounter;<br></code></pre></td></tr></table></figure></li><li><p>首次获取锁：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// 第一个获取读锁的线程  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">firstReader</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;  <br><span class="hljs-comment">// 记录该线程持有的读锁次数（读锁重入次数）  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> firstReaderHoldCount;<br></code></pre></td></tr></table></figure></li><li><p>Sync 构造方法：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><br>Sync() &#123;  <br>    readHolds = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalHoldCounter</span>();  <br>    <span class="hljs-comment">// 确保其他线程的数据可见性，state 是 volatile 修饰的变量，重写该值会将线程本地缓存数据【同步至主存】  </span><br>    setState(getState());   <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h5 id="加锁原理"><a href="#加锁原理" class="headerlink" title="加锁原理"></a>加锁原理</h5><ul><li><p>t1 线程：w.lock（<strong>写锁</strong>），成功上锁 state &#x3D; 0_1</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// lock()  -&gt; sync.acquire(1);  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;  <br>    sync.acquire(<span class="hljs-number">1</span>);  <br>&#125;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;  <br>    <span class="hljs-comment">// 尝试获得写锁，获得写锁失败，将当前线程关联到一个 Node 对象上, 模式为独占模式   </span><br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))  <br>        selfInterrupt();  <br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;  <br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();  <br>    <span class="hljs-comment">// 获得低 16 位, 代表写锁的 state 计数  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> exclusiveCount(c);  <br>    <span class="hljs-comment">// 说明有读锁或者写锁  </span><br>    <span class="hljs-keyword">if</span> (c != <span class="hljs-number">0</span>) &#123;  <br>        <span class="hljs-comment">// c != 0 and w == 0 表示有读锁，【读锁不能升级】，直接返回 false  </span><br>        <span class="hljs-comment">// w != 0 说明有写锁，写锁的拥有者不是自己，获取失败  </span><br>        <span class="hljs-keyword">if</span> (w == <span class="hljs-number">0</span> || current != getExclusiveOwnerThread())  <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>          <br>        <span class="hljs-comment">// 执行到这里只有一种情况：【写锁重入】，所以下面几行代码不存在并发  </span><br>        <span class="hljs-keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)  <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);  <br>        <span class="hljs-comment">// 写锁重入, 获得锁成功，没有并发，所以不使用 CAS  </span><br>        setState(c + acquires);  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    &#125;  <br>      <br>    <span class="hljs-comment">// c == 0，说明没有任何锁，判断写锁是否该阻塞，是 false 就尝试获取锁，失败返回 false  </span><br>    <span class="hljs-keyword">if</span> (writerShouldBlock() || !compareAndSetState(c, c + acquires))  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>    <span class="hljs-comment">// 获得锁成功，设置锁的持有线程为当前线程  </span><br>    setExclusiveOwnerThread(current);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>&#125;  <br><span class="hljs-comment">// 非公平锁 writerShouldBlock 总是返回 false, 无需阻塞  </span><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">writerShouldBlock</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;   <br>&#125;  <br><span class="hljs-comment">// 公平锁会检查 AQS 队列中是否有前驱节点, 没有(false)才去竞争  </span><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">writerShouldBlock</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">return</span> hasQueuedPredecessors();  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>t2 r.lock（<strong>读锁</strong>），进入 tryAcquireShared 流程：</p><ul><li><p>返回 -1 表示失败</p></li><li><p>如果返回 0 表示成功</p></li><li><p>返回正数表示还有多少后继节点支持共享模式，读写锁返回 1</p></li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;  <br>    sync.acquireShared(<span class="hljs-number">1</span>);  <br>&#125;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;  <br>    <span class="hljs-comment">// tryAcquireShared 返回负数, 表示获取读锁失败  </span><br>    <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)  <br>        doAcquireShared(arg);  <br>&#125;<br><br><span class="hljs-comment">// 尝试以共享模式获取  </span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> unused)</span> &#123;  <br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();  <br>    <span class="hljs-comment">// exclusiveCount(c) 代表低 16 位, 写锁的 state，成立说明有线程持有写锁  </span><br>    <span class="hljs-comment">// 写锁的持有者不是当前线程，则获取读锁失败，【写锁允许降级】  </span><br>    <span class="hljs-keyword">if</span> (exclusiveCount(c) != <span class="hljs-number">0</span> &amp;&amp; getExclusiveOwnerThread() != current)  <br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;  <br>      <br>    <span class="hljs-comment">// 高 16 位，代表读锁的 state，共享锁分配出去的总次数  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> sharedCount(c);  <br>    <span class="hljs-comment">// 读锁是否应该阻塞  </span><br>    <span class="hljs-keyword">if</span> (!readerShouldBlock() &amp;&amp;r &lt; MAX_COUNT &amp;&amp;  <br>        compareAndSetState(c, c + SHARED_UNIT)) &#123;<span class="hljs-comment">// 尝试增加读锁计数  </span><br>        <span class="hljs-comment">// 加锁成功  </span><br>        <span class="hljs-comment">// 加锁之前读锁为 0，说明当前线程是第一个读锁线程  </span><br>        <span class="hljs-keyword">if</span> (r == <span class="hljs-number">0</span>) &#123;  <br>            firstReader = current;  <br>            firstReaderHoldCount = <span class="hljs-number">1</span>;  <br>        <span class="hljs-comment">// 第一个读锁线程是自己就发生了读锁重入  </span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (firstReader == current) &#123;  <br>            firstReaderHoldCount++;  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            <span class="hljs-comment">// cachedHoldCounter 设置为当前线程的 holdCounter 对象，即最后一个获取读锁的线程  </span><br>            <span class="hljs-type">HoldCounter</span> <span class="hljs-variable">rh</span> <span class="hljs-operator">=</span> cachedHoldCounter;  <br>            <span class="hljs-comment">// 说明还没设置 rh  </span><br>            <span class="hljs-keyword">if</span> (rh == <span class="hljs-literal">null</span> || rh.tid != getThreadId(current))  <br>                <span class="hljs-comment">// 获取当前线程的锁重入的对象，赋值给 cachedHoldCounter  </span><br>                cachedHoldCounter = rh = readHolds.get();  <br>            <span class="hljs-comment">// 还没重入  </span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rh.count == <span class="hljs-number">0</span>)  <br>                readHolds.set(rh);  <br>            <span class="hljs-comment">// 重入 + 1  </span><br>            rh.count++;  <br>        &#125;  <br>        <span class="hljs-comment">// 读锁加锁成功  </span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <br>    &#125;  <br>    <span class="hljs-comment">// 逻辑到这 应该阻塞，或者 cas 加锁失败  </span><br>    <span class="hljs-comment">// 会不断尝试 for (;;) 获取读锁, 执行过程中无阻塞  </span><br>    <span class="hljs-keyword">return</span> fullTryAcquireShared(current);  <br>&#125;  <br><span class="hljs-comment">// 非公平锁 readerShouldBlock 偏向写锁一些，看 AQS 阻塞队列中第一个节点是否是写锁，是则阻塞，反之不阻塞  </span><br><span class="hljs-comment">// 防止一直有读锁线程，导致写锁线程饥饿  </span><br><span class="hljs-comment">// true 则该阻塞, false 则不阻塞  </span><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">readerShouldBlock</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">return</span> apparentlyFirstQueuedIsExclusive();  <br>&#125;  <br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">readerShouldBlock</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">return</span> hasQueuedPredecessors();  <br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fullTryAcquireShared</span><span class="hljs-params">(Thread current)</span> &#123;  <br>    <span class="hljs-comment">// 当前读锁线程持有的读锁次数对象  </span><br>    <span class="hljs-type">HoldCounter</span> <span class="hljs-variable">rh</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;  <br>    <span class="hljs-keyword">for</span> (;;) &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();  <br>        <span class="hljs-comment">// 说明有线程持有写锁  </span><br>        <span class="hljs-keyword">if</span> (exclusiveCount(c) != <span class="hljs-number">0</span>) &#123;  <br>            <span class="hljs-comment">// 写锁不是自己则获取锁失败  </span><br>            <span class="hljs-keyword">if</span> (getExclusiveOwnerThread() != current)  <br>                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;  <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (readerShouldBlock()) &#123;  <br>            <span class="hljs-comment">// 条件成立说明当前线程是 firstReader，当前锁是读忙碌状态，而且当前线程也是读锁重入  </span><br>            <span class="hljs-keyword">if</span> (firstReader == current) &#123;  <br>                <span class="hljs-comment">// assert firstReaderHoldCount &gt; 0;  </span><br>            &#125; <span class="hljs-keyword">else</span> &#123;  <br>                <span class="hljs-keyword">if</span> (rh == <span class="hljs-literal">null</span>) &#123;  <br>                    <span class="hljs-comment">// 最后一个读锁的 HoldCounter  </span><br>                    rh = cachedHoldCounter;  <br>                    <span class="hljs-comment">// 说明当前线程也不是最后一个读锁  </span><br>                    <span class="hljs-keyword">if</span> (rh == <span class="hljs-literal">null</span> || rh.tid != getThreadId(current)) &#123;  <br>                        <span class="hljs-comment">// 获取当前线程的 HoldCounter  </span><br>                        rh = readHolds.get();  <br>                        <span class="hljs-comment">// 条件成立说明 HoldCounter 对象是上一步代码新建的  </span><br>                        <span class="hljs-comment">// 当前线程不是锁重入，在 readerShouldBlock() 返回 true 时需要去排队  </span><br>                        <span class="hljs-keyword">if</span> (rh.count == <span class="hljs-number">0</span>)  <br>                            <span class="hljs-comment">// 防止内存泄漏  </span><br>                            readHolds.remove();  <br>                    &#125;  <br>                &#125;  <br>                <span class="hljs-keyword">if</span> (rh.count == <span class="hljs-number">0</span>)  <br>                    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-comment">// 越界判断  </span><br>        <span class="hljs-keyword">if</span> (sharedCount(c) == MAX_COUNT)  <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);  <br>        <span class="hljs-comment">// 读锁加锁，条件内的逻辑与 tryAcquireShared 相同  </span><br>        <span class="hljs-keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;  <br>            <span class="hljs-keyword">if</span> (sharedCount(c) == <span class="hljs-number">0</span>) &#123;  <br>                firstReader = current;  <br>                firstReaderHoldCount = <span class="hljs-number">1</span>;  <br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (firstReader == current) &#123;  <br>                firstReaderHoldCount++;  <br>            &#125; <span class="hljs-keyword">else</span> &#123;  <br>                <span class="hljs-keyword">if</span> (rh == <span class="hljs-literal">null</span>)  <br>                    rh = cachedHoldCounter;  <br>                <span class="hljs-keyword">if</span> (rh == <span class="hljs-literal">null</span> || rh.tid != getThreadId(current))  <br>                    rh = readHolds.get();  <br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rh.count == <span class="hljs-number">0</span>)  <br>                    readHolds.set(rh);  <br>                rh.count++;  <br>                cachedHoldCounter = rh; <span class="hljs-comment">// cache for release  </span><br>            &#125;  <br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>获取读锁失败，进入 sync.doAcquireShared(1) 流程开始阻塞，首先也是调用 addWaiter 添加节点，不同之处在于节点被设置为 Node.SHARED 模式而非 Node.EXCLUSIVE 模式，注意此时 t2 仍处于活跃状态</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;  <br>    <span class="hljs-comment">// 将当前线程关联到一个 Node 对象上, 模式为共享模式  </span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addWaiter(Node.SHARED);  <br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;  <br>        <span class="hljs-keyword">for</span> (;;) &#123;  <br>            <span class="hljs-comment">// 获取前驱节点  </span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();  <br>            <span class="hljs-comment">// 如果前驱节点就头节点就去尝试获取锁  </span><br>            <span class="hljs-keyword">if</span> (p == head) &#123;  <br>                <span class="hljs-comment">// 再一次尝试获取读锁  </span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> tryAcquireShared(arg);  <br>                <span class="hljs-comment">// r &gt;= 0 表示获取成功  </span><br>                <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;  <br>                    <span class="hljs-comment">//【这里会设置自己为头节点，唤醒相连的后序的共享节点】  </span><br>                    setHeadAndPropagate(node, r);  <br>                    p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC  </span><br>                    <span class="hljs-keyword">if</span> (interrupted)  <br>                        selfInterrupt();  <br>                    failed = <span class="hljs-literal">false</span>;  <br>                    <span class="hljs-keyword">return</span>;  <br>                &#125;  <br>            &#125;  <br>            <span class="hljs-comment">// 是否在获取读锁失败时阻塞       park 当前线程  </span><br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())  <br>                interrupted = <span class="hljs-literal">true</span>;  <br>        &#125;  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        <span class="hljs-keyword">if</span> (failed)  <br>            cancelAcquire(node);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>  如果没有成功，在 doAcquireShared 内 for (;;) 循环一次，shouldParkAfterFailedAcquire 内把前驱节点的 waitStatus 改为 -1，再 for (;;) 循环一次尝试 tryAcquireShared，不成功在 parkAndCheckInterrupt() 处 park</p><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041907782.png"></p></li><li><p>这种状态下，假设又有 t3 r.lock，t4 w.lock，这期间 t1 仍然持有锁，就变成了下面的样子</p><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041907677.png"></p></li></ul><hr><h5 id="解锁原理"><a href="#解锁原理" class="headerlink" title="解锁原理"></a>解锁原理</h5><ul><li><p>t1 w.unlock， 写锁解锁</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">// 释放锁  </span><br>    sync.release(<span class="hljs-number">1</span>);  <br>&#125;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;  <br>    <span class="hljs-comment">// 尝试释放锁  </span><br>    <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;  <br>        <span class="hljs-comment">// 头节点不为空并且不是等待状态不是 0，唤醒后继的非取消节点  </span><br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)  <br>            unparkSuccessor(h);  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>&#125;  <br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;  <br>    <span class="hljs-keyword">if</span> (!isHeldExclusively())  <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> getState() - releases;  <br>    <span class="hljs-comment">// 因为可重入的原因, 写锁计数为 0, 才算释放成功  </span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">free</span> <span class="hljs-operator">=</span> exclusiveCount(nextc) == <span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">if</span> (free)  <br>        setExclusiveOwnerThread(<span class="hljs-literal">null</span>);  <br>    setState(nextc);  <br>    <span class="hljs-keyword">return</span> free;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>唤醒流程 sync.unparkSuccessor，这时 t2 在 doAcquireShared 的 parkAndCheckInterrupt() 处恢复运行，继续循环，执行 tryAcquireShared 成功则让读锁计数加一</p></li><li><p>接下来 t2 调用 setHeadAndPropagate(node, 1)，它原本所在节点被置为头节点；还会检查下一个节点是否是 shared，如果是则调用 doReleaseShared() 将 head 的状态从 -1 改为 0 并唤醒下一个节点，这时 t3 在 doAcquireShared 内 parkAndCheckInterrupt() 处恢复运行，<strong>唤醒连续的所有的共享节点</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setHeadAndPropagate</span><span class="hljs-params">(Node node, <span class="hljs-type">int</span> propagate)</span> &#123;  <br>    <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;   <br>    <span class="hljs-comment">// 设置自己为 head 节点  </span><br>    setHead(node);  <br>    <span class="hljs-comment">// propagate 表示有共享资源（例如共享读锁或信号量），为 0 就没有资源  </span><br>    <span class="hljs-keyword">if</span> (propagate &gt; <span class="hljs-number">0</span> || h == <span class="hljs-literal">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span> ||  <br>        (h = head) == <span class="hljs-literal">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span>) &#123;  <br>        <span class="hljs-comment">// 获取下一个节点  </span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;  <br>        <span class="hljs-comment">// 如果当前是最后一个节点，或者下一个节点是【等待共享读锁的节点】  </span><br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.isShared())  <br>            <span class="hljs-comment">// 唤醒后继节点  </span><br>            doReleaseShared();  <br>    &#125;  <br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doReleaseShared</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">// 如果 head.waitStatus == Node.SIGNAL ==&gt; 0 成功, 下一个节点 unpark  </span><br><span class="hljs-comment">// 如果 head.waitStatus == 0 ==&gt; Node.PROPAGATE  </span><br>    <span class="hljs-keyword">for</span> (;;) &#123;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;  <br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h != tail) &#123;  <br>            <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> h.waitStatus;  <br>            <span class="hljs-comment">// SIGNAL 唤醒后继  </span><br>            <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;  <br>                <span class="hljs-comment">// 因为读锁共享，如果其它线程也在释放读锁，那么需要将 waitStatus 先改为 0  </span><br>            <span class="hljs-comment">// 防止 unparkSuccessor 被多次执行  </span><br>                <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>))  <br>                    <span class="hljs-keyword">continue</span>;    <br>                <span class="hljs-comment">// 唤醒后继节点  </span><br>                unparkSuccessor(h);  <br>            &#125;  <br>            <span class="hljs-comment">// 如果已经是 0 了，改为 -3，用来解决传播性  </span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp; !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))  <br>                <span class="hljs-keyword">continue</span>;                  <br>        &#125;  <br>        <span class="hljs-comment">// 条件不成立说明被唤醒的节点非常积极，直接将自己设置为了新的 head，  </span><br>        <span class="hljs-comment">// 此时唤醒它的节点（前驱）执行 h == head 不成立，所以不会跳出循环，会继续唤醒新的 head 节点的后继节点  </span><br>        <span class="hljs-keyword">if</span> (h == head)                     <br>            <span class="hljs-keyword">break</span>;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041908507.png"></p></li><li><p>下一个节点不是 shared 了，因此不会继续唤醒 t4 所在节点</p></li><li><p>t2 读锁解锁，进入 sync.releaseShared(1) 中，调用 tryReleaseShared(1) 让计数减一，但计数还不为零，t3 同样让计数减一，计数为零，进入doReleaseShared() 将头节点从 -1 改为 0 并唤醒下一个节点</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;  <br>    sync.releaseShared(<span class="hljs-number">1</span>);  <br>&#125;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">releaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;  <br>    <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;  <br>        doReleaseShared();  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> unused)</span> &#123;  <br>  <br>    <span class="hljs-keyword">for</span> (;;) &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c - SHARED_UNIT;  <br>        <span class="hljs-comment">// 读锁的计数不会影响其它获取读锁线程, 但会影响其它获取写锁线程，计数为 0 才是真正释放  </span><br>        <span class="hljs-keyword">if</span> (compareAndSetState(c, nextc))  <br>            <span class="hljs-comment">// 返回是否已经完全释放了   </span><br>            <span class="hljs-keyword">return</span> nextc == <span class="hljs-number">0</span>;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>t4 在 acquireQueued 中 parkAndCheckInterrupt 处恢复运行，再次 for (;;) 这次自己是头节点的临节点，并且没有其他节点竞争，tryAcquire(1) 成功，修改头结点，流程结束</p><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041909290.png"></p></li></ul><hr><h4 id="Stamped"><a href="#Stamped" class="headerlink" title="Stamped"></a>Stamped</h4><p>StampedLock：读写锁，该类自 JDK 8 加入，是为了进一步优化读性能</p><p>特点：</p><ul><li><p>在使用读锁、写锁时都必须配合戳使用</p></li><li><p>StampedLock 不支持条件变量</p></li><li><p>StampedLock <strong>不支持重入</strong></p></li></ul><p>基本用法</p><ul><li><p>加解读锁：</p><p>  long stamp &#x3D; lock.readLock();<br>  lock.unlockRead(stamp);&#x2F;&#x2F; 类似于 unpark，解指定的锁</p></li><li><p>加解写锁：</p><p>  long stamp &#x3D; lock.writeLock();<br>  lock.unlockWrite(stamp);</p></li><li><p>乐观读，StampedLock 支持 <code>tryOptimisticRead()</code> 方法，读取完毕后做一次<strong>戳校验</strong>，如果校验通过，表示这期间没有其他线程的写操作，数据可以安全使用，如果校验没通过，需要重新获取读锁，保证数据一致性</p><p>  long stamp &#x3D; lock.tryOptimisticRead();<br>  &#x2F;&#x2F; 验戳<br>  if(!lock.validate(stamp)){<br>  &#x2F;&#x2F; 锁升级<br>  }</p></li></ul><p>提供一个数据容器类内部分别使用读锁保护数据的 read() 方法，写锁保护数据的 write() 方法：</p><ul><li><p>读-读可以优化</p></li><li><p>读-写优化读，补加读锁</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>    <span class="hljs-type">DataContainerStamped</span> <span class="hljs-variable">dataContainer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataContainerStamped</span>(<span class="hljs-number">1</span>);  <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>    dataContainer.read(<span class="hljs-number">1000</span>);  <br>    &#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();  <br>    Thread.sleep(<span class="hljs-number">500</span>);  <br>      <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>        dataContainer.write(<span class="hljs-number">1000</span>);  <br>    &#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();  <br>&#125;  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DataContainerStamped</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> data;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">StampedLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StampedLock</span>();  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">int</span> readTime)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>        <span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> lock.tryOptimisticRead();  <br>        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>() + <span class="hljs-string">&quot; optimistic read locking&quot;</span> + stamp);  <br>        Thread.sleep(readTime);  <br>        <span class="hljs-comment">// 戳有效，直接返回数据  </span><br>        <span class="hljs-keyword">if</span> (lock.validate(stamp)) &#123;  <br>            Sout(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>() + <span class="hljs-string">&quot; optimistic read finish...&quot;</span> + stamp);  <br>            <span class="hljs-keyword">return</span> data;  <br>        &#125;  <br>  <br>        <span class="hljs-comment">// 说明其他线程更改了戳，需要锁升级了，从乐观读升级到读锁  </span><br>        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>() + <span class="hljs-string">&quot; updating to read lock&quot;</span> + stamp);  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            stamp = lock.readLock();  <br>            System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>() + <span class="hljs-string">&quot; read lock&quot;</span> + stamp);  <br>            Thread.sleep(readTime);  <br>            System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>() + <span class="hljs-string">&quot; read finish...&quot;</span> + stamp);  <br>            <span class="hljs-keyword">return</span> data;  <br>        &#125; <span class="hljs-keyword">finally</span> &#123;  <br>            System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>() + <span class="hljs-string">&quot; read unlock &quot;</span> +  stamp);  <br>            lock.unlockRead(stamp);  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">int</span> newData)</span> &#123;  <br>        <span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> lock.writeLock();  <br>        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>() + <span class="hljs-string">&quot; write lock &quot;</span> + stamp);  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            Thread.sleep(<span class="hljs-number">2000</span>);  <br>            <span class="hljs-built_in">this</span>.data = newData;  <br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>            e.printStackTrace();  <br>        &#125; <span class="hljs-keyword">finally</span> &#123;  <br>            System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>() + <span class="hljs-string">&quot; write unlock &quot;</span> + stamp);  <br>            lock.unlockWrite(stamp);  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="CountDown"><a href="#CountDown" class="headerlink" title="CountDown"></a>CountDown</h3><h4 id="基本使用-6"><a href="#基本使用-6" class="headerlink" title="基本使用"></a>基本使用</h4><p>CountDownLatch：计数器，用来进行线程同步协作，<strong>等待所有线程完成</strong></p><p>构造器：</p><ul><li><code>public CountDownLatch(int count)</code>：初始化唤醒需要的 down 几步</li></ul><p>常用API：</p><ul><li><p><code>public void await()</code>：让当前线程等待，必须 down 完初始化的数字才可以被唤醒，否则进入无限等待</p></li><li><p><code>public void countDown()</code>：计数器进行减 1（down 1）</p></li></ul><p>应用：同步等待多个 Rest 远程调用结束</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// LOL 10人进入游戏倒计时  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>    <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">latch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">10</span>);  <br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);  <br>    String[] all = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">10</span>];  <br>    <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();  <br>  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++) &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">finalJ</span> <span class="hljs-operator">=</span> j;<span class="hljs-comment">//常量  </span><br>        service.submit(() -&gt; &#123;  <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100</span>; i++) &#123;  <br>                Thread.sleep(random.nextInt(<span class="hljs-number">100</span>));<span class="hljs-comment">//随机休眠  </span><br>                all[finalJ] = i + <span class="hljs-string">&quot;%&quot;</span>;  <br>                System.out.print(<span class="hljs-string">&quot;\r&quot;</span> + Arrays.toString(all));<span class="hljs-comment">// \r代表覆盖  </span><br>            &#125;  <br>            latch.countDown();  <br>        &#125;);  <br>    &#125;  <br>    latch.await();  <br>    System.out.println(<span class="hljs-string">&quot;\n游戏开始&quot;</span>);  <br>    service.shutdown();  <br>&#125;  <br><span class="hljs-comment">/*  </span><br><span class="hljs-comment">[100%, 100%, 100%, 100%, 100%, 100%, 100%, 100%, 100%, 100%]  </span><br><span class="hljs-comment">游戏开始*/</span><br></code></pre></td></tr></table></figure><hr><h4 id="实现原理-6"><a href="#实现原理-6" class="headerlink" title="实现原理"></a>实现原理</h4><p>阻塞等待：</p><ul><li><p>线程调用 await() 等待其他线程完成任务：支持打断</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>    sync.acquireSharedInterruptibly(<span class="hljs-number">1</span>);  <br>&#125;  <br><span class="hljs-comment">// AbstractQueuedSynchronizer#acquireSharedInterruptibly  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireSharedInterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>    <span class="hljs-comment">// 判断线程是否被打断，抛出打断异常  </span><br>    <span class="hljs-keyword">if</span> (Thread.interrupted())  <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();  <br>    <span class="hljs-comment">// 尝试获取共享锁，条件成立说明 state &gt; 0，此时线程入队阻塞等待，等待其他线程获取共享资源  </span><br>    <span class="hljs-comment">// 条件不成立说明 state = 0，此时不需要阻塞线程，直接结束函数调用  </span><br>    <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)  <br>        doAcquireSharedInterruptibly(arg);  <br>&#125;  <br><span class="hljs-comment">// CountDownLatch.Sync#tryAcquireShared  </span><br><span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;  <br>    <span class="hljs-keyword">return</span> (getState() == <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>线程进入 AbstractQueuedSynchronizer#doAcquireSharedInterruptibly 函数阻塞挂起，等待 latch 变为 0：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAcquireSharedInterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>    <span class="hljs-comment">// 将调用latch.await()方法的线程 包装成 SHARED 类型的 node 加入到 AQS 的阻塞队列中  </span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addWaiter(Node.SHARED);  <br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-keyword">for</span> (;;) &#123;  <br>            <span class="hljs-comment">// 获取当前节点的前驱节点  </span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();  <br>            <span class="hljs-comment">// 前驱节点时头节点就可以尝试获取锁  </span><br>            <span class="hljs-keyword">if</span> (p == head) &#123;  <br>                <span class="hljs-comment">// 再次尝试获取锁，获取成功返回 1  </span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> tryAcquireShared(arg);  <br>                <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;  <br>                    <span class="hljs-comment">// 获取锁成功，设置当前节点为 head 节点，并且向后传播  </span><br>                    setHeadAndPropagate(node, r);  <br>                    p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC  </span><br>                    failed = <span class="hljs-literal">false</span>;  <br>                    <span class="hljs-keyword">return</span>;  <br>                &#125;  <br>            &#125;  <br>            <span class="hljs-comment">// 阻塞在这里  </span><br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())  <br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();  <br>        &#125;  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        <span class="hljs-comment">// 阻塞线程被中断后抛出异常，进入取消节点的逻辑  </span><br>        <span class="hljs-keyword">if</span> (failed)  <br>            cancelAcquire(node);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>获取共享锁成功，进入唤醒阻塞队列中与头节点相连的 SHARED 模式的节点：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setHeadAndPropagate</span><span class="hljs-params">(Node node, <span class="hljs-type">int</span> propagate)</span> &#123;  <br>    <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;  <br>    <span class="hljs-comment">// 将当前节点设置为新的 head 节点，前驱节点和持有线程置为 null  </span><br>    setHead(node);  <br><span class="hljs-comment">// propagate = 1，条件一成立  </span><br>    <span class="hljs-keyword">if</span> (propagate &gt; <span class="hljs-number">0</span> || h == <span class="hljs-literal">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span> || (h = head) == <span class="hljs-literal">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span>) &#123;  <br>        <span class="hljs-comment">// 获取当前节点的后继节点  </span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;  <br>        <span class="hljs-comment">// 当前节点是尾节点时 next 为 null，或者后继节点是 SHARED 共享模式  </span><br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.isShared())  <br>            <span class="hljs-comment">// 唤醒所有的等待共享锁的节点  </span><br>            doReleaseShared();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>计数减一：</p><ul><li><p>线程进入 countDown() 完成计数器减一（释放锁）的操作</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">countDown</span><span class="hljs-params">()</span> &#123;  <br>    sync.releaseShared(<span class="hljs-number">1</span>);  <br>&#125;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">releaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;  <br>    <span class="hljs-comment">// 尝试释放共享锁  </span><br>    <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;  <br>        <span class="hljs-comment">// 释放锁成功开始唤醒阻塞节点  </span><br>        doReleaseShared();  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>更新 state 值，每调用一次，state 值减一，当 state -1 正好为 0 时，返回 true</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;  <br>    <span class="hljs-keyword">for</span> (;;) &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();  <br>        <span class="hljs-comment">// 条件成立说明前面【已经有线程触发唤醒操作】了，这里返回 false  </span><br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>)  <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>        <span class="hljs-comment">// 计数器减一  </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c-<span class="hljs-number">1</span>;  <br>        <span class="hljs-keyword">if</span> (compareAndSetState(c, nextc))  <br>            <span class="hljs-comment">// 计数器为 0 时返回 true  </span><br>            <span class="hljs-keyword">return</span> nextc == <span class="hljs-number">0</span>;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>state &#x3D; 0 时，当前线程需要执行<strong>唤醒阻塞节点的任务</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doReleaseShared</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">for</span> (;;) &#123;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;  <br>        <span class="hljs-comment">// 判断队列是否是空队列  </span><br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h != tail) &#123;  <br>            <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> h.waitStatus;  <br>            <span class="hljs-comment">// 头节点的状态为 signal，说明后继节点没有被唤醒过  </span><br>            <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;  <br>                <span class="hljs-comment">// cas 设置头节点的状态为 0，设置失败继续自旋  </span><br>                <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>))  <br>                    <span class="hljs-keyword">continue</span>;  <br>                <span class="hljs-comment">// 唤醒后继节点  </span><br>                unparkSuccessor(h);  <br>            &#125;  <br>            <span class="hljs-comment">// 如果有其他线程已经设置了头节点的状态，重新设置为 PROPAGATE 传播属性  </span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp; !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))  <br>                <span class="hljs-keyword">continue</span>;  <br>        &#125;  <br>        <span class="hljs-comment">// 条件不成立说明被唤醒的节点非常积极，直接将自己设置为了新的head，  </span><br>        <span class="hljs-comment">// 此时唤醒它的节点（前驱）执行 h == head 不成立，所以不会跳出循环，会继续唤醒新的 head 节点的后继节点  </span><br>        <span class="hljs-keyword">if</span> (h == head)  <br>            <span class="hljs-keyword">break</span>;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><h4 id="基本使用-7"><a href="#基本使用-7" class="headerlink" title="基本使用"></a>基本使用</h4><p>CyclicBarrier：循环屏障，用来进行线程协作，等待线程满足某个计数，才能触发自己执行</p><p>常用方法：</p><ul><li><p><code>public CyclicBarrier(int parties, Runnable barrierAction)</code>：用于在线程到达屏障 parties 时，执行 barrierAction</p><ul><li><p>parties：代表多少个线程到达屏障开始触发线程任务</p></li><li><p>barrierAction：线程任务</p></li></ul></li><li><p><code>public int await()</code>：线程调用 await 方法通知 CyclicBarrier 本线程已经到达屏障</p></li></ul><p>与 CountDownLatch 的区别：CyclicBarrier 是可以重用的</p><p>应用：可以实现多线程中，某个任务在等待其他线程执行完毕以后触发</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">2</span>);  <br>    <span class="hljs-type">CyclicBarrier</span> <span class="hljs-variable">barrier</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CyclicBarrier</span>(<span class="hljs-number">2</span>, () -&gt; &#123;  <br>        System.out.println(<span class="hljs-string">&quot;task1 task2 finish...&quot;</span>);  <br>    &#125;);  <br>  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123; <span class="hljs-comment">// 循环重用  </span><br>        service.submit(() -&gt; &#123;  <br>            System.out.println(<span class="hljs-string">&quot;task1 begin...&quot;</span>);  <br>            <span class="hljs-keyword">try</span> &#123;  <br>                Thread.sleep(<span class="hljs-number">1000</span>);  <br>                barrier.await();    <span class="hljs-comment">// 2 - 1 = 1  </span><br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;  <br>                e.printStackTrace();  <br>            &#125;  <br>        &#125;);  <br>  <br>        service.submit(() -&gt; &#123;  <br>            System.out.println(<span class="hljs-string">&quot;task2 begin...&quot;</span>);  <br>            <span class="hljs-keyword">try</span> &#123;  <br>                Thread.sleep(<span class="hljs-number">2000</span>);  <br>                barrier.await();    <span class="hljs-comment">// 1 - 1 = 0  </span><br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;  <br>                e.printStackTrace();  <br>            &#125;  <br>        &#125;);  <br>    &#125;  <br>    service.shutdown();  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="实现原理-7"><a href="#实现原理-7" class="headerlink" title="实现原理"></a>实现原理</h4><h5 id="成员属性-6"><a href="#成员属性-6" class="headerlink" title="成员属性"></a>成员属性</h5><ul><li><p>全局锁：利用可重入锁实现的工具类</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// barrier 实现是依赖于Condition条件队列，condition 条件队列必须依赖lock才能使用  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();  <br><span class="hljs-comment">// 线程挂起实现使用的 condition 队列，当前代所有线程到位，这个条件队列内的线程才会被唤醒  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">trip</span> <span class="hljs-operator">=</span> lock.newCondition();<br></code></pre></td></tr></table></figure></li><li><p>线程数量：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> parties;<span class="hljs-comment">// 代表多少个线程到达屏障开始触发线程任务  </span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> count;<span class="hljs-comment">// 表示当前“代”还有多少个线程未到位，初始值为 parties</span><br></code></pre></td></tr></table></figure></li><li><p>当前代中最后一个线程到位后要执行的事件：</p><p>  <code>private final Runnable barrierCommand;</code></p></li><li><p>代：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// 表示 barrier 对象当前 代  </span><br><span class="hljs-keyword">private</span> <span class="hljs-type">Generation</span> <span class="hljs-variable">generation</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Generation</span>();  <br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Generation</span> &#123;  <br>    <span class="hljs-comment">// 表示当前“代”是否被打破，如果被打破再来到这一代的线程 就会直接抛出 BrokenException 异常  </span><br>    <span class="hljs-comment">// 且在这一代挂起的线程都会被唤醒，然后抛出 BrokerException 异常。  </span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">broken</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>构造方法：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">CyclicBarrie</span><span class="hljs-params">(<span class="hljs-type">int</span> parties, Runnable barrierAction)</span> &#123;  <br>    <span class="hljs-comment">// 因为小于等于 0 的 barrier 没有任何意义  </span><br>    <span class="hljs-keyword">if</span> (parties &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();  <br>  <br>    <span class="hljs-built_in">this</span>.parties = parties;  <br>    <span class="hljs-built_in">this</span>.count = parties;  <br>    <span class="hljs-comment">// 可以为 null  </span><br>    <span class="hljs-built_in">this</span>.barrierCommand = barrierAction;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041913080.png"></p><hr><h5 id="成员方法-5"><a href="#成员方法-5" class="headerlink" title="成员方法"></a>成员方法</h5><ul><li><p>await()：阻塞等待所有线程到位</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, BrokenBarrierException &#123;  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-keyword">return</span> dowait(<span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);  <br>    &#125; <span class="hljs-keyword">catch</span> (TimeoutException toe) &#123;  <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(toe); <span class="hljs-comment">// cannot happen  </span><br>    &#125;  <br>&#125;<br><br><span class="hljs-comment">// timed：表示当前调用await方法的线程是否指定了超时时长，如果 true 表示线程是响应超时的  </span><br><span class="hljs-comment">// nanos：线程等待超时时长，单位是纳秒  </span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dowait</span><span class="hljs-params">(<span class="hljs-type">boolean</span> timed, <span class="hljs-type">long</span> nanos)</span> &#123;  <br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;  <br>    <span class="hljs-comment">// 加锁  </span><br>    lock.lock();  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-comment">// 获取当前代  </span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Generation</span> <span class="hljs-variable">g</span> <span class="hljs-operator">=</span> generation;  <br>​  <br>        <span class="hljs-comment">// 【如果当前代是已经被打破状态，则当前调用await方法的线程，直接抛出Broken异常】  </span><br>        <span class="hljs-keyword">if</span> (g.broken)  <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BrokenBarrierException</span>();  <br>        <span class="hljs-comment">// 如果当前线程被中断了，则打破当前代，然后当前线程抛出中断异常  </span><br>        <span class="hljs-keyword">if</span> (Thread.interrupted()) &#123;  <br>            <span class="hljs-comment">// 设置当前代的状态为 broken 状态，唤醒在 trip 条件队列内的线程  </span><br>            breakBarrier();  <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();  <br>        &#125;  <br>​  <br>        <span class="hljs-comment">// 逻辑到这说明，当前线程中断状态是 false， 当前代的 broken 为 false（未打破状态）  </span><br>          <br>        <span class="hljs-comment">// 假设 parties 给的是 5，那么index对应的值为 4,3,2,1,0  </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> --count;  <br>        <span class="hljs-comment">// 条件成立说明当前线程是最后一个到达 barrier 的线程，【需要开启新代，唤醒阻塞线程】  </span><br>        <span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span>) &#123;  <br>            <span class="hljs-comment">// 栅栏任务启动标记  </span><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">ranAction</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;  <br>            <span class="hljs-keyword">try</span> &#123;  <br>                <span class="hljs-keyword">final</span> <span class="hljs-type">Runnable</span> <span class="hljs-variable">command</span> <span class="hljs-operator">=</span> barrierCommand;  <br>                <span class="hljs-keyword">if</span> (command != <span class="hljs-literal">null</span>)  <br>                    <span class="hljs-comment">// 启动触发的任务  </span><br>                    command.run();  <br>                <span class="hljs-comment">// run()未抛出异常的话，启动标记设置为 true  </span><br>                ranAction = <span class="hljs-literal">true</span>;  <br>                <span class="hljs-comment">// 开启新的一代，这里会【唤醒所有的阻塞队列】  </span><br>                nextGeneration();  <br>                <span class="hljs-comment">// 返回 0 因为当前线程是此代最后一个到达的线程，index == 0  </span><br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>            &#125; <span class="hljs-keyword">finally</span> &#123;  <br>                <span class="hljs-comment">// 如果 command.run() 执行抛出异常的话，会进入到这里  </span><br>                <span class="hljs-keyword">if</span> (!ranAction)  <br>                    breakBarrier();  <br>            &#125;  <br>        &#125;  <br>​  <br>        <span class="hljs-comment">// 自旋，一直到条件满足、当前代被打破、线程被中断，等待超时  </span><br>        <span class="hljs-keyword">for</span> (;;) &#123;  <br>            <span class="hljs-keyword">try</span> &#123;  <br>                <span class="hljs-comment">// 根据是否需要超时等待选择阻塞方法  </span><br>                <span class="hljs-keyword">if</span> (!timed)  <br>                    <span class="hljs-comment">// 当前线程释放掉 lock，【进入到 trip 条件队列的尾部挂起自己】，等待被唤醒  </span><br>                    trip.await();  <br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nanos &gt; <span class="hljs-number">0L</span>)  <br>                    nanos = trip.awaitNanos(nanos);  <br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException ie) &#123;  <br>                <span class="hljs-comment">// 被中断后来到这里的逻辑  </span><br>                  <br>                <span class="hljs-comment">// 当前代没有变化并且没有被打破  </span><br>                <span class="hljs-keyword">if</span> (g == generation &amp;&amp; !g.broken) &#123;  <br>                    <span class="hljs-comment">// 打破屏障  </span><br>                    breakBarrier();  <br>                    <span class="hljs-comment">// node 节点在【条件队列】内收到中断信号时 会抛出中断异常  </span><br>                    <span class="hljs-keyword">throw</span> ie;  <br>                &#125; <span class="hljs-keyword">else</span> &#123;  <br>                    <span class="hljs-comment">// 等待过程中代变化了，完成一次自我打断  </span><br>                    Thread.currentThread().interrupt();  <br>                &#125;  <br>            &#125;  <br>            <span class="hljs-comment">// 唤醒后的线程，【判断当前代已经被打破，线程唤醒后依次抛出 BrokenBarrier 异常】  </span><br>            <span class="hljs-keyword">if</span> (g.broken)  <br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BrokenBarrierException</span>();  <br>​  <br>            <span class="hljs-comment">// 当前线程挂起期间，最后一个线程到位了，然后触发了开启新的一代的逻辑  </span><br>            <span class="hljs-keyword">if</span> (g != generation)  <br>                <span class="hljs-keyword">return</span> index;  <br>            <span class="hljs-comment">// 当前线程 trip 中等待超时，然后主动转移到阻塞队列  </span><br>            <span class="hljs-keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="hljs-number">0L</span>) &#123;  <br>                breakBarrier();  <br>                <span class="hljs-comment">// 抛出超时异常  </span><br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimeoutException</span>();  <br>            &#125;  <br>        &#125;  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        <span class="hljs-comment">// 解锁  </span><br>        lock.unlock();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>breakBarrier()：打破 Barrier 屏障</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">breakBarrier</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">// 将代中的 broken 设置为 true，表示这一代是被打破了，再来到这一代的线程，直接抛出异常  </span><br>    generation.broken = <span class="hljs-literal">true</span>;  <br>    <span class="hljs-comment">// 重置 count 为 parties  </span><br>    count = parties;  <br>    <span class="hljs-comment">// 将在trip条件队列内挂起的线程全部唤醒，唤醒后的线程会检查当前是否是打破的，然后抛出异常  </span><br>    trip.signalAll();  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>nextGeneration()：开启新的下一代</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">nextGeneration</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">// 将在 trip 条件队列内挂起的线程全部唤醒  </span><br>    trip.signalAll();  <br>    <span class="hljs-comment">// 重置 count 为 parties  </span><br>    count = parties;  <br>  <br>    <span class="hljs-comment">// 开启新的一代，使用一个新的generation对象，表示新的一代，新的一代和上一代【没有任何关系】  </span><br>    generation = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Generation</span>();  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><h4 id="基本使用-8"><a href="#基本使用-8" class="headerlink" title="基本使用"></a>基本使用</h4><p>synchronized 可以起到锁的作用，但某个时间段内，只能有一个线程允许执行</p><p>Semaphore（信号量）用来限制能同时访问共享资源的线程上限，非重入锁</p><p>构造方法：</p><ul><li><p><code>public Semaphore(int permits)</code>：permits 表示许可线程的数量（state）</p></li><li><p><code>public Semaphore(int permits, boolean fair)</code>：fair 表示公平性，如果设为 true，下次执行的线程会是等待最久的线程</p></li></ul><p>常用API：</p><ul><li><p><code>public void acquire()</code>：表示获取许可</p></li><li><p><code>public void release()</code>：表示释放许可，acquire() 和 release() 方法之间的代码为同步代码</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    <span class="hljs-comment">// 1.创建Semaphore对象  </span><br>    <span class="hljs-type">Semaphore</span> <span class="hljs-variable">semaphore</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">3</span>);  <br>  <br>    <span class="hljs-comment">// 2. 10个线程同时运行  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;  <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>            <span class="hljs-keyword">try</span> &#123;  <br>                <span class="hljs-comment">// 3. 获取许可  </span><br>                semaphore.acquire();  <br>                sout(Thread.currentThread().getName() + <span class="hljs-string">&quot; running...&quot;</span>);  <br>                Thread.sleep(<span class="hljs-number">1000</span>);  <br>                sout(Thread.currentThread().getName() + <span class="hljs-string">&quot; end...&quot;</span>);  <br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>                e.printStackTrace();  <br>            &#125; <span class="hljs-keyword">finally</span> &#123;  <br>                <span class="hljs-comment">// 4. 释放许可  </span><br>                semaphore.release();  <br>            &#125;  <br>        &#125;).start();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="实现原理-8"><a href="#实现原理-8" class="headerlink" title="实现原理"></a>实现原理</h4><p>加锁流程：</p><ul><li><p>Semaphore 的 permits（state）为 3，这时 5 个线程来获取资源</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Sync(<span class="hljs-type">int</span> permits) &#123;  <br>    setState(permits);  <br>&#125;<br></code></pre></td></tr></table></figure><p>  假设其中 Thread-1，Thread-2，Thread-4 CAS 竞争成功，permits 变为 0，而 Thread-0 和 Thread-3 竞争失败，进入 AQS 队列park 阻塞</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// acquire() -&gt; sync.acquireSharedInterruptibly(1)，可中断  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireSharedInterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;  <br>    <span class="hljs-keyword">if</span> (Thread.interrupted())  <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();  <br>    <span class="hljs-comment">// 尝试获取通行证，获取成功返回 &gt;= 0的值  </span><br>    <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)  <br>        <span class="hljs-comment">// 获取许可证失败，进入阻塞  </span><br>        doAcquireSharedInterruptibly(arg);  <br>&#125;  <br>  <br><span class="hljs-comment">// tryAcquireShared() -&gt; nonfairTryAcquireShared()  </span><br><span class="hljs-comment">// 非公平，公平锁会在循环内 hasQueuedPredecessors()方法判断阻塞队列是否有临头节点(第二个节点)  </span><br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nonfairTryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;  <br>    <span class="hljs-keyword">for</span> (;;) &#123;  <br>        <span class="hljs-comment">// 获取 state ，state 这里【表示通行证】  </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">available</span> <span class="hljs-operator">=</span> getState();  <br>        <span class="hljs-comment">// 计算当前线程获取通行证完成之后，通行证还剩余数量  </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">remaining</span> <span class="hljs-operator">=</span> available - acquires;  <br>        <span class="hljs-comment">// 如果许可已经用完, 返回负数, 表示获取失败,  </span><br>        <span class="hljs-keyword">if</span> (remaining &lt; <span class="hljs-number">0</span> ||  <br>            <span class="hljs-comment">// 许可证足够分配的，如果 cas 重试成功, 返回正数, 表示获取成功  </span><br>            compareAndSetState(available, remaining))  <br>            <span class="hljs-keyword">return</span> remaining;  <br>    &#125;  <br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAcquireSharedInterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;  <br>    <span class="hljs-comment">// 将调用 Semaphore.aquire 方法的线程，包装成 node 加入到 AQS 的阻塞队列中  </span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addWaiter(Node.SHARED);  <br>    <span class="hljs-comment">// 获取标记  </span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-keyword">for</span> (;;) &#123;  <br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();  <br>            <span class="hljs-comment">// 前驱节点是头节点可以再次获取许可  </span><br>            <span class="hljs-keyword">if</span> (p == head) &#123;  <br>                <span class="hljs-comment">// 再次尝试获取许可，【返回剩余的许可证数量】  </span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> tryAcquireShared(arg);  <br>                <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;  <br>                    <span class="hljs-comment">// 成功后本线程出队（AQS）, 所在 Node设置为 head  </span><br>                    <span class="hljs-comment">// r 表示【可用资源数】, 为 0 则不会继续传播  </span><br>                    setHeadAndPropagate(node, r);   <br>                    p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC  </span><br>                    failed = <span class="hljs-literal">false</span>;  <br>                    <span class="hljs-keyword">return</span>;  <br>                &#125;  <br>            &#125;  <br>            <span class="hljs-comment">// 不成功, 设置上一个节点 waitStatus = Node.SIGNAL, 下轮进入 park 阻塞  </span><br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())  <br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();  <br>        &#125;  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        <span class="hljs-comment">// 被打断后进入该逻辑  </span><br>        <span class="hljs-keyword">if</span> (failed)  <br>            cancelAcquire(node);  <br>    &#125;  <br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setHeadAndPropagate</span><span class="hljs-params">(Node node, <span class="hljs-type">int</span> propagate)</span> &#123;      <br>    <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;  <br>    <span class="hljs-comment">// 设置自己为 head 节点  </span><br>    setHead(node);  <br>    <span class="hljs-comment">// propagate 表示有【共享资源】（例如共享读锁或信号量）  </span><br>    <span class="hljs-comment">// head waitStatus == Node.SIGNAL 或 Node.PROPAGATE，doReleaseShared 函数中设置的  </span><br>    <span class="hljs-keyword">if</span> (propagate &gt; <span class="hljs-number">0</span> || h == <span class="hljs-literal">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span> ||  <br>        (h = head) == <span class="hljs-literal">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span>) &#123;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;  <br>        <span class="hljs-comment">// 如果是最后一个节点或者是等待共享读锁的节点，做一次唤醒  </span><br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.isShared())  <br>            doReleaseShared();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041916624.png"></p></li><li><p>这时 Thread-4 释放了 permits，状态如下</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// release() -&gt; releaseShared()  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">releaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;  <br>    <span class="hljs-comment">// 尝试释放锁  </span><br>    <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;  <br>        doReleaseShared();  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    &#125;      <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>&#125;  <br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;      <br>    <span class="hljs-keyword">for</span> (;;) &#123;  <br>        <span class="hljs-comment">// 获取当前锁资源的可用许可证数量  </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> getState();  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> current + releases;  <br>        <span class="hljs-comment">// 索引越界判断  </span><br>        <span class="hljs-keyword">if</span> (next &lt; current)              <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum permit count exceeded&quot;</span>);          <br>        <span class="hljs-comment">// 释放锁  </span><br>        <span class="hljs-keyword">if</span> (compareAndSetState(current, next))              <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;      <br>    &#125;  <br>&#125;  <br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doReleaseShared</span><span class="hljs-params">()</span> &#123;      <br>    <span class="hljs-comment">// PROPAGATE 详解      </span><br>    <span class="hljs-comment">// 如果 head.waitStatus == Node.SIGNAL ==&gt; 0 成功, 下一个节点 unpark  </span><br>    <span class="hljs-comment">// 如果 head.waitStatus == 0 ==&gt; Node.PROPAGATE  </span><br>&#125;<br></code></pre></td></tr></table></figure><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041917776.png"></p></li><li><p>接下来 Thread-0 竞争成功，permits 再次设置为 0，设置自己为 head 节点，并且 unpark 接下来的共享状态的 Thread-3 节点，但由于 permits 是 0，因此 Thread-3 在尝试不成功后再次进入 park 状态</p></li></ul><hr><h4 id="PROPAGATE"><a href="#PROPAGATE" class="headerlink" title="PROPAGATE"></a>PROPAGATE</h4><p>假设存在某次循环中队列里排队的结点情况为 <code>head(-1) → t1(-1) → t2(0)</code>，存在将要释放信号量的 T3 和 T4，释放顺序为先 T3 后 T4</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// 老版本代码  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setHeadAndPropagate</span><span class="hljs-params">(Node node, <span class="hljs-type">int</span> propagate)</span> &#123;      <br>    setHead(node);      <br>    <span class="hljs-comment">// 有空闲资源      </span><br>    <span class="hljs-keyword">if</span> (propagate &gt; <span class="hljs-number">0</span> &amp;&amp; node.waitStatus != <span class="hljs-number">0</span>) &#123;      <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;          <br>        <span class="hljs-comment">// 下一个          </span><br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.isShared())              <br>            unparkSuccessor(node);          <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>正常流程：</p><ul><li><p>T3 调用 releaseShared(1)，直接调用了 unparkSuccessor(head)，head.waitStatus 从 -1 变为 0</p></li><li><p>T1 由于 T3 释放信号量被唤醒，然后 T4 释放，唤醒 T2</p></li></ul><p>BUG 流程：</p><ul><li><p>T3 调用 releaseShared(1)，直接调用了 unparkSuccessor(head)，head.waitStatus 从 -1 变为 0</p></li><li><p>T1 由于 T3 释放信号量被唤醒，调用 tryAcquireShared，返回值为 0（获取锁成功，但没有剩余资源量）</p></li><li><p>T1 还没调用 setHeadAndPropagate 方法，T4 调用 releaseShared(1)，此时 head.waitStatus 为 0（此时读到的 head 和 1 中为同一个 head），不满足条件，因此不调用 unparkSuccessor(head)</p></li><li><p>T1 获取信号量成功，调用 setHeadAndPropagate(t1.node, 0) 时，因为不满足 propagate &gt; 0（剩余资源量 &#x3D;&#x3D; 0），从而不会唤醒后继结点， <strong>T2 线程得不到唤醒</strong></p></li></ul><p>更新后流程：</p><ul><li><p>T3 调用 releaseShared(1)，直接调用了 unparkSuccessor(head)，head.waitStatus 从 -1 变为 0</p></li><li><p>T1 由于 T3 释放信号量被唤醒，调用 tryAcquireShared，返回值为 0（获取锁成功，但没有剩余资源量）</p></li><li><p>T1 还没调用 setHeadAndPropagate 方法，T4 调用 releaseShared()，此时 head.waitStatus 为 0（此时读到的 head 和 1 中为同一个 head），调用 doReleaseShared() 将等待状态置为 <strong>PROPAGATE（-3）</strong></p></li><li><p>T1 获取信号量成功，调用 setHeadAndPropagate 时，读到 h.waitStatus &lt; 0，从而调用 doReleaseShared() 唤醒 T2</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setHeadAndPropagate</span><span class="hljs-params">(Node node, <span class="hljs-type">int</span> propagate)</span> &#123;      <br>    <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;  <br>    <span class="hljs-comment">// 设置自己为 head 节点  </span><br>    setHead(node);  <br>    <span class="hljs-comment">// propagate 表示有共享资源（例如共享读锁或信号量）  </span><br>    <span class="hljs-comment">// head waitStatus == Node.SIGNAL 或 Node.PROPAGATE  </span><br>    <span class="hljs-keyword">if</span> (propagate &gt; <span class="hljs-number">0</span> || h == <span class="hljs-literal">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span> ||  <br>        (h = head) == <span class="hljs-literal">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span>) &#123;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;  <br>        <span class="hljs-comment">// 如果是最后一个节点或者是等待共享读锁的节点，做一次唤醒  </span><br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.isShared())  <br>            doReleaseShared();  <br>    &#125;  <br>&#125;<br><br><span class="hljs-comment">// 唤醒  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doReleaseShared</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">// 如果 head.waitStatus == Node.SIGNAL ==&gt; 0 成功, 下一个节点 unpark  </span><br>    <span class="hljs-comment">// 如果 head.waitStatus == 0 ==&gt; Node.PROPAGATE      </span><br>    <span class="hljs-keyword">for</span> (;;) &#123;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;  <br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h != tail) &#123;  <br>            <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> h.waitStatus;  <br>            <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;  <br>                <span class="hljs-comment">// 防止 unparkSuccessor 被多次执行  </span><br>                <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>))  <br>                    <span class="hljs-keyword">continue</span>;  <br>                <span class="hljs-comment">// 唤醒后继节点  </span><br>                unparkSuccessor(h);  <br>            &#125;  <br>            <span class="hljs-comment">// 如果已经是 0 了，改为 -3，用来解决传播性  </span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp; !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))  <br>                <span class="hljs-keyword">continue</span>;  <br>        &#125;  <br>        <span class="hljs-keyword">if</span> (h == head)  <br>            <span class="hljs-keyword">break</span>;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h3><p>Exchanger：交换器，是一个用于线程间协作的工具类，用于进行线程间的数据交换</p><p>工作流程：两个线程通过 exchange 方法交换数据，如果第一个线程先执行 exchange() 方法，它会一直等待第二个线程也执行 exchange 方法，当两个线程都到达同步点时，这两个线程就可以交换数据</p><p>常用方法：</p><ul><li><p><code>public Exchanger()</code>：创建一个新的交换器</p></li><li><p><code>public V exchange(V x)</code>：等待另一个线程到达此交换点</p></li><li><p><code>public V exchange(V x, long timeout, TimeUnit unit)</code>：等待一定的时间</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExchangerDemo</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-comment">// 创建交换对象（信使）  </span><br>        Exchanger&lt;String&gt; exchanger = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exchanger</span>&lt;&gt;();  <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadA</span>(exchanger).start();  <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadB</span>(exchanger).start();  <br>    &#125;   <br>&#125;  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;  <br>    <span class="hljs-keyword">private</span> Exchanger&lt;String&gt; <span class="hljs-title function_">exchanger</span><span class="hljs-params">()</span>;  <br>      <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadA</span><span class="hljs-params">(Exchanger&lt;String&gt; exchanger)</span>&#123;  <br>        <span class="hljs-built_in">this</span>.exchanger = exchanger;  <br>    &#125;  <br>      <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">try</span>&#123;  <br>            sout(<span class="hljs-string">&quot;线程A，做好了礼物A，等待线程B送来的礼物B&quot;</span>);  <br>            <span class="hljs-comment">//如果等待了5s还没有交换就死亡（抛出异常）！  </span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> exchanger.exchange(<span class="hljs-string">&quot;礼物A&quot;</span>,<span class="hljs-number">5</span>,TimeUnit.SECONDS);  <br>            sout(<span class="hljs-string">&quot;线程A收到线程B的礼物：&quot;</span> + s);  <br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;  <br>            System.out.println(<span class="hljs-string">&quot;线程A等待了5s，没有收到礼物,最终就执行结束了!&quot;</span>);  <br>        &#125;  <br>    &#125;  <br>&#125;  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;  <br>    <span class="hljs-keyword">private</span> Exchanger&lt;String&gt; exchanger;  <br>      <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadB</span><span class="hljs-params">(Exchanger&lt;String&gt; exchanger)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.exchanger = exchanger;  <br>    &#125;  <br>      <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            sout(<span class="hljs-string">&quot;线程B,做好了礼物B,等待线程A送来的礼物A.....&quot;</span>);  <br>            <span class="hljs-comment">// 开始交换礼物。参数是送给其他线程的礼物!  </span><br>            sout(<span class="hljs-string">&quot;线程B收到线程A的礼物：&quot;</span> + exchanger.exchange(<span class="hljs-string">&quot;礼物B&quot;</span>));  <br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;  <br>            e.printStackTrace();  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并发</tag>
      
      <tag>JVM</tag>
      
      <tag>内存模型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于并发编程（上）</title>
    <link href="/posts/6aabc494/"/>
    <url>/posts/6aabc494/</url>
    
    <content type="html"><![CDATA[<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402211423293.png"></p><hr><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>进程：程序是静止的，进程实体的运行过程就是进程，是系统进行<strong>资源分配的基本单位</strong></p><p>进程的特征：并发性、异步性、动态性、独立性、结构性</p><p><strong>线程</strong>：线程是属于进程的，是一个基本的 CPU 执行单元，是程序执行流的最小单元。线程是进程中的一个实体，是系统<strong>独立调度的基本单位</strong>，线程本身不拥有系统资源，只拥有一点在运行中必不可少的资源，与同属一个进程的其他线程共享进程所拥有的全部资源</p><p>关系：一个进程可以包含多个线程，这就是多线程，比如看视频是进程，图画、声音、广告等就是多个线程</p><p>线程的作用：使多道程序更好的并发执行，提高资源利用率和系统吞吐量，增强操作系统的并发性能</p><p>并发并行：</p><ul><li><p>并行：在同一时刻，有多个指令在多个 CPU 上同时执行</p></li><li><p>并发：在同一时刻，有多个指令在单个 CPU 上交替执行</p></li></ul><p>同步异步：</p><ul><li><p>需要等待结果返回，才能继续运行就是同步</p></li><li><p>不需要等待结果返回，就能继续运行就是异步</p></li></ul><hr><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>线程进程对比：</p><ul><li><p>进程基本上相互独立的，而线程存在于进程内，是进程的一个子集</p></li><li><p>进程拥有共享的资源，如内存空间等，供其<strong>内部的线程共享</strong></p></li><li><p>进程间通信较为复杂</p><p>  同一台计算机的进程通信称为 IPC（Inter-process communication）</p><ul><li><p>信号量：信号量是一个计数器，用于多进程对共享数据的访问，解决同步相关的问题并避免竞争条件</p></li><li><p>共享存储：多个进程可以访问同一块内存空间，需要使用信号量用来同步对共享存储的访问</p></li><li><p>管道通信：管道是用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件 pipe 文件，该文件同一时间只允许一个进程访问，所以只支持<strong>半双工通信</strong></p><ul><li><p>匿名管道（Pipes）：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信</p></li><li><p>命名管道（Names Pipes）：以磁盘文件的方式存在，可以实现本机任意两个进程通信，遵循 FIFO</p></li></ul></li><li><p>消息队列：内核中存储消息的链表，由消息队列标识符标识，能在不同进程之间提供<strong>全双工通信</strong>，对比管道：</p><ul><li><p>匿名管道存在于内存中的文件；命名管道存在于实际的磁盘介质或者文件系统；消息队列存放在内核中，只有在内核重启（操作系统重启）或者显示地删除一个消息队列时，该消息队列才被真正删除</p></li><li><p>读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收</p></li></ul></li></ul><p>  不同计算机之间的<strong>进程通信</strong>，需要通过网络，并遵守共同的协议，例如 HTTP</p><ul><li>套接字：与其它通信机制不同的是，可用于不同机器间的互相通信</li></ul></li><li><p>线程通信相对简单，因为线程之间共享进程内的内存，一个例子是多个线程可以访问同一个共享变量</p><p>  <strong>Java 中的通信机制</strong>：volatile、等待&#x2F;通知机制、join 方式、InheritableThreadLocal、MappedByteBuffer</p></li><li><p>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低</p></li></ul><hr><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><h4 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h4><p>Thread 创建线程方式：创建线程类，匿名内部类方式</p><ul><li><p><strong>start() 方法底层其实是给 CPU 注册当前线程，并且触发 run() 方法执行</strong></p></li><li><p>线程的启动必须调用 start() 方法，如果线程直接调用 run() 方法，相当于变成了普通类的执行，此时主线程将只有执行该线程</p></li><li><p>建议线程先创建子线程，主线程的任务放在之后，否则主线程（main）永远是先执行完</p></li></ul><p>Thread 构造器：</p><ul><li><p><code>public Thread()</code></p></li><li><p><code>public Thread(String name)</code></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadDemo</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();  <br>        t.start();  <br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">100</span> ; i++ )&#123;  <br>            System.out.println(<span class="hljs-string">&quot;main线程&quot;</span> + i)  <br>        &#125;  <br>        <span class="hljs-comment">// main线程输出放在上面 就变成有先后顺序了，因为是 main 线程驱动的子线程运行  </span><br>    &#125;  <br>&#125;  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">100</span> ; i++ ) &#123;  <br>            System.out.println(<span class="hljs-string">&quot;子线程输出：&quot;</span>+i)  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>继承 Thread 类的优缺点：</p><ul><li><p>优点：编码简单</p></li><li><p>缺点：线程类已经继承了 Thread 类无法继承其他类了，功能不能通过继承拓展（单继承的局限性）</p></li></ul><hr><h4 id="Runnable"><a href="#Runnable" class="headerlink" title="Runnable"></a>Runnable</h4><p>Runnable 创建线程方式：创建线程类，匿名内部类方式</p><p>Thread 的构造器：</p><ul><li><p><code>public Thread(Runnable target)</code></p></li><li><p><code>public Thread(Runnable target, String name)</code></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadDemo</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>();  <br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(target,<span class="hljs-string">&quot;1号线程&quot;</span>);  <br>t1.start();  <br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(target);<span class="hljs-comment">//Thread-0  </span><br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">10</span> ; i++ )&#123;  <br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;-&gt;&quot;</span> + i);  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Thread 类本身也是实现了 Runnable 接口</strong>，Thread 类中持有 Runnable 的属性，执行线程 run 方法底层是调用 Runnable run：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;  <br>    <span class="hljs-keyword">private</span> Runnable target;  <br>      <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">if</span> (target != <span class="hljs-literal">null</span>) &#123;  <br>          <span class="hljs-comment">// 底层调用的是 Runnable 的 run 方法  </span><br>            target.run();  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>Runnable 方式的优缺点：</p><ul><li><p>缺点：代码复杂一点。</p></li><li><p>优点：</p><ol><li><p>线程任务类只是实现了 Runnable 接口，可以继续继承其他类，避免了单继承的局限性</p></li><li><p>同一个线程任务对象可以被包装成多个线程对象</p></li><li><p>适合多个多个线程去共享同一个资源</p></li><li><p>实现解耦操作，线程任务代码可以被多个线程共享，线程任务代码和线程独立</p></li><li><p>线程池可以放入实现 Runnable 或 Callable 线程任务对象</p></li></ol></li></ul><hr><h4 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h4><p>实现 Callable 接口：</p><ol><li><p>定义一个线程任务类实现 Callable 接口，申明线程执行的结果类型</p></li><li><p>重写线程任务类的 call 方法，这个方法可以直接返回执行的结果</p></li><li><p>创建一个 Callable 的线程任务对象</p></li><li><p>把 Callable 的线程任务对象<strong>包装成一个未来任务对象</strong></p></li><li><p>把未来任务对象包装成线程对象</p></li><li><p>调用线程的 start() 方法启动线程</p></li></ol><p><code>public FutureTask(Callable&lt;V&gt; callable)</code>：未来任务对象，在线程执行完后得到线程的执行结果</p><ul><li><p>FutureTask 就是 Runnable 对象，因为 <strong>Thread 类只能执行 Runnable 实例的任务对象</strong>，所以把 Callable 包装成未来任务对象</p></li><li><p>线程池部分详解了 FutureTask 的源码</p></li></ul><p><code>public V get()</code>：同步等待 task 执行完毕的结果，如果在线程中获取另一个线程执行结果，会阻塞等待，用于线程同步</p><ul><li><p>get() 线程会阻塞等待任务执行完成</p></li><li><p>run() 执行完后会把结果设置到 FutureTask 的一个成员变量，get() 线程可以获取到该变量的值</p></li></ul><p>优缺点：</p><ul><li><p>优点：同 Runnable，并且能得到线程执行的结果</p></li><li><p>缺点：编码复杂</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadDemo</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">Callable</span> <span class="hljs-variable">call</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>();  <br>        FutureTask&lt;String&gt; task = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(call);  <br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task);  <br>        t.start();  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> task.get(); <span class="hljs-comment">// 获取call方法返回的结果（正常/异常结果）  </span><br>            System.out.println(s);  <br>        &#125;  <span class="hljs-keyword">catch</span> (Exception e) &#123;  <br>            e.printStackTrace();  <br>        &#125;  <br>    &#125;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;String&gt; &#123;  <br>    <span class="hljs-meta">@Override</span><span class="hljs-comment">//重写线程任务类方法  </span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;  <br>        <span class="hljs-keyword">return</span> Thread.currentThread().getName() + <span class="hljs-string">&quot;-&gt;&quot;</span> + <span class="hljs-string">&quot;Hello World&quot;</span>;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="线程方法"><a href="#线程方法" class="headerlink" title="线程方法"></a>线程方法</h3><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><p>Thread 类 API：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public void start()</td><td>启动一个新线程，Java虚拟机调用此线程的 run 方法</td></tr><tr><td>public void run()</td><td>线程启动后调用该方法</td></tr><tr><td>public void setName(String name)</td><td>给当前线程取名字</td></tr><tr><td>public void getName()</td><td>获取当前线程的名字 线程存在默认名称：子线程是 Thread-索引，主线程是 main</td></tr><tr><td>public static Thread currentThread()</td><td>获取当前线程对象，代码在哪个线程中执行</td></tr><tr><td>public static void sleep(long time)</td><td>让当前线程休眠多少毫秒再继续执行 <strong>Thread.sleep(0)</strong> : 让操作系统立刻重新进行一次 CPU 竞争</td></tr><tr><td>public static native void yield()</td><td>提示线程调度器让出当前线程对 CPU 的使用</td></tr><tr><td>public final int getPriority()</td><td>返回此线程的优先级</td></tr><tr><td>public final void setPriority(int priority)</td><td>更改此线程的优先级，常用 1 5 10</td></tr><tr><td>public void interrupt()</td><td>中断这个线程，异常处理机制</td></tr><tr><td>public static boolean interrupted()</td><td>判断当前线程是否被打断，清除打断标记</td></tr><tr><td>public boolean isInterrupted()</td><td>判断当前线程是否被打断，不清除打断标记</td></tr><tr><td>public final void join()</td><td>等待这个线程结束</td></tr><tr><td>public final void join(long millis)</td><td>等待这个线程死亡 millis 毫秒，0 意味着永远等待</td></tr><tr><td>public final native boolean isAlive()</td><td>线程是否存活（还没有运行完毕）</td></tr><tr><td>public final void setDaemon(boolean on)</td><td>将此线程标记为守护线程或用户线程</td></tr></tbody></table><hr><h4 id="run-start"><a href="#run-start" class="headerlink" title="run start"></a>run start</h4><p>run：称为线程体，包含了要执行的这个线程的内容，方法运行结束，此线程随即终止。直接调用 run 是在主线程中执行了 run，没有启动新的线程，需要顺序执行</p><p>start：使用 start 是启动新的线程，此线程处于就绪（可运行）状态，通过新的线程间接执行 run 中的代码</p><p>说明：<strong>线程控制资源类</strong></p><p>run() 方法中的异常不能抛出，只能 try&#x2F;catch</p><ul><li><p>因为父类中没有抛出任何异常，子类不能比父类抛出更多的异常</p></li><li><p><strong>异常不能跨线程传播回 main() 中</strong>，因此必须在本地进行处理</p></li></ul><hr><h4 id="sleep-yield"><a href="#sleep-yield" class="headerlink" title="sleep yield"></a>sleep yield</h4><p>sleep：</p><ul><li><p>调用 sleep 会让当前线程从 <code>Running</code> 进入 <code>Timed Waiting</code> 状态（阻塞）</p></li><li><p>sleep() 方法的过程中，<strong>线程不会释放对象锁</strong></p></li><li><p>其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException</p></li><li><p>睡眠结束后的线程未必会立刻得到执行，需要抢占 CPU</p></li><li><p>建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性</p></li></ul><p>yield：</p><ul><li><p>调用 yield 会让提示线程调度器让出当前线程对 CPU 的使用</p></li><li><p>具体的实现依赖于操作系统的任务调度器</p></li><li><p><strong>会放弃 CPU 资源，锁资源不会释放</strong></p></li></ul><hr><h4 id="join"><a href="#join" class="headerlink" title="join"></a>join</h4><p>public final void join()：等待这个线程结束</p><p>原理：调用者轮询检查线程 alive 状态，t1.join() 等价于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">join</span><span class="hljs-params">(<span class="hljs-type">long</span> millis)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>    <span class="hljs-comment">// 调用者线程进入 thread 的 waitSet 等待, 直到当前线程运行结束  </span><br>    <span class="hljs-keyword">while</span> (isAlive()) &#123;  <br>        wait(<span class="hljs-number">0</span>);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>join 方法是被 synchronized 修饰的，本质上是一个对象锁，其内部的 wait 方法调用也是释放锁的，但是<strong>释放的是当前的线程对象锁，而不是外面的锁</strong></p></li><li><p>当调用某个线程（t1）的 join 方法后，该线程（t1）抢占到 CPU 资源，就不再释放，直到线程执行完毕</p></li></ul><p>线程同步：</p><ul><li><p>join 实现线程同步，因为会阻塞等待另一个线程的结束，才能继续向下运行</p><ul><li><p>需要外部共享变量，不符合面向对象封装的思想</p></li><li><p>必须等待线程结束，不能配合线程池使用</p></li></ul></li><li><p>Future 实现（同步）：get() 方法阻塞等待执行结果</p><ul><li><p>main 线程接收结果</p></li><li><p>get 方法是让调用线程同步等待</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;  <br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>        test1();  <br>    &#125;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>            <span class="hljs-keyword">try</span> &#123;  <br>                Thread.sleep(<span class="hljs-number">1000</span>);  <br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>                e.printStackTrace();  <br>            &#125;  <br>            r = <span class="hljs-number">10</span>;  <br>        &#125;);  <br>        t1.start();  <br>        t1.join();<span class="hljs-comment">//不等待线程执行结束，输出的10  </span><br>        System.out.println(r);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h4><h5 id="打断线程"><a href="#打断线程" class="headerlink" title="打断线程"></a>打断线程</h5><p><code>public void interrupt()</code>：打断这个线程，异常处理机制</p><p><code>public static boolean interrupted()</code>：判断当前线程是否被打断，打断返回 true，<strong>清除打断标记</strong>，连续调用两次一定返回 false</p><p><code>public boolean isInterrupted()</code>：判断当前线程是否被打断，不清除打断标记</p><p>打断的线程会发生上下文切换，操作系统会保存线程信息，抢占到 CPU 后会从中断的地方接着运行（打断不是停止）</p><ul><li>sleep、wait、join 方法都会让线程进入阻塞状态，打断线程<strong>会清空打断状态</strong>（false）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            Thread.sleep(<span class="hljs-number">1000</span>);  <br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>            e.printStackTrace();  <br>        &#125;  <br>    &#125;, <span class="hljs-string">&quot;t1&quot;</span>);  <br>    t1.start();  <br>    Thread.sleep(<span class="hljs-number">500</span>);  <br>    t1.interrupt();  <br>    System.out.println(<span class="hljs-string">&quot; 打断状态: &#123;&#125;&quot;</span> + t1.isInterrupted());<span class="hljs-comment">// 打断状态: &#123;&#125;false  </span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>打断正常运行的线程：不会清空打断状态（true）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;  <br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;  <br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;  <br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();  <br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> current.isInterrupted();  <br>            <span class="hljs-keyword">if</span>(interrupted) &#123;  <br>                System.out.println(<span class="hljs-string">&quot; 打断状态: &#123;&#125;&quot;</span> + interrupted);<span class="hljs-comment">//打断状态: &#123;&#125;true  </span><br>                <span class="hljs-keyword">break</span>;  <br>            &#125;  <br>        &#125;  <br>    &#125;, <span class="hljs-string">&quot;t2&quot;</span>);  <br>    t2.start();  <br>    Thread.sleep(<span class="hljs-number">500</span>);  <br>    t2.interrupt();  <br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h5 id="打断-park"><a href="#打断-park" class="headerlink" title="打断 park"></a>打断 park</h5><p>park 作用类似 sleep，打断 park 线程，不会清空打断状态（true）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;  <br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>        System.out.println(<span class="hljs-string">&quot;park...&quot;</span>);  <br>        LockSupport.park();  <br>        System.out.println(<span class="hljs-string">&quot;unpark...&quot;</span>);  <br>        System.out.println(<span class="hljs-string">&quot;打断状态：&quot;</span> + Thread.currentThread().isInterrupted());<span class="hljs-comment">//打断状态：true  </span><br>    &#125;, <span class="hljs-string">&quot;t1&quot;</span>);  <br>    t1.start();  <br>    Thread.sleep(<span class="hljs-number">2000</span>);  <br>    t1.interrupt();  <br>&#125;<br></code></pre></td></tr></table></figure><p>如果打断标记已经是 true, 则 park 会失效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">LockSupport.park();  <br>System.out.println(<span class="hljs-string">&quot;unpark...&quot;</span>);  <br>LockSupport.park();<span class="hljs-comment">//失效，不会阻塞  </span><br>System.out.println(<span class="hljs-string">&quot;unpark...&quot;</span>);<span class="hljs-comment">//和上一个unpark同时执行</span><br></code></pre></td></tr></table></figure><p>可以修改获取打断状态方法，使用 <code>Thread.interrupted()</code>，清除打断标记</p><p>LockSupport 类在 同步 → park-un 详解</p><hr><h5 id="终止模式"><a href="#终止模式" class="headerlink" title="终止模式"></a>终止模式</h5><p>终止模式之两阶段终止模式：Two Phase Termination</p><p>目标：在一个线程 T1 中如何优雅终止线程 T2？优雅指的是给 T2 一个后置处理器</p><p>错误思想：</p><ul><li><p>使用线程对象的 stop() 方法停止线程：stop 方法会真正杀死线程，如果这时线程锁住了共享资源，当它被杀死后就再也没有机会释放锁，其它线程将永远无法获取锁</p></li><li><p>使用 System.exit(int) 方法停止线程：目的仅是停止一个线程，但这种做法会让整个程序都停止</p></li></ul><p>两阶段终止模式图示：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041617846.png"></p><p>打断线程可能在任何时间，所以需要考虑在任何时刻被打断的处理方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>        <span class="hljs-type">TwoPhaseTermination</span> <span class="hljs-variable">tpt</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TwoPhaseTermination</span>();  <br>        tpt.start();  <br>        Thread.sleep(<span class="hljs-number">3500</span>);  <br>        tpt.stop();  <br>    &#125;  <br>&#125;  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TwoPhaseTermination</span> &#123;  <br>    <span class="hljs-keyword">private</span> Thread monitor;  <br>    <span class="hljs-comment">// 启动监控线程  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;  <br>        monitor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;  <br>            <span class="hljs-meta">@Override</span>  <br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;  <br>                    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> Thread.currentThread();  <br>                    <span class="hljs-keyword">if</span> (thread.isInterrupted()) &#123;  <br>                        System.out.println(<span class="hljs-string">&quot;后置处理&quot;</span>);  <br>                        <span class="hljs-keyword">break</span>;  <br>                    &#125;  <br>                    <span class="hljs-keyword">try</span> &#123;  <br>                        Thread.sleep(<span class="hljs-number">1000</span>);<span class="hljs-comment">// 睡眠  </span><br>                        System.out.println(<span class="hljs-string">&quot;执行监控记录&quot;</span>);<span class="hljs-comment">// 在此被打断不会异常  </span><br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<span class="hljs-comment">// 在睡眠期间被打断，进入异常处理的逻辑  </span><br>                        e.printStackTrace();  <br>                        <span class="hljs-comment">// 重新设置打断标记，打断 sleep 会清除打断状态  </span><br>                        thread.interrupt();  <br>                    &#125;  <br>                &#125;  <br>            &#125;  <br>        &#125;);  <br>        monitor.start();  <br>    &#125;  <br>    <span class="hljs-comment">// 停止监控线程  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">()</span> &#123;  <br>        monitor.interrupt();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="daemon"><a href="#daemon" class="headerlink" title="daemon"></a>daemon</h4><p><code>public final void setDaemon(boolean on)</code>：如果是 true ，将此线程标记为守护线程</p><p>线程<strong>启动前</strong>调用此方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>() &#123;  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;running&quot;</span>);  <br>    &#125;  <br>&#125;;  <br><span class="hljs-comment">// 设置该线程为守护线程  </span><br>t.setDaemon(<span class="hljs-literal">true</span>);  <br>t.start();<br></code></pre></td></tr></table></figure><p>用户线程：平常创建的普通线程</p><p>守护线程：服务于用户线程，只要其它非守护线程运行结束了，即使守护线程代码没有执行完，也会强制结束。守护进程是<strong>脱离于终端并且在后台运行的进程</strong>，脱离终端是为了避免在执行的过程中的信息在终端上显示</p><p>说明：当运行的线程都是守护线程，Java 虚拟机将退出，因为普通线程执行完后，JVM 是守护线程，不会继续运行下去</p><p>常见的守护线程：</p><ul><li><p>垃圾回收器线程就是一种守护线程</p></li><li><p>Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等待它们处理完当前请求</p></li></ul><hr><h4 id="不推荐"><a href="#不推荐" class="headerlink" title="不推荐"></a>不推荐</h4><p>不推荐使用的方法，这些方法已过时，容易破坏同步代码块，造成线程死锁：</p><ul><li><p><code>public final void stop()</code>：停止线程运行</p><p>  废弃原因：方法粗暴，除非可能执行 finally 代码块以及释放 synchronized 外，线程将直接被终止，如果线程持有 JUC 的互斥锁可能导致锁来不及释放，造成其他线程永远等待的局面</p></li><li><p><code>public final void suspend()</code>：<strong>挂起（暂停）线程运行</strong></p><p>  废弃原因：如果目标线程在暂停时对系统资源持有锁，则在目标线程恢复之前没有线程可以访问该资源，如果<strong>恢复目标线程的线程</strong>在调用 resume 之前会尝试访问此共享资源，则会导致死锁</p></li><li><p><code>public final void resume()</code>：恢复线程运行</p></li></ul><hr><h3 id="线程原理"><a href="#线程原理" class="headerlink" title="线程原理"></a>线程原理</h3><h4 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h4><p>Java Virtual Machine Stacks（Java 虚拟机栈）：每个线程启动后，虚拟机就会为其分配一块栈内存</p><ul><li><p>每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存</p></li><li><p>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</p></li></ul><p>线程上下文切换（Thread Context Switch）：一些原因导致 CPU 不再执行当前线程，转而执行另一个线程</p><ul><li><p>线程的 CPU 时间片用完</p></li><li><p>垃圾回收</p></li><li><p>有更高优先级的线程需要运行</p></li><li><p>线程自己调用了 sleep、yield、wait、join、park 等方法</p></li></ul><p>程序计数器（Program Counter Register）：记住下一条 JVM 指令的执行地址，是线程私有的</p><p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态（PCB 中），并恢复另一个线程的状态，包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等</p><p>JVM 规范并没有限定线程模型，以 HotSopot 为例：</p><ul><li><p>Java 的线程是内核级线程（1:1 线程模型），每个 Java 线程都映射到一个操作系统原生线程，需要消耗一定的内核资源（堆栈）</p></li><li><p><strong>线程的调度是在内核态运行的，而线程中的代码是在用户态运行</strong>，所以线程切换（状态改变）会导致用户与内核态转换进行系统调用，这是非常消耗性能</p></li></ul><p>Java 中 main 方法启动的是一个进程也是一个主线程，main 方法里面的其他线程均为子线程，main 线程是这些线程的父线程</p><hr><h4 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h4><p>线程调度指系统为线程分配处理器使用权的过程，方式有两种：协同式线程调度、抢占式线程调度（Java 选择）</p><p>协同式线程调度：线程的执行时间由线程本身控制</p><ul><li><p>优点：线程做完任务才通知系统切换到其他线程，相当于所有线程串行执行，不会出现线程同步问题</p></li><li><p>缺点：线程执行时间不可控，如果代码编写出现问题，可能导致程序一直阻塞，引起系统的奔溃</p></li></ul><p>抢占式线程调度：线程的执行时间由系统分配</p><ul><li><p>优点：线程执行时间可控，不会因为一个线程的问题而导致整体系统不可用</p></li><li><p>缺点：无法主动为某个线程多分配时间</p></li></ul><p>Java 提供了线程优先级的机制，优先级会提示（hint）调度器优先调度该线程，但这仅仅是一个提示，调度器可以忽略它。在线程的就绪状态时，如果 CPU 比较忙，那么优先级高的线程会获得更多的时间片，但 CPU 闲时，优先级几乎没作用</p><p>说明：并不能通过优先级来判断线程执行的先后顺序</p><hr><h4 id="未来优化"><a href="#未来优化" class="headerlink" title="未来优化"></a>未来优化</h4><p>内核级线程调度的成本较大，所以引入了更轻量级的协程。用户线程的调度由用户自己实现（多对一的线程模型，多<strong>个用户线程映射到一个内核级线程</strong>），被设计为协同式调度，所以叫协程</p><ul><li><p>有栈协程：协程会完整的做调用栈的保护、恢复工作，所以叫有栈协程</p></li><li><p>无栈协程：本质上是一种有限状态机，状态保存在闭包里，比有栈协程更轻量，但是功能有限</p></li></ul><p>有栈协程中有一种特例叫纤程，在新并发模型中，一段纤程的代码被分为两部分，执行过程和调度器：</p><ul><li><p>执行过程：用于维护执行现场，保护、恢复上下文状态</p></li><li><p>调度器：负责编排所有要执行的代码顺序</p></li></ul><hr><h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><p>进程的状态参考操作系统：创建态、就绪态、运行态、阻塞态、终止态</p><p>线程由生到死的完整过程（生命周期）：当线程被创建并启动以后，既不是一启动就进入了执行状态，也不是一直处于执行状态，在 API 中 <code>java.lang.Thread.State</code> 这个枚举中给出了六种线程状态：</p><table><thead><tr><th>线程状态</th><th>导致状态发生条件</th></tr></thead><tbody><tr><td>NEW（新建）</td><td>线程刚被创建，但是并未启动，还没调用 start 方法，只有线程对象，没有线程特征</td></tr><tr><td>Runnable（可运行）</td><td>线程可以在 Java 虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操作系统处理器，调用了 t.start() 方法：就绪（经典叫法）</td></tr><tr><td>Blocked（阻塞）</td><td>当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入 Blocked 状态；当该线程持有锁时，该线程将变成 Runnable 状态</td></tr><tr><td>Waiting（无限等待）</td><td>一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入 Waiting 状态，进入这个状态后不能自动唤醒，必须等待另一个线程调用 notify 或者 notifyAll 方法才能唤醒</td></tr><tr><td>Timed Waiting （限期等待）</td><td>有几个方法有超时参数，调用将进入 Timed Waiting 状态，这一状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有 Thread.sleep 、Object.wait</td></tr><tr><td>Teminated（结束）</td><td>run 方法正常退出而死亡，或者因为没有捕获的异常终止了 run 方法而死亡</td></tr></tbody></table><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041618351.png"></p><ul><li><p>NEW → RUNNABLE：当调用 t.start() 方法时，由 NEW → RUNNABLE</p></li><li><p>RUNNABLE &lt;–&gt; WAITING：</p><ul><li><p>调用 obj.wait() 方法时</p><p>  调用 obj.notify()、obj.notifyAll()、t.interrupt()：</p><ul><li><p>竞争锁成功，t 线程从 WAITING → RUNNABLE</p></li><li><p>竞争锁失败，t 线程从 WAITING → BLOCKED</p></li></ul></li><li><p>当前线程调用 t.join() 方法，注意是当前线程在 t 线程对象的监视器上等待</p></li><li><p>当前线程调用 LockSupport.park() 方法</p></li></ul></li><li><p>RUNNABLE &lt;–&gt; TIMED_WAITING：调用 obj.wait(long n) 方法、当前线程调用 t.join(long n) 方法、当前线程调用 Thread.sleep(long n)</p></li><li><p>RUNNABLE &lt;–&gt; BLOCKED：t 线程用 synchronized(obj) 获取了对象锁时竞争失败</p></li></ul><hr><h3 id="查看线程"><a href="#查看线程" class="headerlink" title="查看线程"></a>查看线程</h3><p>Windows：</p><ul><li><p>任务管理器可以查看进程和线程数，也可以用来杀死进程</p></li><li><p>tasklist 查看进程</p></li><li><p>taskkill 杀死进程</p></li></ul><p>Linux：</p><ul><li><p>ps -ef 查看所有进程</p></li><li><p>ps -fT -p &lt; PID&gt; 查看某个进程（PID）的所有线程</p></li><li><p>kill 杀死进程</p></li><li><p>top 按大写 H 切换是否显示线程</p></li><li><p>top -H -p &lt; PID&gt; 查看某个进程（PID）的所有线程</p></li></ul><p>Java：</p><ul><li><p>jps 命令查看所有 Java 进程</p></li><li><p>jstack &lt; PID&gt; 查看某个 Java 进程（PID）的所有线程状态</p></li><li><p>jconsole 来查看某个 Java 进程中线程的运行情况（图形界面）</p></li></ul><hr><h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><p>临界资源：一次仅允许一个进程使用的资源成为临界资源</p><p>临界区：访问临界资源的代码块</p><p>竞态条件：多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了竞态条件</p><p>一个程序运行多个线程是没有问题，多个线程读共享资源也没有问题，在多个线程对共享资源读写操作时发生指令交错，就会出现问题</p><p>为了避免临界区的竞态条件发生（解决线程安全问题）：</p><ul><li><p>阻塞式的解决方案：synchronized，lock</p></li><li><p>非阻塞式的解决方案：原子变量</p></li></ul><p>管程（monitor）：由局部于自己的若干公共变量和所有访问这些公共变量的过程所组成的软件模块，保证同一时刻只有一个进程在管程内活动，即管程内定义的操作在同一时刻只被一个进程调用（由编译器实现）</p><p><strong>synchronized：对象锁，保证了临界区内代码的原子性</strong>，采用互斥的方式让同一时刻至多只有一个线程能持有对象锁，其它线程获取这个对象锁时会阻塞，保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换</p><p>互斥和同步都可以采用 synchronized 关键字来完成，区别：</p><ul><li><p>互斥是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区代码</p></li><li><p>同步是由于线程执行的先后、顺序不同、需要一个线程等待其它线程运行到某个点</p></li></ul><p>性能：</p><ul><li><p>线程安全，性能差</p></li><li><p>线程不安全性能好，假如开发中不会存在多线程安全问题，建议使用线程不安全的设计类</p></li></ul><hr><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><h4 id="使用锁"><a href="#使用锁" class="headerlink" title="使用锁"></a>使用锁</h4><h5 id="同步块"><a href="#同步块" class="headerlink" title="同步块"></a>同步块</h5><p>锁对象：理论上可以是<strong>任意的唯一对象</strong></p><p>synchronized 是可重入、不公平的重量级锁</p><p>原则上：</p><ul><li><p>锁对象建议使用共享资源</p></li><li><p>在实例方法中使用 this 作为锁对象，锁住的 this 正好是共享资源</p></li><li><p>在静态方法中使用类名 .class 字节码作为锁对象，因为静态成员属于类，被所有实例对象共享，所以需要锁住类</p></li></ul><p>同步代码块格式：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">synchronized</span><span class="hljs-params">(锁对象)</span></span>&#123;  <br><span class="hljs-comment">// 访问共享资源的核心代码  </span><br>&#125;<br></code></pre></td></tr></table></figure><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">demo</span> &#123;  <br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br>    <span class="hljs-comment">//static修饰，则元素是属于类本身的，不属于对象  ，与类一起加载一次，只有一个  </span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">room</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;  <br>                <span class="hljs-keyword">synchronized</span> (room) &#123;  <br>                    counter++;  <br>                &#125;  <br>            &#125;  <br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);  <br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;  <br>                <span class="hljs-keyword">synchronized</span> (room) &#123;  <br>                    counter--;  <br>                &#125;  <br>            &#125;  <br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>);  <br>        t1.start();  <br>        t2.start();  <br>        t1.join();  <br>        t2.join();  <br>        System.out.println(counter);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h5><p>把出现线程安全问题的核心方法锁起来，每次只能一个线程进入访问</p><p>synchronized 修饰的方法的不具备继承性，所以子类是线程不安全的，如果子类的方法也被 synchronized 修饰，两个锁对象其实是一把锁，而且是<strong>子类对象作为锁</strong></p><p>用法：直接给方法加上一个修饰符 synchronized</p><p>&#x2F;&#x2F;同步方法  </p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada">修饰符 <span class="hljs-keyword">synchronized</span> 返回值类型 方法名(方法参数) &#123;   <br>方法体；  <br>&#125;  <br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F;同步静态方法  </p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino">修饰符 <span class="hljs-type">static</span> <span class="hljs-keyword">synchronized</span> 返回值类型 方法名(方法参数) &#123;   <br>方法体；  <br>&#125;<br></code></pre></td></tr></table></figure><p>同步方法底层也是有锁对象的：</p><ul><li>如果方法是实例方法：同步方法默认用 this 作为的锁对象</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> synchronized <span class="hljs-built_in">void</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;&#125; <span class="hljs-comment">//等价于  </span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;  <br><span class="hljs-title function_">synchronized</span>(<span class="hljs-params"><span class="hljs-variable language_">this</span></span>) &#123;&#125;  <br> &#125;<br></code></pre></td></tr></table></figure><ul><li>如果方法是静态方法：同步方法默认用类名 .class 作为的锁对象</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;  <br><span class="hljs-keyword">public</span> synchronized <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;&#125;  <br>&#125;  <br><span class="hljs-comment">//等价于  </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;  <br>        <span class="hljs-title function_">synchronized</span>(<span class="hljs-params">Test.<span class="hljs-keyword">class</span></span>) &#123;&#125;  <br>&#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="线程八锁"><a href="#线程八锁" class="headerlink" title="线程八锁"></a>线程八锁</h5><p>线程八锁就是考察 synchronized 锁住的是哪个对象，直接百度搜索相关的实例</p><p>说明：主要关注锁住的对象是不是同一个</p><ul><li><p>锁住类对象，所有类的实例的方法都是安全的，类的所有实例都相当于同一把锁</p></li><li><p>锁住 this 对象，只有在当前实例对象的线程内是安全的，如果有多个实例就不安全</p></li></ul><p>线程不安全：因为锁住的不是同一个对象，线程 1 调用 a 方法锁住的n1对象，线程 2 调用 b 方法锁住的 n2 对象，不是同一个对象</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Number</span>&#123;  <br>    public <span class="hljs-keyword">static</span> synchronized <span class="hljs-literal">void</span> a()&#123;  <br>        Thread.sleep(<span class="hljs-number">1000</span>);  <br>        System.out.println(<span class="hljs-string">&quot;1&quot;</span>);  <br>    &#125;  <br>    public synchronized <span class="hljs-literal">void</span> b() &#123;  <br>        System.out.println(<span class="hljs-string">&quot;2&quot;</span>);  <br>    &#125;  <br>&#125;  <br>public <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> main(<span class="hljs-built_in">String</span>[] args) &#123;  <br>    <span class="hljs-built_in">Number</span> n1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>();  <br>    <span class="hljs-built_in">Number</span> n2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>();  <br>    <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(()-&gt;&#123; n1.a(); &#125;)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;  </span><br><span class="hljs-function">    <span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(()-&gt;&#123; n2.b(); &#125;)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;  </span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><p>线程安全：因为 n1 调用 a() 方法，锁住的是类对象，n2 调用 b() 方法，锁住的也是类对象，所以线程安全</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Number</span>&#123;  <br>    public <span class="hljs-keyword">static</span> synchronized <span class="hljs-literal">void</span> a()&#123;  <br>        Thread.sleep(<span class="hljs-number">1000</span>);  <br>        System.out.println(<span class="hljs-string">&quot;1&quot;</span>);  <br>    &#125;  <br>    public <span class="hljs-keyword">static</span> synchronized <span class="hljs-literal">void</span> b() &#123;  <br>        System.out.println(<span class="hljs-string">&quot;2&quot;</span>);  <br>    &#125;  <br>&#125;  <br>public <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> main(<span class="hljs-built_in">String</span>[] args) &#123;  <br>    <span class="hljs-built_in">Number</span> n1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>();  <br>    <span class="hljs-built_in">Number</span> n2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>();  <br>    <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(()-&gt;&#123; n1.a(); &#125;)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;  </span><br><span class="hljs-function">    <span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(()-&gt;&#123; n2.b(); &#125;)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;  </span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><hr><h4 id="锁原理"><a href="#锁原理" class="headerlink" title="锁原理"></a>锁原理</h4><h5 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h5><p>Monitor 被翻译为监视器或管程</p><p>每个 Java 对象都可以关联一个 Monitor 对象，Monitor 也是 class，其<strong>实例存储在堆中</strong>，如果使用 synchronized 给对象上锁（重量级）之后，该对象头的 Mark Word 中就被设置指向 Monitor 对象的指针，这就是重量级锁</p><ul><li>Mark Word 结构：最后两位是<strong>锁标志位</strong></li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041620782.png"></p><ul><li>64 位虚拟机 Mark Word：</li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041620048.png"></p><p>工作流程：</p><ul><li><p>开始时 Monitor 中 Owner 为 null</p></li><li><p>当 Thread-2 执行 synchronized(obj) 就会将 Monitor 的所有者 Owner 置为 Thread-2，Monitor 中只能有一个 Owner，<strong>obj 对象的 Mark Word 指向 Monitor</strong>，把<strong>对象原有的 MarkWord 存入线程栈中的锁记录</strong>中（轻量级锁部分详解）<br><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041621477.png">    </p></li><li><p>在 Thread-2 上锁的过程，Thread-3、Thread-4、Thread-5 也执行 synchronized(obj)，就会进入 EntryList BLOCKED（双向链表）</p></li><li><p>Thread-2 执行完同步代码块的内容，根据 obj 对象头中 Monitor 地址寻找，设置 Owner 为空，把线程栈的锁记录中的对象头的值设置回 MarkWord</p></li><li><p>唤醒 EntryList 中等待的线程来竞争锁，竞争是<strong>非公平的</strong>，如果这时有新的线程想要获取锁，可能直接就抢占到了，阻塞队列的线程就会继续阻塞</p></li><li><p>WaitSet 中的 Thread-0，是以前获得过锁，但条件不满足进入 WAITING 状态的线程（wait-notify 机制）</p></li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041621372.png"></p><p>注意：</p><ul><li><p>synchronized 必须是进入同一个对象的 Monitor 才有上述的效果</p></li><li><p>不加 synchronized 的对象不会关联监视器，不遵从以上规则</p></li></ul><hr><h5 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h5><p>代码：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) &#123;  <br>    Object lock = <span class="hljs-keyword">new</span> Object();  <br>    <span class="hljs-keyword">synchronized</span> (lock) &#123;  <br>        System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;ok&quot;</span>);  <br>    &#125;  <br>&#125;<br><br><span class="hljs-number">0</span>: <span class="hljs-keyword">new</span>#<span class="hljs-number">2</span><span class="hljs-comment">// new Object  </span><br><span class="hljs-number">3</span>: dup  <br><span class="hljs-number">4</span>: invokespecial #<span class="hljs-number">1</span> <span class="hljs-comment">// invokespecial &lt;init&gt;:()V，非虚方法  </span><br><span class="hljs-number">7</span>: astore_1 <span class="hljs-comment">// lock引用 -&gt; lock  </span><br><span class="hljs-number">8</span>: aload_1<span class="hljs-comment">// lock （synchronized开始）  </span><br><span class="hljs-number">9</span>: dup<span class="hljs-comment">// 一份用来初始化，一份用来引用  </span><br><span class="hljs-number">10</span>: astore_2 <span class="hljs-comment">// lock引用 -&gt; slot 2  </span><br><span class="hljs-number">11</span>: monitorenter <span class="hljs-comment">// 【将 lock对象 MarkWord 置为 Monitor 指针】  </span><br><span class="hljs-number">12</span>: getstatic #<span class="hljs-number">3</span><span class="hljs-comment">// System.out  </span><br><span class="hljs-number">15</span>: ldc #<span class="hljs-number">4</span><span class="hljs-comment">// &quot;ok&quot;  </span><br><span class="hljs-number">17</span>: invokevirtual #<span class="hljs-number">5</span> <span class="hljs-comment">// invokevirtual println:(Ljava/lang/String;)V  </span><br><span class="hljs-number">20</span>: aload_2 <span class="hljs-comment">// slot 2(lock引用)  </span><br><span class="hljs-number">21</span>: monitorexit <span class="hljs-comment">// 【将 lock对象 MarkWord 重置, 唤醒 EntryList】  </span><br><span class="hljs-number">22</span>: goto <span class="hljs-number">30</span>  <br><span class="hljs-number">25</span>: astore_3 <span class="hljs-comment">// any -&gt; slot 3  </span><br><span class="hljs-number">26</span>: aload_2 <span class="hljs-comment">// slot 2(lock引用)  </span><br><span class="hljs-number">27</span>: monitorexit <span class="hljs-comment">// 【将 lock对象 MarkWord 重置, 唤醒 EntryList】  </span><br><span class="hljs-number">28</span>: aload_3  <br><span class="hljs-number">29</span>: athrow  <br><span class="hljs-number">30</span>: <span class="hljs-keyword">return</span>  <br>Exception table:  <br>    <span class="hljs-keyword">from</span> to target type  <br>      <span class="hljs-number">12</span> <span class="hljs-number">22</span> <span class="hljs-number">25</span> <span class="hljs-keyword">any</span>  <br>      <span class="hljs-number">25</span> <span class="hljs-number">28</span> <span class="hljs-number">25</span> <span class="hljs-keyword">any</span>  <br>LineNumberTable: ...  <br>LocalVariableTable:  <br>    Start Length Slot Name Signature  <br>    <span class="hljs-number">0</span> <span class="hljs-number">31</span> <span class="hljs-number">0</span> args [Ljava<span class="hljs-regexp">/lang/</span>String;  <br>    <span class="hljs-number">8</span> <span class="hljs-number">23</span> <span class="hljs-number">1</span> lock Ljava<span class="hljs-regexp">/lang/</span>Object;<br><br></code></pre></td></tr></table></figure><p>说明：</p><ul><li><p>通过异常 <strong>try-catch 机制</strong>，确保一定会被解锁</p></li><li><p>方法级别的 synchronized 不会在字节码指令中有所体现</p></li></ul><hr><h4 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h4><h5 id="升级过程"><a href="#升级过程" class="headerlink" title="升级过程"></a>升级过程</h5><p><strong>synchronized 是可重入、不公平的重量级锁</strong>，所以可以对其进行优化</p><p>无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁&#x2F;&#x2F; 随着竞争的增加，只能锁升级，不能降级</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041622328.png"></p><hr><h5 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h5><p>偏向锁的思想是偏向于让第一个获取锁对象的线程，这个线程之后重新获取该锁不再需要同步操作：</p><ul><li><p>当锁对象第一次被线程获得的时候进入偏向状态，标记为 101，同时<strong>使用 CAS 操作将线程 ID 记录到 Mark Word</strong>。如果 CAS 操作成功，这个线程以后进入这个锁相关的同步块，查看这个线程 ID 是自己的就表示没有竞争，就不需要再进行任何同步操作</p></li><li><p>当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向（Revoke Bias）后恢复到未锁定或轻量级锁状态</p></li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041622764.png"></p><p>一个对象创建时：</p><ul><li><p>如果开启了偏向锁（默认开启），那么对象创建后，MarkWord 值为 0x05 即最后 3 位为 101，thread、epoch、age 都为 0</p></li><li><p>偏向锁是默认是延迟的，不会在程序启动时立即生效，如果想避免延迟，可以加 VM 参数 <code>-XX:BiasedLockingStartupDelay=0</code> 来禁用延迟。JDK 8 延迟 4s 开启偏向锁原因：在刚开始执行代码时，会有好多线程来抢锁，如果开偏向锁效率反而降低</p></li><li><p>当一个对象已经计算过 hashCode，就再也无法进入偏向状态了</p></li><li><p>添加 VM 参数 <code>-XX:-UseBiasedLocking</code> 禁用偏向锁</p></li></ul><p>撤销偏向锁的状态：</p><ul><li><p>调用对象的 hashCode：偏向锁的对象 MarkWord 中存储的是线程 id，调用 hashCode 导致偏向锁被撤销</p></li><li><p>当有其它线程使用偏向锁对象时，会将偏向锁升级为轻量级锁</p></li><li><p>调用 wait&#x2F;notify，需要申请 Monitor，进入 WaitSet</p></li></ul><p><strong>批量撤销</strong>：如果对象被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，重偏向会重置对象的 Thread ID</p><ul><li><p>批量重偏向：当撤销偏向锁阈值超过 20 次后，JVM 会觉得是不是偏向错了，于是在给这些对象加锁时重新偏向至加锁线程</p></li><li><p>批量撤销：当撤销偏向锁阈值超过 40 次后，JVM 会觉得自己确实偏向错了，根本就不该偏向，于是整个类的所有对象都会变为不可偏向的，新建的对象也是不可偏向的</p></li></ul><hr><h5 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h5><p>一个对象有多个线程要加锁，但加锁的时间是错开的（没有竞争），可以使用轻量级锁来优化，轻量级锁对使用者是透明的（不可见）</p><p>可重入锁：线程可以进入任何一个它已经拥有的锁所同步着的代码块，可重入锁最大的作用是<strong>避免死锁</strong></p><p>轻量级锁在没有竞争时（锁重入时），每次重入仍然需要执行 CAS 操作，Java 6 才引入的偏向锁来优化</p><p>锁重入实例：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">static</span> final <span class="hljs-title class_">Object</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">method1</span>(<span class="hljs-params"></span>) &#123;  <br>    <span class="hljs-title function_">synchronized</span>(<span class="hljs-params"> obj </span>) &#123;  <br>        <span class="hljs-comment">// 同步块 A  </span><br>        <span class="hljs-title function_">method2</span>();  <br>    &#125;  <br>&#125;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">method2</span>(<span class="hljs-params"></span>) &#123;  <br>    <span class="hljs-title function_">synchronized</span>(<span class="hljs-params"> obj </span>) &#123;  <br>    <span class="hljs-comment">// 同步块 B  </span><br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>创建锁记录（Lock Record）对象，每个线程的<strong>栈帧</strong>都会包含一个锁记录的结构，存储锁定对象的 Mark Word</li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041622396.png"></p><ul><li><p>让锁记录中 Object reference 指向锁住的对象，并尝试用 CAS 替换 Object 的 Mark Word，将 Mark Word 的值存入锁记录</p></li><li><p>如果 CAS 替换成功，对象头中存储了锁记录地址和状态 00（轻量级锁） ，表示由该线程给对象加锁<br><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041623035.png"></p></li><li><p>如果 CAS 失败，有两种情况：</p><ul><li><p>如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入锁膨胀过程</p></li><li><p>如果是线程自己执行了 synchronized 锁重入，就添加一条 Lock Record 作为重入的计数</p></li></ul></li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041623988.png"></p><ul><li><p>当退出 synchronized 代码块（解锁时）</p><ul><li><p>如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减 1</p></li><li><p>如果锁记录的值不为 null，这时使用 CAS <strong>将 Mark Word 的值恢复给对象头</strong></p><ul><li><p>成功，则解锁成功</p></li><li><p>失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</p></li></ul></li></ul></li></ul><hr><h5 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h5><p>在尝试加轻量级锁的过程中，CAS 操作无法成功，可能是其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为<strong>重量级锁</strong></p><ul><li>当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁</li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041623875.png"></p><ul><li>Thread-1 加轻量级锁失败，进入锁膨胀流程：为 Object 对象申请 Monitor 锁，<strong>通过 Object 对象头获取到持锁线程</strong>，将 Monitor 的 Owner 置为 Thread-0，将 Object 的对象头指向重量级锁地址，然后自己进入 Monitor 的 EntryList BLOCKED</li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041624894.png"></p><ul><li>当 Thread-0 退出同步块解锁时，使用 CAS 将 Mark Word 的值恢复给对象头失败，这时进入重量级解锁流程，即按照 Monitor 地址找到 Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中 BLOCKED 线程</li></ul><hr><h4 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h4><h5 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h5><p>重量级锁竞争时，尝试获取锁的线程不会立即阻塞，可以使用<strong>自旋</strong>（默认 10 次）来进行优化，采用循环的方式去尝试获取锁</p><p>注意：</p><ul><li><p>自旋占用 CPU 时间，单核 CPU 自旋就是浪费时间，因为同一时刻只能运行一个线程，多核 CPU 自旋才能发挥优势</p></li><li><p>自旋失败的线程会进入阻塞状态</p></li></ul><p>优点：不会进入阻塞状态，<strong>减少线程上下文切换的消耗</strong></p><p>缺点：当自旋的线程越来越多时，会不断的消耗 CPU 资源</p><p>自旋锁情况：</p><ul><li><p>自旋成功的情况：<br><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041624183.png"></p></li><li><p>自旋失败的情况：</p></li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041625916.png"></p><p>自旋锁说明：</p><ul><li><p>在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，比较智能</p></li><li><p>Java 7 之后不能控制是否开启自旋功能，由 JVM 控制</p></li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><br><span class="hljs-comment">//手写自旋锁  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SpinLock</span> &#123;  <br>    <span class="hljs-comment">// 泛型装的是Thread，原子引用线程  </span><br>    AtomicReference&lt;Thread&gt; atomicReference = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;();  <br>  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span>()</span> &#123;  <br>        Thread thread = Thread.currentThread();  <br>        System.<span class="hljs-keyword">out</span>.println(thread.getName() + <span class="hljs-string">&quot; come in&quot;</span>);  <br>  <br>        <span class="hljs-comment">//开始自旋，期望值为null，更新值是当前线程  </span><br>        <span class="hljs-keyword">while</span> (!atomicReference.compareAndSet(<span class="hljs-literal">null</span>, thread)) &#123;  <br>            Thread.sleep(<span class="hljs-number">1000</span>);  <br>            System.<span class="hljs-keyword">out</span>.println(thread.getName() + <span class="hljs-string">&quot; 正在自旋&quot;</span>);  <br>        &#125;  <br>        System.<span class="hljs-keyword">out</span>.println(thread.getName() + <span class="hljs-string">&quot; 自旋成功&quot;</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span>()</span> &#123;  <br>        Thread thread = Thread.currentThread();  <br>  <br>        <span class="hljs-comment">//线程使用完锁把引用变为null  </span><br>atomicReference.compareAndSet(thread, <span class="hljs-literal">null</span>);  <br>        System.<span class="hljs-keyword">out</span>.println(thread.getName() + <span class="hljs-string">&quot; invoke unlock&quot;</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>) throws InterruptedException</span> &#123;  <br>        SpinLock <span class="hljs-keyword">lock</span> = <span class="hljs-keyword">new</span> SpinLock();  <br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;  <br>            <span class="hljs-comment">//占有锁  </span><br>            <span class="hljs-keyword">lock</span>.<span class="hljs-keyword">lock</span>();  <br>            Thread.sleep(<span class="hljs-number">10000</span>);   <br>  <br>            <span class="hljs-comment">//释放锁  </span><br>            <span class="hljs-keyword">lock</span>.unlock();  <br>        &#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();  <br>  <br>        <span class="hljs-comment">// 让main线程暂停1秒，使得t1线程，先执行  </span><br>        Thread.sleep(<span class="hljs-number">1000</span>);  <br>  <br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;  <br>            <span class="hljs-keyword">lock</span>.<span class="hljs-keyword">lock</span>();  <br>            <span class="hljs-keyword">lock</span>.unlock();  <br>        &#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h5><p>锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除，这是 JVM <strong>即时编译器的优化</strong></p><p>锁消除主要是通过<strong>逃逸分析</strong>来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除（同步消除：JVM 逃逸分析）</p><hr><h5 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h5><p>对相同对象多次加锁，导致线程发生多次重入，频繁的加锁操作就会导致性能损耗，可以使用锁粗化方式优化</p><p>如果虚拟机探测到一串的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部</p><ul><li><p>一些看起来没有加锁的代码，其实隐式的加了很多锁：</p><p>  public static String concatString(String s1, String s2, String s3) {<br>  return s1 + s2 + s3;<br>  }</p></li><li><p>String 是一个不可变的类，编译器会对 String 的拼接自动优化。在 JDK 1.5 之前，转化为 StringBuffer 对象的连续 append() 操作，每个 append() 方法中都有一个同步块</p><p>  public static String concatString(String s1, String s2, String s3) {<br>  StringBuffer sb &#x3D; new StringBuffer();<br>  sb.append(s1);<br>  sb.append(s2);<br>  sb.append(s3);<br>  return sb.toString();<br>  }</p></li></ul><p>扩展到第一个 append() 操作之前直至最后一个 append() 操作之后，只需要加锁一次就可以</p><hr><h4 id="多把锁"><a href="#多把锁" class="headerlink" title="多把锁"></a>多把锁</h4><p>多把不相干的锁：一间大屋子有两个功能睡觉、学习，互不相干。现在一人要学习，一人要睡觉，如果只用一间屋子（一个对象锁）的话，那么并发度很低</p><p>将锁的粒度细分：</p><ul><li><p>好处，是可以增强并发度</p></li><li><p>坏处，如果一个线程需要同时获得多把锁，就容易发生死锁</p></li></ul><p>解决方法：准备多个对象锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    <span class="hljs-type">BigRoom</span> <span class="hljs-variable">bigRoom</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigRoom</span>();  <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123; bigRoom.study(); &#125;).start();  <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123; bigRoom.sleep(); &#125;).start();  <br>&#125;  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BigRoom</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">studyRoom</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">sleepRoom</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>        <span class="hljs-keyword">synchronized</span> (sleepRoom) &#123;  <br>            System.out.println(<span class="hljs-string">&quot;sleeping 2 小时&quot;</span>);  <br>            Thread.sleep(<span class="hljs-number">2000</span>);  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>        <span class="hljs-keyword">synchronized</span> (studyRoom) &#123;  <br>            System.out.println(<span class="hljs-string">&quot;study 1 小时&quot;</span>);  <br>            Thread.sleep(<span class="hljs-number">1000</span>);  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="活跃性"><a href="#活跃性" class="headerlink" title="活跃性"></a>活跃性</h4><h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><h6 id="形成"><a href="#形成" class="headerlink" title="形成"></a>形成</h6><p>死锁：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放，由于线程被无限期地阻塞，因此程序不可能正常终止</p><p>Java 死锁产生的四个必要条件：</p><ol><li><p>互斥条件，即当资源被一个线程使用（占有）时，别的线程不能使用</p></li><li><p>不可剥夺条件，资源请求者不能强制从资源占有者手中夺取资源，资源只能由资源占有者主动释放</p></li><li><p>请求和保持条件，即当资源请求者在请求其他的资源的同时保持对原有资源的占有</p></li><li><p>循环等待条件，即存在一个等待循环队列：p1 要 p2 的资源，p2 要 p1 的资源，形成了一个等待环路</p></li></ol><p>四个条件都成立的时候，便形成死锁。死锁情况下打破上述任何一个条件，便可让死锁消失</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dead</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">resources1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">resources2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>            <span class="hljs-comment">// 线程1：占用资源1 ，请求资源2  </span><br>            <span class="hljs-keyword">synchronized</span>(resources1)&#123;  <br>                System.out.println(<span class="hljs-string">&quot;线程1已经占用了资源1，开始请求资源2&quot;</span>);  <br>                Thread.sleep(<span class="hljs-number">2000</span>);<span class="hljs-comment">//休息两秒，防止线程1直接运行完成。  </span><br>                <span class="hljs-comment">//2秒内线程2肯定可以锁住资源2  </span><br>                <span class="hljs-keyword">synchronized</span> (resources2)&#123;  <br>                    System.out.println(<span class="hljs-string">&quot;线程1已经占用了资源2&quot;</span>);  <br>                &#125;  <br>        &#125;).start();  <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>            <span class="hljs-comment">// 线程2：占用资源2 ，请求资源1  </span><br>            <span class="hljs-keyword">synchronized</span>(resources2)&#123;  <br>                System.out.println(<span class="hljs-string">&quot;线程2已经占用了资源2，开始请求资源1&quot;</span>);  <br>                Thread.sleep(<span class="hljs-number">2000</span>);  <br>                <span class="hljs-keyword">synchronized</span> (resources1)&#123;  <br>                    System.out.println(<span class="hljs-string">&quot;线程2已经占用了资源1&quot;</span>);  <br>                &#125;  <br>            &#125;&#125;  <br>        &#125;).start();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h6 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h6><p>定位死锁的方法：</p><ul><li><p>使用 jps 定位进程 id，再用 <code>jstack id</code> 定位死锁，找到死锁的线程去查看源码，解决优化</p><p>  “Thread-1” #12 prio&#x3D;5 os_prio&#x3D;0 tid&#x3D;0x000000001eb69000 nid&#x3D;0xd40 waiting formonitor entry [0x000000001f54f000]<br>  java.lang.Thread.State: BLOCKED (on object monitor)<br>  #省略<br>  “Thread-1” #12 prio&#x3D;5 os_prio&#x3D;0 tid&#x3D;0x000000001eb69000 nid&#x3D;0xd40 waiting for monitor entry [0x000000001f54f000]<br>  java.lang.Thread.State: BLOCKED (on object monitor)<br>  #省略<br>  Found one Java-level deadlock:<br>  “Thread-1”:<br>  waiting to lock monitor 0x000000000361d378 (object 0x000000076b5bf1c0, a java.lang.Object),<br>  which is held by “Thread-0”<br>  “Thread-0”:<br>  waiting to lock monitor 0x000000000361e768 (object 0x000000076b5bf1d0, a java.lang.Object),<br>  which is held by “Thread-1”<br><br>  Java stack information for the threads listed above:<br>  “Thread-1”:<br>  at thread.TestDeadLock.lambda$main$1(TestDeadLock.java:28)<br>  - waiting to lock &lt;0x000000076b5bf1c0&gt; (a java.lang.Object)<br>  - locked &lt;0x000000076b5bf1d0&gt; (a java.lang.Object)<br>  at thread.TestDeadLock$$Lambda$2&#x2F;883049899.run(Unknown Source)<br>  at java.lang.Thread.run(Thread.java:745)<br>  “Thread-0”:<br>  at thread.TestDeadLock.lambda$main$0(TestDeadLock.java:15)<br>  - waiting to lock &lt;0x000000076b5bf1d0&gt; (a java.lang.Object)<br>  - locked &lt;0x000000076b5bf1c0&gt; (a java.lang.Object)<br>  at thread.TestDeadLock$$Lambda$1&#x2F;495053715</p></li><li><p>Linux 下可以通过 top 先定位到 CPU 占用高的 Java 进程，再利用 <code>top -Hp 进程id</code> 来定位是哪个线程，最后再用 jstack &lt; pid&gt;的输出来看各个线程栈</p></li><li><p>避免死锁：避免死锁要注意加锁顺序</p></li><li><p>可以使用 jconsole 工具，在 <code>jdk\bin</code> 目录下</p></li></ul><hr><h5 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h5><p>活锁：指的是任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试—失败—尝试—失败的过程</p><p>两个线程互相改变对方的结束条件，最后谁也无法结束：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestLiveLock</span> &#123;  <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;  <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>            <span class="hljs-comment">// 期望减到 0 退出循环  </span><br>            <span class="hljs-keyword">while</span> (count &gt; <span class="hljs-number">0</span>) &#123;  <br>                Thread.sleep(<span class="hljs-number">200</span>);  <br>                count--;  <br>                System.out.println(<span class="hljs-string">&quot;线程一count:&quot;</span> + count);  <br>            &#125;  <br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();  <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>            <span class="hljs-comment">// 期望超过 20 退出循环  </span><br>            <span class="hljs-keyword">while</span> (count &lt; <span class="hljs-number">20</span>) &#123;  <br>                Thread.sleep(<span class="hljs-number">200</span>);  <br>                count++;  <br>                System.out.println(<span class="hljs-string">&quot;线程二count:&quot;</span>+ count);  <br>            &#125;  <br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h5><p>饥饿：一个线程由于优先级太低，始终得不到 CPU 调度执行，也不能够结束</p><hr><h3 id="wait-ify"><a href="#wait-ify" class="headerlink" title="wait-ify"></a>wait-ify</h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>需要获取对象锁后才可以调用 <code>锁对象.wait()</code>，notify 随机唤醒一个线程，notifyAll 唤醒所有线程去竞争 CPU</p><p>Object 类 API：</p><p>public final void notify():唤醒正在等待对象监视器的单个线程。<br>public final void notifyAll():唤醒正在等待对象监视器的所有线程。<br>public final void wait():导致当前线程等待，直到另一个线程调用该对象的 notify() 方法或 notifyAll()方法。<br>public final native void wait(long timeout):有时限的等待, 到n毫秒后结束等待，或是被唤醒</p><p>说明：<strong>wait 是挂起线程，需要唤醒的都是挂起操作</strong>，阻塞线程可以自己去争抢锁，挂起的线程需要唤醒后去争抢锁</p><p>对比 sleep()：</p><ul><li><p>原理不同：sleep() 方法是属于 Thread 类，是线程用来控制自身流程的，使此线程暂停执行一段时间而把执行机会让给其他线程；wait() 方法属于 Object 类，用于线程间通信</p></li><li><p>对<strong>锁的处理机制</strong>不同：调用 sleep() 方法的过程中，线程不会释放对象锁，当调用 wait() 方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池（不释放锁其他线程怎么抢占到锁执行唤醒操作），但是都会释放 CPU</p></li><li><p>使用区域不同：wait() 方法必须放在<strong>同步控制方法和同步代码块（先获取锁）</strong>中使用，sleep() 方法则可以放在任何地方使用</p></li></ul><p>底层原理：</p><ul><li><p>Owner 线程发现条件不满足，调用 wait 方法，即可进入 WaitSet 变为 WAITING 状态</p></li><li><p>BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片</p></li><li><p>BLOCKED 线程会在 Owner 线程释放锁时唤醒</p></li><li><p>WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，唤醒后并不意味者立刻获得锁，<strong>需要进入 EntryList 重新竞争</strong></p></li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041625177.png"></p><hr><h4 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h4><p>虚假唤醒：notify 只能随机唤醒一个 WaitSet 中的线程，这时如果有其它线程也在等待，那么就可能唤醒不了正确的线程</p><p>解决方法：采用 notifyAll</p><p>notifyAll 仅解决某个线程的唤醒问题，使用 if + wait 判断仅有一次机会，一旦条件不成立，无法重新判断</p><p>解决方法：用 while + wait，当条件不成立，再次 wait</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@Slf4j(topic = &quot;c.demo&quot;)</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">demo</span> &#123;  <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">room</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();  <br>    <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">hasCigarette</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;    <span class="hljs-comment">//有没有烟  </span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">hasTakeout</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>            <span class="hljs-keyword">synchronized</span> (room) &#123;  <br>                log.debug(<span class="hljs-string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);  <br>                <span class="hljs-keyword">while</span> (!hasCigarette) &#123;<span class="hljs-comment">//while防止虚假唤醒  </span><br>                    log.debug(<span class="hljs-string">&quot;没烟，先歇会！&quot;</span>);  <br>                    <span class="hljs-keyword">try</span> &#123;  <br>                        room.wait();  <br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>                        e.printStackTrace();  <br>                    &#125;  <br>                &#125;  <br>                log.debug(<span class="hljs-string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);  <br>                <span class="hljs-keyword">if</span> (hasCigarette) &#123;  <br>                    log.debug(<span class="hljs-string">&quot;可以开始干活了&quot;</span>);  <br>                &#125; <span class="hljs-keyword">else</span> &#123;  <br>                    log.debug(<span class="hljs-string">&quot;没干成活...&quot;</span>);  <br>                &#125;  <br>            &#125;  <br>        &#125;, <span class="hljs-string">&quot;小南&quot;</span>).start();  <br>  <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>            <span class="hljs-keyword">synchronized</span> (room) &#123;  <br>                <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> Thread.currentThread();  <br>                log.debug(<span class="hljs-string">&quot;外卖送到没？[&#123;&#125;]&quot;</span>, hasTakeout);  <br>                <span class="hljs-keyword">if</span> (!hasTakeout) &#123;  <br>                    log.debug(<span class="hljs-string">&quot;没外卖，先歇会！&quot;</span>);  <br>                    <span class="hljs-keyword">try</span> &#123;  <br>                        room.wait();  <br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>                        e.printStackTrace();  <br>                    &#125;  <br>                &#125;  <br>                log.debug(<span class="hljs-string">&quot;外卖送到没？[&#123;&#125;]&quot;</span>, hasTakeout);  <br>                <span class="hljs-keyword">if</span> (hasTakeout) &#123;  <br>                    log.debug(<span class="hljs-string">&quot;可以开始干活了&quot;</span>);  <br>                &#125; <span class="hljs-keyword">else</span> &#123;  <br>                    log.debug(<span class="hljs-string">&quot;没干成活...&quot;</span>);  <br>                &#125;  <br>            &#125;  <br>        &#125;, <span class="hljs-string">&quot;小女&quot;</span>).start();  <br>  <br>  <br>        Thread.sleep(<span class="hljs-number">1000</span>);  <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>        <span class="hljs-comment">// 这里能不能加 synchronized (room)？  </span><br>            <span class="hljs-keyword">synchronized</span> (room) &#123;  <br>                hasTakeout = <span class="hljs-literal">true</span>;  <br><span class="hljs-comment">//log.debug(&quot;烟到了噢！&quot;);  </span><br>                log.debug(<span class="hljs-string">&quot;外卖到了噢！&quot;</span>);  <br>                room.notifyAll();  <br>            &#125;  <br>        &#125;, <span class="hljs-string">&quot;送外卖的&quot;</span>).start();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="park-un"><a href="#park-un" class="headerlink" title="park-un"></a>park-un</h3><p>LockSupport 是用来创建锁和其他同步类的<strong>线程原语</strong></p><p>LockSupport 类方法：</p><ul><li><p><code>LockSupport.park()</code>：暂停当前线程，挂起原语</p></li><li><p><code>LockSupport.unpark(暂停的线程对象)</code>：恢复某个线程的运行</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>        System.out.println(<span class="hljs-string">&quot;start...&quot;</span>);<span class="hljs-comment">//1  </span><br>Thread.sleep(<span class="hljs-number">1000</span>);<span class="hljs-comment">// Thread.sleep(3000)  </span><br>        <span class="hljs-comment">// 先 park 再 unpark 和先 unpark 再 park 效果一样，都会直接恢复线程的运行  </span><br>        System.out.println(<span class="hljs-string">&quot;park...&quot;</span>);<span class="hljs-comment">//2  </span><br>        LockSupport.park();  <br>        System.out.println(<span class="hljs-string">&quot;resume...&quot;</span>);<span class="hljs-comment">//4  </span><br>    &#125;,<span class="hljs-string">&quot;t1&quot;</span>);  <br>    t1.start();  <br>   Thread.sleep(<span class="hljs-number">2000</span>);  <br>    System.out.println(<span class="hljs-string">&quot;unpark...&quot;</span>);<span class="hljs-comment">//3  </span><br>    LockSupport.unpark(t1);  <br>&#125;<br></code></pre></td></tr></table></figure><p>LockSupport 出现就是为了增强 wait &amp; notify 的功能：</p><ul><li><p>wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park、unpark 不需要</p></li><li><p>park &amp; unpark <strong>以线程为单位</strong>来阻塞和唤醒线程，而 notify 只能随机唤醒一个等待线程，notifyAll 是唤醒所有等待线程</p></li><li><p>park &amp; unpark 可以先 unpark，而 wait &amp; notify 不能先 notify。类比生产消费，先消费发现有产品就消费，没有就等待；先生产就直接产生商品，然后线程直接消费</p></li><li><p>wait 会释放锁资源进入等待队列，<strong>park 不会释放锁资源</strong>，只负责阻塞当前线程，会释放 CPU</p></li></ul><p>原理：类似生产者消费者</p><ul><li><p>先 park：</p><ol><li><p>当前线程调用 Unsafe.park() 方法</p></li><li><p>检查 _counter ，本情况为 0，这时获得 _mutex 互斥锁</p></li><li><p>线程进入 _cond 条件变量挂起</p></li><li><p>调用 Unsafe.unpark(Thread_0) 方法，设置 _counter 为 1</p></li><li><p>唤醒 _cond 条件变量中的 Thread_0，Thread_0 恢复运行，设置 _counter 为 0</p></li></ol></li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041626876.png"></p><ul><li><p>先 unpark：</p><ol><li><p>调用 Unsafe.unpark(Thread_0) 方法，设置 _counter 为 1</p></li><li><p>当前线程调用 Unsafe.park() 方法</p></li><li><p>检查 _counter ，本情况为 1，这时线程无需挂起，继续运行，设置 _counter 为 0</p></li></ol></li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041626568.png"></p><hr><h3 id="安全分析"><a href="#安全分析" class="headerlink" title="安全分析"></a>安全分析</h3><p>成员变量和静态变量：</p><ul><li><p>如果它们没有共享，则线程安全</p></li><li><p>如果它们被共享了，根据它们的状态是否能够改变，分两种情况：</p><ul><li><p>如果只有读操作，则线程安全</p></li><li><p>如果有读写操作，则这段代码是临界区，需要考虑线程安全问题</p></li></ul></li></ul><p>局部变量：</p><ul><li><p>局部变量是线程安全的</p></li><li><p>局部变量引用的对象不一定线程安全（逃逸分析）：</p><ul><li><p>如果该对象没有逃离方法的作用访问，它是线程安全的（每一个方法有一个栈帧）</p></li><li><p>如果该对象逃离方法的作用范围，需要考虑线程安全问题（暴露引用）</p></li></ul></li></ul><p>常见线程安全类：String、Integer、StringBuffer、Random、Vector、Hashtable、java.util.concurrent 包</p><ul><li><p>线程安全的是指，多个线程调用它们同一个实例的某个方法时，是线程安全的</p></li><li><p><strong>每个方法是原子的，但多个方法的组合不是原子的</strong>，只能保证调用的方法内部安全：</p><p>  Hashtable table &#x3D; new Hashtable();<br>  &#x2F;&#x2F; 线程1，线程2<br>  if(table.get(“key”) &#x3D;&#x3D; null) {<br>  table.put(“key”, value);<br>  }</p></li></ul><p>无状态类线程安全，就是没有成员变量的类</p><p>不可变类线程安全：String、Integer 等都是不可变类，<strong>内部的状态不可以改变</strong>，所以方法是线程安全</p><ul><li><p>replace 等方法底层是新建一个对象，复制过去</p><p>  Map&lt;String,Object&gt; map &#x3D; new HashMap&lt;&gt;();&#x2F;&#x2F; 线程不安全<br>  String S1 &#x3D; “…”;&#x2F;&#x2F; 线程安全<br>  final String S2 &#x3D; “…”;&#x2F;&#x2F; 线程安全<br>  Date D1 &#x3D; new Date();&#x2F;&#x2F; 线程不安全<br>  final Date D2 &#x3D; new Date();&#x2F;&#x2F; 线程不安全，final让D2引用的对象不能变，但对象的内容可以变</p></li></ul><p>抽象方法如果有参数，被重写后行为不确定可能造成线程不安全，被称之为外星方法：<code>public abstract foo(Student s);</code></p><hr><h3 id="同步模式"><a href="#同步模式" class="headerlink" title="同步模式"></a>同步模式</h3><h4 id="保护性暂停"><a href="#保护性暂停" class="headerlink" title="保护性暂停"></a>保护性暂停</h4><h5 id="单任务版"><a href="#单任务版" class="headerlink" title="单任务版"></a>单任务版</h5><p>Guarded Suspension，用在一个线程等待另一个线程的执行结果</p><ul><li><p>有一个结果需要从一个线程传递到另一个线程，让它们关联同一个 GuardedObject</p></li><li><p>如果有结果不断从一个线程到另一个线程那么可以使用消息队列（见生产者&#x2F;消费者）</p></li><li><p>JDK 中，join 的实现、Future 的实现，采用的就是此模式</p></li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041627568.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    <span class="hljs-type">GuardedObject</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GuardedObjectV2</span>();  <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>        sleep(<span class="hljs-number">1</span>);  <br>        object.complete(Arrays.asList(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>));  <br>    &#125;).start();  <br>      <br>    <span class="hljs-type">Object</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> object.get(<span class="hljs-number">2500</span>);  <br>    <span class="hljs-keyword">if</span> (response != <span class="hljs-literal">null</span>) &#123;  <br>        log.debug(<span class="hljs-string">&quot;get response: [&#123;&#125;] lines&quot;</span>, ((List&lt;String&gt;) response).size());  <br>    &#125; <span class="hljs-keyword">else</span> &#123;  <br>        log.debug(<span class="hljs-string">&quot;can&#x27;t get response&quot;</span>);  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GuardedObject</span> &#123;  <br>    <span class="hljs-keyword">private</span> Object response;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();  <br>  <br>    <span class="hljs-comment">//获取结果  </span><br>    <span class="hljs-comment">//timeout :最大等待时间  </span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> millis)</span> &#123;  <br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;  <br>            <span class="hljs-comment">// 1) 记录最初时间  </span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> System.currentTimeMillis();  <br>            <span class="hljs-comment">// 2) 已经经历的时间  </span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">timePassed</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br>            <span class="hljs-keyword">while</span> (response == <span class="hljs-literal">null</span>) &#123;  <br>                <span class="hljs-comment">// 4) 假设 millis 是 1000，结果在 400 时唤醒了，那么还有 600 要等  </span><br>                <span class="hljs-type">long</span> <span class="hljs-variable">waitTime</span> <span class="hljs-operator">=</span> millis - timePassed;  <br>                log.debug(<span class="hljs-string">&quot;waitTime: &#123;&#125;&quot;</span>, waitTime);  <br>                <span class="hljs-comment">//经历时间超过最大等待时间退出循环  </span><br>                <span class="hljs-keyword">if</span> (waitTime &lt;= <span class="hljs-number">0</span>) &#123;  <br>                    log.debug(<span class="hljs-string">&quot;break...&quot;</span>);  <br>                    <span class="hljs-keyword">break</span>;  <br>                &#125;  <br>                <span class="hljs-keyword">try</span> &#123;  <br>                    lock.wait(waitTime);  <br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>                    e.printStackTrace();  <br>                &#125;  <br>                <span class="hljs-comment">// 3) 如果提前被唤醒，这时已经经历的时间假设为 400  </span><br>                timePassed = System.currentTimeMillis() - begin;  <br>                log.debug(<span class="hljs-string">&quot;timePassed: &#123;&#125;, object is null &#123;&#125;&quot;</span>,  <br>                        timePassed, response == <span class="hljs-literal">null</span>);  <br>            &#125;  <br>            <span class="hljs-keyword">return</span> response;  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//产生结果  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">complete</span><span class="hljs-params">(Object response)</span> &#123;  <br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;  <br>            <span class="hljs-comment">// 条件满足，通知等待线程  </span><br>            <span class="hljs-built_in">this</span>.response = response;  <br>            log.debug(<span class="hljs-string">&quot;notify...&quot;</span>);  <br>            lock.notifyAll();  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="多任务版"><a href="#多任务版" class="headerlink" title="多任务版"></a>多任务版</h5><p>多任务版保护性暂停：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041627603.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;  <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">People</span>().start();  <br>    &#125;  <br>    Thread.sleep(<span class="hljs-number">1000</span>);  <br>    <span class="hljs-keyword">for</span> (Integer id : Mailboxes.getIds()) &#123;  <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Postman</span>(id, id + <span class="hljs-string">&quot;号快递到了&quot;</span>).start();  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-meta">@Slf4j(topic = &quot;c.People&quot;)</span>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-comment">// 收信  </span><br>        <span class="hljs-type">GuardedObject</span> <span class="hljs-variable">guardedObject</span> <span class="hljs-operator">=</span> Mailboxes.createGuardedObject();  <br>        log.debug(<span class="hljs-string">&quot;开始收信i d:&#123;&#125;&quot;</span>, guardedObject.getId());  <br>        <span class="hljs-type">Object</span> <span class="hljs-variable">mail</span> <span class="hljs-operator">=</span> guardedObject.get(<span class="hljs-number">5000</span>);  <br>        log.debug(<span class="hljs-string">&quot;收到信id:&#123;&#125;，内容:&#123;&#125;&quot;</span>, guardedObject.getId(),mail);  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Postman</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;  <br>    <span class="hljs-keyword">private</span> String mail;  <br>    <span class="hljs-comment">//构造方法  </span><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-type">GuardedObject</span> <span class="hljs-variable">guardedObject</span> <span class="hljs-operator">=</span> Mailboxes.getGuardedObject(id);  <br>        log.debug(<span class="hljs-string">&quot;开始送信i d:&#123;&#125;，内容:&#123;&#125;&quot;</span>, guardedObject.getId(),mail);  <br>        guardedObject.complete(mail);  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-keyword">class</span>  <span class="hljs-title class_">Mailboxes</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;Integer, GuardedObject&gt; boxes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hashtable</span>&lt;&gt;();  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;  <br>  <br>    <span class="hljs-comment">//产生唯一的id  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">int</span> <span class="hljs-title function_">generateId</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> id++;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GuardedObject <span class="hljs-title function_">getGuardedObject</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;  <br>        <span class="hljs-keyword">return</span> boxes.remove(id);  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GuardedObject <span class="hljs-title function_">createGuardedObject</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-type">GuardedObject</span> <span class="hljs-variable">go</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GuardedObject</span>(generateId());  <br>        boxes.put(go.getId(), go);  <br>        <span class="hljs-keyword">return</span> go;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Set&lt;Integer&gt; <span class="hljs-title function_">getIds</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> boxes.keySet();  <br>    &#125;  <br>&#125;  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GuardedObject</span> &#123;  <br>    <span class="hljs-comment">//标识，Guarded Object  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<span class="hljs-comment">//添加get set方法  </span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="顺序输出"><a href="#顺序输出" class="headerlink" title="顺序输出"></a>顺序输出</h4><p>顺序输出 2 1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;  <br>            <span class="hljs-comment">//try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; &#125;  </span><br>            <span class="hljs-comment">// 当没有许可时，当前线程暂停运行；有许可时，用掉这个许可，当前线程恢复运行  </span><br>            LockSupport.park();  <br>            System.out.println(<span class="hljs-string">&quot;1&quot;</span>);  <br>        &#125;  <br>    &#125;);  <br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;  <br>            System.out.println(<span class="hljs-string">&quot;2&quot;</span>);  <br>            <span class="hljs-comment">// 给线程 t1 发放『许可』（多次连续调用 unpark 只会发放一个『许可』）  </span><br>            LockSupport.unpark(t1);  <br>            <span class="hljs-keyword">try</span> &#123; Thread.sleep(<span class="hljs-number">500</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; &#125;  <br>        &#125;  <br>    &#125;);  <br>    t1.start();  <br>    t2.start();  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="交替输出"><a href="#交替输出" class="headerlink" title="交替输出"></a>交替输出</h4><p>连续输出 5 次 abc</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">day2_14</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>        <span class="hljs-type">AwaitSignal</span> <span class="hljs-variable">awaitSignal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AwaitSignal</span>(<span class="hljs-number">5</span>);  <br>        <span class="hljs-type">Condition</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> awaitSignal.newCondition();  <br>        <span class="hljs-type">Condition</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> awaitSignal.newCondition();  <br>        <span class="hljs-type">Condition</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> awaitSignal.newCondition();  <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>            awaitSignal.print(<span class="hljs-string">&quot;a&quot;</span>, a, b);  <br>        &#125;).start();  <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>            awaitSignal.print(<span class="hljs-string">&quot;b&quot;</span>, b, c);  <br>        &#125;).start();  <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>            awaitSignal.print(<span class="hljs-string">&quot;c&quot;</span>, c, a);  <br>        &#125;).start();  <br>  <br>        Thread.sleep(<span class="hljs-number">1000</span>);  <br>        awaitSignal.lock();  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            a.signal();  <br>        &#125; <span class="hljs-keyword">finally</span> &#123;  <br>            awaitSignal.unlock();  <br>        &#125;  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AwaitSignal</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ReentrantLock</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> loopNumber;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AwaitSignal</span><span class="hljs-params">(<span class="hljs-type">int</span> loopNumber)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.loopNumber = loopNumber;  <br>    &#125;  <br>    <span class="hljs-comment">//参数1：打印内容  参数二：条件变量  参数二：唤醒下一个  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(String str, Condition condition, Condition next)</span> &#123;  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;  <br>            lock();  <br>            <span class="hljs-keyword">try</span> &#123;  <br>                condition.await();  <br>                System.out.print(str);  <br>                next.signal();  <br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>                e.printStackTrace();  <br>            &#125; <span class="hljs-keyword">finally</span> &#123;  <br>                unlock();  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="异步模式"><a href="#异步模式" class="headerlink" title="异步模式"></a>异步模式</h3><h4 id="传统版"><a href="#传统版" class="headerlink" title="传统版"></a>传统版</h4><p>异步模式之生产者&#x2F;消费者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ShareData</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">condition</span> <span class="hljs-operator">=</span> lock.newCondition();  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;  <br>        <span class="hljs-comment">// 同步代码块，加锁  </span><br>        lock.lock();  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            <span class="hljs-comment">// 判断  防止虚假唤醒  </span><br>            <span class="hljs-keyword">while</span>(number != <span class="hljs-number">0</span>) &#123;  <br>                <span class="hljs-comment">// 等待不能生产  </span><br>                condition.await();  <br>            &#125;  <br>            <span class="hljs-comment">// 干活  </span><br>            number++;  <br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t &quot;</span> + number);  <br>            <span class="hljs-comment">// 通知 唤醒  </span><br>            condition.signalAll();  <br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;  <br>            e.printStackTrace();  <br>        &#125; <span class="hljs-keyword">finally</span> &#123;  <br>            lock.unlock();  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decrement</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;  <br>        <span class="hljs-comment">// 同步代码块，加锁  </span><br>        lock.lock();  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            <span class="hljs-comment">// 判断 防止虚假唤醒  </span><br>            <span class="hljs-keyword">while</span>(number == <span class="hljs-number">0</span>) &#123;  <br>                <span class="hljs-comment">// 等待不能消费  </span><br>                condition.await();  <br>            &#125;  <br>            <span class="hljs-comment">// 干活  </span><br>            number--;  <br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t &quot;</span> + number);  <br>            <span class="hljs-comment">// 通知 唤醒  </span><br>            condition.signalAll();  <br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;  <br>            e.printStackTrace();  <br>        &#125; <span class="hljs-keyword">finally</span> &#123;  <br>            lock.unlock();  <br>        &#125;  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TraditionalProducerConsumer</span> &#123;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">ShareData</span> <span class="hljs-variable">shareData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ShareData</span>();  <br>        <span class="hljs-comment">// t1线程，生产  </span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;  <br>            shareData.increment();  <br>            &#125;  <br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();  <br>  <br>        <span class="hljs-comment">// t2线程，消费  </span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;  <br>shareData.decrement();  <br>            &#125;  <br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();   <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="改进版"><a href="#改进版" class="headerlink" title="改进版"></a>改进版</h4><p>异步模式之生产者&#x2F;消费者：</p><ul><li><p>消费队列可以用来平衡生产和消费的线程资源，不需要产生结果和消费结果的线程一一对应</p></li><li><p>生产者仅负责产生结果数据，不关心数据该如何处理，而消费者专心处理结果数据</p></li><li><p>消息队列是有容量限制的，满时不会再加入数据，空时不会再消耗数据</p></li><li><p>JDK 中各种阻塞队列，采用的就是这种模式</p></li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041627710.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">demo</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">MessageQueue</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageQueue</span>(<span class="hljs-number">2</span>);  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;  <br>            <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> i;  <br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>                queue.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(id,<span class="hljs-string">&quot;值&quot;</span>+id));  <br>            &#125;, <span class="hljs-string">&quot;生产者&quot;</span> + i).start();  <br>        &#125;  <br>          <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;  <br>                <span class="hljs-keyword">try</span> &#123;  <br>                    Thread.sleep(<span class="hljs-number">1000</span>);  <br>                    <span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> queue.take();  <br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>                    e.printStackTrace();  <br>                &#125;  <br>            &#125;  <br>        &#125;,<span class="hljs-string">&quot;消费者&quot;</span>).start();  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-comment">//消息队列类，Java间线程之间通信  </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageQueue</span> &#123;  <br>    <span class="hljs-keyword">private</span> LinkedList&lt;Message&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<span class="hljs-comment">//消息的队列集合  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capacity;<span class="hljs-comment">//队列容量  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MessageQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.capacity = capacity;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//获取消息  </span><br>    <span class="hljs-keyword">public</span> Message <span class="hljs-title function_">take</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-comment">//检查队列是否为空  </span><br>        <span class="hljs-keyword">synchronized</span> (list) &#123;  <br>            <span class="hljs-keyword">while</span> (list.isEmpty()) &#123;  <br>                <span class="hljs-keyword">try</span> &#123;  <br>                    sout(Thread.currentThread().getName() + <span class="hljs-string">&quot;:队列为空，消费者线程等待&quot;</span>);  <br>                    list.wait();  <br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>                    e.printStackTrace();  <br>                &#125;  <br>            &#125;  <br>            <span class="hljs-comment">//从队列的头部获取消息返回  </span><br>            <span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> list.removeFirst();  <br>            sout(Thread.currentThread().getName() + <span class="hljs-string">&quot;：已消费消息--&quot;</span> + message);  <br>            list.notifyAll();  <br>            <span class="hljs-keyword">return</span> message;  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//存入消息  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(Message message)</span> &#123;  <br>        <span class="hljs-keyword">synchronized</span> (list) &#123;  <br>            <span class="hljs-comment">//检查队列是否满  </span><br>            <span class="hljs-keyword">while</span> (list.size() == capacity) &#123;  <br>                <span class="hljs-keyword">try</span> &#123;  <br>                    sout(Thread.currentThread().getName()+<span class="hljs-string">&quot;:队列为已满，生产者线程等待&quot;</span>);  <br>                    list.wait();  <br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>                    e.printStackTrace();  <br>                &#125;  <br>            &#125;  <br>            <span class="hljs-comment">//将消息加入队列尾部  </span><br>            list.addLast(message);  <br>            sout(Thread.currentThread().getName() + <span class="hljs-string">&quot;:已生产消息--&quot;</span> + message);  <br>            list.notifyAll();  <br>        &#125;  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Message</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;  <br>    <span class="hljs-keyword">private</span> Object value;  <br><span class="hljs-comment">//get set  </span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">1</span>);  <br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">producer</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">1</span>);  <br>    BlockingQueue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;&gt;();  <br>    producer.submit(() -&gt; &#123;  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            System.out.println(<span class="hljs-string">&quot;生产...&quot;</span>);  <br>            Thread.sleep(<span class="hljs-number">1000</span>);  <br>            queue.put(<span class="hljs-number">10</span>);  <br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>            e.printStackTrace();  <br>        &#125;  <br>    &#125;);  <br>    consumer.submit(() -&gt; &#123;  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            System.out.println(<span class="hljs-string">&quot;等待消费...&quot;</span>);  <br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> queue.take();  <br>            System.out.println(<span class="hljs-string">&quot;结果为:&quot;</span> + result);  <br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>            e.printStackTrace();  <br>        &#125;  <br>    &#125;);  <br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线程安全</tag>
      
      <tag>并发</tag>
      
      <tag>并行</tag>
      
      <tag>同步</tag>
      
      <tag>异步</tag>
      
      <tag>互斥</tag>
      
      <tag>悲观锁</tag>
      
      <tag>乐观锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重拾设计模式（三）</title>
    <link href="/posts/bd826a18/"/>
    <url>/posts/bd826a18/</url>
    
    <content type="html"><![CDATA[<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><blockquote><p>实现一个商场收银软件，营业员根据客户购买的商品单价和数量收费。</p></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201056028.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201057372.png"></p><blockquote><p>如果要去商场对商品搞活动，所有商品打八折呢。<br>那不就是totalPrices后面乘以0.8么？<br>那难道商场活动结束了，再改造一次代码么？然后再用改后的程序把所有机器全部安装一次么？还有可能周年庆，打五折的情况，如何处理？<br>那再加一个下拉框，选择商品活动呢？</p></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201100218.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201059095.png"></p><blockquote><p>这比刚才灵活性上是好多了，不过重复代码很多，像Convert.ToDouble()，你这里就写了8遍，而且4个分支要执行的语句除了打折多少以外几乎没什么不同，应该考虑重构一下。不过这还不是最主要的，现在我的需求又来了，商场的活动加大，需要有满300返100的促销算法，怎么办？</p></blockquote><h3 id="简单工厂实现"><a href="#简单工厂实现" class="headerlink" title="简单工厂实现"></a>简单工厂实现</h3><blockquote><p>面向对象的编程，并不是类越多越好，类的划分是为了封装，但分类的基础是抽象，具有相同属性和功能的对象的抽象集合才是类。打一折和打九折只是形式的不同，抽象分析出来，所有的打折算法都是一样的，所以打折算法应该是一个类。好了，空话已说了太多，写出来才是真的懂。</p></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201104978.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201105121.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201105619.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201105338.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201105903.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201106421.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201106166.png"></p><blockquote><p>简单工厂模式虽然也能解决这个问题，但这个模式只是解决对象的创建问题，而且由于工厂本身包括了所有的收费方式，商场是可能经常性地更改打折额度和返利额度，每次维护或扩展收费方式都要改动这个工厂，以致代码需重新编译部署，这真的是很糟糕的处理方式，所以用它不是最好的办法。面对算法的时常变动，应该有更好的办法。</p></blockquote><h3 id="策略模式实现"><a href="#策略模式实现" class="headerlink" title="策略模式实现"></a>策略模式实现</h3><blockquote><p>策略模式（Strategy）：它定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。</p></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201114498.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201115485.png"><br><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201115807.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201115497.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201116484.png"></p><blockquote><p>写的CashSuper就是抽象策略，而正常收费CashNormal、打折收费CashRebate和返利收费CashReturn就是三个具体策略，也就是策略模式中说的具体算法。</p><p>模仿策略模式的基本代码，改写一下你的程序。<br>其实不麻烦，原来写的CashSuper、CashNormal、CashRebate和CashReturn都不用更改了，只要加一个CashContext类，并改写一下客户端就行了。</p></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201118128.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201119104.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201119863.png"></p><blockquote><p>代码是模仿着写出来了。但我感觉这样子做不又回到了原来的老路了吗，在客户端去判断用哪一个算法？<br>有没有什么好办法，把这个判断的过程从客户端程序转移走呢？<br>难道简单工厂就一定要是一个单独的类吗？难道不可以与策略模式的Context结合？</p></blockquote><h3 id="策略与简单工厂结合"><a href="#策略与简单工厂结合" class="headerlink" title="策略与简单工厂结合"></a>策略与简单工厂结合</h3><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201121336.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201122776.png"></p><blockquote><p>原来简单工厂模式并非只有建一个工厂类的做法，还可以这样子做。此时比刚才的模仿策略模式的写法要清楚多了，客户端代码简单明了。</p></blockquote><blockquote><p>观察一下，找出它们的不同之处。<br><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201123227.png"></p></blockquote><blockquote><p>简单工厂模式我需要让客户端认识两个类， CashSuper和CashFactory，而策略模式与简单工厂结合的用法，客户端就只需要认识一个类CashContext就可以了。耦合更加降低。</p><p>在客户端实例化的是CashContext的对象，调用的是CashContext的方法GetResult，这使得具体的收费算法彻底地与客户端分离。连算法的父类CashSuper都不让客户端认识了。</p></blockquote><hr><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p class="note note-primary">观察者模式是一种行为设计模式，用于定义对象之间的一对多依赖关系，当一个对象的状态发生变化时，其所有依赖对象都会自动收到通知并进行相应的更新。</p><p>一个软件系统里面包含了各种对象，就像一片欣欣向荣的森林充满了各种生物一样。在一片森林中，各种生物彼此依赖和约束，形成一个个生物链。一种生物的状态变化会造成其他一些生物的相应行动，每一个生物都处于别的生物的互动之中。</p><p>同样，一个软件系统常常要求在某一个对象的状态发生变化的时候，某些其他的对象做出相应的改变。做到这一点的设计方案有很多，但是为了使系统能够易于复用，应该选择低耦合度的设计方案。减少对象之间的耦合有利于系统的复用，但是同时设计师需要使这些低耦合度的对象之间能够维持行动的协调一致，保证高度的协作。观察者模式是满足这一要求的各种设计方案中最重要的一种。</p><p>下面以一个简单的示意性实现为例，讨论观察者模式的结构。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402211139342.png"></p><p>观察者模式所涉及的角色有：</p><p>●　　<strong>抽象主题(Subject)角色：</strong> 抽象主题角色把所有对观察者对象的引用保存在一个聚集（比如ArrayList对象）里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象，抽象主题角色又叫做抽象被观察者(Observable)角色。</p><p>●　　<strong>具体主题(ConcreteSubject)角色：</strong> 将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。具体主题角色又叫做具体被观察者(Concrete Observable)角色。</p><p>●　　<strong>抽象观察者(Observer)角色：</strong> 为所有的具体观察者定义一个接口，在得到主题的通知时更新自己，这个接口叫做更新接口。</p><p>●　　<strong>具体观察者(ConcreteObserver)角色：</strong> 存储与主题的状态自恰的状态。具体观察者角色实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态 像协调。如果需要，具体观察者角色可以保持一个指向具体主题对象的引用。</p><p><strong>抽象主题角色类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Subject</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用来保存注册的观察者对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> List&lt;Observer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Observer&gt;();<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 注册观察者对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> observer    观察者对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attach</span><span class="hljs-params">(Observer observer)</span>&#123;<br>        <br>        list.add(observer);<br>        System.out.println(<span class="hljs-string">&quot;Attached an observer&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除观察者对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> observer    观察者对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">detach</span><span class="hljs-params">(Observer observer)</span>&#123;<br>        <br>        list.remove(observer);<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 通知所有注册的观察者对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyObservers</span><span class="hljs-params">(String newState)</span>&#123;<br>        <br>        <span class="hljs-keyword">for</span>(Observer observer : list)&#123;<br>            observer.update(newState);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>具体主题角色类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteSubject</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Subject</span>&#123;<br>    <br>    <span class="hljs-keyword">private</span> String state;<br>    <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getState</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> state;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">change</span><span class="hljs-params">(String newState)</span>&#123;<br>        state = newState;<br>        System.out.println(<span class="hljs-string">&quot;主题状态为：&quot;</span> + state);<br>        <span class="hljs-comment">//状态发生改变，通知各个观察者</span><br>        <span class="hljs-built_in">this</span>.nodifyObservers(state);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>抽象观察者角色类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Observer</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 更新接口</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> state    更新的状态</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(String state)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>具体观察者角色类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteObserver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Observer</span> &#123;<br>    <span class="hljs-comment">//观察者的状态</span><br>    <span class="hljs-keyword">private</span> String observerState;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(String state)</span> &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 更新观察者的状态，使其与目标的状态保持一致</span><br><span class="hljs-comment">         */</span><br>        observerState = state;<br>        System.out.println(<span class="hljs-string">&quot;状态为：&quot;</span>+observerState);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>客户端类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建主题对象</span><br>        <span class="hljs-type">ConcreteSubject</span> <span class="hljs-variable">subject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteSubject</span>();<br>        <span class="hljs-comment">//创建观察者对象</span><br>        <span class="hljs-type">Observer</span> <span class="hljs-variable">observer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteObserver</span>();<br>        <span class="hljs-comment">//将观察者对象登记到主题对象上</span><br>        subject.attach(observer);<br>        <span class="hljs-comment">//改变主题对象的状态</span><br>        subject.change(<span class="hljs-string">&quot;new state&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出结果</strong>：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402211146366.png"></p><p>在运行时，这个客户端首先创建了具体主题类的实例，以及一个观察者对象。然后，它调用主题对象的attach()方法，将这个观察者对象向主题对象登记，也就是将它加入到主题对象的聚集中去。</p><p>这时，客户端调用主题的change()方法，改变了主题对象的内部状态。主题对象在状态发生变化时，调用超类的notifyObservers()方法，通知所有登记过的观察者对象。</p><h3 id="推模型和拉模型"><a href="#推模型和拉模型" class="headerlink" title="推模型和拉模型"></a>推模型和拉模型</h3><p>在观察者模式中，又分为推模型和拉模型两种方式。<br>●　　<strong>推模型</strong><br>主题对象向观察者推送主题的详细信息，不管观察者是否需要，推送的信息通常是主题对象的全部或部分数据。<br>●　　<strong>拉模型</strong><br>主题对象在通知观察者的时候，只传递少量信息。如果观察者需要更具体的信息，由观察者主动到主题对象中获取，相当于是观察者从主题对象中拉数据。一般这种模型的实现中，会把主题对象自身通过update()方法传递给观察者，这样在观察者需要获取数据的时候，就可以通过这个引用来获取了。</p><p>根据上面的描述，发现前面的例子就是典型的推模型，下面给出一个拉模型的实例。</p><p><strong>拉模型的抽象观察者类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Observer</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 更新接口</span><br><span class="hljs-comment">     * 拉模型通常都是把主题对象当做参数传递。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> subject 传入主题对象，方面获取相应的主题对象的状态</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Subject subject)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>拉模型的具体观察者类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteObserver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Observer</span> &#123;<br>    <span class="hljs-comment">//观察者的状态</span><br>    <span class="hljs-keyword">private</span> String observerState;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Subject subject)</span> &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 更新观察者的状态，使其与目标的状态保持一致</span><br><span class="hljs-comment">         */</span><br>        observerState = ((ConcreteSubject)subject).getState();<br>        System.out.println(<span class="hljs-string">&quot;观察者状态为：&quot;</span>+observerState);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>拉模型的抽象主题类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">　　拉模型的抽象主题类主要的改变是nodifyObservers()方法。在循环通知观察者的时候，也就是循环调用观察者的update()方法的时候，传入的参数不同了。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Subject</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用来保存注册的观察者对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span>    List&lt;Observer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Observer&gt;();<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 注册观察者对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> observer    观察者对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attach</span><span class="hljs-params">(Observer observer)</span>&#123;<br>        <br>        list.add(observer);<br>        System.out.println(<span class="hljs-string">&quot;Attached an observer&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除观察者对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> observer    观察者对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">detach</span><span class="hljs-params">(Observer observer)</span>&#123;<br>        <br>        list.remove(observer);<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 通知所有注册的观察者对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">nodifyObservers</span><span class="hljs-params">()</span>&#123;<br>        <br>        <span class="hljs-keyword">for</span>(Observer observer : list)&#123;<br>            observer.update(<span class="hljs-built_in">this</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>拉模型的具体主题类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">　　跟推模型相比，有一点变化，就是调用通知观察者的方法的时候，不需要传入参数了。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteSubject</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Subject</span>&#123;<br>    <br>    <span class="hljs-keyword">private</span> String state;<br>    <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getState</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> state;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">change</span><span class="hljs-params">(String newState)</span>&#123;<br>        state = newState;<br>        System.out.println(<span class="hljs-string">&quot;主题状态为：&quot;</span> + state);<br>        <span class="hljs-comment">//状态发生改变，通知各个观察者</span><br>        <span class="hljs-built_in">this</span>.nodifyObservers();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="两种模式的比较"><a href="#两种模式的比较" class="headerlink" title="两种模式的比较"></a>两种模式的比较</h3><p>■　　推模型是假定主题对象知道观察者需要的数据；而拉模型是主题对象不知道观察者具体需要什么数据，没有办法的情况下，干脆把自身传递给观察者，让观察者自己去按需要取值。</p><p>■　　推模型可能会使得观察者对象难以复用，因为观察者的update()方法是按需要定义的参数，可能无法兼顾没有考虑到的使用情况。这就意味着出现新情况的时候，就可能提供新的update()方法，或者是干脆重新实现观察者；而拉模型就不会造成这样的情况，因为拉模型下，update()方法的参数是主题对象本身，这基本上是主题对象能传递的最大数据集合了，基本上可以适应各种情况的需要。</p><hr><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p class="note note-primary">命令模式是一种行为设计模式，它允许您将请求封装成对象，使得请求的发送者和接收者彻底解耦。在命令模式中，请求被封装成一个命令对象，这个命令对象可以被传递和存储，从而允许对请求进行参数化和延迟执行。</p><p>命令模式包含以下关键角色：</p><ul><li><strong>Command（命令）</strong>：定义了执行请求的接口。</li><li><strong>ConcreteCommand（具体命令）</strong>：实现了 Command 接口，并封装了请求的接收者。</li><li><strong>Receiver（接收者）</strong>：执行实际操作的对象。</li><li><strong>Invoker（调用者）</strong>：负责调用命令对象执行请求。</li><li><strong>Client（客户端）</strong>：创建命令对象并设置其接收者。</li></ul><p>下面是一个简单的 Java 代码示例，演示了如何使用命令模式来实现一个简单的遥控器控制灯泡的场景：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Command 接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Command</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">// ConcreteCommand 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LightOnCommand</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Command</span> &#123;<br>    <span class="hljs-keyword">private</span> Light light;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LightOnCommand</span><span class="hljs-params">(Light light)</span> &#123;<br>        <span class="hljs-built_in">this</span>.light = light;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span> &#123;<br>        light.turnOn();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Receiver 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Light</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">turnOn</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Light is on&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">turnOff</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Light is off&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Invoker 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RemoteControl</span> &#123;<br>    <span class="hljs-keyword">private</span> Command command;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCommand</span><span class="hljs-params">(Command command)</span> &#123;<br>        <span class="hljs-built_in">this</span>.command = command;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pressButton</span><span class="hljs-params">()</span> &#123;<br>        command.execute();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Client 类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建接收者对象</span><br>        <span class="hljs-type">Light</span> <span class="hljs-variable">light</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Light</span>();<br><br>        <span class="hljs-comment">// 创建命令对象并设置其接收者</span><br>        <span class="hljs-type">Command</span> <span class="hljs-variable">lightOnCommand</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LightOnCommand</span>(light);<br><br>        <span class="hljs-comment">// 创建调用者对象并设置命令对象</span><br>        <span class="hljs-type">RemoteControl</span> <span class="hljs-variable">remoteControl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RemoteControl</span>();<br>        remoteControl.setCommand(lightOnCommand);<br><br>        <span class="hljs-comment">// 模拟按下按钮，执行命令</span><br>        remoteControl.pressButton(); <span class="hljs-comment">// 输出：Light is on</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>在这个示例中，我们创建了一个遥控器（Invoker），并设置了一个命令（Command）来控制灯泡（Receiver）。当我们按下按钮时，调用者会执行命令，命令又会调用接收者执行相应的操作。</p><p>命令模式是一种非常有用的设计模式，它可以将请求封装成对象，从而允许您以参数化的方式进行方法调用、队列请求、日志记录和撤销操作等。</p><p>命令模式非常灵活，允许您轻松地扩展和修改功能。例如，您可以添加新的具体命令类来实现不同的操作，而不需要修改现有的代码。这种可扩展性使得命令模式在面对变化需求时非常有用。</p></blockquote><hr><h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><p class="note note-primary">模板方法模式是一种行为设计模式，它在一个方法中定义了一个算法的骨架，而将一些步骤的具体实现延迟到子类中。这样，可以在不改变算法结构的情况下，重新定义算法的某些步骤。模板方法模式提供了一种代码复用的方式，同时允许更容易地对算法进行定制。</p><p>模板方法模式包含以下关键角色：</p><ul><li><strong>AbstractClass（抽象类）</strong>：定义了一个模板方法，其中包含算法的骨架和一些步骤的具体实现。</li><li><strong>ConcreteClass（具体类）</strong>：实现了抽象类中的某些步骤，完成算法的具体实现。</li></ul><p>下面是一个简单的示例，演示了如何使用模板方法模式来制作咖啡和茶：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 抽象类：饮料</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Beverage</span> &#123;<br>    <span class="hljs-comment">// 模板方法，定义了制作饮料的步骤</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">prepareBeverage</span><span class="hljs-params">()</span> &#123;<br>        boilWater();<br>        brew();<br>        pourInCup();<br>        <span class="hljs-keyword">if</span> (customerWantsCondiments()) &#123;<br>            addCondiments();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 抽象方法，由子类实现</span><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">brew</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addCondiments</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">// 具体方法，共享实现</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">boilWater</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Boiling water&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">pourInCup</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Pouring into cup&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 钩子方法，子类可以选择性地覆盖</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">customerWantsCondiments</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 具体类：咖啡</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Coffee</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Beverage</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">brew</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Dripping Coffee through filter&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">addCondiments</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Adding Sugar and Milk&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 具体类：茶</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tea</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Beverage</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">brew</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Steeping the tea&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">addCondiments</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Adding Lemon&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">customerWantsCondiments</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 茶不加调料</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 客户端代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Beverage</span> <span class="hljs-variable">coffee</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Coffee</span>();<br>        System.out.println(<span class="hljs-string">&quot;Making coffee...&quot;</span>);<br>        coffee.prepareBeverage();<br><br>        System.out.println();<br><br>        <span class="hljs-type">Beverage</span> <span class="hljs-variable">tea</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Tea</span>();<br>        System.out.println(<span class="hljs-string">&quot;Making tea...&quot;</span>);<br>        tea.prepareBeverage();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在这个示例中，<code>Beverage</code> 是抽象类，定义了制作饮料的模板方法 <code>prepareBeverage()</code>，以及一些共享的具体方法。<code>Coffee</code> 和 <code>Tea</code> 是具体类，分别实现了 <code>brew()</code> 和 <code>addCondiments()</code> 方法，以完成制作咖啡和茶的过程。</p><p><strong>JDK 中的应用</strong></p><p>在 JDK 中，模板方法模式被广泛应用。其中一个典型的例子就是在 <code>java.util.AbstractList</code> 类中。这个类实现了 <code>java.util.List</code> 接口，提供了 <code>equals()</code> 和 <code>hashCode()</code> 方法的默认实现，这些方法都是模板方法。以下是 <code>AbstractList</code> 类中的部分核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// java.util.AbstractList 类中的部分代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractList</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractCollection</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">List</span>&lt;E&gt; &#123;<br>    <span class="hljs-comment">// 省略其他方法</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!(o <span class="hljs-keyword">instanceof</span> List)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        Iterator&lt;E&gt; e1 = iterator();<br>        ListIterator&lt;?&gt; e2 = ((List&lt;?&gt;) o).listIterator();<br>        <span class="hljs-keyword">while</span> (e1.hasNext() &amp;&amp; e2.hasNext()) &#123;<br>            <span class="hljs-type">E</span> <span class="hljs-variable">o1</span> <span class="hljs-operator">=</span> e1.next();<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">o2</span> <span class="hljs-operator">=</span> e2.next();<br>            <span class="hljs-keyword">if</span> (!(o1==<span class="hljs-literal">null</span> ? o2==<span class="hljs-literal">null</span> : o1.equals(o2))) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> !(e1.hasNext() || e2.hasNext());<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">hashCode</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (E e : <span class="hljs-built_in">this</span>) &#123;<br>            hashCode = <span class="hljs-number">31</span> * hashCode + (e == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : e.hashCode());<br>        &#125;<br>        <span class="hljs-keyword">return</span> hashCode;<br>    &#125;<br><br>    <span class="hljs-comment">// 省略其他方法</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>equals()</code> 和 <code>hashCode()</code> 方法就是模板方法，它们定义了算法的骨架，具体的比较和哈希计算操作由子类实现。</p><p>模板方法模式是一种非常有用的设计模式，它提供了一种代码复用的方式，并允许在不改变算法结构的情况下，重新定义算法的某些步骤。在 JDK 中，模板方法模式被广泛应用于各种类库和框架中，如集合框架、IO 操作等。</p><hr><h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><p class="note note-primary">状态模式（State Pattern）是一种行为设计模式，它允许对象在其内部状态改变时改变其行为。这种模式的关键是将对象的状态封装成不同的类，并将行为委托给当前状态对象。状态模式可以使得对象的状态转换更加清晰、简单，并且避免了使用大量的条件语句。</p><p><strong>角色介绍</strong></p><ul><li><strong>Context（上下文）</strong>：定义客户端感兴趣的接口，维护一个当前状态对象。</li><li><strong>State（状态）</strong>：定义一个接口，用于封装与 Context 相关的行为。</li><li><strong>ConcreteState（具体状态）</strong>：实现 State 接口的具体状态类，负责处理与状态相关的操作。</li></ul><p><strong>应用示例</strong></p><p>下面是一个简单的示例，演示了如何使用状态模式来实现一个电梯控制器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 上下文类：电梯</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Elevator</span> &#123;<br>    <span class="hljs-keyword">private</span> State state;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Elevator</span><span class="hljs-params">()</span> &#123;<br>        state = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClosedState</span>(); <span class="hljs-comment">// 初始化为关闭状态</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setState</span><span class="hljs-params">(State state)</span> &#123;<br>        <span class="hljs-built_in">this</span>.state = state;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">open</span><span class="hljs-params">()</span> &#123;<br>        state.open(<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> &#123;<br>        state.close(<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">()</span> &#123;<br>        state.move(<span class="hljs-built_in">this</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 状态接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">State</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">open</span><span class="hljs-params">(Elevator elevator)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">(Elevator elevator)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">(Elevator elevator)</span>;<br>&#125;<br><br><span class="hljs-comment">// 具体状态类：关闭状态</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClosedState</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">State</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">open</span><span class="hljs-params">(Elevator elevator)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Opening the door...&quot;</span>);<br>        elevator.setState(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OpenState</span>());<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">(Elevator elevator)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;The door is already closed.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">(Elevator elevator)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Moving the elevator...&quot;</span>);<br>        elevator.setState(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MovingState</span>());<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 具体状态类：打开状态</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">OpenState</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">State</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">open</span><span class="hljs-params">(Elevator elevator)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;The door is already open.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">(Elevator elevator)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Closing the door...&quot;</span>);<br>        elevator.setState(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClosedState</span>());<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">(Elevator elevator)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Cannot move while the door is open.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 具体状态类：运行状态</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MovingState</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">State</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">open</span><span class="hljs-params">(Elevator elevator)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Cannot open the door while the elevator is moving.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">(Elevator elevator)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Cannot close the door while the elevator is moving.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">(Elevator elevator)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;The elevator is already moving.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 客户端代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Elevator</span> <span class="hljs-variable">elevator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Elevator</span>();<br><br>        elevator.open();<br>        elevator.close();<br>        elevator.move();<br>        elevator.open();<br>        elevator.move();<br>        elevator.close();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在这个示例中，<code>Elevator</code> 类是上下文类，负责维护当前状态，并将状态相关的操作委托给当前状态对象。<code>State</code> 接口定义了状态的行为，具体状态类实现了该接口，并负责处理与状态相关的操作。</p><p><strong>JDK 中的应用</strong></p><p>在 JDK 中，状态模式被广泛应用。其中一个典型的例子就是在 <code>java.awt.Component</code> 类中。这个类表示可视化组件，其中的 <code>setVisible()</code> 方法就是使用了状态模式。以下是 <code>Component</code> 类中的部分核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// java.awt.Component 类中的部分代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Component</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> visible;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setVisible</span><span class="hljs-params">(<span class="hljs-type">boolean</span> visible)</span> &#123;<br>        <span class="hljs-built_in">this</span>.visible = visible;<br>        <span class="hljs-keyword">if</span> (visible) &#123;<br>            <span class="hljs-comment">// 显示组件的相关操作</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 隐藏组件的相关操作</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 其他方法</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>Component</code> 类维护了一个 <code>visible</code> 属性，用于表示组件的可见状态。根据这个状态的改变，<code>setVisible()</code> 方法会执行不同的操作，从而改变组件的行为。</p><p>状态模式是一种非常有用的设计模式，它可以使得对象在其内部状态改变时改变其行为。通过将状态封装成不同的类，并委托给当前状态对象处理相关操作，状态模式使得代码更加清晰、简单，并且避免了使用大量的条件语句。</p><hr><h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><p class="note note-primary">责任链模式（Chain of Responsibility Pattern）是一种行为设计模式，它允许多个对象都有机会处理请求，从而避免了请求的发送者和接收者之间的耦合关系。在责任链模式中，请求沿着一个链条传递，直到有一个对象处理它为止。</p><p><strong>角色介绍</strong></p><ul><li><strong>Handler（处理器）</strong>：定义了处理请求的接口，并维护了一个指向下一个处理器的引用。</li><li><strong>ConcreteHandler（具体处理器）</strong>：实现了处理器接口的具体处理器类，负责处理它所能处理的请求，并在不能处理时将请求传递给下一个处理器</li></ul><p><strong>应用示例</strong></p><p>考虑一个简单的购买审批系统，其中包含三个级别的审批人：经理、副总裁和总裁。如果购买金额小于等于1000元，经理可以直接批准；如果金额在1000到5000元之间，需要副总裁审批；如果金额超过5000元，需要总裁审批。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 处理器接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Approver</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">processRequest</span><span class="hljs-params">(PurchaseRequest request)</span>;<br>&#125;<br><br><span class="hljs-comment">// 具体处理器类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Manager</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Approver</span> &#123;<br>    <span class="hljs-keyword">private</span> Approver nextApprover;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processRequest</span><span class="hljs-params">(PurchaseRequest request)</span> &#123;<br>        <span class="hljs-keyword">if</span> (request.getAmount() &lt;= <span class="hljs-number">1000</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Manager approves purchase request #&quot;</span> + request.getId());<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nextApprover != <span class="hljs-literal">null</span>) &#123;<br>            nextApprover.processRequest(request);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;No one can handle the purchase request #&quot;</span> + request.getId());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNextApprover</span><span class="hljs-params">(Approver nextApprover)</span> &#123;<br>        <span class="hljs-built_in">this</span>.nextApprover = nextApprover;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">VicePresident</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Approver</span> &#123;<br>    <span class="hljs-keyword">private</span> Approver nextApprover;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processRequest</span><span class="hljs-params">(PurchaseRequest request)</span> &#123;<br>        <span class="hljs-keyword">if</span> (request.getAmount() &lt;= <span class="hljs-number">5000</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Vice President approves purchase request #&quot;</span> + request.getId());<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nextApprover != <span class="hljs-literal">null</span>) &#123;<br>            nextApprover.processRequest(request);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;No one can handle the purchase request #&quot;</span> + request.getId());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNextApprover</span><span class="hljs-params">(Approver nextApprover)</span> &#123;<br>        <span class="hljs-built_in">this</span>.nextApprover = nextApprover;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">President</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Approver</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processRequest</span><span class="hljs-params">(PurchaseRequest request)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;President approves purchase request #&quot;</span> + request.getId());<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 请求类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PurchaseRequest</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> amount;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PurchaseRequest</span><span class="hljs-params">(<span class="hljs-type">int</span> id, <span class="hljs-type">double</span> amount)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.amount = amount;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getAmount</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> amount;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 客户端代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 构建责任链</span><br>        <span class="hljs-type">Approver</span> <span class="hljs-variable">manager</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Manager</span>();<br>        <span class="hljs-type">Approver</span> <span class="hljs-variable">vicePresident</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VicePresident</span>();<br>        <span class="hljs-type">Approver</span> <span class="hljs-variable">president</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">President</span>();<br><br>        manager.setNextApprover(vicePresident);<br>        vicePresident.setNextApprover(president);<br><br>        <span class="hljs-comment">// 创建购买请求</span><br>        <span class="hljs-type">PurchaseRequest</span> <span class="hljs-variable">request1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PurchaseRequest</span>(<span class="hljs-number">1</span>, <span class="hljs-number">800</span>);<br>        <span class="hljs-type">PurchaseRequest</span> <span class="hljs-variable">request2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PurchaseRequest</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3500</span>);<br>        <span class="hljs-type">PurchaseRequest</span> <span class="hljs-variable">request3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PurchaseRequest</span>(<span class="hljs-number">3</span>, <span class="hljs-number">7000</span>);<br><br>        <span class="hljs-comment">// 处理购买请求</span><br>        manager.processRequest(request1);<br>        manager.processRequest(request2);<br>        manager.processRequest(request3);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>JDK 中的应用</strong></p><p>在 JDK 中，责任链模式被广泛应用。其中一个典型的例子是 Servlet 中的过滤器链。Servlet 过滤器链是一系列过滤器按照顺序链接在一起，每个过滤器负责处理请求或者将请求传递给下一个过滤器。以下是 Servlet 过滤器链的核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Filter</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">FilterChain</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response)</span> <span class="hljs-keyword">throws</span> IOException, ServletException;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>Filter</code> 接口代表一个过滤器，其中的 <code>doFilter()</code> 方法负责处理请求或者将请求传递给下一个过滤器。而 <code>FilterChain</code> 接口表示一个过滤器链，其中的 <code>doFilter()</code> 方法将请求传递给下一个过滤器。</p><hr><h2 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h2><p class="note note-primary">解释器模式（Interpreter Pattern）是一种行为设计模式，用于定义一个语言的文法，并且提供解释器来解释该语言中的语句。这种模式将语言中的语句表示为抽象语法树，并提供一种方式来递归地解释该树中的节点。</p><p><strong>角色介绍</strong></p><ul><li><strong>AbstractExpression（抽象表达式）</strong>：声明了一个抽象的解释方法 <code>interpret()</code>，所有的具体表达式都继承自该抽象类。</li><li><strong>TerminalExpression（终结符表达式）</strong>：实现了抽象表达式接口，表示语言中的终结符，即不可再分解的最小单元。</li><li><strong>NonterminalExpression（非终结符表达式）</strong>：实现了抽象表达式接口，表示语言中的非终结符，即可再分解的复合单元。</li><li><strong>Context（上下文）</strong>：包含解释器需要的一些全局信息或状态。</li></ul><p><strong>应用示例</strong></p><p>假设我们需要实现一个简单的表达式解析器，可以解析简单的四则运算表达式，例如 <code>1 + 2 - 3 * 4</code>。我们可以使用解释器模式来实现这个功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 抽象表达式接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Expression</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">interpret</span><span class="hljs-params">(Context context)</span>;<br>&#125;<br><br><span class="hljs-comment">// 终结符表达式：数字</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumberExpression</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Expression</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> number;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NumberExpression</span><span class="hljs-params">(<span class="hljs-type">int</span> number)</span> &#123;<br>        <span class="hljs-built_in">this</span>.number = number;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">interpret</span><span class="hljs-params">(Context context)</span> &#123;<br>        <span class="hljs-keyword">return</span> number;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 非终结符表达式：加法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddExpression</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Expression</span> &#123;<br>    <span class="hljs-keyword">private</span> Expression left;<br>    <span class="hljs-keyword">private</span> Expression right;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AddExpression</span><span class="hljs-params">(Expression left, Expression right)</span> &#123;<br>        <span class="hljs-built_in">this</span>.left = left;<br>        <span class="hljs-built_in">this</span>.right = right;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">interpret</span><span class="hljs-params">(Context context)</span> &#123;<br>        <span class="hljs-keyword">return</span> left.interpret(context) + right.interpret(context);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 非终结符表达式：减法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubstractExpression</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Expression</span> &#123;<br>    <span class="hljs-keyword">private</span> Expression left;<br>    <span class="hljs-keyword">private</span> Expression right;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SubstractExpression</span><span class="hljs-params">(Expression left, Expression right)</span> &#123;<br>        <span class="hljs-built_in">this</span>.left = left;<br>        <span class="hljs-built_in">this</span>.right = right;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">interpret</span><span class="hljs-params">(Context context)</span> &#123;<br>        <span class="hljs-keyword">return</span> left.interpret(context) - right.interpret(context);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 非终结符表达式：乘法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MultiplyExpression</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Expression</span> &#123;<br>    <span class="hljs-keyword">private</span> Expression left;<br>    <span class="hljs-keyword">private</span> Expression right;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MultiplyExpression</span><span class="hljs-params">(Expression left, Expression right)</span> &#123;<br>        <span class="hljs-built_in">this</span>.left = left;<br>        <span class="hljs-built_in">this</span>.right = right;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">interpret</span><span class="hljs-params">(Context context)</span> &#123;<br>        <span class="hljs-keyword">return</span> left.interpret(context) * right.interpret(context);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">// 上下文类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Context</span> &#123;<br>    <span class="hljs-comment">// 如果需要的话，可以在这里添加一些上下文信息</span><br>&#125;<br><br><span class="hljs-comment">// 客户端代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 构建解释器表达式树：1 + 2 - 3 * 4</span><br>        <span class="hljs-type">Expression</span> <span class="hljs-variable">expression</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubstractExpression</span>(<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">AddExpression</span>( <br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">NumberExpression</span>(<span class="hljs-number">1</span>), <br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">NumberExpression</span>(<span class="hljs-number">2</span>) <br>            ), <br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">MultiplyExpression</span>( <br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">NumberExpression</span>(<span class="hljs-number">3</span>), <br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">NumberExpression</span>(<span class="hljs-number">4</span>) <br>            )<br>        );<br><br>        <span class="hljs-comment">// 创建上下文对象</span><br>        <span class="hljs-type">Context</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Context</span>();<br><br>        <span class="hljs-comment">// 解释表达式并输出结果</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> expression.interpret(context);<br>        System.out.println(<span class="hljs-string">&quot;Result: &quot;</span> + result); <span class="hljs-comment">// 输出：-9</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>解释器模式是一种在特定场景下非常有用的设计模式，它可以帮助我们构建简单的语言解释器，实现对特定语言的解析和执行。通过将语言表示为抽象语法树，并提供一种递归的解释方式，解释器模式使得对复杂语言的处理变得简单、清晰。</p><hr><h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><p class="note note-primary">中介者模式（Mediator Pattern）是一种行为设计模式，它允许对象之间通过一个中介对象进行通信，而不直接相互引用。这种模式可以减少对象之间的耦合，使系统更易于维护和扩展。</p><p><strong>角色介绍</strong></p><ul><li><strong>Mediator（中介者）</strong>：定义了一个接口用于与各个同事对象通信。</li><li><strong>ConcreteMediator（具体中介者）</strong>：实现了中介者接口，负责协调各个同事对象之间的交互。</li><li><strong>Colleague（同事）</strong>：定义了一个接口用于与中介者进行通信。</li><li><strong>ConcreteColleague（具体同事）</strong>：实现了同事接口，每个具体同事对象都知道中介者对象，并通过中介者对象来与其他同事对象通信。</li></ul><p><strong>应用示例</strong></p><p>考虑一个简单的聊天室系统，其中有多个用户可以在聊天室中发送消息。我们可以使用中介者模式来实现该聊天室系统。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 中介者接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ChatMediator</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMessage</span><span class="hljs-params">(String message, User user)</span>;<br>&#125;<br><br><span class="hljs-comment">// 具体中介者类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ChatRoom</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ChatMediator</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMessage</span><span class="hljs-params">(String message, User user)</span> &#123;<br>        System.out.println(user.getName() + <span class="hljs-string">&quot; sends message: &quot;</span> + message);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 同事接口</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">protected</span> ChatMediator mediator;<br>    <span class="hljs-keyword">protected</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(ChatMediator mediator, String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.mediator = mediator;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMessage</span><span class="hljs-params">(String message)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiveMessage</span><span class="hljs-params">(String message)</span>;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 具体同事类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BasicUser</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BasicUser</span><span class="hljs-params">(ChatMediator mediator, String name)</span> &#123;<br>        <span class="hljs-built_in">super</span>(mediator, name);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMessage</span><span class="hljs-params">(String message)</span> &#123;<br>        mediator.sendMessage(message, <span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiveMessage</span><span class="hljs-params">(String message)</span> &#123;<br>        System.out.println(name + <span class="hljs-string">&quot; receives message: &quot;</span> + message);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 客户端代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ChatMediator</span> <span class="hljs-variable">mediator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChatRoom</span>();<br><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BasicUser</span>(mediator, <span class="hljs-string">&quot;Alice&quot;</span>);<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BasicUser</span>(mediator, <span class="hljs-string">&quot;Bob&quot;</span>);<br><br>        mediator.sendMessage(<span class="hljs-string">&quot;Hello, everyone!&quot;</span>, user1);<br>        user2.sendMessage(<span class="hljs-string">&quot;Hi, Alice!&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>中介者模式是一种非常有用的设计模式，它可以帮助我们降低系统中对象之间的耦合度，提高代码的可维护性和可扩展性。通过引入一个中介者对象来管理对象之间的通信，中介者模式使得系统更易于理解和修改。</p><hr><h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><p class="note note-primary">访问者模式（Visitor Pattern）是一种行为设计模式，用于在不修改现有代码的情况下，向对象结构中添加新操作。该模式将操作封装到访问者对象中，并在对象结构中的每个元素上应用访问者，从而实现新的操作。</p><p><strong>角色介绍</strong></p><ul><li><strong>Visitor（访问者）</strong>：定义了一个访问方法，用于接受不同类型元素的访问。</li><li><strong>ConcreteVisitor（具体访问者）</strong>：实现了访问者接口，提供了对元素的具体访问逻辑。</li><li><strong>Element（元素）</strong>：定义了一个接受访问者的方法，用于接受访问者的访问。</li><li><strong>ConcreteElement（具体元素）</strong>：实现了元素接口，提供了对访问者的具体接受方法。</li><li><strong>ObjectStructure（对象结构）</strong>：维护了一个元素的集合，并提供了一个接受访问者的方法。</li></ul><p><strong>应用示例</strong></p><p>假设我们有一个简单的图形界面系统，其中包含不同类型的图形元素，如圆形、矩形等。我们希望对这些图形元素进行不同的操作，比如计算面积、绘制等。我们可以使用访问者模式来实现这个功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 访问者接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ShapeVisitor</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(Circle circle)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(Rectangle rectangle)</span>;<br>&#125;<br><br><span class="hljs-comment">// 具体访问者类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AreaVisitor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ShapeVisitor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(Circle circle)</span> &#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">area</span> <span class="hljs-operator">=</span> Math.PI * Math.pow(circle.getRadius(), <span class="hljs-number">2</span>);<br>        System.out.println(<span class="hljs-string">&quot;Area of circle: &quot;</span> + area);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(Rectangle rectangle)</span> &#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">area</span> <span class="hljs-operator">=</span> rectangle.getWidth() * rectangle.getHeight();<br>        System.out.println(<span class="hljs-string">&quot;Area of rectangle: &quot;</span> + area);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 元素接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(ShapeVisitor visitor)</span>;<br>&#125;<br><br><span class="hljs-comment">// 具体元素类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> radius;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Circle</span><span class="hljs-params">(<span class="hljs-type">double</span> radius)</span> &#123;<br>        <span class="hljs-built_in">this</span>.radius = radius;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getRadius</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> radius;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(ShapeVisitor visitor)</span> &#123;<br>        visitor.visit(<span class="hljs-built_in">this</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> width;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> height;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Rectangle</span><span class="hljs-params">(<span class="hljs-type">double</span> width, <span class="hljs-type">double</span> height)</span> &#123;<br>        <span class="hljs-built_in">this</span>.width = width;<br>        <span class="hljs-built_in">this</span>.height = height;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getWidth</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> width;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getHeight</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> height;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(ShapeVisitor visitor)</span> &#123;<br>        visitor.visit(<span class="hljs-built_in">this</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 对象结构类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ShapeCollection</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;Shape&gt; shapes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addShape</span><span class="hljs-params">(Shape shape)</span> &#123;<br>        shapes.add(shape);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(ShapeVisitor visitor)</span> &#123;<br>        <span class="hljs-keyword">for</span> (Shape shape : shapes) &#123;<br>            shape.accept(visitor);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 客户端代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ShapeCollection</span> <span class="hljs-variable">collection</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ShapeCollection</span>();<br>        collection.addShape(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Circle</span>(<span class="hljs-number">5</span>));<br>        collection.addShape(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Rectangle</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>));<br><br>        <span class="hljs-type">ShapeVisitor</span> <span class="hljs-variable">areaVisitor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AreaVisitor</span>();<br>        collection.accept(areaVisitor);<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>访问者模式是一种非常有用的设计模式，它可以帮助我们在不修改现有代码的情况下，向对象结构中添加新的操作。通过将操作封装到访问者对象中，并在对象结构中的每个元素上应用访问者，访问者模式使得代码更加灵活和易于扩展。</p><hr><h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><p class="note note-primary">备忘录模式（Memento Pattern）是一种行为设计模式，用于捕获对象的内部状态，并在不破坏对象封装性的情况下将其保存在外部，并在需要时恢复对象状态。这种模式有助于实现撤销操作和历史记录功能。</p><p><strong>角色介绍</strong></p><ul><li><strong>Originator（发起人）</strong>：负责创建备忘录对象，并可以使用备忘录对象恢复自身状态。</li><li><strong>Memento（备忘录）</strong>：负责存储发起人对象的内部状态。</li><li><strong>Caretaker（管理者）</strong>：负责保存备忘录对象，并在需要时将其返回给发起人对象。</li></ul><p><strong>应用示例</strong></p><p>假设我们有一个简单的文本编辑器，用户可以在其中输入文本，并且可以通过撤销功能回到之前的状态。我们可以使用备忘录模式来实现这个功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 备忘录类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TextMemento</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String text;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TextMemento</span><span class="hljs-params">(String text)</span> &#123;<br>        <span class="hljs-built_in">this</span>.text = text;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getText</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> text;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 发起人类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TextEditor</span> &#123;<br>    <span class="hljs-keyword">private</span> String text;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setText</span><span class="hljs-params">(String text)</span> &#123;<br>        <span class="hljs-built_in">this</span>.text = text;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getText</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> text;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> TextMemento <span class="hljs-title function_">save</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextMemento</span>(text);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">restore</span><span class="hljs-params">(TextMemento memento)</span> &#123;<br>        <span class="hljs-built_in">this</span>.text = memento.getText();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 管理者类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">History</span> &#123;<br>    <span class="hljs-keyword">private</span> Stack&lt;TextMemento&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(TextMemento memento)</span> &#123;<br>        stack.push(memento);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> TextMemento <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> stack.pop();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 客户端代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">TextEditor</span> <span class="hljs-variable">editor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextEditor</span>();<br>        <span class="hljs-type">History</span> <span class="hljs-variable">history</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">History</span>();<br><br>        editor.setText(<span class="hljs-string">&quot;Hello, world!&quot;</span>);<br>        history.push(editor.save());<br>        System.out.println(<span class="hljs-string">&quot;Current text: &quot;</span> + editor.getText());<br><br>        editor.setText(<span class="hljs-string">&quot;Java Design Patterns&quot;</span>);<br>        history.push(editor.save());<br>        System.out.println(<span class="hljs-string">&quot;Current text: &quot;</span> + editor.getText());<br><br>        <span class="hljs-comment">// 撤销一次</span><br>        editor.restore(history.pop());<br>        System.out.println(<span class="hljs-string">&quot;Current text after undo: &quot;</span> + editor.getText());<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>在这个示例中，<code>TextEditor</code> 类充当了发起人角色，负责创建备忘录对象并保存和恢复状态。</li><li><code>TextMemento</code> 类充当了备忘录角色，负责存储发起人对象的内部状态。</li><li><code>History</code> 类充当了管理者角色，负责保存备忘录对象，并在需要时将其返回给发起人对象。</li></ul><p>备忘录模式是一种非常有用的设计模式，它可以帮助我们实现撤销操作和历史记录功能，而不破坏对象的封装性。通过将对象的状态保存在外部，并在需要时恢复状态，备忘录模式使得程序更加灵活和易于维护。</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>行为型模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重拾设计模式（二）</title>
    <link href="/posts/509408b0/"/>
    <url>/posts/509408b0/</url>
    
    <content type="html"><![CDATA[<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p class="note note-primary">适配器模式（Adapter Pattern）将一个类的接口转换成客户端所希望的另一个接口，适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p><blockquote><p>用电器做例子，笔记本电脑的插头一般都是三相的，即除了阳极、阴极外，还有一个地极。而有些地方的电源插座却只有两极，没有地极。电源插座与笔记本电脑的电源插头不匹配使得笔记本电脑无法使用。这时候一个三相到两相的转换器（适配器）就能解决此问题，而这正像是本模式所做的事情。</p></blockquote><p>适配器模式有<strong>类的适配器模式</strong>和<strong>对象的适配器模式</strong>两种不同的形式。</p><h3 id="类的适配器模式"><a href="#类的适配器模式" class="headerlink" title="类的适配器模式"></a>类的适配器模式</h3><p class="note note-primary">类的适配器模式把适配的类的API转换成为目标类的API。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201630926.png"></p><p>在上图中可以看出，Adaptee类并没有sampleOperation2()方法，而客户端则期待这个方法。为使客户端能够使用Adaptee类，提供一个中间环节，即类Adapter，把Adaptee的API与Target类的API衔接起来。Adapter与Adaptee是继承关系，这决定了这个适配器模式是类的。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201631845.png"></p><p><strong>Target</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Target</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 这是源类Adaptee也有的方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sampleOperation1</span><span class="hljs-params">()</span>; <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 这是源类Adapteee没有的方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sampleOperation2</span><span class="hljs-params">()</span>; <br>&#125;<br></code></pre></td></tr></table></figure><p>上面给出的是目标角色的源代码，这个角色是以一个JAVA接口的形式实现的。可以看出，这个接口声明了两个方法：sampleOperation1()和sampleOperation2()。而源角色Adaptee是一个具体类，它有一个sampleOperation1()方法，但是没有sampleOperation2()方法。</p><p><strong>Adaptee</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Adaptee</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sampleOperation1</span><span class="hljs-params">()</span>&#123;&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>适配器角色Adapter扩展了Adaptee,同时又实现了目标(Target)接口。由于Adaptee没有提供sampleOperation2()方法，而目标接口又要求这个方法，因此适配器角色Adapter实现了这个方法。</p><p><strong>Adapter</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Adapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Adaptee</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Target</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 由于源类Adaptee没有方法sampleOperation2()</span><br><span class="hljs-comment">     * 因此适配器补充上这个方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sampleOperation2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//写相关的代码</span><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="对象的适配器模式"><a href="#对象的适配器模式" class="headerlink" title="对象的适配器模式"></a>对象的适配器模式</h3><p class="note note-primary">与类的适配器模式一样，对象的适配器模式把被适配的类的API转换成为目标类的API，与类的适配器模式不同的是，对象的适配器模式不是使用继承关系连接到Adaptee类，而是使用委派关系连接到Adaptee类</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201634934.png"></p><p>从上图可以看出，Adaptee类并没有sampleOperation2()方法，而客户端则期待这个方法。为使客户端能够使用Adaptee类，需要提供一个包装(Wrapper)类Adapter。这个包装类包装了一个Adaptee的实例，从而此包装类能够把Adaptee的API与Target类的API衔接起来。Adapter与Adaptee是委派关系，这决定了适配器模式是对象的。</p><p><strong>Target</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Target</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 这是源类Adaptee也有的方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sampleOperation1</span><span class="hljs-params">()</span>; <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 这是源类Adapteee没有的方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sampleOperation2</span><span class="hljs-params">()</span>; <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Adaptee</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Adaptee</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sampleOperation1</span><span class="hljs-params">()</span>&#123;&#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Adapter</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Adapter</span> &#123;<br>    <span class="hljs-keyword">private</span> Adaptee adaptee;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Adapter</span><span class="hljs-params">(Adaptee adaptee)</span>&#123;<br>        <span class="hljs-built_in">this</span>.adaptee = adaptee;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 源类Adaptee有方法sampleOperation1</span><br><span class="hljs-comment">     * 因此适配器类直接委派即可</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sampleOperation1</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-built_in">this</span>.adaptee.sampleOperation1();<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 源类Adaptee没有方法sampleOperation2</span><br><span class="hljs-comment">     * 因此由适配器类需要补充此方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sampleOperation2</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//写相关的代码</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="类适配器和对象适配器"><a href="#类适配器和对象适配器" class="headerlink" title="类适配器和对象适配器"></a>类适配器和对象适配器</h3><p>●<strong>类适配器</strong>使用对象继承的方式，是静态的定义方式；而<strong>对象适配器</strong>使用对象组合的方式，是动态组合的方式。</p><p>●<strong>对于类适配器</strong>，由于适配器直接继承了Adaptee，使得适配器不能和Adaptee的子类一起工作，因为继承是静态的关系，当适配器继承了Adaptee后，就不可能再去处理  Adaptee的子类了。</p><p> <strong>对于对象适配器</strong>，一个适配器可以把多种不同的源适配到同一个目标。换言之，同一个适配器可以把源类和它的子类都适配到目标接口。因为对象适配器采用的是对象组合的关系，只要对象类型正确，是不是子类都无所谓。</p><p>●<strong>对于类适配器</strong>，适配器可以重定义Adaptee的部分行为，相当于子类覆盖父类的部分实现方法。</p><p> <strong>对于对象适配器</strong>，要重定义Adaptee的行为比较困难，这种情况下，需要定义Adaptee的子类来实现重定义，然后让适配器组合子类。虽然重定义Adaptee的行为比较困难，但是想要增加一些新的行为则方便的很，而且新增加的行为可同时适用于所有的源。</p><p>●<strong>对于类适配器</strong>，仅仅引入了一个对象，并不需要额外的引用来间接得到Adaptee。</p><p> <strong>对于对象适配器</strong>，需要额外的引用来间接得到Adaptee。</p><p><strong>建议尽量使用对象适配器的实现方式</strong>，多用合成&#x2F;聚合、少用继承。当然，具体问题具体分析，根据需要来选用实现方式，最适合的才是最好的。</p><h3 id="缺省适配模式"><a href="#缺省适配模式" class="headerlink" title="缺省适配模式"></a>缺省适配模式</h3><p class="note note-primary">缺省适配(Default Adapter)模式为一个接口提供缺省实现，这样子类型可以从这个缺省实现进行扩展，而不必从原有接口进行扩展。作为适配器模式的一个特例，缺省是适配模式在JAVA语言中有着特殊的应用。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201706389.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">AbstractService</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serviceOperation1</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">serviceOperation2</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">serviceOperation3</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AbstractService</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serviceOperation1</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">serviceOperation2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">serviceOperation3</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>可以看到，接口AbstractService要求定义三个方法，分别是serviceOperation1()、serviceOperation2()、serviceOperation3()；而抽象适配器类ServiceAdapter则为这三种方法都提供了平庸的实现。因此，任何继承自抽象类ServiceAdapter的具体类都可以选择它所需要的方法实现，而不必理会其他的不需要的方法。</p><p><strong>适配器模式的用意</strong>是要改变源的接口，以便于目标接口相容。<strong>缺省适配的用意稍有不同</strong>，它是为了方便建立一个不平庸的适配器类而提供的一种平庸实现。</p><p>在任何时候，如果不准备实现一个接口的所有方法时，就可以使用“缺省适配模式”制造一个抽象类，给出所有方法的平庸的具体实现。这样，从这个抽象类再继承下去的子类就不必实现所有的方法了。</p></blockquote><hr><h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><p class="note note-primary">桥接模式的本质是把抽象(Abstraction)与行为实现(Implementation)分离开来，从而可以保持各部分的独立性以及应对他们的功能扩展，基于类的最小设计原则，通过使用封装、聚合及继承等行为让不同的类承担不同的职责。</p><p><strong>示例</strong></p><p>一个咖啡店卖咖啡，卖出的咖啡可以从几个角度来看：</p><ol><li><p>口味：摩卡、拿铁、美式等；</p></li><li><p>容量：大杯、中杯、小杯等；</p></li><li><p>添加物：牛奶、糖、蜂蜜等；</p></li><li><p>温度：热、常温、冷等；</p></li></ol><p>如果需要设计一个点餐系统，来生成咖啡订单，如何在系统中将上面说到的拥有4个属性的咖啡生成呢？</p><p><strong>第一种方法</strong></p><p>为每种咖啡组合编写不同的类，如下</p><ol><li><p>大杯热牛奶摩卡类；</p></li><li><p>中杯热牛奶摩卡类；</p></li><li><p>小杯热牛奶摩卡类；</p></li><li><p>大杯热蜂蜜摩卡类； ……</p></li></ol><p>试想一下，需要多少各类？假设4个维度分别可选的值是a、b、c、d，那么需要定义的类就是a x b x c x d种。而且每种属性都是固化到特定的类，没法复用，按照这个方法要定义3x3x3x3&#x3D;81个类。</p><p><strong>第二种方法</strong></p><p>针对第一种方法，我们能不能单独定义每种属性，并让每种属性能够复用，然后将他们组合&#x2F;聚合起来形成一杯咖啡呢？这样就减少每个属性的重复定义了。 例如： 1. 口味：摩卡、拿铁、美式等分别定义一个类；3个类 2. 容量：大杯、中杯、小杯等分别定义一个类；3个类 3. 添加物：牛奶、糖、蜂蜜等分别定义一个类；3个类 4. 温度：热、常温、冷等分别定义一个类；3个类</p><p>如果能够找到一种方法把这4个维度组合起来，是不是总的类数就变成a+b+c+d&#x3D;3+3+3+3&#x3D;12个类？类的数量锐减。</p><p>那么如何将这个4个维度组合起来实现一杯咖啡呢？</p><p><strong>桥接模式的原理</strong></p><p class="note note-primary">桥接模式就是为了实现上面的第二种方法的，先进行抽象，然后通过桥接将属性连接起来。</p><p>看一下下面原理图（初步思路）：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201725509.png"></p><p>再优化一下，进一步思路如下图：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201726170.png"></p><p>想一下，咖啡的最重要的属性就是口味（也可以说是本质的属性），其它的属性相对来说不是最重要的，那么我们就让口味直接通过继承的方式实现属性的集成，其它三个属性为了提升替换性&#x2F;重用性，可以也进行一个抽象类的定义，然后去具体实现。</p><p>这样设计后，通过组合&#x2F;聚合实现了咖啡多个属性的集成，减少了类的数量。</p><p>图中组合&#x2F;聚合关系就是桥接模式中Bridge的核心要义，通过组合&#x2F;聚合将多个属性连接起来的。</p><p>最后就形成了桥接模式的通用示意图，如下：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201730057.png"></p><p>**桥接模式的角色：</p><ul><li><p> <strong>抽象化(Abstraction)角色</strong>：抽象化给出的定义，并保存一个对实现化对象的引用，就是上面所说的Coffe抽象类。</p></li><li><p><strong>修正抽象化(RefinedAbstraction)角色</strong>：扩展抽象化角色，改变和修正父类对抽象化的定义，就是上面的<strong>口味实现类</strong>。  </p></li><li><p><strong>实现化(Implementor)角色</strong>：这个角色给出实现化角色的接口，但不给出具体的实现。必须指出的是，这个接口不一定和抽象化角色的接口定义相同，实际上，这两个接口可以非常不一样。实现化角色应当只给出底层操作，而抽象化角色应当只给出基于底层操作的更高一层的操作。就是上面的<strong>容量、温度、添加物抽象类</strong>。  </p></li><li><p><strong>具体实现化(ConcreteImplementor)角色</strong>：这个角色给出实现化角色接口的具体实现，就是上面的<strong>容量、温度、添加物实现类</strong>。</p></li></ul><blockquote><ol><li>抽象化(Abstraction)角色：Coffe抽象类-AbstractCoffe类的定义</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractCoffe</span> &#123;<br>    <span class="hljs-comment">// 重点：此处就是连接其它属性的关键，通过成员变量的方式聚合了其它属性</span><br>    ICapacity capacity;<br>    IAdditives additives;<br>    ITemperature temperature;<br><br>    <span class="hljs-comment">// 此处通过有参构造的方式接受客户端想要的咖啡属性</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AbstractCoffe</span><span class="hljs-params">(ICapacity capacity,IAdditives additives,ITemperature temperature)</span>&#123;<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>        <span class="hljs-built_in">this</span>.additives = additives;<br>        <span class="hljs-built_in">this</span>.temperature = temperature;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Order</span><span class="hljs-params">(<span class="hljs-type">int</span> count)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ol start="2"><li>修正抽象化(RefinedAbstraction)角色:口味实现类-MocaCoffe类定义</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MocaCoffe</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractCoffe</span>&#123;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">MocaCoffe</span><span class="hljs-params">(ICapacity capacity,IAdditives additives,ITemperature temperature)</span>&#123;<br>        <span class="hljs-built_in">super</span>(capacity, additives, temperature);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Order</span><span class="hljs-params">(<span class="hljs-type">int</span> count)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;开始制作摩卡咖啡：&quot;</span>);<br>        capacity.SetCupCapacity();<br>        additives.AddAdditives();<br>        temperature.SetTemperature();<br>        System.out.println(count+<span class="hljs-string">&quot; 杯Moca Coffe制作完成！&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//本例中就实现了一种类型，就是摩卡，还可以实现其它的口味类型，代码类似，此处就省略了。</span><br></code></pre></td></tr></table></figure><blockquote><ol start="3"><li>实现化(Implementor)角色:容量、温度、添加物抽象类-ICapacity、ITemperature、IAdditives抽象类定义</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//（1）容量抽象类ICapacity</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ICapacity</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">SetCupCapacity</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//（2）温度抽象类ITemperature</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ITemperature</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">SetTemperature</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//（3）添加物抽象类IAdditives</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IAdditives</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">AddAdditives</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ol start="4"><li>具体实现化(ConcreteImplementor)角色:容量、温度、添加物实现类-Capacity、Temperature、Additives抽象类定义</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">（1）Capacity实现类-3种</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// 大杯</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LargeCapacity</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ICapacity</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">SetCupCapacity</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;制作杯子尺寸：Large&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//中杯</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MiddleCapacity</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ICapacity</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">SetCupCapacity</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;制作杯子尺寸：Middle&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//小杯</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SmallCapacity</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ICapacity</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">SetCupCapacity</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;制作杯子尺寸：Small&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">（2）Temperature实现类-3种</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// 热饮</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HotTemperature</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ITemperature</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">SetTemperature</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;加热温度至：Hot&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 冷饮</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NormalTemperature</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ITemperature</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">SetTemperature</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;加热温度至：Normal&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 常温</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ColdTemperature</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ITemperature</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">SetTemperature</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;加热温度至：Cold&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">（3）Additives实现类-2种</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// 加奶</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MilkAdditives</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IAdditives</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">AddAdditives</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;添加 MILK 成功！&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 加糖</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SugarAdditives</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IAdditives</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">AddAdditives</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;添加 SUGAR 成功！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ol start="5"><li>客户端类定义</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 客户端传入想要的咖啡各个属性的具体对象</span><br>        <span class="hljs-type">AbstractCoffe</span> <span class="hljs-variable">mocaCoffe</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MocaCoffe</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MiddleCapacity</span>(),<span class="hljs-keyword">new</span> <span class="hljs-title class_">SugarAdditives</span>(),<span class="hljs-keyword">new</span> <span class="hljs-title class_">ColdTemperature</span>());<br>        mocaCoffe.Order(<span class="hljs-number">4</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li><p>抽象与实现分离，扩展能力强，符合开闭原则。  </p></li><li><p>实现细节对客户透明。  </p></li><li><p>减少了因为继承带来的类爆炸。</p></li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li><p>抽象难度大；  </p></li><li><p>类之间的关系变得复杂。</p></li></ul><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li><p>某个类有多个的维度的变化，如果用继承就会使项目变的臃肿，会产生许多的子类。  </p></li><li><p>抽象的部分和实现的部分都应该可以扩展。</p></li></ul><hr><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p class="note note-primary">组合模式（Composite Pattern）是一种结构型设计模式，允许你将对象组合成树形结构以表示“整体-部分”关系。组合模式使得客户端对单个对象和组合对象的使用具有一致性，从而可以将复杂的对象结构简化为一组简单的递归关系。<br/>在组合模式中，对象被组织成树形结构，其中包括复合对象（组合）和叶子对象。复合对象可以包含多个叶子对象和其他复合对象，而叶子对象不能包含任何其他对象。这些对象具有相同的接口，客户端可以通过相同的方式使用它们。</p><p>组合模式通过以下几个组件实现：</p><ol><li>抽象组件（Component）：定义了组合对象和叶子对象的公共接口。</li><li>叶子组件（Leaf Component）：表示组合中的叶子对象，不能包含任何子对象。</li><li>复合组件（Composite Component）：表示组合中的复合对象，可以包含其他叶子对象和复合对象。</li><li>客户端（Client）：使用组合对象的客户端，通过组件的公共接口与组合对象进行交互。</li></ol><p>组合模式的优点包括：</p><ol><li>简化客户端代码：客户端可以像处理单个对象一样处理组合对象，无需关心其内部结构和类型。</li><li>灵活性：可以动态地添加或删除组合对象，而无需更改现有代码。</li><li>可扩展性：可以通过添加新的叶子和复合对象扩展现有组合对象。</li><li>符合单一职责原则：组合对象只负责管理其子对象，而具体的对象操作则交由叶子对象或复合对象实现。</li></ol><p>一个简单的组合模式示例是一个文件系统，其中目录可以包含其他目录和文件。在这种情况下，文件和目录都可以看作是组合对象，它们具有相同的接口，可以相互组合。这种结构可以通过组合模式实现，并将目录和文件表示为组合对象的复合和叶子。</p><p><strong>在Java中实现的简单demo</strong></p><blockquote><p>1.定义抽象组件（Component）接口，它是组合对象和叶子对象的公共接口。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Component</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>2.定义叶子组件（Leaf Component）类，它表示组合中的叶子对象。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Leaf</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Component</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 叶子对象的具体操作</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>3.定义复合组件（Composite Component）类，它表示组合中的复合对象，可以包含其他叶子对象和复合对象。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Composite</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Component</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;Component&gt; children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 复合对象的具体操作</span><br>        <span class="hljs-keyword">for</span> (Component child : children) &#123;<br>            child.operation();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Component component)</span> &#123;<br>        children.add(component);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Component component)</span> &#123;<br>        children.remove(component);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Component <span class="hljs-title function_">getChild</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">return</span> children.get(index);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>4.定义客户端（Client）类，使用组合对象的客户端，通过组件的公共接口与组合对象进行交互。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Component</span> <span class="hljs-variable">leaf1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Leaf</span>();<br>        <span class="hljs-type">Component</span> <span class="hljs-variable">leaf2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Leaf</span>();<br><br>        <span class="hljs-type">Composite</span> <span class="hljs-variable">composite1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Composite</span>();<br>        composite1.add(leaf1);<br>        composite1.add(leaf2);<br><br>        <span class="hljs-type">Component</span> <span class="hljs-variable">leaf3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Leaf</span>();<br>        <span class="hljs-type">Component</span> <span class="hljs-variable">leaf4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Leaf</span>();<br><br>        <span class="hljs-type">Composite</span> <span class="hljs-variable">composite2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Composite</span>();<br>        composite2.add(leaf3);<br>        composite2.add(leaf4);<br>        composite2.add(composite1);<br><br>        composite2.operation();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>在这个例子中，我们创建了一个复合对象，它包含两个叶子对象和一个嵌套的复合对象。客户端代码可以像处理单个对象一样处理组合对象，而无需关心其内部结构和类型。在这个例子中，我们通过调用 <code>composite2.operation()</code> 方法，递归调用了复合对象和叶子对象的 <code>operation()</code> 方法。</p></blockquote><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol><li>当你需要表示对象的整体-部分层次结构时，可以使用组合模式。例如，文件系统中的目录和文件，GUI中的窗口和控件，组织结构图中的部门和员工等。</li><li>当你希望客户端能够统一处理复合对象和叶子对象时，可以使用组合模式。例如，你<strong>希望像处理单个对象一样处理组合对象，而无需区分它们的内部结构和类型</strong>。</li><li>当你需要以递归方式遍历复合对象中的所有元素时，可以使用组合模式。例如，你希望对文件系统中的目录和文件进行递归遍历，或对组织结构图中的部门和员工进行递归遍历。</li><li>当你需要添加或删除组合对象中的子元素时，可以使用组合模式。例如，你需要在文件系统中添加或删除目录和文件，或在组织结构图中添加或删除部门和员工。</li></ol><p>总之，组合模式适用于需要表示对象的整体-部分层次结构，并希望以统一的方式处理复合对象和叶子对象的场景。它可以使得代码更加灵活、易于扩展，并且符合面向对象设计的开闭原则。</p><hr><h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><p class="note note-primary">装饰器模式（Decorator Pattern）属于设计模式中的结构型模式，它是作为现有的类的一个包装。实现方式一般是创建一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。在想要增强某个对象的功能但是又不想改变该对象的代码时，可以引入装饰器模式。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201753494.png"></p><p>抽象组件（Component）：定义了原始对象和装饰器对象的共同接口，可以是抽象类或接口。<br>具体组件（ConcreteComponent）：实现了抽象组件接口，是需要被装饰的原始对象。<br>抽象装饰器（Decorator）：继承了抽象组件，持有一个抽象组件对象的引用，并定义了与抽象组件相同的接口。<br>具体装饰器（ConcreteDecorator）：继承了抽象装饰器，通过对抽象组件进行装饰，添加额外的功能。</p><p><strong>Component</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Coffee</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">drink</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>ConcreteComponent</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cappuccino</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Coffee</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drink</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;上一杯卡布奇诺！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Decorator</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Decorator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Coffee</span> &#123;<br>    Coffee coffee;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Decorator</span><span class="hljs-params">(Coffee coffee)</span> &#123;<br>        <span class="hljs-built_in">this</span>.coffee = coffee;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drink</span><span class="hljs-params">()</span> &#123;<br>        coffee.drink();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>ConcreteDecorator</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteDecorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Decorator</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcreteDecorator</span><span class="hljs-params">(Coffee coffee)</span> &#123;<br>        <span class="hljs-built_in">super</span>(coffee);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drink</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;上一杯加糖后的卡布奇诺！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">//原对象</span><br>    <span class="hljs-type">Coffee</span> <span class="hljs-variable">cappuccino</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cappuccino</span>();<br>    cappuccino.drink();<br>    <span class="hljs-comment">//装饰对象</span><br>    <span class="hljs-type">Coffee</span> <span class="hljs-variable">decorator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteDecorator</span>(cappuccino);<br>    decorator.drink();<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><p class="note note-primary">为子系统的接口提供一组统一的入口。外观模式定义了一个高层接口，这个接口使得子系统的更加容易使用。</p><p>在外观模式中，一个子系统的外部与其内部通信通过一个统一的外观类进行，外观类将客户类与子系统的内部复杂性分隔，使得客户类只需要与外观角色打交道，而不需要与子系统内部的很多其他对象交互。</p><p>外观模式是<strong>迪米特法则</strong>的一种具体实现，通过引入一个外观角色降低原有系统的复杂度，同时降低客户类与子系统的耦合度。</p><blockquote><p><strong>迪米特法则：</strong> 每一个软件单元对其他单元都只有最少的信息，而且局限于那些与本单元密切相关的软件单元。迪米特法则要求一个软件实体应该尽可能少地与其他实体发生相互作用。</p></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402202050224.png"></p><p>一个典型的用户与一个系统（汽车）中的多个子系统（动力系统，离合器，变速器，油门）进行交互的情形，用户需要和所有的子系统交互，才能完成自己想要实现的功能，这其实是极不合理的，也极容易出错。</p><p>首先来看看各个子系统的定义，包括：动力系统、离合器、加速器、变速器四个子系统。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 动力系统</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PowerSystem</span> &#123;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 汽车发动</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startUp</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;汽车发动。。。。&quot;</span>);<br>&#125;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 汽车熄火</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">closeDown</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;汽车熄火。。。。&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 离合器</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClutchSystem</span> &#123;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 踩下离合</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">press</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;踩下离合。。。。&quot;</span>);<br>&#125;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 松开离合</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">release</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;松开离合。。。。&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 变速器</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TransmissionSystem</span> &#123;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 挂挡操作</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> gear 所挂档位</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shift</span><span class="hljs-params">(<span class="hljs-type">int</span> gear)</span> &#123;<br><span class="hljs-keyword">switch</span> (gear) &#123;<br><span class="hljs-keyword">case</span> -<span class="hljs-number">1</span>:<br>System.out.println(<span class="hljs-string">&quot;挂倒档。。。。&quot;</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>System.out.println(<span class="hljs-string">&quot;挂空档。。。。&quot;</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>System.out.println(<span class="hljs-string">&quot;挂一档。。。。&quot;</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>System.out.println(<span class="hljs-string">&quot;挂二档。。。。&quot;</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>System.out.println(<span class="hljs-string">&quot;挂三档。。。。&quot;</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>System.out.println(<span class="hljs-string">&quot;挂四档。。。。&quot;</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>System.out.println(<span class="hljs-string">&quot;挂五档。。。。&quot;</span>);<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 加速器，即油门</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AcceleratorSystem</span> &#123;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 踩下油门</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">press</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;踩下油门。。。。&quot;</span>);<br>&#125;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 松开油门</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">release</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;松开油门。。。。&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来该看看外观的定义了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 外观类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Facade</span> &#123;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 示意方法，停车起步</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parkingStart</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">// 创建需要转调的子系统对象实例</span><br><span class="hljs-type">ClutchSystem</span> <span class="hljs-variable">clutchSystem</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClutchSystem</span>();<br><span class="hljs-type">TransmissionSystem</span> <span class="hljs-variable">transmissionSystem</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransmissionSystem</span>();<br><span class="hljs-type">AcceleratorSystem</span> <span class="hljs-variable">acceleratorSystem</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AcceleratorSystem</span>();<br><span class="hljs-comment">// 转调子系统的功能</span><br>clutchSystem.press();<br>transmissionSystem.shift(<span class="hljs-number">1</span>);<br>clutchSystem.release();<br>acceleratorSystem.press();<br>System.out.println(<span class="hljs-string">&quot;汽车开始动了。。。。&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建一个客户端类测试一下，示例代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br> <br><span class="hljs-type">PowerSystem</span> <span class="hljs-variable">powerSystem</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PowerSystem</span>();<br><span class="hljs-comment">// 发动汽车</span><br><span class="hljs-comment">// 此处作为示意，用户可以跳过外观，直接与子系统进行交互</span><br>powerSystem.startUp();<br><span class="hljs-comment">// 创建外观实例</span><br><span class="hljs-type">Facade</span> <span class="hljs-variable">facade</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Facade</span>();<br><span class="hljs-comment">// 停车起步</span><br>facade.parkingStart();<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">并未把“发动汽车”这个步骤一并加入的Facade对象中，主要是为了作一个示意：根据实际需要，用户是可以越过Facade层，直接与子系统进行交互的。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">汽车发动。。。。<br>踩下离合。。。。<br>挂一档。。。。<br>松开离合。。。。<br>踩下油门。。。。<br>汽车开始动了。。。。<br></code></pre></td></tr></table></figure><h3 id="抽象外观类"><a href="#抽象外观类" class="headerlink" title="抽象外观类"></a>抽象外观类</h3><p class="note note-primary">在上述外观模式中，如果需要增加或删除与外观类交互的子系统类，必须修改原有代码，**违背开闭原则**，因此可以通过引入**抽象外观类**对系统进行改进。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402202056641.png"></p><p>引入抽象外观类之后，客户端可以针对抽象层编程，对于新的业务需求，不需要修改原有的外观类，直接增加一个新的具体外观类即可，符合开闭原则。</p><hr><h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p class="note note-primary">享元模式（Flyweight Pattern）是一种结构型设计模式，它旨在通过共享对象来最大限度地减少内存使用和提高性能。</p>>享元模式的核心思想是将对象的状态（内部数据）分为内部状态（Intrinsic State）和外部状态（Extrinsic State）。内部状态是对象可以共享的状态，它独立于对象的场景，可以被多个对象共享。外部状态是对象特定于场景的状态，它不可共享，每个对象需要自己管理。>>享元模式的关键是引入一个享元工厂（Flyweight Factory），它负责创建和管理享元对象。当客户端需要对象时，它首先向享元工厂请求对象。如果对象已存在，享元工厂直接返回现有对象；如果对象不存在，享元工厂创建一个新的对象，并在需要时进行共享。<p>以下是享元模式的组成部分：</p><ol><li>享元接口（Flyweight）：定义共享对象的接口，包括操作共享状态的方法。</li><li>具体享元（Concrete Flyweight）：实现享元接口，并存储内部状态。</li><li>享元工厂（Flyweight Factory）：负责创建和管理享元对象，确保对象的共享和复用。</li></ol><p>下面是一个简单的 Java 代码示例，演示了如何使用享元模式来共享数字对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-comment">// Flyweight 接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Number</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">printNumber</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">// ConcreteFlyweight 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteNumber</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Number</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> value;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcreteNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-built_in">this</span>.value = value;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printNumber</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Printing number: &quot;</span> + value);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// FlyweightFactory 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumberFactory</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;Integer, Number&gt; numberMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Number <span class="hljs-title function_">getNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!numberMap.containsKey(value)) &#123;<br>            numberMap.put(value, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteNumber</span>(value));<br>        &#125;<br>        <span class="hljs-keyword">return</span> numberMap.get(value);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 客户端代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 获取共享的数字对象</span><br>        <span class="hljs-type">Number</span> <span class="hljs-variable">number1</span> <span class="hljs-operator">=</span> NumberFactory.getNumber(<span class="hljs-number">5</span>);<br>        <span class="hljs-type">Number</span> <span class="hljs-variable">number2</span> <span class="hljs-operator">=</span> NumberFactory.getNumber(<span class="hljs-number">10</span>);<br><br>        <span class="hljs-comment">// 输出结果</span><br>        number1.printNumber(); <span class="hljs-comment">// 输出：Printing number: 5</span><br>        number2.printNumber(); <span class="hljs-comment">// 输出：Printing number: 10</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在这个示例中，<code>NumberFactory</code> 充当享元工厂的角色，负责创建和管理数字对象。当客户端请求一个数字时，工厂首先检查对象是否已存在，如果存在则返回已有的对象，如果不存在则创建一个新的对象并添加到工厂中。这样就实现了数字对象的共享，避免了重复创建，节省了内存资源。</p><p>享元模式是一种非常有用的设计模式，可以在系统中存在大量相似对象时节省内存资源。通过共享对象的状态，可以显著减少对象的数量，提高系统的性能和效率。在实际开发中，我们可以根据具体的需求来应用享元模式，从而优化系统的设计和实现。</p><hr><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p class="note note-primary">代理模式是一种结构型设计模式，其主要目的是为其他对象提供一种代理以控制对这个对象的访问。代理对象通常充当客户端和实际对象之间的中介，它可以在访问实际对象之前或之后执行一些额外的操作，例如权限控制、延迟加载、缓存等。</p><p>代理模式包含以下关键角色：</p><ul><li><strong>Subject（抽象主题）</strong>：定义了代理对象和真实对象的公共接口，客户端通过这个接口访问真实对象和代理对象。</li><li><strong>RealSubject（真实主题）</strong>：定义了真实对象，是代理对象所代表的真实内容。</li><li><strong>Proxy（代理）</strong>：保存了一个引用，使得代理可以访问实际主题，同时提供了与主题相同的接口，客户端通过代理访问真实主题。</li></ul><p>下面是一个简单的 Java 代码示例，演示了如何使用代理模式来控制对实际对象的访问，并在访问前后执行额外的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Subject 接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Image</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">// RealSubject 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RealImage</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Image</span> &#123;<br>    <span class="hljs-keyword">private</span> String filename;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RealImage</span><span class="hljs-params">(String filename)</span> &#123;<br>        <span class="hljs-built_in">this</span>.filename = filename;<br>        loadFromDisk(filename);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Displaying &quot;</span> + filename);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadFromDisk</span><span class="hljs-params">(String filename)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Loading &quot;</span> + filename + <span class="hljs-string">&quot; from disk&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Proxy 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyImage</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Image</span> &#123;<br>    <span class="hljs-keyword">private</span> RealImage realImage;<br>    <span class="hljs-keyword">private</span> String filename;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ProxyImage</span><span class="hljs-params">(String filename)</span> &#123;<br>        <span class="hljs-built_in">this</span>.filename = filename;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//延迟加载</span><br>        <span class="hljs-keyword">if</span> (realImage == <span class="hljs-literal">null</span>) &#123;<br>            realImage = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RealImage</span>(filename);<br>        &#125;<br>        realImage.display();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 客户端代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Image</span> <span class="hljs-variable">image</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProxyImage</span>(<span class="hljs-string">&quot;test.jpg&quot;</span>);<br><br>        <span class="hljs-comment">// 图像将从磁盘加载</span><br>        image.display();<br>        System.out.println();<br><br>        <span class="hljs-comment">// 图像将不会从磁盘加载</span><br>        image.display();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在这个示例中，<code>Image</code> 接口定义了图片展示的公共方法 <code>display()</code>。<code>RealImage</code> 类表示真实的图片对象，而 <code>ProxyImage</code> 类充当了代理，负责控制对真实图片对象的访问。当客户端首次调用 <code>display()</code> 方法时，<code>ProxyImage</code> 会创建一个真实图片对象，并调用其 <code>display()</code> 方法展示图片。之后再次调用 <code>display()</code> 方法时，由于已经创建了真实图片对象，代理将直接调用真实图片对象的 <code>display()</code> 方法展示图片。</p><p>再来看一个关于缓存的示例，<strong>缓存</strong>是指将经常使用的数据存储在临时存储区域中，以加快数据访问速度。通过代理模式，我们可以在代理类中添加缓存逻辑，然后在访问真实对象之前先检查缓存是否存在。下面是一个简单的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-comment">// 接口：数据访问</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">DataAccessor</span> &#123;<br>    String <span class="hljs-title function_">getData</span><span class="hljs-params">(String key)</span>;<br>&#125;<br><br><span class="hljs-comment">// 具体实现类：真实数据访问</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RealDataAccessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DataAccessor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getData</span><span class="hljs-params">(String key)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Fetching data from database for key: &quot;</span> + key);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Data for &quot;</span> + key;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 代理类：缓存代理</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CachingProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DataAccessor</span> &#123;<br>    <span class="hljs-keyword">private</span> DataAccessor realDataAccessor;<br>    <span class="hljs-keyword">private</span> Map&lt;String, String&gt; cache;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CachingProxy</span><span class="hljs-params">()</span> &#123;<br>        realDataAccessor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RealDataAccessor</span>();<br>        cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getData</span><span class="hljs-params">(String key)</span> &#123;<br>        <span class="hljs-keyword">if</span> (cache.containsKey(key)) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Retrieving data from cache for key: &quot;</span> + key);<br>            <span class="hljs-keyword">return</span> cache.get(key);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> realDataAccessor.getData(key);<br>            cache.put(key, data);<br>            <span class="hljs-keyword">return</span> data;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 客户端代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建缓存代理</span><br>        <span class="hljs-type">DataAccessor</span> <span class="hljs-variable">dataAccessor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CachingProxy</span>();<br><br>        <span class="hljs-comment">// 第一次访问时从数据库获取数据，并缓存起来</span><br>        System.out.println(dataAccessor.getData(<span class="hljs-string">&quot;key1&quot;</span>));<br><br>        <span class="hljs-comment">// 第二次访问时直接从缓存获取数据</span><br>        System.out.println(dataAccessor.getData(<span class="hljs-string">&quot;key1&quot;</span>));<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在这个示例中，<code>CachingProxy</code> 是缓存代理类，它在访问真实对象之前先检查缓存是否存在数据。</p><p>通过代理模式，我们可以很容易地实现延迟加载、权限控制、缓存等功能，并且不需要修改原始对象的代码，从而增强了代码的可维护性和灵活性。</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>结构性模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重拾设计模式（一）</title>
    <link href="/posts/b138f59e/"/>
    <url>/posts/b138f59e/</url>
    
    <content type="html"><![CDATA[<h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><blockquote><p>请用C++、Java、C#或VB.NET任意一种面向对象语言实现一个计算器控制台程序，要求输入两个数和运算符号，得到结果。</p></blockquote><p>可以直接写，如下所示：<br><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041828241.png"></p><p>“且先不说出题人的意思，单就你现在的代码，就有很多不足的地方需要改进。”</p><ul><li>A、B、C、D命名不规范；</li><li>判断分支全用if，意味着每个条件都要判断；</li><li>除数为0会产生错误；</li><li>等等；</li></ul><p>最重要一点是，<strong>没有体现出面向对象</strong>的意思。</p><p><strong>考虑通过封装、继承、多态把程序的耦合度降低；<br>考虑用设计模式使得程序更加的灵活，容易修改，并且易于复用；</strong></p><p>试着以面向对象的形式改写例子：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402042113078.png"><br><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402042113911.png"></p><p>首先是一个运算类，它有两个Number属性，主要用于计算器的前后数，然后有一个虚方法GetResult()，用于得到结果，然后我把加减乘除都写成了运算类的子类，继承它后，重写了GetResult()方法，这样如果要修改任何一个算法，就不需要提供其他算法的代码了。但问题来了，<strong>我如何让计算器知道我是希望用哪一个算法呢</strong>？</p><p>现在的问题其实就是如何去实例化对象的问题，教你一招‘简单工厂模式’，也就是说，到底要实例化谁，将来会不会增加实例化的对象，比如增加开根运算，这是很容易变化的地方，应该考虑用一个单独的类来做这个创造实例的过程，这就是工厂，来，我们看看这个类如何写。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402042117297.png"></p><p>只需要输入特定的符号，工厂就实例化出合适的对象，通过多态，返回父类的方式实现计算器的结果：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402042118942.png"></p><p>Q：如果有一天我们需要更改加法运算，我们只需要改哪里；</p><p>A：改OperationAdd就可以了。</p><p>Q：那么我们需要增加各种复杂运算，比如平方根，立方根，自然对数，正弦余弦等，如何做？</p><p>A：只要增加相应的运算子类，并且还需要去修改运算类工厂，在switch中增加分支。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402042121776.png"></p><hr><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>再来看看工厂方法模式，与简单工厂模式还是有些差异。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402042125151.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402042126986.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402042126723.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402042126384.png"></p><p><strong>简单工厂VS工厂方法</strong></p><blockquote><p>如果我现在需要增加其他运算，比如求M数的N次方，或者求M数的N次方根，这些功能的增加，在简单工厂里，我是先去加‘求M数的N次方’功能类，然后去更改工厂方法，当中加‘Case’语句来做判断，现在用了工厂方法，加功能类没问题，再加相关的工厂类，这也没问题，但要我再去更改客户端，这不等于不但没有减化难度，反而增加了很多类和方法，把复杂性增加了吗？为什么要这样？</p></blockquote><p>这其实就是工厂方法模式和简单工厂的区别所在。<strong>简单工厂模式的最大优点在于工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，对于客户端来说，去除了与具体产品的依赖。</strong></p><p>但问题也就在这里，如你所说，如果要加一个‘求M数的N次方’的功能，我们是一定需要给运算工厂类的方法里加‘Case’的分支条件的，修改原有的类？这可不是好办法，这就等于说，我们不但对扩展开放了，对修改也开放了，<strong>违背了开闭原则</strong>。</p><p>而<strong>工厂方法模式实现时，客户端需要决定实例化哪一个工厂来实现运算类，选择判断的问题还是存在的，也就是说，工厂方法把简单工厂的内部逻辑判断移到了客户端代码来进行。你想要加功<br>能，本来是改工厂类的，而现在是修改客户端</strong>！</p><p><strong>工厂方法克服了简单工厂违背开放-封闭原则的缺点，又保持了封装对象创建过程的优点。</strong></p><hr><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><blockquote><p>通常我们可以让一个全局变量使得一个对象被访问，但它不能防止你实例化多个对象。一个最好的办法就是，让类自身负责保存它的唯一实例。这个类可以保证没有其他实例可以被创建，并且它可以提供一个访问该实例的方法。</p></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201501805.png"></p><blockquote><p>Singleton类，定义一个GetInstance操作，允许客户访问它的唯一实例。GetInstance是一个静态方法，主要负责创建自己的唯一实例。</p></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201502791.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201502277.png"></p><h4 id="多线程时的单例"><a href="#多线程时的单例" class="headerlink" title="多线程时的单例"></a>多线程时的单例</h4><p class="note note-warning">多线程的程序中，多个线程同时，注意是同时访问Singleton类，调用GetInstance()方法，会有可能造成创建多个实例的。</p><blockquote><p>可以给进程一把锁来处理。这里需要解释一下lock语句的涵义，lock是确保当一个线程位于代码的临界区时，另一个线程不进入临界区。如果其他线程试图进入锁定的代码，则它将一直等待（即被阻止），直到该对象被释放。</p></blockquote><blockquote><p>线程安全的单例实现方式有很多，这里记录四种常见的。</p></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201511950.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201511780.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201515253.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201512884.png"></p><h4 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h4><blockquote><p>虽然静态内部类方式实现单例模式通常被认为是线程安全的，但是有一种情况可能会导致它不安全，即在反序列化时。</p><p>在 Java 中，如果一个类可序列化（即实现了 <code>Serializable</code> 接口），那么它的实例可以被序列化为字节流，并在需要时反序列化成对象。但是，在反序列化过程中，会通过调用类的无参构造函数来创建对象，而不会调用类的任何其他构造函数。这就意味着，如果我们不小心让一个静态内部类单例模式的外部类可序列化，然后尝试对其进行反序列化，就会产生一个新的实例。</p><p>以静态内部类方式举例，要解决这个问题，可以通过增加一个特殊的方法 <code>readResolve()</code> 来解决。<code>readResolve()</code> 方法会在反序列化后调用，它允许我们返回原始的单例实例，而不是新创建的实例。</p></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201518754.png"></p><hr><h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><blockquote><p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示的意图时，我们需要应用于一个设计模式，‘建造者（Builder）模式’，又叫生成器模式。主要解决在软件系统中，有时候面临着”一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。</p></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201520989.png"></p><blockquote><p>比如创建一个手机，需要cpu，主板、内存、屏幕等，通过一个代码示例可以很清晰的得知建造者模式的用途：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.pattern.builder3;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Phone</span> &#123;<br>    <span class="hljs-keyword">private</span> String cpu;<br>    <span class="hljs-keyword">private</span> String screen;<br>    <span class="hljs-keyword">private</span> String memory;<br>    <span class="hljs-keyword">private</span> String mainboard;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Phone&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;cpu=&#x27;&quot;</span> + cpu + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, screen=&#x27;&quot;</span> + screen + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, memory=&#x27;&quot;</span> + memory + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, mainboard=&#x27;&quot;</span> + mainboard + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//私有构造</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Phone</span><span class="hljs-params">(Builder builder)</span> &#123;<br>        <span class="hljs-built_in">this</span>.cpu = builder.cpu;<br>        <span class="hljs-built_in">this</span>.screen = builder.screen;<br>        <span class="hljs-built_in">this</span>.memory = builder.memory;<br>        <span class="hljs-built_in">this</span>.mainboard = builder.mainboard;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Builder</span> &#123;<br>        <span class="hljs-keyword">private</span> String cpu;<br>        <span class="hljs-keyword">private</span> String screen;<br>        <span class="hljs-keyword">private</span> String memory;<br>        <span class="hljs-keyword">private</span> String mainboard;<br><br>        <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">cpu</span><span class="hljs-params">(String cpu)</span> &#123;<br>            <span class="hljs-built_in">this</span>.cpu = cpu;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">screen</span><span class="hljs-params">(String screen)</span> &#123;<br>            <span class="hljs-built_in">this</span>.screen = screen;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">memory</span><span class="hljs-params">(String memory)</span> &#123;<br>            <span class="hljs-built_in">this</span>.memory = memory;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">mainboard</span><span class="hljs-params">(String mainboard)</span> &#123;<br>            <span class="hljs-built_in">this</span>.mainboard = mainboard;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> Phone <span class="hljs-title function_">build</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone</span>(<span class="hljs-built_in">this</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.pattern.builder3;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Phone</span> <span class="hljs-variable">phone</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone</span>.Builder()<br>                .cpu(<span class="hljs-string">&quot;intel&quot;</span>)<br>                .mainboard(<span class="hljs-string">&quot;华硕&quot;</span>)<br>                .memory(<span class="hljs-string">&quot;金士顿&quot;</span>)<br>                .screen(<span class="hljs-string">&quot;三星&quot;</span>).build();<br>        System.out.println(phone);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><blockquote><p>用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型对象相同的新对象<br>1.如果你需要复制一些对象， 同时又希望代码独立于这些对象所属的具体类， 可以使用原型模式。<br>2.如果子类的区别仅在于其对象的初始化方式， 那么你可以使用该模式来减少子类的数量。 别人创建这些子类的目的可能是为了创建特定类型的对象。<br>3.Spring中原型bean的创建，就是原型模式的应用</p></blockquote><blockquote><p>原型模式的克隆分为浅克隆和深克隆。<br>浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原  有属性所指向的对象的内存地址。<br>深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。</p></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201536440.png"></p><h4 id="古老方法"><a href="#古老方法" class="headerlink" title="古老方法"></a>古老方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 羊 实体类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sheep</span> &#123;<br> <br>    <span class="hljs-comment">// 名称</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-comment">// 产地</span><br>    <span class="hljs-keyword">public</span> SheepAddress sheepAddress;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Sheep</span><span class="hljs-params">()</span>&#123;&#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Sheep</span><span class="hljs-params">(String name, SheepAddress sheepAddress)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.sheepAddress = sheepAddress;<br>    &#125;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Sheep&#123;name=&#x27;&quot;</span> + name + <span class="hljs-string">&quot;, sheepAddress=&quot;</span> + sheepAddress +<span class="hljs-string">&quot;&#125;&quot;</span>;<br>    &#125;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Objects.hash(name, sheepAddress);<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> SheepAddress <span class="hljs-title function_">getSheepAddress</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sheepAddress;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSheepAddress</span><span class="hljs-params">(SheepAddress sheepAddress)</span> &#123;<br>        <span class="hljs-built_in">this</span>.sheepAddress = sheepAddress;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 羊产地</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SheepAddress</span> &#123;<br> <br>    <span class="hljs-comment">//省</span><br>    <span class="hljs-keyword">private</span> String province;<br>    <span class="hljs-comment">//市</span><br>    <span class="hljs-keyword">private</span> String city;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SheepAddress</span><span class="hljs-params">()</span>&#123;&#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SheepAddress</span><span class="hljs-params">(String province, String city)</span> &#123;<br>        <span class="hljs-built_in">this</span>.province = province;<br>        <span class="hljs-built_in">this</span>.city = city;<br>    &#125;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;SheepAddress&#123;province=&quot;</span> + province + <span class="hljs-string">&quot;, city=&#x27;&quot;</span> + city + <span class="hljs-string">&quot;&#125;&quot;</span>;<br>    &#125;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Objects.hash(province, city);<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getProvince</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> province;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setProvince</span><span class="hljs-params">(String province)</span> &#123;<br>        <span class="hljs-built_in">this</span>.province = province;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getCity</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> city;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCity</span><span class="hljs-params">(String city)</span> &#123;<br>        <span class="hljs-built_in">this</span>.city = city;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProtTest</span> &#123;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Sheep</span> <span class="hljs-variable">sheep</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sheep</span>(<span class="hljs-string">&quot;多莉&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">SheepAddress</span>(<span class="hljs-string">&quot;内蒙古&quot;</span>, <span class="hljs-string">&quot;呼和浩特市&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;sheep对象的hashcode:&quot;</span> + sheep.hashCode() + <span class="hljs-string">&quot; sheepAddress对象的hashcode:&quot;</span> + sheep.sheepAddress.hashCode() + <span class="hljs-string">&quot; 属性值：&quot;</span> + sheep);<br> <br>        <span class="hljs-type">Sheep</span> <span class="hljs-variable">sheep1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sheep</span>(<span class="hljs-string">&quot;多莉1&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">SheepAddress</span>(<span class="hljs-string">&quot;内蒙古1&quot;</span>, <span class="hljs-string">&quot;呼和浩特市1&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;sheep对象的hashcode:&quot;</span> + sheep1.hashCode() + <span class="hljs-string">&quot; sheepAddress对象的hashcode:&quot;</span> + sheep1.sheepAddress.hashCode() + <span class="hljs-string">&quot; 属性值：&quot;</span> + sheep1);<br> <br>        <span class="hljs-type">Sheep</span> <span class="hljs-variable">sheep2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sheep</span>(<span class="hljs-string">&quot;多莉2&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">SheepAddress</span>(<span class="hljs-string">&quot;内蒙古2&quot;</span>, <span class="hljs-string">&quot;呼和浩特市2&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;sheep对象的hashcode:&quot;</span> + sheep2.hashCode() + <span class="hljs-string">&quot; sheepAddress对象的hashcode:&quot;</span> + sheep2.sheepAddress.hashCode() + <span class="hljs-string">&quot; 属性值：&quot;</span> + sheep2);<br> <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs log">sheep对象的hashcode:-150317243 sheepAddress对象的hashcode:-173282477 属性值：Sheep&#123;name=&#x27;多莉, sheepAddress=SheepAddress&#123;province=内蒙古, city=&#x27;呼和浩特市&#125;&#125;<br>sheep对象的hashcode:-364921810 sheepAddress对象的hashcode:-1076816753 属性值：Sheep&#123;name=&#x27;多莉1, sheepAddress=SheepAddress&#123;province=内蒙古1, city=&#x27;呼和浩特市1&#125;&#125;<br>sheep对象的hashcode:-364921747 sheepAddress对象的hashcode:-1076816721 属性值：Sheep&#123;name=&#x27;多莉2, sheepAddress=SheepAddress&#123;province=内蒙古2, city=&#x27;呼和浩特市2&#125;&#125;<br></code></pre></td></tr></table></figure><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 原型设计模式：浅拷贝，创建一只多莉羊并实现其Cloneable接口</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SheepClone06</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span>&#123;<br> <br>    <span class="hljs-comment">// 名称</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-comment">// 产地</span><br>    <span class="hljs-keyword">public</span> SheepAddress06 sheepAddress;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SheepClone06</span><span class="hljs-params">()</span>&#123;&#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SheepClone06</span><span class="hljs-params">(String name, SheepAddress06 sheepAddress)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.sheepAddress = sheepAddress;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printSheep</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(name + <span class="hljs-string">&quot;:&quot;</span> + <span class="hljs-string">&quot;是一只克隆羊！&quot;</span>);<br>    &#125;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Objects.hash(name, sheepAddress);<br>    &#125;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;SheepClone06&#123;name=&#x27;&quot;</span> + name + <span class="hljs-string">&quot;, sheepAddress=&quot;</span> + sheepAddress + <span class="hljs-string">&quot;&#125;&quot;</span>;<br>    &#125;<br> <br>    <span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.clone();<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> SheepAddress06 <span class="hljs-title function_">getSheepAddress</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sheepAddress;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSheepAddress</span><span class="hljs-params">(SheepAddress06 sheepAddress)</span> &#123;<br>        <span class="hljs-built_in">this</span>.sheepAddress = sheepAddress;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 羊的产区</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SheepAddress06</span> &#123;<br> <br>    <span class="hljs-comment">//省</span><br>    <span class="hljs-keyword">private</span> String province;<br>    <span class="hljs-comment">//市</span><br>    <span class="hljs-keyword">private</span> String city;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SheepAddress06</span><span class="hljs-params">()</span>&#123;&#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SheepAddress06</span><span class="hljs-params">(String province, String city)</span> &#123;<br>        <span class="hljs-built_in">this</span>.province = province;<br>        <span class="hljs-built_in">this</span>.city = city;<br>    &#125;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;SheepAddress06&#123;province=&#x27;&quot;</span> + province + <span class="hljs-string">&quot;&#x27;, city=&#x27;&quot;</span> + city + <span class="hljs-string">&quot;&#125;&quot;</span>;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getProvince</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> province;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setProvince</span><span class="hljs-params">(String province)</span> &#123;<br>        <span class="hljs-built_in">this</span>.province = province;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getCity</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> city;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCity</span><span class="hljs-params">(String city)</span> &#123;<br>        <span class="hljs-built_in">this</span>.city = city;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 原型设计模式是一种创建型设计模式，允许一个对象再创建另一个可定制的对象，无需知道如何创建对象的细节，</span><br><span class="hljs-comment"> * springmvc框架中的单例（singleton）与多例（prototype）正是基于该设计模式而设计的。</span><br><span class="hljs-comment"> * 原型设计模式分为俩种，一种是浅拷贝，另一种是深拷贝。浅拷贝指的是对于基本数据类型和引用类型的变量通过值传递和引用传递，</span><br><span class="hljs-comment"> * 通俗易懂的说法就是，原对象的任何更改都会影响到克隆对象。而深拷贝是通过完整的克隆，重新创建一个新的对象，</span><br><span class="hljs-comment"> * 原对象的更改不会影响到克隆对象。浅拷贝通过实现Cloneable接口，重写clone方法实现。</span><br><span class="hljs-comment"> * 深拷贝可以通过重写clone方法或者实现Serializable序列化接口，通过序列化实现对象深拷贝。</span><br><span class="hljs-comment"> * 多用于复杂对象的创建，简化对象创建过程。本节我们以克隆多莉羊为例，实现原型模式的一个案例。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 原型设计模式：浅拷贝，创建一只多莉羊并实现其Cloneable接口</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProtTest06</span> &#123;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>        <span class="hljs-type">SheepClone06</span> <span class="hljs-variable">sheep</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SheepClone06</span>(<span class="hljs-string">&quot;多莉&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">SheepAddress06</span>(<span class="hljs-string">&quot;内蒙古&quot;</span>, <span class="hljs-string">&quot;呼和浩特市&quot;</span>));<br>        sheep.printSheep();<br>        System.out.println(<span class="hljs-string">&quot;sheep对象--&gt;hashcode值:&quot;</span> + sheep.hashCode() + <span class="hljs-string">&quot; sheepAddress对象的hashcode值:&quot;</span> + sheep.sheepAddress.hashCode() + <span class="hljs-string">&quot; 属性值：&quot;</span> + sheep);<br>        <span class="hljs-comment">//调用克隆方法克隆一只多莉羊</span><br>        System.out.println();<br>        System.out.println(<span class="hljs-string">&quot;开始浅拷贝SheepClone对象...&quot;</span>);<br>        <span class="hljs-type">SheepClone06</span> <span class="hljs-variable">cloneSheep</span> <span class="hljs-operator">=</span> (SheepClone06) sheep.clone();<br>        cloneSheep.printSheep();<br>        <span class="hljs-comment">//更改多莉羊的产地</span><br>        sheep.getSheepAddress().setProvince(<span class="hljs-string">&quot;新疆&quot;</span>);<br>        sheep.getSheepAddress().setCity(<span class="hljs-string">&quot;乌鲁木齐&quot;</span>);<br>        <span class="hljs-comment">//克隆的多莉羊属性</span><br>        System.out.println(<span class="hljs-string">&quot;克隆sheep对象--&gt;hashcode值:&quot;</span> + cloneSheep.hashCode() + <span class="hljs-string">&quot; sheepAddress对象的hashcode值:&quot;</span> + cloneSheep.sheepAddress.hashCode() + <span class="hljs-string">&quot; 属性值: &quot;</span> + cloneSheep);<br> <br>        System.out.println();<br>        System.out.println(<span class="hljs-string">&quot;两个对象值分别为 sheep=&quot;</span> + sheep +<span class="hljs-string">&quot; cloneSheep=&quot;</span>+cloneSheep);<br>    &#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：<br><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201540459.png"></p><blockquote><p> 从上面的案例可以看出，修改复制的新对象属性内容，会影响之前的对象属性值。<br> 1) 对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将 该属性值复制一份给新的对象。<br> 2) 对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数组、某个类 的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用值（内存地址）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成 员变量值<br> 3) 前面我们克隆羊就是浅拷贝<br> 4) 浅拷贝是使用默认的 clone()方法来实现 sheep &#x3D; (Sheep) super.clone(); </p></blockquote><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs java"> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SheepClone07</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span>, Serializable &#123;<br> <br>    <span class="hljs-comment">// 名称</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-comment">// 产地</span><br>    <span class="hljs-keyword">public</span> SheepAddress07 sheepAddress;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SheepClone07</span><span class="hljs-params">()</span>&#123;&#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SheepClone07</span><span class="hljs-params">(String name, SheepAddress07 sheepAddress)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.sheepAddress = sheepAddress;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printSheep</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(name + <span class="hljs-string">&quot;:&quot;</span> + <span class="hljs-string">&quot;是一只克隆羊！&quot;</span>);<br>    &#125;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Objects.hash(name, sheepAddress);<br>    &#125;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;SheepClone07&#123;name=&#x27;&quot;</span> + name + <span class="hljs-string">&quot;, sheepAddress=&quot;</span> + sheepAddress + <span class="hljs-string">&quot;&#125;&quot;</span>;<br>    &#125;<br> <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 方式一： 通过重写clone方法实现深拷贝</span><br><span class="hljs-comment">     **/</span><br>    <span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>        <span class="hljs-comment">//完成对属性为基本数据类型和String的克隆</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">deep</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">super</span>.clone();<br>        <span class="hljs-type">SheepClone07</span> <span class="hljs-variable">sheepClone</span> <span class="hljs-operator">=</span> (SheepClone07) deep;<br>        sheepClone.sheepAddress = (SheepAddress07) sheepAddress.clone();<br>        <span class="hljs-keyword">return</span> sheepClone;<br>    &#125;<br> <br> <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 方式二： 通过序列化反序列化实现深拷贝(推荐使用)</span><br><span class="hljs-comment">     **/</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">deepClone</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//创建流对象</span><br>        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ByteArrayInputStream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//序列化</span><br>            bos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>            oos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(bos);<br>            oos.writeObject(<span class="hljs-built_in">this</span>);<br>            <span class="hljs-comment">//反序列化</span><br>            bis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(bos.toByteArray());<br>            ois = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(bis);<br>            <span class="hljs-type">SheepClone07</span> <span class="hljs-variable">sheepClone</span> <span class="hljs-operator">=</span> (SheepClone07) ois.readObject();<br>            <span class="hljs-keyword">return</span> sheepClone;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">//关闭流</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                bos.close();<br>                oos.close();<br>                bis.close();<br>                ois.close();<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>                System.out.println(e2.getMessage());<br>            &#125;<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> SheepAddress07 <span class="hljs-title function_">getSheepAddress</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sheepAddress;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSheepAddress</span><span class="hljs-params">(SheepAddress07 sheepAddress)</span> &#123;<br>        <span class="hljs-built_in">this</span>.sheepAddress = sheepAddress;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SheepAddress07</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span>, Serializable &#123;<br> <br>    <span class="hljs-comment">//省</span><br>    <span class="hljs-keyword">private</span> String province;<br>    <span class="hljs-comment">//市</span><br>    <span class="hljs-keyword">private</span> String city;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SheepAddress07</span><span class="hljs-params">()</span>&#123;&#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SheepAddress07</span><span class="hljs-params">(String province, String city)</span> &#123;<br>        <span class="hljs-built_in">this</span>.province = province;<br>        <span class="hljs-built_in">this</span>.city = city;<br>    &#125;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.clone();<br>    &#125;<br> <br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;SheepAddress07&#123;province=&#x27;&quot;</span> + province + <span class="hljs-string">&quot;&#x27;, city=&#x27;&quot;</span> + city + <span class="hljs-string">&quot;&#125;&quot;</span>;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getProvince</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> province;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setProvince</span><span class="hljs-params">(String province)</span> &#123;<br>        <span class="hljs-built_in">this</span>.province = province;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getCity</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> city;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCity</span><span class="hljs-params">(String city)</span> &#123;<br>        <span class="hljs-built_in">this</span>.city = city;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProtTest07</span> &#123;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>        <span class="hljs-type">SheepClone07</span> <span class="hljs-variable">sheep</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SheepClone07</span>(<span class="hljs-string">&quot;多莉&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">SheepAddress07</span>(<span class="hljs-string">&quot;内蒙古&quot;</span>, <span class="hljs-string">&quot;呼和浩特市&quot;</span>));<br>        sheep.printSheep();<br>        System.out.println(<span class="hljs-string">&quot;sheep对象--&gt;hashcode值:&quot;</span> + sheep.hashCode() + <span class="hljs-string">&quot; sheepAddress对象的hashcode值:&quot;</span> + sheep.sheepAddress.hashCode() + <span class="hljs-string">&quot; 属性值：&quot;</span> + sheep);<br> <br>        System.out.println();<br>        System.out.println(<span class="hljs-string">&quot;开始深拷贝方式一SheepClone对象(通过重写clone方法实现深拷贝)...&quot;</span>);<br>        <span class="hljs-type">SheepClone07</span> <span class="hljs-variable">cloneSheepOne</span> <span class="hljs-operator">=</span> (SheepClone07) sheep.clone();<br>        cloneSheepOne.setName(<span class="hljs-string">&quot;绵羊&quot;</span>);<br>        cloneSheepOne.printSheep();<br>        System.out.println(<span class="hljs-string">&quot;克隆sheep对象--&gt;hashcode值:&quot;</span> + cloneSheepOne.hashCode() + <span class="hljs-string">&quot; sheepAddress对象的hashcode值:&quot;</span> + cloneSheepOne.sheepAddress.hashCode() + <span class="hljs-string">&quot; 属性值: &quot;</span> + cloneSheepOne);<br> <br>        System.out.println();<br>        System.out.println(<span class="hljs-string">&quot;开始深拷贝方式二序列化SheepClone对象(通过序列化反序列化实现深拷贝)...&quot;</span>);<br>        <span class="hljs-type">SheepClone07</span> <span class="hljs-variable">cloneSheepTwo</span> <span class="hljs-operator">=</span> (SheepClone07) sheep.deepClone();<br>        cloneSheepTwo.printSheep();<br>        System.out.println(<span class="hljs-string">&quot;克隆sheep对象--&gt;hashcode值:&quot;</span> + cloneSheepTwo.hashCode() + <span class="hljs-string">&quot; sheepAddress对象的hashcode值:&quot;</span> + cloneSheepTwo.sheepAddress.hashCode() + <span class="hljs-string">&quot; 属性值: &quot;</span> + cloneSheepTwo);<br> <br>        System.out.println();<br>        System.out.println(<span class="hljs-string">&quot;两个对象值分别为 sheep=&quot;</span> + sheep +<span class="hljs-string">&quot; cloneSheepOne=&quot;</span>+cloneSheepOne+<span class="hljs-string">&quot; cloneSheepTwo=&quot;</span>+cloneSheepTwo);<br> <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：<br><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201543458.png"></p><blockquote><p>深拷贝基本介绍</p><ol><li>复制对象的所有基本数据类型的成员变量值</li><li>为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变 量所引用的对象，直到该对象可达的所有对象。也就是说，对象进行深拷贝要对 整个对象进行拷贝</li><li>深拷贝实现方式</li></ol><ul><li>重写clone方法来实现深拷贝</li><li>通过对象序列化实现深拷贝(推荐)</li></ul><p>原型模式的注意事项和细节</p><ol><li>创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提高效率。</li><li>不用重新初始化对象，而是动态地获得对象运行时的状态。</li><li>如果原始对象发生变化(增加或者减少属性)，其它克隆对象的也会发生相应的变化，无需修改代码。</li><li>在实现深克隆的时候可能需要比较复杂的代码。</li><li>缺点：需要为每一个类配备一个克隆方法，这对全新的类来说不是很难，但对已有 的类进行改造时，需要修改其源代码，违背了ocp原则。</li></ol></blockquote><hr><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>抽象工厂模式为一个产品家族提供了统一的创建接口。当需要这个产品家族的某一系列的时候，可以从抽象工厂中选出相对应的系列来创建一个具体的工厂类别。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。</p><p><strong>相关术语：</strong></p><ul><li><p><strong>产品等级结构：</strong>产品的继承结构，与类的继承相似。例如笔记本是一个抽象的类，那么华为笔记本、苹果和联想笔记本就是其子类。</p></li><li><p><strong>产品族：</strong>指同一个工厂生产的，位于不同的产品等级结构的一组产品。例如华为笔记本、手机、路由器等都产自华为，笔记本的等级结构不同，构成一个产品族。</p></li><li><p><strong>抽象工厂：</strong>是一个接口，抽象工厂模式的核心，包含对多个产品等级结构的声明，任何工厂类都必须实现这个接口。</p></li><li><p><strong>具体工厂：</strong>是抽象工厂的实现，负责实例化某个产品族中的产品对象。例如华为工厂生产华为笔记本、手机、路由器等。</p></li></ul><h3 id="产品族和产品等级结构图"><a href="#产品族和产品等级结构图" class="headerlink" title="产品族和产品等级结构图"></a>产品族和产品等级结构图</h3><p>我们以一个品牌为一个产品族，电脑、手机、路由器为产品等级，每一个品牌都有自己的产品族，这就构成一个完整产品群；</p><p>横向代表一族，纵向代表一个等级，横纵交集代表某一个品牌的某一个产品（比如下图中交集的点为电脑），请看下图；</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201602502.png"></p><h3 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h3><p>这个类图其实比较简单，简单说明下：</p><p><strong>产品顶级接口</strong>：主要被产品抽象类实现；</p><p><strong>产品抽象类</strong>：某个具体产品要实现的类；</p><p><strong>具体实现类</strong>：具体产品实现，比如华为路由器实现自抽象类AbstractRouter；</p><p><strong>工厂接口</strong>：工厂接口中定义创建每个产品方法；</p><p><strong>具体华为工厂</strong>：实现工厂接口，创建华为一族产品（路由器、手机、电脑）；</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201604768.png"></p><h3 id="具体代码实现"><a href="#具体代码实现" class="headerlink" title="具体代码实现"></a>具体代码实现</h3><blockquote><p>代码中我们以华为产品为例，分别定义华为电脑、手机、路由器产品，从UML类图中可以看出我们的产品结构层级比较清晰，现在我们先设计我们产品。</p></blockquote><p><strong>产品顶级接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> pattern.abstractfactory.product;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 定义产品接口</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">InterfaceProduct</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>定义计算机抽象类并实现产品InterfaceProduct 接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> pattern.abstractfactory.product;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 定义计算机产品抽象类，并实现产品接口InterfaceProduct</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractComputers</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InterfaceProduct</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>定义手机抽象类并实现产品InterfaceProduct 接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> pattern.abstractfactory.product;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 定义手机抽象类，并实现产品接口InterfaceProduct</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractPhone</span>  <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InterfaceProduct</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>定义路由器抽象类并实现产品InterfaceProduct 接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> pattern.abstractfactory.product;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 定义路由器产品抽象类，并实现InterfaceProduct接口</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractRouter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InterfaceProduct</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>定义华为电脑具体实现类，继承AbstractComputers抽象类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> pattern.abstractfactory.product;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 华为电脑实现类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HuaWeiComputer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractComputers</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;华为笔记本&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>定义华为手机具体实现类，继承AbstractPhone抽象类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> pattern.abstractfactory.product;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  *  华为手机实现类，</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HuaWeiPhone</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractPhone</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;华为手机&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>定义华为路由器具体实现类，继承AbstractRouter抽象类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> pattern.abstractfactory.product;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 华为路由器</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HuaWeiRouter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractRouter</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;华为品牌路由器&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-primary">下面开始定义工厂</p><p><strong>定义工厂接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> pattern.abstractfactory.factory;<br><span class="hljs-keyword">import</span> pattern.abstractfactory.product.InterfaceProduct;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 定义产品工厂接口,</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">InterfactFactory</span> &#123;<br>    <span class="hljs-comment">//手机产品</span><br>    InterfaceProduct <span class="hljs-title function_">createPhone</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">//电脑产品</span><br>    InterfaceProduct <span class="hljs-title function_">createComputer</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">//路由器产品</span><br>    InterfaceProduct <span class="hljs-title function_">createRouter</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>具体工厂实现类，实现 InterfactFactory  接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> pattern.abstractfactory.factory;<br><span class="hljs-keyword">import</span> pattern.abstractfactory.product.HuaWeiComputer;<br><span class="hljs-keyword">import</span> pattern.abstractfactory.product.HuaWeiPhone;<br><span class="hljs-keyword">import</span> pattern.abstractfactory.product.HuaWeiRouter;<br><span class="hljs-keyword">import</span> pattern.abstractfactory.product.InterfaceProduct;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * **华为工厂**</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HuaWeiFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InterfactFactory</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建电脑对象并返回</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> InterfaceProduct <span class="hljs-title function_">createComputer</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HuaWeiComputer</span>();<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建手机对象并返回</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> InterfaceProduct <span class="hljs-title function_">createPhone</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HuaWeiPhone</span>();<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建路由器对象并返回</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> InterfaceProduct <span class="hljs-title function_">createRouter</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HuaWeiRouter</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>客户端类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> pattern.abstractfactory;<br><span class="hljs-keyword">import</span> pattern.abstractfactory.factory.HuaWeiFactory;<br><span class="hljs-keyword">import</span> pattern.abstractfactory.factory.InterfactFactory;<br><span class="hljs-keyword">import</span> pattern.abstractfactory.product.InterfaceProduct;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 抽象工厂模式测试类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建华为品牌工厂</span><br>        <span class="hljs-type">InterfactFactory</span> <span class="hljs-variable">huawei</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HuaWeiFactory</span>();<br>        <span class="hljs-comment">//通过华为工厂获取华为电脑对象</span><br>        <span class="hljs-type">InterfaceProduct</span> <span class="hljs-variable">computer</span> <span class="hljs-operator">=</span> huawei.createComputer();<br>        computer.get();<br>        <span class="hljs-comment">//通过华为工厂获取华为手机对象</span><br>        <span class="hljs-type">InterfaceProduct</span> <span class="hljs-variable">phone</span> <span class="hljs-operator">=</span> huawei.createPhone();<br>        phone.get();<br>        <span class="hljs-comment">//通过华为工厂获取华为路由器对象</span><br>        <span class="hljs-type">InterfaceProduct</span> <span class="hljs-variable">router</span> <span class="hljs-operator">=</span> huawei.createRouter();<br>        router.get();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201611533.png"></p><h3 id="扩展展品族"><a href="#扩展展品族" class="headerlink" title="扩展展品族"></a>扩展展品族</h3><blockquote><p>抽象工厂模式<strong>对于横向扩展方便，对于纵向扩展非常困难</strong>，也就是说：假如我们要扩展一个新的品牌，比如扩展一个小米品牌，小米产品有电脑、手机、路由器，扩展新品牌就是横向扩展，非常方便，但是我们要给小米添加一个电饭煲产品却非常困难，这就是纵向扩展，所以在使用抽象工厂模式时一定要选择合适的场景，也就是在不同场景中使用最适合的模式才是设计模式的精髓。</p></blockquote><p><strong>小米电脑</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> pattern.abstractfactory.product;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 小米电脑，继承自 AbstractComputers 抽象类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MiComputer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractComputers</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;小米电脑&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>小米手机</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> pattern.abstractfactory.product;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 小米手机，继承自 AbstractPhone 抽象类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MiPhone</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractPhone</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;小米手机&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>小米路由器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> pattern.abstractfactory.product;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 小米路由器，继承自 AbstractRouter 抽象类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MiRouter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractRouter</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;小米路由器&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>添加小米具体工厂类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> pattern.abstractfactory.factory;<br><span class="hljs-keyword">import</span> pattern.abstractfactory.product.InterfaceProduct;<br><span class="hljs-keyword">import</span> pattern.abstractfactory.product.MiComputer;<br><span class="hljs-keyword">import</span> pattern.abstractfactory.product.MiPhone;<br><span class="hljs-keyword">import</span> pattern.abstractfactory.product.MiRouter;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 小米工厂，实现 InterfactFactory 接口</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MiFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InterfactFactory</span>&#123;<br>    <span class="hljs-comment">//小米手机</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> InterfaceProduct <span class="hljs-title function_">createPhone</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MiPhone</span>();<br>    &#125;<br>    <span class="hljs-comment">//小米电脑</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> InterfaceProduct <span class="hljs-title function_">createComputer</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MiComputer</span>();<br>    &#125;<br>    <span class="hljs-comment">//小米路由器</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> InterfaceProduct <span class="hljs-title function_">createRouter</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MiRouter</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后编写测试类，<strong>代码中红色字体为新扩展的品牌产品</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> pattern.abstractfactory;<br><span class="hljs-keyword">import</span> pattern.abstractfactory.factory.HuaWeiFactory;<br><span class="hljs-keyword">import</span> pattern.abstractfactory.factory.InterfactFactory;<br><span class="hljs-keyword">import</span> pattern.abstractfactory.factory.MiFactory;<br><span class="hljs-keyword">import</span> pattern.abstractfactory.product.InterfaceProduct;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 抽象工厂模式测试类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建华为品牌工厂</span><br>        <span class="hljs-type">InterfactFactory</span> <span class="hljs-variable">huawei</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HuaWeiFactory</span>();<br>        <span class="hljs-comment">// 通过华为工厂获取华为电脑对象</span><br>        <span class="hljs-type">InterfaceProduct</span> <span class="hljs-variable">computer</span> <span class="hljs-operator">=</span> huawei.createComputer();<br>        computer.get();<br>        <span class="hljs-comment">// 通过华为工厂获取华为手机对象</span><br>        <span class="hljs-type">InterfaceProduct</span> <span class="hljs-variable">phone</span> <span class="hljs-operator">=</span> huawei.createPhone();<br>        phone.get();<br>        <span class="hljs-comment">// 通过华为工厂获取华为路由器对象</span><br>        <span class="hljs-type">InterfaceProduct</span> <span class="hljs-variable">router</span> <span class="hljs-operator">=</span> huawei.createRouter();<br>        router.get();<br><br>        <span class="hljs-comment">// 创建小米品牌工厂</span><br>        <span class="hljs-type">InterfactFactory</span> <span class="hljs-variable">Mifactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MiFactory</span>();<br>        <span class="hljs-comment">// 通过小米工厂获取小米电脑对象</span><br>        <span class="hljs-type">InterfaceProduct</span> <span class="hljs-variable">micomputer</span> <span class="hljs-operator">=</span> Mifactory.createComputer();<br>        micomputer.get();<br>        <span class="hljs-comment">// 通过小米工厂获取小米手机对象</span><br>        <span class="hljs-type">InterfaceProduct</span> <span class="hljs-variable">miphone</span> <span class="hljs-operator">=</span> Mifactory.createPhone();<br>        miphone.get();<br>        <span class="hljs-comment">// 通过小米工厂获取小米路由器对象</span><br>        <span class="hljs-type">InterfaceProduct</span> <span class="hljs-variable">mirouter</span> <span class="hljs-operator">=</span> Mifactory.createRouter();<br>        mirouter.get();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201615661.png"></p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>创建者模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重拾设计模式（零）- 朝花夕拾</title>
    <link href="/posts/77e3381c/"/>
    <url>/posts/77e3381c/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>设计模式是在软件设计中经常出现的问题的通用解决方案。这些解决方案是经过反复验证和证明的，并且被广泛接受和应用于软件开发中。设计模式提供了一种可重用的思想框架，可以帮助开发人员更有效地解决常见问题，并提高代码的可维护性、可读性和可扩展性。</p><p>编程是一门技术，更加是一门艺术，不能只满足于写完代码运行结果正确就完事，时常考虑如何让代码更加简练，更加容易维护，容易扩展和复用，只有这样才可以真正得到提高。</p><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><p>设计模式的使用应该遵循一些基本的设计原则，这些原则有助于编写更清晰、灵活、可维护和可扩展的代码。以下是一些常见的设计原则：</p><ol><li><p><strong>单一职责原则（Single Responsibility Principle - SRP）：</strong> 一个类应该只有一个修改的理由。每个类都应该专注于一项任务，避免一个类担负过多的职责。</p></li><li><p><strong>开闭原则（Open-Closed Principle - OCP）：</strong> 软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。可以通过接口和抽象类实现。</p></li><li><p><strong>里氏替换原则（Liskov Substitution Principle - LSP）：</strong> 派生类应该能够替换其基类而不影响程序的正确性。即，子类应该能够替代父类并保持程序的行为一致性。</p></li><li><p><strong>依赖倒置原则（Dependency Inversion Principle - DIP）：</strong> 高层模块不应该依赖于底层模块，二者都应该依赖于抽象。抽象不应该依赖于细节，而细节应该依赖于抽象。</p></li><li><p><strong>接口隔离原则（Interface Segregation Principle - ISP）：</strong> 客户端不应该强制依赖于它们不使用的接口。一个类不应该被强制实现它用不到的接口。</p></li><li><p><strong>迪米特法则（Law of Demeter，LoD，又称最少知识原则）：</strong> 一个对象应该对其他对象有最少的了解。避免在一个类中调用过多其他类的方法，减少耦合性。</p></li><li><p><strong>合成复用原则（Composition&#x2F;Aggregation Reuse Principle - CARP）：</strong> 首选使用组合&#x2F;聚合而不是继承来实现复用。通过组合可以更灵活地实现对象间的关系。</p></li><li><p><strong>优先使用对象组合，而不是类继承（Favor Composition Over Inheritance）：</strong> 对象组合通常比类继承更加灵活，能够减少耦合性并支持代码重用。</p></li></ol><p>这些原则通常被认为是良好面向对象设计的基石，它们相互交织，协同工作，帮助设计出符合软件工程最佳实践的系统结构。在实践中，根据具体情况灵活运用这些原则，有助于构建更健壮和可维护的软件系统。</p><h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041803749.png"></p><p>UML（Unified Modeling Language）类图是一种用于描述系统中的类、对象及它们之间关系的图形化建模工具。它是一种强大的面向对象的建模语言，被广泛用于软件开发和系统设计。以下是类图的主要元素和介绍：</p><ol><li><p><strong>类（Class）：</strong> 类是对现实世界中一组相似对象的抽象，它定义了对象的属性和行为。在类图中，类通常用一个矩形框表示，矩形框分为三个部分：类名、属性（字段）和方法。</p></li><li><p><strong>关联（Association）：</strong> 关联表示类之间的关系，描述一个类的实例和另一个类的实例之间的连接。关联可以是单向的或双向的，可以具有方向性，也可以是多重性的，表示一个类中的实例与另一个类中的实例之间的关系。</p></li><li><p><strong>聚合（Aggregation）：</strong> 表示一种弱的拥有关系，整体对象可以包含部分对象，但部分对象并不是整体对象的一部分。聚合用一条带有空心菱形的直线表示。</p></li><li><p><strong>组合（Composition）：</strong> 表示一种强的拥有关系，整体对象包含部分对象，部分对象是整体对象的一部分。组合用一条带有实心菱形的直线表示。</p></li><li><p><strong>泛化（Generalization）：</strong> 表示类之间的继承关系，其中一个类是另一个类的子类。泛化用一条带有空心三角箭头的直线表示。</p></li><li><p><strong>接口（Interface）：</strong> 表示一个类或一组类的契约，它规定了这些类应该实现的一组方法。接口用带有&lt;<interface>&gt;标记的小矩形表示。</p></li><li><p><strong>依赖（Dependency）：</strong> 表示一个类使用了另一个类的服务，但是并不拥有对方的对象。依赖关系用一条带有箭头的虚线表示。</p></li><li><p><strong>多重性（Multiplicity）：</strong> 表示关联、聚合或组合关系中每个端点的实例数目。例如，1..* 表示一个或多个实例。</p></li></ol><p>UML类图是软件开发中非常有用的工具，它能够清晰地展示系统中的类、对象和它们之间的关系，帮助开发人员理解系统结构、设计和实现。通过类图，开发团队能够更好地沟通和协作，确保系统的正确性和可维护性。</p><h2 id="先说结论"><a href="#先说结论" class="headerlink" title="先说结论"></a>先说结论</h2><p><strong>创建型模式</strong></p><ol><li><p><strong>工厂方法模式（Factory Method Pattern）</strong> ：定义一个创建对象的接口，但是让子类决定实例化哪个类。工厂方法使得一个类的实例化延迟到其子类。</p></li><li><p><strong>抽象工厂模式（Abstract Factory Pattern）</strong> ：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p></li><li><p><strong>单例模式（Singleton Pattern）</strong> ：确保一个类只有一个实例，并提供一个全局访问点。</p></li><li><p><strong>建造者模式（Builder Pattern）</strong> ：将一个复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示。</p></li><li><p><strong>原型模式（Prototype Pattern）</strong> ：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p></li></ol><p><strong>结构型模式</strong></p><ol><li><p><strong>适配器模式（Adapter Pattern）</strong> ：将一个类的接口转换成客户希望的另一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的类可以一起工作。</p></li><li><p><strong>桥接模式（Bridge Pattern）</strong> ：将抽象部分与它的实现部分分离，使它们可以独立变化。</p></li><li><p><strong>组合模式（Composite Pattern）</strong> ：将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p></li><li><p><strong>装饰器模式（Decorator Pattern）</strong> ：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。</p></li><li><p><strong>外观模式（Facade Pattern）</strong> ：为子系统中的一组接口提供一个统一的接口。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p></li><li><p><strong>享元模式（Flyweight Pattern）</strong> ：运用共享技术有效地支持大量细粒度的对象。</p></li><li><p><strong>代理模式（Proxy Pattern）</strong> ：为其他对象提供一种代理以控制对这个对象的访问。</p></li></ol><p><strong>行为型模式</strong></p><ol><li><p><strong>责任链模式（Chain of Responsibility Pattern）</strong> ：为请求创建一个接收者对象的链，使得多个对象都有机会处理该请求。在请求发送者和接收者之间解耦。</p></li><li><p><strong>命令模式（Command Pattern）</strong> ：将一个请求封装成一个对象，从而使用户可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。</p></li><li><p><strong>解释器模式（Interpreter Pattern）</strong> ：给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。</p></li><li><p><strong>迭代器模式（Iterator Pattern）</strong> ：提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。</p></li><li><p><strong>中介者模式（Mediator Pattern）</strong> ：用一个中介对象封装一系列对象的交互，中介者使各对象不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p></li><li><p><strong>备忘录模式（Memento Pattern）</strong> ：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。</p></li><li><p><strong>观察者模式（Observer Pattern）</strong> ：定义对象间的一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并自动更新。</p></li><li><p><strong>状态模式（State Pattern）</strong> ：允许对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。</p></li><li><p><strong>策略模式（Strategy Pattern）</strong> ：定义一系列的算法，把它们封装起来，并且使它们可以相互替换。策略模式使得算法可以独立于使用它的客户而变化。</p></li><li><p><strong>模板方法模式（Template Method Pattern）</strong> ：定义一个操作中的算法的框架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p></li><li><p><strong>访问者模式（Visitor Pattern）</strong> ：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式相关</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构和算法之旅（十二）- 其他</title>
    <link href="/posts/98b3bf1e/"/>
    <url>/posts/98b3bf1e/</url>
    
    <content type="html"><![CDATA[<blockquote><p>最近看到一本很有趣的书，《算法图解》。对一些算法描述的非常清晰、直观、有趣。这里简单记录一些读书笔记。</p></blockquote><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>假设你的计算机存储了很多乐曲。对于每个乐队，你都记录了其作品被播放的次数。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041629883.png"></p><p>你要将这个列表按播放次数从多到少的顺序排列，从而将你喜欢的乐队排序。该如何做呢？一种办法是遍历这个列表，找出作品播放次数最多的乐队，并将该乐队添加到一个新列表中。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041630942.png"><br>继续这样做，找出播放次数第二多的乐队。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041631736.png"></p><p>继续这样做，将得到一个有序的列表。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041631559.png"></p><p>接下来，分析一下它时间复杂度。要找出播放次数最多的乐队，必须检查列表中的每个元素。正如你刚才看到的，这需要的时间为O(n)。因此对于这种时间为O(n)的操作，你需要执行n次。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041634338.png"><br>需要的总时间为O(n×n)，即O(n²)。</p><p>排序算法很有用。你现在可以对如下内容进行排序：</p><ul><li>电话薄中的人名</li><li>旅行日期</li><li>电子邮件，从新到旧</li><li>等等</li></ul><p>示例代码</p><p>将数组元素按从小到大的顺序排列。先编写一个用于找出数组中最小元素的函数。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041639433.png"></p><p>现在可以使用这个函数来编写选择排序算法了。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041640898.png"></p><p>选择排序是一种灵巧的算法，但是速度不是很快。快速排序是一种更快的排序算法，其运行时间为O(n log n)。</p><h2 id="分而治之D-amp-C"><a href="#分而治之D-amp-C" class="headerlink" title="分而治之D&amp;C"></a>分而治之D&amp;C</h2><blockquote><p>一种著名的递归式问题解决方法。</p><p>分而治之的原理：<br>1.找出简单的基线条件；<br>2.确定如何缩小问题的规模，使其符合基线条件；<br>D&amp;C并非用于解决问题的算法，而是一种解决问题的思路。</p></blockquote><p>一个简单的例子，给定一个数组，</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041646083.png"><br>需要将这些数字相加，并返回结果。使用循环很容易完成这种任务。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">defsum(arr): <br>total=<span class="hljs-number">0</span> <br>forx <span class="hljs-keyword">in</span> arr: <br>total+= x <br><span class="hljs-keyword">return</span> total <br><span class="hljs-built_in">print</span> <span class="hljs-built_in">sum</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>])<br></code></pre></td></tr></table></figure><p>但如何使用递归函数来完成这种任务呢？</p><p><strong>第一步</strong>：找出基线条件。最简单的数组什么样呢？请想想这个问题，再接着往下读。如果数组不包含任何元素或只包含一个元素，计算总和将非常容易。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041649064.png"><br>因此，这就是基线条件。</p><p><strong>第二步</strong>：每次递归调用都必须离空数组更近一步。如何缩小问题的规模呢？下面是一种办法。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041650285.png"></p><p>这两个版本的结果都为12，但在第二个版本中，给函数sum传递的数组更短。换言之，这缩小了问题的规模！</p><p>函数sum的工作原理类似于下面这样。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041651529.png"></p><p>这个函数的运行过程如下。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041651359.png"></p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><blockquote><p>快速排序是一种常用的排序算法，比选择排序快得多。例如，C语言标准库中的函数qsort实现的就是快速排序。快速排序也使用了D&amp;C。</p></blockquote><p>下面来使用快速排序对数组进行排序。对排序算法来说，最简单的数组什么样呢？还记得前一节的“提示”吗？就是根本不需要排序的数组。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041657372.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">quicksort</span>(<span class="hljs-params">array</span>): <br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(array)&lt;<span class="hljs-number">2</span>: <br><span class="hljs-keyword">return</span> array<br></code></pre></td></tr></table></figure><p>因此，基线条件为数组为空或只包含<strong>一</strong>个元素。在这种情况下，只需原样返回数组——根本就不用排序。</p><p>我们来看看更长的数组。对包含<strong>两</strong>个元素的数组进行排序也很容易。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041659123.png"><br>包含三个元素的数组呢？</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041700889.png"></p><p>别忘了，你要使用D&amp;C，因此需要将数组分解，直到满足基线条件。下面介绍<strong>快速排序的工作原理</strong>。首先，从数组中<strong>选择一个元素</strong>，这个元素被称为<strong>基准值</strong>(pivot)。稍后再介绍如何选择合适的基准值。我们暂时将数组的第一个元素用作基准值。接下来，找出比基准值小的元素以及比基准值大的元素。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041701782.png"><br><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041701748.png"></p><p>这被称为分区(partitioning)。现在你有：</p><ul><li>一个由所有小于基准值的数字组成的子数组；</li><li>基准值；</li><li>一个由所有大于基准值的数组组成的子数组。</li></ul><p>这里只是进行了分区，得到的两个子数组是无序的。但如果这两个数组是有序的，对整个数组进行排序将非常容易。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041702668.png"></p><p>如果子数组是有序的，就可以像下面这样合并得到一个有序的数组：左边的数组+基准值+右边的数组。在这里，就是[10,15]+[33]+[]，结果为有序数组[10,15,33]。</p><p>如何对子数组进行排序呢？对于包含两个元素的数组（左边的子数组）以及空数组（右边的子数组），快速排序知道如何将它们排序，因此只要对这两个子数组进行快速排序，再合并结果，就能得到一个有序数组！</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041704511.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041705539.png"></p><p>快速排序的性能高度依赖于你选择的基准值。假设你总是将第一个元素用作基准值，且要处理的数组是有序的。由于快速排序算法不检查输入数组是否有序，因此它依然尝试对其进行排序。最糟糕的情况运行时间是O(n²)。</p>]]></content>
    
    
    <categories>
      
      <category>data&amp;algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构和算法之旅（十一）- 哈希表</title>
    <link href="/posts/3cbe22a9/"/>
    <url>/posts/3cbe22a9/</url>
    
    <content type="html"><![CDATA[<blockquote><p>哈希表是一种功能强大的数据结构，其操作速度快，还能以不同的方式建立数据模型。</p><p>结合散列函数和数组来创建散列表。<br>散列表的查找、插入和删除都非常快。<br>散列表适用于模拟映射关系。<br>负载因子一旦超过0.7，就该调整散列表的长度。<br>散列表可用于缓存数据，例如Web服务器的缓存。<br>散列表非常适合用于防止重复。</p></blockquote><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><blockquote><p>几乎根本不需要自己去实现散列表，因为各种编程语言基本都会提供。不过为了为了掌握，还是敲一边加深印象把。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.datastructure;  <br>  <br><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * 哈希表  </span><br><span class="hljs-comment"> * &lt;p&gt;  </span><br><span class="hljs-comment"> * 给每份数据分配一个编号，放入数组、  </span><br><span class="hljs-comment"> * 建立编号与数组索引的关系，将来可以通过编号快速查找到数据。  </span><br><span class="hljs-comment"> * 存在问题：  </span><br><span class="hljs-comment"> * 1.理想情况下，数组容纳所有数据，但是不现实，因为数组需要连续内存存储的；  </span><br><span class="hljs-comment"> * 2.现实是不能说为了容纳所有数据造一个超大数组，编号也有可能重复的；  </span><br><span class="hljs-comment"> * 解决：  </span><br><span class="hljs-comment"> * 1.有限长度的数组，以【拉链】方式存储数据；  </span><br><span class="hljs-comment"> * 2.允许编号适当重复，通过数据自身进行区分；  </span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashTable</span> &#123;  <br>  <br>    <span class="hljs-comment">//节点类  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> &#123;  <br>        <span class="hljs-type">int</span> hash;<span class="hljs-comment">//哈希码  </span><br>        Object key;<span class="hljs-comment">//键  </span><br>        <span class="hljs-keyword">public</span> Object value;<span class="hljs-comment">//值  </span><br>        <span class="hljs-keyword">public</span> Entry next;<span class="hljs-comment">//下一个节点  </span><br>  <br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Entry</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, Object key, Object value)</span> &#123;  <br>            <span class="hljs-built_in">this</span>.hash = hash;  <br>            <span class="hljs-built_in">this</span>.key = key;  <br>            <span class="hljs-built_in">this</span>.value = value;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> Entry[] table = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[<span class="hljs-number">16</span>];<span class="hljs-comment">//哈希表，数组，每个元素是一个链表的头节点  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//元素个数  </span><br>    <span class="hljs-type">float</span> <span class="hljs-variable">loadFactor</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.75f</span>;<span class="hljs-comment">//负载因子 16*0.75=12  也叫阈值  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">threshold</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (table.length * loadFactor);<span class="hljs-comment">//阈值 用变量记录，后面可以复用  </span><br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * ！！！  </span><br><span class="hljs-comment">     * 求模运算替换为位运算  </span><br><span class="hljs-comment">     *  -前提：数组长度必须是2的n次方  </span><br><span class="hljs-comment">     *  -hash % 数组长度 等价与 hash &amp; (数组长度-1)  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-comment">/**     * 查询  </span><br><span class="hljs-comment">     * 根据hash码获取Value  </span><br><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, Object key)</span> &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> hash &amp; (table.length - <span class="hljs-number">1</span>);  <br>        <span class="hljs-keyword">if</span> (table[idx] == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>        <span class="hljs-type">Entry</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> table[idx];<span class="hljs-comment">//头节点  </span><br>        <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-keyword">if</span> (p.key == key) <span class="hljs-keyword">return</span> p.value;  <br>            p = p.next;  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 向hash表存入新key value，  </span><br><span class="hljs-comment">     * 分三种情况：  </span><br><span class="hljs-comment">     * 找到空位，直接插入  </span><br><span class="hljs-comment">     * 找链表，如果key已存在，替换value  </span><br><span class="hljs-comment">     * 找链表，如果key不存在，插入链表尾部  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, Object key, Object value)</span> &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> hash &amp; (table.length - <span class="hljs-number">1</span>);<span class="hljs-comment">//hash &amp; (数组长度-1)  </span><br>        <span class="hljs-keyword">if</span> (table[idx] == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//1.找到空位 直接插入  </span><br>            table[idx] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(hash, key, value);  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            <span class="hljs-comment">//2.无空位，找链表。如果key已存在，替换value  </span><br>            <span class="hljs-type">Entry</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> table[idx];  <br>            <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span>) &#123;  <br>                <span class="hljs-keyword">if</span> (p.key.equals(key)) &#123;  <br>                    p.value = value;<span class="hljs-comment">//更新  </span><br>                    <span class="hljs-keyword">return</span>;  <br>                &#125;  <br>                <span class="hljs-keyword">if</span> (p.next == <span class="hljs-literal">null</span>) <span class="hljs-keyword">break</span>;  <br>                p = p.next;  <br>            &#125;  <br>            <span class="hljs-comment">//3.找链表，如果key不存在，插入链表尾部  </span><br>            p.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(hash, key, value);  <br>        &#125;  <br>        size++;  <br>        <span class="hljs-keyword">if</span> (size &gt; threshold) &#123;  <br>            resize();  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 根据hash 删除，返回删除的value  </span><br><span class="hljs-comment">     */</span>    Object <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, Object key)</span> &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> hash &amp; (table.length - <span class="hljs-number">1</span>);<span class="hljs-comment">//hash &amp; (数组长度-1)  </span><br>        <span class="hljs-keyword">if</span> (table[idx] == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>        <span class="hljs-type">Entry</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> table[idx];<span class="hljs-comment">//头节点  </span><br>        <span class="hljs-type">Entry</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<span class="hljs-comment">//前一个节点  </span><br>        <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-keyword">if</span> (p.key.equals(key)) &#123;<span class="hljs-comment">//找到了 删除  </span><br>                <span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> p.value;  <br>                <span class="hljs-keyword">if</span> (prev == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//删除的是头节点  </span><br>                    table[idx] = p.next;  <br>                &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//删除的是中间节点  </span><br>                    prev.next = p.next;  <br>                &#125;  <br>                size--;  <br>                <span class="hljs-keyword">return</span> value;  <br>            &#125;  <br>            prev = p;<span class="hljs-comment">//记录前一个节点  </span><br>            p = p.next;  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 扩容  </span><br><span class="hljs-comment">     * &lt;p&gt;  </span><br><span class="hljs-comment">     * 负载因子 = size / table.length  </span><br><span class="hljs-comment">     * 不易过小也不易过大，  </span><br><span class="hljs-comment">     * 过小，浪费，空间利用率低  </span><br><span class="hljs-comment">     * 过大，快满了，效率低  </span><br><span class="hljs-comment">     * &lt;p&gt;  </span><br><span class="hljs-comment">     * 3/4 也是 0.75是经验值 比较合适  </span><br><span class="hljs-comment">     * 扩容之后，会重新计算每个元素的位置  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">resize</span><span class="hljs-params">()</span> &#123;  <br>        Entry[] newTable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[table.length &lt;&lt; <span class="hljs-number">2</span>];<span class="hljs-comment">//新数组 容量是原来的2倍  </span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; table.length; i++) &#123;  <br>            <span class="hljs-type">Entry</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> table[i];<span class="hljs-comment">//头节点  </span><br>            <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">null</span>) &#123;  <br>                <span class="hljs-type">Entry</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;  <br>                <span class="hljs-type">Entry</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;  <br>                <span class="hljs-type">Entry</span> <span class="hljs-variable">aHead</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;  <br>                <span class="hljs-type">Entry</span> <span class="hljs-variable">bHead</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;  <br>                <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span>) &#123;  <br>                    <span class="hljs-comment">//拆分链表 移动到新数组  </span><br>                <span class="hljs-comment">/*  </span><br><span class="hljs-comment">                拆分规律：  </span><br><span class="hljs-comment">                    一个链表最多拆分成两个链表  </span><br><span class="hljs-comment">                    hash&amp;table.length 为0的一组  </span><br><span class="hljs-comment">                    hash&amp;table.length 为1的一组  </span><br><span class="hljs-comment">                 */</span>                    <span class="hljs-keyword">if</span> ((p.hash &amp; table.length) == <span class="hljs-number">0</span>) &#123;  <br>                        <span class="hljs-comment">//a组  </span><br>                        <span class="hljs-keyword">if</span> (a != <span class="hljs-literal">null</span>) &#123;  <br>                            a.next = p;  <br>                        &#125; <span class="hljs-keyword">else</span> &#123;  <br>                            aHead = p;<span class="hljs-comment">//记录头节点  </span><br>                        &#125;  <br>                        a = p;  <br>                    &#125; <span class="hljs-keyword">else</span> &#123;  <br>                        <span class="hljs-comment">//b组  </span><br>                        <span class="hljs-keyword">if</span> (b != <span class="hljs-literal">null</span>) &#123;  <br>                            b.next = p;  <br>                        &#125; <span class="hljs-keyword">else</span> &#123;  <br>                            bHead = p;<span class="hljs-comment">//记录头节点  </span><br>                        &#125;  <br>                        b = p;  <br>                    &#125;  <br>                    p = p.next;  <br>                &#125;  <br>                <span class="hljs-comment">//a、b组，各自的头节点重置规律  </span><br>                <span class="hljs-comment">//a:保持索引位置不变  </span><br>                <span class="hljs-comment">//b:索引位置=原索引位置+原数组长度  </span><br>                <span class="hljs-keyword">if</span> (a != <span class="hljs-literal">null</span>) &#123;  <br>                    a.next = <span class="hljs-literal">null</span>;  <br>                    newTable[i] = aHead;  <br>                &#125;  <br>                <span class="hljs-keyword">if</span> (b != <span class="hljs-literal">null</span>) &#123;  <br>                    b.next = <span class="hljs-literal">null</span>;  <br>                    newTable[i + table.length] = bHead;  <br>                &#125;  <br>            &#125;        &#125;        table = newTable;  <br>        threshold = (<span class="hljs-type">int</span>) (table.length * loadFactor);<span class="hljs-comment">//更新阈值size  </span><br>    &#125;  <br>  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * hash 改造  </span><br><span class="hljs-comment">     * &lt;p&gt;  </span><br><span class="hljs-comment">     * hash码，一种简单的方式，可以直接使用jdk的 object.hashCode()  </span><br><span class="hljs-comment">     * 所以上述 get、put、remove方法都可以加一个重载，去掉hash参数  </span><br><span class="hljs-comment">     */</span>  <br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;  <br>        <span class="hljs-keyword">return</span> key.hashCode();  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">get</span><span class="hljs-params">(Object key)</span> &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> hash(key);  <br>        <span class="hljs-keyword">return</span> get(hash, key);  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(Object key, Object value)</span> &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> hash(key);  <br>        put(hash, key, value);  <br>    &#125;  <br>  <br>    Object <span class="hljs-title function_">remove</span><span class="hljs-params">(Object key)</span> &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> hash(key);  <br>        <span class="hljs-keyword">return</span> remove(hash, key);  <br>    &#125;  <br>  <br>  <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>data&amp;algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构和算法之旅（十）- 红黑树</title>
    <link href="/posts/c47e1f8e/"/>
    <url>/posts/c47e1f8e/</url>
    
    <content type="html"><![CDATA[<blockquote><p>红黑树也是一种自平衡的二叉搜索树，较之AVL，插入和删除旋转次数更少。性能上要稍微高一些。因为判断平衡的依据是不同的，之前AVL树是判断左右子树高度差是不是超过了1，超过1表示不平衡。而红黑树判断平衡是另一种规则。</p></blockquote><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>红黑树特性：</p><ul><li>1.所有节点都有俩种颜色：红与黑</li><li>2.所有null视为黑色</li><li>3.红色节点不能相邻，(判断平衡的主要依据)</li><li>4.根节点时黑色</li><li>5.从根到任意一个叶子节点，路径中的黑色节点数一样(判断平衡的主要依据)</li></ul><p>不满足这些特性的都是不平衡的红黑树。</p></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309220920490.png"></p><h2 id="是否是红黑树？"><a href="#是否是红黑树？" class="headerlink" title="是否是红黑树？"></a>是否是红黑树？</h2><h3 id="树1"><a href="#树1" class="headerlink" title="树1"></a>树1</h3><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309221519546.png"></p><p class="note note-danger">不是红黑树。因为违反了第3条：红色节点不能相邻。</p><h3 id="树2"><a href="#树2" class="headerlink" title="树2"></a>树2</h3><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309221521761.png"></p><p class="note note-danger">不是红黑树。因为违反了第5条：从根到任意一个叶子节点，路径中黑色节点数一样。右边重，左边轻，是不平衡的。</p><h3 id="树3"><a href="#树3" class="headerlink" title="树3"></a>树3</h3><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309221522358.png"></p><p class="note note-success">是红黑树。关键的3,4,5条特性都满足。</p><h3 id="树4"><a href="#树4" class="headerlink" title="树4"></a>树4</h3><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309221524531.png"></p><p class="note note-danger">这个和上一个类似，但是它并不是平衡的。<br>因为没有考虑null值。<br>那什么时候需要考虑null呢，就是当叶子节点没有自己的兄弟的时候，这个时候就需要把null加进来考虑。</p><p>如果加入null值，如下图， 6到2的右孩子只有俩个黑色，而6到1或者8的孩子都是3个黑色，所以是不平衡的。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309221526990.png"></p><p class="note note-warning">那为什么树3是平衡的红黑树呢？可以把null考虑进来，可以看出根到任意叶子节点的黑色数都是3，所以是平衡的。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309221531405.png"></p><p class="note note-primary">判断是否平衡有一点经验总结。<br>如果叶子节点是红色，可以不用不用care。<br>如果叶子节点就一个黑色，没有兄弟节点，那肯定是不平衡的。<br>红色节点无所谓，黑色节点肯定要成对出现的。</p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309221539104.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> redblack;  <br>  <br><span class="hljs-keyword">import</span> com.sun.org.apache.regexp.internal.RE;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedBlackTree</span> &#123;  <br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> &#123;  <br>        RED, BLACK;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">private</span> Node root;  <br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;  <br>        <span class="hljs-type">int</span> key;  <br>        Object value;  <br>        Node left;  <br>        Node right;  <br>        Node parent;<span class="hljs-comment">//父节点 因为红黑树的删除和新增经常用到父节点  </span><br>        <span class="hljs-type">Color</span> <span class="hljs-variable">color</span> <span class="hljs-operator">=</span> Color.RED;<span class="hljs-comment">//默认刚创建出来新节点是为红色  </span><br>  <br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> key, Object value)</span> &#123;  <br>            <span class="hljs-built_in">this</span>.key = key;  <br>            <span class="hljs-built_in">this</span>.value = value;  <br>        &#125;  <br>  <br>        <span class="hljs-comment">//是否是左孩子 常用工具方法  </span><br>        <span class="hljs-type">boolean</span> <span class="hljs-title function_">isLeftChild</span><span class="hljs-params">()</span> &#123;  <br>            <span class="hljs-comment">//如果父节点不为空且父节点的left是自身则是左孩子  </span><br>            <span class="hljs-keyword">return</span> parent != <span class="hljs-literal">null</span> &amp;&amp; parent.left == <span class="hljs-built_in">this</span>;  <br>        &#125;  <br>  <br>        <span class="hljs-comment">//叔叔 常用工具方法  </span><br>        Node <span class="hljs-title function_">uncle</span><span class="hljs-params">()</span> &#123;  <br>            <span class="hljs-keyword">if</span> (parent == <span class="hljs-literal">null</span> || parent.parent == <span class="hljs-literal">null</span>) &#123;  <br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<span class="hljs-comment">//没有爷爷就没有叔叔  </span><br>            &#125;  <br>            <span class="hljs-keyword">if</span> (parent.isLeftChild()) &#123;  <br>                <span class="hljs-keyword">return</span> parent.parent.right;  <br>            &#125; <span class="hljs-keyword">else</span> &#123;  <br>                <span class="hljs-keyword">return</span> parent.parent.left;  <br>            &#125;  <br>        &#125;  <br>  <br>        <span class="hljs-comment">//兄弟 常用工具方法  </span><br>        Node <span class="hljs-title function_">sibling</span><span class="hljs-params">()</span> &#123;  <br>            <span class="hljs-keyword">if</span> (parent == <span class="hljs-literal">null</span>) &#123;  <br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<span class="hljs-comment">//没父亲就没兄弟  </span><br>            &#125;  <br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.isLeftChild()) &#123;  <br>                <span class="hljs-keyword">return</span> parent.right;  <br>            &#125; <span class="hljs-keyword">else</span> &#123;  <br>                <span class="hljs-keyword">return</span> parent.left;  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//判断红、黑  </span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isRed</span><span class="hljs-params">(Node node)</span> &#123;  <br>        <span class="hljs-keyword">return</span> node != <span class="hljs-literal">null</span> &amp;&amp; node.color == Color.RED;  <br>    &#125;  <br>  <br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBlack</span><span class="hljs-params">(Node node)</span> &#123;  <br>        <span class="hljs-keyword">return</span> node == <span class="hljs-literal">null</span> || node.color == Color.BLACK;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//右选 1.parent的处理 2.旋转后新根的父子关系  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rightRotate</span><span class="hljs-params">(Node pink)</span> &#123;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> pink.parent;<span class="hljs-comment">//pink不平衡的节点  </span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">yellow</span> <span class="hljs-operator">=</span> pink.left;<span class="hljs-comment">//yellow新根  </span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">green</span> <span class="hljs-operator">=</span> yellow.right;<span class="hljs-comment">//green要换爹的  </span><br>        <span class="hljs-keyword">if</span> (green != <span class="hljs-literal">null</span>) &#123;  <br>            green.parent = pink;  <br>        &#125;  <br>        yellow.right = pink;<span class="hljs-comment">//顶上去  </span><br>        yellow.parent = parent;  <br>        pink.left = green;  <br>        pink.parent = yellow;  <br>        <span class="hljs-keyword">if</span> (parent == <span class="hljs-literal">null</span>) &#123;  <br>            root = yellow;  <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (parent.left == pink) &#123;  <br>            parent.left = yellow;  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            parent.right = yellow;  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//左旋  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">leftRotate</span><span class="hljs-params">(Node pink)</span> &#123;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> pink.parent;<span class="hljs-comment">//pink不平衡的节点  </span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">yellow</span> <span class="hljs-operator">=</span> pink.right;<span class="hljs-comment">//yellow新根  </span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">green</span> <span class="hljs-operator">=</span> yellow.left;<span class="hljs-comment">//green要换爹的  </span><br>        <span class="hljs-keyword">if</span> (green != <span class="hljs-literal">null</span>) &#123;  <br>            green.parent = pink;  <br>        &#125;  <br>        yellow.left = pink;<span class="hljs-comment">//顶上去  </span><br>        yellow.parent = parent;  <br>        pink.right = green;  <br>        pink.parent = yellow;  <br>        <span class="hljs-keyword">if</span> (parent == <span class="hljs-literal">null</span>) &#123;  <br>            root = yellow;  <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (parent.right == pink) &#123;  <br>            parent.right = yellow;  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            parent.left = yellow;  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 新增或更新  </span><br><span class="hljs-comment">     * 找空位，找到之后根据k-v创建新的节点对象，然后根父节点建立好父子关系，新增操作就算完成了。  </span><br><span class="hljs-comment">     * 如果没有找到空位，就根据key的大小不断的向左找向右找。  </span><br><span class="hljs-comment">     * 如果找相同的key，就是更新。  </span><br><span class="hljs-comment">     * &lt;p&gt;  </span><br><span class="hljs-comment">     * 正常增，遇到红红不平衡进行调整  </span><br><span class="hljs-comment">     * 红红不平衡细分有四种case。  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, Object value)</span> &#123;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> root;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<span class="hljs-comment">//记录新增节点的父节点  </span><br>        <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span>) &#123;  <br>            parent = p;  <br>            <span class="hljs-keyword">if</span> (key &lt; p.key) &#123;  <br>                p = p.left;  <br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p.key &lt; key) &#123;  <br>                p = p.right;  <br>            &#125; <span class="hljs-keyword">else</span> &#123;  <br>                p.value = value;<span class="hljs-comment">//更新  </span><br>                <span class="hljs-keyword">return</span>;  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">inserted</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(key, value);  <br>        <span class="hljs-keyword">if</span> (parent == <span class="hljs-literal">null</span>) root = inserted;  <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &lt; parent.key) &#123;  <br>            parent.left = inserted;  <br>            inserted.parent = parent;<span class="hljs-comment">//1.维护parent属性  </span><br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            parent.right = inserted;  <br>            inserted.parent = parent;<span class="hljs-comment">//1.维护parent属性  </span><br>        &#125;  <br>        fixRedRed(inserted);  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//修复红红  </span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">fixRedRed</span><span class="hljs-params">(Node x)</span> &#123;  <br>        <span class="hljs-comment">//case 1.插入节点是根节点，变黑集合  </span><br>        <span class="hljs-keyword">if</span> (x == root) &#123;  <br>            x.color = Color.BLACK;  <br>            <span class="hljs-keyword">return</span>;  <br>        &#125;  <br>        <span class="hljs-comment">//case 2.插入节点父亲是黑色，无需调整  </span><br>        <span class="hljs-keyword">if</span> (isBlack(x.parent)) &#123;  <br>            <span class="hljs-keyword">return</span>;  <br>        &#125;  <br>        <span class="hljs-comment">/*  </span><br><span class="hljs-comment">        case 3.当红红相邻，叔叔为红色时  </span><br><span class="hljs-comment">        需要将父亲、叔叔变黑、祖父变红，然后对祖父做递归处理  </span><br><span class="hljs-comment">         */</span>        <span class="hljs-type">Node</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> x.parent;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">uncle</span> <span class="hljs-operator">=</span> x.uncle();  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">grandparent</span> <span class="hljs-operator">=</span> parent.parent;  <br>        <span class="hljs-keyword">if</span> (isRed(uncle)) &#123;  <br>            parent.color = Color.BLACK;  <br>            uncle.color = Color.BLACK;  <br>            grandparent.color = Color.RED;  <br>            fixRedRed(grandparent);  <br>        &#125;  <br>  <br>        <span class="hljs-comment">//case 4.  </span><br>        <span class="hljs-keyword">if</span> (parent.isLeftChild() &amp;&amp; x.isLeftChild()) &#123;<span class="hljs-comment">//LL  </span><br>            parent.color = Color.BLACK;  <br>            grandparent.color = Color.RED;  <br>            rightRotate(grandparent);  <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (parent.isLeftChild() &amp;&amp; !x.isLeftChild()) &#123;<span class="hljs-comment">//RL  </span><br>            leftRotate(parent);<span class="hljs-comment">//使之变成LL case  </span><br>            x.color = Color.BLACK;  <br>            grandparent.color = Color.RED;  <br>            rightRotate(grandparent);  <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!parent.isLeftChild() &amp;&amp; !x.isLeftChild()) &#123;<span class="hljs-comment">//RR  </span><br>            parent.color = Color.BLACK;  <br>            grandparent.color = Color.RED;  <br>            leftRotate(grandparent);  <br>        &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//LR  </span><br>            rightRotate(parent);<span class="hljs-comment">////使之变成RR case  </span><br>            x.color = Color.BLACK;  <br>            grandparent.color = Color.RED;  <br>            leftRotate(grandparent);  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 查找删除节点  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">private</span> Node <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> root;  <br>        <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-keyword">if</span> (key &lt; p.key) &#123;  <br>                p = p.left;  <br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p.key &lt; key) &#123;  <br>                p = p.right;  <br>            &#125; <span class="hljs-keyword">else</span> &#123;  <br>                <span class="hljs-keyword">return</span> p;  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 查找剩余节点  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">private</span> Node <span class="hljs-title function_">findReplaced</span><span class="hljs-params">(Node deleted)</span> &#123;  <br>        <span class="hljs-keyword">if</span> (deleted.left == <span class="hljs-literal">null</span> &amp;&amp; deleted.right == <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>        &#125;  <br>        <span class="hljs-keyword">if</span> (deleted.left == <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-keyword">return</span> deleted.right;  <br>        &#125;  <br>        <span class="hljs-keyword">if</span> (deleted.right == <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-keyword">return</span> deleted.left;  <br>        &#125;  <br>        <span class="hljs-comment">//有俩个孩子，要找后继节点(右子树的最左)  </span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> deleted.right;  <br>        <span class="hljs-keyword">while</span> (s.left != <span class="hljs-literal">null</span>) &#123;  <br>            s = s.left;  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> s;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 删除  </span><br><span class="hljs-comment">     * 正常删、会用到李代桃僵的技巧，遇到黑黑不平衡进行调整  </span><br><span class="hljs-comment">     * 黑黑不平衡细分有6种case。  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">deleted</span> <span class="hljs-operator">=</span> find(key);  <br>        <span class="hljs-keyword">if</span> (deleted == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;  <br>        doRemove(deleted);  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doRemove</span><span class="hljs-params">(Node deleted)</span> &#123;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">replaced</span> <span class="hljs-operator">=</span> findReplaced(deleted);  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> deleted.parent;  <br>        <span class="hljs-keyword">if</span> (replaced == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//没有孩子  </span><br>            <span class="hljs-comment">//case 1.删的根节点  </span><br>            <span class="hljs-keyword">if</span> (deleted == root) &#123;  <br>                root = <span class="hljs-literal">null</span>;  <br>            &#125; <span class="hljs-keyword">else</span> &#123;  <br>                <span class="hljs-keyword">if</span> (isBlack(deleted)) &#123;<span class="hljs-comment">//删除到节点时黑，剩余的也是黑，双黑(null也是黑)  </span><br>                    <span class="hljs-comment">//复杂调整  </span><br>                    fixDoubleBlack(deleted);<span class="hljs-comment">//先调整平衡，下面在删除  </span><br>                &#125; <span class="hljs-keyword">else</span> &#123;  <br>                    <span class="hljs-comment">//红色叶子，无需任何处理  </span><br>                &#125;  <br>                <span class="hljs-comment">//case 2.不是根节点 并没有孩子  </span><br>                <span class="hljs-keyword">if</span> (deleted.isLeftChild()) &#123;  <br>                    parent.left = <span class="hljs-literal">null</span>;  <br>                &#125; <span class="hljs-keyword">else</span> &#123;  <br>                    parent.right = <span class="hljs-literal">null</span>;  <br>                &#125;  <br>                deleted.parent = <span class="hljs-literal">null</span>;<span class="hljs-comment">//help GC  </span><br>            &#125;  <br>            <span class="hljs-keyword">return</span>;  <br>        &#125;  <br>        <span class="hljs-keyword">if</span> (deleted.left == <span class="hljs-literal">null</span> || deleted.right == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//有一个孩子  </span><br>            <span class="hljs-keyword">if</span> (deleted == root) &#123;  <br>                <span class="hljs-comment">//case 1.删的根节点  </span><br>                root.key = replaced.key;  <br>                root.value = replaced.value;  <br>                root.left = root.right = <span class="hljs-literal">null</span>;  <br>            &#125; <span class="hljs-keyword">else</span> &#123;  <br>                <span class="hljs-comment">//case 2.不是根节点 并有一个孩子  </span><br>                <span class="hljs-keyword">if</span> (deleted.isLeftChild()) &#123;  <br>                    parent.left = replaced;  <br>                &#125; <span class="hljs-keyword">else</span> &#123;  <br>                    parent.right = replaced;  <br>                &#125;  <br>                replaced.parent = parent;  <br>                deleted.left = deleted.right = deleted.parent = <span class="hljs-literal">null</span>;<span class="hljs-comment">//help GC  </span><br>                <span class="hljs-keyword">if</span> (isBlack(deleted) &amp;&amp; isBlack(replaced)) &#123;<span class="hljs-comment">//删除到节点时黑，剩余的也是黑，双黑  </span><br>                    <span class="hljs-comment">//复杂调整  </span><br>                    fixDoubleBlack(replaced);<span class="hljs-comment">//上面先删除了，再调整  </span><br>                &#125; <span class="hljs-keyword">else</span> &#123;  <br>                    <span class="hljs-comment">//case 2  </span><br>                    replaced.color = Color.BLACK;  <br>                &#125;  <br>            &#125;  <br>            <span class="hljs-keyword">return</span>;  <br>        &#125;  <br>        <span class="hljs-comment">//有俩个孩子，找到后继，替换，删除后继节点  </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> deleted.key;  <br>        deleted.key = replaced.key;  <br>        replaced.key = t;  <br>  <br>        <span class="hljs-type">Object</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> deleted.value;  <br>        deleted.value = replaced.value;  <br>        replaced.value = v;  <br>        doRemove(replaced);  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 处理双黑  </span><br><span class="hljs-comment">     * 删除到节点和剩下的节点都是黑，触发双黑，双黑的意思是，整个路径上少一个黑！需要调整  </span><br><span class="hljs-comment">     * case 3：被调整节点的兄弟为红，此时俩个侄子定为黑（过度情况，需要转换成4或5，通过旋转）  </span><br><span class="hljs-comment">     * case 4：被调整节点的兄弟为黑，俩个侄子都为黑  </span><br><span class="hljs-comment">     * case 5：被调整节点的兄弟为黑，至少一个红侄子  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fixDoubleBlack</span><span class="hljs-params">(Node x)</span> &#123;  <br>        <span class="hljs-keyword">if</span> (x == root) &#123;<span class="hljs-comment">//递归结束条件  </span><br>            <span class="hljs-keyword">return</span>;  <br>        &#125;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> x.parent;<span class="hljs-comment">//父  </span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">sibling</span> <span class="hljs-operator">=</span> x.sibling();<span class="hljs-comment">//兄弟  </span><br>        <span class="hljs-comment">//case 3:兄弟节点是红色  </span><br>        <span class="hljs-keyword">if</span> (isRed(sibling)) &#123;  <br>            <span class="hljs-keyword">if</span> (x.isLeftChild()) &#123;<span class="hljs-comment">//旋转  </span><br>                leftRotate(parent);  <br>            &#125; <span class="hljs-keyword">else</span> &#123;  <br>                rightRotate(parent);  <br>            &#125;  <br>            parent.color = Color.RED;<span class="hljs-comment">//换色  </span><br>            sibling.color = Color.BLACK;  <br>            fixDoubleBlack(x);  <br>            <span class="hljs-keyword">return</span>;  <br>        &#125;  <br>        <span class="hljs-comment">//case 4:兄弟节点是黑色，俩个侄子都是黑  </span><br>        <span class="hljs-keyword">if</span> (sibling != <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-keyword">if</span> (isBlack(sibling.left) &amp;&amp; isBlack(sibling.right)) &#123;  <br>                sibling.color = Color.RED;  <br>                <span class="hljs-keyword">if</span> (isRed(parent)) &#123;  <br>                    parent.color = Color.BLACK;  <br>                &#125; <span class="hljs-keyword">else</span> &#123;  <br>                    fixDoubleBlack(parent);  <br>                &#125;  <br>            &#125; <span class="hljs-keyword">else</span> &#123;  <br>                <span class="hljs-comment">//case 5:兄弟是黑色，但是侄子有红色  </span><br>                <span class="hljs-comment">//LL 兄弟是左孩子，左侄子是红  </span><br>                <span class="hljs-keyword">if</span> (sibling.isLeftChild() &amp;&amp; isRed(sibling.left)) &#123;  <br>                    rightRotate(parent);  <br>                    sibling.left.color = Color.BLACK;  <br>                    sibling.color = parent.color;  <br>                &#125;  <br>                <span class="hljs-comment">//LR 兄弟是左孩子，右侄子是红  </span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sibling.isLeftChild() &amp;&amp; isRed(sibling.right)) &#123;  <br>                    sibling.right.color = parent.color;  <br>                    leftRotate(sibling);  <br>                    rightRotate(parent);  <br>                &#125;  <br>                <span class="hljs-comment">//RR 兄弟是右孩子，右侄子是红  </span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!sibling.isLeftChild() &amp;&amp; isRed(sibling.left)) &#123;  <br>                    sibling.left.color = parent.color;  <br>                    rightRotate(sibling);  <br>                    leftRotate(parent);  <br>                &#125;  <br>                <span class="hljs-comment">//RL 兄弟是右孩子，左侄子是红  </span><br>                <span class="hljs-keyword">else</span> &#123;  <br>                    leftRotate(parent);  <br>                    sibling.right.color = Color.BLACK;  <br>                    sibling.color = parent.color;  <br>                &#125;  <br>                parent.color = Color.BLACK;  <br>            &#125;  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            fixDoubleBlack(parent);  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h3><p><strong>旋转前</strong></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309221548839.png"></p><p><strong>旋转后</strong></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309221550900.png"></p><p>理解旋转，对照图，标记颜色有助于帮助理解，和代码实现。</p><p>📌<em>旋转前</em>：<br>yellow是pink的左孩子；<code>Node yellow = pink.left</code><br>green是yellow的右孩子；<code>Node green = yellow.right</code><br>📌<em>旋转后</em>：<br>yellow要顶上去，成为新根；<br>pink要下去，成为yellow的右孩子；<code>yellow.right = pink</code><br>而且pink的左孩子变成了green； <code>pink.left = green</code></p><p>到这一步，如果是AVL树就完事了，不过红黑树还要维护一个parent，🙃 还需要继续处理，并且要把新根yellow的父子关系直接在旋转这个方法里给搭建好；</p><p>接下来就把pink、yellow、green的parent属性处理好。</p><p>1️⃣ 处理green的parent：<br>旋转前，green的parent是yellow；<br>旋转后，green的parent是pink；<br>所以green的parent要重新赋值，当然green并不一定存在，所以需要一个判断：<br><code>if(green != null) green.parent = pink;</code></p><p>2️⃣ 处理yellow的parent：<br>旋转前，yellow的parent是pink；<br>旋转后，yellow成了pink的parent；<br>该图列不存在5,8的parent，但是可能存在，所以，<br><code>yellow.parent = pink.parent</code> 等价于 <code>yellow.parent = parent</code>，<br>因为这个parent就是通过<code>Node parent = pink.parent</code>拿到的。</p><p>3️⃣ 处理pink的parent：<br>旋转后，pink的parent变成了yellow；<br>所以<code>pink.parent = yellow</code></p><p><strong>还有一件事</strong>，就是处理好新根的父子关系，该图例有些特殊，直接就是根了，看一下下面图例：</p><p><strong>旋转前</strong></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309221605459.png"></p><p><strong>旋转后</strong></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309221606180.png"></p><p>要维护yellow顶上去之后的parent父子关系。<br>旋转前，通过<code>Node parent = pink.parent;</code> 拿到之前的根。<br>旋转后，需要判断之前pink是它的父的左还是右孩子，就可以判断之后，决定yellow是之前根到左还是右，所以：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(parent.left == pink)&#123;<br>parent.left = yellow;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>parent.right = yellow;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后再考虑之前的特殊情况，<br><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309221548839.png"></p><p>pink是之前的根，它的parent是null，那去给它的left、right赋值肯定是有问题的，所以应该排除这种情况，直接把yellow作为root即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(parent == <span class="hljs-literal">null</span>) root = yellow;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(parent.left == pink)&#123;<span class="hljs-comment">//把上面的非根情况逻辑补充上</span><br>parent.left = yellow;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>parent.right = yellow;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h3><p>其实左旋类似右旋，只不过反过来。可以通过着色法搞一下，比对右旋加深理解。</p><h3 id="新增或更新"><a href="#新增或更新" class="headerlink" title="新增或更新"></a>新增或更新</h3><p>新增的时候，跟基本的二叉搜索树一致，只不过多两件事</p><ul><li>1.要维护新增节点的parent属性</li><li>2.要维护红红的不平衡，因为新增的是默认红色</li></ul><p>红红不平衡，细分有四种case：<br>因为插入节点均视为红色🔴</p><ul><li>case 1.插入节点为根节点，将根节点变黑⚫️</li><li>case 2.插入节点的父节点若为黑色⚫️，树的红黑性质不变，无序调整<br>插入节点的父节点为红色🔴，触发红红相邻</li><li>case 3.叔叔为红色🔴<ul><li>1.父亲变为黑色⚫️，为了保证黑色平衡，连带叔叔也变成黑色⚫️</li><li>2.祖父如果是黑色不变，会造成这个子树黑色过多，因此祖父也变为红色🔴</li><li>3.祖父如果变成红色，可能会接着触发红红相邻，因此继续对祖父进行递归调整</li><li>4.直到根节点，如果root变为红色，改为红色就完成了</li></ul></li><li>case 4.叔叔为黑色⚫️<ul><li>1.父亲为左孩子，插入节点也是左孩子，此时即LL不平衡</li><li>2.父亲为左孩子，插入节点是右孩子，此时即LR不平衡</li><li>3.父亲为右孩子，插入节点也是右孩子，此时即RR不平衡</li><li>4.父亲为右孩子，插入节点是左孩子，此时即RL不平衡</li></ul></li></ul><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>删除可能触发双黑的情况，触发双黑，双黑的意思是，整个路径上少一个黑！需要调整也有很多case如下：</p><ul><li>case 0：如果删除节点有俩个孩子，化简成只有一个孩子或没有孩子（替换删除）</li><li>csae 1：删除到是根节点</li><li>case 2：删除的是黑⚫️，剩下的红🔴，剩下这个红节点变黑⚫️</li><li>case 3：被调整节点的兄弟为红🔴，此时俩个侄子定为黑⚫️</li><li>case 4：被调整节点的兄弟是黑⚫️，俩个侄子都为黑⚫️</li><li>case 5：被调整节点的兄弟是黑⚫️，至少一个红🔴侄子<ul><li>如果兄弟是左孩子，左侄子是红🔴，LL不平衡</li><li>如果兄弟是左孩子，右侄子是红🔴，LR不平衡</li><li>如果兄弟是右孩子，右侄子是红🔴，RR不平衡</li><li>如果兄弟是右孩子，左侄子是红🔴，RL不平衡</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>data&amp;algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>红黑树</tag>
      
      <tag>左旋</tag>
      
      <tag>右旋</tag>
      
      <tag>变色</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构和算法之旅（九）- AVL树</title>
    <link href="/posts/cbf454fc/"/>
    <url>/posts/cbf454fc/</url>
    
    <content type="html"><![CDATA[<p class="note note-light">二叉搜索树，如果不平衡，那么查找效率就会从对数级降级成O(n)。<br>可以通过旋转来恢复平衡，而且旋转并不影响二叉搜索树的特性。<br>那么，如何判断是否不平衡呢，是有个结论的：<br>如果一个节点的左右孩子，高度差超过1，则此节点失衡，才需要旋转。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309212107467.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309212109106.png"></p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><ul><li>二叉搜索树在插入和删除时，节点可能失衡。</li><li>如果在插入和删除时通过旋转，始终让二叉搜索树保持平衡，称为自平衡的二叉搜索树。</li><li>AVL是自平衡二叉搜索树的实现之一。</li></ul></blockquote><h2 id="旋转分析"><a href="#旋转分析" class="headerlink" title="旋转分析"></a>旋转分析</h2><p>失衡有四种情况LL、LR、RL、RR，但基本的选择操作有俩种就是左旋或右旋。</p><h3 id="LL"><a href="#LL" class="headerlink" title="LL"></a>LL</h3><blockquote><ul><li>失衡节点（图中5红色）的bf &gt; 1，即左边更高</li><li>失衡节点的左孩子（图中3黄色）的bf &gt;&#x3D; 0，即左孩子也是左边更高或等高</li></ul></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309212134218.png"></p><h3 id="LR"><a href="#LR" class="headerlink" title="LR"></a>LR</h3><blockquote><ul><li>失衡节点（图中6）的bf &gt; 1，即左边高</li><li>失衡节点的左孩子（图中2红色）的bf &lt; 0，即左孩子是右边高</li></ul></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309212135453.png"></p><h3 id="RL"><a href="#RL" class="headerlink" title="RL"></a>RL</h3><blockquote><ul><li>失衡节点（图中2）的bf &lt; -1 ，即右边高</li><li>失衡节点的右孩子（图中6红色）的bf &gt; 0 ，即右孩子的左边更高</li></ul></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309212135743.png"></p><h3 id="RR"><a href="#RR" class="headerlink" title="RR"></a>RR</h3><blockquote><ul><li>失衡节点（图中2红色）的bf &lt; -1 ，即右边更高</li><li>失衡节点（图中6黄色）的bf &lt;&#x3D; 0，即右孩子的右边更高或等高</li></ul></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309212135380.png"></p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> avl;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AVLTree</span> &#123;  <br>  <br>    AVLNode root;  <br>  <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AVLNode</span> &#123;  <br>        <span class="hljs-type">int</span> key;  <br>        Object value;  <br>        AVLNode left;  <br>        AVLNode right;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">height</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//高度  </span><br>  <br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">AVLNode</span><span class="hljs-params">(<span class="hljs-type">int</span> key, Object value)</span> &#123;  <br>            <span class="hljs-built_in">this</span>.key = key;  <br>            <span class="hljs-built_in">this</span>.value = value;  <br>        &#125;  <br>  <br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">AVLNode</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;  <br>            <span class="hljs-built_in">this</span>.key = key;  <br>        &#125;  <br>  <br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">AVLNode</span><span class="hljs-params">(<span class="hljs-type">int</span> key, Object value, AVLNode left, AVLNode right)</span> &#123;  <br>            <span class="hljs-built_in">this</span>.key = key;  <br>            <span class="hljs-built_in">this</span>.value = value;  <br>            <span class="hljs-built_in">this</span>.left = left;  <br>            <span class="hljs-built_in">this</span>.right = right;  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//求节点的高度  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">height</span><span class="hljs-params">(AVLNode node)</span> &#123;  <br>        <span class="hljs-keyword">return</span> node == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : node.height;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//更新节点高度(新增、删除、旋转)  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateHeight</span><span class="hljs-params">(AVLNode node)</span> &#123;  <br>        <span class="hljs-comment">//就是找左或右深度加1  </span><br>        node.height = Integer.max(height(node.left), height(node.right)) + <span class="hljs-number">1</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 平衡因子balance factor = 左子树高度-右子树高度  </span><br><span class="hljs-comment">     * 0 , -1, 1 都是平衡的  </span><br><span class="hljs-comment">     * bf&gt;1，不平衡，表示左边高  </span><br><span class="hljs-comment">     * bf&lt;-1，不平衡，表示右边高  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">bf</span><span class="hljs-params">(AVLNode node)</span> &#123;  <br>        <span class="hljs-keyword">return</span> height(node.left) - height(node.right);  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 右旋，就是把根旋转下去，把左子树旋转上来  </span><br><span class="hljs-comment">     *  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> node 要旋转的节点  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 选装上去的新的根节点  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">private</span> AVLNode <span class="hljs-title function_">rightRotate</span><span class="hljs-params">(AVLNode node)</span> &#123;  <br>        <span class="hljs-type">AVLNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> node.left;<span class="hljs-comment">//找到左子树  </span><br>        left.right = node;<span class="hljs-comment">//顶上去  </span><br>        node.left = left.right;<span class="hljs-comment">//换爹的  </span><br>        updateHeight(node);<span class="hljs-comment">//更新高度  </span><br>        updateHeight(left);<span class="hljs-comment">//更新高度  </span><br>        <span class="hljs-keyword">return</span> left;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 左旋，就是把根旋转下去，把右子树旋转上来  </span><br><span class="hljs-comment">     *  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> node 要旋转的节点  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 选装上去的新的根节点  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">private</span> AVLNode <span class="hljs-title function_">leftRotate</span><span class="hljs-params">(AVLNode node)</span> &#123;  <br>        <span class="hljs-type">AVLNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> node.right;<span class="hljs-comment">//找到右子树  </span><br>        right.left = node;<span class="hljs-comment">//顶上去  </span><br>        node.right = right.left;<span class="hljs-comment">//换爹的  </span><br>        updateHeight(node);<span class="hljs-comment">//更新高度  </span><br>        updateHeight(right);<span class="hljs-comment">//更新高度  </span><br>        <span class="hljs-keyword">return</span> right;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//先左旋左子树，再右旋根节点  </span><br>    <span class="hljs-keyword">private</span> AVLNode <span class="hljs-title function_">leftRightRotate</span><span class="hljs-params">(AVLNode node)</span> &#123;  <br>        node.left = leftRotate(node.left);  <br>        <span class="hljs-keyword">return</span> rightRotate(node);  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//先右旋右子树，在左旋根节点  </span><br>    <span class="hljs-keyword">private</span> AVLNode <span class="hljs-title function_">rightLeftRotate</span><span class="hljs-params">(AVLNode node)</span> &#123;  <br>        node.right = rightRotate(node.right);  <br>        <span class="hljs-keyword">return</span> leftRotate(node);  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 检查节点是否失衡，重新平衡  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">private</span> AVLNode <span class="hljs-title function_">balance</span><span class="hljs-params">(AVLNode node)</span> &#123;  <br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">bf</span> <span class="hljs-operator">=</span> bf(node);  <br>        <span class="hljs-keyword">if</span> (bf &gt; <span class="hljs-number">1</span> &amp;&amp; bf(node.left) &gt;= <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//LL 考虑删除引发的不平衡，加个等号  </span><br>            <span class="hljs-keyword">return</span> leftRotate(node);  <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bf &gt; <span class="hljs-number">1</span> &amp;&amp; bf(node.left) &lt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//LR  </span><br>            <span class="hljs-keyword">return</span> leftRightRotate(node);  <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bf &lt; -<span class="hljs-number">1</span> &amp;&amp; bf(node.right) &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//RL  </span><br>            <span class="hljs-keyword">return</span> rightLeftRotate(node);  <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bf &lt; -<span class="hljs-number">1</span> &amp;&amp; bf(node.right) &lt;= <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//RR 考虑删除引发的不平衡，加个等号  </span><br>            <span class="hljs-keyword">return</span> rightRotate(node);  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> node;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 新增&amp;更新  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, Object value)</span> &#123;  <br>        root = doPut(root, key, value);  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 递归实现put  </span><br><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> AVLNode <span class="hljs-title function_">doPut</span><span class="hljs-params">(AVLNode node, <span class="hljs-type">int</span> key, Object value)</span> &#123;  <br>        <span class="hljs-comment">//1.找到空位，创建新节点  </span><br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AVLNode</span>(key, value);  <br>        &#125;  <br>        <span class="hljs-comment">//2.key已存在，更新  </span><br>        <span class="hljs-keyword">if</span> (key == node.key) &#123;  <br>            node.value = value;  <br>            <span class="hljs-keyword">return</span> node;  <br>        &#125;  <br>        <span class="hljs-comment">//3.继续查找  </span><br>        <span class="hljs-keyword">if</span> (key &lt; node.key) &#123;  <br>            node.left = doPut(node.left, key, value);  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            node.right = doPut(node.right, key, value);  <br>        &#125;  <br>        updateHeight(node);  <br>        <span class="hljs-keyword">return</span> balance(node);  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 删除  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;  <br>        root = doRemove(root, root.key);  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">private</span> AVLNode <span class="hljs-title function_">doRemove</span><span class="hljs-params">(AVLNode node, <span class="hljs-type">int</span> key)</span> &#123;  <br>        <span class="hljs-comment">//1.node==null  </span><br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>        <span class="hljs-comment">//2.没找到key继续递归  </span><br>        <span class="hljs-keyword">if</span> (key &lt; node.key) &#123;  <br>            node.left = doRemove(node.left, key);  <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.key &lt; key) &#123;  <br>            node.right = doRemove(node.right, key);  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            <span class="hljs-comment">//3.找到key  1.没有孩子  2.只有一个孩子  3有俩个孩子  </span><br>            <span class="hljs-keyword">if</span> (node.left == <span class="hljs-literal">null</span> &amp;&amp; node.right == <span class="hljs-literal">null</span>) &#123;  <br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.left == <span class="hljs-literal">null</span>) &#123;  <br>                node = node.right;<span class="hljs-comment">//暂存给node 等待更新高度和平衡  </span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.right == <span class="hljs-literal">null</span>) &#123;  <br>                node = node.left;<span class="hljs-comment">//暂存给node 等待更新高度和平衡  </span><br>            &#125; <span class="hljs-keyword">else</span> &#123;  <br>                <span class="hljs-comment">//找后续：右子树的最左  </span><br>                <span class="hljs-comment">//处理后事  </span><br>                <span class="hljs-comment">//顶替  </span><br>                <span class="hljs-type">AVLNode</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.right;  <br>                <span class="hljs-keyword">while</span> (s.left != <span class="hljs-literal">null</span>) &#123;  <br>                    s = s.left;  <br>                &#125;  <br>                s.right = doRemove(node.right, s.key);  <br>                s.left = node.left;  <br>                node = s;  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-comment">//4.更新高度  </span><br>        updateHeight(node);  <br>        <span class="hljs-comment">//5.balance  </span><br>        <span class="hljs-keyword">return</span> balance(node);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>data&amp;algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AVL树</tag>
      
      <tag>失衡</tag>
      
      <tag>高度</tag>
      
      <tag>旋转</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构和算法之旅（八）- 二叉搜索树</title>
    <link href="/posts/6ed67d4e/"/>
    <url>/posts/6ed67d4e/</url>
    
    <content type="html"><![CDATA[<blockquote><p>之前接触过了很多数据结果，包括动态数组、单向链表、双向链表、环形链表、优先级队列、大顶堆等等，在这些数据结构里查找一个元素效率都不太高，都是线性的时间。如果想实现快速查找，就得引入新的算法或者数据结构了。最早了解的二分查找算法查找效率不错，是logn的。但是排序也是成本比较高的，先排序再查找有些得不偿失。<br>那么有什么新的算法或数据结构呢，答案是有的。<br>接下来就来看一下二叉搜索树，也称为二叉排序树。</p></blockquote><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309211606403.png"></p><p class="note note-primary">二叉搜索树有俩个特点：<br>1.树节点增加key属性，用来比较谁大谁小，key不可重复。<br>2.对于任意一个树节点，它的key比左子树的key都大，同时也比右子树的key都小。</p><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><blockquote><p>查找的性能是对数级别的，但是有些情况比如树不平衡的时候，时间复杂度又回到了O(n)。</p></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309211610963.png"></p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309212009913.png"></p><p class="note note-light">以下是几个提前准备的算法基础。</p><p><strong>前任的算法</strong></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309211951386.png"></p><p><strong>后任的算法</strong>（与前任相反）<br><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309212008791.png"></p><p><strong>删除的算法</strong>（稍微复杂）<br><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309212014389.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> bst;  <br>  <br><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * Binary Search Tree二叉搜索树  </span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BSTTree</span>&lt;K <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;K&gt;, V&gt; &#123;  <br>  <br>    BSTNode&lt;K, V&gt; root;<span class="hljs-comment">//根节点  </span><br>  <br>  <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BSTNode</span>&lt;K, V&gt; &#123;  <br>        K key;  <br>        V value;  <br>        BSTNode&lt;K, V&gt; left;  <br>        BSTNode&lt;K, V&gt; right;  <br>  <br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">BSTNode</span><span class="hljs-params">(K key)</span> &#123;  <br>            <span class="hljs-built_in">this</span>.key = key;  <br>        &#125;  <br>  <br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">BSTNode</span><span class="hljs-params">(K key, V value)</span> &#123;  <br>            <span class="hljs-built_in">this</span>.key = key;  <br>            <span class="hljs-built_in">this</span>.value = value;  <br>        &#125;  <br>  <br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">BSTNode</span><span class="hljs-params">(K key, V value, BSTNode&lt;K, V&gt; left, BSTNode&lt;K, V&gt; right)</span> &#123;  <br>            <span class="hljs-built_in">this</span>.key = key;  <br>            <span class="hljs-built_in">this</span>.value = value;  <br>            <span class="hljs-built_in">this</span>.left = left;  <br>            <span class="hljs-built_in">this</span>.right = right;  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 查找关键字对应的值  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(K key)</span> &#123;  <br>        <span class="hljs-comment">//对外隐藏了BSTNode的参数，不用暴露给外界  </span><br>        <span class="hljs-keyword">return</span> doGet(root, key);  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 递归方式实现get  </span><br><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> V <span class="hljs-title function_">doGet</span><span class="hljs-params">(BSTNode&lt;K, V&gt; p, K key)</span> &#123;  <br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<span class="hljs-comment">//没有节点了，没找到，结束递归  </span><br>        &#125;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> key.compareTo(p.key);  <br>        <span class="hljs-keyword">if</span> (result &lt; <span class="hljs-number">0</span>) &#123;  <br>            <span class="hljs-keyword">return</span> doGet(p.left, key);<span class="hljs-comment">//如果待查找的key小于node，向左找  </span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result &gt; <span class="hljs-number">0</span>) &#123;  <br>            <span class="hljs-keyword">return</span> doGet(p.right, key);<span class="hljs-comment">//向右找  </span><br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            <span class="hljs-keyword">return</span> p.value;<span class="hljs-comment">//找到了就返回value  </span><br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 非递归实现get  </span><br><span class="hljs-comment">     * 尾递归的代码转换成非递归的实现非常简单，这样性能更好一些  </span><br><span class="hljs-comment">     * 比较java不支持尾递归自动优化，不妨都转换成循环的方式。  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">_get</span><span class="hljs-params">(K key)</span> &#123;  <br>        BSTNode&lt;K, V&gt; p = root;  <br>        <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> key.compareTo(p.key);  <br>            <span class="hljs-comment">/*  </span><br><span class="hljs-comment">            compareTo            -1 key &lt; node.key            0 key == node.key            1 key &gt; node.key             */</span>            <span class="hljs-keyword">if</span> (result &lt; <span class="hljs-number">0</span>) &#123;  <br>                p = p.left;  <br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result &gt; <span class="hljs-number">0</span>) &#123;  <br>                p = p.right;  <br>            &#125; <span class="hljs-keyword">else</span> &#123;  <br>                <span class="hljs-keyword">return</span> p.value;  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 查找最小关键字的值  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">min</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> doMin(root);  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 递归实现min  </span><br><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">doMin</span><span class="hljs-params">(BSTNode&lt;K, V&gt; node)</span> &#123;  <br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>        <span class="hljs-keyword">if</span> (node.left == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//最小节点  </span><br>            <span class="hljs-keyword">return</span> node.value;  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> doMin(node.left);  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 非递归实现min  </span><br><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">_doMin1</span><span class="hljs-params">(BSTNode node)</span> &#123;  <br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>        <span class="hljs-keyword">while</span> (node.left != <span class="hljs-literal">null</span>) &#123;  <br>            node = node.left;  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> node.value;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 查找最大关键字对应的值  </span><br><span class="hljs-comment">     * 最最小值类似，换找right即可，此处就省略了  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">max</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> _doMax(root);  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 非递归实现max  </span><br><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">_doMax</span><span class="hljs-params">(BSTNode&lt;K, V&gt; node)</span> &#123;  <br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>        <span class="hljs-keyword">while</span> (node.right != <span class="hljs-literal">null</span>) &#123;  <br>            node = node.right;  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> node.value;  <br>    &#125;  <br>  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 存储关键字和对应值  </span><br><span class="hljs-comment">     * 先比较，再判断是更新还是新增  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;  <br>        <span class="hljs-comment">//1.key存在，更新  </span><br>        <span class="hljs-comment">//2.key不存在，新增  </span><br>  <br>        <span class="hljs-comment">//get的实现拿过来  </span><br>        BSTNode&lt;K, V&gt; p = root;  <br>        BSTNode&lt;K, V&gt; parent = <span class="hljs-literal">null</span>;  <br>  <br>        <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span>) &#123;  <br>            parent = p;  <br>            <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> key.compareTo(p.key);  <br>            <span class="hljs-keyword">if</span> (result &lt; <span class="hljs-number">0</span>) &#123;  <br>                p = p.left;  <br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result &gt; <span class="hljs-number">0</span>) &#123;  <br>                p = p.right;  <br>            &#125; <span class="hljs-keyword">else</span> &#123;  <br>                <span class="hljs-comment">//找到了，更新  </span><br>                p.value = value;  <br>                <span class="hljs-keyword">return</span>;  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-comment">//没找到，新增  </span><br>        <span class="hljs-comment">//父节点就是parent，因为if、else if变成null之后parent就是目标父节点  </span><br>        <span class="hljs-keyword">if</span> (parent == <span class="hljs-literal">null</span>) &#123;  <br>            root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BSTNode</span>&lt;&gt;(key, value);  <br>        &#125;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">compareTo</span> <span class="hljs-operator">=</span> key.compareTo(parent.key);  <br>        <span class="hljs-keyword">if</span> (compareTo &lt; <span class="hljs-number">0</span>) &#123;  <br>            parent.left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BSTNode</span>&lt;&gt;(key, value);  <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (compareTo &gt; <span class="hljs-number">0</span>) &#123;  <br>            parent.right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BSTNode</span>&lt;&gt;(key, value);  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 查找关键字的前驱值（前任，比它小的里面最大的）  </span><br><span class="hljs-comment">     * 对二叉搜索树做一次中序遍历一下即可得到升序的结果，但这样不高效。  </span><br><span class="hljs-comment">     * &lt;p&gt;  </span><br><span class="hljs-comment">     * 而是要通过一下总结下来的规律得出的。  </span><br><span class="hljs-comment">     * 情况1：节点有左子树，此时前任就是左子树的最大值  </span><br><span class="hljs-comment">     * 情况2：节点没有左子树，若离它最近的、自左而来的祖先就是前任  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">predecessor</span><span class="hljs-params">(K key)</span> &#123;  <br>        BSTNode&lt;K, V&gt; p = root;  <br>        BSTNode&lt;K, V&gt; fromLeft = <span class="hljs-literal">null</span>;  <br>  <br>        <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> key.compareTo(p.key);  <br>            <span class="hljs-keyword">if</span> (result &lt; <span class="hljs-number">0</span>) &#123;  <br>                p = p.left;<span class="hljs-comment">//向左走，祖先自右而来  </span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result &gt; <span class="hljs-number">0</span>) &#123;  <br>                p = p.right;<span class="hljs-comment">//向右走，祖先自左而来  </span><br>                fromLeft = p;  <br>            &#125; <span class="hljs-keyword">else</span> &#123;  <br>                <span class="hljs-keyword">break</span>;  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-comment">//没找到节点  </span><br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>        &#125;  <br>        <span class="hljs-comment">//情况1  </span><br>        <span class="hljs-keyword">if</span> (p.left != <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-keyword">return</span> _doMax(p.left);<span class="hljs-comment">//左子树最大值  </span><br>        &#125;  <br>        <span class="hljs-comment">//情况2  </span><br>        <span class="hljs-keyword">return</span> fromLeft != <span class="hljs-literal">null</span> ? fromLeft.value : <span class="hljs-literal">null</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 查找关键字的后驱值（后任，比它大的里面最小的）  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">successor</span><span class="hljs-params">(K key)</span> &#123;  <br>        BSTNode&lt;K, V&gt; p = root;  <br>        BSTNode&lt;K, V&gt; fromRight = <span class="hljs-literal">null</span>;  <br>  <br>        <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> key.compareTo(p.key);  <br>            <span class="hljs-keyword">if</span> (result &lt; <span class="hljs-number">0</span>) &#123;  <br>                p = p.left;<span class="hljs-comment">//向左走，祖先自右而来  </span><br>                fromRight = p;  <br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result &gt; <span class="hljs-number">0</span>) &#123;  <br>                p = p.right;<span class="hljs-comment">//向右走，祖先自左而来  </span><br>            &#125; <span class="hljs-keyword">else</span> &#123;  <br>                <span class="hljs-keyword">break</span>;  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-comment">//没找到节点  </span><br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>        &#125;  <br>        <span class="hljs-comment">//情况1 节点有右子树，此时后任就是右子树的最小值  </span><br>        <span class="hljs-keyword">if</span> (p.right != <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-keyword">return</span> doMin(p.right);<span class="hljs-comment">//右子树最小值  </span><br>        &#125;  <br>        <span class="hljs-comment">//情况2 节点数没有右子树，若离它最近的、自右而来的祖先就是后任  </span><br>        <span class="hljs-keyword">return</span> fromRight != <span class="hljs-literal">null</span> ? fromRight.value : <span class="hljs-literal">null</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 根据关键字删除  </span><br><span class="hljs-comment">     * 核心概念：把被删除的节点的后继节点顶上去  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">delete</span><span class="hljs-params">(K key)</span> &#123;  <br>        BSTNode&lt;K, V&gt; p = root;  <br>        BSTNode&lt;K, V&gt; parent = <span class="hljs-literal">null</span>;  <br>        <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> key.compareTo(p.key);  <br>            <span class="hljs-keyword">if</span> (result &lt; <span class="hljs-number">0</span>) &#123;  <br>                parent = p;  <br>                p = p.left;<span class="hljs-comment">//向左走，祖先自右而来  </span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result &gt; <span class="hljs-number">0</span>) &#123;  <br>                parent = p;  <br>                p = p.right;<span class="hljs-comment">//向右走，祖先自左而来  </span><br>            &#125; <span class="hljs-keyword">else</span> &#123;  <br>                <span class="hljs-keyword">break</span>;  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>        <span class="hljs-comment">//删除操作  </span><br>        <span class="hljs-keyword">if</span> (p.left == <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-comment">//删除情况1(含情况3，走1,2都可以)  </span><br>            shift(parent, p, p.right);  <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p.right == <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-comment">//删除情况2  </span><br>            shift(parent, p, p.left);  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            <span class="hljs-comment">//删除情况4  </span><br>            <span class="hljs-comment">//4.1被删除节点找后继  </span><br>            BSTNode&lt;K, V&gt; s = p.right;  <br>            BSTNode&lt;K, V&gt; sPrent = p;<span class="hljs-comment">//后继父亲  </span><br>            <span class="hljs-keyword">while</span> (s.left != <span class="hljs-literal">null</span>) &#123;  <br>                sPrent = s;  <br>                s = s.left;  <br>            &#125;<span class="hljs-comment">//s就是后继节点  </span><br>            <span class="hljs-comment">//4.2删除节点与后继节点不相邻处理后继的后事  </span><br>            <span class="hljs-keyword">if</span> (sPrent != p) &#123;<span class="hljs-comment">//不相邻  </span><br>                shift(sPrent, s, s.right);<span class="hljs-comment">//不可能有左孩子  </span><br>                s.right = p.right;<span class="hljs-comment">//顶上去的右  </span><br>            &#125;  <br>            <span class="hljs-comment">//4.3后继取代被删除节点  </span><br>            shift(parent, p, s);  <br>            s.left = p.left;<span class="hljs-comment">//顶上去的左  </span><br>        &#125;  <br>        <span class="hljs-keyword">return</span> p.value;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 托孤方法 shift  </span><br><span class="hljs-comment">     *     * <span class="hljs-doctag">@param</span> parent  被删除节点的父节点  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> deleted 被删除到节点  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> child   被顶上去的节点  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shift</span><span class="hljs-params">(BSTNode&lt;K, V&gt; parent, BSTNode&lt;K, V&gt; deleted, BSTNode&lt;K, V&gt; child)</span> &#123;  <br>        <span class="hljs-keyword">if</span> (parent == <span class="hljs-literal">null</span>) &#123;  <br>            root = child;  <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (deleted == parent.left) &#123;  <br>            parent.left = child;  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            parent.right = child;  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>data&amp;algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉搜索树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构和算法之旅（七）- 二叉树</title>
    <link href="/posts/d9d84fdb/"/>
    <url>/posts/d9d84fdb/</url>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p class="note note-light">树中每个节点最多俩个子节点，不同于完全二叉树，不需要每层都满。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309211458897.png"></p><p class="note note-secondary">这种数据结构表示方式有俩种：<br>一种是TreeNode。<br>一种是数组。</p><h3 id="TreeNode"><a href="#TreeNode" class="headerlink" title="TreeNode"></a>TreeNode</h3><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309211459204.png"></p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309211459847.png"></p><h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309211500904.png"></p><p class="note note-secondary">层序遍历即是广度优先遍历，需要配合队列实现。<br>注：<br>以队列来层序遍历时针对TreeNode这种方式表示的二叉树。<br>如果用数组形式实现二叉树，则直接遍历数组即可，自然为层序遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.datastructure.treetraversal;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 递归方式遍历二叉树，前序、中序、后序</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeTraversal</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         *         1</span><br><span class="hljs-comment">         *       /  \</span><br><span class="hljs-comment">         *      2    3</span><br><span class="hljs-comment">         *    /     /\</span><br><span class="hljs-comment">         *   4      5  6</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         */</span><br><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<br>                        <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">4</span>), <span class="hljs-number">2</span>, <span class="hljs-literal">null</span>), <span class="hljs-number">1</span>,<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">5</span>), <span class="hljs-number">3</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">6</span>)<br>                )<br>        );<br><br>        System.out.println(<span class="hljs-string">&quot;前序遍历：&quot;</span>);<br>        preOrder(root);<br>        System.out.println(<span class="hljs-string">&quot;\n中序遍历：&quot;</span>);<br>        inOrder(root);<br>        System.out.println(<span class="hljs-string">&quot;\n后序遍历：&quot;</span>);<br>        postOrder(root);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 前序遍历</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preOrder</span><span class="hljs-params">(TreeNode node)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        System.out.print(node.val + <span class="hljs-string">&quot;\t&quot;</span>);<br>        preOrder(node.left);<br>        preOrder(node.right);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 中序遍历</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inOrder</span><span class="hljs-params">(TreeNode node)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        inOrder(node.left);<br>        System.out.print(node.val + <span class="hljs-string">&quot;\t&quot;</span>);<br>        inOrder(node.right);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 后序遍历</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postOrder</span><span class="hljs-params">(TreeNode node)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        postOrder(node.left);<br>        postOrder(node.right);<br>        System.out.print(node.val + <span class="hljs-string">&quot;\t&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>data&amp;algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
      <tag>广度优先遍历</tag>
      
      <tag>深度优先遍历</tag>
      
      <tag>前序</tag>
      
      <tag>中序</tag>
      
      <tag>后序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构和算法之旅（六）- 堆</title>
    <link href="/posts/88ba86b6/"/>
    <url>/posts/88ba86b6/</url>
    
    <content type="html"><![CDATA[<p class="note note-light">在了解优先级队列中，接触过堆的概念，了解了堆的特性以及如何使用，这里看如何建立一个堆。</p><h2 id="大顶堆"><a href="#大顶堆" class="headerlink" title="大顶堆"></a>大顶堆</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.datastructure;<br><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 大顶堆</span><br><span class="hljs-comment"> * heapify建堆，使用弗洛伊德算符，时间复杂度O(n)</span><br><span class="hljs-comment"> * 1.找到最后一个非叶子节点</span><br><span class="hljs-comment"> * 2.从最后一个非叶子节点开始，依次下沉</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * heapify、down、up这是三个核心方法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MaxHeap</span> &#123;<br>    <span class="hljs-type">int</span>[] array;<br>    <span class="hljs-type">int</span> size;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MaxHeap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array)</span> &#123;<br>        <span class="hljs-built_in">this</span>.array = array;<br>        <span class="hljs-built_in">this</span>.size = array.length;<br>        heapify();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 建堆</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">heapify</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//如何找到最后一个非叶子节点    size/2-1</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> size / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            down(i);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除堆顶元素</span><br><span class="hljs-comment">     * 直接从索引0位置移除效率不高，所以先将它最后一个元素交换，</span><br><span class="hljs-comment">     * 尾部移除，size-1就可以了，但可能导致不满足大顶堆特性，</span><br><span class="hljs-comment">     * 需要做一次下潜</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">poll</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">top</span> <span class="hljs-operator">=</span> array[<span class="hljs-number">0</span>];<br>        swap(<span class="hljs-number">0</span>, size - <span class="hljs-number">1</span>);<br>        size--;<br>        down(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> top;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除指定索引处元素</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">poll</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">deleted</span> <span class="hljs-operator">=</span> array[index];<br>        swap(index, size - <span class="hljs-number">1</span>);<br>        size--;<br>        down(index);<br>        <span class="hljs-keyword">return</span> deleted;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 替换堆顶元素</span><br><span class="hljs-comment">     * 替换后可能不满足大顶堆特性，需要做一次下潜</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">replace</span><span class="hljs-params">(<span class="hljs-type">int</span> replaced)</span> &#123;<br>        array[<span class="hljs-number">0</span>] = replaced;<br>        down(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取堆顶元素</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> array[<span class="hljs-number">0</span>];<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 向堆的尾部添加元素</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(<span class="hljs-type">int</span> offered)</span> &#123;<br>        <span class="hljs-keyword">if</span> (size == array.length) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        up(offered);<br>        size++;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将inserted元素上浮：直至offered小于父元素或到堆顶</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">up</span><span class="hljs-params">(<span class="hljs-type">int</span> offered)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">child</span> <span class="hljs-operator">=</span> size;<br>        <span class="hljs-keyword">while</span> (child &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> (child - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<span class="hljs-comment">//父节点 公式</span><br>            <span class="hljs-keyword">if</span> (array[parent] &gt;= offered)<br>                array[child] = array[parent];<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">break</span>;<br>            child = parent;<br>        &#125;<br>        array[child] = offered;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将parent索引处元素下沉：与俩个孩子较大者交换，直至没孩子或孩子没它大</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">down</span><span class="hljs-params">(<span class="hljs-type">int</span> parent)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> parent * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<span class="hljs-comment">//左孩子 公式</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> left + <span class="hljs-number">1</span>;<span class="hljs-comment">//右孩子 公式</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> parent;<br>        <span class="hljs-keyword">if</span> (left &lt; size &amp;&amp; array[left] &gt; array[max]) max = left;<br>        <span class="hljs-keyword">if</span> (right &lt; size &amp;&amp; array[right] &gt; array[max]) max = right;<br>        <span class="hljs-keyword">if</span> (max != parent) &#123;<span class="hljs-comment">//如果孩子比父亲大，就交换</span><br>            swap(max, parent);<br>            down(max);<span class="hljs-comment">//递归</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 交换俩个索引处元素</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> array[i];<br>        array[i] = array[j];<br>        array[j] = t;<br>    &#125;<br><br><br>    <span class="hljs-comment">//test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] array = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125;;<br>        <span class="hljs-type">MaxHeap</span> <span class="hljs-variable">maxHeap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MaxHeap</span>(array);<br>        System.out.println(Arrays.toString(maxHeap.array));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309211454884.png"></p>]]></content>
    
    
    <categories>
      
      <category>data&amp;algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>堆</tag>
      
      <tag>大顶堆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构和算法之旅（五）- 栈</title>
    <link href="/posts/a110ea6d/"/>
    <url>/posts/a110ea6d/</url>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p class="note note-primary">栈是一种线性数据结构，只能在其一端添加数据和移除数据。习惯来说，这一端称为栈顶，另一端不能操作数据的称为栈底，就如同生活中的一摞书籍。<br>还是老样子，看一下用不同方式实现栈。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*先定义一个Stack接口*/</span><br><span class="hljs-keyword">package</span> org.example.datastructure;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Stack</span>&lt;E&gt; &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 向栈顶压入元素</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 待压入元素</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 压入成功返回true，否则返回false</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">push</span><span class="hljs-params">(E value)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从栈顶弹出元素</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 栈非空返回栈顶元素，否则返回null</span><br><span class="hljs-comment">     */</span><br>    E <span class="hljs-title function_">pop</span><span class="hljs-params">()</span>;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回栈顶元素，但不弹出</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 栈非空返回栈顶元素，否则返回null</span><br><span class="hljs-comment">     */</span><br>    E <span class="hljs-title function_">peek</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断栈是否为空</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 空返回true，否则返回false</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断栈是否已满</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 已满返回true，否则返回false</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="链表实现"><a href="#链表实现" class="headerlink" title="链表实现"></a>链表实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.datastructure;<br><br><span class="hljs-keyword">import</span> java.util.Iterator;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 链表实现栈</span><br><span class="hljs-comment"> * 含哨兵单向链表</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedListStack</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Stack</span>&lt;E&gt;, Iterable&lt;E&gt; &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;E&gt; &#123;<br>        E value;<br>        Node&lt;E&gt; next;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(E value, Node&lt;E&gt; next)</span> &#123;<br>            <span class="hljs-built_in">this</span>.value = value;<br>            <span class="hljs-built_in">this</span>.next = next;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capacity;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 哨兵节点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Node&lt;E&gt; head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedListStack</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * head -&gt; 1 -&gt; null</span><br><span class="hljs-comment">     * head -&gt; 2 -&gt; 1 -&gt; null</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">push</span><span class="hljs-params">(E value)</span> &#123;<br>        <span class="hljs-keyword">if</span> (isFull()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">//        Node&lt;E&gt; added = new Node&lt;&gt;(value, head.next);</span><br><span class="hljs-comment">//        head.next = added;</span><br>        head.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(value, head.next);<br>        size++;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        Node&lt;E&gt; first = head.next;<span class="hljs-comment">//找到第一个节点</span><br>        head.next = first.next;<span class="hljs-comment">//跳过(删除)第一个节点</span><br>        size--;<br>        <span class="hljs-keyword">return</span> first.value;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        Node&lt;E&gt; first = head.next;<span class="hljs-comment">//找到第一个节点</span><br>        <span class="hljs-keyword">return</span> first.value;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//        return head.next == null;</span><br>        <span class="hljs-keyword">return</span> size == <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> size == capacity;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Iterator&lt;E&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt;() &#123;<br>            Node&lt;E&gt; p = head.next;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> p != <span class="hljs-literal">null</span>;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> E <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-type">E</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> p.value;<br>                p = p.next;<br>                <span class="hljs-keyword">return</span> value;<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="数组实现"><a href="#数组实现" class="headerlink" title="数组实现"></a>数组实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.datastructure;<br><br><span class="hljs-keyword">import</span> java.util.Iterator;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayStack</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Stack</span>&lt;E&gt;, Iterable&lt;E&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> E[] array;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> top;<span class="hljs-comment">//栈顶指针</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 底            顶</span><br><span class="hljs-comment">     * 0  1  2  3  4</span><br><span class="hljs-comment">     * 因为右边数组更好操作，与链表是反方向的</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-meta">@SuppressWarnings(&quot;all&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayStack</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.array = (E[]) <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[capacity];<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">push</span><span class="hljs-params">(E value)</span> &#123;<br>        <span class="hljs-keyword">if</span> (isFull()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        array[top++] = value;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> array[--top];<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> array[top - <span class="hljs-number">1</span>];<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> top == <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> top == array.length;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Iterator&lt;E&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt;() &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> top;<span class="hljs-comment">//指向栈顶，从右往左遍历</span><br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> p &gt; <span class="hljs-number">0</span>;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> E <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> array[--p];<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="有效括号"><a href="#有效括号" class="headerlink" title="有效括号"></a>有效括号</h2><p class="note note-secondary">这个很简单：<br>遇到左括号，把要配对的右括号压入栈。<br>遇到右括号，把它与栈顶元素比对。<br>- 若相等，栈顶元素弹出，继续比对下一组。<br>- 若不等，无效括号直接返回false。<br></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309202202374.png"></p><h2 id="逆波兰表达式"><a href="#逆波兰表达式" class="headerlink" title="逆波兰表达式"></a>逆波兰表达式</h2><p class="note note-secondary">1 + 2 ，这是中缀表达式。<br>1 2 +，这是后缀表达式。<br>后缀表达式交给计算机计算非常方便，因为从左向右计算，且不需要考虑优先级，优先级就是从左到右给定的顺序。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309202204129.png"></p><p class="note note-primary">解题思路：<br>遇到数字就放入栈，如果遇到运算符就从栈中取出前俩个元素计算，计算结果再压入栈，栈中剩余的一个元素就是运算结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">evalRPN</span><span class="hljs-params">(String[] tokens)</span> &#123;<br>        LinkedList&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (String t : tokens) &#123;<br>            <span class="hljs-keyword">switch</span> (t) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;+&quot;</span> -&gt; &#123;<br>                    <span class="hljs-type">Integer</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> stack.pop();<br>                    <span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> stack.pop();<br>                    stack.push(a + b);<br>                &#125;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;-&quot;</span> -&gt; &#123;<br>                    <span class="hljs-type">Integer</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> stack.pop();<br>                    <span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> stack.pop();<br>                    stack.push(a - b);<br>                &#125;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;*&quot;</span> -&gt; &#123;<br>                    <span class="hljs-type">Integer</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> stack.pop();<br>                    <span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> stack.pop();<br>                    stack.push(a * b);<br>                &#125;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/&quot;</span> -&gt; &#123;<br>                    <span class="hljs-type">Integer</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> stack.pop();<br>                    <span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> stack.pop();<br>                    stack.push(a / b);<br>                &#125;<br>                <span class="hljs-keyword">default</span> -&gt; &#123;<span class="hljs-comment">//数字</span><br>                    stack.push(Integer.parseInt(t));<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stack.pop();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>data&amp;algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
      <tag>有效括号</tag>
      
      <tag>逆波兰表达式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构和算法之旅（四）- 队列</title>
    <link href="/posts/18ca4eee/"/>
    <url>/posts/18ca4eee/</url>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p class="note note-primary">计算机科学中，queue是以顺序的方式维护一组数据集合，在一端添加数据，从另一个端移除数据。习惯来说，添加的一端称为尾，移除的一端称为头，就如同生活中排队购买商品。</p><h2 id="链表实现队列"><a href="#链表实现队列" class="headerlink" title="链表实现队列"></a>链表实现队列</h2><p class="note note-secondary">下面以单向环形含哨兵链表方式来实现队列。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309202026177.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//首先定义队列的接口</span><br><span class="hljs-keyword">package</span> org.example.datastructure;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 队列</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Queue</span>&lt;E&gt; &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 向队列尾部添加一个元素</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> val 待插入值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 插入成功返回true，否则返回false</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E val)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从队列头部取出一个元素，并移除</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 如果队列非空，返回队列头部元素，否则返回null</span><br><span class="hljs-comment">     */</span><br>    E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从队列头部取出一个元素，但不移除</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 如果队列非空，返回队列头部元素，否则返回null</span><br><span class="hljs-comment">     */</span><br>    E <span class="hljs-title function_">peek</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断队列是否为空</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 空返回true，否则返回false</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span>;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断队列是否已满</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 已满返回true，否则返回false</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.datastructure;<br><br><span class="hljs-keyword">import</span> java.util.Iterator;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 基于单向环形链表实现的队列</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * 队列只需要操作头，尾部不需要操作，所以只需要一个指针即可</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &lt;E&gt;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedListQueue</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Queue</span>&lt;E&gt;, Iterable&lt;E&gt; &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 节点类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;E&gt; &#123;<br>        E value;<br>        Node&lt;E&gt; next;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(E value, Node&lt;E&gt; next)</span> &#123;<br>            <span class="hljs-built_in">this</span>.value = value;<br>            <span class="hljs-built_in">this</span>.next = next;<br>        &#125;<br>    &#125;<br><br>    Node&lt;E&gt; head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>    Node&lt;E&gt; tail = head;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<span class="hljs-comment">// 节点数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">capacity</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<span class="hljs-comment">// 队列容量</span><br><br>    &#123;<br>    <span class="hljs-comment">//构成环</span><br>        tail.next = head;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedListQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedListQueue</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E val)</span> &#123;<br>        <span class="hljs-keyword">if</span> (isFull()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        Node&lt;E&gt; added = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(val, head);<br>        tail.next = added;<br>        tail = added;<span class="hljs-comment">//让新节点作为新的tail</span><br>        size++;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        Node&lt;E&gt; first = head.next;<br>        head.next = first.next;<br>        <span class="hljs-keyword">if</span> (first == tail) tail = head;<br>        size--;<br>        <span class="hljs-keyword">return</span> first.value;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> head.next.value;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> head == tail;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> size == capacity;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Iterator&lt;E&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt;() &#123;<br>            Node&lt;E&gt; p = head.next;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> p != head;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> E <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-type">E</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> p.value;<br>                p = p.next;<br>                <span class="hljs-keyword">return</span> value;<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="环形数组实现队列"><a href="#环形数组实现队列" class="headerlink" title="环形数组实现队列"></a>环形数组实现队列</h2><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309202148425.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309202148648.png"></p><p class="note note-secondary">判断头指针和尾指针是否指向同一个就是判空。<br>当尾指针+1等于头指针就是判断满，(tail+1)%5 == head。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.datastructure;<br><br><span class="hljs-keyword">import</span> java.util.Iterator;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayQueue1</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Queue</span>&lt;E&gt;, Iterable&lt;E&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> E[] array;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> head;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> tail;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capacity;<br><br>    <span class="hljs-meta">@SuppressWarnings(&quot;all&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayQueue1</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        array = (E[]) <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-built_in">this</span>.capacity + <span class="hljs-number">1</span>];<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E val)</span> &#123;<br>        <span class="hljs-keyword">if</span> (isFull()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        array[tail] = val;<br>        tail = (tail + <span class="hljs-number">1</span>) % array.length;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">E</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> array[head];<br>        head = (head + <span class="hljs-number">1</span>) % array.length;<br>        <span class="hljs-keyword">return</span> val;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> array[head];<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> head == tail;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> (tail + <span class="hljs-number">1</span>) % array.length == head;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Iterator&lt;E&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt;() &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> head;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> p != tail;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> E <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-type">E</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> array[p];<br>                p = (p + <span class="hljs-number">1</span>) % array.length;<br>                <span class="hljs-keyword">return</span> e;<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h2><p class="note note-primary">双端队列特点：俩端都可以添加、删除</p><h3 id="基于双向环形链表实现"><a href="#基于双向环形链表实现" class="headerlink" title="基于双向环形链表实现"></a>基于双向环形链表实现</h3><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309210856606.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.datastructure;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 双端队列</span><br><span class="hljs-comment"> * 两端都可以操作添加和删除</span><br><span class="hljs-comment"> * queue 普通队列</span><br><span class="hljs-comment"> * deque 双端队列   double-ended queue</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Deque</span>&lt;E&gt; &#123;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 向头部添加元素</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> e 待添加元素</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 添加成功返回true</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">offerFirst</span><span class="hljs-params">(E e)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 向尾部添加元素</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> e 待添加元素</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 添加成功返回true</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">offerLast</span><span class="hljs-params">(E e)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从队列头部删除元素</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 头部元素</span><br><span class="hljs-comment">     */</span><br>    E <span class="hljs-title function_">pollFirst</span><span class="hljs-params">()</span>;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从尾部获取元素并删除</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 尾部元素</span><br><span class="hljs-comment">     */</span><br>    E <span class="hljs-title function_">pollLast</span><span class="hljs-params">()</span>;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从头部获取元素但不删除</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 头部元素</span><br><span class="hljs-comment">     */</span><br>    E <span class="hljs-title function_">peekFirst</span><span class="hljs-params">()</span>;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从尾部获取元素但不删除</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 尾部元素</span><br><span class="hljs-comment">     */</span><br>    E <span class="hljs-title function_">peekLast</span><span class="hljs-params">()</span>;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 队列是否为空</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 空返回true, 否则返回false</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 队列是否已满</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 满返回true, 否则返回false</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.datastructure;<br><br><span class="hljs-keyword">import</span> java.util.Iterator;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 基于双向环形链表实现的双端队列</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * 注：双向和双端是两个概念，</span><br><span class="hljs-comment"> * 双向是指链表节点有两个指针，一个指向前一个节点，一个指向后一个节点；</span><br><span class="hljs-comment"> * 双端是指队列两端都可以操作添加和删除。</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * 为什么要用双向链表？</span><br><span class="hljs-comment"> * 因为双端队列需要操作尾端，所以需要尾指针，而单向链表只有头指针，所以需要双向链表。</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * 为什么要用环形链表？</span><br><span class="hljs-comment"> * 因为环形链表可以用一个哨兵，即充当头指针又充当尾指针，这样就可以省去一个指针。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedListDeque</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Deque</span>&lt;E&gt;, Iterable&lt;E&gt; &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;E&gt; &#123;<br>        Node&lt;E&gt; prev;<br>        E value;<br>        Node&lt;E&gt; next;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(Node&lt;E&gt; prev, E value, Node&lt;E&gt; next)</span> &#123;<br>            <span class="hljs-built_in">this</span>.prev = prev;<br>            <span class="hljs-built_in">this</span>.value = value;<br>            <span class="hljs-built_in">this</span>.next = next;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">capacity</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>    <span class="hljs-type">int</span> size;<br>    Node&lt;E&gt; sentinel = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<span class="hljs-comment">//哨兵</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedListDeque</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>        <span class="hljs-comment">//初始化哨兵</span><br>        sentinel.prev = sentinel;<br>        sentinel.next = sentinel;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * a added b</span><br><span class="hljs-comment">     * 向头部添加</span><br><span class="hljs-comment">     * a就是哨兵，b就是哨兵的next</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offerFirst</span><span class="hljs-params">(E e)</span> &#123;<br>        <span class="hljs-keyword">if</span> (isFull()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        Node&lt;E&gt; a = sentinel;<br>        Node&lt;E&gt; b = sentinel.next;<br>        Node&lt;E&gt; added = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(a, e, b);<br>        a.next = added;<br>        b.prev = added;<br>        size++;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * a added b</span><br><span class="hljs-comment">     * 向尾部添加</span><br><span class="hljs-comment">     * b就是哨兵，a就是哨兵的prev</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offerLast</span><span class="hljs-params">(E e)</span> &#123;<br>        <span class="hljs-keyword">if</span> (isFull()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        Node&lt;E&gt; a = sentinel.prev;<br>        Node&lt;E&gt; b = sentinel;<br>        Node&lt;E&gt; added = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(a, e, b);<br>        a.next = added;<br>        b.prev = added;<br>        size++;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * a removed b</span><br><span class="hljs-comment">     * 移除头部</span><br><span class="hljs-comment">     * a就是哨兵，b就是哨兵的next</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">pollFirst</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        Node&lt;E&gt; a = sentinel;<br>        Node&lt;E&gt; removed = sentinel.next;<br>        Node&lt;E&gt; b = removed.next;<br>        a.next = b;<br>        b.prev = a;<br>        size--;<br>        <span class="hljs-keyword">return</span> removed.value;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * a removed b</span><br><span class="hljs-comment">     * 移除尾部</span><br><span class="hljs-comment">     * b就是哨兵，a就是哨兵的prev</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">pollLast</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        Node&lt;E&gt; b = sentinel;<br>        Node&lt;E&gt; removed = sentinel.prev;<br>        Node&lt;E&gt; a = removed.prev;<br>        a.next = b;<br>        b.prev = a;<br>        size--;<br>        <span class="hljs-keyword">return</span> removed.value;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">peekFirst</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> sentinel.next.value;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">peekLast</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> sentinel.prev.value;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> size == <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> size == capacity;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Iterator&lt;E&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt;() &#123;<br>            Node&lt;E&gt; p = sentinel.next;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> p != sentinel;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> E <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-type">E</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> p.value;<br>                p = p.next;<br>                <span class="hljs-keyword">return</span> value;<br>            &#125;<br>        &#125;;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="基于数组实现"><a href="#基于数组实现" class="headerlink" title="基于数组实现"></a>基于数组实现</h3><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309210857074.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.datastructure;<br><br><span class="hljs-keyword">import</span> java.util.Iterator;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 基于循环数组实现的双端队列</span><br><span class="hljs-comment"> * 循环数组动的是头尾指针，不动的是数组元素</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * tail 停下来的位置不存储，会浪费一个位置</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * h - head</span><br><span class="hljs-comment"> * tail - tail</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * h</span><br><span class="hljs-comment"> * t</span><br><span class="hljs-comment"> * 0  1  2  3</span><br><span class="hljs-comment"> * a  b     c</span><br><span class="hljs-comment"> * offerLast(a)     先添加元素 tail++</span><br><span class="hljs-comment"> * offerLast(b)</span><br><span class="hljs-comment"> * offerFirst(c)    先head-- 再添加元素</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * pollFirst()      先取元素 head++</span><br><span class="hljs-comment"> * pollLast()       先tail-- 再取元素</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * head==tail 空</span><br><span class="hljs-comment"> * head~tail == 数组长度-1 满</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayDeque1</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Deque</span>&lt;E&gt;, Iterable&lt;E&gt; &#123;<br><br>    E[] array;<br>    <span class="hljs-type">int</span> head;<br>    <span class="hljs-type">int</span> tail;<br><br>    <span class="hljs-meta">@SuppressWarnings(&quot;all&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayDeque1</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        array = (E[]) <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[capacity + <span class="hljs-number">1</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">inc</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> length)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &gt;= length)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dec</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> length)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i - <span class="hljs-number">1</span> &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> i - <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offerFirst</span><span class="hljs-params">(E e)</span> &#123;<br>        <span class="hljs-keyword">if</span> (isFull()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        head = dec(head, array.length);<br>        array[head] = e;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offerLast</span><span class="hljs-params">(E e)</span> &#123;<br>        <span class="hljs-keyword">if</span> (isFull()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        array[tail] = e;<br>        tail = inc(tail, array.length);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">pollFirst</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">E</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> array[head];<br>        array[head] = <span class="hljs-literal">null</span>;<span class="hljs-comment">//help gc</span><br>        head = inc(head, array.length);<br>        <span class="hljs-keyword">return</span> e;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">pollLast</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        tail = dec(tail, array.length);<br>        <span class="hljs-type">E</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> array[tail];<br>        array[tail] = <span class="hljs-literal">null</span>;<span class="hljs-comment">//help gc</span><br>        <span class="hljs-keyword">return</span> e;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">peekFirst</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> array[head];<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">peekLast</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> array[dec(tail, array.length)];<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> head == tail;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (tail &gt; head) &#123;<br>            <span class="hljs-keyword">return</span> tail - head == array.length - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tail &lt; head) &#123;<br>            <span class="hljs-keyword">return</span> head - tail == <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Iterator&lt;E&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt;() &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> head;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> p != tail;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> E <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-type">E</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> array[p];<br>                p = inc(p, array.length);<br>                <span class="hljs-keyword">return</span> e;<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h2><p class="note note-primary">优先级队列特点：一端进，另一端出，但出的时候按照优先级出！</p><h3 id="基于无序数组实现"><a href="#基于无序数组实现" class="headerlink" title="基于无序数组实现"></a>基于无序数组实现</h3><p class="note note-success">无序数组实现的优势：<br>入队就直接加入对尾。<br>出队就遍历找到最大值，并删除，然后把后续的往前顺延。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> priorityqueue;  <br>  <br><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * 队列接口</span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Queue</span>&lt;E&gt; &#123;  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 向队列尾部添加一个元素  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> val 待插入值  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 插入成功返回true，否则返回false  </span><br><span class="hljs-comment">     */</span>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E val)</span>;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 从队列头部取出一个元素，并移除  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 如果队列非空，返回队列头部元素，否则返回null  </span><br><span class="hljs-comment">     */</span>    E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span>;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 从队列头部取出一个元素，但不移除  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 如果队列非空，返回队列头部元素，否则返回null  </span><br><span class="hljs-comment">     */</span>    E <span class="hljs-title function_">peek</span><span class="hljs-params">()</span>;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 判断队列是否为空  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 空返回true，否则返回false  </span><br><span class="hljs-comment">     */</span>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span>;  <br>  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 判断队列是否已满  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 已满返回true，否则返回false  </span><br><span class="hljs-comment">     */</span>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> priorityqueue;  <br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 优先级接口</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Priority</span> &#123;  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 返回对象的优先级，约定数字越大，优先级越高  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-type">int</span> <span class="hljs-title function_">priority</span><span class="hljs-params">()</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> priorityqueue;  <br>  <br><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * 基于无序数组实现  </span><br><span class="hljs-comment"> * 入队：把元素加到数组末尾  </span><br><span class="hljs-comment"> * 出队：找到最大优先级元素，删除，相当于进行了一次选择排序  </span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PriorityQueue</span>&lt;E <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Priority</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Queue</span>&lt;E&gt; &#123;  <br>  <br>    Priority[] array;  <br>    <span class="hljs-type">int</span> size;  <br>  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PriorityQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;  <br>        array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Priority</span>[capacity];  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//O(1)  </span><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e)</span> &#123;  <br>        <span class="hljs-keyword">if</span> (isFull()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>        array[size++] = e;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//返回优先级最高的索引值  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">selectMax</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;  <br>            <span class="hljs-keyword">if</span> (array[i].priority() &gt; array[max].priority()) &#123;  <br>                max = i;  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> max;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;  <br>        <span class="hljs-keyword">if</span> (index &lt; size - <span class="hljs-number">1</span>) &#123;  <br>            <span class="hljs-comment">//移动  </span><br>            System.arraycopy(array, index + <span class="hljs-number">1</span>, array, index, size - <span class="hljs-number">1</span> - index);  <br>        &#125;  <br>        array[--size]=<span class="hljs-literal">null</span>;<span class="hljs-comment">//help GC </span><br>    &#125;  <br>  <br>    <span class="hljs-comment">//O(n)  </span><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">if</span> (isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> selectMax();  <br>        <span class="hljs-type">E</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> (E) array[max];  <br>        remove(max);  <br>        <span class="hljs-keyword">return</span> e;  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">if</span> (isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> selectMax();  <br>        <span class="hljs-keyword">return</span> (E) array[max];  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> size == <span class="hljs-number">0</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> size == array.length;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="基于有序数组实现"><a href="#基于有序数组实现" class="headerlink" title="基于有序数组实现"></a>基于有序数组实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> priorityqueue;  <br>  <br><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * 基于有序数组实现  </span><br><span class="hljs-comment"> * 优先级最高的在队尾，优点是出队操作变的简单，直接size--就行。  </span><br><span class="hljs-comment"> * 缺点是，入队操作需要做一次排序，插入到正确位置。相当于一次插入排序。  </span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PriorityQueue2</span>&lt;E <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Priority</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Queue</span>&lt;E&gt; &#123;  <br>  <br>    Priority[] array;  <br>    <span class="hljs-type">int</span> size;  <br>  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PriorityQueue2</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;  <br>        array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Priority</span>[capacity];  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//O(n)  </span><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e)</span> &#123;  <br>        <span class="hljs-keyword">if</span> (isFull()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br><span class="hljs-comment">//        array[size++] = e;  </span><br>        insert(e);  <br>        size++;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 插入排序  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(E e)</span> &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> size - <span class="hljs-number">1</span>;  <br>        <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; array[i].priority() &gt; e.priority()) &#123;  <br>            array[i + <span class="hljs-number">1</span>] = array[i];  <br>            i--;  <br>        &#125;  <br>        array[i + <span class="hljs-number">1</span>] = e;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//O(1)  </span><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">if</span> (isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br><span class="hljs-comment">//        int max = selectMax();  </span><br><span class="hljs-comment">//        E e = (E) array[max];  </span><br><span class="hljs-comment">//        remove(max);  </span><br>        <span class="hljs-type">E</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> (E) array[size - <span class="hljs-number">1</span>];  <br>        array[--size] = <span class="hljs-literal">null</span>;<span class="hljs-comment">//help GC  </span><br>        <span class="hljs-keyword">return</span> e;  <br>    &#125;  <br><span class="hljs-comment">//O(1)  </span><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">if</span> (isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br><span class="hljs-comment">//        int max = selectMax();  </span><br><span class="hljs-comment">//        return (E) array[max];  </span><br>        <span class="hljs-keyword">return</span> (E) array[size - <span class="hljs-number">1</span>];  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> size == <span class="hljs-number">0</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> size == array.length;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-primary">基于无序和基于有序数组实现俩种的差别在于：<br>无序：入队O(1)，出队O(n)<br>有序：入队O(n)，出队O(1)<br><br>BUT，这俩种都不是最优的实现方式，接下来看看更优解。</p><h3 id="基于堆实现"><a href="#基于堆实现" class="headerlink" title="基于堆实现"></a>基于堆实现</h3><blockquote><p>堆是一种基于树的数据结构，通常用完全二叉树实现。堆的特性如下：</p><ul><li>在大顶堆中，任意节点C与它的父节点P符合P.value &gt;&#x3D; C.value。</li><li>在小顶堆中，任意节点C与它的父节点P符合P.vlaue &lt;&#x3D; C.value。</li><li>最顶层节点(没有父亲)称之为root根节点。</li></ul></blockquote><blockquote><p>二叉树，简单理解就是一个节点最多有俩个子节点。</p></blockquote><blockquote><p>完全二叉树，就是说树的每一层除了最后一层都是填满的（都是俩个子节点）。<br>另外，向完全二叉树加入节点时，必须从左开始添加。</p></blockquote><p class="note note-info">它是非线性的数据结构，但是存储的时候可以使用线性的数组结构存储。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309210937016.png"></p><p class="note note-primary">这种数据结构具备一些特征，前辈总结了一些规律公式，可以在已知父节点的时候快速找到子节点，或者已知子节点的时候快速找到父节点。<br>堆存在数组中有俩种方式，一种是从索引0直接存根，另一种是索引0空着从1开始存根节点。<br>- 如果从索引0开始存储节点数据<br>    1. 节点 i 的父节点为 (i-1)/2，当i>0时。<br>    2. 节点 i 的左子节点为 2i+1 ，右子节点为 2i+2，当然它们得小于size。<br>- 如果从索引1开始存储节点数据<br>    1. 节点i的父节点为 i/2 ，当 i>1 时。<br>    2. 节点 i 的左子节点为 2i ，右子节点为 2i+1 ，同样得小于size。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309210948549.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> priorityqueue;  <br>  <br><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * 基于大顶堆实现  </span><br><span class="hljs-comment"> * &lt;p&gt;  </span><br><span class="hljs-comment"> * 入队  </span><br><span class="hljs-comment"> * 1.入堆新元素，加入到数组末尾  </span><br><span class="hljs-comment"> * 2.不断比较新元素与它父节点优先级  </span><br><span class="hljs-comment"> * （上浮）  </span><br><span class="hljs-comment"> * - 如果父节点优先级低，则向下移动，并找到下一个parent  </span><br><span class="hljs-comment"> * - 直至父节点优先级更高或child==0为止。  </span><br><span class="hljs-comment"> * &lt;p&gt;  </span><br><span class="hljs-comment"> * 出队  </span><br><span class="hljs-comment"> * 1.交换堆顶和尾部元素，让尾部出队  </span><br><span class="hljs-comment"> * 2.（下潜）  </span><br><span class="hljs-comment"> * - 从堆顶开始，将父元素与俩个孩子较大者交换  </span><br><span class="hljs-comment"> * - 直到父元素大于俩个孩子，或者没有孩子为止。  </span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PriorityQueue3</span>&lt;E <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Priority</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Queue</span>&lt;E&gt; &#123;  <br>  <br>    Priority[] array;  <br>    <span class="hljs-type">int</span> size;  <br>  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PriorityQueue3</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;  <br>        array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Priority</span>[capacity];  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//O(logn)  </span><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E offered)</span> &#123;  <br>        <span class="hljs-keyword">if</span> (isFull()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">child</span> <span class="hljs-operator">=</span> size++;<span class="hljs-comment">//确定索引，先不同填充值，可能要调整堆  </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> (child - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<span class="hljs-comment">//找到父节点  </span><br>        <span class="hljs-keyword">while</span> (child &gt; <span class="hljs-number">0</span> &amp;&amp; offered.priority() &gt; array[parent].priority()) &#123;  <br>            array[child] = array[parent];<span class="hljs-comment">//下移  </span><br>            child = parent;  <br>            parent = (child - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;  <br>        &#125;  <br>        <span class="hljs-comment">//循环结束找到目标待插入节点  </span><br>        array[child] = offered;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 交换  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;  <br>        <span class="hljs-type">Priority</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> array[i];  <br>        array[i] = array[j];  <br>        array[j] = t;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * O(logn)     * 下潜  </span><br><span class="hljs-comment">     * 因为可以通过公式，已知父节点可以得到子节点，所以参数一个即可  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">down</span><span class="hljs-params">(<span class="hljs-type">int</span> parent)</span> &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> * parent + <span class="hljs-number">1</span>;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> left + <span class="hljs-number">1</span>;<span class="hljs-comment">//等价于 2*parent+2  </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> parent;<span class="hljs-comment">//假设父元素优先级更高  </span><br>        <span class="hljs-keyword">if</span> (left &lt; size &amp;&amp; array[left].priority() &gt; array[max].priority()) &#123;<span class="hljs-comment">//left&lt;size因为通过公式得到的不一定存在  </span><br>            max = left;  <br>        &#125;  <br>        <span class="hljs-keyword">if</span> (right &lt; size &amp;&amp; array[right].priority() &gt; array[max].priority()) &#123;  <br>            max = right;  <br>        &#125;  <br>        <span class="hljs-keyword">if</span> (max != parent) &#123;  <br>            <span class="hljs-comment">//说明被更新了  </span><br>            swap(max, parent);  <br>            <span class="hljs-comment">//递归调用  </span><br>            down(max);  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">if</span> (isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>        swap(<span class="hljs-number">0</span>, size - <span class="hljs-number">1</span>);<span class="hljs-comment">//交换堆顶和尾元素  </span><br>        size--;<span class="hljs-comment">//移除数组尾部元素,就是把size减1即可  </span><br>        <span class="hljs-type">Priority</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> array[size];  <br>        array[size] = <span class="hljs-literal">null</span>;<span class="hljs-comment">//help GC  </span><br>        <span class="hljs-comment">//下潜  </span><br>        down(<span class="hljs-number">0</span>);  <br>        <span class="hljs-keyword">return</span> (E) e;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//O(1)  </span><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">if</span> (isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>        <span class="hljs-keyword">return</span> (E) array[<span class="hljs-number">0</span>];  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> size == <span class="hljs-number">0</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> size == array.length;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-primary">三种实现区别<br>无序：入队O(1)，出队O(n)<br>有序：入队O(n)，出队O(1)<br>堆：入队O(logn)，出队O(logn)  推荐<br></p><h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><blockquote><p>目前队列存在的问题<br>1.很多场景要求分离生产者、消费者俩个角色，它们由不同的线程来担当，而之前的实现并没有考虑线程安全问题。<br>2.队列为空，那么在之前的实现里会返回null，如果就是硬要拿到一个元素呢？只能不能循环尝试。<br>3.队列为满，那么在之前的实现里会返回false，如果就是硬要塞入一个元素呢？只能不断循环尝试。</p></blockquote><h3 id="单锁实现"><a href="#单锁实现" class="headerlink" title="单锁实现"></a>单锁实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> blockqueue;  <br>  <br><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * 目前队列存在的问题  </span><br><span class="hljs-comment"> * &gt; 1.很多场景要求分离生产者、消费者俩个角色，它们由不同的线程来担当，而之前的实现并没有考虑线程安全问题。  </span><br><span class="hljs-comment"> * &gt; 2.队列为空，那么在之前的实现里会返回null，如果就是硬要拿到一个元素呢？只能不能循环尝试。  </span><br><span class="hljs-comment"> * &gt; 3.队列为满，那么在之前的实现里会返回false，如果就是硬要塞入一个元素呢？只能不断循环尝试。  </span><br><span class="hljs-comment"> * &lt;p&gt;  </span><br><span class="hljs-comment"> * 解决方法：  </span><br><span class="hljs-comment"> * 1.用锁保证线程安全  </span><br><span class="hljs-comment"> * 2.用条件变量让poll或offer线程进入等待状态  </span><br><span class="hljs-comment"> */</span>  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BlockQueue</span>&lt;E&gt; &#123;<span class="hljs-comment">//阻塞队列  </span><br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 入队不再需要返回值，因为会进入阻塞状态  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e)</span> <span class="hljs-keyword">throws</span> InterruptedException;  <br>  <br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e, <span class="hljs-type">long</span> timeout)</span> <span class="hljs-keyword">throws</span> InterruptedException;  <br>  <br>    E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException;  <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> blockqueue;  <br>  <br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;  <br><span class="hljs-keyword">import</span> java.util.concurrent.locks.Condition;  <br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;  <br>  <br><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * 单锁实现  </span><br><span class="hljs-comment"> *  </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &lt;E&gt;  </span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlockQueue1</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BlockQueue</span>&lt;E&gt; &#123;  <br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> E[] array;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> head;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> tail;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;  <br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">headWaits</span> <span class="hljs-operator">=</span> lock.newCondition();<span class="hljs-comment">//配合poll方法使用 因为队列先入先出，出队的时候就用head表示  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">tailWaits</span> <span class="hljs-operator">=</span> lock.newCondition();<span class="hljs-comment">//配合offer方法使用 入队  </span><br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> size == <span class="hljs-number">0</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> size == array.length;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BlockQueue1</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;  <br>        array = (E[]) <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[capacity];  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>        lock.lockInterruptibly();  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            <span class="hljs-keyword">while</span> (isFull()) &#123;  <br>                <span class="hljs-comment">//不能用if，防止虚假唤醒  </span><br>                tailWaits.await();<span class="hljs-comment">//进入阻塞状态  </span><br>            &#125;  <br>            <span class="hljs-comment">//不满，可以添加  </span><br>            array[tail] = e;  <br>            <span class="hljs-keyword">if</span> (++tail == array.length) &#123;  <br>                tail = <span class="hljs-number">0</span>;  <br>            &#125;  <br>            size++;  <br>            <span class="hljs-comment">//此时，poll可能在等待队列非空要取数据，所以要去唤醒  </span><br>            headWaits.signal();  <br>        &#125; <span class="hljs-keyword">finally</span> &#123;  <br>            lock.unlock();  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 可以设置等待时间，上面的offer会一直等  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e, <span class="hljs-type">long</span> timeout)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>        lock.lockInterruptibly();  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            <span class="hljs-type">long</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> TimeUnit.MILLISECONDS.toNanos(timeout);<span class="hljs-comment">//传过来毫秒转换一下  </span><br>            <span class="hljs-keyword">while</span> (isFull()) &#123;  <br>                <span class="hljs-keyword">if</span> (t &lt;= <span class="hljs-number">0</span>) &#123;  <br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>                &#125;  <br>                t = tailWaits.awaitNanos(t);<span class="hljs-comment">//最多等待多少纳秒 1s 4s 返回值代表剩余时间  </span><br>            &#125;  <br>            <span class="hljs-comment">//不满，可以添加  </span><br>            array[tail] = e;  <br>            <span class="hljs-keyword">if</span> (++tail == array.length) &#123;  <br>                tail = <span class="hljs-number">0</span>;  <br>            &#125;  <br>            size++;  <br>            <span class="hljs-comment">//此时，poll可能在等待队列非空要取数据，所以要去唤醒  </span><br>            headWaits.signal();  <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>        &#125; <span class="hljs-keyword">finally</span> &#123;  <br>            lock.unlock();  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>        lock.lockInterruptibly();  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            <span class="hljs-keyword">while</span> (isEmpty()) &#123;  <br>                headWaits.await();  <br>            &#125;  <br>            <span class="hljs-type">E</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> array[head];  <br>            array[head] = <span class="hljs-literal">null</span>;<span class="hljs-comment">//help GC  </span><br>            <span class="hljs-keyword">if</span> (++head == array.length) &#123;  <br>                head = <span class="hljs-number">0</span>;  <br>            &#125;  <br>            size--;  <br>            <span class="hljs-comment">//此时，offer可能在等待队列不满要取数据，所以要去唤醒  </span><br>            tailWaits.signal();  <br>            <span class="hljs-keyword">return</span> e;  <br>        &#125; <span class="hljs-keyword">finally</span> &#123;  <br>            lock.unlock();  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="双锁实现"><a href="#双锁实现" class="headerlink" title="双锁实现"></a>双锁实现</h3><blockquote><p>上面单锁实现加锁是为了多线程下产生指令交错，结果达不到预期，所以加了一一把锁来实现。<br><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309211132224.png"><br>加锁来保证多行代码的原子性，保证左边执行完，右边再执行。这是为什么加锁。</p><p>但是加锁后，会产生新的问题，offer和poll都需要加锁，而且用到同一把锁。<br><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309211134026.png"><br>offer和poll线程是互相影响的，offer在加锁状态下，poll加不上锁会处于阻塞状态，得等offer执行完了解锁，poll才能获得锁。读写不能同时进行！这样是不合理的。一个操作头，一个操作尾，按理来讲应该互不干扰。所以可以用双锁来实现。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> blockqueue;  <br>  <br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;  <br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;  <br><span class="hljs-keyword">import</span> java.util.concurrent.locks.Condition;  <br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;  <br>  <br><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * 双锁实现  </span><br><span class="hljs-comment"> *  </span><br><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlockQueue2</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BlockQueue</span>&lt;E&gt; &#123;  <br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> E[] array;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> head;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> tail;  <br>    <span class="hljs-comment">//    private int size;  </span><br>    <span class="hljs-keyword">private</span> AtomicInteger size;  <br>  <br>    <span class="hljs-comment">//    private ReentrantLock lock = new ReentrantLock();  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">tailLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<span class="hljs-comment">//给offer用  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">tailWaits</span> <span class="hljs-operator">=</span> tailLock.newCondition();  <br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">headLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<span class="hljs-comment">//给poll方法用  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">headWaits</span> <span class="hljs-operator">=</span> headLock.newCondition();  <br>  <br><span class="hljs-comment">//    private Condition headWaits = lock.newCondition();//配合poll方法使用 因为队列先入先出，出队的时候就用head表示  </span><br><span class="hljs-comment">//    private Condition tailWaits = lock.newCondition();//配合offer方法使用 入队  </span><br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> size.get() == <span class="hljs-number">0</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> size.get() == array.length;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BlockQueue2</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;  <br>        array = (E[]) <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[capacity];  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>        <span class="hljs-type">int</span> c;<span class="hljs-comment">//添加前元素个数 c=0的时候进行加锁和唤醒操作  </span><br>        tailLock.lockInterruptibly();  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            <span class="hljs-keyword">while</span> (isFull()) &#123;  <br>                <span class="hljs-comment">//不能用if，防止虚假唤醒  </span><br>                tailWaits.await();<span class="hljs-comment">//进入阻塞状态  </span><br>            &#125;  <br>            <span class="hljs-comment">//不满，可以添加  </span><br>            array[tail] = e;  <br>            <span class="hljs-keyword">if</span> (++tail == array.length) &#123;  <br>                tail = <span class="hljs-number">0</span>;  <br>            &#125;  <br>            <span class="hljs-comment">//修改size  </span><br>            <span class="hljs-comment">/*             * 1.读取成员变量size的值  </span><br><span class="hljs-comment">             * 2.自增  </span><br><span class="hljs-comment">             * 3.结果写会成员变量size  </span><br><span class="hljs-comment">             */</span>            c = size.getAndIncrement();<span class="hljs-comment">//size++ 但能保证原子性  </span><br>            <span class="hljs-keyword">if</span> (c + <span class="hljs-number">1</span> &lt; array.length) &#123;  <br>                tailWaits.signal();  <br>            &#125;  <br>  <br>        &#125; <span class="hljs-keyword">finally</span> &#123;  <br>            tailLock.unlock();  <br>        &#125;  <br>        <span class="hljs-keyword">if</span> (c &gt; <span class="hljs-number">0</span>) &#123;  <br>            <span class="hljs-comment">//解决死锁的方法很简单，不要写成嵌套的方式即可  </span><br>            headLock.lock();  <br>            <span class="hljs-keyword">try</span> &#123;  <br>                headWaits.signal();<span class="hljs-comment">//signal和await必须搭配对应的锁  </span><br>            &#125; <span class="hljs-keyword">finally</span> &#123;  <br>                headLock.unlock();  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 可以设置等待时间，上面的offer会一直等  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e, <span class="hljs-type">long</span> timeout)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>        <span class="hljs-type">int</span> c;<span class="hljs-comment">//添加前元素个数 c=0的时候进行加锁和唤醒操作  </span><br>        tailLock.lockInterruptibly();  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            <span class="hljs-type">long</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> TimeUnit.MILLISECONDS.toNanos(timeout);<span class="hljs-comment">//传过来毫秒转换一下  </span><br>            <span class="hljs-keyword">while</span> (isFull()) &#123;  <br>                <span class="hljs-keyword">if</span> (t &lt;= <span class="hljs-number">0</span>) &#123;  <br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>                &#125;  <br>                t = tailWaits.awaitNanos(t);<span class="hljs-comment">//最多等待多少纳秒 1s 4s 返回值代表剩余时间  </span><br>            &#125;  <br>            <span class="hljs-comment">//不满，可以添加  </span><br>            array[tail] = e;  <br>            <span class="hljs-keyword">if</span> (++tail == array.length) &#123;  <br>                tail = <span class="hljs-number">0</span>;  <br>            &#125;  <br>            <span class="hljs-comment">//修改size  </span><br>            <span class="hljs-comment">/*             * 1.读取成员变量size的值  </span><br><span class="hljs-comment">             * 2.自增  </span><br><span class="hljs-comment">             * 3.结果写会成员变量size  </span><br><span class="hljs-comment">             */</span><span class="hljs-comment">//            size++;  </span><br>            c = size.getAndIncrement();<span class="hljs-comment">//size++ 但能保证原子性  </span><br>            <span class="hljs-comment">//此时，poll可能在等待队列非空要取数据，所以要去唤醒  </span><br><span class="hljs-comment">//            headWaits.signal();  </span><br>            <span class="hljs-keyword">if</span> (c + <span class="hljs-number">1</span> &lt; array.length) &#123;<span class="hljs-comment">//如果不是从满到不满，自己唤醒剩余的  </span><br>                tailWaits.signal();  <br>            &#125;  <br>  <br>        &#125; <span class="hljs-keyword">finally</span> &#123;  <br>            tailLock.unlock();  <br>        &#125;  <br>  <br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;  <br>            <span class="hljs-comment">//唤醒等待的poll线程  </span><br>            headLock.lock();<span class="hljs-comment">// offer_3 offer_3  </span><br>            <span class="hljs-keyword">try</span> &#123;  <br>                headWaits.signal();<span class="hljs-comment">// offer_1 让offer_1唤醒一次，offer_2和3不做唤醒操作，让poll自己内部唤醒，减少锁的使用  </span><br>            &#125; <span class="hljs-keyword">finally</span> &#123;  <br>                headLock.unlock();  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>        E e;  <br>        <span class="hljs-type">int</span> c;<span class="hljs-comment">//取走前的元素个数  </span><br>        headLock.lockInterruptibly();  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            <span class="hljs-keyword">while</span> (isEmpty()) &#123;  <br>                headWaits.await();<span class="hljs-comment">// poll_1 poll_2 poll_3  .   poll_1被唤醒后，自己唤醒poll2和3，这种思想叫做级联通知。  </span><br>            &#125;  <br>            e = array[head];  <br>            array[head] = <span class="hljs-literal">null</span>;<span class="hljs-comment">//help GC  </span><br>            <span class="hljs-keyword">if</span> (++head == array.length) &#123;  <br>                head = <span class="hljs-number">0</span>;  <br>            &#125;  <br>            <span class="hljs-comment">//修改size  </span><br>            <span class="hljs-comment">/*             * 1.读取成员变量size的值  </span><br><span class="hljs-comment">             * 2.自增  </span><br><span class="hljs-comment">             * 3.结果写会成员变量size  </span><br><span class="hljs-comment">             */</span><span class="hljs-comment">//            size--;  </span><br>            c = size.getAndDecrement();  <br>            <span class="hljs-keyword">if</span> (c &gt; <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//如果还有剩余元素，级联通知去唤醒剩下的  </span><br>                headWaits.signal();  <br>            &#125;  <br>        &#125; <span class="hljs-keyword">finally</span> &#123;  <br>            headLock.unlock();  <br>        &#125;  <br>        <span class="hljs-comment">//但是这样写，可能会产生死锁！！offer和poll中tailLock和headLock交叉引用了！  </span><br>        <span class="hljs-comment">//所以要改成平级的，不要嵌套的。  </span><br>        <span class="hljs-comment">//唤醒等待的offer线程  </span><br>        <span class="hljs-keyword">if</span> (c == array.length) &#123;<span class="hljs-comment">//从队列满到不满时，由poll唤醒等待不满offer线程  </span><br>            tailLock.lock();  <br>            <span class="hljs-keyword">try</span> &#123;  <br>                tailWaits.signal();<span class="hljs-comment">//signal和await必须搭配对应的锁  </span><br>            &#125; <span class="hljs-keyword">finally</span> &#123;  <br>                tailLock.unlock();  <br>            &#125;  <br>        &#125;  <br>  <br>        <span class="hljs-keyword">return</span> e;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-primary">其实这也是阻塞队列的源码，我们自己实现之后，就会更加清晰。双锁实现的阻塞队列的设计思想是值得反复去斟酌学习的。</p>]]></content>
    
    
    <categories>
      
      <category>data&amp;algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>队列</tag>
      
      <tag>双端队列</tag>
      
      <tag>优先级队列</tag>
      
      <tag>阻塞队列</tag>
      
      <tag>级联通知</tag>
      
      <tag>可重入锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构和算法之旅（三）- 递归</title>
    <link href="/posts/1bf3c967/"/>
    <url>/posts/1bf3c967/</url>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p class="note note-primary">在计算机科学中，递归是一种解决计算问题的方法，其中解决方案取决于同一类问题的更小子集。<br>比如，单链表递归遍历的例子。<br>void f(Node node){<br>&nbsp;&nbsp;f(node.next);<br>}<br>说明：<br>1.自己调用自己，如果每个函数对应着一种解决方案，自己调用自己意味着解决方案是一样的（有规律的）<br>2.每次调用，函数处理的数据会比上次缩减（子集），而且最后会缩减至无需继续递归。<br>3.内存函数调用（子集处理）完成，外层函数才能算调用完成！</p><h2 id="单链表递归分析"><a href="#单链表递归分析" class="headerlink" title="单链表递归分析"></a>单链表递归分析</h2><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309201838927.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309201839255.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309201839734.png"></p><h2 id="递归思路"><a href="#递归思路" class="headerlink" title="递归思路"></a>递归思路</h2><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309201840039.png"></p><p class="note note-primary">深入到最里面叫做递。<br>从最里面出来叫做归。<br>在递的过程中，外层函数的局部变量以及方法参数并未消失，归的时候还可以使用。</p><h2 id="阶乘"><a href="#阶乘" class="headerlink" title="阶乘"></a>阶乘</h2><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309201841987.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br><span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> n * f(n-<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-secondary">伪代码，分析执行流程如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">f(<span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">3</span> * f(<span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * f(<span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>)&#123;<br><span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="反向打印字符串"><a href="#反向打印字符串" class="headerlink" title="反向打印字符串"></a>反向打印字符串</h2><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309201844478.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309201845599.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">因为递的时候是正序的，归的时候逆序的，所以把递归调用放在前面，打印放在后面，即可实现</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReversePrintString</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span> n, String str)</span>&#123;<br><span class="hljs-keyword">if</span>(n == str.length()) <span class="hljs-keyword">return</span>;<br>f(n + <span class="hljs-number">1</span>, str);<span class="hljs-comment">//递</span><br>System.out.println(str.charAt(n));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309201848656.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">递归实现二分查找</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RecursionBinarySearch</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br><span class="hljs-type">int</span>[] a = &#123;<span class="hljs-number">7</span>,<span class="hljs-number">13</span>,<span class="hljs-number">21</span>,<span class="hljs-number">30</span>,<span class="hljs-number">38</span>,<span class="hljs-number">44</span>,<span class="hljs-number">52</span>,<span class="hljs-number">53</span>&#125;;<br>System.out.println(search(a, <span class="hljs-number">7</span>)); <span class="hljs-comment">//0</span><br>System.out.println(search(a, <span class="hljs-number">13</span>));<span class="hljs-comment">//1</span><br>System.out.println(search(a, <span class="hljs-number">21</span>));<span class="hljs-comment">//2</span><br>System.out.println(search(a, <span class="hljs-number">53</span>));<span class="hljs-comment">//7</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> target)</span>&#123;<br><span class="hljs-comment">//让调用者少传参数, 隐藏具体实现</span><br><span class="hljs-keyword">return</span> f(a, target, <span class="hljs-number">0</span>, a.length - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* left和right不对外暴露，让调用者使用更简单</span><br><span class="hljs-comment">* 返回目标索引</span><br><span class="hljs-comment">* 找不到返回-1</span><br><span class="hljs-comment">*/</span><br>priavte <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span>&#123;<br><span class="hljs-keyword">if</span>(left &gt; right) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">//递归终止条件</span><br><span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> (left + right) &gt;&gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(target &lt; a[m])&#123;<br><span class="hljs-keyword">return</span> f(a, target, left, m - <span class="hljs-number">1</span>);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[m] &lt; target)&#123;<br><span class="hljs-keyword">return</span> f(a, targetm m + <span class="hljs-number">1</span>, right);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">return</span> m;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="冒泡排序0-n-2"><a href="#冒泡排序0-n-2" class="headerlink" title="冒泡排序0(n^2)"></a>冒泡排序0(n^2)</h2><p>以下是冒泡排序的实现原理步骤：</p><ol><li>从列表的第一个元素开始，比较它与下一个元素的大小。</li><li>如果第一个元素大于第二个元素（逆序），则交换它们的位置。</li><li>移动到下一个元素，重复步骤1和步骤2，直到列表的末尾。</li><li>重复上述步骤，每次内部循环将最大的元素 “冒泡” 到列表的最后一个位置。</li><li>外部循环减小待排序元素的范围，直到没有需要交换的元素为止，表示排序完成。</li></ol><p>冒泡排序的特点是每一轮内部循环都将当前未排序部分中的最大元素移动到了最后。这意味着在每一轮后，最后的元素都会是当前未排序部分的最大值。排序过程中，如果一轮内部循环没有发生任何交换，就可以提前结束排序，因为列表已经是有序的。</p><p class="note note-info">用递归实现冒泡过程分析：<br>1.将数组划分成俩部分 [0..j]，[j+1 .. a.length-1]。<br>2.左边[0..j] 是未排序的部分。<br>3.右边[j+1 .. a.length-1]是已排序部分。<br>4.未排序区间内，相邻俩个元素比较，如果前一个大，则交换位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BubbleSort</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a)</span>&#123;<br>bubble(a, a.length-<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">//j 代表未排序区域的右边界</span><br><span class="hljs-comment">//bubble内部首先是递归结束条件，然后for循环是一次冒泡，然后调用自身</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bubble</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> j)</span>&#123;<br><span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; j; i++)&#123;<br><span class="hljs-keyword">if</span>(a[i] &gt; a[i+<span class="hljs-number">1</span>])&#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> a[i];<br>a[i] = a[i+<span class="hljs-number">1</span>];<br>a[i+<span class="hljs-number">1</span>] = t;<br>&#125;<br>&#125;<br>bubble(a, j-<span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309201908139.png"></p><blockquote><p>这种情况下，未排序区域还很大，但是只需要在冒泡一次，把2和1交换就达到目的了，但是未排序边界 j 还没有到 0 ，会做很多无用功。尝试优化一下。</p></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309201910581.png"></p><blockquote><p>可以搞一个 x ，初始为0，如果当次产生交换，就让所以 i 的索引赋给 x，如果没有产生交换，x 就保持上一次的不变，那么 x 就能当做无序和有序的边界了，下次递归就不用 j 去递减了。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BubbleSort</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a)</span>&#123;<br>bubble(a, a.length-<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">//j 代表未排序区域的右边界</span><br><span class="hljs-comment">//bubble内部首先是递归结束条件，然后for循环是一次冒泡，然后调用自身</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bubble</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> j)</span>&#123;<br><span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; j; i++)&#123;<br><span class="hljs-keyword">if</span>(a[i] &gt; a[i+<span class="hljs-number">1</span>])&#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> a[i];<br>a[i] = a[i+<span class="hljs-number">1</span>];<br>a[i+<span class="hljs-number">1</span>] = t;<br>x = i;<br>&#125;<br>&#125;<br>bubble(a, x);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="插入排序O-n-2"><a href="#插入排序O-n-2" class="headerlink" title="插入排序O(n^2)"></a>插入排序O(n^2)</h2><p>它的工作方式优点像整理一手扑克牌，以下是插入排序的实现原理步骤：</p><ol><li>从第二个元素开始（索引为1），将当前元素视为待插入的元素。</li><li>将待插入的元素与已排序部分的元素逐个比较，直到找到一个比待插入元素小的元素，或者已经遍历完已排序部分。</li><li>将待插入元素插入到找到的位置，使得已排序部分仍然保持有序。</li><li>重复上述步骤，逐个处理未排序部分的元素，直到整个列表都有序。</li></ol><p>插入排序的特点是在每一轮内部循环中，将当前未排序元素插入到已排序部分的合适位置，逐步扩展已排序部分。这使得已排序部分始终保持有序。插入排序适用于小型数据集或基本有序的数据集，因为它的时间复杂度为 O(n^2)，在大型数据集上性能较差。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a)</span>&#123;<br>insertion(a, <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">用递归实现</span><br><span class="hljs-comment">low是未排序的左边界，从1开始</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertion</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> low)</span>&#123;<br><span class="hljs-keyword">if</span>(low == a.length)&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> a[low];<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> low - <span class="hljs-number">1</span>;<span class="hljs-comment">//已排序区域指针</span><br><span class="hljs-keyword">while</span>(i&gt;=<span class="hljs-number">0</span> &amp;&amp; a[i]&gt;t)&#123;<span class="hljs-comment">//没有找到插入位置</span><br>a[i+<span class="hljs-number">1</span>] = a[i];<span class="hljs-comment">//空出插入位置</span><br>i--;<br>&#125;<br><span class="hljs-comment">//找到插入位置</span><br>a[i+<span class="hljs-number">1</span>] = t;<br><br>insertion(a, low+<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="斐波那契数列-多路递归"><a href="#斐波那契数列-多路递归" class="headerlink" title="斐波那契数列(多路递归)"></a>斐波那契数列(多路递归)</h2><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309201931055.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Fibonacci</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br><span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> f(n - <span class="hljs-number">1</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> f(n - <span class="hljs-number">2</span>)；<br><span class="hljs-keyword">return</span> x + y;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-danger">斐波那契是多路递归的典型案例，整个计算过程相当于二叉树了，其中很多重复的步骤，造成时间复杂度很差。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309201934609.png"></p><p class="note note-success">可以看出，上面计算过程有很多重复，可以定义一个数组，存储 f(n) 的解，将来计算到哪一项的时候，如果数组有就直接从数组取，可以大大优化；<br>这种方式称为记忆法，也称为备忘录，其实就是剪枝的过程。<br>改进之后时间复杂度从O(1.68n)优化为O(n)。但因额外产生数组，这就是空间换时间。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309201936305.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fbonacci</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br><span class="hljs-type">int</span>[] cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>Arrays.fill(cache, -<span class="hljs-number">1</span>);<span class="hljs-comment">//都填充-1</span><br>cache[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>cache[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> f(n, cache);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[] cache)</span>&#123;<br><span class="hljs-keyword">if</span>(cache[n] != -<span class="hljs-number">1</span>)&#123;<br><span class="hljs-keyword">return</span> cache[n];<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> f(n-<span class="hljs-number">1</span>, cache);<br><span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> f(n-<span class="hljs-number">2</span>, cache);<br>cache[n] = x + y;<span class="hljs-comment">//存入数组</span><br><span class="hljs-keyword">return</span> cache[n];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="递归求和"><a href="#递归求和" class="headerlink" title="递归求和"></a>递归求和</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sum</span>&#123;<br><span class="hljs-comment">//f(n) = f(n-1) + n;</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">long</span> n)</span>&#123;<br><span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> sum(n-<span class="hljs-number">1</span>) + n;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309201948253.png"></p><p class="note note-danger">递归求和，属于单路递归，很容易就想到了思路，为什么贴上这个呢。可以把n等于15000试一下，就很发现为什么了。因为栈内存溢出了！也就是爆栈了！<br>只有最内层的sum(n = 1)的函数执行完了，才能一层一层往外归。也就是说递的过程必须递到最深处才能归！！！每个方法调用是需要消耗内存的，需要存储方法的相关信息，比如说方法的参数信息，方法内的局部变量，方法的返回地址，这些信息都需要存放在栈内存中，在最内层n = 1没有结束之前，前面14999个方法都需要等着！！它们占用的内存也不能得到释放。所以会导致占内存溢出。</p><h3 id="尾调用-amp-尾递归"><a href="#尾调用-amp-尾递归" class="headerlink" title="尾调用&amp;尾递归"></a>尾调用&amp;尾递归</h3><p class="note note-success">在解决爆栈问题之前，需要掌握几个其他知识。<br>尾调用：如果函数的最后一步是调用一个函数，称为尾调用。<br>尾递归：在函数内部最后调用自己，称为尾递归。<br>能对尾递归优化的语言有c++、scala，它们会把逐级递归的方式改成平级的形式。scala也属于java的近亲，也是编译成class类在JVM上运行，有幸了解过一些。<br>当然，从根本上避免爆栈问题，就是避免使用递归。把递归代码改成循环代码。理论上所有递归都能改写成循环代码。</p><p class="note note-secondary">经典白学，哈哈哈哈</p>]]></content>
    
    
    <categories>
      
      <category>data&amp;algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
      <tag>多路递归</tag>
      
      <tag>尾递归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构和算法之旅（二）- 链表</title>
    <link href="/posts/60be154/"/>
    <url>/posts/60be154/</url>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p class="note note-primary">在计算机科学中，链表是数据元素的线性集合，其每个元素都指向下一个元素，元素存储上并不连续。<br>可分类为：<br>- 单向链表：每个元素只知道其下一个元素<br>- 双向链表：每个元素知道其上一个元素和下一个元素<br>- 循环链表：通常的链表尾节点tail指向null，而循环链表的tail指向的头结点head<br><br>链表内还有一种特殊的节点，称为哨兵(Sentinel)节点，也叫做哑元(Dummy)节点，它不存储数据，通常用作头尾，用来简化边界判断。<br></p><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><h3 id="随机访问"><a href="#随机访问" class="headerlink" title="随机访问"></a>随机访问</h3><p>根据index查找，时间复杂度O(n)，因为需要一个节点next、next找到目标。</p><h3 id="插入或删除"><a href="#插入或删除" class="headerlink" title="插入或删除"></a>插入或删除</h3><ul><li>起始位置：O(1)。</li><li>结束位置：如果已知tail节点则是O(1)，不知道tail节点则是O(n)。</li><li>中间位置：根据index查找时间+O(1)。</li></ul><h2 id="单向链表之无哨兵节点"><a href="#单向链表之无哨兵节点" class="headerlink" title="单向链表之无哨兵节点"></a>单向链表之无哨兵节点</h2><p class="note note-light">talk is cheap, show me the code.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.datastructure;<br><br><span class="hljs-keyword">import</span> java.util.Iterator;<br><span class="hljs-keyword">import</span> java.util.function.Consumer;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 单向链表 基础实现 无哨兵节点</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BasicSingleLinkedList</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterable</span> &#123;<span class="hljs-comment">//整体</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Node</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<span class="hljs-comment">//头节点，默认为null</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 内部类关系，对外隐藏实现细节</span><br><span class="hljs-comment">     * 对外部调用者只需要LinkedList即可</span><br><span class="hljs-comment">     * 内部类一半都加上static</span><br><span class="hljs-comment">     * 节点类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<span class="hljs-comment">//节点</span><br>        <span class="hljs-type">int</span> value;<span class="hljs-comment">//值</span><br>        Node next;<span class="hljs-comment">//下一个节点</span><br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> value, Node next)</span> &#123;<br>            <span class="hljs-built_in">this</span>.value = value;<br>            <span class="hljs-built_in">this</span>.next = next;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 向链表头添加元素</span><br><span class="hljs-comment">     * 多理解！！</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addFirst</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-comment">//链表为空</span><br><span class="hljs-comment">//        head = new Node(value, null);</span><br>        <span class="hljs-comment">//链表非空</span><br>        <span class="hljs-comment">//因为head默认为null，所以不需要判断，链表空不空都能能用</span><br>        head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(value, head);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 向列表尾添加元素</span><br><span class="hljs-comment">     * 先找到尾节点，再添加</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addLast</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> findLast();<br>        <span class="hljs-keyword">if</span> (last == <span class="hljs-literal">null</span>) &#123;<br>            addFirst(value);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        last.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(value, <span class="hljs-literal">null</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 向索引位置插入节点</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> index 索引位置</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 待插入值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span>) &#123;<br>            addFirst(value);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> findNode(index - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (prev == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//找不到前一个节点</span><br>            <span class="hljs-keyword">throw</span> illegalIndex();<br>        &#125;<br>        prev.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(value, prev.next);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除头节点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeFirst</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> illegalIndex();<br>        &#125;<br>        head = head.next;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据索引删除节点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span>) &#123;<br>            removeFirst();<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> findNode(index - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (prev == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//找不到前一个节点</span><br>            <span class="hljs-keyword">throw</span> illegalIndex();<br>        &#125;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">removed</span> <span class="hljs-operator">=</span> prev.next;<br>        <span class="hljs-keyword">if</span> (removed == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> illegalIndex();<br>        &#125;<br>        prev.next = removed.next;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> IllegalArgumentException <span class="hljs-title function_">illegalIndex</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;index illegal&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 找到最后一个节点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Node <span class="hljs-title function_">findLast</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//链表为空，没有最后一个节点</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">//利用for循环特性获取最后一个节点</span><br>        Node p;<br>        <span class="hljs-keyword">for</span> (p = head; p.next != <span class="hljs-literal">null</span>; p = p.next) &#123;<br>        &#125;<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查询指定位置元素</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Node <span class="hljs-title function_">findNode</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//利用for循环特性获取指定index位置节点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> head; p != <span class="hljs-literal">null</span>; p = p.next, i++) &#123;<br>            <span class="hljs-keyword">if</span> (i == index) &#123;<br>                <span class="hljs-keyword">return</span> p;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * get方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> findNode(index);<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> illegalIndex();<br>        &#125;<br>        <span class="hljs-keyword">return</span> node.value;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 循环1 while</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loop1</span><span class="hljs-params">(Consumer&lt;Integer&gt; consumer)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">pointer</span> <span class="hljs-operator">=</span> head;<span class="hljs-comment">//初始值指向头节点</span><br>        <span class="hljs-keyword">while</span> (pointer != <span class="hljs-literal">null</span>) &#123;<br>            consumer.accept(pointer.value);<span class="hljs-comment">//提供给外部的方法</span><br>            pointer = pointer.next;<span class="hljs-comment">//指向下一个节点</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 循环2 for</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loop2</span><span class="hljs-params">(Consumer&lt;Integer&gt; consumer)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">pointer</span> <span class="hljs-operator">=</span> head; pointer != <span class="hljs-literal">null</span>; pointer = pointer.next) &#123;<br>            consumer.accept(pointer.value);<span class="hljs-comment">//提供给外部的方法</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 循环3 iterator</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Iterator <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 匿名内部类 -&gt; 带名字的内部类</span><br><span class="hljs-comment">         * 这个抽取出来的内部类MyIterator，它是不加static的</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * 当内部类用到了外部类的成员变量时候，就不能加static</span><br><span class="hljs-comment">         * 因为static的意思是不依赖外部类实例的存在，而成员变量是依赖外部类的对象的</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * 而Node节点类是可以加static的，因为它不依赖外部类的对象的</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * 内部类能加就加，不能加就不加，建议加static</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyIterator</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">pointer</span> <span class="hljs-operator">=</span> head;<span class="hljs-comment">//初始值指向头节点</span><br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<span class="hljs-comment">//是否有下一个元素</span><br>            <span class="hljs-keyword">return</span> pointer != <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<span class="hljs-comment">//返回当前值，并指向下一个元素</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> pointer.value;<br>            pointer = pointer.next;<br>            <span class="hljs-keyword">return</span> v;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="单向链表之含哨兵节点"><a href="#单向链表之含哨兵节点" class="headerlink" title="单向链表之含哨兵节点"></a>单向链表之含哨兵节点</h2><p class="note note-light">talk is cheap, show me the code.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.datastructure;<br><br><span class="hljs-keyword">import</span> java.util.Iterator;<br><span class="hljs-keyword">import</span> java.util.function.Consumer;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 单向链表 优化实现 含哨兵节点</span><br><span class="hljs-comment"> * 带哨兵节点的单向链表可以减少很多边界判断</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SentinelSinglyLinkedList</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterable</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 头指针指向哨兵节点，哨兵节点值无所谓</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Node</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">111</span>, <span class="hljs-literal">null</span>);<span class="hljs-comment">//头节点</span><br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 内部类关系，对外隐藏实现细节</span><br><span class="hljs-comment">     * 对外部调用者只需要LinkedList即可</span><br><span class="hljs-comment">     * 内部类一般都加上static</span><br><span class="hljs-comment">     * 节点类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<span class="hljs-comment">//节点</span><br>        <span class="hljs-type">int</span> value;<span class="hljs-comment">//值</span><br>        Node next;<span class="hljs-comment">//下一个节点</span><br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> value, Node next)</span> &#123;<br>            <span class="hljs-built_in">this</span>.value = value;<br>            <span class="hljs-built_in">this</span>.next = next;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 加哨兵后修改</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * 向链表头添加元素</span><br><span class="hljs-comment">     * 多理解！！</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addFirst</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-comment">//不需要判断链表是否为空，因为链表一定不为空</span><br><span class="hljs-comment">//        //1.链表为空</span><br><span class="hljs-comment">////        head = new Node(value, null);</span><br><span class="hljs-comment">//        //2.链表非空</span><br><span class="hljs-comment">//        //因为head默认为null，所以不需要判断，链表空不空都能能用</span><br><span class="hljs-comment">//        head = new Node(value, head);</span><br>        insert(<span class="hljs-number">0</span>, value);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 加哨兵后修改</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * 向列表尾添加元素</span><br><span class="hljs-comment">     * 先找到尾节点，再添加</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addLast</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> findLast();<br>        <span class="hljs-comment">//含哨兵节点，不需要判断链表是否为空，因为链表一定不为空</span><br><span class="hljs-comment">//        if (last == null) &#123;</span><br><span class="hljs-comment">//            addFirst(value);</span><br><span class="hljs-comment">//            return;</span><br><span class="hljs-comment">//        &#125;</span><br>        last.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(value, <span class="hljs-literal">null</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 加哨兵后修改</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * 向索引位置插入节点</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> index 索引位置</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 待插入值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> value)</span> &#123;<br><span class="hljs-comment">//        if (index == 0) &#123;</span><br><span class="hljs-comment">//            addFirst(value);</span><br><span class="hljs-comment">//            return;</span><br><span class="hljs-comment">//        &#125;</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> findNode(index - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (prev == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//找不到前一个节点</span><br>            <span class="hljs-keyword">throw</span> illegalIndex();<br>        &#125;<br>        prev.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(value, prev.next);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 加哨兵后修改</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * 删除头节点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeFirst</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//        if (head == null) &#123;</span><br><span class="hljs-comment">//            throw illegalIndex();</span><br><span class="hljs-comment">//        &#125;</span><br><span class="hljs-comment">//        head = head.next;</span><br>        remove(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 加哨兵后修改</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * 根据索引删除节点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br><span class="hljs-comment">//        if (index == 0) &#123;</span><br><span class="hljs-comment">//            removeFirst();</span><br><span class="hljs-comment">//            return;</span><br><span class="hljs-comment">//        &#125;</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> findNode(index - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (prev == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//找不到前一个节点</span><br>            <span class="hljs-keyword">throw</span> illegalIndex();<br>        &#125;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">removed</span> <span class="hljs-operator">=</span> prev.next;<br>        <span class="hljs-keyword">if</span> (removed == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> illegalIndex();<br>        &#125;<br>        prev.next = removed.next;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> IllegalArgumentException <span class="hljs-title function_">illegalIndex</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;index illegal&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 加哨兵后修改</span><br><span class="hljs-comment">     * 找到最后一个节点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Node <span class="hljs-title function_">findLast</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//含哨兵节点，不需要判断链表是否为空，因为链表一定不为空</span><br><span class="hljs-comment">//        if (head == null) &#123;</span><br><span class="hljs-comment">//            //链表为空，没有最后一个节点</span><br><span class="hljs-comment">//            return null;</span><br><span class="hljs-comment">//        &#125;</span><br>        Node p;<br>        <span class="hljs-keyword">for</span> (p = head; p.next != <span class="hljs-literal">null</span>; p = p.next) &#123;<br>        &#125;<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 加哨兵后修改</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * 查询指定位置元素</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Node <span class="hljs-title function_">findNode</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//为什么i=-1？ 因为哨兵节点也占一位。</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> head; p != <span class="hljs-literal">null</span>; p = p.next, i++) &#123;<br>            <span class="hljs-keyword">if</span> (i == index) &#123;<br>                <span class="hljs-keyword">return</span> p;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * get方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> findNode(index);<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> illegalIndex();<br>        &#125;<br>        <span class="hljs-keyword">return</span> node.value;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 加哨兵后修改</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * 循环1 while</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loop1</span><span class="hljs-params">(Consumer&lt;Integer&gt; consumer)</span> &#123;<br>        <span class="hljs-comment">//遍历的起点变了</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">pointer</span> <span class="hljs-operator">=</span> head.next;<span class="hljs-comment">//初始值指向头节点</span><br>        <span class="hljs-keyword">while</span> (pointer != <span class="hljs-literal">null</span>) &#123;<br>            consumer.accept(pointer.value);<span class="hljs-comment">//提供给外部的方法</span><br>            pointer = pointer.next;<span class="hljs-comment">//指向下一个节点</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 加哨兵后修改</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * 循环2 for</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loop2</span><span class="hljs-params">(Consumer&lt;Integer&gt; consumer)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">pointer</span> <span class="hljs-operator">=</span> head.next; pointer != <span class="hljs-literal">null</span>; pointer = pointer.next) &#123;<br>            consumer.accept(pointer.value);<span class="hljs-comment">//提供给外部的方法</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 循环3 iterator</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Iterator <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 匿名内部类 -&gt; 带名字的内部类</span><br><span class="hljs-comment">         * 这个抽取出来的内部类MyIterator，它是不加static的</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * 当内部类用到了外部类的成员变量时候，就不能加static</span><br><span class="hljs-comment">         * 因为static的意思是不依赖外部类实例的存在，而成员变量是依赖外部类的对象的</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * 而Node节点类是可以加static的，因为它不依赖外部类的对象的</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * 内部类能加就加，不能加就不加，建议加static</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyIterator</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">pointer</span> <span class="hljs-operator">=</span> head.next;<span class="hljs-comment">//初始值指向头节点</span><br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<span class="hljs-comment">//是否有下一个元素</span><br>            <span class="hljs-keyword">return</span> pointer != <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<span class="hljs-comment">//返回当前值，并指向下一个元素</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> pointer.value;<br>            pointer = pointer.next;<br>            <span class="hljs-keyword">return</span> v;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="双向链表之含哨兵节点"><a href="#双向链表之含哨兵节点" class="headerlink" title="双向链表之含哨兵节点"></a>双向链表之含哨兵节点</h2><p class="note note-light">talk is cheap, show me the code.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.datastructure;<br><br><span class="hljs-keyword">import</span> java.util.Iterator;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 双向链表 带哨兵节点</span><br><span class="hljs-comment"> * 俩个哨兵节点，一个头哨兵，一个尾哨兵</span><br><span class="hljs-comment"> * 也就是说，链表中至少有俩个节点</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * 双向链表的优点：从尾部直接能获取最后一个节点</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DoublyLinkedListSentinel</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterable</span>&lt;Integer&gt; &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>        Node prev;<span class="hljs-comment">//上一个节点</span><br>        <span class="hljs-type">int</span> value;<span class="hljs-comment">//值</span><br>        Node next;<span class="hljs-comment">//下一个节点</span><br><br>        <span class="hljs-comment">//构造方法 方便初始化</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(Node prev, <span class="hljs-type">int</span> value, Node next)</span> &#123;<br>            <span class="hljs-built_in">this</span>.prev = prev;<br>            <span class="hljs-built_in">this</span>.value = value;<br>            <span class="hljs-built_in">this</span>.next = next;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Node head;<span class="hljs-comment">//头哨兵</span><br>    <span class="hljs-keyword">private</span> Node tail;<span class="hljs-comment">//尾哨兵</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DoublyLinkedListSentinel</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//头尾节点随便给个值就行</span><br>        head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-literal">null</span>, <span class="hljs-number">666</span>, <span class="hljs-literal">null</span>);<br>        tail = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-literal">null</span>, <span class="hljs-number">888</span>, <span class="hljs-literal">null</span>);<br>        head.next = tail;<br>        tail.prev = head;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据索引查找节点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Node <span class="hljs-title function_">findNode</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<span class="hljs-comment">//头哨兵也要参与遍历所以从-1开始</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> head; p != tail; p = p.next, i++) &#123;<br>            <span class="hljs-keyword">if</span> (i == index) &#123;<br>                <span class="hljs-keyword">return</span> p;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addFirst</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        insert(<span class="hljs-number">0</span>, value);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeFirst</span><span class="hljs-params">()</span> &#123;<br>        remove(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 向列表尾添加元素</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addLast</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> tail.prev;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">added</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(last, value, tail);<br>        last.next = added;<br>        tail.prev = added;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除列表尾元素</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeLast</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">removed</span> <span class="hljs-operator">=</span> tail.prev;<br>        <span class="hljs-keyword">if</span> (removed == head) &#123;<br>            <span class="hljs-keyword">throw</span> illegalIndex();<br>        &#125;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> removed.prev;<br>        prev.next = tail;<br>        tail.prev = prev;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 向索引位置插入节点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> findNode(index - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (prev == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> illegalIndex();<br>        &#125;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> prev.next;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">inserted</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(prev, value, next);<span class="hljs-comment">//新节点的上一个节点是prev，下一个节点是next</span><br>        prev.next = inserted;<span class="hljs-comment">//prev的下一个节点是inserted</span><br>        next.prev = inserted;<span class="hljs-comment">//next的上一个节点是inserted</span><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除索引位置的节点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> findNode(index - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (prev == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> illegalIndex();<br>        &#125;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">removed</span> <span class="hljs-operator">=</span> prev.next;<br>        <span class="hljs-keyword">if</span> (removed == tail) &#123;<br>            <span class="hljs-keyword">throw</span> illegalIndex();<br>        &#125;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> removed.next;<br><br>        prev.next = next;<br>        next.prev = prev;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> IllegalArgumentException <span class="hljs-title function_">illegalIndex</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;index illegal&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Iterator&lt;Integer&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Iterator</span>&lt;Integer&gt;() &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> head.next;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> p != tail;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> p.value;<br>                p = p.next;<br>                <span class="hljs-keyword">return</span> v;<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="双向环形含哨兵链表"><a href="#双向环形含哨兵链表" class="headerlink" title="双向环形含哨兵链表"></a>双向环形含哨兵链表</h2><p class="note note-light">talk is cheap, show me the code.<br> 这个有些特殊，此时哨兵即作为头，也作为尾。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309201522659.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.datastructure;<br><br><span class="hljs-keyword">import</span> java.util.Iterator;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 环形双向含哨兵链表</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RingDoublyLinkedListSentinel</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterable</span>&lt;Integer&gt; &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>        Node prev;<br>        <span class="hljs-type">int</span> value;<br>        Node next;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(Node prev, <span class="hljs-type">int</span> value, Node next)</span> &#123;<br>            <span class="hljs-built_in">this</span>.prev = prev;<br>            <span class="hljs-built_in">this</span>.value = value;<br>            <span class="hljs-built_in">this</span>.next = next;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Node</span> <span class="hljs-variable">sentinel</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-literal">null</span>, <span class="hljs-number">666</span>, <span class="hljs-literal">null</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RingDoublyLinkedListSentinel</span><span class="hljs-params">()</span> &#123;<br>        sentinel.next = sentinel;<br>        sentinel.prev = sentinel;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 添加到链表头部</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addFirst</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> sentinel;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> sentinel.next;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">added</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(a, value, b);<br>        a.next = added;<br>        b.prev = added;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 添加到链表尾部</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addLast</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> sentinel.prev;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> sentinel;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">added</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(a, value, b);<br>        a.next = added;<br>        b.prev = added;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除第一个</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeFirst</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">removed</span> <span class="hljs-operator">=</span> sentinel.next;<br>        <span class="hljs-keyword">if</span> (removed == sentinel) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal argument&quot;</span>);<br>        &#125;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> removed.prev;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> removed.next;<br>        a.next = b;<br>        b.prev = a;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除最后一个</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeLast</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">removed</span> <span class="hljs-operator">=</span> sentinel.prev;<br>        <span class="hljs-keyword">if</span> (removed == sentinel) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal argument&quot;</span>);<br>        &#125;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> removed.prev;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> removed.next;<br>        a.next = b;<br>        b.prev = a;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据值删除节点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeByValue</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">removed</span> <span class="hljs-operator">=</span> findByValue(value);<br>        <span class="hljs-keyword">if</span> (removed == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal argument&quot;</span>);<br>        &#125;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> removed.prev;<span class="hljs-comment">//前一个节点</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> removed.next;<span class="hljs-comment">//后一个节点</span><br>        a.next = b;<span class="hljs-comment">//前一个节点的next指向后一个节点</span><br>        b.prev = a;<span class="hljs-comment">//后一个节点的prev指向前一个节点</span><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据值找到节点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Node <span class="hljs-title function_">findByValue</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> sentinel.next;<br>        <span class="hljs-keyword">while</span> (p != sentinel) &#123;<br>            <span class="hljs-keyword">if</span> (p.value == value) &#123;<br>                <span class="hljs-keyword">return</span> p;<br>            &#125;<br>            p = p.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Iterator&lt;Integer&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Iterator</span>&lt;Integer&gt;() &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">pointer</span> <span class="hljs-operator">=</span> sentinel.next;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> pointer != sentinel;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> pointer.value;<br>                pointer = pointer.next;<br>                <span class="hljs-keyword">return</span> v;<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="单向链表的递归遍历"><a href="#单向链表的递归遍历" class="headerlink" title="单向链表的递归遍历"></a>单向链表的递归遍历</h2><p class="note note-light">talk is cheap, show me the code.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><code class="hljs java">  <br><span class="hljs-keyword">import</span> java.util.Iterator;  <br><span class="hljs-keyword">import</span> java.util.function.Consumer;  <br>  <br><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * 单向链表 基础实现  </span><br><span class="hljs-comment"> * &lt;p&gt;  </span><br><span class="hljs-comment"> * ！！！递归遍历！！！  </span><br><span class="hljs-comment"> * 它是链表的一种非常重要的遍历方式  </span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RecursionLinkedList</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterable</span> &#123;<span class="hljs-comment">//整体  </span><br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Node</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<span class="hljs-comment">//头节点，默认为null  </span><br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 内部类关系，对外隐藏实现细节  </span><br><span class="hljs-comment">     * 对外部调用者只需要LinkedList即可  </span><br><span class="hljs-comment">     * 内部类一半都加上static  </span><br><span class="hljs-comment">     * 节点类  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<span class="hljs-comment">//节点  </span><br>        <span class="hljs-type">int</span> value;<span class="hljs-comment">//值  </span><br>        Node next;<span class="hljs-comment">//下一个节点  </span><br>  <br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> value, Node next)</span> &#123;  <br>            <span class="hljs-built_in">this</span>.value = value;  <br>            <span class="hljs-built_in">this</span>.next = next;  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 向链表头添加元素  </span><br><span class="hljs-comment">     * 多理解！！  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addFirst</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;  <br>        <span class="hljs-comment">//1.链表为空  </span><br><span class="hljs-comment">//        head = new Node(value, null);  </span><br>        <span class="hljs-comment">//2.链表非空  </span><br>        <span class="hljs-comment">//因为head默认为null，所以不需要判断，链表空不空都能能用  </span><br>        head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(value, head);  <br>    &#125;  <br>  <br>  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 向列表尾添加元素  </span><br><span class="hljs-comment">     * 先找到尾节点，再添加  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addLast</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> findLast();  <br>        <span class="hljs-keyword">if</span> (last == <span class="hljs-literal">null</span>) &#123;  <br>            addFirst(value);  <br>            <span class="hljs-keyword">return</span>;  <br>        &#125;  <br>        last.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(value, <span class="hljs-literal">null</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 向索引位置插入节点  </span><br><span class="hljs-comment">     *  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> index 索引位置  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 待插入值  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> value)</span> &#123;  <br>        <span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span>) &#123;  <br>            addFirst(value);  <br>            <span class="hljs-keyword">return</span>;  <br>        &#125;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> findNode(index - <span class="hljs-number">1</span>);  <br>        <span class="hljs-keyword">if</span> (prev == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//找不到前一个节点  </span><br>            <span class="hljs-keyword">throw</span> illegalIndex();  <br>        &#125;  <br>        prev.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(value, prev.next);  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 删除头节点  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeFirst</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-keyword">throw</span> illegalIndex();  <br>        &#125;  <br>        head = head.next;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 根据索引删除节点  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;  <br>        <span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span>) &#123;  <br>            removeFirst();  <br>            <span class="hljs-keyword">return</span>;  <br>        &#125;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> findNode(index - <span class="hljs-number">1</span>);  <br>        <span class="hljs-keyword">if</span> (prev == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//找不到前一个节点  </span><br>            <span class="hljs-keyword">throw</span> illegalIndex();  <br>        &#125;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">removed</span> <span class="hljs-operator">=</span> prev.next;  <br>        <span class="hljs-keyword">if</span> (removed == <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-keyword">throw</span> illegalIndex();  <br>        &#125;  <br>        prev.next = removed.next;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> IllegalArgumentException <span class="hljs-title function_">illegalIndex</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;index illegal&quot;</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 找到最后一个节点  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">private</span> Node <span class="hljs-title function_">findLast</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-comment">//链表为空，没有最后一个节点  </span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>        &#125;  <br>        Node p;  <br>        <span class="hljs-keyword">for</span> (p = head; p.next != <span class="hljs-literal">null</span>; p = p.next) &#123;  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> p;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 查询指定位置元素  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">private</span> Node <span class="hljs-title function_">findNode</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> head; p != <span class="hljs-literal">null</span>; p = p.next, i++) &#123;  <br>            <span class="hljs-keyword">if</span> (i == index) &#123;  <br>                <span class="hljs-keyword">return</span> p;  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * get方法  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> findNode(index);  <br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-keyword">throw</span> illegalIndex();  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> node.value;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 循环3 iterator  </span><br><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> Iterator <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-comment">/**  </span><br><span class="hljs-comment">         * 匿名内部类 -&gt; 带名字的内部类  </span><br><span class="hljs-comment">         * 这个抽取出来的内部类MyIterator，它是不加static的  </span><br><span class="hljs-comment">         *  </span><br><span class="hljs-comment">         * 当内部类用到了外部类的成员变量时候，就不能加static  </span><br><span class="hljs-comment">         * 因为static的意思是不依赖外部类实例的存在，而成员变量是依赖外部类的对象的  </span><br><span class="hljs-comment">         *  </span><br><span class="hljs-comment">         * 而Node节点类是可以加static的，因为它不依赖外部类的对象的  </span><br><span class="hljs-comment">         *  </span><br><span class="hljs-comment">         * 内部类能加就加，不能加就不加，建议加static  </span><br><span class="hljs-comment">         */</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyIterator</span>();  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span> &#123;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">pointer</span> <span class="hljs-operator">=</span> head;<span class="hljs-comment">//初始值指向头节点  </span><br>  <br>        <span class="hljs-meta">@Override</span>  <br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<span class="hljs-comment">//是否有下一个元素  </span><br>            <span class="hljs-keyword">return</span> pointer != <span class="hljs-literal">null</span>;  <br>        &#125;  <br>  <br>        <span class="hljs-meta">@Override</span>  <br>        <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<span class="hljs-comment">//返回当前值，并指向下一个元素  </span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> pointer.value;  <br>            pointer = pointer.next;  <br>            <span class="hljs-keyword">return</span> v;  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recursion</span><span class="hljs-params">(Node curr, Consumer&lt;String&gt; before, Consumer&lt;String&gt; after)</span>&#123; <br>        <span class="hljs-keyword">if</span> (curr == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//递归需要一个终止条件  </span><br>            <span class="hljs-keyword">return</span>;  <br>        &#125;  <br>        before.accept(<span class="hljs-string">&quot;before: &quot;</span> + curr.value);  <br>        recursion(curr.next, before, after);<span class="hljs-comment">//这样自己调用自己称为递归  </span><br>        after.accept(<span class="hljs-string">&quot;after: &quot;</span> + curr.value);  <br>    &#125;  <br>  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    <span class="hljs-type">RecursionLinkedList</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RecursionLinkedList</span>();  <br>    list.addLast(<span class="hljs-number">55</span>);  <br>    list.addLast(<span class="hljs-number">66</span>);  <br>    list.addLast(<span class="hljs-number">77</span>);  <br>    list.addLast(<span class="hljs-number">88</span>);  <br>    list.recursion(list.findNode(<span class="hljs-number">0</span>),System.out::println, System.out::println);  <br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>通过递归方式遍历打印的时候，发现了有趣的现象，不同情况，打印结果却不同<br>打印在前，递归在后<br>递归在前，递归在后<br>俩种情况的呈现方式相差很大，如下图。</p></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309201607691.png"></p><blockquote><p>下一篇，会详细探讨一下递归，来解释为什么有这种现象。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>data&amp;algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
      <tag>链表</tag>
      
      <tag>单向链表</tag>
      
      <tag>双向链表</tag>
      
      <tag>环形链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构和算法之旅（一）- 数组</title>
    <link href="/posts/743df8dd/"/>
    <url>/posts/743df8dd/</url>
    
    <content type="html"><![CDATA[<blockquote><p>在计算机科学中，数组是由一组元素(值或变量)组成的数据结构，每个元素有至少一个索引来标识；因为数组内元素是连续存储的，所以数组中的元素的地址，可以通过其索引计算出来，例如：<img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309201048552.png"></p><p>数组的特点：<strong>随机访问</strong>。即根据索引查找元素，时间复杂度是O(1)。</p></blockquote><h2 id="自定义动态数组"><a href="#自定义动态数组" class="headerlink" title="自定义动态数组"></a>自定义动态数组</h2><p class="note note-info">数组是静态数组，不能够动态调整大小。Java是有提供好的动态数组，其实就是ArrayList，但目前是为了学习数据结构，下面自己来实现一个动态数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.datastructure;<br><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Iterator;<br><span class="hljs-keyword">import</span> java.util.function.Consumer;<br><span class="hljs-keyword">import</span> java.util.stream.IntStream;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 动态数组</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DynamicArray</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterable</span>&lt;Integer&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//逻辑大小</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">capacity</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<span class="hljs-comment">//容量 ,java中arraylist默认是10</span><br><br>    <span class="hljs-comment">//    private int[] array = new int[capacity];//延迟加载</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] array = &#123;&#125;;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 添加元素到数组末尾</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> element 待添加的元素</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addLast</span><span class="hljs-params">(<span class="hljs-type">int</span> element)</span> &#123;<br>        <span class="hljs-comment">//array[size] = element;</span><br>        <span class="hljs-comment">//size++;</span><br>        add(size, element);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 添加元素到指定位置</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> index   索引位置</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> element 待添加的元素</span><br><span class="hljs-comment">     * 时间复杂度</span><br><span class="hljs-comment">     *    头部插入：O(n)</span><br><span class="hljs-comment">     *    中间插入：O(n)</span><br><span class="hljs-comment">     *    尾部插入：O(1)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> element)</span> &#123;<br>        <span class="hljs-comment">//扩容检查</span><br>        checkAndGrow();<br>        <span class="hljs-comment">//检查index是否合法</span><br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt; size) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>(<span class="hljs-string">&quot;index:&quot;</span> + index + <span class="hljs-string">&quot;,size:&quot;</span> + size);<br>        &#125;<br>        <span class="hljs-comment">//拷贝，把目标index后的元素都往后移动一位</span><br>        System.arraycopy(array, index, array, index + <span class="hljs-number">1</span>, size - index);<br>        array[index] = element;<br>        size++;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 扩容检查</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkAndGrow</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>) &#123;<br>            array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[capacity];<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (size == capacity) &#123;<br>            <span class="hljs-comment">//扩容，1.5倍、1.618倍、2倍：建议这些</span><br>            capacity += capacity &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span>[] newArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[capacity];<br>            <span class="hljs-comment">//拷贝</span><br>            System.arraycopy(array, <span class="hljs-number">0</span>, newArray, <span class="hljs-number">0</span>, size);<br>            <span class="hljs-comment">//替换</span><br>            array = newArray;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除指定位置的元素</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> index</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<span class="hljs-comment">//[0..size)</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">removed</span> <span class="hljs-operator">=</span> array[index];<br>        <span class="hljs-keyword">if</span> (index &lt; size - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">//拷贝，把目标index后的元素都往前移动一位</span><br>            System.arraycopy(array, index + <span class="hljs-number">1</span>, array, index, size - index - <span class="hljs-number">1</span>);<br>            size--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> removed;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查询指定位置的元素</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> index 索引</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 时间复杂度：O(1)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<span class="hljs-comment">// [0..size)</span><br>        <span class="hljs-keyword">return</span> array[index];<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 使用函数式接口Consumer,遍历数组，</span><br><span class="hljs-comment">     * 对每个元素执行consumer.accept(array[i])，令调用方执行自定义的操作</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> consumer</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">foreach</span><span class="hljs-params">(Consumer&lt;Integer&gt; consumer)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            <span class="hljs-comment">// 提供array[i]</span><br>            <span class="hljs-comment">// 返回void</span><br>            consumer.accept(array[i]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 迭代器遍历</span><br><span class="hljs-comment">     * 实现Iterable接口，使得DynamicArray可以使用foreach语法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Iterator&lt;Integer&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Iterator</span>&lt;Integer&gt;() &#123;<br>            <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> index &lt; size;<span class="hljs-comment">//index &lt; size表示还有元素</span><br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> array[index++];<br>            &#125;<br>        &#125;;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取流对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> IntStream <span class="hljs-title function_">stream</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> IntStream.of(Arrays.copyOfRange(array, <span class="hljs-number">0</span>, size));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="System-arraycopy"><a href="#System-arraycopy" class="headerlink" title="System.arraycopy"></a>System.arraycopy</h2><p class="note note-warning">注：System.arraycopy(Object src, int srcPos, Object dest, int destPos, int length);</br>- src：源数组，即要复制的数组。</br>- srcPos：源数组的起始位置，从源数组的哪个索引开始复制。</br>- dest：目标数组，即复制到的数组。</br>- destPos：目标数组的起始位置，复制到目标数组的哪个索引位置。</br>- length：要复制的元素数量。</br></br>System.arrayCopy 的主要特点和注意事项：</br>1. **低级别操作：** 这是一种低级别的数组操作，直接在内存中复制数组内容，效率较高。    </br>2. **复制范围控制：** 你可以控制复制的范围，包括源数组的起始位置、目标数组的起始位置和要复制的元素数量。    </br>3. **原地复制：** 它允许在不创建新数组的情况下，将源数组的一部分复制到目标数组中，适用于需要在原地进行数据移动的情况。    </br>4. **数据类型检查：** `System.arrayCopy` 不会进行数据类型检查，因此要确保源和目标数组的数据类型一致，否则可能会导致运行时异常。    </br>5. **不会自动扩展：** 它不会自动扩展目标数组，如果目标数组长度不足以容纳复制的数据，会导致数组越界异常。    </br>6. **效率高：** 由于是底层操作，因此通常情况下比使用迭代或循环来复制数组要更高效</p><h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p class="note note-primary">这个很有趣，推荐平常多使用函数式接口来优化代码，这里总结汇总一下吧。</p><h3 id="Runnable-和-Callable"><a href="#Runnable-和-Callable" class="headerlink" title="Runnable 和 Callable"></a>Runnable 和 Callable</h3><ul><li><code>Runnable</code> 通常用于<strong>多线程编程，用于定义线程要执行的任务</strong>。它没有输入参数，也没有返回值。</li><li><code>Callable</code> 类似于 <code>Runnable</code>，但<strong>允许任务返回结果</strong>。通常与线程池一起使用，可以获得任务执行的结果。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用Runnable创建线程任务</span><br><span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> () -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;Hello from Runnable&quot;</span>);<br>&#125;;<br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable);<br>thread.start();<br><br><span class="hljs-comment">// 使用Callable和ExecutorService获取线程任务的返回值</span><br>Callable&lt;Integer&gt; callable = () -&gt; &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;<br>&#125;;<br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newSingleThreadExecutor();<br>Future&lt;Integer&gt; result = executorService.submit(callable);<br>System.out.println(<span class="hljs-string">&quot;Result from Callable: &quot;</span> + result.get());<br>executorService.shutdown();<br></code></pre></td></tr></table></figure><h3 id="Comparator"><a href="#Comparator" class="headerlink" title="Comparator"></a>Comparator</h3><ul><li><code>Comparator</code> 用于<strong>比较两个对象的顺序</strong>。它通常用于集合的排序操作。</li><li>可以使用 <code>Comparator</code> 的 <code>comparing</code> 方法创建比较器，也可以使用 <code>reversed</code> 方法反转比较器的顺序。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; names = Arrays.asList(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;Charlie&quot;</span>);<br>names.sort((s1, s2) -&gt; s1.compareTo(s2));<br><span class="hljs-comment">// 或者使用Comparator.comparing方法</span><br>names.sort(Comparator.comparing(String::length));<br></code></pre></td></tr></table></figure><h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><ul><li>直译有”消费者”的含义。</li><li><code>Consumer</code> 用于<strong>接受一个参数并执行操作，通常没有返回值</strong>。它常用于集合的遍历和元素处理。</li><li>可以使用 <code>andThen</code> 方法组合多个 <code>Consumer</code>，形成一个连续的操作链。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; numbers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br>Consumer&lt;Integer&gt; printSquare = (num) -&gt; System.out.println(num * num);<br>numbers.forEach(printSquare);<br></code></pre></td></tr></table></figure><h3 id="Supplier"><a href="#Supplier" class="headerlink" title="Supplier"></a>Supplier</h3><ul><li>直译有“供应者”的含义。</li><li><code>Supplier</code> <strong>通常不接受参数，用于生成一个值</strong>。它可以用于延迟加载或惰性计算。</li><li>可以在需要值的地方<strong>调用 <code>get</code> 方法来获取值</strong>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Supplier&lt;Double&gt; randomNumberSupplier = () -&gt; Math.random();<br><span class="hljs-type">double</span> <span class="hljs-variable">randomValue</span> <span class="hljs-operator">=</span> randomNumberSupplier.get();<br>System.out.println(<span class="hljs-string">&quot;Random Value: &quot;</span> + randomValue);<br></code></pre></td></tr></table></figure><h3 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h3><ul><li>直译有”谓语”的含义。</li><li><code>Predicate</code> <strong>接受一个参数并返回布尔值，用于进行条件判断</strong>。它通常用于过滤和筛选数据。</li><li>可以使用 <code>and</code>、<code>or</code> 和 <code>negate</code> 方法来组合多个谓词。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; numbers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br>Predicate&lt;Integer&gt; isEven = (num) -&gt; num % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;<br>List&lt;Integer&gt; evenNumbers = numbers.stream().filter(isEven).collect(Collectors.toList());<br></code></pre></td></tr></table></figure><h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h3><ul><li><code>Function</code> <strong>接受一个参数并返回一个值，用于将输入映射到输出</strong>。它通常用于数据转换和处理。</li><li>可以使用 <code>andThen</code> 和 <code>compose</code> 方法来组合多个函数，形成一个函数链。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Function&lt;Integer, String&gt; intToString = (i) -&gt; String.valueOf(i);<br><span class="hljs-type">String</span> <span class="hljs-variable">stringValue</span> <span class="hljs-operator">=</span> intToString.apply(<span class="hljs-number">42</span>);<br>System.out.println(<span class="hljs-string">&quot;String Value: &quot;</span> + stringValue);<br></code></pre></td></tr></table></figure><h3 id="BiFunction"><a href="#BiFunction" class="headerlink" title="BiFunction"></a>BiFunction</h3><ul><li><code>BiFunction</code> <strong>接受两个参数并返回一个值，用于处理两个输入并产生一个输出</strong>。它通常用于需要两个输入的操作。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">BiFunction&lt;Integer, Integer, Integer&gt; add = (a, b) -&gt; a + b;<br><span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> add.apply(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>);<br>System.out.println(<span class="hljs-string">&quot;Sum: &quot;</span> + sum);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>data&amp;algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>二维数组</tag>
      
      <tag>函数式接口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构和算法之旅（零）- 认识算法</title>
    <link href="/posts/24ec10c/"/>
    <url>/posts/24ec10c/</url>
    
    <content type="html"><![CDATA[<p class="note note-secondary">通过二分查找算法，认识算法。</br>需求：在有序数组A内，查找值target：</br>1.如果找到返回索引；</br>2.如果找不到返回-1；</p><h2 id="二分查找算法"><a href="#二分查找算法" class="headerlink" title="二分查找算法"></a>二分查找算法</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>根据需求，可以直观的想出来的解法如下：</p><ul><li>前提：给定一个内含n个元素的有序数组A，查找指定值target;</li><li>1.设置<code>i = 0</code>为左边界索引，<code>j = n - 1</code>为右边界索引;</li><li>2.如果<code>i &gt; j</code>，结束查找，没找到；</li><li>3.设置<code>m = medium((i+j)/2)</code>，m为中间索引，medium是向下取整的最小整数；</li><li>4.如果<code>target &lt; A[m]</code>，设置 <code>j = m - 1</code>，转第二步；</li><li>5.如果<code>A[m] &lt; target</code>，设置<code>i = m + 1</code>，转第二步；</li><li>6.如果<code>A[m] = target</code>，结束查找，说明找到了；</li></ul><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearchBasic</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> target)</span>&#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = a.length - <span class="hljs-number">1</span>;<span class="hljs-comment">//设置指针和初值</span><br><span class="hljs-keyword">while</span>(i&lt;=j)&#123;<br><span class="hljs-comment">//int m = (i+j)/2;//java除法自动取整，但除法有隐患，当然数值范围不大可以忽略</span><br><span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> (i+j)&gt;&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-comment">//无符号右移，相当于除以2，且能避免隐患</span><br><span class="hljs-keyword">if</span>(target&lt;a[m])&#123;<br><span class="hljs-comment">//如果目标在中间值的左边，设置右边界指针为中间索引-1</span><br>j = m - <span class="hljs-number">1</span>;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[m]&lt;target)&#123;<br><span class="hljs-comment">//如果目标在中间值的右边，设置左边界指针为中间索引+1</span><br>i = m + <span class="hljs-number">1</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">//找到了</span><br><span class="hljs-keyword">return</span> m;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="why"><a href="#why" class="headerlink" title="why"></a>why</h3><p class="note note-danger">Q：为什么是i <= j 意味着区间内有未比较的元素，而不是i < j ？</p><p class="note note-success">A：因为i=j 指向的元素也有可能是要查找的目标，如果没有等号，就会漏掉一次比较；</p><p class="note note-danger">Q：(i+j)/2 有没有问题？为什么使用右移代替？</p><p class="note note-success">A：因为如果数组无限大，j初始是Integer.MAX_VALUE - 1。第一次(i+j)/2没问题，但是如果此时，目标值比中间值大，需要把左侧i边界设置为m+1，那么此时，再进行取中间索引时候，(i+j)/2. 一个是Integer.MAX_VALUE的一半，一个是MAX_VALUE就会超过正整数能表达的范围，就会得到一个负数。负数是补码的形式，符号位不变，数值为取反。所以会得到一个负数；java里面二进制数都是有符号的，最高位是符号位。</p><p class="note note-danger">Q：为什么判断条件都写小于符号？</p><p class="note note-success">A：因为这里数组a是升序排列的，写成小于符号，相当于与数组排列的顺序是一致的。</p><h2 id="二分查找的应用"><a href="#二分查找的应用" class="headerlink" title="二分查找的应用"></a>二分查找的应用</h2><h3 id="重复元素"><a href="#重复元素" class="headerlink" title="重复元素"></a>重复元素</h3><p class="note note-secondary">需求，如果存在重复元素，希望找到最左侧的第一个元素</br>这种形式称为LeftMost，找最右侧的第一个元素，即为RightMost</p><p class="note note-info">首先，还是二分查找的解法，只不过在找到了的分支，追加向左区间继续找或向右区间继续找目标值的逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * 二分查找 - LeftMost  </span><br><span class="hljs-comment"> * 重复元素的数组中，查找最左侧的  </span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearchLeftMost</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> target)</span> &#123;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = a.length - <span class="hljs-number">1</span>;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">candidate</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">//候选  </span><br>    <span class="hljs-keyword">while</span> (i &lt;= j) &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> (i + j) &gt;&gt;&gt; <span class="hljs-number">1</span>;  <br>        <span class="hljs-keyword">if</span> (target &lt; a[m]) &#123;  <br>            j = m - <span class="hljs-number">1</span>;  <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a[m] &lt; target) &#123;  <br>            i = m + <span class="hljs-number">1</span>;  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            <span class="hljs-comment">//只需要修改这里，找到目标需要存为候选，然后继续向左边找  </span><br>            candidate = m;  <br>            <span class="hljs-comment">//继续向左边找，则需要设置右侧指针移至中间索引-1  </span><br>            j = m - <span class="hljs-number">1</span>;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> candidate;  <br>&#125;<br><br><br><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * 二分查找 - RightMost  </span><br><span class="hljs-comment"> * 重复元素的数组中，查找最右侧的  </span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearchRightMost</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> target)</span> &#123;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = a.length - <span class="hljs-number">1</span>;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">candidate</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">//候选  </span><br>    <span class="hljs-keyword">while</span> (i &lt;= j) &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> (i + j) &gt;&gt;&gt; <span class="hljs-number">1</span>;  <br>        <span class="hljs-keyword">if</span> (target &lt; a[m]) &#123;  <br>            j = m - <span class="hljs-number">1</span>;  <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a[m] &lt; target) &#123;  <br>            i = m + <span class="hljs-number">1</span>;  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            <span class="hljs-comment">//只需要修改这里，找到目标需要存为候选，然后继续向右边找  </span><br>            candidate = m;  <br>            <span class="hljs-comment">//继续向右边找，则需要设置左侧指针移至中间索引+1  </span><br>            i = m + <span class="hljs-number">1</span>;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> candidate;  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="求排名"><a href="#求排名" class="headerlink" title="求排名"></a>求排名</h3><p class="note note-secondary">求排名，其实是LeftMost的应用，看一个图就了解了</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309201022852.png"></p><p class="note note-info">所以，求排名的解法就是：LeftMost+1。</p><h3 id="求前任后任"><a href="#求前任后任" class="headerlink" title="求前任后任"></a>求前任后任</h3><p class="note note-secondary">还是这张图，也是最左和最右的应用。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309201022852.png"></p><p class="note note-info">分析可知，</br>求前任解法即：LeftMost-1</br>求后任解法即：RightMost+1</p><h3 id="最近邻居"><a href="#最近邻居" class="headerlink" title="最近邻居"></a>最近邻居</h3><p class="note note-info">比如5的最近邻居是4，因为4和5差1，5和7差2，</br>就是找到前任和后任，然后比对，找到其中最小的。</p><h3 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h3><p class="note note-info">比如想找所有小于4的目标，0 .. LeftMost(4) - 1</br>比如找所有小于等于4的目标， 0 .. RightMost(4)</br>比如找所有大于4的目标， RightMost(4)+1 .. 无穷大</br>比如找所有大于等于4的目标，LeftMost(4) .. 无穷大</br>找 4 <= x <=7 ，LeftMost(4) .. RightMost(7)</br>找 4 < x <=7，RightMost(4)+1 .. LeftMost(7)-1</p><h3 id="leetcode"><a href="#leetcode" class="headerlink" title="leetcode"></a>leetcode</h3><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309201038568.png"></p><p class="note note-info">抱一丝，仍然是leftMost和rightMost的应用，有了最左和最右就可以得到结果，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">pubic <span class="hljs-type">int</span>[] searchRange(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> target)&#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> leftMost(a, target);<br><span class="hljs-keyword">if</span>(left == -<span class="hljs-number">1</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;left, rightMost(a, traget)&#125;;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>data&amp;algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
