<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>备忘系列-zookeeper</title>
    <link href="/posts/5326b2b2/"/>
    <url>/posts/5326b2b2/</url>
    
    <content type="html"><![CDATA[<p>sadasd</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>云原生之DevOps</title>
    <link href="/posts/9393e822/"/>
    <url>/posts/9393e822/</url>
    
    <content type="html"><![CDATA[<p>123123ss拾叁</p>]]></content>
    
    
    <categories>
      
      <category>云原生</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DevOps</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>云原生之kubeSphere</title>
    <link href="/posts/68893475/"/>
    <url>/posts/68893475/</url>
    
    <content type="html"><![CDATA[<p>1111222</p>]]></content>
    
    
    <categories>
      
      <category>云原生</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kubeSphere</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>云原生之k8s</title>
    <link href="/posts/7b28abd7/"/>
    <url>/posts/7b28abd7/</url>
    
    <content type="html"><![CDATA[<p>kkk8s<br>11</p>]]></content>
    
    
    <categories>
      
      <category>云原生</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kubernetes</tag>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>备忘系列-nginx</title>
    <link href="/posts/c06c050/"/>
    <url>/posts/c06c050/</url>
    
    <content type="html"><![CDATA[<p>2323</p>]]></content>
    
    
    <categories>
      
      <category>网络应用组件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线程安全</tag>
      
      <tag>nginx</tag>
      
      <tag>反向代理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>备忘系列-netty</title>
    <link href="/posts/75dbf2b5/"/>
    <url>/posts/75dbf2b5/</url>
    
    <content type="html"><![CDATA[<p>是sadasd</p>]]></content>
    
    
    <categories>
      
      <category>网络应用组件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>netty</tag>
      
      <tag>io</tag>
      
      <tag>nio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>备忘系列-mongodb</title>
    <link href="/posts/c9d19155/"/>
    <url>/posts/c9d19155/</url>
    
    <content type="html"><![CDATA[<p>1212</p>]]></content>
    
    
    <categories>
      
      <category>nosql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mongodb</tag>
      
      <tag>nosql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>备忘系列-solr</title>
    <link href="/posts/7aa76e65/"/>
    <url>/posts/7aa76e65/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>nosql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nosql</tag>
      
      <tag>solr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>备忘系列-xxl-job</title>
    <link href="/posts/89b2e006/"/>
    <url>/posts/89b2e006/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>xxl-job</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通关微服务-mysql</title>
    <link href="/posts/bb4eda82/"/>
    <url>/posts/bb4eda82/</url>
    
    <content type="html"><![CDATA[<p>333311</p>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通关微服务-redis</title>
    <link href="/posts/554b12af/"/>
    <url>/posts/554b12af/</url>
    
    <content type="html"><![CDATA[<p>redis is good<br>2333</p>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通关微服务-seata</title>
    <link href="/posts/6235e4a0/"/>
    <url>/posts/6235e4a0/</url>
    
    <content type="html"><![CDATA[<p>asd221</p>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>seata</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通关微服务-sentinel</title>
    <link href="/posts/60bdb85a/"/>
    <url>/posts/60bdb85a/</url>
    
    <content type="html"><![CDATA[<p>收到22111</p>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sentinel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通关微服务-ELK</title>
    <link href="/posts/9b53a343/"/>
    <url>/posts/9b53a343/</url>
    
    <content type="html"><![CDATA[<p>elk…ss</p>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
      <category>nosql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nosql</tag>
      
      <tag>elasticsearch</tag>
      
      <tag>logstash</tag>
      
      <tag>kibana</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通关微服务-SpringAMQP</title>
    <link href="/posts/8e215a30/"/>
    <url>/posts/8e215a30/</url>
    
    <content type="html"><![CDATA[<p>11ss</p>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AMQP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通关微服务-rabbitMQ</title>
    <link href="/posts/d4befa93/"/>
    <url>/posts/d4befa93/</url>
    
    <content type="html"><![CDATA[<p>啊啊啊啊啊啊</p>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rabbitMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通关微服务-gateway</title>
    <link href="/posts/4d88743d/"/>
    <url>/posts/4d88743d/</url>
    
    <content type="html"><![CDATA[<p>112</p>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>gateway</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通关微服务-nacos</title>
    <link href="/posts/2c2c4e78/"/>
    <url>/posts/2c2c4e78/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nacos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通关微服务-dubbo</title>
    <link href="/posts/198ade24/"/>
    <url>/posts/198ade24/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dubbo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>认识微服务体系</title>
    <link href="/posts/ffffd0ab/"/>
    <url>/posts/ffffd0ab/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>单体应用的困境</title>
    <link href="/posts/6fe0354c/"/>
    <url>/posts/6fe0354c/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2020终章</title>
    <link href="/posts/bd0587f7/"/>
    <url>/posts/bd0587f7/</url>
    
    <content type="html"><![CDATA[<p>奥术大师发的</p>]]></content>
    
    
    <categories>
      
      <category>年度总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>2020年度总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>elementUI case</title>
    <link href="/posts/2c7fc5c1/"/>
    <url>/posts/2c7fc5c1/</url>
    
    <content type="html"><![CDATA[<p>爱上大时代elementUI</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>elementUI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue case</title>
    <link href="/posts/888f2d51/"/>
    <url>/posts/888f2d51/</url>
    
    <content type="html"><![CDATA[<p>是vueasdad</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>bootstrap case</title>
    <link href="/posts/acf88edb/"/>
    <url>/posts/acf88edb/</url>
    
    <content type="html"><![CDATA[<p>bootstrapss112</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>bootstrap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>angular case</title>
    <link href="/posts/2f5c2e2e/"/>
    <url>/posts/2f5c2e2e/</url>
    
    <content type="html"><![CDATA[<p>爱上大时代sss</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>angular</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重构法则(下)</title>
    <link href="/posts/915cdc75/"/>
    <url>/posts/915cdc75/</url>
    
    <content type="html"><![CDATA[<p>重构下</p>]]></content>
    
    
    <categories>
      
      <category>重构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>重构</tag>
      
      <tag>架构</tag>
      
      <tag>设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重构法则(上)</title>
    <link href="/posts/8847ed34/"/>
    <url>/posts/8847ed34/</url>
    
    <content type="html"><![CDATA[<p>重构1sss</p>]]></content>
    
    
    <categories>
      
      <category>重构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>重构</tag>
      
      <tag>架构</tag>
      
      <tag>设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>备忘系列-swagger</title>
    <link href="/posts/a9fb96f4/"/>
    <url>/posts/a9fb96f4/</url>
    
    <content type="html"><![CDATA[<p>ss阿达达斯swa</p>]]></content>
    
    
    <categories>
      
      <category>swagger</category>
      
    </categories>
    
    
    <tags>
      
      <tag>swagger</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>备忘系列-docker</title>
    <link href="/posts/14e7ef72/"/>
    <url>/posts/14e7ef72/</url>
    
    <content type="html"><![CDATA[<p>doc</p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>备忘系列-maven使用指北</title>
    <link href="/posts/cc2d81c9/"/>
    <url>/posts/cc2d81c9/</url>
    
    <content type="html"><![CDATA[<p>mvn llalal</p>]]></content>
    
    
    <categories>
      
      <category>maven</category>
      
    </categories>
    
    
    <tags>
      
      <tag>maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>备忘系列-git使用指北</title>
    <link href="/posts/2581ce52/"/>
    <url>/posts/2581ce52/</url>
    
    <content type="html"><![CDATA[<p>ggg11</p>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>备忘系列-jenkins自动化与持续集成</title>
    <link href="/posts/aeac244/"/>
    <url>/posts/aeac244/</url>
    
    <content type="html"><![CDATA[<p>京津冀</p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jenkins</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mybatis is good. And plus is better.</title>
    <link href="/posts/85fa2e33/"/>
    <url>/posts/85fa2e33/</url>
    
    <content type="html"><![CDATA[<p>sss1111</p>]]></content>
    
    
    <categories>
      
      <category>mybatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mybatis</tag>
      
      <tag>mybatis-plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于SpringBoot</title>
    <link href="/posts/8358769a/"/>
    <url>/posts/8358769a/</url>
    
    <content type="html"><![CDATA[<p>llkkl123123</p>]]></content>
    
    
    <categories>
      
      <category>spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于SpringMVC</title>
    <link href="/posts/b3998b21/"/>
    <url>/posts/b3998b21/</url>
    
    <content type="html"><![CDATA[<p>ss213123</p>]]></content>
    
    
    <categories>
      
      <category>spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springMVC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于Spring</title>
    <link href="/posts/ed0120ab/"/>
    <url>/posts/ed0120ab/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring、SpringMVC、SpringBoot，开整</title>
    <link href="/posts/72086715/"/>
    <url>/posts/72086715/</url>
    
    <content type="html"><![CDATA[<p>事实上asdad</p>]]></content>
    
    
    <categories>
      
      <category>spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于并发编程（下）</title>
    <link href="/posts/a4f048b3/"/>
    <url>/posts/a4f048b3/</url>
    
    <content type="html"><![CDATA[<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402211423293.png"></p><hr><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><h3 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h3><h4 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h4><p>Java 内存模型是 Java Memory Model（JMM），本身是一种<strong>抽象的概念</strong>，实际上并不存在，描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式</p><p>JMM 作用：</p><ul><li><p>屏蔽各种硬件和操作系统的内存访问差异，实现让 Java 程序在各种平台下都能达到一致的内存访问效果</p></li><li><p>规定了线程和内存之间的一些关系</p></li></ul><p>根据 JMM 的设计，系统存在一个主内存（Main Memory），Java 中所有变量都存储在主存中，对于所有线程都是共享的；每条线程都有自己的工作内存（Working Memory），工作内存中保存的是主存中某些<strong>变量的拷贝</strong>，线程对所有变量的操作都是先对变量进行拷贝，然后在工作内存中进行，不能直接操作主内存中的变量；线程之间无法相互直接访问，线程间的通信（传递）必须通过主内存来完成</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041651883.png"></p><p>主内存和工作内存：</p><ul><li><p>主内存：计算机的内存，也就是经常提到的 8G 内存，16G 内存，存储所有共享变量的值</p></li><li><p>工作内存：存储该线程使用到的共享变量在主内存的的值的副本拷贝</p></li></ul><p><strong>JVM 和 JMM 之间的关系</strong>：JMM 中的主内存、工作内存与 JVM 中的 Java 堆、栈、方法区等并不是同一个层次的内存划分，这两者基本上是没有关系的，如果两者一定要勉强对应起来：</p><ul><li><p>主内存主要对应于 Java 堆中的对象实例数据部分，而工作内存则对应于虚拟机栈中的部分区域</p></li><li><p>从更低层次上说，主内存直接对应于物理硬件的内存，工作内存对应寄存器和高速缓存</p></li></ul><hr><h4 id="内存交互"><a href="#内存交互" class="headerlink" title="内存交互"></a>内存交互</h4><p>Java 内存模型定义了 8 个操作来完成主内存和工作内存的交互操作，每个操作都是<strong>原子</strong>的</p><p>非原子协定：没有被 volatile 修饰的 long、double 外，默认按照两次 32 位的操作</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041652749.png"></p><ul><li><p>lock：作用于主内存，将一个变量标识为被一个线程独占状态（对应 monitorenter）</p></li><li><p>unclock：作用于主内存，将一个变量从独占状态释放出来，释放后的变量才可以被其他线程锁定（对应 monitorexit）</p></li><li><p>read：作用于主内存，把一个变量的值从主内存传输到工作内存中</p></li><li><p>load：作用于工作内存，在 read 之后执行，把 read 得到的值放入工作内存的变量副本中</p></li><li><p>use：作用于工作内存，把工作内存中一个变量的值传递给<strong>执行引擎</strong>，每当遇到一个使用到变量的操作时都要使用该指令</p></li><li><p>assign：作用于工作内存，把从执行引擎接收到的一个值赋给工作内存的变量</p></li><li><p>store：作用于工作内存，把工作内存的一个变量的值传送到主内存中</p></li><li><p>write：作用于主内存，在 store 之后执行，把 store 得到的值放入主内存的变量中</p></li></ul><hr><h4 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h4><h5 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h5><p>可见性：是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值</p><p>存在不可见问题的根本原因是由于缓存的存在，线程持有的是共享变量的副本，无法感知其他线程对于共享变量的更改，导致读取的值不是最新的。但是 final 修饰的变量是<strong>不可变</strong>的，就算有缓存，也不会存在不可见的问题</p><p>main 线程对 run 变量的修改对于 t 线程不可见，导致了 t 线程无法停止：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">run</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">//添加volatile  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;  <br>        <span class="hljs-keyword">while</span>(run)&#123;  <br>        <span class="hljs-comment">// ....  </span><br>        &#125;  <br>&#125;);  <br>    t.start();  <br>    sleep(<span class="hljs-number">1</span>);  <br>    run = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 线程t不会如预想的停下来  </span><br>&#125;<br></code></pre></td></tr></table></figure><p>原因：</p><ul><li><p>初始状态， t 线程刚开始从主内存读取了 run 的值到工作内存</p></li><li><p>因为 t 线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值缓存至自己工作内存中的高速缓存中，减少对主存中 run 的访问，提高效率</p></li><li><p>1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量的值，结果永远是旧值</p></li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041653387.png"></p><hr><h5 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h5><p>原子性：不可分割，完整性，也就是说某个线程正在做某个具体业务时，中间不可以被分割，需要具体完成，要么同时成功，要么同时失败，保证指令不会受到线程上下文切换的影响</p><p>定义原子操作的使用规则：</p><ol><li><p>不允许 read 和 load、store 和 write 操作之一单独出现，必须顺序执行，但是不要求连续</p></li><li><p>不允许一个线程丢弃 assign 操作，必须同步回主存</p></li><li><p>不允许一个线程无原因地（没有发生过任何 assign 操作）把数据从工作内存同步会主内存中</p></li><li><p>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（assign 或者 load）的变量，即对一个变量实施 use 和 store 操作之前，必须先自行 assign 和 load 操作</p></li><li><p>一个变量在同一时刻只允许一条线程对其进行 lock 操作，但 lock 操作可以被同一线程重复执行多次，多次执行 lock 后，只有<strong>执行相同次数的 unlock</strong> 操作，变量才会被解锁，<strong>lock 和 unlock 必须成对出现</strong></p></li><li><p>如果对一个变量执行 lock 操作，将会<strong>清空工作内存中此变量的值</strong>，在执行引擎使用这个变量之前需要重新从主存加载</p></li><li><p>如果一个变量事先没有被 lock 操作锁定，则不允许执行 unlock 操作，也不允许去 unlock 一个被其他线程锁定的变量</p></li><li><p>对一个变量执行 unlock 操作之前，必须<strong>先把此变量同步到主内存</strong>中（执行 store 和 write 操作）</p></li></ol><hr><h5 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h5><p>有序性：在本线程内观察，所有操作都是有序的；在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序</p><p>CPU 的基本工作是执行存储的指令序列，即程序，程序的执行过程实际上是不断地取出指令、分析指令、执行指令的过程，为了提高性能，编译器和处理器会对指令重排，一般分为以下三种：</p><p>源代码 -&gt; 编译器优化的重排 -&gt; 指令并行的重排 -&gt; 内存系统的重排 -&gt; 最终执行指令</p><p>现代 CPU 支持多级指令流水线，几乎所有的冯•诺伊曼型计算机的 CPU，其工作都可以分为 5 个阶段：取指令、指令译码、执行指令、访存取数和结果写回，可以称之为<strong>五级指令流水线</strong>。CPU 可以在一个时钟周期内，同时运行五条指令的<strong>不同阶段</strong>（每个线程不同的阶段），本质上流水线技术并不能缩短单条指令的执行时间，但变相地提高了指令地吞吐率</p><p>处理器在进行重排序时，必须要考虑<strong>指令之间的数据依赖性</strong></p><ul><li><p>单线程环境也存在指令重排，由于存在依赖性，最终执行结果和代码顺序的结果一致</p></li><li><p>多线程环境中线程交替执行，由于编译器优化重排，会获取其他线程处在不同阶段的指令同时执行</p></li></ul><p>补充知识：</p><ul><li><p>指令周期是取出一条指令并执行这条指令的时间，一般由若干个机器周期组成</p></li><li><p>机器周期也称为 CPU 周期，一条指令的执行过程划分为若干个阶段（如取指、译码、执行等），每一阶段完成一个基本操作，完成一个基本操作所需要的时间称为机器周期</p></li><li><p>振荡周期指周期性信号作周期性重复变化的时间间隔</p></li></ul><hr><h3 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h3><h4 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h4><h5 id="缓存结构"><a href="#缓存结构" class="headerlink" title="缓存结构"></a>缓存结构</h5><p>在计算机系统中，CPU 高速缓存（CPU Cache，简称缓存）是用于减少处理器访问内存所需平均时间的部件；在存储体系中位于自顶向下的第二层，仅次于 CPU 寄存器；其容量远小于内存，但速度却可以接近处理器的频率</p><p>CPU 处理器速度远远大于在主内存中的，为了解决速度差异，在它们之间架设了多级缓存，如 L1、L2、L3 级别的缓存，这些缓存离 CPU 越近就越快，将频繁操作的数据缓存到这里，加快访问速度</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041653288.png"></p><table><thead><tr><th>从 CPU 到</th><th>大约需要的时钟周期</th></tr></thead><tbody><tr><td>寄存器</td><td>1 cycle (4GHz 的 CPU 约为 0.25ns)</td></tr><tr><td>L1</td><td>3~4 cycle</td></tr><tr><td>L2</td><td>10~20 cycle</td></tr><tr><td>L3</td><td>40~45 cycle</td></tr><tr><td>内存</td><td>120~240 cycle</td></tr></tbody></table><h5 id="缓存使用"><a href="#缓存使用" class="headerlink" title="缓存使用"></a>缓存使用</h5><p>当处理器发出内存访问请求时，会先查看缓存内是否有请求数据，如果存在（命中），则不用访问内存直接返回该数据；如果不存在（失效），则要先把内存中的相应数据载入缓存，再将其返回处理器</p><p>缓存之所以有效，主要因为程序运行时对内存的访问呈现局部性（Locality）特征。既包括空间局部性（Spatial Locality），也包括时间局部性（Temporal Locality），有效利用这种局部性，缓存可以达到极高的命中率</p><hr><h4 id="伪共享"><a href="#伪共享" class="headerlink" title="伪共享"></a>伪共享</h4><p><strong>缓存以缓存行 cache line 为单位</strong>，每个缓存行对应着一块内存，一般是 64 byte（8 个 long），在 CPU 从主存获取数据时，以 cache line 为单位加载，于是相邻的数据会一并加载到缓存中</p><p>缓存会造成数据副本的产生，即同一份数据会缓存在不同核心的缓存行中，CPU 要保证数据的一致性，需要做到某个 CPU 核心更改了数据，其它 CPU 核心对应的<strong>整个缓存行必须失效</strong>，这就是伪共享</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041653250.png"></p><p>解决方法：</p><ul><li><p>padding：通过填充，让数据落在不同的 cache line 中</p></li><li><p>@Contended：原理参考 无锁 → Adder → 优化机制 → 伪共享</p></li></ul><p>Linux 查看 CPU 缓存行：</p><ul><li><p>命令：<code>cat /sys/devices/system/cpu/cpu0/cache/index0/coherency_line_size64</code></p></li><li><p>内存地址格式： [ 高位组标记 ] [ 低位索引 ] [ 偏移量 ]</p></li></ul><hr><h4 id="缓存一致"><a href="#缓存一致" class="headerlink" title="缓存一致"></a>缓存一致</h4><p>缓存一致性：当多个处理器运算任务都涉及到同一块主内存区域的时候，将可能导致各自的缓存数据不一样</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041655075.png"></p><p>MESI（Modified Exclusive Shared Or Invalid）是一种广泛使用的<strong>支持写回策略的缓存一致性协议</strong>，CPU 中每个缓存行（caceh line）使用 4 种状态进行标记（使用额外的两位 bit 表示)：</p><ul><li><p>M：被修改（Modified）</p><p>  该缓存行只被缓存在该 CPU 的缓存中，并且是被修改过的，与主存中的数据不一致 (dirty)，该缓存行中的内存需要写回 (write back) 主存。该状态的数据再次被修改不会发送广播，因为其他核心的数据已经在第一次修改时失效一次</p><p>  当被写回主存之后，该缓存行的状态会变成独享 (exclusive) 状态</p></li><li><p>E：独享的（Exclusive）</p><p>  该缓存行只被缓存在该 CPU 的缓存中，是未被修改过的 (clear)，与主存中数据一致，修改数据不需要通知其他 CPU 核心，该状态可以在任何时刻有其它 CPU 读取该内存时变成共享状态 (shared)</p><p>  当 CPU 修改该缓存行中内容时，该状态可以变成 Modified 状态</p></li><li><p>S：共享的（Shared）</p><p>  该状态意味着该缓存行可能被多个 CPU 缓存，并且各个缓存中的数据与主存数据一致，当 CPU 修改该缓存行中，会向其它 CPU 核心广播一个请求，使该缓存行变成无效状态 (Invalid)，然后再更新当前 Cache 里的数据</p></li><li><p>I：无效的（Invalid）</p><p>  该缓存是无效的，可能有其它 CPU 修改了该缓存行</p></li></ul><p>解决方法：各个处理器访问缓存时都遵循一些协议，在读写时要根据协议进行操作，协议主要有 MSI、MESI 等</p><hr><h4 id="处理机制"><a href="#处理机制" class="headerlink" title="处理机制"></a>处理机制</h4><p>单核 CPU 处理器会自动保证基本内存操作的原子性</p><p>多核 CPU 处理器，每个 CPU 处理器内维护了一块内存，每个内核内部维护着一块缓存，当多线程并发读写时，就会出现缓存数据不一致的情况。处理器提供：</p><ul><li><p>总线锁定：当处理器要操作共享变量时，在 BUS 总线上发出一个 LOCK 信号，其他处理器就无法操作这个共享变量，该操作会导致大量阻塞，从而增加系统的性能开销（<strong>平台级别的加锁</strong>）</p></li><li><p>缓存锁定：当处理器对缓存中的共享变量进行了操作，其他处理器有嗅探机制，将各自缓存中的该共享变量的失效，读取时会重新从主内存中读取最新的数据，基于 MESI 缓存一致性协议来实现</p></li></ul><p>有如下两种情况处理器不会使用缓存锁定：</p><ul><li><p>当操作的数据跨多个缓存行，或没被缓存在处理器内部，则处理器会使用总线锁定</p></li><li><p>有些处理器不支持缓存锁定，比如：Intel 486 和 Pentium 处理器也会调用总线锁定</p></li></ul><p>总线机制：</p><ul><li><p>总线嗅探：每个处理器通过嗅探在总线上传播的数据来检查自己缓存值是否过期了，当处理器发现自己的缓存对应的内存地址的数据被修改，就<strong>将当前处理器的缓存行设置为无效状态</strong>，当处理器对这个数据进行操作时，会重新从内存中把数据读取到处理器缓存中</p></li><li><p>总线风暴：当某个 CPU 核心更新了 Cache 中的数据，要把该事件广播通知到其他核心（<strong>写传播</strong>），CPU 需要每时每刻监听总线上的一切活动，但是不管别的核心的 Cache 是否缓存相同的数据，都需要发出一个广播事件，不断的从主内存嗅探和 CAS 循环，无效的交互会导致总线带宽达到峰值；因此不要大量使用 volatile 关键字，使用 volatile、syschonized 都需要根据实际场景</p></li></ul><hr><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><h4 id="同步机制"><a href="#同步机制" class="headerlink" title="同步机制"></a>同步机制</h4><p>volatile 是 Java 虚拟机提供的<strong>轻量级</strong>的同步机制（三大特性）</p><ul><li><p>保证可见性</p></li><li><p>不保证原子性</p></li><li><p>保证有序性（禁止指令重排）</p></li></ul><p>性能：volatile 修饰的变量进行读操作与普通变量几乎没什么差别，但是写操作相对慢一些，因为需要在本地代码中插入很多内存屏障来保证指令不会发生乱序执行，但是开销比锁要小</p><p>synchronized 无法禁止指令重排和处理器优化，为什么可以保证有序性可见性</p><ul><li><p>加了锁之后，只能有一个线程获得到了锁，获得不到锁的线程就要阻塞，所以同一时间只有一个线程执行，相当于单线程，由于数据依赖性的存在，单线程的指令重排是没有问题的</p></li><li><p>线程加锁前，将<strong>清空工作内存</strong>中共享变量的值，使用共享变量时需要从主内存中重新读取最新的值；线程解锁前，必须把共享变量的最新值<strong>刷新到主内存</strong>中（JMM 内存交互章节有讲）</p></li></ul><hr><h4 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h4><p>volatile 修饰的变量，可以禁用指令重排</p><p>指令重排实例：</p><ul><li><p>example 1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mySort</span><span class="hljs-params">()</span> &#123;  <br><span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">11</span>;<span class="hljs-comment">//语句1  </span><br><span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> <span class="hljs-number">12</span>;<span class="hljs-comment">//语句2  谁先执行效果一样  </span><br>x = x + <span class="hljs-number">5</span>;<span class="hljs-comment">//语句3  </span><br>y = x * x;<span class="hljs-comment">//语句4  </span><br>&#125;<br>    <br>执行顺序是：<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>、<span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>、<span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span><br><br>指令重排也有限制不会出现：<span class="hljs-number">4321</span>，语句 <span class="hljs-number">4</span> 需要依赖于 y 以及 x 的申明，因为存在数据依赖，无法首先执行<br></code></pre></td></tr></table></figure></li><li><p>example 2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br><span class="hljs-type">boolean</span> <span class="hljs-variable">ready</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;  <br><span class="hljs-comment">// 线程1 执行此方法  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor1</span><span class="hljs-params">(I_Result r)</span> &#123;  <br><span class="hljs-keyword">if</span>(ready) &#123;  <br>r.r1 = num + num;  <br>&#125; <span class="hljs-keyword">else</span> &#123;  <br>r.r1 = <span class="hljs-number">1</span>;  <br>&#125;  <br>&#125;  <br><span class="hljs-comment">// 线程2 执行此方法  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor2</span><span class="hljs-params">(I_Result r)</span> &#123;  <br>num = <span class="hljs-number">2</span>;  <br>ready = <span class="hljs-literal">true</span>;  <br>&#125;<br><br>情况一：线程 <span class="hljs-number">1</span> 先执行，ready = <span class="hljs-literal">false</span>，结果为 r.r1 = <span class="hljs-number">1</span><br><br>情况二：线程 <span class="hljs-number">2</span> 先执行 num = <span class="hljs-number">2</span>，但还没执行 ready = <span class="hljs-literal">true</span>，线程 <span class="hljs-number">1</span> 执行，结果为 r.r1 = <span class="hljs-number">1</span><br><br>情况三：线程 <span class="hljs-number">2</span> 先执行 ready = <span class="hljs-literal">true</span>，线程 <span class="hljs-number">1</span> 执行，进入 <span class="hljs-keyword">if</span> 分支结果为 r.r1 = <span class="hljs-number">4</span><br><br>情况四：线程 <span class="hljs-number">2</span> 执行 ready = <span class="hljs-literal">true</span>，切换到线程 <span class="hljs-number">1</span>，进入 <span class="hljs-keyword">if</span> 分支为 r.r1 = <span class="hljs-number">0</span>，再切回线程 <span class="hljs-number">2</span> 执行 num = <span class="hljs-number">2</span>，发生指令重排<br></code></pre></td></tr></table></figure></li></ul><hr><h4 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h4><h5 id="缓存一致-1"><a href="#缓存一致-1" class="headerlink" title="缓存一致"></a>缓存一致</h5><p>使用 volatile 修饰的共享变量，底层通过汇编 lock 前缀指令进行缓存锁定，在线程修改完共享变量后写回主存，其他的 CPU 核心上运行的线程通过 CPU 总线嗅探机制会修改其共享变量为失效状态，读取时会重新从主内存中读取最新的数据</p><p>lock 前缀指令就相当于内存屏障，Memory Barrier（Memory Fence）</p><ul><li><p>对 volatile 变量的写指令后会加入写屏障</p></li><li><p>对 volatile 变量的读指令前会加入读屏障</p></li></ul><p>内存屏障有三个作用：</p><ul><li><p>确保对内存的读-改-写操作原子执行</p></li><li><p>阻止屏障两侧的指令重排序</p></li><li><p>强制把缓存中的脏数据写回主内存，让缓存行中相应的数据失效</p></li></ul><hr><h5 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h5><p>保证<strong>可见性</strong>：</p><ul><li><p>写屏障（sfence，Store Barrier）保证在该屏障之前的，对共享变量的改动，都同步到主存当中</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor2</span><span class="hljs-params">(I_Result r)</span> &#123;  <br>num = <span class="hljs-number">2</span>;  <br>ready = <span class="hljs-literal">true</span>; <span class="hljs-comment">// ready 是 volatile 赋值带写屏障  </span><br><span class="hljs-comment">// 写屏障  </span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>读屏障（lfence，Load Barrier）保证在该屏障之后的，对共享变量的读取，从主存刷新变量值，加载的是主存中最新数据</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor1</span><span class="hljs-params">(I_Result r)</span> &#123;  <br><span class="hljs-comment">// 读屏障  </span><br><span class="hljs-comment">// ready 是 volatile 读取值带读屏障  </span><br><span class="hljs-keyword">if</span>(ready) &#123;  <br>r.r1 = num + num;  <br>&#125; <span class="hljs-keyword">else</span> &#123;  <br>r.r1 = <span class="hljs-number">1</span>;  <br>&#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041658375.png"></p></li><li><p>全能屏障：mfence（modify&#x2F;mix Barrier），兼具 sfence 和 lfence 的功能</p></li></ul><p>保证<strong>有序性</strong>：</p><ul><li><p>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</p></li><li><p>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</p></li></ul><p>不能解决指令交错：</p><ul><li><p>写屏障仅仅是保证之后的读能够读到最新的结果，但不能保证其他线程的读跑到写屏障之前</p></li><li><p>有序性的保证也只是保证了本线程内相关代码不被重排序</p><p>  volatile i &#x3D; 0;<br>  new Thread(() -&gt; {i++});<br>  new Thread(() -&gt; {i–});</p><p>  i++ 反编译后的指令：</p><p>  0: iconst_1&#x2F;&#x2F; 当int取值 -1~5 时，JVM采用iconst指令将常量压入栈中<br>  1: istore_1&#x2F;&#x2F; 将操作数栈顶数据弹出，存入局部变量表的 slot 1<br>  2: iinc1, 1</p><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041659289.png"></p></li></ul><hr><h5 id="交互规则"><a href="#交互规则" class="headerlink" title="交互规则"></a>交互规则</h5><p>对于 volatile 修饰的变量：</p><ul><li><p>线程对变量的 use 与 load、read 操作是相关联的，所以变量使用前必须先从主存加载</p></li><li><p>线程对变量的 assign 与 store、write 操作是相关联的，所以变量使用后必须同步至主存</p></li><li><p>线程 1 和线程 2 谁先对变量执行 read 操作，就会先进行 write 操作，防止指令重排</p></li></ul><hr><h4 id="双端检锁"><a href="#双端检锁" class="headerlink" title="双端检锁"></a>双端检锁</h4><h5 id="检锁机制"><a href="#检锁机制" class="headerlink" title="检锁机制"></a>检锁机制</h5><p>Double-Checked Locking：双端检锁机制</p><p>DCL（双端检锁）机制不一定是线程安全的，原因是有指令重排的存在，加入 volatile 可以禁止指令重排</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123; &#125;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;  <br>      <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">if</span>(INSTANCE == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// t2，这里的判断不是线程安全的  </span><br>            <span class="hljs-comment">// 首次访问会同步，而之后的使用没有 synchronized  </span><br>            <span class="hljs-keyword">synchronized</span>(Singleton.class) &#123;  <br>                <span class="hljs-comment">// 这里是线程安全的判断，防止其他线程在当前线程等待锁的期间完成了初始化  </span><br>                <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-literal">null</span>) &#123;   <br>                    INSTANCE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();  <br>                &#125;  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> INSTANCE;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>不锁 INSTANCE 的原因：</p><ul><li><p>INSTANCE 要重新赋值</p></li><li><p>INSTANCE 是 null，线程加锁之前需要获取对象的引用，设置对象头，null 没有引用</p></li></ul><p>实现特点：</p><ul><li><p>懒惰初始化</p></li><li><p>首次使用 getInstance() 才使用 synchronized 加锁，后续使用时无需加锁</p></li><li><p>第一个 if 使用了 INSTANCE 变量，是在同步块之外，但在多线程环境下会产生问题</p></li></ul><hr><h5 id="DCL问题"><a href="#DCL问题" class="headerlink" title="DCL问题"></a>DCL问题</h5><p>getInstance 方法对应的字节码为：</p><figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs ldif"><br><span class="hljs-attribute">0</span>: getstatic <span class="hljs-comment">#2 // Field INSTANCE:Ltest/Singleton;  </span><br><span class="hljs-attribute">3</span>: ifnonnull 37  <br><span class="hljs-attribute">6</span>: ldc <span class="hljs-comment">#3 // class test/Singleton  </span><br><span class="hljs-attribute">8</span>: dup  <br><span class="hljs-attribute">9</span>: astore_0  <br><span class="hljs-attribute">10</span>: monitorenter  <br><span class="hljs-attribute">11</span>: getstatic <span class="hljs-comment">#2 // Field INSTANCE:Ltest/Singleton;  </span><br><span class="hljs-attribute">14</span>: ifnonnull 27  <br><span class="hljs-attribute">17</span>: new <span class="hljs-comment">#3 // class test/Singleton  </span><br><span class="hljs-attribute">20</span>: dup  <br><span class="hljs-attribute">21</span>: invokespecial <span class="hljs-comment">#4 // Method &quot;&lt;init&gt;&quot;:()V  </span><br><span class="hljs-attribute">24</span>: putstatic <span class="hljs-comment">#2 // Field INSTANCE:Ltest/Singleton;  </span><br><span class="hljs-attribute">27</span>: aload_0  <br><span class="hljs-attribute">28</span>: monitorexit  <br><span class="hljs-attribute">29</span>: goto 37  <br><span class="hljs-attribute">32</span>: astore_1  <br><span class="hljs-attribute">33</span>: aload_0  <br><span class="hljs-attribute">34</span>: monitorexit  <br><span class="hljs-attribute">35</span>: aload_1  <br><span class="hljs-attribute">36</span>: athrow  <br><span class="hljs-attribute">37</span>: getstatic <span class="hljs-comment">#2 // Field INSTANCE:Ltest/Singleton;  </span><br><span class="hljs-attribute">40</span>: areturn<br></code></pre></td></tr></table></figure><ul><li><p>17 表示创建对象，将对象引用入栈</p></li><li><p>20 表示复制一份对象引用，引用地址</p></li><li><p>21 表示利用一个对象引用，调用构造方法初始化对象</p></li><li><p>24 表示利用一个对象引用，赋值给 static INSTANCE</p></li></ul><p><strong>步骤 21 和 24 之间不存在数据依赖关系</strong>，而且无论重排前后，程序的执行结果在单线程中并没有改变，因此这种重排优化是允许的</p><ul><li><p>关键在于 0:getstatic 这行代码在 monitor 控制之外，可以越过 monitor 读取 INSTANCE 变量的值</p></li><li><p>当其他线程访问 INSTANCE 不为 null 时，由于 INSTANCE 实例未必已初始化，那么 t2 拿到的是将是一个未初始化完毕的单例返回，这就造成了线程安全的问题</p></li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041700443.png"></p><hr><h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><p>指令重排只会保证串行语义的执行一致性（单线程），但并不会关系多线程间的语义一致性</p><p>引入 volatile，来保证出现指令重排的问题，从而保证单例模式的线程安全性：</p><p><code>private static volatile SingletonDemo INSTANCE = null;</code></p><hr><h3 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h3><p>happens-before 先行发生</p><p>Java 内存模型具备一些先天的“有序性”，即不需要通过任何同步手段（volatile、synchronized 等）就能够得到保证的安全，这个通常也称为 happens-before 原则，它是可见性与有序性的一套规则总结</p><p>不符合 happens-before 规则，JMM 并不能保证一个线程的可见性和有序性</p><ol><li><p>程序次序规则 (Program Order Rule)：一个线程内，逻辑上书写在前面的操作先行发生于书写在后面的操作 ，因为多个操作之间有先后依赖关系，则不允许对这些操作进行重排序</p></li><li><p>锁定规则 (Monitor Lock Rule)：一个 unlock 操作先行发生于后面（时间的先后）对同一个锁的 lock 操作，所以线程解锁 m 之前对变量的写（解锁前会刷新到主内存中），对于接下来对 m 加锁的其它线程对该变量的读可见</p></li><li><p><strong>volatile 变量规则</strong> (Volatile Variable Rule)：对 volatile 变量的写操作先行发生于后面对这个变量的读</p></li><li><p>传递规则 (Transitivity)：具有传递性，如果操作 A 先行发生于操作 B，而操作 B 又先行发生于操作 C，则可以得出操作 A 先行发生于操作 C</p></li><li><p>线程启动规则 (Thread Start Rule)：Thread 对象的 start()方 法先行发生于此线程中的每一个操作</p><p> static int x &#x3D; 10;&#x2F;&#x2F;线程 start 前对变量的写，对该线程开始后对该变量的读可见<br> new Thread(()-&gt;{System.out.println(x);},”t1”).start();</p></li><li><p>线程中断规则 (Thread Interruption Rule)：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生</p></li><li><p>线程终止规则 (Thread Termination Rule)：线程中所有的操作都先行发生于线程的终止检测，可以通过 Thread.join() 方法结束、Thread.isAlive() 的返回值手段检测到线程已经终止执行</p></li><li><p>对象终结规则（Finaizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始</p></li></ol><hr><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><h4 id="终止模式"><a href="#终止模式" class="headerlink" title="终止模式"></a>终止模式</h4><p>终止模式之两阶段终止模式：停止标记用 volatile 是为了保证该变量在多个线程之间的可见性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TwoPhaseTermination</span> &#123;  <br>    <span class="hljs-comment">// 监控线程  </span><br>    <span class="hljs-keyword">private</span> Thread monitor;  <br>    <span class="hljs-comment">// 停止标记  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">stop</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;;  <br>  <br>    <span class="hljs-comment">// 启动监控线程  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;  <br>        monitor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;  <br>                <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> Thread.currentThread();  <br>                <span class="hljs-keyword">if</span> (stop) &#123;  <br>                    System.out.println(<span class="hljs-string">&quot;后置处理&quot;</span>);  <br>                    <span class="hljs-keyword">break</span>;  <br>                &#125;  <br>                <span class="hljs-keyword">try</span> &#123;  <br>                    Thread.sleep(<span class="hljs-number">1000</span>);<span class="hljs-comment">// 睡眠  </span><br>                    System.out.println(thread.getName() + <span class="hljs-string">&quot;执行监控记录&quot;</span>);  <br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>                   System.out.println(<span class="hljs-string">&quot;被打断，退出睡眠&quot;</span>);  <br>                &#125;  <br>            &#125;  <br>        &#125;);  <br>        monitor.start();  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 停止监控线程  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">()</span> &#123;  <br>        stop = <span class="hljs-literal">true</span>;  <br>        monitor.interrupt();<span class="hljs-comment">// 让线程尽快退出Timed Waiting  </span><br>    &#125;  <br>&#125;  <br><span class="hljs-comment">// 测试  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>    <span class="hljs-type">TwoPhaseTermination</span> <span class="hljs-variable">tpt</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TwoPhaseTermination</span>();  <br>    tpt.start();  <br>    Thread.sleep(<span class="hljs-number">3500</span>);  <br>    System.out.println(<span class="hljs-string">&quot;停止监控&quot;</span>);  <br>    tpt.stop();  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="Balking"><a href="#Balking" class="headerlink" title="Balking"></a>Balking</h4><p>Balking （犹豫）模式用在一个线程发现另一个线程或本线程已经做了某一件相同的事，那么本线程就无需再做了，直接结束返回</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MonitorService</span> </span>&#123;  <br>    <span class="hljs-comment">// 用来表示是否已经有线程已经在执行启动了  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> starting = <span class="hljs-keyword">false</span>;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;  <br>        System.out.println(<span class="hljs-string">&quot;尝试启动监控线程...&quot;</span>);  <br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;  <br>            <span class="hljs-keyword">if</span> (starting) &#123;  <br>            <span class="hljs-keyword">return</span>;  <br>            &#125;  <br>            starting = <span class="hljs-keyword">true</span>;  <br>        &#125;  <br>        <span class="hljs-comment">// 真正启动监控线程...  </span><br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>对比保护性暂停模式：保护性暂停模式用在一个线程等待另一个线程的执行结果，当条件不满足时线程等待</p><p>例子：希望 doInit() 方法仅被调用一次，下面的实现出现的问题：</p><ul><li><p>当 t1 线程进入 init() 准备 doInit()，t2 线程进来，initialized 还为f alse，则 t2 就又初始化一次</p></li><li><p>volatile 适合一个线程写，其他线程读的情况，这个代码需要加锁</p></li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TestVolatile</span> &#123;  <br>    <span class="hljs-keyword">volatile</span> boolean initialized = <span class="hljs-literal">false</span>;  <br>      <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span>()</span> &#123;  <br>        <span class="hljs-keyword">if</span> (initialized) &#123;  <br>            <span class="hljs-keyword">return</span>;  <br>        &#125;  <br>    doInit();  <br>    initialized = <span class="hljs-literal">true</span>;  <br>    &#125;  <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doInit</span>()</span> &#123;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h2><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>无锁编程：Lock Free</p><p>CAS 的全称是 Compare-And-Swap，是 <strong>CPU 并发原语</strong></p><ul><li><p>CAS 并发原语体现在 Java 语言中就是 sun.misc.Unsafe 类的各个方法，调用 UnSafe 类中的 CAS 方法，JVM 会实现出 CAS 汇编指令，这是一种完全依赖于硬件的功能，实现了原子操作</p></li><li><p>CAS 是一种系统原语，原语属于操作系统范畴，是由若干条指令组成 ，用于完成某个功能的一个过程，并且原语的执行必须是连续的，执行过程中不允许被中断，所以 CAS 是一条 CPU 的原子指令，不会造成数据不一致的问题，是线程安全的</p></li></ul><p>底层原理：CAS 的底层是 <code>lock cmpxchg</code> 指令（X86 架构），在单核和多核 CPU 下都能够保证比较交换的原子性</p><ul><li><p>程序是在单核处理器上运行，会省略 lock 前缀，单处理器自身会维护处理器内的顺序一致性，不需要 lock 前缀的内存屏障效果</p></li><li><p>程序是在多核处理器上运行，会为 cmpxchg 指令加上 lock 前缀。当某个核执行到带 lock 的指令时，CPU 会执行<strong>总线锁定或缓存锁定</strong>，将修改的变量写入到主存，这个过程不会被线程的调度机制所打断，保证了多个线程对内存操作的原子性</p></li></ul><p>作用：比较当前工作内存中的值和主物理内存中的值，如果相同则执行规定操作，否则继续比较直到主内存和工作内存的值一致为止</p><p>CAS 特点：</p><ul><li><p>CAS 体现的是<strong>无锁并发、无阻塞并发</strong>，线程不会陷入阻塞，线程不需要频繁切换状态（上下文切换，系统调用）</p></li><li><p>CAS 是基于乐观锁的思想</p></li></ul><p>CAS 缺点：</p><ul><li><p>执行的是循环操作，如果比较不成功一直在循环，最差的情况某个线程一直取到的值和预期值都不一样，就会无限循环导致饥饿，<strong>使用 CAS 线程数不要超过 CPU 的核心数</strong>，采用分段 CAS 和自动迁移机制</p></li><li><p>只能保证一个共享变量的原子操作</p><ul><li><p>对于一个共享变量执行操作时，可以通过循环 CAS 的方式来保证原子操作</p></li><li><p>对于多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候<strong>只能用锁来保证原子性</strong></p></li></ul></li><li><p>引出来 ABA 问题</p></li></ul><hr><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>CAS 与 synchronized 总结：</p><ul><li><p>synchronized 是从悲观的角度出发：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程），因此 synchronized 也称之为悲观锁，ReentrantLock 也是一种悲观锁，性能较差</p></li><li><p>CAS 是从乐观的角度出发：总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据。<strong>如果别人修改过，则获取现在最新的值，如果别人没修改过，直接修改共享数据的值</strong>，CAS 这种机制也称之为乐观锁，综合性能较好</p></li></ul><hr><h3 id="Atomic"><a href="#Atomic" class="headerlink" title="Atomic"></a>Atomic</h3><h4 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h4><p>常见原子类：AtomicInteger、AtomicBoolean、AtomicLong</p><p>构造方法：</p><ul><li><p><code>public AtomicInteger()</code>：初始化一个默认值为 0 的原子型 Integer</p></li><li><p><code>public AtomicInteger(int initialValue)</code>：初始化一个指定值的原子型 Integer</p></li></ul><p>常用API：</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>public final int get()</td><td>获取 AtomicInteger 的值</td></tr><tr><td>public final int getAndIncrement()</td><td>以原子方式将当前值加 1，返回的是自增前的值</td></tr><tr><td>public final int incrementAndGet()</td><td>以原子方式将当前值加 1，返回的是自增后的值</td></tr><tr><td>public final int getAndSet(int value)</td><td>以原子方式设置为 newValue 的值，返回旧值</td></tr><tr><td>public final int addAndGet(int data)</td><td>以原子方式将输入的数值与实例中的值相加并返回 实例：AtomicInteger 里的 value</td></tr></tbody></table><hr><h4 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h4><p><strong>AtomicInteger 原理</strong>：自旋锁 + CAS 算法</p><p>CAS 算法：有 3 个操作数（内存值 V， 旧的预期值 A，要修改的值 B）</p><ul><li><p>当旧的预期值 A &#x3D;&#x3D; 内存值 V 此时可以修改，将 V 改为 B</p></li><li><p>当旧的预期值 A !&#x3D; 内存值 V 此时不能修改，并重新获取现在的最新值，重新获取的动作就是自旋</p></li></ul><p>分析 getAndSet 方法：</p><ul><li><p>AtomicInteger：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public final <span class="hljs-built_in">int</span> get<span class="hljs-constructor">AndSet(<span class="hljs-params">int</span> <span class="hljs-params">newValue</span>)</span> &#123;  <br><span class="hljs-comment">/**  </span><br><span class="hljs-comment">* this: 当前对象  </span><br><span class="hljs-comment">* valueOffset:内存偏移量，内存地址  </span><br><span class="hljs-comment">*/</span>  <br>return unsafe.get<span class="hljs-constructor">AndSetInt(<span class="hljs-params">this</span>, <span class="hljs-params">valueOffset</span>, <span class="hljs-params">newValue</span>)</span>;  <br>&#125;<br>valueOffset：偏移量表示该变量值相对于当前对象地址的偏移，Unsafe 就是根据内存偏移地址获取数据<br><br>valueOffset = unsafe.objectFieldOffset  <br>(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AtomicInteger</span>.</span></span><span class="hljs-keyword">class</span>.get<span class="hljs-constructor">DeclaredField(<span class="hljs-string">&quot;value&quot;</span>)</span>);  <br><span class="hljs-comment">//调用本地方法   --&gt;  </span><br>public native long <span class="hljs-keyword">object</span><span class="hljs-constructor">FieldOffset(Field <span class="hljs-params">var1</span>)</span>;<br></code></pre></td></tr></table></figure></li><li><p>unsafe 类：</p></li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// val1: AtomicInteger对象本身，var2: 该对象值得引用地址，var4: 需要变动的数  </span><br>public final <span class="hljs-built_in">int</span> get<span class="hljs-constructor">AndSetInt(Object <span class="hljs-params">var1</span>, <span class="hljs-params">long</span> <span class="hljs-params">var2</span>, <span class="hljs-params">int</span> <span class="hljs-params">var4</span>)</span> &#123;  <br><span class="hljs-built_in">int</span> var5;  <br><span class="hljs-keyword">do</span> &#123;  <br><span class="hljs-comment">// var5: 用 var1 和 var2 找到的内存中的真实值  </span><br>var5 = this.get<span class="hljs-constructor">IntVolatile(<span class="hljs-params">var1</span>, <span class="hljs-params">var2</span>)</span>;  <br>&#125; <span class="hljs-keyword">while</span>(!this.compare<span class="hljs-constructor">AndSwapInt(<span class="hljs-params">var1</span>, <span class="hljs-params">var2</span>, <span class="hljs-params">var5</span>, <span class="hljs-params">var4</span>)</span>);  <br>return var5;  <br>&#125;<br><br><br>var5：从主内存中拷贝到工作内存中的值（每次都要从主内存拿到最新的值到本地内存），然后执行 `compare<span class="hljs-constructor">AndSwapInt()</span>` 再和主内存的值进行比较，假设方法返回 <span class="hljs-literal">false</span>，那么就一直执行 <span class="hljs-keyword">while</span> 方法，直到期望的值和真实值一样，修改数据<br></code></pre></td></tr></table></figure><ul><li><p>变量 value 用 volatile 修饰，保证了多线程之间的内存可见性，避免线程从工作缓存中获取失效的变量</p><p>  private volatile int value</p><p>  <strong>CAS 必须借助 volatile 才能读取到共享变量的最新值来实现比较并交换的效果</strong></p></li></ul><p>分析 getAndUpdate 方法：</p><ul><li><p>getAndUpdate：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndUpdate</span><span class="hljs-params">(IntUnaryOperator updateFunction)</span> &#123;  <br><span class="hljs-type">int</span> prev, next;  <br><span class="hljs-keyword">do</span> &#123;  <br>prev = get();<span class="hljs-comment">//当前值，cas的期望值  </span><br>next = updateFunction.applyAsInt(prev);<span class="hljs-comment">//期望值更新到该值  </span><br>&#125; <span class="hljs-keyword">while</span> (!compareAndSet(prev, next));<span class="hljs-comment">//自旋  </span><br><span class="hljs-keyword">return</span> prev;  <br>&#125;<br>    <br>函数式接口：可以自定义操作逻辑<br><br><span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();  <br>a.getAndUpdate(i -&gt; i + <span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure></li><li><p>compareAndSet：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSet</span><span class="hljs-params">(<span class="hljs-type">int</span> expect, <span class="hljs-type">int</span> update)</span> &#123;  <br><span class="hljs-comment">/**  </span><br><span class="hljs-comment">* this: 当前对象  </span><br><span class="hljs-comment">* valueOffset:内存偏移量，内存地址  </span><br><span class="hljs-comment">* expect:期望的值  </span><br><span class="hljs-comment">* update: 更新的值  </span><br><span class="hljs-comment">*/</span>  <br><span class="hljs-keyword">return</span> unsafe.compareAndSwapInt(<span class="hljs-built_in">this</span>, valueOffset, expect, update);  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h4 id="原子引用"><a href="#原子引用" class="headerlink" title="原子引用"></a>原子引用</h4><p>原子引用：对 Object 进行原子操作，提供一种读和写都是原子性的对象引用变量</p><p>原子引用类：AtomicReference、AtomicStampedReference、AtomicMarkableReference</p><p>AtomicReference 类：</p><ul><li><p>构造方法：<code>AtomicReference&lt;T&gt; atomicReference = new AtomicReference&lt;T&gt;()</code></p></li><li><p>常用 API：</p><ul><li><p><code>public final boolean compareAndSet(V expectedValue, V newValue)</code>：CAS 操作</p></li><li><p><code>public final void set(V newValue)</code>：将值设置为 newValue</p></li><li><p><code>public final V get()</code>：返回当前值</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicReferenceDemo</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-number">33</span>, <span class="hljs-string">&quot;z3&quot;</span>);  <br>          <br>        <span class="hljs-comment">// 创建原子引用包装类  </span><br>        AtomicReference&lt;Student&gt; atomicReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>&lt;&gt;();  <br>        <span class="hljs-comment">// 设置主内存共享变量为s1  </span><br>        atomicReference.set(s1);  <br>  <br>        <span class="hljs-comment">// 比较并交换，如果现在主物理内存的值为 z3，那么交换成 l4  </span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;  <br>            <span class="hljs-type">Student</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-number">44</span>, <span class="hljs-string">&quot;l4&quot;</span>);  <br>            <span class="hljs-keyword">if</span> (atomicReference.compareAndSet(s1, s2)) &#123;  <br>                <span class="hljs-keyword">break</span>;  <br>            &#125;  <br>        &#125;  <br>        System.out.println(atomicReference.get());  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;  <br>    <span class="hljs-keyword">private</span> String name;  <br>    <span class="hljs-comment">//。。。。  </span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="原子数组"><a href="#原子数组" class="headerlink" title="原子数组"></a>原子数组</h4><p>原子数组类：AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray</p><p>AtomicIntegerArray 类方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">/**  </span><br><span class="hljs-comment">*   ithe index  </span><br><span class="hljs-comment">* expect the expected value  </span><br><span class="hljs-comment">* update the new value  </span><br><span class="hljs-comment">*/</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSet</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> expect, <span class="hljs-type">int</span> update)</span> &#123;  <br>    <span class="hljs-keyword">return</span> compareAndSetRaw(checkedByteOffset(i), expect, update);  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="原子更新器"><a href="#原子更新器" class="headerlink" title="原子更新器"></a>原子更新器</h4><p>原子更新器类：AtomicReferenceFieldUpdater、AtomicIntegerFieldUpdater、AtomicLongFieldUpdater</p><p>利用字段更新器，可以针对对象的某个域（Field）进行原子操作，只能配合 volatile 修饰的字段使用，否则会出现异常 <code>IllegalArgumentException: Must be volatile type</code></p><p>常用 API：</p><ul><li><p><code>static &lt;U&gt; AtomicIntegerFieldUpdater&lt;U&gt; newUpdater(Class&lt;U&gt; c, String fieldName)</code>：构造方法</p></li><li><p><code>abstract boolean compareAndSet(T obj, int expect, int update)</code>：CAS</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UpdateDemo</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> field;  <br>      <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">AtomicIntegerFieldUpdater</span> <span class="hljs-variable">fieldUpdater</span> <span class="hljs-operator">=</span> AtomicIntegerFieldUpdater  <br>            .newUpdater(UpdateDemo.class, <span class="hljs-string">&quot;field&quot;</span>);  <br>        <span class="hljs-type">UpdateDemo</span> <span class="hljs-variable">updateDemo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UpdateDemo</span>();  <br>        fieldUpdater.compareAndSet(updateDemo, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>);  <br>        System.out.println(updateDemo.field);<span class="hljs-comment">//10  </span><br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="原子累加器"><a href="#原子累加器" class="headerlink" title="原子累加器"></a>原子累加器</h4><p>原子累加器类：LongAdder、DoubleAdder、LongAccumulator、DoubleAccumulator</p><p>LongAdder 和 LongAccumulator 区别：</p><p>相同点：</p><ul><li><p>LongAddr 与 LongAccumulator 类都是使用非阻塞算法 CAS 实现的</p></li><li><p>LongAddr 类是 LongAccumulator 类的一个特例，只是 LongAccumulator 提供了更强大的功能，可以自定义累加规则，当accumulatorFunction 为 null 时就等价于 LongAddr</p></li></ul><p>不同点：</p><ul><li><p>调用 casBase 时，LongAccumulator 使用 function.applyAsLong(b &#x3D; base, x) 来计算，LongAddr 使用 casBase(b &#x3D; base, b + x)</p></li><li><p>LongAccumulator 类功能更加强大，构造方法参数中</p><ul><li><p>accumulatorFunction 是一个双目运算器接口，可以指定累加规则，比如累加或者相乘，其根据输入的两个参数返回一个计算值，LongAdder 内置累加规则</p></li><li><p>identity 则是 LongAccumulator 累加器的初始值，LongAccumulator 可以为累加器提供非0的初始值，而 LongAdder 只能提供默认的 0</p></li></ul></li></ul><hr><h3 id="Adder"><a href="#Adder" class="headerlink" title="Adder"></a>Adder</h3><h4 id="优化机制"><a href="#优化机制" class="headerlink" title="优化机制"></a>优化机制</h4><p>LongAdder 是 Java8 提供的类，跟 AtomicLong 有相同的效果，但对 CAS 机制进行了优化，尝试使用分段 CAS 以及自动分段迁移的方式来大幅度提升多线程高并发执行 CAS 操作的性能</p><p>CAS 底层实现是在一个循环中不断地尝试修改目标值，直到修改成功。如果竞争不激烈修改成功率很高，否则失败率很高，失败后这些重复的原子性操作会耗费性能（导致大量线程<strong>空循环，自旋转</strong>）</p><p>优化核心思想：数据分离，将 AtomicLong 的<strong>单点的更新压力分担到各个节点，空间换时间</strong>，在低并发的时候直接更新，可以保障和 AtomicLong 的性能基本一致，而在高并发的时候通过分散减少竞争，提高了性能</p><p><strong>分段 CAS 机制</strong>：</p><ul><li><p>在发生竞争时，创建 Cell 数组用于将不同线程的操作离散（通过 hash 等算法映射）到不同的节点上</p></li><li><p>设置多个累加单元（会根据需要扩容，最大为 CPU 核数），Therad-0 累加 Cell[0]，而 Thread-1 累加 Cell[1] 等，最后将结果汇总</p></li><li><p>在累加时操作的不同的 Cell 变量，因此减少了 CAS 重试失败，从而提高性能</p></li></ul><p><strong>自动分段迁移机制</strong>：某个 Cell 的 value 执行 CAS 失败，就会自动寻找另一个 Cell 分段内的 value 值进行 CAS 操作</p><hr><h4 id="伪共享-1"><a href="#伪共享-1" class="headerlink" title="伪共享"></a>伪共享</h4><p>Cell 为累加单元：数组访问索引是通过 Thread 里的 threadLocalRandomProbe 域取模实现的，这个域是 ThreadLocalRandom 更新的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Striped64.Cell  </span><br><span class="hljs-meta">@sun</span>.misc.Contended <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cell</span> &#123;  <br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> value;  <br>    Cell(<span class="hljs-type">long</span> x) &#123; value = x; &#125;  <br>    <span class="hljs-comment">// 用 cas 方式进行累加, prev 表示旧值, next 表示新值  </span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">cas</span><span class="hljs-params">(<span class="hljs-type">long</span> prev, <span class="hljs-type">long</span> next)</span> &#123;  <br>    <span class="hljs-keyword">return</span> UNSAFE.compareAndSwapLong(<span class="hljs-built_in">this</span>, valueOffset, prev, next);  <br>    &#125;  <br>    <span class="hljs-comment">// 省略不重要代码  </span><br>&#125;<br></code></pre></td></tr></table></figure><p>Cell 是数组形式，<strong>在内存中是连续存储的</strong>，64 位系统中，一个 Cell 为 24 字节（16 字节的对象头和 8 字节的 value），每一个 cache line 为 64 字节，因此缓存行可以存下 2 个的 Cell 对象，当 Core-0 要修改 Cell[0]、Core-1 要修改 Cell[1]，无论谁修改成功都会导致当前缓存行失效，从而导致对方的数据失效，需要重新去主存获取，影响效率</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041706137.png"></p><p>@sun.misc.Contended：防止缓存行伪共享，在使用此注解的对象或字段的前后各增加 128 字节大小的 padding，使用 2 倍于大多数硬件缓存行让 CPU 将对象预读至缓存时<strong>占用不同的缓存行</strong>，这样就不会造成对方缓存行的失效</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041706578.png"></p><hr><h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h4><p>Striped64 类成员属性：</p><p>&#x2F;&#x2F; 表示当前计算机CPU数量<br>static final int NCPU &#x3D; Runtime.getRuntime().availableProcessors()<br>&#x2F;&#x2F; 累加单元数组, 懒惰初始化<br>transient volatile Cell[] cells;<br>&#x2F;&#x2F; 基础值, 如果没有竞争, 则用 cas 累加这个域，当 cells 扩容时，也会将数据写到 base 中<br>transient volatile long base;<br>&#x2F;&#x2F; 在 cells 初始化或扩容时只能有一个线程执行, 通过 CAS 更新 cellsBusy 置为 1 来实现一个锁<br>transient volatile int cellsBusy;</p><p>工作流程：</p><ul><li><p>cells 占用内存是相对比较大的，是惰性加载的，在无竞争或者其他线程正在初始化 cells 数组的情况下，直接更新 base 域</p></li><li><p>在第一次发生竞争时（casBase 失败）会创建一个大小为 2 的 cells 数组，将当前累加的值包装为 Cell 对象，放入映射的槽位上</p></li><li><p>分段累加的过程中，如果当前线程对应的 cells 槽位为空，就会新建 Cell 填充，如果出现竞争，就会重新计算线程对应的槽位，继续自旋尝试修改</p></li><li><p>分段迁移后还出现竞争就会扩容 cells 数组长度为原来的两倍，然后 rehash，<strong>数组长度总是 2 的 n 次幂</strong>，默认最大为 CPU 核数，但是可以超过，如果核数是 6 核，数组最长是 8</p></li></ul><p>方法分析：</p><p><strong>LongAdder#add：累加方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">long</span> x)</span> &#123;  <br>    <span class="hljs-comment">// as 为累加单元数组的引用，b 为基础值，v 表示期望值  </span><br>    <span class="hljs-comment">// m 表示 cells 数组的长度 - 1，a 表示当前线程命中的 cell 单元格  </span><br>    Cell[] as; <span class="hljs-type">long</span> b, v; <span class="hljs-type">int</span> m; Cell a;  <br>      <br>    <span class="hljs-comment">// cells 不为空说明 cells 已经被初始化，线程发生了竞争，去更新对应的 cell 槽位  </span><br>    <span class="hljs-comment">// 进入 || 后的逻辑去更新 base 域，更新失败表示发生竞争进入条件  </span><br>    <span class="hljs-keyword">if</span> ((as = cells) != <span class="hljs-literal">null</span> || !casBase(b = base, b + x)) &#123;  <br>        <span class="hljs-comment">// uncontended 为 true 表示 cell 没有竞争  </span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">uncontended</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;  <br>          <br>        <span class="hljs-comment">// 条件一: true 说明 cells 未初始化，多线程写 base 发生竞争需要进行初始化 cells 数组  </span><br>        <span class="hljs-comment">//  fasle 说明 cells 已经初始化，进行下一个条件寻找自己的 cell 去累加  </span><br>        <span class="hljs-comment">// 条件二: getProbe() 获取 hash 值，&amp; m 的逻辑和 HashMap 的逻辑相同，保证散列的均匀性  </span><br>        <span class="hljs-comment">//   true 说明当前线程对应下标的 cell 为空，需要创建 cell  </span><br>        <span class="hljs-comment">//        false 说明当前线程对应的 cell 不为空，进行下一个条件【将 x 值累加到对应的 cell 中】  </span><br>        <span class="hljs-comment">// 条件三: 有取反符号，false 说明 cas 成功，直接返回，true 说明失败，当前线程对应的 cell 有竞争  </span><br>        <span class="hljs-keyword">if</span> (as == <span class="hljs-literal">null</span> || (m = as.length - <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span> ||  <br>            (a = as[getProbe() &amp; m]) == <span class="hljs-literal">null</span> ||  <br>            !(uncontended = a.cas(v = a.value, v + x)))  <br>            longAccumulate(x, <span class="hljs-literal">null</span>, uncontended);  <br>        <span class="hljs-comment">// 【uncontended 在对应的 cell 上累加失败的时候才为 false，其余情况均为 true】  </span><br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Striped64#longAccumulate：cell 数组创建</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// x  null false | true  </span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">longAccumulate</span><span class="hljs-params">(<span class="hljs-type">long</span> x, LongBinaryOperator fn, <span class="hljs-type">boolean</span> wasUncontended)</span> &#123;  <br><span class="hljs-type">int</span> h;  <br><span class="hljs-comment">// 当前线程还没有对应的 cell, 需要随机生成一个 hash 值用来将当前线程绑定到 cell  </span><br><span class="hljs-keyword">if</span> ((h = getProbe()) == <span class="hljs-number">0</span>) &#123;  <br><span class="hljs-comment">// 初始化 probe，获取 hash 值  </span><br>ThreadLocalRandom.current();   <br>h = getProbe();  <br><span class="hljs-comment">// 默认情况下 当前线程肯定是写入到了 cells[0] 位置，不把它当做一次真正的竞争  </span><br>wasUncontended = <span class="hljs-literal">true</span>;  <br>&#125;  <br><span class="hljs-comment">// 表示【扩容意向】，false 一定不会扩容，true 可能会扩容  </span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">collide</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;   <br><span class="hljs-comment">//自旋  </span><br><span class="hljs-keyword">for</span> (;;) &#123;  <br><span class="hljs-comment">// as 表示cells引用，a 表示当前线程命中的 cell，n 表示 cells 数组长度，v 表示 期望值  </span><br>Cell[] as; Cell a; <span class="hljs-type">int</span> n; <span class="hljs-type">long</span> v;  <br><span class="hljs-comment">// 【CASE1】: 表示 cells 已经初始化了，当前线程应该将数据写入到对应的 cell 中  </span><br><span class="hljs-keyword">if</span> ((as = cells) != <span class="hljs-literal">null</span> &amp;&amp; (n = as.length) &gt; <span class="hljs-number">0</span>) &#123;  <br><span class="hljs-comment">// CASE1.1: true 表示当前线程对应的索引下标的 Cell 为 null，需要创建 new Cell  </span><br><span class="hljs-keyword">if</span> ((a = as[(n - <span class="hljs-number">1</span>) &amp; h]) == <span class="hljs-literal">null</span>) &#123;  <br><span class="hljs-comment">// 判断 cellsBusy 是否被锁  </span><br><span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span>) &#123;     <br><span class="hljs-comment">// 创建 cell, 初始累加值为 x  </span><br><span class="hljs-type">Cell</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cell</span>(x);    <br><span class="hljs-comment">// 加锁  </span><br><span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp; casCellsBusy()) &#123;  <br><span class="hljs-comment">// 创建成功标记，进入【创建 cell 逻辑】  </span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">created</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;  <br><span class="hljs-keyword">try</span> &#123;  <br>Cell[] rs; <span class="hljs-type">int</span> m, j;  <br><span class="hljs-comment">// 把当前 cells 数组赋值给 rs，并且不为 null  </span><br><span class="hljs-keyword">if</span> ((rs = cells) != <span class="hljs-literal">null</span> &amp;&amp;  <br>(m = rs.length) &gt; <span class="hljs-number">0</span> &amp;&amp;  <br><span class="hljs-comment">// 再次判断防止其它线程初始化过该位置，当前线程再次初始化该位置会造成数据丢失  </span><br><span class="hljs-comment">// 因为这里是线程安全的判断，进行的逻辑不会被其他线程影响  </span><br>rs[j = (m - <span class="hljs-number">1</span>) &amp; h] == <span class="hljs-literal">null</span>) &#123;  <br><span class="hljs-comment">// 把新创建的 cell 填充至当前位置  </span><br>rs[j] = r;  <br>created = <span class="hljs-literal">true</span>;<span class="hljs-comment">// 表示创建完成  </span><br>&#125;  <br>&#125; <span class="hljs-keyword">finally</span> &#123;  <br>cellsBusy = <span class="hljs-number">0</span>;<span class="hljs-comment">// 解锁  </span><br>&#125;  <br><span class="hljs-keyword">if</span> (created)<span class="hljs-comment">// true 表示创建完成，可以推出循环了  </span><br><span class="hljs-keyword">break</span>;  <br><span class="hljs-keyword">continue</span>;  <br>&#125;  <br>&#125;  <br>collide = <span class="hljs-literal">false</span>;  <br>&#125;  <br><span class="hljs-comment">// CASE1.2: 条件成立说明线程对应的 cell 有竞争, 改变线程对应的 cell 来重试 cas  </span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!wasUncontended)  <br>wasUncontended = <span class="hljs-literal">true</span>;  <br><span class="hljs-comment">// CASE 1.3: 当前线程 rehash 过，如果新命中的 cell 不为空，就尝试累加，false 说明新命中也有竞争  </span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a.cas(v = a.value, ((fn == <span class="hljs-literal">null</span>) ? v + x : fn.applyAsLong(v, x))))  <br><span class="hljs-keyword">break</span>;  <br><span class="hljs-comment">// CASE 1.4: cells 长度已经超过了最大长度 CPU 内核的数量或者已经扩容  </span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n &gt;= NCPU || cells != as)  <br>collide = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 扩容意向改为false，【表示不能扩容了】  </span><br><span class="hljs-comment">// CASE 1.5: 更改扩容意向，如果 n &gt;= NCPU，这里就永远不会执行到，case1.4 永远先于 1.5 执行  </span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!collide)  <br>collide = <span class="hljs-literal">true</span>;  <br><span class="hljs-comment">// CASE 1.6: 【扩容逻辑】，进行加锁  </span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp; casCellsBusy()) &#123;  <br><span class="hljs-keyword">try</span> &#123;  <br><span class="hljs-comment">// 线程安全的检查，防止期间被其他线程扩容了  </span><br><span class="hljs-keyword">if</span> (cells == as) &#123;       <br><span class="hljs-comment">// 扩容为以前的 2 倍  </span><br>Cell[] rs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cell</span>[n &lt;&lt; <span class="hljs-number">1</span>];  <br><span class="hljs-comment">// 遍历移动值  </span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)  <br>rs[i] = as[i];  <br><span class="hljs-comment">// 把扩容后的引用给 cells  </span><br>cells = rs;  <br>&#125;  <br>&#125; <span class="hljs-keyword">finally</span> &#123;  <br>cellsBusy = <span class="hljs-number">0</span>;<span class="hljs-comment">// 解锁  </span><br>&#125;  <br>collide = <span class="hljs-literal">false</span>;<span class="hljs-comment">// 扩容意向改为 false，表示不扩容了  </span><br><span class="hljs-keyword">continue</span>;  <br>&#125;  <br><span class="hljs-comment">// 重置当前线程 Hash 值，这就是【分段迁移机制】  </span><br>h = advanceProbe(h);  <br>&#125;  <br>  <br><span class="hljs-comment">// 【CASE2】: 运行到这说明 cells 还未初始化，as 为null  </span><br><span class="hljs-comment">// 判断是否没有加锁，没有加锁就用 CAS 加锁  </span><br><span class="hljs-comment">// 条件二判断是否其它线程在当前线程给 as 赋值之后修改了 cells，这里不是线程安全的判断  </span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;  <br><span class="hljs-comment">// 初始化标志，开始 【初始化 cells 数组】  </span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">init</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;  <br><span class="hljs-keyword">try</span> &#123;   <br><span class="hljs-comment">// 再次判断 cells == as 防止其它线程已经提前初始化了，当前线程再次初始化导致丢失数据  </span><br><span class="hljs-comment">// 因为这里是【线程安全的，重新检查，经典 DCL】  </span><br><span class="hljs-keyword">if</span> (cells == as) &#123;  <br>Cell[] rs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cell</span>[<span class="hljs-number">2</span>];<span class="hljs-comment">// 初始化数组大小为2  </span><br>rs[h &amp; <span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cell</span>(x);<span class="hljs-comment">// 填充线程对应的cell  </span><br>cells = rs;  <br>init = <span class="hljs-literal">true</span>;<span class="hljs-comment">// 初始化成功，标记置为 true  </span><br>&#125;  <br>&#125; <span class="hljs-keyword">finally</span> &#123;  <br>cellsBusy = <span class="hljs-number">0</span>;<span class="hljs-comment">// 解锁啊  </span><br>&#125;  <br><span class="hljs-keyword">if</span> (init)  <br><span class="hljs-keyword">break</span>;<span class="hljs-comment">// 初始化成功直接跳出自旋  </span><br>&#125;  <br><span class="hljs-comment">// 【CASE3】: 运行到这说明其他线程在初始化 cells，当前线程将值累加到 base，累加成功直接结束自旋  </span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (casBase(v = base, ((fn == <span class="hljs-literal">null</span>) ? v + x :  <br>fn.applyAsLong(v, x))))  <br><span class="hljs-keyword">break</span>;   <br>&#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>sum：获取最终结果通过 sum 整合，保证最终一致性，不保证强一致性</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">sum</span><span class="hljs-params">()</span> &#123;  <br>Cell[] as = cells; Cell a;  <br><span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> base;  <br><span class="hljs-keyword">if</span> (as != <span class="hljs-literal">null</span>) &#123;  <br><span class="hljs-comment">// 遍历 累加  </span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; as.length; ++i) &#123;  <br><span class="hljs-keyword">if</span> ((a = as[i]) != <span class="hljs-literal">null</span>)  <br>sum += a.value;  <br>&#125;  <br>&#125;  <br><span class="hljs-keyword">return</span> sum;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="ABA"><a href="#ABA" class="headerlink" title="ABA"></a>ABA</h3><p>ABA 问题：当进行获取主内存值时，该内存值在写入主内存时已经被修改了 N 次，但是最终又改成原来的值</p><p>其他线程先把 A 改成 B 又改回 A，主线程<strong>仅能判断出共享变量的值与最初值 A 是否相同</strong>，不能感知到这种从 A 改为 B 又 改回 A 的情况，这时 CAS 虽然成功，但是过程存在问题</p><ul><li><p>构造方法：</p><ul><li><code>public AtomicStampedReference(V initialRef, int initialStamp)</code>：初始值和初始版本号</li></ul></li><li><p>常用API：</p><ul><li><p><code>public boolean compareAndSet(V expectedReference, V newReference, int expectedStamp, int newStamp)</code>：<strong>期望引用和期望版本号都一致</strong>才进行 CAS 修改数据</p></li><li><p><code>public void set(V newReference, int newStamp)</code>：设置值和版本号</p></li><li><p><code>public V getReference()</code>：返回引用的值</p></li><li><p><code>public int getStamp()</code>：返回当前版本号</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    AtomicStampedReference&lt;Integer&gt; atomicReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicStampedReference</span>&lt;&gt;(<span class="hljs-number">100</span>,<span class="hljs-number">1</span>);  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">startStamp</span> <span class="hljs-operator">=</span> atomicReference.getStamp();  <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt;&#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> atomicReference.getStamp();  <br>        atomicReference.compareAndSet(<span class="hljs-number">100</span>, <span class="hljs-number">101</span>, stamp, stamp + <span class="hljs-number">1</span>);  <br>        stamp = atomicReference.getStamp();  <br>        atomicReference.compareAndSet(<span class="hljs-number">101</span>, <span class="hljs-number">100</span>, stamp, stamp + <span class="hljs-number">1</span>);  <br>    &#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();  <br>  <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt;&#123;  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            Thread.sleep(<span class="hljs-number">1000</span>);  <br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>            e.printStackTrace();  <br>        &#125;  <br>        <span class="hljs-keyword">if</span> (!atomicReference.compareAndSet(<span class="hljs-number">100</span>, <span class="hljs-number">200</span>, startStamp, startStamp + <span class="hljs-number">1</span>)) &#123;  <br>            System.out.println(atomicReference.getReference());<span class="hljs-comment">//100  </span><br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;线程修改失败&quot;</span>);  <br>        &#125;  <br>    &#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();  <br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h3 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h3><p>Unsafe 是 CAS 的核心类，由于 Java 无法直接访问底层系统，需要通过本地（Native）方法来访问</p><p>Unsafe 类存在 sun.misc 包，其中所有方法都是 native 修饰的，都是直接调用<strong>操作系统底层资源</strong>执行相应的任务，基于该类可以直接操作特定的内存数据，其内部方法操作类似 C 的指针</p><p>模拟实现原子整数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    <span class="hljs-type">MyAtomicInteger</span> <span class="hljs-variable">atomicInteger</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyAtomicInteger</span>(<span class="hljs-number">10</span>);  <br>    <span class="hljs-keyword">if</span> (atomicInteger.compareAndSwap(<span class="hljs-number">20</span>)) &#123;  <br>        System.out.println(atomicInteger.getValue());  <br>    &#125;  <br>&#125;  <br>​  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAtomicInteger</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Unsafe UNSAFE;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> VALUE_OFFSET;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> value;  <br>​  <br>    <span class="hljs-keyword">static</span> &#123;  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            <span class="hljs-comment">//Unsafe unsafe = Unsafe.getUnsafe()这样会报错，需要反射获取  </span><br>            <span class="hljs-type">Field</span> <span class="hljs-variable">theUnsafe</span> <span class="hljs-operator">=</span> Unsafe.class.getDeclaredField(<span class="hljs-string">&quot;theUnsafe&quot;</span>);  <br>            theUnsafe.setAccessible(<span class="hljs-literal">true</span>);  <br>            UNSAFE = (Unsafe) theUnsafe.get(<span class="hljs-literal">null</span>);  <br>            <span class="hljs-comment">// 获取 value 属性的内存地址，value 属性指向该地址，直接设置该地址的值可以修改 value 的值  </span><br>            VALUE_OFFSET = UNSAFE.objectFieldOffset(  <br>                           MyAtomicInteger.class.getDeclaredField(<span class="hljs-string">&quot;value&quot;</span>));  <br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;  <br>            e.printStackTrace();  <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>();  <br>        &#125;  <br>    &#125;  <br>​  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyAtomicInteger</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.value = value;  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> value;  <br>    &#125;  <br>​  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSwap</span><span class="hljs-params">(<span class="hljs-type">int</span> update)</span> &#123;  <br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;  <br>            <span class="hljs-type">int</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.value;  <br>            <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> update;  <br>            <span class="hljs-comment">//  当前对象  内存偏移量    期望值 更新值  </span><br>            <span class="hljs-keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="hljs-built_in">this</span>, VALUE_OFFSET, prev, update)) &#123;  <br>                System.out.println(<span class="hljs-string">&quot;CAS成功&quot;</span>);  <br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestFinal</span> &#123;  <br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;  <br>&#125;<br><br>字节码：<br><br><span class="hljs-number">0</span>: aload_0  <br><span class="hljs-number">1</span>: invokespecial #<span class="hljs-number">1</span> <span class="hljs-comment">// Method java/lang/Object.&quot;&lt; init&gt;&quot;:()V  </span><br><span class="hljs-number">4</span>: aload_0  <br><span class="hljs-number">5</span>: bipush <span class="hljs-number">20</span><span class="hljs-comment">// 将值直接放入栈中  </span><br><span class="hljs-number">7</span>: putfield #<span class="hljs-number">2</span> <span class="hljs-comment">// Field a:I  </span><br>&lt;-- 写屏障  <br><span class="hljs-number">10</span>: <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><p>final 变量的赋值通过 putfield 指令来完成，在这条指令之后也会加入写屏障，保证在其它线程读到它的值时不会出现为 0 的情况</p><p>其他线程访问 final 修饰的变量</p><ul><li><p><strong>复制一份放入栈中</strong>直接访问，效率高</p></li><li><p>大于 short 最大值会将其复制到类的常量池，访问时从常量池获取</p></li></ul><hr><h4 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h4><p>不可变：如果一个对象不能够修改其内部状态（属性），那么就是不可变对象</p><p>不可变对象线程安全的，不存在并发修改和可见性问题，是另一种避免竞争的方式</p><p>String 类也是不可变的，该类和类中所有属性都是 final 的</p><ul><li><p>类用 final 修饰保证了该类中的方法不能被覆盖，防止子类无意间破坏不可变性</p></li><li><p>无写入方法（set）确保外部不能对内部属性进行修改</p></li><li><p>属性用 final 修饰保证了该属性是只读的，不能修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span>  <br><span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;  <br><span class="hljs-comment">/** The value is used for character storage. */</span>  <br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span> value[];  <br><span class="hljs-comment">//....  </span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>更改 String 类数据时，会构造新字符串对象，生成新的 char[] value，通过<strong>创建副本对象来避免共享的方式称之为保护性拷贝</strong></p></li></ul><hr><h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p>无状态：成员变量保存的数据也可以称为状态信息，无状态就是没有成员变量</p><p>Servlet 为了保证其线程安全，一般不为 Servlet 设置成员变量，这种没有任何成员变量的类是线程安全的</p><hr><h3 id="Local"><a href="#Local" class="headerlink" title="Local"></a>Local</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>ThreadLocal 类用来提供线程内部的局部变量，这种变量在多线程环境下访问（通过 get 和 set 方法访问）时能保证各个线程的变量相对独立于其他线程内的变量，分配在堆内的 <strong>TLAB</strong> 中</p><p>ThreadLocal 实例通常来说都是 <code>private static</code> 类型的，属于一个线程的本地变量，用于关联线程和线程上下文。每个线程都会在 ThreadLocal 中保存一份该线程独有的数据，所以是线程安全的</p><p>ThreadLocal 作用：</p><ul><li><p>线程并发：应用在多线程并发的场景下</p></li><li><p>传递数据：通过 ThreadLocal 实现在同一线程不同函数或组件中传递公共变量，减少传递复杂度</p></li><li><p>线程隔离：每个线程的变量都是独立的，不会互相影响</p></li></ul><p>对比 synchronized：</p><table><thead><tr><th></th><th>synchronized</th><th>ThreadLocal</th></tr></thead><tbody><tr><td>原理</td><td>同步机制采用<strong>以时间换空间</strong>的方式，只提供了一份变量，让不同的线程排队访问</td><td>ThreadLocal 采用<strong>以空间换时间</strong>的方式，为每个线程都提供了一份变量的副本，从而实现同时访问而相不干扰</td></tr><tr><td>侧重点</td><td>多个线程之间访问资源的同步</td><td>多线程中让每个线程之间的数据相互隔离</td></tr></tbody></table><hr><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><h5 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h5><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>ThreadLocal&lt;&gt;()</td><td>创建 ThreadLocal 对象</td></tr><tr><td>protected T initialValue()</td><td>返回当前线程局部变量的初始值</td></tr><tr><td>public void set( T value)</td><td>设置当前线程绑定的局部变量</td></tr><tr><td>public T get()</td><td>获取当前线程绑定的局部变量</td></tr><tr><td>public void remove()</td><td>移除当前线程绑定的局部变量</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyDemo</span> &#123;  <br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;String&gt; tl = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();  <br>  <br>    <span class="hljs-keyword">private</span> String content;  <br>  <br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getContent</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-comment">// 获取当前线程绑定的变量  </span><br>        <span class="hljs-keyword">return</span> tl.get();  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setContent</span><span class="hljs-params">(String content)</span> &#123;  <br>        <span class="hljs-comment">// 变量content绑定到当前线程  </span><br>        tl.set(content);  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">MyDemo</span> <span class="hljs-variable">demo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyDemo</span>();  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;  <br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;  <br>                <span class="hljs-meta">@Override</span>  <br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>                    <span class="hljs-comment">// 设置数据  </span><br>                    demo.setContent(Thread.currentThread().getName() + <span class="hljs-string">&quot;的数据&quot;</span>);  <br>                    System.out.println(<span class="hljs-string">&quot;-----------------------&quot;</span>);  <br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;---&gt;&quot;</span> + demo.getContent());  <br>                &#125;  <br>            &#125;);  <br>            thread.setName(<span class="hljs-string">&quot;线程&quot;</span> + i);  <br>            thread.start();  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h5><p>ThreadLocal 适用于下面两种场景：</p><ul><li><p>每个线程需要有自己单独的实例</p></li><li><p>实例需要在多个方法中共享，但不希望被多线程共享</p></li></ul><p>ThreadLocal 方案有两个突出的优势：</p><ol><li><p>传递数据：保存每个线程绑定的数据，在需要的地方可以直接获取，避免参数直接传递带来的代码耦合问题</p></li><li><p>线程隔离：各线程之间的数据相互隔离却又具备并发性，避免同步方式带来的性能损失</p></li></ol><p>ThreadLocal 用于数据连接的事务管理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JdbcUtils</span> &#123;  <br>    <span class="hljs-comment">// ThreadLocal对象，将connection绑定在当前线程中  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;Connection&gt; tl = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>();  <br>    <span class="hljs-comment">// c3p0 数据库连接池对象属性  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ComboPooledDataSource</span> <span class="hljs-variable">ds</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ComboPooledDataSource</span>();  <br>    <span class="hljs-comment">// 获取连接  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;  <br>        <span class="hljs-comment">//取出当前线程绑定的connection对象  </span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> tl.get();  <br>        <span class="hljs-keyword">if</span> (conn == <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-comment">//如果没有，则从连接池中取出  </span><br>            conn = ds.getConnection();  <br>            <span class="hljs-comment">//再将connection对象绑定到当前线程中，非常重要的操作  </span><br>            tl.set(conn);  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> conn;  <br>    &#125;  <br><span class="hljs-comment">// ...  </span><br>&#125;<br></code></pre></td></tr></table></figure><p>用 ThreadLocal 使 SimpleDateFormat 从独享变量变成单个线程变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalDateUtil</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;DateFormat&gt; threadLocal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;DateFormat&gt;() &#123;  <br>        <span class="hljs-meta">@Override</span>  <br>        <span class="hljs-keyword">protected</span> DateFormat <span class="hljs-title function_">initialValue</span><span class="hljs-params">()</span> &#123;  <br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);  <br>        &#125;  <br>    &#125;;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Date <span class="hljs-title function_">parse</span><span class="hljs-params">(String dateStr)</span> <span class="hljs-keyword">throws</span> ParseException &#123;  <br>        <span class="hljs-keyword">return</span> threadLocal.get().parse(dateStr);  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">format</span><span class="hljs-params">(Date date)</span> &#123;  <br>        <span class="hljs-keyword">return</span> threadLocal.get().format(date);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><h5 id="底层结构"><a href="#底层结构" class="headerlink" title="底层结构"></a>底层结构</h5><p>JDK8 以前：每个 ThreadLocal 都创建一个 Map，然后用线程作为 Map 的 key，要存储的局部变量作为 Map 的 value，达到各个线程的局部变量隔离的效果。这种结构会造成 Map 结构过大和内存泄露，因为 Thread 停止后无法通过 key 删除对应的数据</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041721661.png"></p><p>JDK8 以后：每个 Thread 维护一个 ThreadLocalMap，这个 Map 的 key 是 ThreadLocal 实例本身，value 是真正要存储的值</p><ul><li><p><strong>每个 Thread 线程内部都有一个 Map (ThreadLocalMap)</strong></p></li><li><p>Map 里面存储 ThreadLocal 对象（key）和线程的私有变量（value）</p></li><li><p>Thread 内部的 Map 是由 ThreadLocal 维护的，由 ThreadLocal 负责向 map 获取和设置线程的变量值</p></li><li><p>对于不同的线程，每次获取副本值时，别的线程并不能获取到当前线程的副本值，形成副本的隔离，互不干扰</p></li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041722540.png"></p><p>JDK8 前后对比：</p><ul><li><p>每个 Map 存储的 Entry 数量会变少，因为之前的存储数量由 Thread 的数量决定，现在由 ThreadLocal 的数量决定，在实际编程当中，往往 ThreadLocal 的数量要少于 Thread 的数量</p></li><li><p>当 Thread 销毁之后，对应的 ThreadLocalMap 也会随之销毁，能减少内存的使用，<strong>防止内存泄露</strong></p></li></ul><hr><h5 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h5><ul><li><p>Thread 类的相关属性：<strong>每一个线程持有一个 ThreadLocalMap 对象</strong>，存放由 ThreadLocal 和数据组成的 Entry 键值对</p><p>  ThreadLocal.ThreadLocalMap threadLocals &#x3D; null</p></li><li><p>计算 ThreadLocal 对象的哈希值：</p><p>  private final int threadLocalHashCode &#x3D; nextHashCode()</p><p>  使用 <code>threadLocalHashCode &amp; (table.length - 1)</code> 计算当前 entry 需要存放的位置</p></li><li><p>每创建一个 ThreadLocal 对象就会使用 nextHashCode 分配一个 hash 值给这个对象：</p><p>  private static AtomicInteger nextHashCode &#x3D; new AtomicInteger()</p></li><li><p>斐波那契数也叫黄金分割数，hash 的<strong>增量</strong>就是这个数字，带来的好处是 hash 分布非常均匀：</p><p>  private static final int HASH_INCREMENT &#x3D; 0x61c88647</p></li></ul><hr><h5 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h5><p>方法都是线程安全的，因为 ThreadLocal 属于一个线程的，ThreadLocal 中的方法，逻辑都是获取当前线程维护的 ThreadLocalMap 对象，然后进行数据的增删改查，没有指定初始值的 threadlcoal 对象默认赋值为 null</p><ul><li><p>initialValue()：返回该线程局部变量的初始值</p><ul><li><p>延迟调用的方法，在执行 get 方法时才执行</p></li><li><p>该方法缺省（默认）实现直接返回一个 null</p></li><li><p>如果想要一个初始值，可以重写此方法， 该方法是一个 <code>protected</code> 的方法，为了让子类覆盖而设计的</p></li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> T <span class="hljs-title function_">initialValue</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>nextHashCode()：计算哈希值，ThreadLocal 的散列方式称之为<strong>斐波那契散列</strong>，每次获取哈希值都会加上 HASH_INCREMENT，这样做可以尽量避免 hash 冲突，让哈希值能均匀的分布在 2 的 n 次方的数组中</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nextHashCode</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">// 哈希值自增一个 HASH_INCREMENT 数值  </span><br>    <span class="hljs-keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>set()：修改当前线程与当前 threadlocal 对象相关联的线程局部变量</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;  <br>    <span class="hljs-comment">// 获取当前线程对象  </span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();  <br>    <span class="hljs-comment">// 获取此线程对象中维护的 ThreadLocalMap 对象  </span><br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);  <br>    <span class="hljs-comment">// 判断 map 是否存在  </span><br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>)  <br>        <span class="hljs-comment">// 调用 threadLocalMap.set 方法进行重写或者添加  </span><br>        map.set(<span class="hljs-built_in">this</span>, value);  <br>    <span class="hljs-keyword">else</span>  <br>        <span class="hljs-comment">// map 为空，调用 createMap 进行 ThreadLocalMap 对象的初始化。参数1是当前线程，参数2是局部变量  </span><br>        createMap(t, value);  <br>&#125;<br><br><span class="hljs-comment">// 获取当前线程 Thread 对应维护的 ThreadLocalMap   </span><br>ThreadLocalMap <span class="hljs-title function_">getMap</span><span class="hljs-params">(Thread t)</span> &#123;  <br>    <span class="hljs-keyword">return</span> t.threadLocals;  <br>&#125;  <br><span class="hljs-comment">// 创建当前线程Thread对应维护的ThreadLocalMap   </span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> &#123;  <br>    <span class="hljs-comment">// 【这里的 this 是调用此方法的 threadLocal】，创建一个新的 Map 并设置第一个数据  </span><br>    t.threadLocals = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalMap</span>(<span class="hljs-built_in">this</span>, firstValue);  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>get()：获取当前线程与当前 ThreadLocal 对象相关联的线程局部变量</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();  <br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);  <br>    <span class="hljs-comment">// 如果此map存在  </span><br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;  <br>        <span class="hljs-comment">// 以当前的 ThreadLocal 为 key，调用 getEntry 获取对应的存储实体 e  </span><br>        ThreadLocalMap.<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> map.getEntry(<span class="hljs-built_in">this</span>);  <br>        <span class="hljs-comment">// 对 e 进行判空   </span><br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-comment">// 获取存储实体 e 对应的 value值  </span><br>            <span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (T)e.value;  <br>            <span class="hljs-keyword">return</span> result;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-comment">/*有两种情况有执行当前代码  </span><br><span class="hljs-comment">      第一种情况: map 不存在，表示此线程没有维护的 ThreadLocalMap 对象  </span><br><span class="hljs-comment">      第二种情况: map 存在, 但是【没有与当前 ThreadLocal 关联的 entry】，就会设置为默认值 */</span>  <br>    <span class="hljs-comment">// 初始化当前线程与当前 threadLocal 对象相关联的 value  </span><br>    <span class="hljs-keyword">return</span> setInitialValue();  <br>&#125;<br><br><span class="hljs-keyword">private</span> T <span class="hljs-title function_">setInitialValue</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">// 调用initialValue获取初始化的值，此方法可以被子类重写, 如果不重写默认返回 null  </span><br>    <span class="hljs-type">T</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> initialValue();  <br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();  <br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);  <br>    <span class="hljs-comment">// 判断 map 是否初始化过  </span><br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>)  <br>        <span class="hljs-comment">// 存在则调用 map.set 设置此实体 entry，value 是默认的值  </span><br>        map.set(<span class="hljs-built_in">this</span>, value);  <br>    <span class="hljs-keyword">else</span>  <br>        <span class="hljs-comment">// 调用 createMap 进行 ThreadLocalMap 对象的初始化中  </span><br>        createMap(t, value);  <br>    <span class="hljs-comment">// 返回线程与当前 threadLocal 关联的局部变量  </span><br>    <span class="hljs-keyword">return</span> value;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>remove()：移除当前线程与当前 threadLocal 对象相关联的线程局部变量</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">// 获取当前线程对象中维护的 ThreadLocalMap 对象  </span><br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> getMap(Thread.currentThread());  <br>    <span class="hljs-keyword">if</span> (m != <span class="hljs-literal">null</span>)  <br>        <span class="hljs-comment">// map 存在则调用 map.remove，this时当前ThreadLocal，以this为key删除对应的实体  </span><br>        m.remove(<span class="hljs-built_in">this</span>);  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h4 id="LocalMap"><a href="#LocalMap" class="headerlink" title="LocalMap"></a>LocalMap</h4><h5 id="成员属性"><a href="#成员属性" class="headerlink" title="成员属性"></a>成员属性</h5><p>ThreadLocalMap 是 ThreadLocal 的内部类，没有实现 Map 接口，用独立的方式实现了 Map 的功能，其内部 Entry 也是独立实现</p><p>&#x2F;&#x2F; 初始化当前 map 内部散列表数组的初始长度 16<br>private static final int INITIAL_CAPACITY &#x3D; 16;  </p><p>&#x2F;&#x2F; 存放数据的table，数组长度必须是2的整次幂。<br>private Entry[] table;  </p><p>&#x2F;&#x2F; 数组里面 entrys 的个数，可以用于判断 table 当前使用量是否超过阈值<br>private int size &#x3D; 0;  </p><p>&#x2F;&#x2F; 进行扩容的阈值，表使用量大于它的时候进行扩容。<br>private int threshold;</p><p>存储结构 Entry：</p><ul><li><p>Entry 继承 WeakReference，key 是弱引用，目的是将 ThreadLocal 对象的生命周期和线程生命周期解绑</p></li><li><p>Entry 限制只能用 ThreadLocal 作为 key，key 为 null (entry.get() &#x3D;&#x3D; null) 意味着 key 不再被引用，entry 也可以从 table 中清除</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;  <br>    Object value;  <br>    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;  <br>        <span class="hljs-comment">// this.referent = referent = key;  </span><br>        <span class="hljs-built_in">super</span>(k);  <br>        value = v;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>构造方法：延迟初始化的，线程第一次存储 threadLocal - value 时才会创建 threadLocalMap 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;  <br>    <span class="hljs-comment">// 初始化table，创建一个长度为16的Entry数组  </span><br>    table = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[INITIAL_CAPACITY];  <br>    <span class="hljs-comment">// 【寻址算法】计算索引  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="hljs-number">1</span>);  <br>    <span class="hljs-comment">// 创建 entry 对象，存放到指定位置的 slot 中  </span><br>    table[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(firstKey, firstValue);  <br>    <span class="hljs-comment">// 数据总量是 1  </span><br>    size = <span class="hljs-number">1</span>;  <br>    <span class="hljs-comment">// 将阈值设置为 （当前数组长度 * 2）/ 3。  </span><br>    setThreshold(INITIAL_CAPACITY);  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="成员方法-1"><a href="#成员方法-1" class="headerlink" title="成员方法"></a>成员方法</h5><ul><li><p>set()：添加数据，ThreadLocalMap 使用<strong>线性探测法来解决哈希冲突</strong></p><ul><li><p>该方法会一直探测下一个地址，直到有空的地址后插入，若插入后 Map 数量超过阈值，数组会扩容为原来的 2 倍</p><p>  假设当前 table 长度为16，计算出来 key 的 hash 值为 14，如果 table[14] 上已经有值，并且其 key 与当前 key 不一致，那么就发生了 hash 冲突，这个时候将 14 加 1 得到 15，取 table[15] 进行判断，如果还是冲突会回到 0，取 table[0]，以此类推，直到可以插入，可以把 Entry[] table 看成一个<strong>环形数组</strong></p></li><li><p>线性探测法会出现<strong>堆积问题</strong>，可以采取平方探测法解决</p></li><li><p>在探测过程中 ThreadLocal 会复用 key 为 null 的脏 Entry 对象，并进行垃圾清理，防止出现内存泄漏</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;  <br>    <span class="hljs-comment">// 获取散列表  </span><br>    ThreadLocal.ThreadLocalMap.Entry[] tab = table;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;  <br>    <span class="hljs-comment">// 哈希寻址  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (len-<span class="hljs-number">1</span>);  <br>    <span class="hljs-comment">// 使用线性探测法向后查找元素，碰到 entry 为空时停止探测  </span><br>    <span class="hljs-keyword">for</span> (ThreadLocal.ThreadLocalMap.<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[i]; e != <span class="hljs-literal">null</span>; e = tab[i = nextIndex(i, len)]) &#123;  <br>        <span class="hljs-comment">// 获取当前元素 key  </span><br>        ThreadLocal&lt;?&gt; k = e.get();  <br>        <span class="hljs-comment">// ThreadLocal 对应的 key 存在，【直接覆盖之前的值】  </span><br>        <span class="hljs-keyword">if</span> (k == key) &#123;  <br>            e.value = value;  <br>            <span class="hljs-keyword">return</span>;  <br>        &#125;  <br>        <span class="hljs-comment">// 【这两个条件谁先成立不一定，所以 replaceStaleEntry 中还需要判断 k == key 的情况】  </span><br>          <br>        <span class="hljs-comment">// key 为 null，但是值不为 null，说明之前的 ThreadLocal 对象已经被回收了，当前是【过期数据】  </span><br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-comment">// 【碰到一个过期的 slot，当前数据复用该槽位，替换过期数据】  </span><br>            <span class="hljs-comment">// 这个方法还进行了垃圾清理动作，防止内存泄漏  </span><br>            replaceStaleEntry(key, value, i);  <br>            <span class="hljs-keyword">return</span>;  <br>        &#125;  <br>    &#125;  <br><span class="hljs-comment">// 逻辑到这说明碰到 slot == null 的位置，则在空元素的位置创建一个新的 Entry  </span><br>    tab[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(key, value);  <br>    <span class="hljs-comment">// 数量 + 1  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">sz</span> <span class="hljs-operator">=</span> ++size;  <br>      <br>    <span class="hljs-comment">// 【做一次启发式清理】，如果没有清除任何 entry 并且【当前使用量达到了负载因子所定义，那么进行 rehash  </span><br>    <span class="hljs-keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)  <br>        <span class="hljs-comment">// 扩容  </span><br>        rehash();  <br>&#125;<br><br><span class="hljs-comment">// 获取【环形数组】的下一个索引  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nextIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> len)</span> &#123;  <br>    <span class="hljs-comment">// 索引越界后从 0 开始继续获取  </span><br>    <span class="hljs-keyword">return</span> ((i + <span class="hljs-number">1</span> &lt; len) ? i + <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);  <br>&#125;<br><br><span class="hljs-comment">// 在指定位置插入指定的数据  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">replaceStaleEntry</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, Object value, <span class="hljs-type">int</span> staleSlot)</span> &#123;  <br>    <span class="hljs-comment">// 获取散列表  </span><br>    Entry[] tab = table;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;  <br>    Entry e;  <br><span class="hljs-comment">// 探测式清理的开始下标，默认从当前 staleSlot 开始  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">slotToExpunge</span> <span class="hljs-operator">=</span> staleSlot;  <br>    <span class="hljs-comment">// 以当前 staleSlot 开始【向前迭代查找】，找到索引靠前过期数据，找到以后替换 slotToExpunge 值  </span><br>    <span class="hljs-comment">// 【保证在一个区间段内，从最前面的过期数据开始清理】  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> prevIndex(staleSlot, len); (e = tab[i]) != <span class="hljs-literal">null</span>; i = prevIndex(i, len))  <br>        <span class="hljs-keyword">if</span> (e.get() == <span class="hljs-literal">null</span>)  <br>            slotToExpunge = i;  <br>  <br><span class="hljs-comment">// 以 staleSlot 【向后去查找】，直到碰到 null 为止，还是线性探测  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> nextIndex(staleSlot, len); (e = tab[i]) != <span class="hljs-literal">null</span>; i = nextIndex(i, len)) &#123;  <br>        <span class="hljs-comment">// 获取当前节点的 key  </span><br>        ThreadLocal&lt;?&gt; k = e.get();  <br><span class="hljs-comment">// 条件成立说明是【替换逻辑】  </span><br>        <span class="hljs-keyword">if</span> (k == key) &#123;  <br>            e.value = value;  <br>            <span class="hljs-comment">// 因为本来要在 staleSlot 索引处插入该数据，现在找到了i索引处的key与数据一致  </span><br>            <span class="hljs-comment">// 但是 i 位置距离正确的位置更远，因为是向后查找，所以还是要在 staleSlot 位置插入当前 entry  </span><br>            <span class="hljs-comment">// 然后将 table[staleSlot] 这个过期数据放到当前循环到的 table[i] 这个位置，  </span><br>            tab[i] = tab[staleSlot];  <br>            tab[staleSlot] = e;  <br>  <br>            <span class="hljs-comment">// 条件成立说明向前查找过期数据并未找到过期的 entry，但 staleSlot 位置已经不是过期数据了，i 位置才是  </span><br>            <span class="hljs-keyword">if</span> (slotToExpunge == staleSlot)  <br>                slotToExpunge = i;  <br>              <br>            <span class="hljs-comment">// 【清理过期数据，expungeStaleEntry 探测式清理，cleanSomeSlots 启发式清理】  </span><br>            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);  <br>            <span class="hljs-keyword">return</span>;  <br>        &#125;  <br><span class="hljs-comment">// 条件成立说明当前遍历的 entry 是一个过期数据，并且该位置前面也没有过期数据  </span><br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span> &amp;&amp; slotToExpunge == staleSlot)  <br>            <span class="hljs-comment">// 探测式清理过期数据的开始下标修改为当前循环的 index，因为 staleSlot 会放入要添加的数据  </span><br>            slotToExpunge = i;  <br>    &#125;  <br><span class="hljs-comment">// 向后查找过程中并未发现 k == key 的 entry，说明当前是一个【取代过期数据逻辑】  </span><br>    <span class="hljs-comment">// 删除原有的数据引用，防止内存泄露  </span><br>    tab[staleSlot].value = <span class="hljs-literal">null</span>;  <br>    <span class="hljs-comment">// staleSlot 位置添加数据，【上面的所有逻辑都不会更改 staleSlot 的值】  </span><br>    tab[staleSlot] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(key, value);  <br>  <br>    <span class="hljs-comment">// 条件成立说明除了 staleSlot 以外，还发现其它的过期 slot，所以要【开启清理数据的逻辑】  </span><br>    <span class="hljs-keyword">if</span> (slotToExpunge != staleSlot)  <br>        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);  <br>&#125;<br><br></code></pre></td></tr></table></figure><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041727787.png"></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">prevIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> len)</span> &#123;  <br>    <span class="hljs-comment">// 形成一个环绕式的访问，头索引越界后置为尾索引  </span><br>    <span class="hljs-keyword">return</span> ((i - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>) ? i - <span class="hljs-number">1</span> : len - <span class="hljs-number">1</span>);  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>getEntry()：ThreadLocal 的 get 方法以当前的 ThreadLocal 为 key，调用 getEntry 获取对应的存储实体 e</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> Entry <span class="hljs-title function_">getEntry</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key)</span> &#123;  <br>    <span class="hljs-comment">// 哈希寻址  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (table.length - <span class="hljs-number">1</span>);  <br>    <span class="hljs-comment">// 访问散列表中指定指定位置的 slot   </span><br>    <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> table[i];  <br>    <span class="hljs-comment">// 条件成立，说明 slot 有值并且 key 就是要寻找的 key，直接返回  </span><br>    <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span> &amp;&amp; e.get() == key)  <br>        <span class="hljs-keyword">return</span> e;  <br>    <span class="hljs-keyword">else</span>  <br>        <span class="hljs-comment">// 进行线性探测  </span><br>        <span class="hljs-keyword">return</span> getEntryAfterMiss(key, i, e);  <br>&#125;  <br><span class="hljs-comment">// 线性探测寻址  </span><br><span class="hljs-keyword">private</span> Entry <span class="hljs-title function_">getEntryAfterMiss</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, <span class="hljs-type">int</span> i, Entry e)</span> &#123;  <br>    <span class="hljs-comment">// 获取散列表  </span><br>    Entry[] tab = table;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;  <br>  <br>    <span class="hljs-comment">// 开始遍历，碰到 slot == null 的情况，搜索结束  </span><br>    <span class="hljs-keyword">while</span> (e != <span class="hljs-literal">null</span>) &#123;  <br><span class="hljs-comment">// 获取当前 slot 中 entry 对象的 key  </span><br>        ThreadLocal&lt;?&gt; k = e.get();  <br>        <span class="hljs-comment">// 条件成立说明找到了，直接返回  </span><br>        <span class="hljs-keyword">if</span> (k == key)  <br>            <span class="hljs-keyword">return</span> e;  <br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>)  <br>             <span class="hljs-comment">// 过期数据，【探测式过期数据回收】  </span><br>            expungeStaleEntry(i);  <br>        <span class="hljs-keyword">else</span>  <br>            <span class="hljs-comment">// 更新 index 继续向后走  </span><br>            i = nextIndex(i, len);  <br>        <span class="hljs-comment">// 获取下一个槽位中的 entry  </span><br>        e = tab[i];  <br>    &#125;  <br>    <span class="hljs-comment">// 说明当前区段没有找到相应数据  </span><br>    <span class="hljs-comment">// 【因为存放数据是线性的向后寻找槽位，都是紧挨着的，不可能越过一个 空槽位 在后面放】，可以减少遍历的次数  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>rehash()：触发一次全量清理，如果数组长度大于等于长度的 <code>2/3 * 3/4 = 1/2</code>，则进行 resize</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rehash</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">// 清楚当前散列表内的【所有】过期的数据  </span><br>    expungeStaleEntries();  <br>      <br>    <span class="hljs-comment">// threshold = len * 2 / 3，就是 2/3 * (1 - 1/4)  </span><br>    <span class="hljs-keyword">if</span> (size &gt;= threshold - threshold / <span class="hljs-number">4</span>)  <br>        resize();  <br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">expungeStaleEntries</span><span class="hljs-params">()</span> &#123;  <br>    Entry[] tab = table;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;  <br>    <span class="hljs-comment">// 【遍历所有的槽位，清理过期数据】  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; len; j++) &#123;  <br>        <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[j];  <br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span> &amp;&amp; e.get() == <span class="hljs-literal">null</span>)  <br>            expungeStaleEntry(j);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>  Entry <strong>数组为扩容为原来的 2 倍</strong> ，重新计算 key 的散列值，如果遇到 key 为 null 的情况，会将其 value 也置为 null，帮助 GC</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">resize</span><span class="hljs-params">()</span> &#123;  <br>    Entry[] oldTab = table;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldLen</span> <span class="hljs-operator">=</span> oldTab.length;  <br>    <span class="hljs-comment">// 新数组的长度是老数组的二倍  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">newLen</span> <span class="hljs-operator">=</span> oldLen * <span class="hljs-number">2</span>;  <br>    Entry[] newTab = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[newLen];  <br>    <span class="hljs-comment">// 统计新table中的entry数量  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br><span class="hljs-comment">// 遍历老表，进行【数据迁移】  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; oldLen; ++j) &#123;  <br>        <span class="hljs-comment">// 访问老表的指定位置的 entry  </span><br>        <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> oldTab[j];  <br>        <span class="hljs-comment">// 条件成立说明老表中该位置有数据，可能是过期数据也可能不是  </span><br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;  <br>            ThreadLocal&lt;?&gt; k = e.get();  <br>            <span class="hljs-comment">// 过期数据  </span><br>            <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>) &#123;  <br>                e.value = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Help the GC  </span><br>            &#125; <span class="hljs-keyword">else</span> &#123;  <br>                <span class="hljs-comment">// 非过期数据，在新表中进行哈希寻址  </span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> k.threadLocalHashCode &amp; (newLen - <span class="hljs-number">1</span>);  <br>                <span class="hljs-comment">// 【线程探测】  </span><br>                <span class="hljs-keyword">while</span> (newTab[h] != <span class="hljs-literal">null</span>)  <br>                    h = nextIndex(h, newLen);  <br>                <span class="hljs-comment">// 将数据存放到新表合适的 slot 中  </span><br>                newTab[h] = e;  <br>                count++;  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br><span class="hljs-comment">// 设置下一次触发扩容的指标：threshold = len * 2 / 3;  </span><br>    setThreshold(newLen);  <br>    size = count;  <br>    <span class="hljs-comment">// 将扩容后的新表赋值给 threadLocalMap 内部散列表数组引用  </span><br>    table = newTab;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>remove()：删除 Entry</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key)</span> &#123;  <br>    Entry[] tab = table;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;  <br>    <span class="hljs-comment">// 哈希寻址  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (len-<span class="hljs-number">1</span>);  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[i]; e != <span class="hljs-literal">null</span>; e = tab[i = nextIndex(i, len)]) &#123;  <br>        <span class="hljs-comment">// 找到了对应的 key  </span><br>        <span class="hljs-keyword">if</span> (e.get() == key) &#123;  <br>            <span class="hljs-comment">// 设置 key 为 null  </span><br>            e.clear();  <br>            <span class="hljs-comment">// 探测式清理  </span><br>            expungeStaleEntry(i);  <br>            <span class="hljs-keyword">return</span>;  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h5 id="清理方法"><a href="#清理方法" class="headerlink" title="清理方法"></a>清理方法</h5><ul><li><p>探测式清理：沿着开始位置向后探测清理过期数据，沿途中碰到未过期数据则将此数据 rehash 在 table 数组中的定位，重定位后的元素理论上更接近 <code>i = entry.key &amp; (table.length - 1)</code>，让<strong>数据的排列更紧凑</strong>，会优化整个散列表查询性能</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// table[staleSlot] 是一个过期数据，以这个位置开始继续向后查找过期数据  </span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">expungeStaleEntry</span><span class="hljs-params">(<span class="hljs-type">int</span> staleSlot)</span> &#123;  <br>    <span class="hljs-comment">// 获取散列表和数组长度  </span><br>    Entry[] tab = table;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;  <br>  <br>    <span class="hljs-comment">// help gc，先把当前过期的 entry 置空，在取消对 entry 的引用  </span><br>    tab[staleSlot].value = <span class="hljs-literal">null</span>;  <br>    tab[staleSlot] = <span class="hljs-literal">null</span>;  <br>    <span class="hljs-comment">// 数量-1  </span><br>    size--;  <br>  <br>    Entry e;  <br>    <span class="hljs-type">int</span> i;  <br>    <span class="hljs-comment">// 从 staleSlot 开始向后遍历，直到碰到 slot == null 结束，【区间内清理过期数据】  </span><br>    <span class="hljs-keyword">for</span> (i = nextIndex(staleSlot, len); (e = tab[i]) != <span class="hljs-literal">null</span>; i = nextIndex(i, len)) &#123;  <br>        ThreadLocal&lt;?&gt; k = e.get();  <br>        <span class="hljs-comment">// 当前 entry 是过期数据  </span><br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-comment">// help gc  </span><br>            e.value = <span class="hljs-literal">null</span>;  <br>            tab[i] = <span class="hljs-literal">null</span>;  <br>            size--;  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            <span class="hljs-comment">// 当前 entry 不是过期数据的逻辑，【rehash】  </span><br>            <span class="hljs-comment">// 重新计算当前 entry 对应的 index  </span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> k.threadLocalHashCode &amp; (len - <span class="hljs-number">1</span>);  <br>            <span class="hljs-comment">// 条件成立说明当前 entry 存储时发生过 hash 冲突，向后偏移过了  </span><br>            <span class="hljs-keyword">if</span> (h != i) &#123;  <br>                <span class="hljs-comment">// 当前位置置空  </span><br>                tab[i] = <span class="hljs-literal">null</span>;  <br>                <span class="hljs-comment">// 以正确位置 h 开始，向后查找第一个可以存放 entry 的位置  </span><br>                <span class="hljs-keyword">while</span> (tab[h] != <span class="hljs-literal">null</span>)  <br>                    h = nextIndex(h, len);  <br>                <span class="hljs-comment">// 将当前元素放入到【距离正确位置更近的位置，有可能就是正确位置】  </span><br>                tab[h] = e;  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-comment">// 返回 slot = null 的槽位索引，图例是 7，这个索引代表【索引前面的区间已经清理完成垃圾了】  </span><br>    <span class="hljs-keyword">return</span> i;  <br>&#125;<br></code></pre></td></tr></table></figure><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041729624.png"></p><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041729128.png"></p></li><li><p>启发式清理：向后循环扫描过期数据，发现过期数据调用探测式清理方法，如果连续几次的循环都没有发现过期数据，就停止扫描</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">//  i 表示启发式清理工作开始位置，一般是空 slot，n 一般传递的是 table.length   </span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">cleanSomeSlots</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> n)</span> &#123;  <br>    <span class="hljs-comment">// 表示启发式清理工作是否清除了过期数据  </span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">removed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;  <br>    <span class="hljs-comment">// 获取当前 map 的散列表引用  </span><br>    Entry[] tab = table;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;  <br>    <span class="hljs-keyword">do</span> &#123;  <br>        <span class="hljs-comment">// 获取下一个索引，因为探测式返回的 slot 为 null  </span><br>        i = nextIndex(i, len);  <br>        <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[i];  <br>        <span class="hljs-comment">// 条件成立说明是过期的数据，key 被 gc 了  </span><br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span> &amp;&amp; e.get() == <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-comment">// 【发现过期数据重置 n 为数组的长度】  </span><br>            n = len;  <br>            <span class="hljs-comment">// 表示清理过过期数据  </span><br>            removed = <span class="hljs-literal">true</span>;  <br>            <span class="hljs-comment">// 以当前过期的 slot 为开始节点 做一次探测式清理工作  </span><br>            i = expungeStaleEntry(i);  <br>        &#125;  <br>        <span class="hljs-comment">// 假设 table 长度为 16  </span><br>        <span class="hljs-comment">// 16 &gt;&gt;&gt; 1 ==&gt; 8，8 &gt;&gt;&gt; 1 ==&gt; 4，4 &gt;&gt;&gt; 1 ==&gt; 2，2 &gt;&gt;&gt; 1 ==&gt; 1，1 &gt;&gt;&gt; 1 ==&gt; 0  </span><br>        <span class="hljs-comment">// 连续经过这么多次循环【没有扫描到过期数据】，就停止循环，扫描到空 slot 不算，因为不是过期数据  </span><br>    &#125; <span class="hljs-keyword">while</span> ((n &gt;&gt;&gt;= <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>);  <br>      <br>    <span class="hljs-comment">// 返回清除标记  </span><br>    <span class="hljs-keyword">return</span> removed;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h4><p>Memory leak：内存泄漏是指程序中动态分配的堆内存由于某种原因未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果，内存泄漏的堆积终将导致内存溢出</p><ul><li><p>如果 key 使用强引用：使用完 ThreadLocal ，threadLocal Ref 被回收，但是 threadLocalMap 的 Entry 强引用了 threadLocal，造成 threadLocal 无法被回收，无法完全避免内存泄漏</p><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041730276.png"></p></li><li><p>如果 key 使用弱引用：使用完 ThreadLocal ，threadLocal Ref 被回收，ThreadLocalMap 只持有 ThreadLocal 的弱引用，所以threadlocal 也可以被回收，此时 Entry 中的 key &#x3D; null。但没有手动删除这个 Entry 或者 CurrentThread 依然运行，依然存在强引用链，value 不会被回收，而这块 value 永远不会被访问到，也会导致 value 内存泄漏</p><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041730339.png"></p></li><li><p>两个主要原因：</p><ul><li><p>没有手动删除这个 Entry</p></li><li><p>CurrentThread 依然运行</p></li></ul></li></ul><p>根本原因：ThreadLocalMap 是 Thread的一个属性，<strong>生命周期跟 Thread 一样长</strong>，如果没有手动删除对应 Entry 就会导致内存泄漏</p><p>解决方法：使用完 ThreadLocal 中存储的内容后将它 remove 掉就可以</p><p>ThreadLocal 内部解决方法：在 ThreadLocalMap 中的 set&#x2F;getEntry 方法中，通过线性探测法对 key 进行判断，如果 key 为 null（ThreadLocal 为 null）会对 Entry 进行垃圾回收。所以<strong>使用弱引用比强引用多一层保障</strong>，就算不调用 remove，也有机会进行 GC</p><hr><h4 id="变量传递"><a href="#变量传递" class="headerlink" title="变量传递"></a>变量传递</h4><h5 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h5><p>父子线程：创建子线程的线程是父线程，比如实例中的 main 线程就是父线程</p><p>ThreadLocal 中存储的是线程的局部变量，如果想<strong>实现线程间局部变量传递</strong>可以使用 InheritableThreadLocal 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    ThreadLocal&lt;String&gt; threadLocal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InheritableThreadLocal</span>&lt;&gt;();  <br>    threadLocal.set(<span class="hljs-string">&quot;父线程设置的值&quot;</span>);  <br>  <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; System.out.println(<span class="hljs-string">&quot;子线程输出：&quot;</span> + threadLocal.get())).start();  <br>&#125;  <br><span class="hljs-comment">// 子线程输出：父线程设置的值</span><br></code></pre></td></tr></table></figure><hr><h5 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h5><p>InheritableThreadLocal 源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InheritableThreadLocal</span>&lt;T&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ThreadLocal</span>&lt;T&gt; &#123;  <br>    <span class="hljs-keyword">protected</span> T <span class="hljs-title function_">childValue</span><span class="hljs-params">(T parentValue)</span> &#123;  <br>        <span class="hljs-keyword">return</span> parentValue;  <br>    &#125;  <br>    ThreadLocalMap <span class="hljs-title function_">getMap</span><span class="hljs-params">(Thread t)</span> &#123;  <br>       <span class="hljs-keyword">return</span> t.inheritableThreadLocals;  <br>    &#125;  <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> &#123;  <br>        t.inheritableThreadLocals = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalMap</span>(<span class="hljs-built_in">this</span>, firstValue);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>实现父子线程间的局部变量共享需要追溯到 Thread 对象的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(ThreadGroup g, Runnable target, String name, <span class="hljs-type">long</span> stackSize, AccessControlContext acc,  </span><br><span class="hljs-params">                  // 该参数默认是 <span class="hljs-literal">true</span>  </span><br><span class="hljs-params">                  <span class="hljs-type">boolean</span> inheritThreadLocals)</span> &#123;  <br>  <span class="hljs-comment">// ...  </span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> currentThread();  <br>  <br>    <span class="hljs-comment">// 判断父线程（创建子线程的线程）的 inheritableThreadLocals 属性不为 null  </span><br>    <span class="hljs-keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="hljs-literal">null</span>) &#123;  <br>        <span class="hljs-comment">// 复制父线程的 inheritableThreadLocals 属性，实现父子线程局部变量共享  </span><br>        <span class="hljs-built_in">this</span>.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);   <br>    &#125;  <br>    <span class="hljs-comment">// ..  </span><br>&#125;  <br><span class="hljs-comment">// 【本质上还是创建 ThreadLocalMap，只是把父类中的可继承数据设置进去了】  </span><br><span class="hljs-keyword">static</span> ThreadLocalMap <span class="hljs-title function_">createInheritedMap</span><span class="hljs-params">(ThreadLocalMap parentMap)</span> &#123;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalMap</span>(parentMap);  <br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-title function_">ThreadLocalMap</span><span class="hljs-params">(ThreadLocalMap parentMap)</span> &#123;  <br>    <span class="hljs-comment">// 获取父线程的哈希表  </span><br>    Entry[] parentTable = parentMap.table;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> parentTable.length;  <br>    setThreshold(len);  <br>    table = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[len];  <br><span class="hljs-comment">// 【逐个复制父线程 ThreadLocalMap 中的数据】  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; len; j++) &#123;  <br>        <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> parentTable[j];  <br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;  <br>            ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();  <br>            <span class="hljs-keyword">if</span> (key != <span class="hljs-literal">null</span>) &#123;  <br>                <span class="hljs-comment">// 调用的是 InheritableThreadLocal#childValue(T parentValue)  </span><br>                <span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> key.childValue(e.value);  <br>                <span class="hljs-type">Entry</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(key, value);  <br>                <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (len - <span class="hljs-number">1</span>);  <br>                <span class="hljs-comment">// 线性探测  </span><br>                <span class="hljs-keyword">while</span> (table[h] != <span class="hljs-literal">null</span>)  <br>                    h = nextIndex(h, len);  <br>                table[h] = c;  <br>                size++;  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h3><p>线程池：一个容纳多个线程的容器，容器中的线程可以重复使用，省去了频繁创建和销毁线程对象的操作</p><p>线程池作用：</p><ol><li><p>降低资源消耗，减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务</p></li><li><p>提高响应速度，当任务到达时，如果有线程可以直接用，不会出现系统僵死</p></li><li><p>提高线程的可管理性，如果无限制的创建线程，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控</p></li></ol><p>线程池的核心思想：<strong>线程复用</strong>，同一个线程可以被重复使用，来处理多个任务</p><p>池化技术 (Pool) ：一种编程技巧，核心思想是资源复用，在请求量大时能优化应用性能，降低系统频繁建连的资源开销</p><hr><h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><h4 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>有界队列和无界队列：</p><ul><li><p>有界队列：有固定大小的队列，比如设定了固定大小的 LinkedBlockingQueue，又或者大小为 0</p></li><li><p>无界队列：没有设置固定大小的队列，这些队列可以直接入队，直到溢出（超过 Integer.MAX_VALUE），所以相当于无界</p></li></ul><p>java.util.concurrent.BlockingQueue 接口有以下阻塞队列的实现：<strong>FIFO 队列</strong></p><ul><li><p>ArrayBlockQueue：由数组结构组成的有界阻塞队列</p></li><li><p>LinkedBlockingQueue：由链表结构组成的无界（默认大小 Integer.MAX_VALUE）的阻塞队列</p></li><li><p>PriorityBlockQueue：支持优先级排序的无界阻塞队列</p></li><li><p>DelayedWorkQueue：使用优先级队列实现的延迟无界阻塞队列</p></li><li><p>SynchronousQueue：不存储元素的阻塞队列，每一个生产线程会阻塞到有一个 put 的线程放入元素为止</p></li><li><p>LinkedTransferQueue：由链表结构组成的无界阻塞队列</p></li><li><p>LinkedBlockingDeque：由链表结构组成的<strong>双向</strong>阻塞队列</p></li></ul><p>与普通队列（LinkedList、ArrayList等）的不同点在于阻塞队列中阻塞添加和阻塞删除方法，以及线程安全：</p><ul><li><p>阻塞添加 put()：当阻塞队列元素已满时，添加队列元素的线程会被阻塞，直到队列元素不满时才重新唤醒线程执行</p></li><li><p>阻塞删除 take()：在队列元素为空时，删除队列元素的线程将被阻塞，直到队列不为空再执行删除操作（一般会返回被删除的元素)</p></li></ul><hr><h4 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h4><table><thead><tr><th>方法类型</th><th>抛出异常</th><th>特殊值</th><th>阻塞</th><th>超时</th></tr></thead><tbody><tr><td>插入（尾）</td><td>add(e)</td><td>offer(e)</td><td>put(e)</td><td>offer(e,time,unit)</td></tr><tr><td>移除（头）</td><td>remove()</td><td>poll()</td><td>take()</td><td>poll(time,unit)</td></tr><tr><td>检查（队首元素）</td><td>element()</td><td>peek()</td><td>不可用</td><td>不可用</td></tr></tbody></table><ul><li><p>抛出异常组：</p><ul><li><p>当阻塞队列满时：在往队列中 add 插入元素会抛出 IIIegalStateException: Queue full</p></li><li><p>当阻塞队列空时：再往队列中 remove 移除元素，会抛出 NoSuchException</p></li></ul></li><li><p>特殊值组：</p><ul><li><p>插入方法：成功 true，失败 false</p></li><li><p>移除方法：成功返回出队列元素，队列没有就返回 null</p></li></ul></li><li><p>阻塞组：</p><ul><li><p>当阻塞队列满时，生产者继续往队列里 put 元素，队列会一直阻塞生产线程直到队列有空间 put 数据或响应中断退出</p></li><li><p>当阻塞队列空时，消费者线程试图从队列里 take 元素，队列会一直阻塞消费者线程直到队列中有可用元素</p></li></ul></li><li><p>超时退出：当阻塞队列满时，队里会阻塞生产者线程一定时间，超过限时后生产者线程会退出</p></li></ul><hr><h4 id="链表队列"><a href="#链表队列" class="headerlink" title="链表队列"></a>链表队列</h4><h5 id="入队出队"><a href="#入队出队" class="headerlink" title="入队出队"></a>入队出队</h5><p>LinkedBlockingQueue 源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueue</span>&lt;E&gt;  <br><span class="hljs-keyword">implements</span> <span class="hljs-title class_">BlockingQueue</span>&lt;E&gt;, java.io.Serializable &#123;  <br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;E&gt; &#123;  <br>        E item;  <br>        <span class="hljs-comment">/**  </span><br><span class="hljs-comment">        * 下列三种情况之一  </span><br><span class="hljs-comment">        * - 真正的后继节点  </span><br><span class="hljs-comment">        * - 自己, 发生在出队时  </span><br><span class="hljs-comment">        * - null, 表示是没有后继节点, 是尾节点了  </span><br><span class="hljs-comment">        */</span>  <br>        Node&lt;E&gt; next;  <br>  <br>        Node(E x) &#123; item = x; &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>入队：<strong>尾插法</strong></p><ul><li><p>初始化链表 <code>last = head = new Node&lt;E&gt;(null)</code>，<strong>Dummy 节点用来占位</strong>，item 为 null</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedBlockingQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;  <br>    <span class="hljs-comment">// 默认是 Integer.MAX_VALUE  </span><br>    <span class="hljs-keyword">if</span> (capacity &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();  <br>    <span class="hljs-built_in">this</span>.capacity = capacity;  <br>    last = head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;E&gt;(<span class="hljs-literal">null</span>);  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>当一个节点入队：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">enqueue</span><span class="hljs-params">(Node&lt;E&gt; node)</span> &#123;  <br>    <span class="hljs-comment">// 从右向左计算  </span><br>    last = last.next = node;  <br>&#125;<br></code></pre></td></tr></table></figure><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041733155.png"></p></li><li><p>再来一个节点入队 <code>last = last.next = node</code></p></li></ul><p>出队：<strong>出队头节点</strong>，FIFO</p><ul><li><p>出队源码：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> E <span class="hljs-title function_">dequeue</span><span class="hljs-params">()</span> &#123;  <br>    Node&lt;E&gt; h = head;  <br>    <span class="hljs-comment">// 获取临头节点  </span><br>    Node&lt;E&gt; first = h.next;  <br>    <span class="hljs-comment">// 自己指向自己，help GC  </span><br>    h.next = h;  <br>    head = first;  <br>    <span class="hljs-comment">// 出队的元素  </span><br>    <span class="hljs-type">E</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> first.item;  <br>    <span class="hljs-comment">// 【当前节点置为 Dummy 节点】  </span><br>    first.item = <span class="hljs-literal">null</span>;  <br>    <span class="hljs-keyword">return</span> x;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>h = head</code> → <code>first = h.next</code></p><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041734054.png"></p></li><li><p><code>h.next = h</code> → <code>head = first</code></p><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041734203.png"></p><ul><li><code>first.item = null</code>：当前节点置为 Dummy 节点</li></ul></li></ul><hr><h5 id="加锁分析"><a href="#加锁分析" class="headerlink" title="加锁分析"></a>加锁分析</h5><p>用了两把锁和 dummy 节点：</p><ul><li><p>用一把锁，同一时刻，最多只允许有一个线程（生产者或消费者，二选一）执行</p></li><li><p>用两把锁，同一时刻，可以允许两个线程同时（一个生产者与一个消费者）执行</p><ul><li><p>消费者与消费者线程仍然串行</p></li><li><p>生产者与生产者线程仍然串行</p></li></ul></li></ul><p>线程安全分析：</p><ul><li><p>当节点总数大于 2 时（包括 dummy 节点），<strong>putLock 保证的是 last 节点的线程安全，takeLock 保证的是 head 节点的线程安全</strong>，两把锁保证了入队和出队没有竞争</p></li><li><p>当节点总数等于 2 时（即一个 dummy 节点，一个正常节点）这时候，仍然是两把锁锁两个对象，不会竞争</p></li><li><p>当节点总数等于 1 时（就一个 dummy 节点）这时 take 线程会被 notEmpty 条件阻塞，有竞争，会阻塞</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// 用于 put(阻塞) offer(非阻塞)  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">putLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();  <br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">notFull</span> <span class="hljs-operator">=</span> putLock.newCondition();<span class="hljs-comment">// 阻塞等待不满，说明已经满了  </span><br>  <br><span class="hljs-comment">// 用于 take(阻塞) poll(非阻塞)  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">takeLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();  <br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">notEmpty</span> <span class="hljs-operator">=</span> takeLock.newCondition();<span class="hljs-comment">// 阻塞等待不空，说明已经是空的</span><br></code></pre></td></tr></table></figure></li></ul><p>入队出队：</p><ul><li><p>put 操作：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(E e)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>    <span class="hljs-comment">// 空指针异常  </span><br>    <span class="hljs-keyword">if</span> (e == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;  <br>    <span class="hljs-comment">// 把待添加的元素封装为 node 节点  </span><br>    Node&lt;E&gt; node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;E&gt;(e);  <br>    <span class="hljs-comment">// 获取全局生产锁  </span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">putLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.putLock;  <br>    <span class="hljs-comment">// count 用来维护元素计数  </span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.count;  <br>    <span class="hljs-comment">// 获取可打断锁，会抛出异常  </span><br>    putLock.lockInterruptibly();  <br>    <span class="hljs-keyword">try</span> &#123;  <br>    <span class="hljs-comment">// 队列满了等待  </span><br>        <span class="hljs-keyword">while</span> (count.get() == capacity) &#123;  <br>            <span class="hljs-comment">// 【等待队列不满时，就可以生产数据】，线程处于 Waiting  </span><br>            notFull.await();  <br>        &#125;  <br>        <span class="hljs-comment">// 有空位, 入队且计数加一，尾插法  </span><br>        enqueue(node);  <br>        <span class="hljs-comment">// 返回自增前的数字  </span><br>        c = count.getAndIncrement();  <br>        <span class="hljs-comment">// put 完队列还有空位, 唤醒其他生产 put 线程，唤醒一个减少竞争  </span><br>        <span class="hljs-keyword">if</span> (c + <span class="hljs-number">1</span> &lt; capacity)  <br>            notFull.signal();  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        <span class="hljs-comment">// 解锁  </span><br>        putLock.unlock();  <br>    &#125;  <br>    <span class="hljs-comment">// c自增前是0，说明生产了一个元素，唤醒一个 take 线程  </span><br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>)  <br>        signalNotEmpty();  <br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">signalNotEmpty</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">takeLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.takeLock;  <br>    takeLock.lock();  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-comment">// 调用 notEmpty.signal()，而不是 notEmpty.signalAll() 是为了减少竞争，因为只剩下一个元素  </span><br>        notEmpty.signal();  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        takeLock.unlock();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>take 操作：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>    E x;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;  <br>    <span class="hljs-comment">// 元素个数  </span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.count;  <br>    <span class="hljs-comment">// 获取全局消费锁  </span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">takeLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.takeLock;  <br>    <span class="hljs-comment">// 可打断锁  </span><br>    takeLock.lockInterruptibly();  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-comment">// 没有元素可以出队  </span><br>        <span class="hljs-keyword">while</span> (count.get() == <span class="hljs-number">0</span>) &#123;  <br>            <span class="hljs-comment">// 【阻塞等待队列不空，就可以消费数据】，线程处于 Waiting  </span><br>            notEmpty.await();  <br>        &#125;  <br>        <span class="hljs-comment">// 出队，计数减一，FIFO，出队头节点  </span><br>        x = dequeue();  <br>        <span class="hljs-comment">// 返回自减前的数字  </span><br>        c = count.getAndDecrement();  <br>        <span class="hljs-comment">// 队列还有元素  </span><br>        <span class="hljs-keyword">if</span> (c &gt; <span class="hljs-number">1</span>)  <br>            <span class="hljs-comment">// 唤醒一个消费take线程  </span><br>            notEmpty.signal();  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        takeLock.unlock();  <br>    &#125;  <br>    <span class="hljs-comment">// c 是消费前的数据，消费前满了，消费一个后还剩一个空位，唤醒生产线程  </span><br>    <span class="hljs-keyword">if</span> (c == capacity)  <br>        <span class="hljs-comment">// 调用的是 notFull.signal() 而不是 notFull.signalAll() 是为了减少竞争  </span><br>        signalNotFull();  <br>    <span class="hljs-keyword">return</span> x;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h5 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h5><p>主要列举 LinkedBlockingQueue 与 ArrayBlockingQueue 的性能比较：</p><ul><li><p>Linked 支持有界，Array 强制有界</p></li><li><p>Linked 实现是链表，Array 实现是数组</p></li><li><p>Linked 是懒惰的，而 Array 需要提前初始化 Node 数组</p></li><li><p>Linked 每次入队会生成新 Node，而 Array 的 Node 是提前创建好的</p></li><li><p>Linked 两把锁，Array 一把锁</p></li></ul><hr><h4 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h4><h5 id="成员属性-1"><a href="#成员属性-1" class="headerlink" title="成员属性"></a>成员属性</h5><p>SynchronousQueue 是一个不存储元素的 BlockingQueue，<strong>每一个生产者必须阻塞匹配到一个消费者</strong></p><p>成员变量：</p><ul><li><p>运行当前程序的平台拥有 CPU 的数量：</p><p>  <code>static final int NCPUS = Runtime.getRuntime().availableProcessors()</code></p></li><li><p>指定超时时间后，当前线程最大自旋次数：</p><p>  &#x2F;&#x2F; 只有一个 CPU 时自旋次数为 0，所有程序都是串行执行，多核 CPU 时自旋 32 次是一个经验值<br>  <code>static final int maxTimedSpins = (NCPUS &lt; 2) ? 0 : 32;</code></p><p>  自旋的原因：线程挂起唤醒需要进行上下文切换，涉及到用户态和内核态的转变，是非常消耗资源的。自旋期间线程会一直检查自己的状态是否被匹配到，如果自旋期间被匹配到，那么直接就返回了，如果自旋次数达到某个指标后，还是会将当前线程挂起</p></li><li><p>未指定超时时间，当前线程最大自旋次数：</p><p>  <code>static final int maxUntimedSpins = maxTimedSpins * 16;// maxTimedSpins 的 16 倍</code></p></li><li><p>指定超时限制的阈值，小于该值的线程不会被挂起：</p><p>  <code>static final long spinForTimeoutThreshold = 1000L;// 纳秒</code></p><p>  超时时间设置的小于该值，就会被禁止挂起，阻塞再唤醒的成本太高，不如选择自旋空转</p></li><li><p>转换器：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Transferer&lt;E&gt; transferer;  <br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Transferer</span>&lt;E&gt; &#123;  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">    * 参数一：可以为 null，null 时表示这个请求是一个 REQUEST 类型的请求，反之是一个 DATA 类型的请求  </span><br><span class="hljs-comment">    * 参数二：如果为 true 表示指定了超时时间，如果为 false 表示不支持超时，会一直阻塞到匹配或者被打断  </span><br><span class="hljs-comment">    * 参数三：超时时间限制，单位是纳秒  </span><br><span class="hljs-comment">      </span><br><span class="hljs-comment">    * 返回值：返回值如果不为 null 表示匹配成功，DATA 类型的请求返回当前线程 put 的数据  </span><br><span class="hljs-comment">    *      如果返回 null，表示请求超时或被中断  </span><br><span class="hljs-comment">    */</span>  <br>    <span class="hljs-keyword">abstract</span> E <span class="hljs-title function_">transfer</span><span class="hljs-params">(E e, <span class="hljs-type">boolean</span> timed, <span class="hljs-type">long</span> nanos)</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>构造方法：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">SynchronousQueue</span><span class="hljs-params">(<span class="hljs-type">boolean</span> fair)</span> &#123;  <br>    <span class="hljs-comment">// fair 默认 false  </span><br>    <span class="hljs-comment">// 非公平模式实现的数据结构是栈，公平模式的数据结构是队列  </span><br>    transferer = fair ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransferQueue</span>&lt;E&gt;() : <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransferStack</span>&lt;E&gt;();  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>成员方法：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e)</span> &#123;  <br>    <span class="hljs-keyword">if</span> (e == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();  <br>    <span class="hljs-keyword">return</span> transferer.transfer(e, <span class="hljs-literal">true</span>, <span class="hljs-number">0</span>) != <span class="hljs-literal">null</span>;  <br>&#125;  <br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">return</span> transferer.transfer(<span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>, <span class="hljs-number">0</span>);  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h5 id="非公实现"><a href="#非公实现" class="headerlink" title="非公实现"></a>非公实现</h5><p>TransferStack 是非公平的同步队列，因为所有的请求都被压入栈中，栈顶的元素会最先得到匹配，造成栈底的等待线程饥饿</p><p>TransferStack 类成员变量：</p><ul><li><p>请求类型：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// 表示 Node 类型为请求类型  </span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">REQUEST</span>    <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br><span class="hljs-comment">// 表示 Node类 型为数据类型  </span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DATA</span>       <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;  <br><span class="hljs-comment">// 表示 Node 类型为匹配中类型  </span><br><span class="hljs-comment">// 假设栈顶元素为 REQUEST-NODE，当前请求类型为 DATA，入栈会修改类型为 FULFILLING 【栈顶 &amp; 栈顶之下的一个node】  </span><br><span class="hljs-comment">// 假设栈顶元素为 DATA-NODE，当前请求类型为 REQUEST，入栈会修改类型为 FULFILLING 【栈顶 &amp; 栈顶之下的一个node】  </span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">FULFILLING</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure></li><li><p>栈顶元素：</p><p>  <code>volatile SNode head;</code></p></li></ul><p>内部类 SNode：</p><ul><li><p>成员变量：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SNode</span> &#123;  <br>    <span class="hljs-comment">// 指向下一个栈帧  </span><br>    <span class="hljs-keyword">volatile</span> SNode next;   <br>    <span class="hljs-comment">// 与当前 node 匹配的节点  </span><br>    <span class="hljs-keyword">volatile</span> SNode match;  <br>    <span class="hljs-comment">// 假设当前node对应的线程自旋期间未被匹配成功，那么node对应的线程需要挂起，  </span><br>    <span class="hljs-comment">// 挂起前 waiter 保存对应的线程引用，方便匹配成功后，被唤醒。  </span><br>    <span class="hljs-keyword">volatile</span> Thread waiter;  <br>      <br>    <span class="hljs-comment">// 数据域，不为空表示当前 Node 对应的请求类型为 DATA 类型，反之则表示 Node 为 REQUEST 类型  </span><br>    Object item;   <br>    <span class="hljs-comment">// 表示当前Node的模式 【DATA/REQUEST/FULFILLING】  </span><br>    <span class="hljs-type">int</span> mode;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>构造方法：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><br>SNode(Object item) &#123;  <br>    <span class="hljs-built_in">this</span>.item = item;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>设置方法：设置 Node 对象的 next 字段，此处<strong>对 CAS 进行了优化</strong>，提升了 CAS 的效率</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">casNext</span><span class="hljs-params">(SNode cmp, SNode val)</span> &#123;  <br>    <span class="hljs-comment">//【优化：cmp == next】，可以提升一部分性能。 cmp == next 不相等，就没必要走 cas指令。  </span><br>    <span class="hljs-keyword">return</span> cmp == next &amp;&amp; UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, nextOffset, cmp, val);  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>匹配方法：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">tryMatch</span><span class="hljs-params">(SNode s)</span> &#123;  <br>    <span class="hljs-comment">// 当前 node 尚未与任何节点发生过匹配，CAS 设置 match 字段为 s 节点，表示当前 node 已经被匹配  </span><br>    <span class="hljs-keyword">if</span> (match == <span class="hljs-literal">null</span> &amp;&amp; UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, matchOffset, <span class="hljs-literal">null</span>, s)) &#123;  <br>        <span class="hljs-comment">// 当前 node 如果自旋结束，会 park 阻塞，阻塞前将 node 对应的 Thread 保留到 waiter 字段  </span><br>        <span class="hljs-comment">// 获取当前 node 对应的阻塞线程  </span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> waiter;  <br>        <span class="hljs-comment">// 条件成立说明 node 对应的 Thread 正在阻塞  </span><br>        <span class="hljs-keyword">if</span> (w != <span class="hljs-literal">null</span>) &#123;  <br>            waiter = <span class="hljs-literal">null</span>;  <br>            <span class="hljs-comment">// 使用 unpark 方式唤醒线程  </span><br>            LockSupport.unpark(w);  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    &#125;  <br>    <span class="hljs-comment">// 匹配成功返回 true  </span><br>    <span class="hljs-keyword">return</span> match == s;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>取消方法：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// 取消节点的方法  </span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">tryCancel</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">// match 字段指向自己，表示这个 node 是取消状态，取消状态的 node，最终会被强制移除出栈  </span><br>    UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, matchOffset, <span class="hljs-literal">null</span>, <span class="hljs-built_in">this</span>);  <br>&#125;  <br>  <br><span class="hljs-type">boolean</span> <span class="hljs-title function_">isCancelled</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">return</span> match == <span class="hljs-built_in">this</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>TransferStack 类成员方法：</p><ul><li><p>snode()：填充节点方法</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">static</span> SNode <span class="hljs-title function_">snode</span><span class="hljs-params">(SNode s, Object e, SNode next, <span class="hljs-type">int</span> mode)</span> &#123;  <br>    <span class="hljs-comment">// 引用指向空时，snode 方法会创建一个 SNode 对象   </span><br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span>) s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SNode</span>(e);  <br>    <span class="hljs-comment">// 填充数据  </span><br>    s.mode = mode;  <br>    s.next = next;  <br>    <span class="hljs-keyword">return</span> s;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>transfer()：核心方法，请求匹配出栈，不匹配阻塞</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs java"><br>E <span class="hljs-title function_">transfer</span><span class="hljs-params">(E e, <span class="hljs-type">boolean</span> timed, <span class="hljs-type">long</span> nanos)</span> &#123;  <br><span class="hljs-comment">// 包装当前线程的 node  </span><br>    <span class="hljs-type">SNode</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;  <br>    <span class="hljs-comment">// 根据元素判断当前的请求类型  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">mode</span> <span class="hljs-operator">=</span> (e == <span class="hljs-literal">null</span>) ? REQUEST : DATA;  <br><span class="hljs-comment">// 自旋  </span><br>    <span class="hljs-keyword">for</span> (;;) &#123;  <br>        <span class="hljs-comment">// 获取栈顶指针  </span><br>        <span class="hljs-type">SNode</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;  <br>       <span class="hljs-comment">// 【CASE1】：当前栈为空或者栈顶 node 模式与当前请求模式一致无法匹配，做入栈操作  </span><br>        <span class="hljs-keyword">if</span> (h == <span class="hljs-literal">null</span> || h.mode == mode) &#123;  <br>            <span class="hljs-comment">// 当前请求是支持超时的，但是 nanos &lt;= 0 说明这个请求不支持 “阻塞等待”  </span><br>            <span class="hljs-keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="hljs-number">0</span>) &#123;   <br>                <span class="hljs-comment">// 栈顶元素是取消状态  </span><br>                <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h.isCancelled())  <br>                    <span class="hljs-comment">// 栈顶出栈，设置新的栈顶  </span><br>                    casHead(h, h.next);  <br>                <span class="hljs-keyword">else</span>  <br>                    <span class="hljs-comment">// 表示【匹配失败】  </span><br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>            <span class="hljs-comment">// 入栈  </span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (casHead(h, s = snode(s, e, h, mode))) &#123;  <br>                <span class="hljs-comment">// 等待被匹配的逻辑，正常情况返回匹配的节点；取消情况返回当前节点，就是 s  </span><br>                <span class="hljs-type">SNode</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> awaitFulfill(s, timed, nanos);  <br>                <span class="hljs-comment">// 说明当前 node 是【取消状态】  </span><br>                <span class="hljs-keyword">if</span> (m == s) &#123;   <br>                    <span class="hljs-comment">// 将取消节点出栈  </span><br>                    clean(s);  <br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>                &#125;  <br>                <span class="hljs-comment">// 执行到这说明【匹配成功】了  </span><br>                <span class="hljs-comment">// 栈顶有节点并且 匹配节点还未出栈，需要协助出栈  </span><br>                <span class="hljs-keyword">if</span> ((h = head) != <span class="hljs-literal">null</span> &amp;&amp; h.next == s)  <br>                    casHead(h, s.next);  <br>                <span class="hljs-comment">// 当前 node 模式为 REQUEST 类型，返回匹配节点的 m.item 数据域  </span><br>                <span class="hljs-comment">// 当前 node 模式为 DATA 类型：返回 node.item 数据域，当前请求提交的数据 e  </span><br>                <span class="hljs-keyword">return</span> (E) ((mode == REQUEST) ? m.item : s.item);  <br>            &#125;  <br>        <span class="hljs-comment">// 【CASE2】：逻辑到这说明请求模式不一致，如果栈顶不是 FULFILLING 说明没被其他节点匹配，【当前可以匹配】  </span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!isFulfilling(h.mode)) &#123;  <br>            <span class="hljs-comment">// 头节点是取消节点，match 指向自己，协助出栈  </span><br>            <span class="hljs-keyword">if</span> (h.isCancelled())  <br>                casHead(h, h.next);  <br>            <span class="hljs-comment">// 入栈当前请求的节点  </span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (casHead(h, s=snode(s, e, h, FULFILLING|mode))) &#123;  <br>                <span class="hljs-keyword">for</span> (;;) &#123;   <br>                    <span class="hljs-comment">// m 是 s 的匹配的节点  </span><br>                    <span class="hljs-type">SNode</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> s.next;  <br>                    <span class="hljs-comment">// m 节点在 awaitFulfill 方法中被中断，clean 了自己  </span><br>                    <span class="hljs-keyword">if</span> (m == <span class="hljs-literal">null</span>) &#123;  <br>                        <span class="hljs-comment">// 清空栈  </span><br>                        casHead(s, <span class="hljs-literal">null</span>);  <br>                        s = <span class="hljs-literal">null</span>;  <br>                        <span class="hljs-comment">// 返回到外层自旋中  </span><br>                        <span class="hljs-keyword">break</span>;  <br>                    &#125;  <br>                    <span class="hljs-comment">// 获取匹配节点的下一个节点  </span><br>                    <span class="hljs-type">SNode</span> <span class="hljs-variable">mn</span> <span class="hljs-operator">=</span> m.next;  <br>                    <span class="hljs-comment">// 尝试匹配，【匹配成功】，则将 fulfilling 和 m 一起出栈，并且唤醒被匹配的节点的线程  </span><br>                    <span class="hljs-keyword">if</span> (m.tryMatch(s)) &#123;  <br>                        casHead(s, mn);  <br>                        <span class="hljs-keyword">return</span> (E) ((mode == REQUEST) ? m.item : s.item);  <br>                    &#125; <span class="hljs-keyword">else</span>  <br>                        <span class="hljs-comment">// 匹配失败，出栈 m  </span><br>                        s.casNext(m, mn);  <br>                &#125;  <br>            &#125;  <br>        <span class="hljs-comment">// 【CASE3】：栈顶模式为 FULFILLING 模式，表示【栈顶和栈顶下面的节点正在发生匹配】，当前请求需要做协助工作  </span><br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            <span class="hljs-comment">// h 表示的是 fulfilling 节点，m 表示 fulfilling 匹配的节点  </span><br>            <span class="hljs-type">SNode</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> h.next;  <br>            <span class="hljs-keyword">if</span> (m == <span class="hljs-literal">null</span>)  <br>                <span class="hljs-comment">// 清空栈  </span><br>                casHead(h, <span class="hljs-literal">null</span>);  <br>            <span class="hljs-keyword">else</span> &#123;  <br>                <span class="hljs-type">SNode</span> <span class="hljs-variable">mn</span> <span class="hljs-operator">=</span> m.next;  <br>                <span class="hljs-comment">// m 和 h 匹配，唤醒 m 中的线程  </span><br>                <span class="hljs-keyword">if</span> (m.tryMatch(h))  <br>                    casHead(h, mn);  <br>                <span class="hljs-keyword">else</span>  <br>                    h.casNext(m, mn);  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>awaitFulfill()：阻塞当前线程等待被匹配，返回匹配的节点，或者被取消的节点</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><br>SNode <span class="hljs-title function_">awaitFulfill</span><span class="hljs-params">(SNode s, <span class="hljs-type">boolean</span> timed, <span class="hljs-type">long</span> nanos)</span> &#123;  <br>    <span class="hljs-comment">// 等待的截止时间  </span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> timed ? System.nanoTime() + nanos : <span class="hljs-number">0L</span>;  <br>    <span class="hljs-comment">// 当前线程  </span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> Thread.currentThread();  <br>    <span class="hljs-comment">// 表示当前请求线程在下面的 for(;;) 自旋检查的次数  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">spins</span> <span class="hljs-operator">=</span> (shouldSpin(s) ? (timed ? maxTimedSpins : maxUntimedSpins) : <span class="hljs-number">0</span>);  <br>    <span class="hljs-comment">// 自旋检查逻辑：是否匹配、是否超时、是否被中断  </span><br>    <span class="hljs-keyword">for</span> (;;) &#123;  <br>        <span class="hljs-comment">// 当前线程收到中断信号，需要设置 node 状态为取消状态  </span><br>        <span class="hljs-keyword">if</span> (w.isInterrupted())  <br>            s.tryCancel();  <br>        <span class="hljs-comment">// 获取与当前 s 匹配的节点  </span><br>        <span class="hljs-type">SNode</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> s.match;  <br>        <span class="hljs-keyword">if</span> (m != <span class="hljs-literal">null</span>)  <br>            <span class="hljs-comment">// 可能是正常的匹配的，也可能是取消的  </span><br>            <span class="hljs-keyword">return</span> m;  <br>        <span class="hljs-comment">// 执行了超时限制就判断是否超时  </span><br>        <span class="hljs-keyword">if</span> (timed) &#123;  <br>            nanos = deadline - System.nanoTime();  <br>            <span class="hljs-comment">// 【超时了，取消节点】  </span><br>            <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0L</span>) &#123;  <br>                s.tryCancel();  <br>                <span class="hljs-keyword">continue</span>;  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-comment">// 说明当前线程还可以进行自旋检查  </span><br>        <span class="hljs-keyword">if</span> (spins &gt; <span class="hljs-number">0</span>)  <br>            <span class="hljs-comment">// 自旋一次 递减 1  </span><br>            spins = shouldSpin(s) ? (spins - <span class="hljs-number">1</span>) : <span class="hljs-number">0</span>;  <br>        <span class="hljs-comment">// 说明没有自旋次数了  </span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.waiter == <span class="hljs-literal">null</span>)  <br>            <span class="hljs-comment">//【把当前 node 对应的 Thread 保存到 node.waiter 字段中，要阻塞了】  </span><br>            s.waiter = w;  <br>        <span class="hljs-comment">// 没有超时限制直接阻塞  </span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!timed)  <br>            LockSupport.park(<span class="hljs-built_in">this</span>);  <br>        <span class="hljs-comment">// nanos &gt; 1000 纳秒的情况下，才允许挂起当前线程  </span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nanos &gt; spinForTimeoutThreshold)  <br>            LockSupport.parkNanos(<span class="hljs-built_in">this</span>, nanos);  <br>    &#125;  <br>&#125;<br><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">shouldSpin</span><span class="hljs-params">(SNode s)</span> &#123;  <br>    <span class="hljs-comment">// 获取栈顶  </span><br>    <span class="hljs-type">SNode</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;  <br>    <span class="hljs-comment">// 条件一成立说明当前 s 就是栈顶，允许自旋检查  </span><br>    <span class="hljs-comment">// 条件二成立说明当前 s 节点自旋检查期间，又来了一个与当前 s 节点匹配的请求，双双出栈后条件会成立  </span><br>    <span class="hljs-comment">// 条件三成立前提当前 s 不是栈顶元素，并且当前栈顶正在匹配中，这种状态栈顶下面的元素，都允许自旋检查  </span><br>    <span class="hljs-keyword">return</span> (h == s || h == <span class="hljs-literal">null</span> || isFulfilling(h.mode));  <br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>clear()：指定节点出栈</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">clean</span><span class="hljs-params">(SNode s)</span> &#123;  <br>    <span class="hljs-comment">// 清空数据域和关联线程  </span><br>    s.item = <span class="hljs-literal">null</span>;  <br>    s.waiter = <span class="hljs-literal">null</span>;  <br>      <br><span class="hljs-comment">// 获取取消节点的下一个节点  </span><br>    <span class="hljs-type">SNode</span> <span class="hljs-variable">past</span> <span class="hljs-operator">=</span> s.next;  <br>    <span class="hljs-comment">// 判断后继节点是不是取消节点，是就更新 past  </span><br>    <span class="hljs-keyword">if</span> (past != <span class="hljs-literal">null</span> &amp;&amp; past.isCancelled())  <br>        past = past.next;  <br>  <br>    SNode p;  <br>    <span class="hljs-comment">// 从栈顶开始向下检查，【将栈顶开始向下的 取消状态 的节点全部清理出去】，直到碰到 past 或者不是取消状态为止  </span><br>    <span class="hljs-keyword">while</span> ((p = head) != <span class="hljs-literal">null</span> &amp;&amp; p != past &amp;&amp; p.isCancelled())  <br>        <span class="hljs-comment">// 修改的是内存地址对应的值，p 指向该内存地址所以数据一直在变化  </span><br>        casHead(p, p.next);  <br><span class="hljs-comment">// 说明中间遇到了不是取消状态的节点，继续迭代下去  </span><br>    <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span> &amp;&amp; p != past) &#123;  <br>        <span class="hljs-type">SNode</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> p.next;  <br>        <span class="hljs-keyword">if</span> (n != <span class="hljs-literal">null</span> &amp;&amp; n.isCancelled())  <br>            p.casNext(n, n.next);  <br>        <span class="hljs-keyword">else</span>  <br>            p = n;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h5 id="公平实现"><a href="#公平实现" class="headerlink" title="公平实现"></a>公平实现</h5><p>TransferQueue 是公平的同步队列，采用 FIFO 的队列实现，请求节点与队尾模式不同，需要与队头发生匹配</p><p>TransferQueue 类成员变量：</p><ul><li><p>指向队列的 dummy 节点：</p><p>  <code>transient volatile QNode head;</code></p></li><li><p>指向队列的尾节点：</p><p>  <code>transient volatile QNode tail;</code></p></li><li><p>被清理节点的前驱节点：</p><p>  <code>transient volatile QNode cleanMe;</code></p><p>  入队操作是两步完成的，第一步是 t.next &#x3D; newNode，第二步是 tail &#x3D; newNode，所以队尾节点出队，是一种非常特殊的情况</p></li></ul><p>TransferQueue 内部类：</p><ul><li>QNode：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">QNode</span> &#123;  <br>    <span class="hljs-comment">// 指向当前节点的下一个节点  </span><br>    <span class="hljs-keyword">volatile</span> QNode next;  <br>    <span class="hljs-comment">// 数据域，Node 代表的是 DATA 类型 item 表示数据，否则 Node 代表的 REQUEST 类型，item == null  </span><br>    <span class="hljs-keyword">volatile</span> Object item;  <br>    <span class="hljs-comment">// 假设当前 node 对应的线程自旋期间未被匹配成功，那么 node 对应的线程需要挂起，  </span><br>    <span class="hljs-comment">// 挂起前 waiter 保存对应的线程引用，方便匹配成功后被唤醒。  </span><br>    <span class="hljs-keyword">volatile</span> Thread waiter;  <br>    <span class="hljs-comment">// true 当前 Node 是一个 DATA 类型，false 表示当前 Node 是一个 REQUEST 类型  </span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> isData;  <br>  <br><span class="hljs-comment">// 构建方法  </span><br>    QNode(Object item, <span class="hljs-type">boolean</span> isData) &#123;  <br>        <span class="hljs-built_in">this</span>.item = item;  <br>        <span class="hljs-built_in">this</span>.isData = isData;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 尝试取消当前 node，取消状态的 node 的 item 域指向自己  </span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">tryCancel</span><span class="hljs-params">(Object cmp)</span> &#123;  <br>        UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, itemOffset, cmp, <span class="hljs-built_in">this</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 判断当前 node 是否为取消状态  </span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isCancelled</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> item == <span class="hljs-built_in">this</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 判断当前节点是否 “不在” 队列内，当 next 指向自己时，说明节点已经出队。  </span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isOffList</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> next == <span class="hljs-built_in">this</span>;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>TransferQueue 类成员方法：</p><ul><li><p>设置头尾节点：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">advanceHead</span><span class="hljs-params">(QNode h, QNode nh)</span> &#123;  <br>    <span class="hljs-comment">// 设置头指针指向新的节点，  </span><br>    <span class="hljs-keyword">if</span> (h == head &amp;&amp; UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, headOffset, h, nh))  <br>        <span class="hljs-comment">// 老的头节点出队  </span><br>        h.next = h;  <br>&#125;  <br><span class="hljs-keyword">void</span> <span class="hljs-title function_">advanceTail</span><span class="hljs-params">(QNode t, QNode nt)</span> &#123;  <br>    <span class="hljs-keyword">if</span> (tail == t)  <br>        <span class="hljs-comment">// 更新队尾节点为新的队尾  </span><br>        UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, tailOffset, t, nt);  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>transfer()：核心方法</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java"><br>E <span class="hljs-title function_">transfer</span><span class="hljs-params">(E e, <span class="hljs-type">boolean</span> timed, <span class="hljs-type">long</span> nanos)</span> &#123;  <br>    <span class="hljs-comment">// s 指向当前请求对应的 node  </span><br>    <span class="hljs-type">QNode</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;  <br>    <span class="hljs-comment">// 是否是 DATA 类型的请求  </span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">isData</span> <span class="hljs-operator">=</span> (e != <span class="hljs-literal">null</span>);  <br><span class="hljs-comment">// 自旋  </span><br>    <span class="hljs-keyword">for</span> (;;) &#123;  <br>        <span class="hljs-type">QNode</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail;  <br>        <span class="hljs-type">QNode</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;  <br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span> || h == <span class="hljs-literal">null</span>)  <br>            <span class="hljs-keyword">continue</span>;  <br><span class="hljs-comment">// head 和 tail 同时指向 dummy 节点，说明是空队列  </span><br>        <span class="hljs-comment">// 队尾节点与当前请求类型是一致的情况，说明阻塞队列中都无法匹配，  </span><br>        <span class="hljs-keyword">if</span> (h == t || t.isData == isData) &#123;  <br>            <span class="hljs-comment">// 获取队尾 t 的 next 节点  </span><br>            <span class="hljs-type">QNode</span> <span class="hljs-variable">tn</span> <span class="hljs-operator">=</span> t.next;  <br>            <span class="hljs-comment">// 多线程环境中其他线程可能修改尾节点  </span><br>            <span class="hljs-keyword">if</span> (t != tail)  <br>                <span class="hljs-keyword">continue</span>;  <br>            <span class="hljs-comment">// 已经有线程入队了，更新 tail  </span><br>            <span class="hljs-keyword">if</span> (tn != <span class="hljs-literal">null</span>) &#123;  <br>                advanceTail(t, tn);  <br>                <span class="hljs-keyword">continue</span>;  <br>            &#125;  <br>            <span class="hljs-comment">// 允许超时，超时时间小于 0，这种方法不支持阻塞等待  </span><br>            <span class="hljs-keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="hljs-number">0</span>)  <br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>            <span class="hljs-comment">// 创建 node 的逻辑  </span><br>            <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span>)  <br>                s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QNode</span>(e, isData);  <br>            <span class="hljs-comment">// 将 node 添加到队尾  </span><br>            <span class="hljs-keyword">if</span> (!t.casNext(<span class="hljs-literal">null</span>, s))  <br>                <span class="hljs-keyword">continue</span>;  <br><span class="hljs-comment">// 更新队尾指针  </span><br>            advanceTail(t, s);  <br>              <br>            <span class="hljs-comment">// 当前节点 等待匹配....  </span><br>            <span class="hljs-type">Object</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> awaitFulfill(s, e, timed, nanos);  <br>              <br>            <span class="hljs-comment">// 说明【当前 node 状态为 取消状态】，需要做出队逻辑  </span><br>            <span class="hljs-keyword">if</span> (x == s) &#123;  <br>                clean(t, s);  <br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>            &#125;  <br><span class="hljs-comment">// 说明当前 node 仍然在队列内，匹配成功，需要做出队逻辑  </span><br>            <span class="hljs-keyword">if</span> (!s.isOffList()) &#123;  <br>                <span class="hljs-comment">// t 是当前 s 节点的前驱节点，判断 t 是不是头节点，是就更新 dummy 节点为 s 节点  </span><br>                advanceHead(t, s);  <br>                <span class="hljs-comment">// s 节点已经出队，所以需要把它的 item 域设置为它自己，表示它是个取消状态  </span><br>                <span class="hljs-keyword">if</span> (x != <span class="hljs-literal">null</span>)  <br>                    s.item = s;  <br>                s.waiter = <span class="hljs-literal">null</span>;  <br>            &#125;  <br>            <span class="hljs-keyword">return</span> (x != <span class="hljs-literal">null</span>) ? (E)x : e;  <br><span class="hljs-comment">// 队尾节点与当前请求节点【互补匹配】  </span><br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            <span class="hljs-comment">// h.next 节点，【请求节点与队尾模式不同，需要与队头发生匹配】，TransferQueue 是一个【公平模式】  </span><br>            <span class="hljs-type">QNode</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> h.next;  <br>            <span class="hljs-comment">// 并发导致其他线程修改了队尾节点，或者已经把 head.next 匹配走了  </span><br>            <span class="hljs-keyword">if</span> (t != tail || m == <span class="hljs-literal">null</span> || h != head)  <br>                <span class="hljs-keyword">continue</span>;  <br><span class="hljs-comment">// 获取匹配节点的数据域保存到 x  </span><br>            <span class="hljs-type">Object</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> m.item;  <br>            <span class="hljs-comment">// 判断是否匹配成功  </span><br>            <span class="hljs-keyword">if</span> (isData == (x != <span class="hljs-literal">null</span>) ||  <br>                x == m ||  <br>                !m.casItem(x, e)) &#123;  <br>                advanceHead(h, m);  <br>                <span class="hljs-keyword">continue</span>;  <br>            &#125;  <br><span class="hljs-comment">// 【匹配完成】，将头节点出队，让这个新的头结点成为 dummy 节点  </span><br>            advanceHead(h, m);  <br>            <span class="hljs-comment">// 唤醒该匹配节点的线程  </span><br>            LockSupport.unpark(m.waiter);  <br>            <span class="hljs-keyword">return</span> (x != <span class="hljs-literal">null</span>) ? (E)x : e;  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>awaitFulfill()：阻塞当前线程等待被匹配</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><br>Object <span class="hljs-title function_">awaitFulfill</span><span class="hljs-params">(QNode s, E e, <span class="hljs-type">boolean</span> timed, <span class="hljs-type">long</span> nanos)</span> &#123;  <br>    <span class="hljs-comment">// 表示等待截止时间  </span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> timed ? System.nanoTime() + nanos : <span class="hljs-number">0L</span>;  <br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> Thread.currentThread();  <br>    <span class="hljs-comment">// 自选检查的次数  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">spins</span> <span class="hljs-operator">=</span> ((head.next == s) ? (timed ? maxTimedSpins : maxUntimedSpins) : <span class="hljs-number">0</span>);  <br>    <span class="hljs-keyword">for</span> (;;) &#123;  <br>        <span class="hljs-comment">// 被打断就取消节点  </span><br>        <span class="hljs-keyword">if</span> (w.isInterrupted())  <br>            s.tryCancel(e);  <br>        <span class="hljs-comment">// 获取当前 Node 数据域  </span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> s.item;  <br>          <br>        <span class="hljs-comment">// 当前请求为 DATA 模式时：e 请求带来的数据  </span><br>        <span class="hljs-comment">// s.item 修改为 this，说明当前 QNode 对应的线程 取消状态  </span><br>        <span class="hljs-comment">// s.item 修改为 null 表示已经有匹配节点了，并且匹配节点拿走了 item 数据  </span><br>  <br>        <span class="hljs-comment">// 当前请求为 REQUEST 模式时：e == null  </span><br>        <span class="hljs-comment">// s.item 修改为 this，说明当前 QNode 对应的线程 取消状态  </span><br>        <span class="hljs-comment">// s.item != null 且 item != this  表示当前 REQUEST 类型的 Node 已经匹配到 DATA 了   </span><br>        <span class="hljs-keyword">if</span> (x != e)  <br>            <span class="hljs-keyword">return</span> x;  <br>        <span class="hljs-comment">// 超时检查  </span><br>        <span class="hljs-keyword">if</span> (timed) &#123;  <br>            nanos = deadline - System.nanoTime();  <br>            <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0L</span>) &#123;  <br>                s.tryCancel(e);  <br>                <span class="hljs-keyword">continue</span>;  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-comment">// 自旋次数减一  </span><br>        <span class="hljs-keyword">if</span> (spins &gt; <span class="hljs-number">0</span>)  <br>            --spins;  <br>        <span class="hljs-comment">// 没有自旋次数了，把当前线程封装进去 waiter  </span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.waiter == <span class="hljs-literal">null</span>)  <br>            s.waiter = w;  <br>        <span class="hljs-comment">// 阻塞  </span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!timed)  <br>            LockSupport.park(<span class="hljs-built_in">this</span>);  <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nanos &gt; spinForTimeoutThreshold)  <br>            LockSupport.parkNanos(<span class="hljs-built_in">this</span>, nanos);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><p>TODO HERE</p><h3 id="操作Pool"><a href="#操作Pool" class="headerlink" title="操作Pool"></a>操作Pool</h3><h4 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h4><h5 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h5><p>存放线程的容器：</p><p><code>private final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;();</code></p><p>构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,  </span><br><span class="hljs-params">                          <span class="hljs-type">int</span> maximumPoolSize,  </span><br><span class="hljs-params">                          <span class="hljs-type">long</span> keepAliveTime,  </span><br><span class="hljs-params">                          TimeUnit unit,  </span><br><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue,  </span><br><span class="hljs-params">                          ThreadFactory threadFactory,  </span><br><span class="hljs-params">                          RejectedExecutionHandler handler)</span><br></code></pre></td></tr></table></figure><p>参数介绍：</p><ul><li><p>corePoolSize：核心线程数，定义了最小可以同时运行的线程数量</p></li><li><p>maximumPoolSize：最大线程数，当队列中存放的任务达到队列容量时，当前可以同时运行的数量变为最大线程数，创建线程并立即执行最新的任务，与核心线程数之间的差值又叫救急线程数</p></li><li><p>keepAliveTime：救急线程最大存活时间，当线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等到 <code>keepAliveTime</code> 时间超过销毁</p></li><li><p>unit：<code>keepAliveTime</code> 参数的时间单位</p></li><li><p>workQueue：阻塞队列，存放被提交但尚未被执行的任务</p></li><li><p>threadFactory：线程工厂，创建新线程时用到，可以为线程创建时起名字</p></li><li><p>handler：拒绝策略，线程到达最大线程数仍有新任务时会执行拒绝策略</p><p>  RejectedExecutionHandler 下有 4 个实现类：</p><ul><li><p>AbortPolicy：让调用者抛出 RejectedExecutionException 异常，<strong>默认策略</strong></p></li><li><p>CallerRunsPolicy：让调用者运行的调节机制，将某些任务回退到调用者，从而降低新任务的流量</p></li><li><p>DiscardPolicy：直接丢弃任务，不予任何处理也不抛出异常</p></li><li><p>DiscardOldestPolicy：放弃队列中最早的任务，把当前任务加入队列中尝试再次提交当前任务</p></li></ul><p>  补充：其他框架拒绝策略</p><ul><li><p>Dubbo：在抛出 RejectedExecutionException 异常前记录日志，并 dump 线程栈信息，方便定位问题</p></li><li><p>Netty：创建一个新线程来执行任务</p></li><li><p>ActiveMQ：带超时等待（60s）尝试放入队列</p></li><li><p>PinPoint：它使用了一个拒绝策略链，会逐一尝试策略链中每种拒绝策略</p></li></ul></li></ul><p>工作原理：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041808994.png"></p><ol><li><p>创建线程池，这时没有创建线程（<strong>懒惰</strong>），等待提交过来的任务请求，调用 execute 方法才会创建线程</p></li><li><p>当调用 execute() 方法添加一个请求任务时，线程池会做如下判断：</p><ul><li><p>如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务</p></li><li><p>如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列</p></li><li><p>如果这时队列满了且正在运行的线程数量还小于 maximumPoolSize，那么会创建非核心线程<strong>立刻运行这个任务</strong>，对于阻塞队列中的任务不公平。这是因为创建每个 Worker（线程）对象会绑定一个初始任务，启动 Worker 时会优先执行</p></li><li><p>如果队列满了且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会启动饱和<strong>拒绝策略</strong>来执行</p></li></ul></li><li><p>当一个线程完成任务时，会从队列中取下一个任务来执行</p></li><li><p>当一个线程空闲超过一定的时间（keepAliveTime）时，线程池会判断：如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉，所以线程池的所有任务完成后最终会收缩到 corePoolSize 大小</p></li></ol><hr><h5 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h5><p>Executors 提供了四种线程池的创建：newCachedThreadPool、newFixedThreadPool、newSingleThreadExecutor、newScheduledThreadPool</p><ul><li><p>newFixedThreadPool：创建一个拥有 n 个线程的线程池</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> nThreads)</span> &#123;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(nThreads, nThreads, <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,  <br>                                  <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>核心线程数 &#x3D;&#x3D; 最大线程数（没有救急线程被创建），因此也无需超时时间</p></li><li><p>LinkedBlockingQueue 是一个单向链表实现的阻塞队列，默认大小为 <code>Integer.MAX_VALUE</code>，也就是无界队列，可以放任意数量的任务，在任务比较多的时候会导致 OOM（内存溢出）</p></li><li><p>适用于任务量已知，相对耗时的长期任务</p></li></ul></li><li><p>newCachedThreadPool：创建一个可扩容的线程池</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newCachedThreadPool</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">0</span>, Integer.MAX_VALUE, <span class="hljs-number">60L</span>, TimeUnit.SECONDS,  <br>                                  <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;Runnable&gt;());  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>核心线程数是 0， 最大线程数是 29 个 1，全部都是救急线程（60s 后可以回收），可能会创建大量线程，从而导致 <strong>OOM</strong></p></li><li><p>SynchronousQueue 作为阻塞队列，没有容量，对于每一个 take 的线程会阻塞直到有一个 put 的线程放入元素为止（类似一手交钱、一手交货）</p></li><li><p>适合任务数比较密集，但每个任务执行时间较短的情况</p></li></ul></li><li><p>newSingleThreadExecutor：创建一个只有 1 个线程的单线程池</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newSingleThreadExecutor</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FinalizableDelegatedExecutorService</span>  <br>        (<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,  <br>                                <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>保证所有任务按照<strong>指定顺序执行</strong>，线程数固定为 1，任务数多于 1 时会放入无界队列排队，任务执行完毕，这唯一的线程也不会被释放</li></ul></li></ul><p>对比：</p><ul><li><p>创建一个单线程串行执行任务，如果任务执行失败而终止那么没有任何补救措施，线程池会新建一个线程，保证池的正常工作</p></li><li><p>Executors.newSingleThreadExecutor() 线程个数始终为 1，不能修改。FinalizableDelegatedExecutorService 应用的是装饰器模式，只对外暴露了 ExecutorService 接口，因此不能调用 ThreadPoolExecutor 中特有的方法</p><p>  原因：父类不能直接调用子类中的方法，需要反射或者创建对象的方式，可以调用子类静态方法</p></li><li><p>Executors.newFixedThreadPool(1) 初始时为 1，可以修改。对外暴露的是 ThreadPoolExecutor 对象，可以强转后调用 setCorePoolSize 等方法进行修改</p></li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041812233.png"></p><hr><h5 id="开发要求"><a href="#开发要求" class="headerlink" title="开发要求"></a>开发要求</h5><p>阿里巴巴 Java 开发手册要求：</p><ul><li><p><strong>线程资源必须通过线程池提供，不允许在应用中自行显式创建线程</strong></p><ul><li><p>使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源的开销，解决资源不足的问题</p></li><li><p>如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者过度切换的问题</p></li></ul></li><li><p>线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式更加明确线程池的运行规则，规避资源耗尽的风险</p><p>  Executors 返回的线程池对象弊端如下：</p><ul><li><p>FixedThreadPool 和 SingleThreadPool：请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM</p></li><li><p>CacheThreadPool 和 ScheduledThreadPool：允许创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，导致 OOM</p></li></ul></li></ul><p>创建多大容量的线程池合适？</p><ul><li><p>一般来说池中<strong>总线程数是核心池线程数量两倍</strong>，确保当核心池有线程停止时，核心池外有线程进入核心池</p></li><li><p>过小会导致程序不能充分地利用系统资源、容易导致饥饿</p></li><li><p>过大会导致更多的线程上下文切换，占用更多内存</p><p>  上下文切换：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态，任务从保存到再加载的过程就是一次上下文切换</p></li></ul><p>核心线程数常用公式：</p><ul><li><p><strong>CPU 密集型任务 (N+1)：</strong> 这种任务消耗的是 CPU 资源，可以将核心线程数设置为 N (CPU 核心数) + 1，比 CPU 核心数多出来的一个线程是为了防止线程发生缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 某个核心就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间</p><p>  CPU 密集型简单理解就是利用 CPU 计算能力的任务比如在内存中对大量数据进行分析</p></li><li><p><strong>I&#x2F;O 密集型任务：</strong> 这种系统 CPU 处于阻塞状态，用大部分的时间来处理 I&#x2F;O 交互，而线程在处理 I&#x2F;O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用，因此在 I&#x2F;O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N 或 CPU 核数&#x2F; (1-阻塞系数)，阻塞系数在 0.8~0.9 之间</p><p>  IO 密集型就是涉及到网络读取，文件读取此类任务 ，特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上</p></li></ul><hr><h4 id="提交方法"><a href="#提交方法" class="headerlink" title="提交方法"></a>提交方法</h4><p>ExecutorService 类 API：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//执行任务（Executor 类 API）</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> <br><br><span class="hljs-comment">//提交任务 task()</span><br>Future&lt; ?&gt; submit(Runnable task) <br><br><span class="hljs-comment">//提交任务 task，用返回值 Future 获得任务执行结果</span><br>Future <span class="hljs-title function_">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span> <br><br><span class="hljs-comment">//提交 tasks 中所有任务</span><br>List&lt;Future&lt;T&gt;&gt; <span class="hljs-title function_">invokeAll</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span> <br><br><span class="hljs-comment">//提交 tasks 中所有任务，超时时间针对所有task，超时会取消没有执行完的任务，并抛出超时异常</span><br>List&lt;Future&lt;T&gt;&gt; <span class="hljs-title function_">invokeAll</span><span class="hljs-params">(Collection&lt; ? extends Callable&lt;T&gt;&gt; tasks, <span class="hljs-type">long</span> timeout, TimeUnit unit)</span> <br><br><span class="hljs-comment">//提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消</span><br>T <span class="hljs-title function_">invokeAny</span><span class="hljs-params">(Collection&lt; ? extends Callable&lt;T&gt;&gt; tasks)</span> <br></code></pre></td></tr></table></figure><p>execute 和 submit 都属于线程池的方法，对比：</p><ul><li><p>execute 只能执行 Runnable 类型的任务，没有返回值； submit 既能提交 Runnable 类型任务也能提交 Callable 类型任务，底层是<strong>封装成 FutureTask，然后调用 execute 执行</strong></p></li><li><p>execute 会直接抛出任务执行时的异常，submit 会吞掉异常，可通过 Future 的 get 方法将任务执行时的异常重新抛出</p></li></ul><hr><h4 id="关闭方法"><a href="#关闭方法" class="headerlink" title="关闭方法"></a>关闭方法</h4><p>ExecutorService 类 API：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">//线程池状态变为 SHUTDOWN，等待任务执行完后关闭线程池，不会接收新任务，但已提交任务会执行完，而且也可以添加线程（不绑定任务）</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">()</span><br><br><span class="hljs-comment">//线程池状态变为 STOP，用 interrupt 中断正在执行的任务，直接关闭线程池，不会接收新任务，会将队列中的任务返回</span><br>List&lt;Runnable&gt; <span class="hljs-title function_">shutdownNow</span><span class="hljs-params">()</span><br><br><span class="hljs-comment">//不在 RUNNING 状态的线程池，此执行者已被关闭，方法返回 true</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">isShutdown</span><span class="hljs-params">()</span><br><br><span class="hljs-comment">//线程池状态是否是 TERMINATED，如果所有任务在关闭后完成，返回 true</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">isTerminated</span><span class="hljs-params">()</span><br><br><span class="hljs-comment">//调用 shutdown 后，由于调用线程不会等待所有任务运行结束，如果它想在线程池 TERMINATED 后做些事情，可以利用此方法等待</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">awaitTermination</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br><br></code></pre></td></tr></table></figure><hr><h4 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h4><p>execute 会直接抛出任务执行时的异常，submit 会吞掉异常，有两种处理方法</p><p>方法 1：主动捉异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">1</span>);  <br>pool.submit(() -&gt; &#123;  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;task1&quot;</span>);  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> / <span class="hljs-number">0</span>;  <br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;  <br>        e.printStackTrace();  <br>    &#125;  <br>&#125;);<br></code></pre></td></tr></table></figure><p>方法 2：使用 Future 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">1</span>);  <br>Future&lt;?&gt; future = pool.submit(() -&gt; &#123;  <br>    System.out.println(<span class="hljs-string">&quot;task1&quot;</span>);  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> / <span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>&#125;);  <br>System.out.println(future.get());<br></code></pre></td></tr></table></figure><hr><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><h4 id="状态信息"><a href="#状态信息" class="headerlink" title="状态信息"></a>状态信息</h4><p>ThreadPoolExecutor 使用 int 的<strong>高 3 位来表示线程池状态，低 29 位表示线程数量</strong>。这些信息存储在一个原子变量 ctl 中，目的是将线程池状态与线程个数合二为一，这样就可以用一次 CAS 原子操作进行赋值</p><ul><li><p>状态表示：</p><p>  &#x2F;&#x2F; 高3位：表示当前线程池运行状态，除去高3位之后的低位：表示当前线程池中所拥有的线程数量<br>  <code>private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));  </code><br>  &#x2F;&#x2F; 表示在 ctl 中，低 COUNT_BITS 位，是用于存放当前线程数量的位<br>  <code>private static final int COUNT_BITS = Integer.SIZE - 3;  </code><br>  &#x2F;&#x2F; 低 COUNT_BITS 位所能表达的最大数值，000 11111111111111111111 &#x3D;&gt; 5亿多<br>  <code>private static final int CAPACITY   = (1 &lt;&lt; COUNT_BITS) - 1;</code></p><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041822556.png"></p></li><li><p>四种状态：</p><p>  &#x2F;&#x2F; 111 000000000000000000，转换成整数后其实就是一个【负数】<br>  private static final int RUNNING    &#x3D; -1 &lt;&lt; COUNT_BITS;<br>  &#x2F;&#x2F; 000 000000000000000000<br>  private static final int SHUTDOWN   &#x3D;  0 &lt;&lt; COUNT_BITS;<br>  &#x2F;&#x2F; 001 000000000000000000<br>  private static final int STOP       &#x3D;  1 &lt;&lt; COUNT_BITS;<br>  &#x2F;&#x2F; 010 000000000000000000<br>  private static final int TIDYING    &#x3D;  2 &lt;&lt; COUNT_BITS;<br>  &#x2F;&#x2F; 011 000000000000000000<br>  private static final int TERMINATED &#x3D;  3 &lt;&lt; COUNT_BITS;</p><table><thead><tr><th>状态</th><th>高3位</th><th>接收新任务</th><th>处理阻塞任务队列</th><th>说明</th></tr></thead><tbody><tr><td>RUNNING</td><td>111</td><td>Y</td><td>Y</td><td></td></tr><tr><td>SHUTDOWN</td><td>000</td><td>N</td><td>Y</td><td>不接收新任务，但处理阻塞队列剩余任务</td></tr><tr><td>STOP</td><td>001</td><td>N</td><td>N</td><td>中断正在执行的任务，并抛弃阻塞队列任务</td></tr><tr><td>TIDYING</td><td>010</td><td>-</td><td>-</td><td>任务全执行完毕，活动线程为 0 即将进入终结</td></tr><tr><td>TERMINATED</td><td>011</td><td>-</td><td>-</td><td>终止状态</td></tr></tbody></table></li><li><p>获取当前线程池运行状态：</p><p>  &#x2F;&#x2F; ~CAPACITY &#x3D; ~000 11111111111111111111 &#x3D; 111 000000000000000000000（取反）<br>  &#x2F;&#x2F; c &#x3D;&#x3D; ctl &#x3D; 111 000000000000000000111<br>  &#x2F;&#x2F; 111 000000000000000000111<br>  &#x2F;&#x2F; 111 000000000000000000000<br>  &#x2F;&#x2F; 111 000000000000000000000获取到了运行状态<br>  <code>private static int runStateOf(int c)     &#123; return c &amp; ~CAPACITY; &#125;</code></p></li><li><p>获取当前线程池线程数量：</p><p>  &#x2F;&#x2F;        c &#x3D; 111 000000000000000000111<br>  &#x2F;&#x2F; CAPACITY &#x3D; 000 111111111111111111111<br>  &#x2F;&#x2F;            000 000000000000000000111 &#x3D;&gt; 7<br>  <code>private static int workerCountOf(int c)  &#123; return c &amp; CAPACITY; &#125;</code></p></li><li><p>重置当前线程池状态 ctl：</p><p>  &#x2F;&#x2F; rs 表示线程池状态，wc 表示当前线程池中 worker（线程）数量，相与以后就是合并后的状态<br>  <code>private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125;</code></p></li><li><p>比较当前线程池 ctl 所表示的状态：</p><p>  &#x2F;&#x2F; 比较当前线程池 ctl 所表示的状态，是否小于某个状态 s<br>  &#x2F;&#x2F; 状态对比：RUNNING &lt; SHUTDOWN &lt; STOP &lt; TIDYING &lt; TERMINATED<br>  <code>private static boolean runStateLessThan(int c, int s) &#123; return c &lt; s; &#125;  </code><br>  &#x2F;&#x2F; 比较当前线程池 ctl 所表示的状态，是否大于等于某个状态s<br>  <code>private static boolean runStateAtLeast(int c, int s) &#123; return c &gt;= s; &#125;  </code><br>  &#x2F;&#x2F; 小于 SHUTDOWN 的一定是 RUNNING，SHUTDOWN &#x3D;&#x3D; 0<br>  <code>private static boolean isRunning(int c) &#123; return c &lt; SHUTDOWN; &#125;</code></p></li><li><p>设置线程池 ctl：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用 CAS 方式 让 ctl 值 +1 ，成功返回 true, 失败返回 false  </span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndIncrementWorkerCount</span><span class="hljs-params">(<span class="hljs-type">int</span> expect)</span> &#123;  <br>    <span class="hljs-keyword">return</span> ctl.compareAndSet(expect, expect + <span class="hljs-number">1</span>);  <br>&#125;  <br><span class="hljs-comment">// 使用 CAS 方式 让 ctl 值 -1 ，成功返回 true, 失败返回 false  </span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndDecrementWorkerCount</span><span class="hljs-params">(<span class="hljs-type">int</span> expect)</span> &#123;  <br>    <span class="hljs-keyword">return</span> ctl.compareAndSet(expect, expect - <span class="hljs-number">1</span>);  <br>&#125;  <br><span class="hljs-comment">// 将 ctl 值减一，do while 循环会一直重试，直到成功为止  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decrementWorkerCount</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">do</span> &#123;&#125; <span class="hljs-keyword">while</span> (!compareAndDecrementWorkerCount(ctl.get()));  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h4 id="成员属性-2"><a href="#成员属性-2" class="headerlink" title="成员属性"></a>成员属性</h4><p>成员变量</p><ul><li><p><strong>线程池中存放 Worker 的容器</strong>：线程池没有初始化，直接往池中加线程即可</p><p>  <code>private final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;();</code></p></li><li><p>线程全局锁：</p><p>  &#x2F;&#x2F; 增加减少 worker 或者时修改线程池运行状态需要持有 mainLock<br>  <code>private final ReentrantLock mainLock = new ReentrantLock();</code></p></li><li><p>可重入锁的条件变量：</p><p>  &#x2F;&#x2F; 当外部线程调用 awaitTermination() 方法时，会等待当前线程池状态为 Termination 为止<br>  <code>private final Condition termination = mainLock.newCondition()</code></p></li><li><p>线程池相关参数：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> corePoolSize;<span class="hljs-comment">// 核心线程数量  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> maximumPoolSize;<span class="hljs-comment">// 线程池最大线程数量  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> keepAliveTime;<span class="hljs-comment">// 空闲线程存活时间  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> ThreadFactory threadFactory;<span class="hljs-comment">// 创建线程时使用的线程工厂，默认是 DefaultThreadFactory  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;<span class="hljs-comment">// 【超过核心线程提交任务就放入 阻塞队列】</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> RejectedExecutionHandler handler;<span class="hljs-comment">// 拒绝策略，juc包提供了4中方式  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">RejectedExecutionHandler</span> <span class="hljs-variable">defaultHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbortPolicy</span>();<span class="hljs-comment">// 默认策略</span><br></code></pre></td></tr></table></figure></li><li><p>记录线程池相关属性的数值：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> largestPoolSize;<span class="hljs-comment">// 记录线程池生命周期内线程数最大值  </span><br><span class="hljs-keyword">private</span> <span class="hljs-type">long</span> completedTaskCount;<span class="hljs-comment">// 记录线程池所完成任务总数，当某个 worker 退出时将完成的任务累加到该属性</span><br></code></pre></td></tr></table></figure></li><li><p>控制<strong>核心线程数量内的线程是否可以被回收</strong>：</p><p>  &#x2F;&#x2F; false（默认）代表不可以，为 true 时核心线程空闲超过 keepAliveTime 也会被回收<br>  &#x2F;&#x2F; allowCoreThreadTimeOut(boolean value) 方法可以设置该值<br>  <code>private volatile boolean allowCoreThreadTimeOut;</code></p></li></ul><p>内部类：</p><ul><li><p>Worker 类：<strong>每个 Worker 对象会绑定一个初始任务</strong>，启动 Worker 时优先执行，这也是造成线程池不公平的原因。Worker 继承自 AQS，本身具有锁的特性，采用独占锁模式，state &#x3D; 0 表示未被占用，&gt; 0 表示被占用，&lt; 0 表示初始状态不能被抢锁</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;  <br><span class="hljs-keyword">final</span> Thread thread;<span class="hljs-comment">// worker 内部封装的工作线程  </span><br>    Runnable firstTask;<span class="hljs-comment">// worker 第一个执行的任务，普通的 Runnable 实现类或者是 FutureTask  </span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> completedTasks;<span class="hljs-comment">// 记录当前 worker 所完成任务数量  </span><br>      <br>    <span class="hljs-comment">// 构造方法  </span><br>    Worker(Runnable firstTask) &#123;  <br>        <span class="hljs-comment">// 设置AQS独占模式为初始化中状态，这个状态不能被抢占锁  </span><br>       setState(-<span class="hljs-number">1</span>);  <br>        <span class="hljs-comment">// firstTask不为空时，当worker启动后，内部线程会优先执行firstTask，执行完后会到queue中去获取下个任务  </span><br>        <span class="hljs-built_in">this</span>.firstTask = firstTask;  <br>        <span class="hljs-comment">// 使用线程工厂创建一个线程，并且【将当前worker指定为Runnable】，所以thread启动时会调用 worker.run()  </span><br>        <span class="hljs-built_in">this</span>.thread = getThreadFactory().newThread(<span class="hljs-built_in">this</span>);  <br>    &#125;  <br>    <span class="hljs-comment">// 【不可重入锁】  </span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> unused)</span> &#123;  <br>        <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;  <br>            setExclusiveOwnerThread(Thread.currentThread());  <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>    &#125;  <br>&#125;<br><br><span class="hljs-keyword">public</span> Thread <span class="hljs-title function_">newThread</span><span class="hljs-params">(Runnable r)</span> &#123;  <br>    <span class="hljs-comment">// 将当前 worker 指定为 thread 的执行方法，线程调用 start 会调用 r.run()  </span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(group, r, namePrefix + threadNumber.getAndIncrement(), <span class="hljs-number">0</span>);  <br>    <span class="hljs-keyword">if</span> (t.isDaemon())  <br>        t.setDaemon(<span class="hljs-literal">false</span>);  <br>    <span class="hljs-keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)  <br>        t.setPriority(Thread.NORM_PRIORITY);  <br>    <span class="hljs-keyword">return</span> t;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>拒绝策略相关的内部类</p></li></ul><hr><h4 id="成员方法-2"><a href="#成员方法-2" class="headerlink" title="成员方法"></a>成员方法</h4><h5 id="提交方法-1"><a href="#提交方法-1" class="headerlink" title="提交方法"></a>提交方法</h5><ul><li><p>AbstractExecutorService#submit()：提交任务，<strong>把 Runnable 或 Callable 任务封装成 FutureTask 执行</strong>，可以通过方法返回的任务对象，调用 get 阻塞获取任务执行的结果或者异常，源码分析在笔记的 Future 部分</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;  <br>    <span class="hljs-comment">// 空指针异常  </span><br>    <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();  <br>    <span class="hljs-comment">// 把 Runnable 封装成未来任务对象，执行结果就是 null，也可以通过参数指定 FutureTask#get 返回数据  </span><br>    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="hljs-literal">null</span>);  <br>    <span class="hljs-comment">// 执行方法  </span><br>    execute(ftask);  <br>    <span class="hljs-keyword">return</span> ftask;  <br>&#125;  <br><span class="hljs-keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span> &#123;  <br>    <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();  <br>    <span class="hljs-comment">// 把 Callable 封装成未来任务对象  </span><br>    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);  <br>    <span class="hljs-comment">// 执行方法  </span><br>    execute(ftask);  <br>    <span class="hljs-comment">// 返回未来任务对象，用来获取返回值  </span><br>    <span class="hljs-keyword">return</span> ftask;  <br>&#125;<br><br><span class="hljs-keyword">protected</span> &lt;T&gt; RunnableFuture&lt;T&gt; <span class="hljs-title function_">newTaskFor</span><span class="hljs-params">(Runnable runnable, T value)</span> &#123;  <br>    <span class="hljs-comment">// Runnable 封装成 FutureTask，【指定返回值】  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;T&gt;(runnable, value);  <br>&#125;  <br><span class="hljs-keyword">protected</span> &lt;T&gt; RunnableFuture&lt;T&gt; <span class="hljs-title function_">newTaskFor</span><span class="hljs-params">(Callable&lt;T&gt; callable)</span> &#123;  <br>    <span class="hljs-comment">// Callable 直接封装成 FutureTask  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;T&gt;(callable);  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>execute()：执行任务，<strong>但是没有返回值，没办法获取任务执行结果</strong>，出现异常会直接抛出任务执行时的异常。根据线程池中的线程数，选择添加任务时的处理方式</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// command 可以是普通的 Runnable 实现类，也可以是 FutureTask，不能是 Callable  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> &#123;  <br>    <span class="hljs-comment">// 非空判断  </span><br>    <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span>)  <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();  <br>  <span class="hljs-comment">// 获取 ctl 最新值赋值给 c，ctl 高 3 位表示线程池状态，低位表示当前线程池线程数量。  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();  <br>    <span class="hljs-comment">// 【1】当前线程数量小于核心线程数，此次提交任务直接创建一个新的 worker，线程池中多了一个新的线程  </span><br>    <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;  <br>        <span class="hljs-comment">// addWorker 为创建线程的过程，会创建 worker 对象并且将 command 作为 firstTask，优先执行  </span><br>        <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-literal">true</span>))  <br>            <span class="hljs-keyword">return</span>;  <br>          <br>        <span class="hljs-comment">// 执行到这条语句，说明 addWorker 一定是失败的，存在并发现象或者线程池状态被改变，重新获取状态  </span><br>        <span class="hljs-comment">// SHUTDOWN 状态下也有可能创建成功，前提 firstTask == null 而且当前 queue 不为空（特殊情况）  </span><br>        c = ctl.get();  <br>    &#125;  <br>    <span class="hljs-comment">// 【2】执行到这说明当前线程数量已经达到核心线程数量 或者 addWorker 失败  </span><br>    <span class="hljs-comment">// 判断当前线程池是否处于running状态，成立就尝试将 task 放入到 workQueue 中  </span><br>    <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">recheck</span> <span class="hljs-operator">=</span> ctl.get();  <br>        <span class="hljs-comment">// 条件一成立说明线程池状态被外部线程给修改了，可能是执行了 shutdown() 方法，该状态不能接收新提交的任务  </span><br>        <span class="hljs-comment">// 所以要把刚提交的任务删除，删除成功说明提交之后线程池中的线程还未消费（处理）该任务  </span><br>        <span class="hljs-keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))  <br>            <span class="hljs-comment">// 任务出队成功，走拒绝策略  </span><br>            reject(command);  <br>        <span class="hljs-comment">// 执行到这说明线程池是 running 状态，获取线程池中的线程数量，判断是否是 0  </span><br>        <span class="hljs-comment">// 【担保机制】，保证线程池在 running 状态下，最起码得有一个线程在工作  </span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)  <br>            addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);  <br>    &#125;  <br>    <span class="hljs-comment">// 【3】offer失败说明queue满了  </span><br>    <span class="hljs-comment">// 如果线程数量尚未达到 maximumPoolSize，会创建非核心 worker 线程直接执行 command，【这也是不公平的原因】  </span><br>    <span class="hljs-comment">// 如果当前线程数量达到 maximumPoolSiz，这里 addWorker 也会失败，走拒绝策略  </span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-literal">false</span>))  <br>        reject(command);  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h5 id="添加线程"><a href="#添加线程" class="headerlink" title="添加线程"></a>添加线程</h5><ul><li><p>prestartAllCoreThreads()：<strong>提前预热</strong>，创建所有的核心线程</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">prestartAllCoreThreads</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">while</span> (addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>))  <br>        ++n;  <br>    <span class="hljs-keyword">return</span> n;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>addWorker()：<strong>添加线程到线程池</strong>，返回 true 表示创建 Worker 成功，且线程启动。首先判断线程池是否允许添加线程，允许就让线程数量 + 1，然后去创建 Worker 加入线程池</p><p>  注意：SHUTDOWN 状态也能添加线程，但是要求新加的 Woker 没有 firstTask，而且当前 queue 不为空，所以创建一个线程来帮助线程池执行队列中的任务</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// core == true 表示采用核心线程数量限制，false 表示采用 maximumPoolSize  </span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addWorker</span><span class="hljs-params">(Runnable firstTask, <span class="hljs-type">boolean</span> core)</span> &#123;  <br>    <span class="hljs-comment">// 自旋【判断当前线程池状态是否允许创建线程】，允许就设置线程数量 + 1  </span><br>    retry:  <br>    <span class="hljs-keyword">for</span> (;;) &#123;  <br>        <span class="hljs-comment">// 获取 ctl 的值  </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();  <br>        <span class="hljs-comment">// 获取当前线程池运行状态  </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(c);  <br>          <br>        <span class="hljs-comment">// 判断当前线程池状态【是否允许添加线程】  </span><br>          <br>        <span class="hljs-comment">// 当前线程池是 SHUTDOWN 状态，但是队列里面还有任务尚未处理完，需要处理完 queue 中的任务  </span><br>        <span class="hljs-comment">// 【不允许再提交新的 task，所以 firstTask 为空，但是可以继续添加 worker】  </span><br>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; !(rs == SHUTDOWN &amp;&amp; firstTask == <span class="hljs-literal">null</span> &amp;&amp; !workQueue.isEmpty()))  <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>        <span class="hljs-keyword">for</span> (;;) &#123;  <br>            <span class="hljs-comment">// 获取线程池中线程数量  </span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">wc</span> <span class="hljs-operator">=</span> workerCountOf(c);  <br>            <span class="hljs-comment">// 条件一一般不成立，CAPACITY是5亿多，根据 core 判断使用哪个大小限制线程数量，超过了返回 false  </span><br>            <span class="hljs-keyword">if</span> (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize))  <br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>            <span class="hljs-comment">// 记录线程数量已经加 1，类比于申请到了一块令牌，条件失败说明其他线程修改了数量  </span><br>            <span class="hljs-keyword">if</span> (compareAndIncrementWorkerCount(c))  <br>                <span class="hljs-comment">// 申请成功，跳出了 retry 这个 for 自旋  </span><br>                <span class="hljs-keyword">break</span> retry;  <br>            <span class="hljs-comment">// CAS 失败，没有成功的申请到令牌  </span><br>            c = ctl.get();  <br>            <span class="hljs-comment">// 判断当前线程池状态是否发生过变化，被其他线程修改了，可能其他线程调用了 shutdown() 方法  </span><br>            <span class="hljs-keyword">if</span> (runStateOf(c) != rs)  <br>                <span class="hljs-comment">// 返回外层循环检查是否能创建线程，在 if 语句中返回 false  </span><br>                <span class="hljs-keyword">continue</span> retry;  <br>             <br>        &#125;  <br>    &#125;  <br>      <br>    <span class="hljs-comment">//【令牌申请成功，开始创建线程】  </span><br>      <br><span class="hljs-comment">// 运行标记，表示创建的 worker 是否已经启动，false未启动  true启动  </span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">workerStarted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;  <br>    <span class="hljs-comment">// 添加标记，表示创建的 worker 是否添加到池子中了，默认false未添加，true是添加。  </span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">workerAdded</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;  <br>    <span class="hljs-type">Worker</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-comment">// 【创建 Worker，底层通过线程工厂 newThread 方法创建执行线程，指定了首先执行的任务】  </span><br>        w = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(firstTask);  <br>        <span class="hljs-comment">// 将新创建的 worker 节点中的线程赋值给 t  </span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> w.thread;  <br>        <span class="hljs-comment">// 这里的判断为了防止 程序员自定义的 ThreadFactory 实现类有 bug，创造不出线程  </span><br>        <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;  <br>            <span class="hljs-comment">// 加互斥锁，要添加 worker 了  </span><br>            mainLock.lock();  <br>            <span class="hljs-keyword">try</span> &#123;  <br>                <span class="hljs-comment">// 获取最新线程池运行状态保存到 rs  </span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(ctl.get());  <br><span class="hljs-comment">// 判断线程池是否为RUNNING状态，不是再【判断当前是否为SHUTDOWN状态且firstTask为空，特殊情况】  </span><br>                <span class="hljs-keyword">if</span> (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == <span class="hljs-literal">null</span>)) &#123;  <br>                    <span class="hljs-comment">// 当线程start后，线程isAlive会返回true，这里还没开始启动线程，如果被启动了就需要报错  </span><br>                    <span class="hljs-keyword">if</span> (t.isAlive())  <br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalThreadStateException</span>();  <br>                      <br>                    <span class="hljs-comment">//【将新建的 Worker 添加到线程池中】  </span><br>                    workers.add(w);  <br>                    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> workers.size();  <br><span class="hljs-comment">// 当前池中的线程数量是一个新高，更新 largestPoolSize  </span><br>                    <span class="hljs-keyword">if</span> (s &gt; largestPoolSize)  <br>                        largestPoolSize = s;  <br>                    <span class="hljs-comment">// 添加标记置为 true  </span><br>                    workerAdded = <span class="hljs-literal">true</span>;  <br>                &#125;  <br>            &#125; <span class="hljs-keyword">finally</span> &#123;  <br>                <span class="hljs-comment">// 解锁啊  </span><br>                mainLock.unlock();  <br>            &#125;  <br>            <span class="hljs-comment">// 添加成功就【启动线程执行任务】  </span><br>            <span class="hljs-keyword">if</span> (workerAdded) &#123;  <br>                <span class="hljs-comment">// Thread 类中持有 Runnable 任务对象，调用的是 Runnable 的 run ，也就是 FutureTask  </span><br>                t.start();  <br>                <span class="hljs-comment">// 运行标记置为 true  </span><br>                workerStarted = <span class="hljs-literal">true</span>;  <br>            &#125;  <br>        &#125;  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        <span class="hljs-comment">// 如果启动线程失败，做清理工作  </span><br>        <span class="hljs-keyword">if</span> (! workerStarted)  <br>            addWorkerFailed(w);  <br>    &#125;  <br>    <span class="hljs-comment">// 返回新创建的线程是否启动  </span><br>    <span class="hljs-keyword">return</span> workerStarted;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>addWorkerFailed()：清理任务</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addWorkerFailed</span><span class="hljs-params">(Worker w)</span> &#123;  <br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;  <br>    <span class="hljs-comment">// 持有线程池全局锁，因为操作的是线程池相关的东西  </span><br>    mainLock.lock();  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-comment">//条件成立需要将 worker 在 workers 中清理出去。  </span><br>        <span class="hljs-keyword">if</span> (w != <span class="hljs-literal">null</span>)  <br>            workers.remove(w);  <br>        <span class="hljs-comment">// 将线程池计数 -1，相当于归还令牌。  </span><br>        decrementWorkerCount();  <br>        <span class="hljs-comment">// 尝试停止线程池  </span><br>        tryTerminate();  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        <span class="hljs-comment">//释放线程池全局锁。  </span><br>        mainLock.unlock();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h5 id="运行方法"><a href="#运行方法" class="headerlink" title="运行方法"></a>运行方法</h5><ul><li><p>Worker#run：Worker 实现了 Runnable 接口，当线程启动时，会调用 Worker 的 run() 方法</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">// ThreadPoolExecutor#runWorker()  </span><br>    runWorker(<span class="hljs-built_in">this</span>);  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>runWorker()：线程启动就要<strong>执行任务</strong>，会一直 while 循环获取任务并执行</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">runWorker</span><span class="hljs-params">(Worker w)</span> &#123;  <br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">wt</span> <span class="hljs-operator">=</span> Thread.currentThread();  <br>    <span class="hljs-comment">// 获取 worker 的 firstTask  </span><br>    <span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> w.firstTask;  <br>    <span class="hljs-comment">// 引用置空，【防止复用该线程时重复执行该任务】  </span><br>    w.firstTask = <span class="hljs-literal">null</span>;  <br>    <span class="hljs-comment">// 初始化 worker 时设置 state = -1，表示不允许抢占锁  </span><br>    <span class="hljs-comment">// 这里需要设置 state = 0 和 exclusiveOwnerThread = null，开始独占模式抢锁  </span><br>    w.unlock();  <br>    <span class="hljs-comment">// true 表示发生异常退出，false 表示正常退出。  </span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">completedAbruptly</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-comment">// firstTask 不是 null 就直接运行，否则去 queue 中获取任务  </span><br>        <span class="hljs-comment">// 【getTask 如果是阻塞获取任务，会一直阻塞在take方法，直到获取任务，不会走返回null的逻辑】  </span><br>        <span class="hljs-keyword">while</span> (task != <span class="hljs-literal">null</span> || (task = getTask()) != <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-comment">// worker 加锁，shutdown 时会判断当前 worker 状态，【根据独占锁状态判断是否空闲】  </span><br>            w.lock();  <br>              <br><span class="hljs-comment">// 说明线程池状态大于 STOP，目前处于 STOP/TIDYING/TERMINATION，此时给线程一个中断信号  </span><br>            <span class="hljs-keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||  <br>                 <span class="hljs-comment">// 说明线程处于 RUNNING 或者 SHUTDOWN 状态，清除打断标记  </span><br>                 (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted())  <br>                <span class="hljs-comment">// 中断线程，设置线程的中断标志位为 true  </span><br>                wt.interrupt();  <br>            <span class="hljs-keyword">try</span> &#123;  <br>                <span class="hljs-comment">// 钩子方法，【任务执行的前置处理】  </span><br>                beforeExecute(wt, task);  <br>                <span class="hljs-type">Throwable</span> <span class="hljs-variable">thrown</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;  <br>                <span class="hljs-keyword">try</span> &#123;  <br>                    <span class="hljs-comment">// 【执行任务】  </span><br>                    task.run();  <br>                &#125; <span class="hljs-keyword">catch</span> (Exception x) &#123;  <br>                 <span class="hljs-comment">//.....  </span><br>                &#125; <span class="hljs-keyword">finally</span> &#123;  <br>                    <span class="hljs-comment">// 钩子方法，【任务执行的后置处理】  </span><br>                    afterExecute(task, thrown);  <br>                &#125;  <br>            &#125; <span class="hljs-keyword">finally</span> &#123;  <br>                task = <span class="hljs-literal">null</span>;<span class="hljs-comment">// 将局部变量task置为null，代表任务执行完成  </span><br>                w.completedTasks++;<span class="hljs-comment">// 更新worker完成任务数量  </span><br>                w.unlock();<span class="hljs-comment">// 解锁  </span><br>            &#125;  <br>        &#125;  <br>        <span class="hljs-comment">// getTask()方法返回null时会走到这里，表示queue为空并且线程空闲超过保活时间，【当前线程执行退出逻辑】  </span><br>        completedAbruptly = <span class="hljs-literal">false</span>;  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        <span class="hljs-comment">// 正常退出 completedAbruptly = false  </span><br>       <span class="hljs-comment">// 异常退出 completedAbruptly = true，【从 task.run() 内部抛出异常】时，跳到这一行  </span><br>        processWorkerExit(w, completedAbruptly);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>unlock()：重置锁</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123; release(<span class="hljs-number">1</span>); &#125;  <br><span class="hljs-comment">// 外部不会直接调用这个方法 这个方法是 AQS 内调用的，外部调用 unlock 时触发此方法  </span><br><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> unused)</span> &#123;  <br>    setExclusiveOwnerThread(<span class="hljs-literal">null</span>);<span class="hljs-comment">// 设置持有者为 null  </span><br>    setState(<span class="hljs-number">0</span>);<span class="hljs-comment">// 设置 state = 0  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>getTask()：获取任务，线程空闲时间超过 keepAliveTime 就会被回收，判断的依据是<strong>当前线程阻塞获取任务超过保活时间</strong>，方法返回 null 就代表当前线程要被回收了，返回到 runWorker 执行线程退出逻辑。线程池具有担保机制，对于 RUNNING 状态下的超时回收，要保证线程池中最少有一个线程运行，或者任务阻塞队列已经是空</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> Runnable <span class="hljs-title function_">getTask</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">// 超时标记，表示当前线程获取任务是否超时，true 表示已超时  </span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">timedOut</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;   <br>    <span class="hljs-keyword">for</span> (;;) &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();  <br>        <span class="hljs-comment">// 获取线程池当前运行状态  </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(c);  <br>  <br>        <span class="hljs-comment">// 【tryTerminate】打断线程后执行到这，此时线程池状态为STOP或者线程池状态为SHUTDOWN并且队列已经是空  </span><br>        <span class="hljs-comment">// 所以下面的 if 条件一定是成立的，可以直接返回 null，线程就应该退出了  </span><br>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;  <br>            <span class="hljs-comment">// 使用 CAS 自旋的方式让 ctl 值 -1  </span><br>            decrementWorkerCount();  <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>        &#125;  <br>          <br><span class="hljs-comment">// 获取线程池中的线程数量  </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">wc</span> <span class="hljs-operator">=</span> workerCountOf(c);  <br>  <br>        <span class="hljs-comment">// 线程没有明确的区分谁是核心或者非核心线程，是根据当前池中的线程数量判断  </span><br>          <br>        <span class="hljs-comment">// timed = false 表示当前这个线程 获取task时不支持超时机制的，当前线程会使用 queue.take() 阻塞获取  </span><br>        <span class="hljs-comment">// timed = true 表示当前这个线程 获取task时支持超时机制，使用 queue.poll(xxx,xxx) 超时获取  </span><br>        <span class="hljs-comment">// 条件一代表允许回收核心线程，那就无所谓了，全部线程都执行超时回收  </span><br>        <span class="hljs-comment">// 条件二成立说明线程数量大于核心线程数，当前线程认为是非核心线程，有保活时间，去超时获取任务  </span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">timed</span> <span class="hljs-operator">=</span> allowCoreThreadTimeOut || wc &gt; corePoolSize;  <br>          <br><span class="hljs-comment">// 如果线程数量是否超过最大线程数，直接回收  </span><br>        <span class="hljs-comment">// 如果当前线程【允许超时回收并且已经超时了】，就应该被回收了，由于【担保机制】还要做判断：  </span><br>        <span class="hljs-comment">//   wc &gt; 1 说明线程池还用其他线程，当前线程可以直接回收  </span><br>        <span class="hljs-comment">//    workQueue.isEmpty() 前置条件是 wc = 1，【如果当前任务队列也是空了，最后一个线程就可以退出】  </span><br>        <span class="hljs-keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) &amp;&amp; (wc &gt; <span class="hljs-number">1</span> || workQueue.isEmpty())) &#123;  <br>            <span class="hljs-comment">// 使用 CAS 机制将 ctl 值 -1 ,减 1 成功的线程，返回 null，代表可以退出  </span><br>            <span class="hljs-keyword">if</span> (compareAndDecrementWorkerCount(c))  <br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>            <span class="hljs-keyword">continue</span>;  <br>        &#125;  <br>  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            <span class="hljs-comment">// 根据当前线程是否需要超时回收，【选择从队列获取任务的方法】是超时获取或者阻塞获取  </span><br>            <span class="hljs-type">Runnable</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> timed ?  <br>                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take();  <br>            <span class="hljs-comment">// 获取到任务返回任务，【阻塞获取会阻塞到获取任务为止】，不会返回 null  </span><br>            <span class="hljs-keyword">if</span> (r != <span class="hljs-literal">null</span>)  <br>                <span class="hljs-keyword">return</span> r;  <br>            <span class="hljs-comment">// 获取任务为 null 说明超时了，将超时标记设置为 true，下次自旋时返 null  </span><br>            timedOut = <span class="hljs-literal">true</span>;  <br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException retry) &#123;  <br>            <span class="hljs-comment">// 阻塞线程被打断后超时标记置为 false，【说明被打断不算超时】，要继续获取，直到超时或者获取到任务  </span><br>            <span class="hljs-comment">// 如果线程池 SHUTDOWN 状态下的打断，会在循环获取任务前判断，返回 null  </span><br>            timedOut = <span class="hljs-literal">false</span>;  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>processWorkerExit()：<strong>线程退出线程池</strong>，也有担保机制，保证队列中的任务被执行</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// 正常退出 completedAbruptly = false，异常退出为 true  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processWorkerExit</span><span class="hljs-params">(Worker w, <span class="hljs-type">boolean</span> completedAbruptly)</span> &#123;  <br>    <span class="hljs-comment">// 条件成立代表当前 worker 是发生异常退出的，task 任务执行过程中向上抛出异常了  </span><br>    <span class="hljs-keyword">if</span> (completedAbruptly)   <br>        <span class="hljs-comment">// 从异常时到这里 ctl 一直没有 -1，需要在这里 -1  </span><br>        decrementWorkerCount();  <br>  <br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;  <br>    <span class="hljs-comment">// 加锁  </span><br>    mainLock.lock();  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-comment">// 将当前 worker 完成的 task 数量，汇总到线程池的 completedTaskCount  </span><br>        completedTaskCount += w.completedTasks;  <br><span class="hljs-comment">// 将 worker 从线程池中移除  </span><br>        workers.remove(w);  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        mainLock.unlock();<span class="hljs-comment">// 解锁  </span><br>    &#125;  <br><span class="hljs-comment">// 尝试停止线程池，唤醒下一个线程  </span><br>    tryTerminate();  <br>  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();  <br>    <span class="hljs-comment">// 线程池不是停止状态就应该有线程运行【担保机制】  </span><br>    <span class="hljs-keyword">if</span> (runStateLessThan(c, STOP)) &#123;  <br>        <span class="hljs-comment">// 正常退出的逻辑，是对空闲线程回收，不是执行出错  </span><br>        <span class="hljs-keyword">if</span> (!completedAbruptly) &#123;  <br>            <span class="hljs-comment">// 根据是否回收核心线程确定【线程池中的线程数量最小值】  </span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> allowCoreThreadTimeOut ? <span class="hljs-number">0</span> : corePoolSize;  <br>            <span class="hljs-comment">// 最小值为 0，但是线程队列不为空，需要一个线程来完成任务担保机制  </span><br>            <span class="hljs-keyword">if</span> (min == <span class="hljs-number">0</span> &amp;&amp; !workQueue.isEmpty())  <br>                min = <span class="hljs-number">1</span>;  <br>            <span class="hljs-comment">// 线程池中的线程数量大于最小值可以直接返回  </span><br>            <span class="hljs-keyword">if</span> (workerCountOf(c) &gt;= min)  <br>                <span class="hljs-keyword">return</span>;  <br>        &#125;  <br>        <span class="hljs-comment">// 执行 task 时发生异常，有个线程因为异常终止了，需要添加  </span><br>        <span class="hljs-comment">// 或者线程池中的数量小于最小值，这里要创建一个新 worker 加进线程池  </span><br>        addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h5 id="停止方法"><a href="#停止方法" class="headerlink" title="停止方法"></a>停止方法</h5><ul><li><p>shutdown()：停止线程池</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;  <br>    <span class="hljs-comment">// 获取线程池全局锁  </span><br>    mainLock.lock();  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        checkShutdownAccess();  <br>        <span class="hljs-comment">// 设置线程池状态为 SHUTDOWN，如果线程池状态大于 SHUTDOWN，就不会设置直接返回  </span><br>        advanceRunState(SHUTDOWN);  <br>        <span class="hljs-comment">// 中断空闲线程  </span><br>        interruptIdleWorkers();  <br>        <span class="hljs-comment">// 空方法，子类可以扩展  </span><br>        onShutdown();   <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        <span class="hljs-comment">// 释放线程池全局锁  </span><br>        mainLock.unlock();  <br>    &#125;  <br>    tryTerminate();  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>interruptIdleWorkers()：shutdown 方法会<strong>中断所有空闲线程</strong>，根据是否可以获取 AQS 独占锁判断是否处于工作状态。线程之所以空闲是因为阻塞队列没有任务，不会中断正在运行的线程，所以 shutdown 方法会让所有的任务执行完毕</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// onlyOne == true 说明只中断一个线程 ，false 则中断所有线程  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">interruptIdleWorkers</span><span class="hljs-params">(<span class="hljs-type">boolean</span> onlyOne)</span> &#123;  <br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;  <br>    / /持有全局锁  <br>    mainLock.lock();  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-comment">// 遍历所有 worker  </span><br>        <span class="hljs-keyword">for</span> (Worker w : workers) &#123;  <br>            <span class="hljs-comment">// 获取当前 worker 的线程  </span><br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> w.thread;  <br>            <span class="hljs-comment">// 条件一成立：说明当前迭代的这个线程尚未中断  </span><br>            <span class="hljs-comment">// 条件二成立：说明【当前worker处于空闲状态】，阻塞在poll或者take，因为worker执行task时是要加锁的  </span><br>            <span class="hljs-comment">//           每个worker有一个独占锁，w.tryLock()尝试加锁，加锁成功返回 true  </span><br>            <span class="hljs-keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;  <br>                <span class="hljs-keyword">try</span> &#123;  <br>                    <span class="hljs-comment">// 中断线程，处于 queue 阻塞的线程会被唤醒，进入下一次自旋，返回 null，执行退出相逻辑  </span><br>                    t.interrupt();  <br>                &#125; <span class="hljs-keyword">catch</span> (SecurityException ignore) &#123;  <br>                &#125; <span class="hljs-keyword">finally</span> &#123;  <br>                    <span class="hljs-comment">// 释放worker的独占锁  </span><br>                    w.unlock();  <br>                &#125;  <br>            &#125;  <br>            <span class="hljs-comment">// false，代表中断所有的线程  </span><br>            <span class="hljs-keyword">if</span> (onlyOne)  <br>                <span class="hljs-keyword">break</span>;  <br>        &#125;  <br>  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        <span class="hljs-comment">// 释放全局锁  </span><br>        mainLock.unlock();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>shutdownNow()：直接关闭线程池，不会等待任务执行完成</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> List&lt;Runnable&gt; <span class="hljs-title function_">shutdownNow</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">// 返回值引用  </span><br>    List&lt;Runnable&gt; tasks;  <br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;  <br>    <span class="hljs-comment">// 获取线程池全局锁  </span><br>    mainLock.lock();  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        checkShutdownAccess();  <br>        <span class="hljs-comment">// 设置线程池状态为STOP  </span><br>        advanceRunState(STOP);  <br>        <span class="hljs-comment">// 中断线程池中【所有线程】  </span><br>        interruptWorkers();  <br>        <span class="hljs-comment">// 从阻塞队列中导出未处理的task  </span><br>        tasks = drainQueue();  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        mainLock.unlock();  <br>    &#125;  <br>  <br>    tryTerminate();  <br>    <span class="hljs-comment">// 返回当前任务队列中 未处理的任务。  </span><br>    <span class="hljs-keyword">return</span> tasks;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>tryTerminate()：设置为 TERMINATED 状态 if either (SHUTDOWN and pool and queue empty) or (STOP and pool empty)</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tryTerminate</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">for</span> (;;) &#123;  <br>        <span class="hljs-comment">// 获取 ctl 的值  </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();  <br>        <span class="hljs-comment">// 线程池正常，或者有其他线程执行了状态转换的方法，当前线程直接返回  </span><br>        <span class="hljs-keyword">if</span> (isRunning(c) || runStateAtLeast(c, TIDYING) ||  <br>            <span class="hljs-comment">// 线程池是 SHUTDOWN 并且任务队列不是空，需要去处理队列中的任务  </span><br>            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))  <br>            <span class="hljs-keyword">return</span>;  <br>          <br>        <span class="hljs-comment">// 执行到这里说明线程池状态为 STOP 或者线程池状态为 SHUTDOWN 并且队列已经是空  </span><br>        <span class="hljs-comment">// 判断线程池中线程的数量  </span><br>        <span class="hljs-keyword">if</span> (workerCountOf(c) != <span class="hljs-number">0</span>) &#123;  <br>            <span class="hljs-comment">// 【中断一个空闲线程】，在 queue.take() | queue.poll() 阻塞空闲  </span><br>            <span class="hljs-comment">// 唤醒后的线程会在getTask()方法返回null，  </span><br>            <span class="hljs-comment">// 执行 processWorkerExit 退出逻辑时会再次调用 tryTerminate() 唤醒下一个空闲线程  </span><br>            interruptIdleWorkers(ONLY_ONE);  <br>            <span class="hljs-keyword">return</span>;  <br>        &#125;  <br><span class="hljs-comment">// 池中的线程数量为 0 来到这里  </span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;  <br>        <span class="hljs-comment">// 加全局锁  </span><br>        mainLock.lock();  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            <span class="hljs-comment">// 设置线程池状态为 TIDYING 状态，线程数量为 0  </span><br>            <span class="hljs-keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="hljs-number">0</span>))) &#123;  <br>                <span class="hljs-keyword">try</span> &#123;  <br>                    <span class="hljs-comment">// 结束线程池  </span><br>                    terminated();  <br>                &#125; <span class="hljs-keyword">finally</span> &#123;  <br>                    <span class="hljs-comment">// 设置线程池状态为TERMINATED状态。  </span><br>                    ctl.set(ctlOf(TERMINATED, <span class="hljs-number">0</span>));  <br>                    <span class="hljs-comment">// 【唤醒所有调用 awaitTermination() 方法的线程】  </span><br>                    termination.signalAll();  <br>                &#125;  <br>                <span class="hljs-keyword">return</span>;  <br>            &#125;  <br>        &#125; <span class="hljs-keyword">finally</span> &#123;  <br><span class="hljs-comment">// 释放线程池全局锁  </span><br>            mainLock.unlock();  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h4 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h4><h5 id="线程使用"><a href="#线程使用" class="headerlink" title="线程使用"></a>线程使用</h5><p>FutureTask 未来任务对象，继承 Runnable、Future 接口，用于包装 Callable 对象，实现任务的提交</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;  <br>    FutureTask&lt;String&gt; task = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Callable</span>&lt;String&gt;() &#123;  <br>        <span class="hljs-meta">@Override</span>  <br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;  <br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello World&quot;</span>;  <br>        &#125;  <br>    &#125;);  <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task).start();<span class="hljs-comment">//启动线程  </span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> task.get();<span class="hljs-comment">//获取返回任务数据  </span><br>    System.out.println(msg);  <br>&#125;<br></code></pre></td></tr></table></figure><p>构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">FutureTask</span><span class="hljs-params">(Callable&lt;V&gt; callable)</span>&#123;  <br><span class="hljs-built_in">this</span>.callable = callable;<span class="hljs-comment">// 属性注入  </span><br>    <span class="hljs-built_in">this</span>.state = NEW; <span class="hljs-comment">// 任务状态设置为 new  </span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">FutureTask</span><span class="hljs-params">(Runnable runnable, V result)</span> &#123;  <br>    <span class="hljs-comment">// 适配器模式  </span><br>    <span class="hljs-built_in">this</span>.callable = Executors.callable(runnable, result);  <br>    <span class="hljs-built_in">this</span>.state = NEW;         <br>&#125;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Callable&lt;T&gt; <span class="hljs-title function_">callable</span><span class="hljs-params">(Runnable task, T result)</span> &#123;  <br>    <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();  <br>    <span class="hljs-comment">// 使用装饰者模式将 runnable 转换成 callable 接口，外部线程通过 get 获取  </span><br>    <span class="hljs-comment">// 当前任务执行结果时，结果可能为 null 也可能为传进来的值，【传进来什么返回什么】  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RunnableAdapter</span>&lt;T&gt;(task, result);  <br>&#125;  <br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RunnableAdapter</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;T&gt; &#123;  <br>    <span class="hljs-keyword">final</span> Runnable task;  <br>    <span class="hljs-keyword">final</span> T result;  <br>    <span class="hljs-comment">// 构造方法  </span><br>    RunnableAdapter(Runnable task, T result) &#123;  <br>        <span class="hljs-built_in">this</span>.task = task;  <br>        <span class="hljs-built_in">this</span>.result = result;  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">call</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-comment">// 实则调用 Runnable#run 方法  </span><br>        task.run();  <br>        <span class="hljs-comment">// 返回值为构造 FutureTask 对象时传入的返回值或者是 null  </span><br>        <span class="hljs-keyword">return</span> result;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="成员属性-3"><a href="#成员属性-3" class="headerlink" title="成员属性"></a>成员属性</h5><p>FutureTask 类的成员属性：</p><ul><li><p>任务状态：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// 表示当前task状态  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> state;  <br><span class="hljs-comment">// 当前任务尚未执行  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NEW</span>          <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br><span class="hljs-comment">// 当前任务正在结束，尚未完全结束，一种临界状态  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">COMPLETING</span>   <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;  <br><span class="hljs-comment">// 当前任务正常结束  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NORMAL</span>       <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;  <br><span class="hljs-comment">// 当前任务执行过程中发生了异常，内部封装的 callable.run() 向上抛出异常了  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">EXCEPTIONAL</span>  <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;  <br><span class="hljs-comment">// 当前任务被取消  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CANCELLED</span>    <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;  <br><span class="hljs-comment">// 当前任务中断中  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INTERRUPTING</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;  <br><span class="hljs-comment">// 当前任务已中断  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INTERRUPTED</span>  <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;<br></code></pre></td></tr></table></figure></li><li><p>任务对象：</p><p>  <code>private Callable&lt;V&gt; callable;// Runnable 使用装饰者模式伪装成 Callable</code></p></li><li><p><strong>存储任务执行的结果</strong>，这是 run 方法返回值是 void 也可以获取到执行结果的原因：</p><p>  &#x2F;&#x2F; 正常情况下：任务正常执行结束，outcome 保存执行结果，callable 返回值<br>  &#x2F;&#x2F; 非正常情况：callable 向上抛出异常，outcome 保存异常<br>  <code>private Object outcome; </code></p></li><li><p>执行当前任务的线程对象：</p><p>  <code>private volatile Thread runner;// 当前任务被线程执行期间，保存当前执行任务的线程对象引用</code></p></li><li><p><strong>线程阻塞队列的头节点</strong>：</p><p>  &#x2F;&#x2F; 会有很多线程去 get 当前任务的结果，这里使用了一种数据结构头插头取（类似栈）的一个队列来保存所有的 get 线程<br>  <code>private volatile WaitNode waiters;</code></p></li><li><p>内部类：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WaitNode</span> &#123;  <br>    <span class="hljs-comment">// 单向链表  </span><br>    <span class="hljs-keyword">volatile</span> Thread thread;  <br>    <span class="hljs-keyword">volatile</span> WaitNode next;  <br>    WaitNode() &#123; thread = Thread.currentThread(); &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h5 id="成员方法-3"><a href="#成员方法-3" class="headerlink" title="成员方法"></a>成员方法</h5><p>FutureTask 类的成员方法：</p><ul><li><p><strong>FutureTask#run</strong>：任务执行入口</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">//条件一：成立说明当前 task 已经被执行过了或者被 cancel 了，非 NEW 状态的任务，线程就不需要处理了  </span><br>    <span class="hljs-comment">//条件二：线程是 NEW 状态，尝试设置当前任务对象的线程是当前线程，设置失败说明其他线程抢占了该任务，直接返回  </span><br>    <span class="hljs-keyword">if</span> (state != NEW ||  <br>        !UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, runnerOffset, <span class="hljs-literal">null</span>, Thread.currentThread()))  <br>        <span class="hljs-keyword">return</span>;  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-comment">// 执行到这里，当前 task 一定是 NEW 状态，而且【当前线程也抢占 task 成功】  </span><br>        Callable&lt;V&gt; c = callable;  <br>        <span class="hljs-comment">// 判断任务是否为空，防止空指针异常；判断 state 状态，防止外部线程在此期间 cancel 掉当前任务  </span><br>        <span class="hljs-comment">// 【因为 task 的执行者已经设置为当前线程，所以这里是线程安全的】  </span><br>        <span class="hljs-keyword">if</span> (c != <span class="hljs-literal">null</span> &amp;&amp; state == NEW) &#123;  <br>            V result;  <br>            <span class="hljs-comment">// true 表示 callable.run 代码块执行成功 未抛出异常  </span><br>            <span class="hljs-comment">// false 表示 callable.run 代码块执行失败 抛出异常  </span><br>            <span class="hljs-type">boolean</span> ran;  <br>            <span class="hljs-keyword">try</span> &#123;  <br><span class="hljs-comment">// 【调用自定义的方法，执行结果赋值给 result】  </span><br>                result = c.call();  <br>                <span class="hljs-comment">// 没有出现异常  </span><br>                ran = <span class="hljs-literal">true</span>;  <br>            &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;  <br>                <span class="hljs-comment">// 出现异常，返回值置空，ran 置为 false  </span><br>                result = <span class="hljs-literal">null</span>;  <br>                ran = <span class="hljs-literal">false</span>;  <br>                <span class="hljs-comment">// 设置返回的异常  </span><br>                setException(ex);  <br>            &#125;  <br>            <span class="hljs-comment">// 代码块执行正常  </span><br>            <span class="hljs-keyword">if</span> (ran)  <br>                <span class="hljs-comment">// 设置返回的结果  </span><br>                set(result);  <br>        &#125;  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        <span class="hljs-comment">// 任务执行完成，取消线程的引用，help GC  </span><br>        runner = <span class="hljs-literal">null</span>;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;  <br>        <span class="hljs-comment">// 判断任务是不是被中断  </span><br>        <span class="hljs-keyword">if</span> (s &gt;= INTERRUPTING)  <br>            <span class="hljs-comment">// 执行中断处理方法  </span><br>            handlePossibleCancellationInterrupt(s);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>  FutureTask#set：设置正常返回值，首先将任务状态设置为 COMPLETING 状态代表完成中，逻辑执行完设置为 NORMAL 状态代表任务正常执行完成，最后唤醒 get() 阻塞线程</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(V v)</span> &#123;  <br>    <span class="hljs-comment">// CAS 方式设置当前任务状态为完成中，设置失败说明其他线程取消了该任务  </span><br>    <span class="hljs-keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="hljs-built_in">this</span>, stateOffset, NEW, COMPLETING)) &#123;  <br>        <span class="hljs-comment">// 【将结果赋值给 outcome】  </span><br>        outcome = v;  <br>        <span class="hljs-comment">// 将当前任务状态修改为 NORMAL 正常结束状态。  </span><br>        UNSAFE.putOrderedInt(<span class="hljs-built_in">this</span>, stateOffset, NORMAL);  <br>        finishCompletion();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>  FutureTask#setException：设置异常返回值</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setException</span><span class="hljs-params">(Throwable t)</span> &#123;  <br>    <span class="hljs-keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="hljs-built_in">this</span>, stateOffset, NEW, COMPLETING)) &#123;  <br>        <span class="hljs-comment">// 赋值给返回结果，用来向上层抛出来的异常  </span><br>        outcome = t;  <br>        <span class="hljs-comment">// 将当前任务的状态 修改为 EXCEPTIONAL  </span><br>        UNSAFE.putOrderedInt(<span class="hljs-built_in">this</span>, stateOffset, EXCEPTIONAL);  <br>        finishCompletion();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>  FutureTask#finishCompletion：<strong>唤醒 get() 阻塞线程</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finishCompletion</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">// 遍历所有的等待的节点，q 指向头节点  </span><br>    <span class="hljs-keyword">for</span> (WaitNode q; (q = waiters) != <span class="hljs-literal">null</span>;) &#123;  <br>        <span class="hljs-comment">// 使用cas设置 waiters 为 null，防止外部线程使用cancel取消当前任务，触发finishCompletion方法重复执行  </span><br>        <span class="hljs-keyword">if</span> (UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, waitersOffset, q, <span class="hljs-literal">null</span>)) &#123;  <br>            <span class="hljs-comment">// 自旋  </span><br>            <span class="hljs-keyword">for</span> (;;) &#123;  <br>                <span class="hljs-comment">// 获取当前 WaitNode 节点封装的 thread  </span><br>                <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> q.thread;  <br>                <span class="hljs-comment">// 当前线程不为 null，唤醒当前 get() 等待获取数据的线程  </span><br>                <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>) &#123;  <br>                    q.thread = <span class="hljs-literal">null</span>;  <br>                    LockSupport.unpark(t);  <br>                &#125;  <br>                <span class="hljs-comment">// 获取当前节点的下一个节点  </span><br>                <span class="hljs-type">WaitNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> q.next;  <br>                <span class="hljs-comment">// 当前节点是最后一个节点了  </span><br>                <span class="hljs-keyword">if</span> (next == <span class="hljs-literal">null</span>)  <br>                    <span class="hljs-keyword">break</span>;  <br>                <span class="hljs-comment">// 断开链表  </span><br>                q.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help gc  </span><br>                q = next;  <br>            &#125;  <br>            <span class="hljs-keyword">break</span>;  <br>        &#125;  <br>    &#125;  <br>    done();  <br>    callable = <span class="hljs-literal">null</span>;<span class="hljs-comment">// help GC  </span><br>&#125;<br></code></pre></td></tr></table></figure><p>  FutureTask#handlePossibleCancellationInterrupt：任务中断处理</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handlePossibleCancellationInterrupt</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> &#123;  <br>    <span class="hljs-keyword">if</span> (s == INTERRUPTING)  <br>        <span class="hljs-comment">// 中断状态中  </span><br>        <span class="hljs-keyword">while</span> (state == INTERRUPTING)  <br>            <span class="hljs-comment">// 等待中断完成  </span><br>            Thread.yield();  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>FutureTask#get</strong>：获取任务执行的返回值，执行 run 和 get 的不是同一个线程，一般有多个线程 get，只有一个线程 run</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException &#123;  <br>    <span class="hljs-comment">// 获取当前任务状态  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;  <br>    <span class="hljs-comment">// 条件成立说明任务还没执行完成  </span><br>    <span class="hljs-keyword">if</span> (s &lt;= COMPLETING)  <br>        <span class="hljs-comment">// 返回 task 当前状态，可能当前线程在里面已经睡了一会  </span><br>        s = awaitDone(<span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);  <br>    <span class="hljs-keyword">return</span> report(s);  <br>&#125;<br></code></pre></td></tr></table></figure><p>  FutureTask#awaitDone：<strong>get 线程封装成 WaitNode 对象进入阻塞队列阻塞等待</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">awaitDone</span><span class="hljs-params">(<span class="hljs-type">boolean</span> timed, <span class="hljs-type">long</span> nanos)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>    <span class="hljs-comment">// 0 不带超时  </span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> timed ? System.nanoTime() + nanos : <span class="hljs-number">0L</span>;  <br>    <span class="hljs-comment">// 引用当前线程，封装成 WaitNode 对象  </span><br>    <span class="hljs-type">WaitNode</span> <span class="hljs-variable">q</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;  <br>    <span class="hljs-comment">// 表示当前线程 waitNode 对象，是否进入阻塞队列  </span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">queued</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;  <br>    <span class="hljs-comment">// 【三次自旋开始休眠】  </span><br>    <span class="hljs-keyword">for</span> (;;) &#123;  <br>        <span class="hljs-comment">// 判断当前 get() 线程是否被打断，打断返回 true，清除打断标记  </span><br>        <span class="hljs-keyword">if</span> (Thread.interrupted()) &#123;  <br>            <span class="hljs-comment">// 当前线程对应的等待 node 出队，  </span><br>            removeWaiter(q);  <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();  <br>        &#125;  <br><span class="hljs-comment">// 获取任务状态  </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;  <br>        <span class="hljs-comment">// 条件成立说明当前任务执行完成已经有结果了  </span><br>        <span class="hljs-keyword">if</span> (s &gt; COMPLETING) &#123;  <br>            <span class="hljs-comment">// 条件成立说明已经为当前线程创建了 WaitNode，置空 help GC  </span><br>            <span class="hljs-keyword">if</span> (q != <span class="hljs-literal">null</span>)  <br>                q.thread = <span class="hljs-literal">null</span>;  <br>            <span class="hljs-comment">// 返回当前的状态  </span><br>            <span class="hljs-keyword">return</span> s;  <br>        &#125;  <br>        <span class="hljs-comment">// 条件成立说明当前任务接近完成状态，这里让当前线程释放一下 cpu ，等待进行下一次抢占 cpu  </span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s == COMPLETING)   <br>            Thread.yield();  <br>        <span class="hljs-comment">// 【第一次自旋】，当前线程还未创建 WaitNode 对象，此时为当前线程创建 WaitNode对象  </span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (q == <span class="hljs-literal">null</span>)  <br>            q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WaitNode</span>();  <br>        <span class="hljs-comment">// 【第二次自旋】，当前线程已经创建 WaitNode 对象了，但是node对象还未入队  </span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!queued)  <br>            <span class="hljs-comment">// waiters 指向队首，让当前 WaitNode 成为新的队首，【头插法】，失败说明其他线程修改了新的队首  </span><br>            queued = UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, waitersOffset, q.next = waiters, q);  <br>        <span class="hljs-comment">// 【第三次自旋】，会到这里，或者 else 内  </span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (timed) &#123;  <br>            nanos = deadline - System.nanoTime();  <br>            <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0L</span>) &#123;  <br>                removeWaiter(q);  <br>                <span class="hljs-keyword">return</span> state;  <br>            &#125;  <br>            <span class="hljs-comment">// 阻塞指定的时间  </span><br>            LockSupport.parkNanos(<span class="hljs-built_in">this</span>, nanos);  <br>        &#125;  <br>        <span class="hljs-comment">// 条件成立：说明需要阻塞  </span><br>        <span class="hljs-keyword">else</span>  <br>            <span class="hljs-comment">// 【当前 get 操作的线程被 park 阻塞】，除非有其它线程将唤醒或者将当前线程中断  </span><br>            LockSupport.park(<span class="hljs-built_in">this</span>);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>  FutureTask#report：封装运行结果，可以获取 run() 方法中设置的成员变量 outcome，<strong>这是 run 方法的返回值是 void 也可以获取到任务执行的结果的原因</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> V <span class="hljs-title function_">report</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> <span class="hljs-keyword">throws</span> ExecutionException &#123;  <br>    <span class="hljs-comment">// 获取执行结果，是在一个 futuretask 对象中的属性，可以直接获取  </span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> outcome;  <br>    <span class="hljs-comment">// 当前任务状态正常结束  </span><br>    <span class="hljs-keyword">if</span> (s == NORMAL)  <br>        <span class="hljs-keyword">return</span> (V)x;<span class="hljs-comment">// 直接返回 callable 的逻辑结果  </span><br>    <span class="hljs-comment">// 当前任务被取消或者中断  </span><br>    <span class="hljs-keyword">if</span> (s &gt;= CANCELLED)  <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CancellationException</span>();<span class="hljs-comment">// 抛出异常  </span><br>    <span class="hljs-comment">// 执行到这里说明自定义的 callable 中的方法有异常，使用 outcome 上层抛出异常  </span><br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExecutionException</span>((Throwable)x);  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>FutureTask#cancel：任务取消，打断正在执行该任务的线程</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">cancel</span><span class="hljs-params">(<span class="hljs-type">boolean</span> mayInterruptIfRunning)</span> &#123;  <br>    <span class="hljs-comment">// 条件一：表示当前任务处于运行中或者处于线程池任务队列中  </span><br>    <span class="hljs-comment">// 条件二：表示修改状态，成功可以去执行下面逻辑，否则返回 false 表示 cancel 失败  </span><br>    <span class="hljs-keyword">if</span> (!(state == NEW &amp;&amp;  <br>          UNSAFE.compareAndSwapInt(<span class="hljs-built_in">this</span>, stateOffset, NEW,  <br>                                   mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-comment">// 如果任务已经被执行，是否允许打断  </span><br>        <span class="hljs-keyword">if</span> (mayInterruptIfRunning) &#123;  <br>            <span class="hljs-keyword">try</span> &#123;  <br>                <span class="hljs-comment">// 获取执行当前 FutureTask 的线程  </span><br>                <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> runner;  <br>                <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>)  <br>                    <span class="hljs-comment">// 打断执行的线程  </span><br>                    t.interrupt();  <br>            &#125; <span class="hljs-keyword">finally</span> &#123;  <br>                <span class="hljs-comment">// 设置任务状态为【中断完成】  </span><br>                UNSAFE.putOrderedInt(<span class="hljs-built_in">this</span>, stateOffset, INTERRUPTED);  <br>            &#125;  <br>        &#125;  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        <span class="hljs-comment">// 唤醒所有 get() 阻塞的线程  </span><br>        finishCompletion();  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h3><h4 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h4><p>Timer 实现定时功能，Timer 的优点在于简单易用，但由于所有任务都是由同一个线程来调度，因此所有任务都是串行执行的，同一时间只能有一个任务在执行，前一个任务的延迟或异常都将会影响到之后的任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-type">Timer</span> <span class="hljs-variable">timer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Timer</span>();  <br>    <span class="hljs-type">TimerTask</span> <span class="hljs-variable">task1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerTask</span>() &#123;  <br>        <span class="hljs-meta">@Override</span>  <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>            System.out.println(<span class="hljs-string">&quot;task 1&quot;</span>);  <br>            <span class="hljs-comment">//int i = 1 / 0;//任务一的出错会导致任务二无法执行  </span><br>            Thread.sleep(<span class="hljs-number">2000</span>);  <br>        &#125;  <br>    &#125;;  <br>    <span class="hljs-type">TimerTask</span> <span class="hljs-variable">task2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerTask</span>() &#123;  <br>        <span class="hljs-meta">@Override</span>  <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>            System.out.println(<span class="hljs-string">&quot;task 2&quot;</span>);  <br>        &#125;  <br>    &#125;;  <br>    <span class="hljs-comment">// 使用 timer 添加两个任务，希望它们都在 1s 后执行  </span><br><span class="hljs-comment">// 但由于 timer 内只有一个线程来顺序执行队列中的任务，因此任务1的延时，影响了任务2的执行  </span><br>    timer.schedule(task1, <span class="hljs-number">1000</span>);<span class="hljs-comment">//17:45:56 c.ThreadPool [Timer-0] - task 1  </span><br>    timer.schedule(task2, <span class="hljs-number">1000</span>);<span class="hljs-comment">//17:45:58 c.ThreadPool [Timer-0] - task 2  </span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="Scheduled"><a href="#Scheduled" class="headerlink" title="Scheduled"></a>Scheduled</h4><p>任务调度线程池 ScheduledThreadPoolExecutor 继承 ThreadPoolExecutor：</p><ul><li><p>使用内部类 ScheduledFutureTask 封装任务</p></li><li><p>使用内部类 DelayedWorkQueue 作为线程池队列</p></li><li><p>重写 onShutdown 方法去处理 shutdown 后的任务</p></li><li><p>提供 decorateTask 方法作为 ScheduledFutureTask 的修饰方法，以便开发者进行扩展</p></li></ul><p>构造方法：<code>Executors.newScheduledThreadPool(int corePoolSize)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize)</span> &#123;  <br>    <span class="hljs-comment">// 最大线程数固定为 Integer.MAX_VALUE，保活时间 keepAliveTime 固定为 0  </span><br>    <span class="hljs-built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="hljs-number">0</span>, NANOSECONDS,  <br>          <span class="hljs-comment">// 阻塞队列是 DelayedWorkQueue  </span><br>          <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayedWorkQueue</span>());  <br>&#125;<br><br></code></pre></td></tr></table></figure><p>常用 API：</p><ul><li><p><code>ScheduledFuture&lt;?&gt; schedule(Runnable/Callable&lt;V&gt;, long delay, TimeUnit u)</code>：延迟执行任务</p></li><li><p><code>ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable/Callable&lt;V&gt;, long initialDelay, long period, TimeUnit unit)</code>：定时执行周期任务，不考虑执行的耗时，参数为初始延迟时间、间隔时间、单位</p></li><li><p><code>ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable/Callable&lt;V&gt;, long initialDelay, long delay, TimeUnit unit)</code>：定时执行周期任务，考虑执行的耗时，参数为初始延迟时间、间隔时间、单位</p></li></ul><p>基本使用：</p><ul><li><p>延迟任务，但是出现异常并不会在控制台打印，也不会影响其他线程的执行</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;  <br>    <span class="hljs-comment">// 线程池大小为1时也是串行执行  </span><br>    <span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newScheduledThreadPool(<span class="hljs-number">2</span>);  <br>    <span class="hljs-comment">// 添加两个任务，都在 1s 后同时执行  </span><br>    executor.schedule(() -&gt; &#123;  <br>    System.out.println(<span class="hljs-string">&quot;任务1，执行时间：&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());  <br>        <span class="hljs-comment">//int i = 1 / 0;  </span><br>    <span class="hljs-keyword">try</span> &#123; Thread.sleep(<span class="hljs-number">2000</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; &#125;  <br>    &#125;, <span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS);  <br>      <br>    executor.schedule(() -&gt; &#123;  <br>    System.out.println(<span class="hljs-string">&quot;任务2，执行时间：&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());  <br>    &#125;, <span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS);  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>定时任务 scheduleAtFixedRate：<strong>一次任务的启动到下一次任务的启动</strong>之间只要大于等于间隔时间，抢占到 CPU 就会立即执行</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    <span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> Executors.newScheduledThreadPool(<span class="hljs-number">1</span>);  <br>    System.out.println(<span class="hljs-string">&quot;start...&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());  <br>      <br>    pool.scheduleAtFixedRate(() -&gt; &#123;  <br>        System.out.println(<span class="hljs-string">&quot;running...&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());  <br>        Thread.sleep(<span class="hljs-number">2000</span>);  <br>    &#125;, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);  <br>&#125;  <br>  <br><span class="hljs-comment">/*start...Sat Apr 24 18:08:12 CST 2021  </span><br><span class="hljs-comment">running...Sat Apr 24 18:08:13 CST 2021  </span><br><span class="hljs-comment">running...Sat Apr 24 18:08:15 CST 2021  </span><br><span class="hljs-comment">running...Sat Apr 24 18:08:17 CST 2021*/</span><br></code></pre></td></tr></table></figure></li><li><p>定时任务 scheduleWithFixedDelay：<strong>一次任务的结束到下一次任务的启动之间</strong>等于间隔时间，抢占到 CPU 就会立即执行，这个方法才是真正的设置两个任务之间的间隔</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;  <br>    <span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> Executors.newScheduledThreadPool(<span class="hljs-number">3</span>);  <br>    System.out.println(<span class="hljs-string">&quot;start...&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());  <br>      <br>    pool.scheduleWithFixedDelay(() -&gt; &#123;  <br>        System.out.println(<span class="hljs-string">&quot;running...&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());  <br>        Thread.sleep(<span class="hljs-number">2000</span>);  <br>    &#125;, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);  <br>&#125;  <br><span class="hljs-comment">/*start...Sat Apr 24 18:11:41 CST 2021  </span><br><span class="hljs-comment">running...Sat Apr 24 18:11:42 CST 2021  </span><br><span class="hljs-comment">running...Sat Apr 24 18:11:45 CST 2021  </span><br><span class="hljs-comment">running...Sat Apr 24 18:11:48 CST 2021*/</span><br></code></pre></td></tr></table></figure></li></ul><hr><h4 id="成员属性-4"><a href="#成员属性-4" class="headerlink" title="成员属性"></a>成员属性</h4><h5 id="成员变量-1"><a href="#成员变量-1" class="headerlink" title="成员变量"></a>成员变量</h5><ul><li><p>shutdown 后是否继续执行周期任务：</p><p>  <code>private volatile boolean continueExistingPeriodicTasksAfterShutdown;</code></p></li><li><p>shutdown 后是否继续执行延迟任务：</p><p>  <code>private volatile boolean executeExistingDelayedTasksAfterShutdown = true;</code></p></li><li><p>取消方法是否将该任务从队列中移除：</p><p>  &#x2F;&#x2F; 默认 false，不移除，等到线程拿到任务之后抛弃<br>  <code>private volatile boolean removeOnCancel = false;</code></p></li><li><p>任务的序列号，可以用来比较优先级：</p><p>  <code>private static final AtomicLong sequencer = new AtomicLong();</code></p></li></ul><hr><h5 id="延迟任务"><a href="#延迟任务" class="headerlink" title="延迟任务"></a>延迟任务</h5><p>ScheduledFutureTask 继承 FutureTask，实现 RunnableScheduledFuture 接口，具有延迟执行的特点，覆盖 FutureTask 的 run 方法来实现对<strong>延时执行、周期执行</strong>的支持。对于延时任务调用 FutureTask#run，而对于周期性任务则调用 FutureTask#runAndReset 并且在成功之后根据 fixed-delay&#x2F;fixed-rate 模式来设置下次执行时间并重新将任务塞到工作队列</p><p>在调度线程池中无论是 runnable 还是 callable，无论是否需要延迟和定时，所有的任务都会被封装成 ScheduledFutureTask</p><p>成员变量：</p><ul><li><p>任务序列号：</p><p>  <code>private final long sequenceNumber;</code></p></li><li><p>执行时间：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">long</span> time;<span class="hljs-comment">// 任务可以被执行的时间，交付时间，以纳秒表示  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> period;<span class="hljs-comment">// 0 表示非周期任务，正数表示 fixed-rate 模式的周期，负数表示 fixed-delay 模式</span><br><br>fixed-rate：两次开始启动的间隔，fixed-delay：一次执行结束到下一次开始启动<br></code></pre></td></tr></table></figure></li><li><p>实际的任务对象：</p><p>  <code>RunnableScheduledFuture&lt;V&gt; outerTask = this;</code></p></li><li><p>任务在队列数组中的索引下标：</p><p>  &#x2F;&#x2F; DelayedWorkQueue 底层使用的数据结构是最小堆，记录当前任务在堆中的索引，-1 代表删除<br>  <code>int heapIndex;</code></p></li></ul><p>成员方法：</p><ul><li><p>构造方法：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">ScheduledFutureTask(Runnable r, V result, <span class="hljs-type">long</span> ns, <span class="hljs-type">long</span> period) &#123;  <br>    <span class="hljs-built_in">super</span>(r, result);  <br>    <span class="hljs-comment">// 任务的触发时间  </span><br>    <span class="hljs-built_in">this</span>.time = ns;  <br>    <span class="hljs-comment">// 任务的周期，多长时间执行一次  </span><br>    <span class="hljs-built_in">this</span>.period = period;  <br>    <span class="hljs-comment">// 任务的序号  </span><br>    <span class="hljs-built_in">this</span>.sequenceNumber = sequencer.getAndIncrement();  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>compareTo()：ScheduledFutureTask 根据执行时间 time 正序排列，如果执行时间相同，在按照序列号 sequenceNumber 正序排列，任务需要放入 DelayedWorkQueue，延迟队列中使用该方法按照从小到大进行排序</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Delayed other)</span> &#123;  <br>    <span class="hljs-keyword">if</span> (other == <span class="hljs-built_in">this</span>) <span class="hljs-comment">// compare zero if same object  </span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">if</span> (other <span class="hljs-keyword">instanceof</span> ScheduledFutureTask) &#123;  <br>        <span class="hljs-comment">// 类型强转  </span><br>        ScheduledFutureTask&lt;?&gt; x = (ScheduledFutureTask&lt;?&gt;)other;  <br>        <span class="hljs-comment">// 比较者 - 被比较者的执行时间  </span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">diff</span> <span class="hljs-operator">=</span> time - x.time;  <br>        <span class="hljs-comment">// 比较者先执行  </span><br>        <span class="hljs-keyword">if</span> (diff &lt; <span class="hljs-number">0</span>)  <br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;  <br>        <span class="hljs-comment">// 被比较者先执行  </span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (diff &gt; <span class="hljs-number">0</span>)  <br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <br>        <span class="hljs-comment">// 比较者的序列号小  </span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sequenceNumber &lt; x.sequenceNumber)  <br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;  <br>        <span class="hljs-keyword">else</span>  <br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <br>    &#125;  <br>    <span class="hljs-comment">// 不是 ScheduledFutureTask 类型时，根据延迟时间排序  </span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">diff</span> <span class="hljs-operator">=</span> getDelay(NANOSECONDS) - other.getDelay(NANOSECONDS);  <br>    <span class="hljs-keyword">return</span> (diff &lt; <span class="hljs-number">0</span>) ? -<span class="hljs-number">1</span> : (diff &gt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>run()：执行任务，非周期任务直接完成直接结束，<strong>周期任务执行完后会设置下一次的执行时间，重新放入线程池的阻塞队列</strong>，如果线程池中的线程数量少于核心线程，就会添加 Worker 开启新线程</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">// 是否周期性，就是判断 period 是否为 0  </span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">periodic</span> <span class="hljs-operator">=</span> isPeriodic();  <br>    <span class="hljs-comment">// 根据是否是周期任务检查当前状态能否执行任务，不能执行就取消任务  </span><br>    <span class="hljs-keyword">if</span> (!canRunInCurrentRunState(periodic))  <br>        cancel(<span class="hljs-literal">false</span>);  <br>    <span class="hljs-comment">// 非周期任务，直接调用 FutureTask#run 执行  </span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!periodic)  <br>        ScheduledFutureTask.<span class="hljs-built_in">super</span>.run();  <br>    <span class="hljs-comment">// 周期任务的执行，返回 true 表示执行成功  </span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ScheduledFutureTask.<span class="hljs-built_in">super</span>.runAndReset()) &#123;  <br>        <span class="hljs-comment">// 设置周期任务的下一次执行时间  </span><br>        setNextRunTime();  <br>        <span class="hljs-comment">// 任务的下一次执行安排，如果当前线程池状态可以执行周期任务，加入队列，并开启新线程  </span><br>        reExecutePeriodic(outerTask);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>  周期任务正常完成后<strong>任务的状态不会变化</strong>，依旧是 NEW，不会设置 outcome 属性。但是如果本次任务执行出现异常，会进入 setException 方法将任务状态置为异常，把异常保存在 outcome 中，方法返回 false，后续的该任务将不会再周期的执行</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">runAndReset</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">// 任务不是新建的状态了，或者被别的线程执行了，直接返回 false  </span><br>    <span class="hljs-keyword">if</span> (state != NEW ||  <br>        !UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, runnerOffset, <span class="hljs-literal">null</span>, Thread.currentThread()))  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">ran</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        Callable&lt;V&gt; c = callable;  <br>        <span class="hljs-keyword">if</span> (c != <span class="hljs-literal">null</span> &amp;&amp; s == NEW) &#123;  <br>            <span class="hljs-keyword">try</span> &#123;  <br>                <span class="hljs-comment">// 执行方法，没有返回值  </span><br>                c.call();  <br>                ran = <span class="hljs-literal">true</span>;  <br>            &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;  <br>                <span class="hljs-comment">// 出现异常，把任务设置为异常状态，唤醒所有的 get 阻塞线程  </span><br>                setException(ex);  <br>            &#125;  <br>        &#125;  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br><span class="hljs-comment">// 执行完成把执行线程引用置为 null  </span><br>        runner = <span class="hljs-literal">null</span>;  <br>        s = state;  <br>        <span class="hljs-comment">// 如果线程被中断进行中断处理  </span><br>        <span class="hljs-keyword">if</span> (s &gt;= INTERRUPTING)  <br>            handlePossibleCancellationInterrupt(s);  <br>    &#125;  <br>    <span class="hljs-comment">// 如果正常执行，返回 true，并且任务状态没有被取消  </span><br>    <span class="hljs-keyword">return</span> ran &amp;&amp; s == NEW;  <br>&#125;<br><br><span class="hljs-comment">// 任务下一次的触发时间  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNextRunTime</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-type">long</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> period;  <br>    <span class="hljs-keyword">if</span> (p &gt; <span class="hljs-number">0</span>)  <br>        <span class="hljs-comment">// fixed-rate 模式，【时间设置为上一次执行任务的时间 + p】，两次任务执行的时间差  </span><br>        time += p;  <br>    <span class="hljs-keyword">else</span>  <br>        <span class="hljs-comment">// fixed-delay 模式，下一次执行时间是【当前这次任务结束的时间（就是现在） + delay 值】  </span><br>        time = triggerTime(-p);  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>reExecutePeriodic()<strong>：准备任务的下一次执行，重新放入阻塞任务队列</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// ScheduledThreadPoolExecutor#reExecutePeriodic  </span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">reExecutePeriodic</span><span class="hljs-params">(RunnableScheduledFuture&lt;?&gt; task)</span> &#123;  <br>    <span class="hljs-keyword">if</span> (canRunInCurrentRunState(<span class="hljs-literal">true</span>)) &#123;  <br>        <span class="hljs-comment">// 【放入任务队列】  </span><br>        <span class="hljs-built_in">super</span>.getQueue().add(task);  <br>        <span class="hljs-comment">// 如果提交完任务之后，线程池状态变为了 shutdown 状态，需要再次检查是否可以执行，  </span><br>        <span class="hljs-comment">// 如果不能执行且任务还在队列中未被取走，则取消任务  </span><br>        <span class="hljs-keyword">if</span> (!canRunInCurrentRunState(<span class="hljs-literal">true</span>) &amp;&amp; remove(task))  <br>            task.cancel(<span class="hljs-literal">false</span>);  <br>        <span class="hljs-keyword">else</span>  <br>            <span class="hljs-comment">// 当前线程池状态可以执行周期任务，加入队列，并【根据线程数量是否大于核心线程数确定是否开启新线程】  </span><br>            ensurePrestart();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>cancel()：取消任务</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">cancel</span><span class="hljs-params">(<span class="hljs-type">boolean</span> mayInterruptIfRunning)</span> &#123;  <br>    <span class="hljs-comment">// 调用父类 FutureTask#cancel 来取消任务  </span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">cancelled</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">super</span>.cancel(mayInterruptIfRunning);  <br>    <span class="hljs-comment">// removeOnCancel 用于控制任务取消后是否应该从阻塞队列中移除  </span><br>    <span class="hljs-keyword">if</span> (cancelled &amp;&amp; removeOnCancel &amp;&amp; heapIndex &gt;= <span class="hljs-number">0</span>)  <br>        <span class="hljs-comment">// 从等待队列中删除该任务，并调用 tryTerminate() 判断是否需要停止线程池  </span><br>        remove(<span class="hljs-built_in">this</span>);  <br>    <span class="hljs-keyword">return</span> cancelled;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h5 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h5><p>DelayedWorkQueue 是支持延时获取元素的阻塞队列，内部采用优先队列 PriorityQueue（小根堆、满二叉树）存储元素</p><p>其他阻塞队列存储节点的数据结构大都是链表，<strong>延迟队列是数组</strong>，所以延迟队列出队头元素后需要<strong>让其他元素（尾）替换到头节点</strong>，防止空指针异常</p><p>成员变量：</p><ul><li><p>容量：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;<span class="hljs-comment">// 初始容量  </span><br>   <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">// 节点数量  </span><br>   <br>   <span class="hljs-keyword">private</span> RunnableScheduledFuture&lt;?&gt;[] queue =   <br>       <span class="hljs-keyword">new</span> <span class="hljs-title class_">RunnableScheduledFuture</span>&lt;?&gt;[INITIAL_CAPACITY];<span class="hljs-comment">// 存放节点</span><br></code></pre></td></tr></table></figure></li><li><p>锁：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<span class="hljs-comment">// 控制并发  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">available</span> <span class="hljs-operator">=</span> lock.newCondition();<span class="hljs-comment">// 条件队列</span><br></code></pre></td></tr></table></figure></li><li><p>阻塞等待头节点的线程：线程池内的某个线程去 take() 获取任务时，如果延迟队列顶层节点不为 null（队列内有任务），但是节点任务还不到触发时间，线程就去检查<strong>队列的 leader字段</strong>是否被占用</p><ul><li><p>如果未被占用，则当前线程占用该字段，然后当前线程到 available 条件队列指定超时时间 <code>堆顶任务.time - now()</code> 挂起</p></li><li><p>如果被占用，当前线程直接到 available 条件队列不指定超时时间的挂起</p></li></ul><p>  &#x2F;&#x2F; leader 在 available 条件队列内是首元素，它超时之后会醒过来，然后再次将堆顶元素获取走，获取走之后，take()结束之前，会调用是 available.signal() 唤醒下一个条件队列内的等待者，然后释放 lock，下一个等待者被唤醒后去到 AQS 队列，做 acquireQueue(node) 逻辑<br>  <code>private Thread leader = null;</code></p></li></ul><p>成员方法</p><ul><li><p>offer()：插入节点</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(Runnable x)</span> &#123;  <br>    <span class="hljs-comment">// 判空  </span><br>    <span class="hljs-keyword">if</span> (x == <span class="hljs-literal">null</span>)  <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();  <br>    RunnableScheduledFuture&lt;?&gt; e = (RunnableScheduledFuture&lt;?&gt;)x;  <br>    <span class="hljs-comment">// 队列锁，增加删除数据时都要加锁  </span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;  <br>    lock.lock();  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> size;  <br>        <span class="hljs-comment">// 队列数量大于存放节点的数组长度，需要扩容  </span><br>        <span class="hljs-keyword">if</span> (i &gt;= queue.length)  <br>            <span class="hljs-comment">// 扩容为原来长度的 1.5 倍  </span><br>            grow();  <br>        size = i + <span class="hljs-number">1</span>;  <br>        <span class="hljs-comment">// 当前是第一个要插入的节点  </span><br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;  <br>            queue[<span class="hljs-number">0</span>] = e;  <br>            <span class="hljs-comment">// 修改 ScheduledFutureTask 的 heapIndex 属性，表示该对象在队列里的下标  </span><br>            setIndex(e, <span class="hljs-number">0</span>);  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            <span class="hljs-comment">// 向上调整元素的位置，并更新 heapIndex   </span><br>            siftUp(i, e);  <br>        &#125;  <br>        <span class="hljs-comment">// 情况1：当前任务是第一个加入到 queue 内的任务，所以在当前任务加入到 queue 之前，take() 线程会直接  </span><br>        <span class="hljs-comment">//到 available 队列不设置超时的挂起，并不会去占用 leader 字段，这时需会唤醒一个线程 让它去消费  </span><br>       <span class="hljs-comment">// 情况2：当前任务【优先级最高】，原堆顶任务可能还未到触发时间，leader 线程设置超时的在 available 挂起  </span><br>        <span class="hljs-comment">//原先的 leader 等待的是原先的头节点，所以 leader 已经无效，需要将 leader 线程唤醒，  </span><br>        <span class="hljs-comment">//唤醒之后它会检查堆顶，如果堆顶任务可以被消费，则直接获取走，否则继续成为 leader 等待新堆顶任务  </span><br>        <span class="hljs-keyword">if</span> (queue[<span class="hljs-number">0</span>] == e) &#123;  <br>            <span class="hljs-comment">// 将 leader 设置为 null  </span><br>            leader = <span class="hljs-literal">null</span>;  <br>            <span class="hljs-comment">// 直接随便唤醒等待头结点的阻塞线程  </span><br>            available.signal();  <br>        &#125;  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        lock.unlock();  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>  &#x2F;&#x2F; 插入新节点后对堆进行调整，进行节点上移，保持其特性【节点的值小于子节点的值】，小顶堆  </p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">siftUp</span><span class="hljs-params">(<span class="hljs-type">int</span> k, RunnableScheduledFuture&lt;?&gt; key)</span> &#123;  <br>    <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">0</span>) &#123;  <br>        <span class="hljs-comment">// 父节点，就是堆排序  </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> (k - <span class="hljs-number">1</span>) &gt;&gt;&gt; <span class="hljs-number">1</span>;  <br>        RunnableScheduledFuture&lt;?&gt; e = queue[parent];  <br>        <span class="hljs-comment">// key 和父节点比，如果大于父节点可以直接返回，否则就继续上浮  </span><br>        <span class="hljs-keyword">if</span> (key.compareTo(e) &gt;= <span class="hljs-number">0</span>)  <br>            <span class="hljs-keyword">break</span>;  <br>        queue[k] = e;  <br>        setIndex(e, k);  <br>        k = parent;  <br>    &#125;  <br>    queue[k] = key;  <br>    setIndex(key, k);  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>poll()：非阻塞获取头结点，<strong>获取执行时间最近并且可以执行的</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// 非阻塞获取  </span><br><span class="hljs-keyword">public</span> RunnableScheduledFuture&lt;?&gt; poll() &#123;  <br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;  <br>    lock.lock();  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-comment">// 获取队头节点，因为是小顶堆  </span><br>        RunnableScheduledFuture&lt;?&gt; first = queue[<span class="hljs-number">0</span>];  <br>        <span class="hljs-comment">// 头结点为空或者的延迟时间没到返回 null  </span><br>        <span class="hljs-keyword">if</span> (first == <span class="hljs-literal">null</span> || first.getDelay(NANOSECONDS) &gt; <span class="hljs-number">0</span>)  <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>        <span class="hljs-keyword">else</span>  <br>            <span class="hljs-comment">// 头结点达到延迟时间，【尾节点成为替代节点下移调整堆结构】，返回头结点  </span><br>            <span class="hljs-keyword">return</span> finishPoll(first);  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        lock.unlock();  <br>    &#125;  <br>&#125;<br><br><span class="hljs-keyword">private</span> RunnableScheduledFuture&lt;?&gt; finishPoll(RunnableScheduledFuture&lt;?&gt; f) &#123;  <br>    <span class="hljs-comment">// 获取尾索引  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> --size;  <br>    <span class="hljs-comment">// 获取尾节点  </span><br>    RunnableScheduledFuture&lt;?&gt; x = queue[s];  <br>    <span class="hljs-comment">// 将堆结构最后一个节点占用的 slot 设置为 null，因为该节点要尝试升级成堆顶，会根据特性下调  </span><br>    queue[s] = <span class="hljs-literal">null</span>;  <br>    <span class="hljs-comment">// s == 0 说明 当前堆结构只有堆顶一个节点，此时不需要做任何的事情  </span><br>    <span class="hljs-keyword">if</span> (s != <span class="hljs-number">0</span>)  <br>        <span class="hljs-comment">// 从索引处 0 开始向下调整  </span><br>        siftDown(<span class="hljs-number">0</span>, x);  <br>    <span class="hljs-comment">// 出队的元素索引设置为 -1  </span><br>    setIndex(f, -<span class="hljs-number">1</span>);  <br>    <span class="hljs-keyword">return</span> f;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>take()：阻塞获取头节点，读取当前堆中最小的也就是触发时间最近的任务</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> RunnableScheduledFuture&lt;?&gt; take() <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;  <br>    <span class="hljs-comment">// 保证线程安全  </span><br>    lock.lockInterruptibly();  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-keyword">for</span> (;;) &#123;  <br>            <span class="hljs-comment">// 头节点  </span><br>            RunnableScheduledFuture&lt;?&gt; first = queue[<span class="hljs-number">0</span>];  <br>            <span class="hljs-keyword">if</span> (first == <span class="hljs-literal">null</span>)  <br>                <span class="hljs-comment">// 等待队列不空，直至有任务通过 offer 入队并唤醒  </span><br>                available.await();  <br>            <span class="hljs-keyword">else</span> &#123;  <br>                <span class="hljs-comment">// 获取头节点的延迟时间是否到时  </span><br>                <span class="hljs-type">long</span> <span class="hljs-variable">delay</span> <span class="hljs-operator">=</span> first.getDelay(NANOSECONDS);  <br>                <span class="hljs-keyword">if</span> (delay &lt;= <span class="hljs-number">0</span>)  <br>                    <span class="hljs-comment">// 到达触发时间，获取头节点并调整堆，重新选择延迟时间最小的节点放入头部  </span><br>                    <span class="hljs-keyword">return</span> finishPoll(first);  <br>                  <br>                <span class="hljs-comment">// 逻辑到这说明头节点的延迟时间还没到  </span><br>                first = <span class="hljs-literal">null</span>;  <br>                <span class="hljs-comment">// 说明有 leader 线程在等待获取头节点，当前线程直接去阻塞等待  </span><br>                <span class="hljs-keyword">if</span> (leader != <span class="hljs-literal">null</span>)  <br>                    available.await();  <br>                <span class="hljs-keyword">else</span> &#123;  <br>                    <span class="hljs-comment">// 没有 leader 线程，【当前线程作为leader线程，并设置头结点的延迟时间作为阻塞时间】  </span><br>                    <span class="hljs-type">Thread</span> <span class="hljs-variable">thisThread</span> <span class="hljs-operator">=</span> Thread.currentThread();  <br>                    leader = thisThread;  <br>                    <span class="hljs-keyword">try</span> &#123;  <br>                        <span class="hljs-comment">// 在条件队列 available 使用带超时的挂起（堆顶任务.time - now() 纳秒值..）  </span><br>                        available.awaitNanos(delay);  <br>                        <span class="hljs-comment">// 到达阻塞时间时，当前线程会从这里醒来来  </span><br>                    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>                        <span class="hljs-comment">// t堆顶更新，leader 置为 null，offer 方法释放锁后，  </span><br>                        <span class="hljs-comment">// 有其它线程通过 take/poll 拿到锁,读到 leader == null，然后将自身更新为leader。  </span><br>                        <span class="hljs-keyword">if</span> (leader == thisThread)  <br>                            <span class="hljs-comment">// leader 置为 null 用以接下来判断是否需要唤醒后继线程  </span><br>                            leader = <span class="hljs-literal">null</span>;  <br>                    &#125;  <br>                &#125;  <br>            &#125;  <br>        &#125;  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        <span class="hljs-comment">// 没有 leader 线程，头结点不为 null，唤醒阻塞获取头节点的线程，  </span><br>        <span class="hljs-comment">// 【如果没有这一步，就会出现有了需要执行的任务，但是没有线程去执行】  </span><br>        <span class="hljs-keyword">if</span> (leader == <span class="hljs-literal">null</span> &amp;&amp; queue[<span class="hljs-number">0</span>] != <span class="hljs-literal">null</span>)  <br>            available.signal();  <br>        lock.unlock();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>remove()：删除节点，堆移除一个元素的时间复杂度是 O(log n)，<strong>延迟任务维护了 heapIndex</strong>，直接访问的时间复杂度是 O(1)，从而可以更快的移除元素，任务在队列中被取消后会进入该逻辑</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object x)</span> &#123;  <br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;  <br>    lock.lock();  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-comment">// 查找对象在队列数组中的下标  </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> indexOf(x);  <br>        <span class="hljs-comment">// 节点不存在，返回 false  </span><br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>)  <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br><span class="hljs-comment">// 修改元素的 heapIndex，-1 代表删除  </span><br>        setIndex(queue[i], -<span class="hljs-number">1</span>);  <br>        <span class="hljs-comment">// 尾索引是长度-1  </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> --size;  <br>        <span class="hljs-comment">// 尾节点作为替代节点  </span><br>        RunnableScheduledFuture&lt;?&gt; replacement = queue[s];  <br>        queue[s] = <span class="hljs-literal">null</span>;  <br>        <span class="hljs-comment">// s == i 说明头节点就是尾节点，队列空了  </span><br>        <span class="hljs-keyword">if</span> (s != i) &#123;  <br>            <span class="hljs-comment">// 向下调整  </span><br>            siftDown(i, replacement);  <br>            <span class="hljs-comment">// 说明没发生调整  </span><br>            <span class="hljs-keyword">if</span> (queue[i] == replacement)  <br>                <span class="hljs-comment">// 上移和下移不可能同时发生，替代节点大于子节点时下移，否则上移  </span><br>                siftUp(i, replacement);  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        lock.unlock();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h4 id="成员方法-4"><a href="#成员方法-4" class="headerlink" title="成员方法"></a>成员方法</h4><h5 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a>提交任务</h5><ul><li><p>schedule()：延迟执行方法，并指定执行的时间，默认是当前时间</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> &#123;  <br>    <span class="hljs-comment">// 以零延时任务的形式实现  </span><br>    schedule(command, <span class="hljs-number">0</span>, NANOSECONDS);  <br>&#125;<br><br><span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command, <span class="hljs-type">long</span> delay, TimeUnit unit) &#123;  <br>    <span class="hljs-comment">// 判空  </span><br>    <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span> || unit == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();  <br>    <span class="hljs-comment">// 没有做任何操作，直接将 task 返回，该方法主要目的是用于子类扩展，并且【根据延迟时间设置任务触发的时间点】  </span><br>    RunnableScheduledFuture&lt;?&gt; t = decorateTask(command, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledFutureTask</span>&lt;Void&gt;(  <br>        command, <span class="hljs-literal">null</span>, triggerTime(delay, unit)));  <br>    <span class="hljs-comment">// 延迟执行  </span><br>    delayedExecute(t);  <br>    <span class="hljs-keyword">return</span> t;  <br>&#125;<br><br><span class="hljs-comment">// 返回【当前时间 + 延迟时间】，就是触发当前任务执行的时间  </span><br><span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-title function_">triggerTime</span><span class="hljs-params">(<span class="hljs-type">long</span> delay, TimeUnit unit)</span> &#123;  <br>    <span class="hljs-comment">// 设置触发的时间  </span><br>    <span class="hljs-keyword">return</span> triggerTime(unit.toNanos((delay &lt; <span class="hljs-number">0</span>) ? <span class="hljs-number">0</span> : delay));  <br>&#125;  <br><span class="hljs-type">long</span> <span class="hljs-title function_">triggerTime</span><span class="hljs-params">(<span class="hljs-type">long</span> delay)</span> &#123;  <br>    <span class="hljs-comment">// 如果 delay &lt; Long.Max_VALUE/2，则下次执行时间为当前时间 +delay  </span><br>    <span class="hljs-comment">// 否则为了避免队列中出现由于溢出导致的排序紊乱,需要调用overflowFree来修正一下delay  </span><br>    <span class="hljs-keyword">return</span> now() + ((delay &lt; (Long.MAX_VALUE &gt;&gt; <span class="hljs-number">1</span>)) ? delay : overflowFree(delay));  <br>&#125;<br></code></pre></td></tr></table></figure><p>  overflowFree 的原因：如果某个任务的 delay 为负数，说明当前可以执行（其实早该执行了）。阻塞队列中维护任务顺序是基于 compareTo 比较的，比较两个任务的顺序会用 time 相减。那么可能出现一个 delay 为正数减去另一个为负数的 delay，结果上溢为负数，则会导致 compareTo 产生错误的结果</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-title function_">overflowFree</span><span class="hljs-params">(<span class="hljs-type">long</span> delay)</span> &#123;  <br>    <span class="hljs-type">Delayed</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> (Delayed) <span class="hljs-built_in">super</span>.getQueue().peek();  <br>    <span class="hljs-keyword">if</span> (head != <span class="hljs-literal">null</span>) &#123;  <br>        <span class="hljs-type">long</span> <span class="hljs-variable">headDelay</span> <span class="hljs-operator">=</span> head.getDelay(NANOSECONDS);  <br>        <span class="hljs-comment">// 判断一下队首的delay是不是负数，如果是正数就不用管，怎么减都不会溢出  </span><br>        <span class="hljs-comment">// 否则拿当前 delay 减去队首的 delay 来比较看，如果不出现上溢，排序不会乱  </span><br><span class="hljs-comment">// 不然就把当前 delay 值给调整为 Long.MAX_VALUE + 队首 delay  </span><br>        <span class="hljs-keyword">if</span> (headDelay &lt; <span class="hljs-number">0</span> &amp;&amp; (delay - headDelay &lt; <span class="hljs-number">0</span>))  <br>            delay = Long.MAX_VALUE + headDelay;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> delay;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>scheduleAtFixedRate()：定时执行，一次任务的启动到下一次任务的启动的间隔</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, <span class="hljs-type">long</span> initialDelay, <span class="hljs-type">long</span> period,  <br>                                              TimeUnit unit) &#123;  <br>    <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span> || unit == <span class="hljs-literal">null</span>)  <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();  <br>    <span class="hljs-keyword">if</span> (period &lt;= <span class="hljs-number">0</span>)  <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();  <br>    <span class="hljs-comment">// 任务封装，【指定初始的延迟时间和周期时间】  </span><br>    ScheduledFutureTask&lt;Void&gt; sft =<span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledFutureTask</span>&lt;Void&gt;(command, <span class="hljs-literal">null</span>,  <br>                                      triggerTime(initialDelay, unit), unit.toNanos(period));  <br>    <span class="hljs-comment">// 默认返回本身  </span><br>    RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command, sft);  <br>    sft.outerTask = t;  <br>    <span class="hljs-comment">// 开始执行这个任务  </span><br>    delayedExecute(t);  <br>    <span class="hljs-keyword">return</span> t;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>scheduleWithFixedDelay()：定时执行，一次任务的结束到下一次任务的启动的间隔</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, <span class="hljs-type">long</span> initialDelay, <span class="hljs-type">long</span> delay,  <br>                                                 TimeUnit unit) &#123;  <br>    <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span> || unit == <span class="hljs-literal">null</span>)   <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();  <br>    <span class="hljs-keyword">if</span> (delay &lt;= <span class="hljs-number">0</span>)  <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();  <br>    <span class="hljs-comment">// 任务封装，【指定初始的延迟时间和周期时间】，周期时间为 - 表示是 fixed-delay 模式  </span><br>    ScheduledFutureTask&lt;Void&gt; sft = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledFutureTask</span>&lt;Void&gt;(command, <span class="hljs-literal">null</span>,  <br>                                      triggerTime(initialDelay, unit), unit.toNanos(-delay));  <br>    RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command, sft);  <br>    sft.outerTask = t;  <br>    delayedExecute(t);  <br>    <span class="hljs-keyword">return</span> t;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h5 id="运行任务"><a href="#运行任务" class="headerlink" title="运行任务"></a>运行任务</h5><ul><li><p>delayedExecute()：<strong>校验线程池状态</strong>，延迟或周期性任务的主要执行方法</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delayedExecute</span><span class="hljs-params">(RunnableScheduledFuture&lt;?&gt; task)</span> &#123;  <br>    <span class="hljs-comment">// 线程池是 SHUTDOWN 状态，需要执行拒绝策略  </span><br>    <span class="hljs-keyword">if</span> (isShutdown())  <br>        reject(task);  <br>    <span class="hljs-keyword">else</span> &#123;  <br>        <span class="hljs-comment">// 把当前任务放入阻塞队列，因为需要【获取执行时间最近的】，当前任务需要比较  </span><br>        <span class="hljs-built_in">super</span>.getQueue().add(task);  <br>        <span class="hljs-comment">// 线程池状态为 SHUTDOWN 并且不允许执行任务了，就从队列删除该任务，并设置任务的状态为取消状态  </span><br>        <span class="hljs-keyword">if</span> (isShutdown() &amp;&amp; !canRunInCurrentRunState(task.isPeriodic()) &amp;&amp; remove(task))  <br>            task.cancel(<span class="hljs-literal">false</span>);  <br>        <span class="hljs-keyword">else</span>  <br>            <span class="hljs-comment">// 可以执行  </span><br>            ensurePrestart();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>ensurePrestart()：<strong>开启线程执行任务</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// ThreadPoolExecutor#ensurePrestart  </span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">ensurePrestart</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">wc</span> <span class="hljs-operator">=</span> workerCountOf(ctl.get());  <br>    <span class="hljs-comment">// worker数目小于corePoolSize，则添加一个worker。  </span><br>    <span class="hljs-keyword">if</span> (wc &lt; corePoolSize)  <br>        <span class="hljs-comment">// 第二个参数 true 表示采用核心线程数量限制，false 表示采用 maximumPoolSize  </span><br>        addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>);  <br>    <span class="hljs-comment">// corePoolSize = 0的情况，至少开启一个线程，【担保机制】  </span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (wc == <span class="hljs-number">0</span>)  <br>        addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>canRunInCurrentRunState()：任务运行时都会被调用以校验当前状态是否可以运行任务</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">canRunInCurrentRunState</span><span class="hljs-params">(<span class="hljs-type">boolean</span> periodic)</span> &#123;  <br>    <span class="hljs-comment">// 根据是否是周期任务判断，在线程池 shutdown 后是否继续执行该任务，默认非周期任务是继续执行的  </span><br>    <span class="hljs-keyword">return</span> isRunningOrShutdown(periodic ? continueExistingPeriodicTasksAfterShutdown :  <br>                               executeExistingDelayedTasksAfterShutdown);  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>onShutdown()：删除并取消工作队列中的不需要再执行的任务</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">onShutdown</span><span class="hljs-params">()</span> &#123;  <br>    BlockingQueue&lt;Runnable&gt; q = <span class="hljs-built_in">super</span>.getQueue();  <br>    <span class="hljs-comment">// shutdown 后是否仍然执行延时任务  </span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">keepDelayed</span> <span class="hljs-operator">=</span> getExecuteExistingDelayedTasksAfterShutdownPolicy();  <br>    <span class="hljs-comment">// shutdown 后是否仍然执行周期任务  </span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">keepPeriodic</span> <span class="hljs-operator">=</span> getContinueExistingPeriodicTasksAfterShutdownPolicy();  <br>    <span class="hljs-comment">// 如果两者皆不可，则对队列中【所有任务】调用 cancel 取消并清空队列  </span><br>    <span class="hljs-keyword">if</span> (!keepDelayed &amp;&amp; !keepPeriodic) &#123;  <br>        <span class="hljs-keyword">for</span> (Object e : q.toArray())  <br>            <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> RunnableScheduledFuture&lt;?&gt;)  <br>                ((RunnableScheduledFuture&lt;?&gt;) e).cancel(<span class="hljs-literal">false</span>);  <br>        q.clear();  <br>    &#125;  <br>    <span class="hljs-keyword">else</span> &#123;  <br>        <span class="hljs-keyword">for</span> (Object e : q.toArray()) &#123;  <br>            <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> RunnableScheduledFuture) &#123;  <br>                RunnableScheduledFuture&lt;?&gt; t = (RunnableScheduledFuture&lt;?&gt;)e;  <br>                <span class="hljs-comment">// 不需要执行的任务删除并取消，已经取消的任务也需要从队列中删除  </span><br>                <span class="hljs-keyword">if</span> ((t.isPeriodic() ? !keepPeriodic : !keepDelayed) ||  <br>                    t.isCancelled()) &#123;  <br>                    <span class="hljs-keyword">if</span> (q.remove(t))  <br>                        t.cancel(<span class="hljs-literal">false</span>);  <br>                &#125;  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-comment">// 因为任务被从队列中清理掉，所以需要调用 tryTerminate 尝试【改变线程池的状态】  </span><br>    tryTerminate();  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="ForkJoin"><a href="#ForkJoin" class="headerlink" title="ForkJoin"></a>ForkJoin</h3><p>Fork&#x2F;Join：线程池的实现，体现是分治思想，适用于能够进行任务拆分的 CPU 密集型运算，用于<strong>并行计算</strong></p><p>任务拆分：将一个大任务拆分为算法上相同的小任务，直至不能拆分可以直接求解。跟递归相关的一些计算，如归并排序、斐波那契数列都可以用分治思想进行求解</p><ul><li><p>Fork&#x2F;Join 在<strong>分治的基础上加入了多线程</strong>，把每个任务的分解和合并交给不同的线程来完成，提升了运算效率</p></li><li><p>ForkJoin 使用 ForkJoinPool 来启动，是一个特殊的线程池，默认会创建与 CPU 核心数大小相同的线程池</p></li><li><p>任务有返回值继承 RecursiveTask，没有返回值继承 RecursiveAction</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    <span class="hljs-type">ForkJoinPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>(<span class="hljs-number">4</span>);  <br>    System.out.println(pool.invoke(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyTask</span>(<span class="hljs-number">5</span>)));  <br>    <span class="hljs-comment">//拆分  5 + MyTask(4) --&gt; 4 + MyTask(3) --&gt;  </span><br>&#125;  <br>  <br><span class="hljs-comment">// 1~ n 之间整数的和  </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RecursiveTask</span>&lt;Integer&gt; &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> n;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyTask</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.n = n;  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;MyTask&#123;&quot;</span> + <span class="hljs-string">&quot;n=&quot;</span> + n + <span class="hljs-string">&#x27;&#125;&#x27;</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">protected</span> Integer <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-comment">// 如果 n 已经为 1，可以求得结果了  </span><br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;  <br>            <span class="hljs-keyword">return</span> n;  <br>        &#125;  <br>        <span class="hljs-comment">// 将任务进行拆分(fork)  </span><br>        <span class="hljs-type">MyTask</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyTask</span>(n - <span class="hljs-number">1</span>);  <br>        t1.fork();  <br>        <span class="hljs-comment">// 合并(join)结果  </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> n + t1.join();  <br>        <span class="hljs-keyword">return</span> result;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>继续拆分优化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RecursiveTask</span>&lt;Integer&gt; &#123;  <br>    <span class="hljs-type">int</span> begin;  <br>    <span class="hljs-type">int</span> end;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AddTask</span><span class="hljs-params">(<span class="hljs-type">int</span> begin, <span class="hljs-type">int</span> end)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.begin = begin;  <br>        <span class="hljs-built_in">this</span>.end = end;  <br>    &#125;  <br>      <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&quot;</span> + begin + <span class="hljs-string">&quot;,&quot;</span> + end + <span class="hljs-string">&#x27;&#125;&#x27;</span>;  <br>    &#125;  <br>      <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">protected</span> Integer <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-comment">// 5, 5  </span><br>        <span class="hljs-keyword">if</span> (begin == end) &#123;  <br>            <span class="hljs-keyword">return</span> begin;  <br>        &#125;  <br>        <span class="hljs-comment">// 4, 5  防止多余的拆分  提高效率  </span><br>        <span class="hljs-keyword">if</span> (end - begin == <span class="hljs-number">1</span>) &#123;  <br>            <span class="hljs-keyword">return</span> end + begin;  <br>        &#125;  <br>        <span class="hljs-comment">// 1 5  </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (end + begin) / <span class="hljs-number">2</span>; <span class="hljs-comment">// 3  </span><br>        <span class="hljs-type">AddTask</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AddTask</span>(begin, mid); <span class="hljs-comment">// 1,3  </span><br>        t1.fork();  <br>        <span class="hljs-type">AddTask</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AddTask</span>(mid + <span class="hljs-number">1</span>, end); <span class="hljs-comment">// 4,5  </span><br>        t2.fork();  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> t1.join() + t2.join();  <br>        <span class="hljs-keyword">return</span> result;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>ForkJoinPool 实现了<strong>工作窃取算法</strong>来提高 CPU 的利用率：</p><ul><li><p>每个线程都维护了一个<strong>双端队列</strong>，用来存储需要执行的任务</p></li><li><p>工作窃取算法允许空闲的线程从其它线程的双端队列中窃取一个任务来执行</p></li><li><p>窃取的必须是<strong>最晚的任务</strong>，避免和队列所属线程发生竞争，但是队列中只有一个任务时还是会发生竞争</p></li></ul><hr><h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><p>享元模式（Flyweight pattern）： 用于减少创建对象的数量，以减少内存占用和提高性能，这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式</p><p>异步模式：让有限的工作线程（Worker Thread）来轮流异步处理无限多的任务，也可将其归类为分工模式，典型实现就是线程池</p><p>工作机制：享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象</p><p>自定义连接池：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    <span class="hljs-type">Pool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pool</span>(<span class="hljs-number">2</span>);  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;  <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>            <span class="hljs-type">Connection</span> <span class="hljs-variable">con</span> <span class="hljs-operator">=</span> pool.borrow();  <br>            <span class="hljs-keyword">try</span> &#123;  <br>                Thread.sleep(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">1000</span>));  <br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>                e.printStackTrace();  <br>            &#125;  <br>            pool.free(con);  <br>        &#125;).start();  <br>    &#125;  <br>&#125;  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pool</span> &#123;  <br>    <span class="hljs-comment">//连接池的大小  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> poolSize;  <br>    <span class="hljs-comment">//连接对象的数组  </span><br>    <span class="hljs-keyword">private</span> Connection[] connections;  <br>    <span class="hljs-comment">//连接状态数组 0表示空闲  1表示繁忙  </span><br>    <span class="hljs-keyword">private</span> AtomicIntegerArray states;  <span class="hljs-comment">//int[] -&gt; AtomicIntegerArray  </span><br>  <br>    <span class="hljs-comment">//构造方法  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Pool</span><span class="hljs-params">(<span class="hljs-type">int</span> poolSize)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.poolSize = poolSize;  <br>        <span class="hljs-built_in">this</span>.connections = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Connection</span>[poolSize];  <br>        <span class="hljs-built_in">this</span>.states = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicIntegerArray</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[poolSize]);  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;  <br>            connections[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MockConnection</span>(<span class="hljs-string">&quot;连接&quot;</span> + (i + <span class="hljs-number">1</span>));  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//使用连接  </span><br>    <span class="hljs-keyword">public</span> Connection <span class="hljs-title function_">borrow</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;  <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;  <br>                <span class="hljs-keyword">if</span> (states.get(i) == <span class="hljs-number">0</span>) &#123;  <br>                    <span class="hljs-keyword">if</span> (states.compareAndSet(i, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;  <br>                        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; borrow &quot;</span> +  connections[i]);  <br>                        <span class="hljs-keyword">return</span> connections[i];  <br>                    &#125;  <br>                &#125;  <br>            &#125;  <br>            <span class="hljs-comment">//如果没有空闲连接，当前线程等待  </span><br>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;  <br>                <span class="hljs-keyword">try</span> &#123;  <br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; wait...&quot;</span>);  <br>                    <span class="hljs-built_in">this</span>.wait();  <br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>                    e.printStackTrace();  <br>                &#125;  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//归还连接  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">free</span><span class="hljs-params">(Connection con)</span> &#123;  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;  <br>            <span class="hljs-keyword">if</span> (connections[i] == con) &#123;<span class="hljs-comment">//判断是否是同一个对象  </span><br>                states.set(i, <span class="hljs-number">0</span>);<span class="hljs-comment">//不用cas的原因是只会有一个线程使用该连接  </span><br>                <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;  <br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; free &quot;</span> + con);  <br>                    <span class="hljs-built_in">this</span>.notifyAll();  <br>                &#125;  <br>                <span class="hljs-keyword">break</span>;  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>  <br>&#125;  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MockConnection</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Connection</span> &#123;  <br>    <span class="hljs-keyword">private</span> String name;  <br>    <span class="hljs-comment">//.....  </span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="同步器"><a href="#同步器" class="headerlink" title="同步器"></a>同步器</h2><h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><h4 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h4><p>AQS：AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架，许多同步类实现都依赖于该同步器</p><p>AQS 用状态属性来表示资源的状态（分<strong>独占模式和共享模式</strong>），子类需要定义如何维护这个状态，控制如何获取锁和释放锁</p><ul><li><p>独占模式是只有一个线程能够访问资源，如 ReentrantLock</p></li><li><p>共享模式允许多个线程访问资源，如 Semaphore，ReentrantReadWriteLock 是组合式</p></li></ul><p>AQS 核心思想：</p><ul><li><p>如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置锁定状态</p></li><li><p>请求的共享资源被占用，AQS 用队列实现线程阻塞等待以及被唤醒时锁分配的机制，将暂时获取不到锁的线程加入到队列中</p><p>  CLH 是一种基于单向链表的<strong>高性能、公平的自旋锁</strong>，AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配</p><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041843050.png"></p></li></ul><hr><h4 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h4><p>设计原理：</p><ul><li><p>获取锁：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(state 状态不允许获取) &#123;<span class="hljs-comment">// tryAcquire(arg)  </span><br>       <span class="hljs-keyword">if</span>(队列中还没有此线程) &#123;  <br>           入队并阻塞 park  <br>       &#125;  <br>   &#125;  <br>   当前线程出队<br></code></pre></td></tr></table></figure></li><li><p>释放锁：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">if</span>(state 状态允许了) &#123;<span class="hljs-comment">// tryRelease(arg)  </span><br>恢复阻塞的线程(s) unpark  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>AbstractQueuedSynchronizer 中 state 设计：</p><ul><li><p>state 使用了 32bit int 来维护同步状态，独占模式 0 表示未加锁状态，大于 0 表示已经加锁状态</p><p>  <code>private volatile int state;</code></p></li><li><p>state <strong>使用 volatile 修饰配合 cas</strong> 保证其修改时的原子性</p></li><li><p>state 表示<strong>线程重入的次数（独占模式）或者剩余许可数（共享模式）</strong></p></li><li><p>state API：</p><ul><li><p><code>protected final int getState()</code>：获取 state 状态</p></li><li><p><code>protected final void setState(int newState)</code>：设置 state 状态</p></li><li><p><code>protected final boolean compareAndSetState(int expect,int update)</code>：<strong>CAS</strong> 安全设置 state</p></li></ul></li></ul><p>封装线程的 Node 节点中 waitstate 设计：</p><ul><li><p>使用 <strong>volatile 修饰配合 CAS</strong> 保证其修改时的原子性</p></li><li><p>表示 Node 节点的状态，有以下几种状态：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// 默认为 0  </span><br><span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> waitStatus;  <br><span class="hljs-comment">// 由于超时或中断，此节点被取消，不会再改变状态  </span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CANCELLED</span> <span class="hljs-operator">=</span>  <span class="hljs-number">1</span>;  <br><span class="hljs-comment">// 此节点后面的节点已（或即将）被阻止（通过park），【当前节点在释放或取消时必须唤醒后面的节点】  </span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SIGNAL</span>    <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;  <br><span class="hljs-comment">// 此节点当前在条件队列中  </span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CONDITION</span> <span class="hljs-operator">=</span> -<span class="hljs-number">2</span>;  <br><span class="hljs-comment">// 将releaseShared传播到其他节点  </span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PROPAGATE</span> <span class="hljs-operator">=</span> -<span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure></li></ul><p>阻塞恢复设计：</p><ul><li><p>使用 park &amp; unpark 来实现线程的暂停和恢复，因为命令的先后顺序不影响结果</p></li><li><p>park &amp; unpark 是针对线程的，而不是针对同步器的，因此控制粒度更为精细</p></li><li><p>park 线程可以通过 interrupt 打断</p></li></ul><p>队列设计：</p><ul><li><p>使用了 FIFO 先入先出队列，并不支持优先级队列，<strong>同步队列是双向链表，便于出队入队</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// 头结点，指向哑元节点  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node head;  <br><span class="hljs-comment">// 阻塞队列的尾节点，阻塞队列不包含头结点，从 head.next → tail 认为是阻塞队列  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node tail;  <br>  <br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;  <br>    <span class="hljs-comment">// 枚举：共享模式  </span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">SHARED</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();  <br>    <span class="hljs-comment">// 枚举：独占模式  </span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">EXCLUSIVE</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;  <br>    <span class="hljs-comment">// node 需要构建成 FIFO 队列，prev 指向前继节点  </span><br>    <span class="hljs-keyword">volatile</span> Node prev;  <br>    <span class="hljs-comment">// next 指向后继节点  </span><br>    <span class="hljs-keyword">volatile</span> Node next;  <br>    <span class="hljs-comment">// 当前 node 封装的线程  </span><br>    <span class="hljs-keyword">volatile</span> Thread thread;  <br>    <span class="hljs-comment">// 条件队列是单向链表，只有后继指针，条件队列使用该属性  </span><br>    Node nextWaiter;  <br>&#125;<br></code></pre></td></tr></table></figure><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041846265.png"></p></li><li><p>条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet，<strong>条件队列是单向链表</strong></p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConditionObject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Condition</span>, java.io.Serializable &#123;  <br>    <span class="hljs-comment">// 指向条件队列的第一个 node 节点  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node firstWaiter;  <br>    <span class="hljs-comment">// 指向条件队列的最后一个 node 节点  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node lastWaiter;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h4 id="模板对象"><a href="#模板对象" class="headerlink" title="模板对象"></a>模板对象</h4><p>同步器的设计是基于模板方法模式，该模式是基于继承的，主要是为了在不改变模板结构的前提下在子类中重新定义模板中的内容以实现复用代码</p><ul><li><p>使用者继承 <code>AbstractQueuedSynchronizer</code> 并重写指定的方法</p></li><li><p>将 AQS 组合在自定义同步组件的实现中，并调用其模板方法，这些模板方法会调用使用者重写的方法</p></li></ul><p>AQS 使用了模板方法模式，自定义同步器时需要重写下面几个 AQS 提供的模板方法：</p><p>isHeldExclusively()&#x2F;&#x2F;该线程是否正在独占资源。只有用到condition才需要去实现它<br>tryAcquire(int)&#x2F;&#x2F;独占方式。尝试获取资源，成功则返回true，失败则返回false<br>tryRelease(int)&#x2F;&#x2F;独占方式。尝试释放资源，成功则返回true，失败则返回false<br>tryAcquireShared(int)&#x2F;&#x2F;共享方式。尝试获取资源。负数表示失败；0表示成功但没有剩余可用资源；正数表示成功且有剩余资源<br>tryReleaseShared(int)&#x2F;&#x2F;共享方式。尝试释放资源，成功则返回true，失败则返回false</p><ul><li><p>默认情况下，每个方法都抛出 <code>UnsupportedOperationException</code></p></li><li><p>这些方法的实现必须是内部线程安全的</p></li><li><p>AQS 类中的其他方法都是 final ，所以无法被其他类使用，只有这几个方法可以被其他类使用</p></li></ul><hr><h4 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h4><p>自定义一个不可重入锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Lock</span> &#123;  <br>    <span class="hljs-comment">//独占锁 不可重入  </span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">MySync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;  <br>        <span class="hljs-meta">@Override</span>  <br>        <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;  <br>            <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;  <br>                <span class="hljs-comment">// 加上锁 设置 owner 为当前线程  </span><br>                setExclusiveOwnerThread(Thread.currentThread());  <br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>            &#125;  <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>        &#125;  <br>        <span class="hljs-meta">@Override</span>   <span class="hljs-comment">//解锁  </span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;  <br>            setExclusiveOwnerThread(<span class="hljs-literal">null</span>);  <br>            setState(<span class="hljs-number">0</span>);<span class="hljs-comment">//volatile 修饰的变量放在后面，防止指令重排  </span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>        &#125;  <br>        <span class="hljs-meta">@Override</span>   <span class="hljs-comment">//是否持有独占锁  </span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHeldExclusively</span><span class="hljs-params">()</span> &#123;  <br>            <span class="hljs-keyword">return</span> getState() == <span class="hljs-number">1</span>;  <br>        &#125;  <br>        <span class="hljs-keyword">public</span> Condition <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span> &#123;  <br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConditionObject</span>();  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">MySync</span> <span class="hljs-variable">sync</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MySync</span>();  <br>  <br>    <span class="hljs-meta">@Override</span>   <span class="hljs-comment">//加锁（不成功进入等待队列等待）  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;  <br>        sync.acquire(<span class="hljs-number">1</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>   <span class="hljs-comment">//加锁 可打断  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>        sync.acquireInterruptibly(<span class="hljs-number">1</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>   <span class="hljs-comment">//尝试加锁，尝试一次  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> sync.tryAcquire(<span class="hljs-number">1</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>   <span class="hljs-comment">//尝试加锁，带超时  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>        <span class="hljs-keyword">return</span> sync.tryAcquireNanos(<span class="hljs-number">1</span>, unit.toNanos(time));  <br>    &#125;  <br>      <br>    <span class="hljs-meta">@Override</span>   <span class="hljs-comment">//解锁  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;  <br>        sync.release(<span class="hljs-number">1</span>);  <br>    &#125;  <br>      <br>    <span class="hljs-meta">@Override</span>   <span class="hljs-comment">//条件变量  </span><br>    <span class="hljs-keyword">public</span> Condition <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> sync.newCondition();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><h4 id="锁对比"><a href="#锁对比" class="headerlink" title="锁对比"></a>锁对比</h4><p>ReentrantLock 相对于 synchronized 具备如下特点：</p><ol><li><p>锁的实现：synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的</p></li><li><p>性能：新版本 Java 对 synchronized 进行了很多优化，synchronized 与 ReentrantLock 大致相同</p></li><li><p>使用：ReentrantLock 需要手动解锁，synchronized 执行完代码块自动解锁</p></li><li><p><strong>可中断</strong>：ReentrantLock 可中断，而 synchronized 不行</p></li><li><p><strong>公平锁</strong>：公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁</p><ul><li><p>ReentrantLock 可以设置公平锁，synchronized 中的锁是非公平的</p></li><li><p>不公平锁的含义是阻塞队列内公平，队列外非公平</p></li></ul></li><li><p>锁超时：尝试获取锁，超时获取不到直接放弃，不进入阻塞队列</p><ul><li>ReentrantLock 可以设置超时时间，synchronized 会一直等待</li></ul></li><li><p>锁绑定多个条件：一个 ReentrantLock 可以同时绑定多个 Condition 对象，更细粒度的唤醒线程</p></li><li><p>两者都是可重入锁</p></li></ol><hr><h4 id="使用锁"><a href="#使用锁" class="headerlink" title="使用锁"></a>使用锁</h4><p>构造方法：<code>ReentrantLock lock = new ReentrantLock();</code></p><p>ReentrantLock 类 API：</p><ul><li><p><code>public void lock()</code>：获得锁</p><ul><li><p>如果锁没有被另一个线程占用，则将锁定计数设置为 1</p></li><li><p>如果当前线程已经保持锁定，则保持计数增加 1</p></li><li><p>如果锁被另一个线程保持，则当前线程被禁用线程调度，并且在锁定已被获取之前处于休眠状态</p></li></ul></li><li><p><code>public void unlock()</code>：尝试释放锁</p><ul><li><p>如果当前线程是该锁的持有者，则保持计数递减</p></li><li><p>如果保持计数现在为零，则锁定被释放</p></li><li><p>如果当前线程不是该锁的持有者，则抛出异常</p></li></ul></li></ul><p>基本语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取锁  </span><br>reentrantLock.lock();  <br><span class="hljs-keyword">try</span> &#123;  <br>    <span class="hljs-comment">// 临界区  </span><br>&#125; <span class="hljs-keyword">finally</span> &#123;  <br><span class="hljs-comment">// 释放锁  </span><br>reentrantLock.unlock();  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><h5 id="基本使用-2"><a href="#基本使用-2" class="headerlink" title="基本使用"></a>基本使用</h5><p>构造方法：<code>ReentrantLock lock = new ReentrantLock(true)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">(<span class="hljs-type">boolean</span> fair)</span> &#123;  <br>    sync = fair ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">FairSync</span>() : <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();  <br>&#125;<br><br><span class="hljs-comment">//ReentrantLock 默认是不公平的：</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">()</span> &#123;  <br>    sync = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();  <br>&#125;<br><br><span class="hljs-comment">//说明：公平锁一般没有必要，会降低并发度</span><br></code></pre></td></tr></table></figure><hr><h5 id="非公原理"><a href="#非公原理" class="headerlink" title="非公原理"></a>非公原理</h5><h6 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h6><p>NonfairSync 继承自 AQS</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;  <br>    sync.lock();  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>没有竞争：ExclusiveOwnerThread 属于 Thread-0，state 设置为 1</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// ReentrantLock.NonfairSync#lock  </span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">// 用 cas 尝试（仅尝试一次）将 state 从 0 改为 1, 如果成功表示【获得了独占锁】  </span><br>    <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))  <br>        <span class="hljs-comment">// 设置当前线程为独占线程  </span><br>        setExclusiveOwnerThread(Thread.currentThread());  <br>    <span class="hljs-keyword">else</span>  <br>        acquire(<span class="hljs-number">1</span>);<span class="hljs-comment">//失败进入  </span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>第一个竞争出现：Thread-1 执行，CAS 尝试将 state 由 0 改为 1，结果失败（第一次），进入 acquire 逻辑</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// AbstractQueuedSynchronizer#acquire  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;  <br>    <span class="hljs-comment">// tryAcquire 尝试获取锁失败时, 会调用 addWaiter 将当前线程封装成node入队，acquireQueued 阻塞当前线程，  </span><br>    <span class="hljs-comment">// acquireQueued 返回 true 表示挂起过程中线程被中断唤醒过，false 表示未被中断过  </span><br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))  <br>        <span class="hljs-comment">// 如果线程被中断了逻辑来到这，完成一次真正的打断效果  </span><br>        selfInterrupt();  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041851334.png"></p><ul><li><p>进入 tryAcquire 尝试获取锁逻辑，这时 state 已经是1，结果仍然失败（第二次），加锁成功有两种情况：</p><ul><li><p>当前 AQS 处于无锁状态</p></li><li><p>加锁线程就是当前线程，说明发生了锁重入</p></li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// ReentrantLock.NonfairSync#tryAcquire  </span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;  <br>    <span class="hljs-keyword">return</span> nonfairTryAcquire(acquires);  <br>&#125;  <br><span class="hljs-comment">// 抢占成功返回 true，抢占失败返回 false  </span><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">nonfairTryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;  <br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();  <br>    <span class="hljs-comment">// state 值  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();  <br>    <span class="hljs-comment">// 条件成立说明当前处于【无锁状态】  </span><br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;  <br>        <span class="hljs-comment">//如果还没有获得锁，尝试用cas获得，这里体现非公平性: 不去检查 AQS 队列是否有阻塞线程直接获取锁          </span><br>    <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;  <br>            <span class="hljs-comment">// 获取锁成功设置当前线程为独占锁线程。  </span><br>            setExclusiveOwnerThread(current);  <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>         &#125;      <br>&#125;      <br>   <span class="hljs-comment">// 如果已经有线程获得了锁, 独占锁线程还是当前线程, 表示【发生了锁重入】  </span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;  <br>        <span class="hljs-comment">// 更新锁重入的值  </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c + acquires;  <br>        <span class="hljs-comment">// 越界判断，当重入的深度很深时，会导致 nextc &lt; 0，int值达到最大之后再 + 1 变负数  </span><br>        <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow  </span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);  <br>        <span class="hljs-comment">// 更新 state 的值，这里不使用 cas 是因为当前线程正在持有锁，所以这里的操作相当于在一个管程内  </span><br>        setState(nextc);  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    &#125;  <br>    <span class="hljs-comment">// 获取失败  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>接下来进入 addWaiter 逻辑，构造 Node 队列（不是阻塞队列），前置条件是当前线程获取锁失败，说明有线程占用了锁</p><ul><li><p>图中黄色三角表示该 Node 的 waitStatus 状态，其中 0 为默认<strong>正常状态</strong></p></li><li><p>Node 的创建是懒惰的，其中第一个 Node 称为 <strong>Dummy（哑元）或哨兵</strong>，用来占位，并不关联线程</p></li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// AbstractQueuedSynchronizer#addWaiter，返回当前线程的 node 节点  </span><br><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">addWaiter</span><span class="hljs-params">(Node mode)</span> &#123;  <br>    <span class="hljs-comment">// 将当前线程关联到一个 Node 对象上, 模式为独占模式     </span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Thread.currentThread(), mode);  <br>    <span class="hljs-type">Node</span> <span class="hljs-variable">pred</span> <span class="hljs-operator">=</span> tail;  <br>    <span class="hljs-comment">// 快速入队，如果 tail 不为 null，说明存在队列  </span><br>    <span class="hljs-keyword">if</span> (pred != <span class="hljs-literal">null</span>) &#123;  <br>        <span class="hljs-comment">// 将当前节点的前驱节点指向 尾节点  </span><br>        node.prev = pred;  <br>        <span class="hljs-comment">// 通过 cas 将 Node 对象加入 AQS 队列，成为尾节点，【尾插法】  </span><br>        <span class="hljs-keyword">if</span> (compareAndSetTail(pred, node)) &#123;  <br>            pred.next = node;<span class="hljs-comment">// 双向链表  </span><br>            <span class="hljs-keyword">return</span> node;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-comment">// 初始时队列为空，或者 CAS 失败进入这里  </span><br>    enq(node);  <br>    <span class="hljs-keyword">return</span> node;  <br>&#125;<br><br><span class="hljs-comment">// AbstractQueuedSynchronizer#enq  </span><br><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">enq</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node)</span> &#123;  <br>    <span class="hljs-comment">// 自旋入队，必须入队成功才结束循环  </span><br>    <span class="hljs-keyword">for</span> (;;) &#123;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail;  <br>        <span class="hljs-comment">// 说明当前锁被占用，且当前线程可能是【第一个获取锁失败】的线程，【还没有建立队列】  </span><br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-comment">// 设置一个【哑元节点】，头尾指针都指向该节点  </span><br>            <span class="hljs-keyword">if</span> (compareAndSetHead(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>()))  <br>                tail = head;  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            <span class="hljs-comment">// 自旋到这，普通入队方式，首先赋值尾节点的前驱节点【尾插法】  </span><br>            node.prev = t;  <br>            <span class="hljs-comment">// 【在设置完尾节点后，才更新的原始尾节点的后继节点，所以此时从前往后遍历会丢失尾节点】  </span><br>            <span class="hljs-keyword">if</span> (compareAndSetTail(t, node)) &#123;  <br>                <span class="hljs-comment">//【此时 t.next  = null，并且这里已经 CAS 结束，线程并不是安全的】  </span><br>                t.next = node;  <br>                <span class="hljs-keyword">return</span> t;<span class="hljs-comment">// 返回当前 node 的前驱节点  </span><br>            &#125;  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041853324.png">  </p></li><li><p>线程节点加入队列成功，进入 AbstractQueuedSynchronizer#acquireQueued 逻辑阻塞线程</p><ul><li><p>acquireQueued 会在一个自旋中不断尝试获得锁，失败后进入 park 阻塞</p></li><li><p>如果当前线程是在 head 节点后，会再次 tryAcquire 尝试获取锁，state 仍为 1 则失败（第三次）</p></li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-type">int</span> arg)</span> &#123;  <br>    <span class="hljs-comment">// true 表示当前线程抢占锁失败，false 表示成功  </span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-comment">// 中断标记，表示当前线程是否被中断  </span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;  <br>        <span class="hljs-keyword">for</span> (;;) &#123;  <br>            <span class="hljs-comment">// 获得当前线程节点的前驱节点  </span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();  <br>            <span class="hljs-comment">// 前驱节点是 head, FIFO 队列的特性表示轮到当前线程可以去获取锁  </span><br>            <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;  <br>                <span class="hljs-comment">// 获取成功, 设置当前线程自己的 node 为 head  </span><br>                setHead(node);  <br>                p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC  </span><br>                <span class="hljs-comment">// 表示抢占锁成功  </span><br>                failed = <span class="hljs-literal">false</span>;  <br>                <span class="hljs-comment">// 返回当前线程是否被中断  </span><br>                <span class="hljs-keyword">return</span> interrupted;  <br>            &#125;  <br>            <span class="hljs-comment">// 判断是否应当 park，返回 false 后需要新一轮的循环，返回 true 进入条件二阻塞线程  </span><br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())  <br>                <span class="hljs-comment">// 条件二返回结果是当前线程是否被打断，没有被打断返回 false 不进入这里的逻辑  </span><br>                <span class="hljs-comment">// 【就算被打断了，也会继续循环，并不会返回】  </span><br>                interrupted = <span class="hljs-literal">true</span>;  <br>        &#125;  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        <span class="hljs-comment">// 【可打断模式下才会进入该逻辑】  </span><br>        <span class="hljs-keyword">if</span> (failed)  <br>            cancelAcquire(node);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>进入 shouldParkAfterFailedAcquire 逻辑，<strong>将前驱 node 的 waitStatus 改为 -1</strong>，返回 false；waitStatus 为 -1 的节点用来唤醒下一个节点</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">shouldParkAfterFailedAcquire</span><span class="hljs-params">(Node pred, Node node)</span> &#123;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> pred.waitStatus;  <br>    <span class="hljs-comment">// 表示前置节点是个可以唤醒当前节点的节点，返回 true  </span><br>    <span class="hljs-keyword">if</span> (ws == Node.SIGNAL)  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    <span class="hljs-comment">// 前置节点的状态处于取消状态，需要【删除前面所有取消的节点】, 返回到外层循环重试  </span><br>    <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span>) &#123;  <br>        <span class="hljs-keyword">do</span> &#123;  <br>            node.prev = pred = pred.prev;  <br>        &#125; <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>);  <br>        <span class="hljs-comment">// 获取到非取消的节点，连接上当前节点  </span><br>        pred.next = node;  <br>    <span class="hljs-comment">// 默认情况下 node 的 waitStatus 是 0，进入这里的逻辑  </span><br>    &#125; <span class="hljs-keyword">else</span> &#123;  <br>        <span class="hljs-comment">// 【设置上一个节点状态为 Node.SIGNAL】，返回外层循环重试  </span><br>        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);  <br>    &#125;  <br>    <span class="hljs-comment">// 返回不应该 park，再次尝试一次  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>shouldParkAfterFailedAcquire 执行完毕回到 acquireQueued ，再次 tryAcquire 尝试获取锁，这时 state 仍为 1 获取失败（第四次）</p></li><li><p>当再次进入 shouldParkAfterFailedAcquire 时，这时其前驱 node 的 waitStatus 已经是 -1 了，返回 true</p></li><li><p>进入 parkAndCheckInterrupt， Thread-1 park（灰色表示）</p></li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">parkAndCheckInterrupt</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">// 阻塞当前线程，如果打断标记已经是 true, 则 park 会失效  </span><br>    LockSupport.park(<span class="hljs-built_in">this</span>);  <br>    <span class="hljs-comment">// 判断当前线程是否被打断，清除打断标记  </span><br>    <span class="hljs-keyword">return</span> Thread.interrupted();  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>再有多个线程经历竞争失败后：</p><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041853649.png"></p></li></ul><hr><h6 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h6><p>ReentrantLock#unlock：释放锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;  <br>    sync.release(<span class="hljs-number">1</span>);  <br>&#125;<br></code></pre></td></tr></table></figure><p>Thread-0 释放锁，进入 release 流程</p><ul><li><p>进入 tryRelease，设置 exclusiveOwnerThread 为 null，state &#x3D; 0</p></li><li><p>当前队列不为 null，并且 head 的 waitStatus &#x3D; -1，进入 unparkSuccessor</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// AbstractQueuedSynchronizer#release  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;  <br>    <span class="hljs-comment">// 尝试释放锁，tryRelease 返回 true 表示当前线程已经【完全释放锁，重入的释放了】  </span><br>    <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;  <br>        <span class="hljs-comment">// 队列头节点  </span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;  <br>        <span class="hljs-comment">// 头节点什么时候是空？没有发生锁竞争，没有竞争线程创建哑元节点  </span><br>        <span class="hljs-comment">// 条件成立说明阻塞队列有等待线程，需要唤醒 head 节点后面的线程  </span><br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)  <br>            unparkSuccessor(h);  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    &#125;      <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>  &#x2F;&#x2F; ReentrantLock.Sync#tryRelease  </p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;  <br>    <span class="hljs-comment">// 减去释放的值，可能重入  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState() - releases;  <br>    <span class="hljs-comment">// 如果当前线程不是持有锁的线程直接报错  </span><br>    <span class="hljs-keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())  <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();  <br>    <span class="hljs-comment">// 是否已经完全释放锁  </span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">free</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;  <br>    <span class="hljs-comment">// 支持锁重入, 只有 state 减为 0, 才完全释放锁成功  </span><br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;  <br>        free = <span class="hljs-literal">true</span>;  <br>        setExclusiveOwnerThread(<span class="hljs-literal">null</span>);  <br>    &#125;  <br>    <span class="hljs-comment">// 当前线程就是持有锁线程，所以可以直接更新锁，不需要使用 CAS  </span><br>    setState(c);  <br>    <span class="hljs-keyword">return</span> free;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>进入 AbstractQueuedSynchronizer#unparkSuccessor 方法，唤醒当前节点的后继节点</p><ul><li><p>找到队列中距离 head 最近的一个没取消的 Node，unpark 恢复其运行，本例中即为 Thread-1</p></li><li><p>回到 Thread-1 的 acquireQueued 流程</p></li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unparkSuccessor</span><span class="hljs-params">(Node node)</span> &#123;  <br>    <span class="hljs-comment">// 当前节点的状态  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> node.waitStatus;      <br>    <span class="hljs-keyword">if</span> (ws &lt; <span class="hljs-number">0</span>)          <br>        <span class="hljs-comment">// 【尝试重置状态为 0】，因为当前节点要完成对后续节点的唤醒任务了，不需要 -1 了  </span><br>        compareAndSetWaitStatus(node, ws, <span class="hljs-number">0</span>);      <br>    <span class="hljs-comment">// 找到需要 unpark 的节点，当前节点的下一个      </span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;      <br>    <span class="hljs-comment">// 已取消的节点不能唤醒，需要找到距离头节点最近的非取消的节点  </span><br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.waitStatus &gt; <span class="hljs-number">0</span>) &#123;  <br>        s = <span class="hljs-literal">null</span>;  <br>        <span class="hljs-comment">// AQS 队列【从后至前】找需要 unpark 的节点，直到 t == 当前的 node 为止，找不到就不唤醒了  </span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail; t != <span class="hljs-literal">null</span> &amp;&amp; t != node; t = t.prev)  <br>            <span class="hljs-comment">// 说明当前线程状态需要被唤醒  </span><br>            <span class="hljs-keyword">if</span> (t.waitStatus &lt;= <span class="hljs-number">0</span>)  <br>                <span class="hljs-comment">// 置换引用  </span><br>                s = t;  <br>    &#125;  <br>    <span class="hljs-comment">// 【找到合适的可以被唤醒的 node，则唤醒线程】  </span><br>    <span class="hljs-keyword">if</span> (s != <span class="hljs-literal">null</span>)  <br>        LockSupport.unpark(s.thread);  <br>&#125;<br></code></pre></td></tr></table></figure><p>  <strong>从后向前的唤醒的原因</strong>：enq 方法中，节点是尾插法，首先赋值的是尾节点的前驱节点，此时前驱节点的 next 并没有指向尾节点，从前遍历会丢失尾节点  </p></li><li><p>唤醒的线程会从 park 位置开始执行，如果加锁成功（没有竞争），会设置</p><ul><li><p>exclusiveOwnerThread 为 Thread-1，state &#x3D; 1</p></li><li><p>head 指向刚刚 Thread-1 所在的 Node，该 Node 会清空 Thread</p></li><li><p>原本的 head 因为从链表断开，而可被垃圾回收（图中有错误，原来的头节点的 waitStatus 被改为 0 了）</p></li></ul><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041855500.png">  </p></li><li><p>如果这时有其它线程来竞争<strong>（非公平）</strong>，例如这时有 Thread-4 来了并抢占了锁</p><ul><li><p>Thread-4 被设置为 exclusiveOwnerThread，state &#x3D; 1</p></li><li><p>Thread-1 再次进入 acquireQueued 流程，获取锁失败，重新进入 park 阻塞</p></li></ul><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041856156.png"></p></li></ul><hr><h5 id="公平原理"><a href="#公平原理" class="headerlink" title="公平原理"></a>公平原理</h5><p>与非公平锁主要区别在于 tryAcquire 方法：先检查 AQS 队列中是否有前驱节点，没有才去 CAS 竞争</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> -<span class="hljs-number">3000897897090466540L</span>;  <br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;  <br>        acquire(<span class="hljs-number">1</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;  <br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();  <br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;  <br>            <span class="hljs-comment">// 先检查 AQS 队列中是否有前驱节点, 没有(false)才去竞争  </span><br>            <span class="hljs-keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;  <br>                compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;  <br>                setExclusiveOwnerThread(current);  <br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-comment">// 锁重入  </span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>    &#125;  <br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasQueuedPredecessors</span><span class="hljs-params">()</span> &#123;      <br>    <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail;  <br>    <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;  <br>    Node s;      <br>    <span class="hljs-comment">// 头尾指向一个节点，链表为空，返回false  </span><br>    <span class="hljs-keyword">return</span> h != t &amp;&amp;  <br>        <span class="hljs-comment">// 头尾之间有节点，判断头节点的下一个是不是空  </span><br>        <span class="hljs-comment">// 不是空进入最后的判断，第二个节点的线程是否是本线程，不是返回 true，表示当前节点有前驱节点  </span><br>        ((s = h.next) == <span class="hljs-literal">null</span> || s.thread != Thread.currentThread());  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h4><p>可重入是指同一个线程如果首次获得了这把锁，那么它是这把锁的拥有者，因此有权利再次获取这把锁，如果不可重入锁，那么第二次获得锁时，自己也会被锁挡住，直接造成死锁</p><p>源码解析参考：<code>nonfairTryAcquire(int acquires))</code> 和 <code>tryRelease(int releases)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">static</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    method1();  <br>&#125;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span> &#123;  <br>    lock.lock();  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; execute method1&quot;</span>);  <br>        method2();  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        lock.unlock();  <br>    &#125;  <br>&#125;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span> &#123;  <br>    lock.lock();  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; execute method2&quot;</span>);  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        lock.unlock();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>在 Lock 方法加两把锁会是什么情况呢？</p><ul><li><p>加锁两次解锁两次：正常执行</p></li><li><p>加锁两次解锁一次：程序直接卡死，线程不能出来，也就说明<strong>申请几把锁，最后需要解除几把锁</strong></p></li><li><p>加锁一次解锁两次：运行程序会直接报错</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getLock</span><span class="hljs-params">()</span> &#123;  <br>    lock.lock();  <br>    lock.lock();  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t get Lock&quot;</span>);  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        lock.unlock();  <br>        <span class="hljs-comment">//lock.unlock();  </span><br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="可打断"><a href="#可打断" class="headerlink" title="可打断"></a>可打断</h4><h5 id="基本使用-3"><a href="#基本使用-3" class="headerlink" title="基本使用"></a>基本使用</h5><p><code>public void lockInterruptibly()</code>：获得可打断的锁</p><ul><li><p>如果没有竞争此方法就会获取 lock 对象锁</p></li><li><p>如果有竞争就进入阻塞队列，可以被其他线程用 interrupt 打断</p></li></ul><p>注意：如果是不可中断模式，那么即使使用了 interrupt 也不会让等待状态中的线程中断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;      <br>    <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();      <br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;          <br>        <span class="hljs-keyword">try</span> &#123;              <br>            System.out.println(<span class="hljs-string">&quot;尝试获取锁&quot;</span>);              <br>            lock.lockInterruptibly();          <br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;              <br>            System.out.println(<span class="hljs-string">&quot;没有获取到锁，被打断，直接返回&quot;</span>);              <br>            <span class="hljs-keyword">return</span>;          <br>        &#125;          <br>        <span class="hljs-keyword">try</span> &#123;              <br>            System.out.println(<span class="hljs-string">&quot;获取到锁&quot;</span>);          <br>        &#125; <span class="hljs-keyword">finally</span> &#123;              <br>            lock.unlock();          <br>        &#125;      <br>    &#125;, <span class="hljs-string">&quot;t1&quot;</span>);      <br>    lock.lock();      <br>    t1.start();      <br>    Thread.sleep(<span class="hljs-number">2000</span>);      <br>    System.out.println(<span class="hljs-string">&quot;主线程进行打断锁&quot;</span>);      <br>    t1.interrupt();  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="实现原理-2"><a href="#实现原理-2" class="headerlink" title="实现原理"></a>实现原理</h5><ul><li><p>不可打断模式：即使它被打断，仍会驻留在 AQS 阻塞队列中，一直要<strong>等到获得锁后才能得知自己被打断</strong>了</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;      <br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<span class="hljs-comment">//阻塞等待          </span><br>        <span class="hljs-comment">// 如果acquireQueued返回true，打断状态 interrupted = true          </span><br>        selfInterrupt();  <br>&#125;  <br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">selfInterrupt</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">// 知道自己被打断了，需要重新产生一次中断完成中断效果  </span><br>    Thread.currentThread().interrupt();  <br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-type">int</span> arg)</span> &#123;      <br>    <span class="hljs-keyword">try</span> &#123;          <br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;          <br>        <span class="hljs-keyword">for</span> (;;) &#123;              <br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();              <br>            <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;                  <br>                setHead(node);                  <br>                p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC                  </span><br>                failed = <span class="hljs-literal">false</span>;                  <br>                <span class="hljs-comment">// 还是需要获得锁后, 才能返回打断状态  </span><br>                <span class="hljs-keyword">return</span> interrupted;              <br>            &#125;              <br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())&#123;  <br>                <span class="hljs-comment">// 条件二中判断当前线程是否被打断，被打断返回true，设置中断标记为 true，【获取锁后返回】  </span><br>                interrupted = <span class="hljs-literal">true</span>;    <br>            &#125;                    <br>        &#125;   <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        <span class="hljs-keyword">if</span> (failed)  <br>            cancelAcquire(node);  <br>    &#125;  <br>&#125;  <br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">parkAndCheckInterrupt</span><span class="hljs-params">()</span> &#123;      <br>     <span class="hljs-comment">// 阻塞当前线程，如果打断标记已经是 true, 则 park 会失效  </span><br>     LockSupport.park(<span class="hljs-built_in">this</span>);      <br>     <span class="hljs-comment">// 判断当前线程是否被打断，清除打断标记，被打断返回true  </span><br>     <span class="hljs-keyword">return</span> Thread.interrupted();  <br> &#125;<br></code></pre></td></tr></table></figure></li><li><p>可打断模式：AbstractQueuedSynchronizer#acquireInterruptibly，<strong>被打断后会直接抛出异常</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;      <br>    sync.acquireInterruptibly(<span class="hljs-number">1</span>);  <br>&#125;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireInterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;  <br>    <span class="hljs-comment">// 被其他线程打断了直接返回 false  </span><br>    <span class="hljs-keyword">if</span> (Thread.interrupted())  <br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();  <br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg))  <br>        <span class="hljs-comment">// 没获取到锁，进入这里  </span><br>        doAcquireInterruptibly(arg);  <br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAcquireInterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>    <span class="hljs-comment">// 返回封装当前线程的节点  </span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addWaiter(Node.EXCLUSIVE);  <br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-keyword">for</span> (;;) &#123;  <br>            <span class="hljs-comment">//...  </span><br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())  <br>                <span class="hljs-comment">// 【在 park 过程中如果被 interrupt 会抛出异常】, 而不会再次进入循环获取锁后才完成打断效果  </span><br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();  <br>        &#125;      <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        <span class="hljs-comment">// 抛出异常前会进入这里  </span><br>        <span class="hljs-keyword">if</span> (failed)  <br>            <span class="hljs-comment">// 取消当前线程的节点  </span><br>            cancelAcquire(node);  <br>    &#125;  <br>&#125;<br><br><span class="hljs-comment">// 取消节点出队的逻辑  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cancelAcquire</span><span class="hljs-params">(Node node)</span> &#123;  <br>    <span class="hljs-comment">// 判空  </span><br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>)  <br>        <span class="hljs-keyword">return</span>;  <br><span class="hljs-comment">// 把当前节点封装的 Thread 置为空  </span><br>    node.thread = <span class="hljs-literal">null</span>;  <br><span class="hljs-comment">// 获取当前取消的 node 的前驱节点  </span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">pred</span> <span class="hljs-operator">=</span> node.prev;  <br>    <span class="hljs-comment">// 前驱节点也被取消了，循环找到前面最近的没被取消的节点  </span><br>    <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>)  <br>        node.prev = pred = pred.prev;  <br>      <br><span class="hljs-comment">// 获取前驱节点的后继节点，可能是当前 node，也可能是 waitStatus &gt; 0 的节点  </span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">predNext</span> <span class="hljs-operator">=</span> pred.next;  <br>      <br><span class="hljs-comment">// 把当前节点的状态设置为 【取消状态 1】  </span><br>    node.waitStatus = Node.CANCELLED;  <br>      <br><span class="hljs-comment">// 条件成立说明当前节点是尾节点，把当前节点的前驱节点设置为尾节点  </span><br>    <span class="hljs-keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;  <br>        <span class="hljs-comment">// 把前驱节点的后继节点置空，这里直接把所有的取消节点出队  </span><br>        compareAndSetNext(pred, predNext, <span class="hljs-literal">null</span>);  <br>    &#125; <span class="hljs-keyword">else</span> &#123;  <br>        <span class="hljs-comment">// 说明当前节点不是 tail 节点  </span><br>        <span class="hljs-type">int</span> ws;  <br>        <span class="hljs-comment">// 条件一成立说明当前节点不是 head.next 节点  </span><br>        <span class="hljs-keyword">if</span> (pred != head &amp;&amp;  <br>            <span class="hljs-comment">// 判断前驱节点的状态是不是 -1，不成立说明前驱状态可能是 0 或者刚被其他线程取消排队了  </span><br>            ((ws = pred.waitStatus) == Node.SIGNAL ||  <br>             <span class="hljs-comment">// 如果状态不是 -1，设置前驱节点的状态为 -1  </span><br>             (ws &lt;= <span class="hljs-number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;  <br>            <span class="hljs-comment">// 前驱节点的线程不为null  </span><br>            pred.thread != <span class="hljs-literal">null</span>) &#123;  <br>              <br>            <span class="hljs-type">Node</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> node.next;  <br>            <span class="hljs-comment">// 当前节点的后继节点是正常节点  </span><br>            <span class="hljs-keyword">if</span> (next != <span class="hljs-literal">null</span> &amp;&amp; next.waitStatus &lt;= <span class="hljs-number">0</span>)  <br>                <span class="hljs-comment">// 把 前驱节点的后继节点 设置为 当前节点的后继节点，【从队列中删除了当前节点】  </span><br>                compareAndSetNext(pred, predNext, next);  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            <span class="hljs-comment">// 当前节点是 head.next 节点，唤醒当前节点的后继节点  </span><br>            unparkSuccessor(node);  <br>        &#125;  <br>        node.next = node; <span class="hljs-comment">// help GC  </span><br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h4 id="锁超时"><a href="#锁超时" class="headerlink" title="锁超时"></a>锁超时</h4><h5 id="基本使用-4"><a href="#基本使用-4" class="headerlink" title="基本使用"></a>基本使用</h5><p><code>public boolean tryLock()</code>：尝试获取锁，获取到返回 true，获取不到直接放弃，不进入阻塞队列</p><p><code>public boolean tryLock(long timeout, TimeUnit unit)</code>：在给定时间内获取锁，获取不到就退出</p><p>注意：tryLock 期间也可以被打断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();  <br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            <span class="hljs-keyword">if</span> (!lock.tryLock(<span class="hljs-number">2</span>, TimeUnit.SECONDS)) &#123;  <br>                System.out.println(<span class="hljs-string">&quot;获取不到锁&quot;</span>);  <br>                <span class="hljs-keyword">return</span>;  <br>            &#125;  <br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>            System.out.println(<span class="hljs-string">&quot;被打断，获取不到锁&quot;</span>);  <br>            <span class="hljs-keyword">return</span>;  <br>        &#125;  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            log.debug(<span class="hljs-string">&quot;获取到锁&quot;</span>);  <br>        &#125; <span class="hljs-keyword">finally</span> &#123;  <br>            lock.unlock();  <br>        &#125;  <br>    &#125;, <span class="hljs-string">&quot;t1&quot;</span>);  <br>    lock.lock();  <br>    System.out.println(<span class="hljs-string">&quot;主线程获取到锁&quot;</span>);  <br>    t1.start();  <br>      <br>    Thread.sleep(<span class="hljs-number">1000</span>);  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;主线程释放了锁&quot;</span>);  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        lock.unlock();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="实现原理-3"><a href="#实现原理-3" class="headerlink" title="实现原理"></a>实现原理</h5><ul><li><p>成员变量：指定超时限制的阈值，小于该值的线程不会被挂起</p><p>  <code>static final long spinForTimeoutThreshold = 1000L;</code></p><p>  超时时间设置的小于该值，就会被禁止挂起，因为阻塞在唤醒的成本太高，不如选择自旋空转</p></li><li><p>tryLock()</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span> &#123;     <br>    <span class="hljs-comment">// 只尝试一次  </span><br>    <span class="hljs-keyword">return</span> sync.nonfairTryAcquire(<span class="hljs-number">1</span>);  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>tryLock(long timeout, TimeUnit unit)</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquireNanos</span><span class="hljs-params">(<span class="hljs-type">int</span> arg, <span class="hljs-type">long</span> nanosTimeout)</span> &#123;  <br>    <span class="hljs-keyword">if</span> (Thread.interrupted())          <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();      <br>    <span class="hljs-comment">// tryAcquire 尝试一次  </span><br>    <span class="hljs-keyword">return</span> tryAcquire(arg) || doAcquireNanos(arg, nanosTimeout);  <br>&#125;  <br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;      <br>    <span class="hljs-keyword">return</span> nonfairTryAcquire(acquires);  <br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">doAcquireNanos</span><span class="hljs-params">(<span class="hljs-type">int</span> arg, <span class="hljs-type">long</span> nanosTimeout)</span> &#123;      <br>    <span class="hljs-keyword">if</span> (nanosTimeout &lt;= <span class="hljs-number">0L</span>)  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>    <span class="hljs-comment">// 获取最后期限的时间戳  </span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> System.nanoTime() + nanosTimeout;  <br>    <span class="hljs-comment">//...  </span><br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-keyword">for</span> (;;) &#123;  <br>            <span class="hljs-comment">//...  </span><br>            <span class="hljs-comment">// 计算还需等待的时间  </span><br>            nanosTimeout = deadline - System.nanoTime();  <br>            <span class="hljs-keyword">if</span> (nanosTimeout &lt;= <span class="hljs-number">0L</span>)<span class="hljs-comment">//时间已到       </span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;  <br>                <span class="hljs-comment">// 如果 nanosTimeout 大于该值，才有阻塞的意义，否则直接自旋会好点  </span><br>                nanosTimeout &gt; spinForTimeoutThreshold)  <br>                LockSupport.parkNanos(<span class="hljs-built_in">this</span>, nanosTimeout);  <br>            <span class="hljs-comment">// 【被打断会报异常】  </span><br>            <span class="hljs-keyword">if</span> (Thread.interrupted())  <br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();  <br>        &#125;      <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h5 id="哲学家就餐"><a href="#哲学家就餐" class="headerlink" title="哲学家就餐"></a>哲学家就餐</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-string">&quot;1&quot;</span>);<span class="hljs-comment">//...  </span><br>    <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-string">&quot;5&quot;</span>);  <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;苏格拉底&quot;</span>, c1, c2).start();  <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;柏拉图&quot;</span>, c2, c3).start();  <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;亚里士多德&quot;</span>, c3, c4).start();  <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;赫拉克利特&quot;</span>, c4, c5).start();      <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;阿基米德&quot;</span>, c5, c1).start();  <br>&#125;  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Philosopher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;  <br>    Chopstick left;  <br>    Chopstick right;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;  <br>            <span class="hljs-comment">// 尝试获得左手筷子  </span><br>            <span class="hljs-keyword">if</span> (left.tryLock()) &#123;  <br>                <span class="hljs-keyword">try</span> &#123;  <br>                    <span class="hljs-comment">// 尝试获得右手筷子  </span><br>                    <span class="hljs-keyword">if</span> (right.tryLock()) &#123;  <br>                        <span class="hljs-keyword">try</span> &#123;  <br>                            System.out.println(<span class="hljs-string">&quot;eating...&quot;</span>);  <br>                            Thread.sleep(<span class="hljs-number">1000</span>);  <br>                        &#125; <span class="hljs-keyword">finally</span> &#123;  <br>                            right.unlock();  <br>                        &#125;  <br>                    &#125;  <br>                &#125; <span class="hljs-keyword">finally</span> &#123;  <br>                    left.unlock();  <br>                &#125;  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>&#125;  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Chopstick</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ReentrantLock</span> &#123;  <br>    String name;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Chopstick</span><span class="hljs-params">(String name)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.name = name;  <br>    &#125;  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;筷子&#123;&quot;</span> + name + <span class="hljs-string">&#x27;&#125;&#x27;</span>;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><h5 id="基本使用-5"><a href="#基本使用-5" class="headerlink" title="基本使用"></a>基本使用</h5><p>synchronized 的条件变量，是当条件不满足时进入 WaitSet 等待；ReentrantLock 的条件变量比 synchronized 强大之处在于支持多个条件变量</p><p>ReentrantLock 类获取 Condition 对象：<code>public Condition newCondition()</code></p><p>Condition 类 API：</p><ul><li><p><code>void await()</code>：当前线程从运行状态进入等待状态，释放锁</p></li><li><p><code>void signal()</code>：唤醒一个等待在 Condition 上的线程，但是必须获得与该 Condition 相关的锁</p></li></ul><p>使用流程：</p><ul><li><p><strong>await &#x2F; signal 前需要获得锁</strong></p></li><li><p>await 执行后，会释放锁进入 ConditionObject 等待</p></li><li><p>await 的线程被唤醒去重新竞争 lock 锁</p></li><li><p><strong>线程在条件队列被打断会抛出中断异常</strong></p></li><li><p>竞争 lock 锁成功后，从 await 后继续执行</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;      <br>    <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();  <br>    <span class="hljs-comment">//创建一个新的条件变量  </span><br>    <span class="hljs-type">Condition</span> <span class="hljs-variable">condition1</span> <span class="hljs-operator">=</span> lock.newCondition();  <br>    <span class="hljs-type">Condition</span> <span class="hljs-variable">condition2</span> <span class="hljs-operator">=</span> lock.newCondition();  <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            lock.lock();  <br>            System.out.println(<span class="hljs-string">&quot;进入等待&quot;</span>);  <br>            <span class="hljs-comment">//进入休息室等待  </span><br>            condition1.await();  <br>            System.out.println(<span class="hljs-string">&quot;被唤醒了&quot;</span>);  <br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>            e.printStackTrace();  <br>        &#125; <span class="hljs-keyword">finally</span> &#123;  <br>            lock.unlock();  <br>        &#125;      <br>    &#125;).start();  <br>    Thread.sleep(<span class="hljs-number">1000</span>);  <br>    <span class="hljs-comment">//叫醒  </span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>        <span class="hljs-keyword">try</span> &#123;              <br>            lock.lock();  <br>            <span class="hljs-comment">//唤醒  </span><br>            condition2.signal();  <br>        &#125; <span class="hljs-keyword">finally</span> &#123;  <br>            lock.unlock();  <br>        &#125;  <br>    &#125;).start();  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="实现原理-4"><a href="#实现原理-4" class="headerlink" title="实现原理"></a>实现原理</h5><h6 id="await"><a href="#await" class="headerlink" title="await"></a>await</h6><p>总体流程是将 await 线程包装成 node 节点放入 ConditionObject 的条件队列，如果被唤醒就将 node 转移到 AQS 的执行阻塞队列，等待获取锁，<strong>每个 Condition 对象都包含一个等待队列</strong></p><ul><li><p>开始 Thread-0 持有锁，调用 await，线程进入 ConditionObject 等待，直到被唤醒或打断，调用 await 方法的线程都是持锁状态的，所以说逻辑里<strong>不存在并发</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>     <span class="hljs-comment">// 判断当前线程是否是中断状态，是就直接给个中断异常  </span><br>    <span class="hljs-keyword">if</span> (Thread.interrupted())  <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();  <br>    <span class="hljs-comment">// 将调用 await 的线程包装成 Node，添加到条件队列并返回  </span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addConditionWaiter();  <br>    <span class="hljs-comment">// 完全释放节点持有的锁，因为其他线程唤醒当前线程的前提是【持有锁】  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> fullyRelease(node);  <br>      <br>    <span class="hljs-comment">// 设置打断模式为没有被打断，状态码为 0  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">interruptMode</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br>      <br>    <span class="hljs-comment">// 如果该节点还没有转移至 AQS 阻塞队列, park 阻塞，等待进入阻塞队列  </span><br>    <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;  <br>        LockSupport.park(<span class="hljs-built_in">this</span>);  <br>        <span class="hljs-comment">// 如果被打断，退出等待队列，对应的 node 【也会被迁移到阻塞队列】尾部，状态设置为 0  </span><br>        <span class="hljs-keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number">0</span>)  <br>            <span class="hljs-keyword">break</span>;  <br>    &#125;  <br>    <span class="hljs-comment">// 逻辑到这说明当前线程退出等待队列，进入【阻塞队列】  </span><br>      <br>    <span class="hljs-comment">// 尝试枪锁，释放了多少锁就【重新获取多少锁】，获取锁成功判断打断模式  </span><br>    <span class="hljs-keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)  <br>        interruptMode = REINTERRUPT;  <br>      <br>    <span class="hljs-comment">// node 在条件队列时 如果被外部线程中断唤醒，会加入到阻塞队列，但是并未设 nextWaiter = null  </span><br>    <span class="hljs-keyword">if</span> (node.nextWaiter != <span class="hljs-literal">null</span>)  <br>        <span class="hljs-comment">// 清理条件队列内所有已取消的 Node  </span><br>        unlinkCancelledWaiters();  <br>    <span class="hljs-comment">// 条件成立说明挂起期间发生过中断  </span><br>    <span class="hljs-keyword">if</span> (interruptMode != <span class="hljs-number">0</span>)  <br>        <span class="hljs-comment">// 应用打断模式  </span><br>        reportInterruptAfterWait(interruptMode);  <br>&#125;<br><br><span class="hljs-comment">// 打断模式 - 在退出等待时重新设置打断状态  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">REINTERRUPT</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;  <br><span class="hljs-comment">// 打断模式 - 在退出等待时抛出异常  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">THROW_IE</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041900663.png"></p></li><li><p><strong>创建新的 Node 状态为 -2（Node.CONDITION）</strong>，关联 Thread-0，加入等待队列尾部</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">addConditionWaiter</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">// 获取当前条件队列的尾节点的引用，保存到局部变量 t 中  </span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> lastWaiter;  <br>    <span class="hljs-comment">// 当前队列中不是空，并且节点的状态不是 CONDITION（-2），说明当前节点发生了中断  </span><br>    <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;  <br>        <span class="hljs-comment">// 清理条件队列内所有已取消的 Node  </span><br>        unlinkCancelledWaiters();  <br>        <span class="hljs-comment">// 清理完成重新获取 尾节点 的引用  </span><br>        t = lastWaiter;  <br>    &#125;  <br>    <span class="hljs-comment">// 创建一个关联当前线程的新 node, 设置状态为 CONDITION(-2)，添加至队列尾部  </span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Thread.currentThread(), Node.CONDITION);  <br>    <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>)  <br>        firstWaiter = node;<span class="hljs-comment">// 空队列直接放在队首【不用CAS因为执行线程是持锁线程，并发安全】  </span><br>    <span class="hljs-keyword">else</span>  <br>        t.nextWaiter = node;<span class="hljs-comment">// 非空队列队尾追加  </span><br>    lastWaiter = node;<span class="hljs-comment">// 更新队尾的引用  </span><br>    <span class="hljs-keyword">return</span> node;  <br>&#125;<br><br><span class="hljs-comment">// 清理条件队列内所有已取消（不是CONDITION）的 node，【链表删除的逻辑】  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlinkCancelledWaiters</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">// 从头节点开始遍历【FIFO】  </span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> firstWaiter;  <br>    <span class="hljs-comment">// 指向正常的 CONDITION 节点  </span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">trail</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;  <br>    <span class="hljs-comment">// 等待队列不空  </span><br>    <span class="hljs-keyword">while</span> (t != <span class="hljs-literal">null</span>) &#123;  <br>        <span class="hljs-comment">// 获取当前节点的后继节点  </span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> t.nextWaiter;  <br>        <span class="hljs-comment">// 判断 t 节点是不是 CONDITION 节点，条件队列内不是 CONDITION 就不是正常的  </span><br>        <span class="hljs-keyword">if</span> (t.waitStatus != Node.CONDITION) &#123;   <br>            <span class="hljs-comment">// 不是正常节点，需要 t 与下一个节点断开  </span><br>            t.nextWaiter = <span class="hljs-literal">null</span>;  <br>            <span class="hljs-comment">// 条件成立说明遍历到的节点还未碰到过正常节点  </span><br>            <span class="hljs-keyword">if</span> (trail == <span class="hljs-literal">null</span>)  <br>                <span class="hljs-comment">// 更新 firstWaiter 指针为下个节点  </span><br>                firstWaiter = next;  <br>            <span class="hljs-keyword">else</span>  <br>                <span class="hljs-comment">// 让上一个正常节点指向 当前取消节点的 下一个节点，【删除非正常的节点】  </span><br>                trail.nextWaiter = next;  <br>            <span class="hljs-comment">// t 是尾节点了，更新 lastWaiter 指向最后一个正常节点  </span><br>            <span class="hljs-keyword">if</span> (next == <span class="hljs-literal">null</span>)  <br>                lastWaiter = trail;  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            <span class="hljs-comment">// trail 指向的是正常节点   </span><br>            trail = t;  <br>        &#125;  <br>        <span class="hljs-comment">// 把 t.next 赋值给 t，循环遍历  </span><br>        t = next;   <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>接下来 Thread-0 进入 AQS 的 fullyRelease 流程，释放同步器上的锁</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// 线程可能重入，需要将 state 全部释放  </span><br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fullyRelease</span><span class="hljs-params">(Node node)</span> &#123;  <br>    <span class="hljs-comment">// 完全释放锁是否成功，false 代表成功  </span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-comment">// 获取当前线程所持有的 state 值总数  </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> getState();  <br>        <span class="hljs-comment">// release -&gt; tryRelease 解锁重入锁  </span><br>        <span class="hljs-keyword">if</span> (release(savedState)) &#123;  <br>            <span class="hljs-comment">// 释放成功  </span><br>            failed = <span class="hljs-literal">false</span>;  <br>            <span class="hljs-comment">// 返回解锁的深度  </span><br>            <span class="hljs-keyword">return</span> savedState;  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            <span class="hljs-comment">// 解锁失败抛出异常  </span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();  <br>        &#125;  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        <span class="hljs-comment">// 没有释放成功，将当前 node 设置为取消状态  </span><br>        <span class="hljs-keyword">if</span> (failed)  <br>            node.waitStatus = Node.CANCELLED;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>fullyRelease 中会 unpark AQS 队列中的下一个节点竞争锁，假设 Thread-1 竞争成功</p><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041901643.png"></p></li><li><p>Thread-0 进入 isOnSyncQueue 逻辑判断节点<strong>是否移动到阻塞队列</strong>，没有就 park 阻塞 Thread-0</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isOnSyncQueue</span><span class="hljs-params">(Node node)</span> &#123;  <br>    <span class="hljs-comment">// node 的状态是 CONDITION，signal 方法是先修改状态再迁移，所以前驱节点为空证明还【没有完成迁移】  </span><br>    <span class="hljs-keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="hljs-literal">null</span>)  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>    <span class="hljs-comment">// 说明当前节点已经成功入队到阻塞队列，且当前节点后面已经有其它 node，因为条件队列的 next 指针为 null  </span><br>    <span class="hljs-keyword">if</span> (node.next != <span class="hljs-literal">null</span>)  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br><span class="hljs-comment">// 说明【可能在阻塞队列，但是是尾节点】  </span><br>    <span class="hljs-comment">// 从阻塞队列的尾节点开始向前【遍历查找 node】，如果查找到返回 true，查找不到返回 false  </span><br>    <span class="hljs-keyword">return</span> findNodeFromTail(node);  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>await 线程 park 后如果被 unpark 或者被打断，都会进入 checkInterruptWhileWaiting 判断线程是否被打断：<strong>在条件队列被打断的线程需要抛出异常</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">checkInterruptWhileWaiting</span><span class="hljs-params">(Node node)</span> &#123;  <br>    <span class="hljs-comment">// Thread.interrupted() 返回当前线程中断标记位，并且重置当前标记位 为 false  </span><br>    <span class="hljs-comment">// 如果被中断了，根据是否在条件队列被中断的，设置中断状态码  </span><br>    <span class="hljs-keyword">return</span> Thread.interrupted() ?(transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) : <span class="hljs-number">0</span>;  <br>&#125;<br><br><span class="hljs-comment">// 这个方法只有在线程是被打断唤醒时才会调用  </span><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">transferAfterCancelledWait</span><span class="hljs-params">(Node node)</span> &#123;  <br>    <span class="hljs-comment">// 条件成立说明当前node一定是在条件队列内，因为 signal 迁移节点到阻塞队列时，会将节点的状态修改为 0  </span><br>    <span class="hljs-keyword">if</span> (compareAndSetWaitStatus(node, Node.CONDITION, <span class="hljs-number">0</span>)) &#123;  <br>        <span class="hljs-comment">// 把【中断唤醒的 node 加入到阻塞队列中】  </span><br>        enq(node);  <br>        <span class="hljs-comment">// 表示是在条件队列内被中断了，设置为 THROW_IE 为 -1  </span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//执行到这里的情况：  </span><br>    <span class="hljs-comment">//1.当前node已经被外部线程调用 signal 方法将其迁移到 阻塞队列 内了  </span><br>    <span class="hljs-comment">//2.当前node正在被外部线程调用 signal 方法将其迁移至 阻塞队列 进行中状态  </span><br>      <br>    <span class="hljs-comment">// 如果当前线程还没到阻塞队列，一直释放 CPU  </span><br>    <span class="hljs-keyword">while</span> (!isOnSyncQueue(node))  <br>        Thread.yield();  <br>  <br>    <span class="hljs-comment">// 表示当前节点被中断唤醒时不在条件队列了，设置为 REINTERRUPT 为 1  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>最后开始处理中断状态：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reportInterruptAfterWait</span><span class="hljs-params">(<span class="hljs-type">int</span> interruptMode)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>    <span class="hljs-comment">// 条件成立说明【在条件队列内发生过中断，此时 await 方法抛出中断异常】  </span><br>    <span class="hljs-keyword">if</span> (interruptMode == THROW_IE)  <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();  <br>  <br>    <span class="hljs-comment">// 条件成立说明【在条件队列外发生的中断，此时设置当前线程的中断标记位为 true】  </span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (interruptMode == REINTERRUPT)  <br>        <span class="hljs-comment">// 进行一次自己打断，产生中断的效果  </span><br>        selfInterrupt();  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h6 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h6><ul><li><p>假设 Thread-1 要来唤醒 Thread-0，进入 ConditionObject 的 doSignal 流程，<strong>取得等待队列中第一个 Node</strong>，即 Thread-0 所在 Node，必须持有锁才能唤醒, 因此 doSignal 内线程安全</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">signal</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">// 判断调用 signal 方法的线程是否是独占锁持有线程  </span><br>    <span class="hljs-keyword">if</span> (!isHeldExclusively())  <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();  <br>    <span class="hljs-comment">// 获取条件队列中第一个 Node  </span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> firstWaiter;  <br>    <span class="hljs-comment">// 不为空就将第该节点【迁移到阻塞队列】  </span><br>    <span class="hljs-keyword">if</span> (first != <span class="hljs-literal">null</span>)  <br>        doSignal(first);  <br>&#125;<br><br><span class="hljs-comment">// 唤醒 - 【将没取消的第一个节点转移至 AQS 队列尾部】  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSignal</span><span class="hljs-params">(Node first)</span> &#123;  <br>    <span class="hljs-keyword">do</span> &#123;  <br>        <span class="hljs-comment">// 成立说明当前节点的下一个节点是 null，当前节点是尾节点了，队列中只有当前一个节点了  </span><br>        <span class="hljs-keyword">if</span> ((firstWaiter = first.nextWaiter) == <span class="hljs-literal">null</span>)  <br>            lastWaiter = <span class="hljs-literal">null</span>;  <br>        first.nextWaiter = <span class="hljs-literal">null</span>;  <br>    <span class="hljs-comment">// 将等待队列中的 Node 转移至 AQS 队列，不成功且还有节点则继续循环  </span><br>    &#125; <span class="hljs-keyword">while</span> (!transferForSignal(first) &amp;&amp; (first = firstWaiter) != <span class="hljs-literal">null</span>);  <br>&#125;  <br>  <br><span class="hljs-comment">// signalAll() 会调用这个函数，唤醒所有的节点  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSignalAll</span><span class="hljs-params">(Node first)</span> &#123;  <br>    lastWaiter = firstWaiter = <span class="hljs-literal">null</span>;  <br>    <span class="hljs-keyword">do</span> &#123;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> first.nextWaiter;  <br>        first.nextWaiter = <span class="hljs-literal">null</span>;  <br>        transferForSignal(first);  <br>        first = next;  <br>    <span class="hljs-comment">// 唤醒所有的节点，都放到阻塞队列中  </span><br>    &#125; <span class="hljs-keyword">while</span> (first != <span class="hljs-literal">null</span>);  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>执行 transferForSignal，<strong>先将节点的 waitStatus 改为 0，然后加入 AQS 阻塞队列尾部</strong>，将 Thread-3 的 waitStatus 改为 -1</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// 如果节点状态是取消, 返回 false 表示转移失败, 否则转移成功  </span><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">transferForSignal</span><span class="hljs-params">(Node node)</span> &#123;  <br>    <span class="hljs-comment">// CAS 修改当前节点的状态，修改为 0，因为当前节点马上要迁移到阻塞队列了  </span><br>    <span class="hljs-comment">// 如果状态已经不是 CONDITION, 说明线程被取消（await 释放全部锁失败）或者被中断（可打断 cancelAcquire）  </span><br>    <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="hljs-number">0</span>))  <br>        <span class="hljs-comment">// 返回函数调用处继续寻找下一个节点  </span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>      <br>    <span class="hljs-comment">// 【先改状态，再进行迁移】  </span><br>    <span class="hljs-comment">// 将当前 node 入阻塞队列，p 是当前节点在阻塞队列的【前驱节点】  </span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> enq(node);  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> p.waitStatus;  <br>      <br>    <span class="hljs-comment">// 如果前驱节点被取消或者不能设置状态为 Node.SIGNAL，就 unpark 取消当前节点线程的阻塞状态,   </span><br>    <span class="hljs-comment">// 让 thread-0 线程竞争锁，重新同步状态  </span><br>    <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))  <br>        LockSupport.unpark(node.thread);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041902380.png"></p></li><li><p>Thread-1 释放锁，进入 unlock 流程</p></li></ul><hr><h3 id="ReadWrite"><a href="#ReadWrite" class="headerlink" title="ReadWrite"></a>ReadWrite</h3><h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><p>独占锁：指该锁一次只能被一个线程所持有，对 ReentrantLock 和 Synchronized 而言都是独占锁</p><p>共享锁：指该锁可以被多个线程锁持有</p><p>ReentrantReadWriteLock 其<strong>读锁是共享锁，写锁是独占锁</strong></p><p>作用：多个线程同时读一个资源类没有任何问题，为了满足并发量，读取共享资源应该同时进行，但是如果一个线程想去写共享资源，就不应该再有其它线程可以对该资源进行读或写</p><p>使用规则：</p><ul><li><p>加锁解锁格式：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">r.lock();  <br><span class="hljs-keyword">try</span> &#123;  <br>    <span class="hljs-comment">// 临界区  </span><br>&#125; <span class="hljs-keyword">finally</span> &#123;  <br>r.unlock();  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>读-读能共存、读-写不能共存、写-写不能共存</p></li><li><p>读锁不支持条件变量</p></li><li><p><strong>重入时升级不支持</strong>：持有读锁的情况下去获取写锁会导致获取写锁永久等待，需要先释放读，再去获得写</p></li><li><p><strong>重入时降级支持</strong>：持有写锁的情况下去获取读锁，造成只有当前线程会持有读锁，因为写锁会互斥其他的锁</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><br>w.lock();  <br><span class="hljs-keyword">try</span> &#123;  <br>    r.lock();<span class="hljs-comment">// 降级为读锁, 释放写锁, 这样能够让其它线程读取缓存  </span><br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-comment">// ...  </span><br>    &#125; <span class="hljs-keyword">finally</span>&#123;  <br>    w.unlock();<span class="hljs-comment">// 要在写锁释放之前获取读锁  </span><br>    &#125;  <br>&#125; <span class="hljs-keyword">finally</span>&#123;  <br>r.unlock();  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>构造方法：</p><ul><li><p><code>public ReentrantReadWriteLock()</code>：默认构造方法，非公平锁</p></li><li><p><code>public ReentrantReadWriteLock(boolean fair)</code>：true 为公平锁</p></li></ul><p>常用API：</p><ul><li><p><code>public ReentrantReadWriteLock.ReadLock readLock()</code>：返回读锁</p></li><li><p><code>public ReentrantReadWriteLock.WriteLock writeLock()</code>：返回写锁</p></li><li><p><code>public void lock()</code>：加锁</p></li><li><p><code>public void unlock()</code>：解锁</p></li><li><p><code>public boolean tryLock()</code>：尝试获取锁</p></li></ul><p>读读并发：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    <span class="hljs-type">ReentrantReadWriteLock</span> <span class="hljs-variable">rw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantReadWriteLock</span>();  <br>    ReentrantReadWriteLock.<span class="hljs-type">ReadLock</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> rw.readLock();  <br>    ReentrantReadWriteLock.<span class="hljs-type">WriteLock</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> rw.writeLock();  <br>  <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>        r.lock();  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            Thread.sleep(<span class="hljs-number">2000</span>);  <br>            System.out.println(<span class="hljs-string">&quot;Thread 1 running &quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());  <br>        &#125; <span class="hljs-keyword">finally</span> &#123;  <br>            r.unlock();  <br>        &#125;  <br>    &#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();  <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>        r.lock();  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            Thread.sleep(<span class="hljs-number">2000</span>);  <br>            System.out.println(<span class="hljs-string">&quot;Thread 2 running &quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());  <br>        &#125; <span class="hljs-keyword">finally</span> &#123;  <br>            r.unlock();  <br>        &#125;  <br>    &#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="缓存应用"><a href="#缓存应用" class="headerlink" title="缓存应用"></a>缓存应用</h4><p>缓存更新时，是先清缓存还是先更新数据库</p><ul><li><p>先清缓存：可能造成刚清理缓存还没有更新数据库，线程直接查询了数据库更新过期数据到缓存</p></li><li><p>先更新据库：可能造成刚更新数据库，还没清空缓存就有线程从缓存拿到了旧数据</p></li><li><p>补充情况：查询线程 A 查询数据时恰好缓存数据由于时间到期失效，或是第一次查询</p><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041905401.png"></p></li></ul><p>可以使用读写锁进行操作</p><hr><h4 id="实现原理-5"><a href="#实现原理-5" class="headerlink" title="实现原理"></a>实现原理</h4><h5 id="成员属性-5"><a href="#成员属性-5" class="headerlink" title="成员属性"></a>成员属性</h5><p>读写锁用的是同一个 Sycn 同步器，因此等待队列、state 等也是同一个，原理与 ReentrantLock 加锁相比没有特殊之处，不同是<strong>写锁状态占了 state 的低 16 位，而读锁使用的是 state 的高 16 位</strong></p><ul><li><p>读写锁：</p><p>  <code>private final ReentrantReadWriteLock.ReadLock readerLock;</code><br>  <code>private final ReentrantReadWriteLock.WriteLock writerLock;</code></p></li><li><p>构造方法：默认是非公平锁，可以指定参数创建公平锁</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantReadWriteLock</span><span class="hljs-params">(<span class="hljs-type">boolean</span> fair)</span> &#123;  <br>    <span class="hljs-comment">// true 为公平锁  </span><br>    sync = fair ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">FairSync</span>() : <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();  <br>    <span class="hljs-comment">// 这两个 lock 共享同一个 sync 实例，都是由 ReentrantReadWriteLock 的 sync 提供同步实现  </span><br>    readerLock = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReadLock</span>(<span class="hljs-built_in">this</span>);  <br>    writerLock = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WriteLock</span>(<span class="hljs-built_in">this</span>);  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>Sync 类的属性：</p><ul><li><p>统计变量：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// 用来移位  </span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SHARED_SHIFT</span>   <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;  <br><span class="hljs-comment">// 高16位的1  </span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SHARED_UNIT</span>    <span class="hljs-operator">=</span> (<span class="hljs-number">1</span> &lt;&lt; SHARED_SHIFT);  <br><span class="hljs-comment">// 65535，16个1，代表写锁的最大重入次数  </span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_COUNT</span>      <span class="hljs-operator">=</span> (<span class="hljs-number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="hljs-number">1</span>;  <br><span class="hljs-comment">// 低16位掩码：0b 1111 1111 1111 1111，用来获取写锁重入的次数  </span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">EXCLUSIVE_MASK</span> <span class="hljs-operator">=</span> (<span class="hljs-number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure></li><li><p>获取读写锁的次数：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// 获取读写锁的读锁分配的总次数  </span><br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sharedCount</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>    &#123; <span class="hljs-keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;  <br><span class="hljs-comment">// 写锁（独占）锁的重入次数  </span><br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">exclusiveCount</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span> &#123; <span class="hljs-keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;<br></code></pre></td></tr></table></figure></li><li><p>内部类：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// 记录读锁线程自己的持有读锁的数量（重入次数），因为 state 高16位记录的是全局范围内所有的读线程获取读锁的总量  </span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HoldCounter</span> &#123;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br>    <span class="hljs-comment">// Use id, not reference, to avoid garbage retention  </span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">tid</span> <span class="hljs-operator">=</span> getThreadId(Thread.currentThread());  <br>&#125;  <br><span class="hljs-comment">// 线程安全的存放线程各自的 HoldCounter 对象  </span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalHoldCounter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ThreadLocal</span>&lt;HoldCounter&gt; &#123;  <br>    <span class="hljs-keyword">public</span> HoldCounter <span class="hljs-title function_">initialValue</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HoldCounter</span>();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>内部类实例：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// 当前线程持有的可重入读锁的数量，计数为 0 时删除  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> ThreadLocalHoldCounter readHolds;  <br><span class="hljs-comment">// 记录最后一个获取【读锁】线程的 HoldCounter 对象  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> HoldCounter cachedHoldCounter;<br></code></pre></td></tr></table></figure></li><li><p>首次获取锁：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// 第一个获取读锁的线程  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">firstReader</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;  <br><span class="hljs-comment">// 记录该线程持有的读锁次数（读锁重入次数）  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> firstReaderHoldCount;<br></code></pre></td></tr></table></figure></li><li><p>Sync 构造方法：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><br>Sync() &#123;  <br>    readHolds = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalHoldCounter</span>();  <br>    <span class="hljs-comment">// 确保其他线程的数据可见性，state 是 volatile 修饰的变量，重写该值会将线程本地缓存数据【同步至主存】  </span><br>    setState(getState());   <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h5 id="加锁原理"><a href="#加锁原理" class="headerlink" title="加锁原理"></a>加锁原理</h5><ul><li><p>t1 线程：w.lock（<strong>写锁</strong>），成功上锁 state &#x3D; 0_1</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// lock()  -&gt; sync.acquire(1);  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;  <br>    sync.acquire(<span class="hljs-number">1</span>);  <br>&#125;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;  <br>    <span class="hljs-comment">// 尝试获得写锁，获得写锁失败，将当前线程关联到一个 Node 对象上, 模式为独占模式   </span><br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))  <br>        selfInterrupt();  <br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;  <br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();  <br>    <span class="hljs-comment">// 获得低 16 位, 代表写锁的 state 计数  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> exclusiveCount(c);  <br>    <span class="hljs-comment">// 说明有读锁或者写锁  </span><br>    <span class="hljs-keyword">if</span> (c != <span class="hljs-number">0</span>) &#123;  <br>        <span class="hljs-comment">// c != 0 and w == 0 表示有读锁，【读锁不能升级】，直接返回 false  </span><br>        <span class="hljs-comment">// w != 0 说明有写锁，写锁的拥有者不是自己，获取失败  </span><br>        <span class="hljs-keyword">if</span> (w == <span class="hljs-number">0</span> || current != getExclusiveOwnerThread())  <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>          <br>        <span class="hljs-comment">// 执行到这里只有一种情况：【写锁重入】，所以下面几行代码不存在并发  </span><br>        <span class="hljs-keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)  <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);  <br>        <span class="hljs-comment">// 写锁重入, 获得锁成功，没有并发，所以不使用 CAS  </span><br>        setState(c + acquires);  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    &#125;  <br>      <br>    <span class="hljs-comment">// c == 0，说明没有任何锁，判断写锁是否该阻塞，是 false 就尝试获取锁，失败返回 false  </span><br>    <span class="hljs-keyword">if</span> (writerShouldBlock() || !compareAndSetState(c, c + acquires))  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>    <span class="hljs-comment">// 获得锁成功，设置锁的持有线程为当前线程  </span><br>    setExclusiveOwnerThread(current);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>&#125;  <br><span class="hljs-comment">// 非公平锁 writerShouldBlock 总是返回 false, 无需阻塞  </span><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">writerShouldBlock</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;   <br>&#125;  <br><span class="hljs-comment">// 公平锁会检查 AQS 队列中是否有前驱节点, 没有(false)才去竞争  </span><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">writerShouldBlock</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">return</span> hasQueuedPredecessors();  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>t2 r.lock（<strong>读锁</strong>），进入 tryAcquireShared 流程：</p><ul><li><p>返回 -1 表示失败</p></li><li><p>如果返回 0 表示成功</p></li><li><p>返回正数表示还有多少后继节点支持共享模式，读写锁返回 1</p></li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;  <br>    sync.acquireShared(<span class="hljs-number">1</span>);  <br>&#125;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;  <br>    <span class="hljs-comment">// tryAcquireShared 返回负数, 表示获取读锁失败  </span><br>    <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)  <br>        doAcquireShared(arg);  <br>&#125;<br><br><span class="hljs-comment">// 尝试以共享模式获取  </span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> unused)</span> &#123;  <br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();  <br>    <span class="hljs-comment">// exclusiveCount(c) 代表低 16 位, 写锁的 state，成立说明有线程持有写锁  </span><br>    <span class="hljs-comment">// 写锁的持有者不是当前线程，则获取读锁失败，【写锁允许降级】  </span><br>    <span class="hljs-keyword">if</span> (exclusiveCount(c) != <span class="hljs-number">0</span> &amp;&amp; getExclusiveOwnerThread() != current)  <br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;  <br>      <br>    <span class="hljs-comment">// 高 16 位，代表读锁的 state，共享锁分配出去的总次数  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> sharedCount(c);  <br>    <span class="hljs-comment">// 读锁是否应该阻塞  </span><br>    <span class="hljs-keyword">if</span> (!readerShouldBlock() &amp;&amp;r &lt; MAX_COUNT &amp;&amp;  <br>        compareAndSetState(c, c + SHARED_UNIT)) &#123;<span class="hljs-comment">// 尝试增加读锁计数  </span><br>        <span class="hljs-comment">// 加锁成功  </span><br>        <span class="hljs-comment">// 加锁之前读锁为 0，说明当前线程是第一个读锁线程  </span><br>        <span class="hljs-keyword">if</span> (r == <span class="hljs-number">0</span>) &#123;  <br>            firstReader = current;  <br>            firstReaderHoldCount = <span class="hljs-number">1</span>;  <br>        <span class="hljs-comment">// 第一个读锁线程是自己就发生了读锁重入  </span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (firstReader == current) &#123;  <br>            firstReaderHoldCount++;  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            <span class="hljs-comment">// cachedHoldCounter 设置为当前线程的 holdCounter 对象，即最后一个获取读锁的线程  </span><br>            <span class="hljs-type">HoldCounter</span> <span class="hljs-variable">rh</span> <span class="hljs-operator">=</span> cachedHoldCounter;  <br>            <span class="hljs-comment">// 说明还没设置 rh  </span><br>            <span class="hljs-keyword">if</span> (rh == <span class="hljs-literal">null</span> || rh.tid != getThreadId(current))  <br>                <span class="hljs-comment">// 获取当前线程的锁重入的对象，赋值给 cachedHoldCounter  </span><br>                cachedHoldCounter = rh = readHolds.get();  <br>            <span class="hljs-comment">// 还没重入  </span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rh.count == <span class="hljs-number">0</span>)  <br>                readHolds.set(rh);  <br>            <span class="hljs-comment">// 重入 + 1  </span><br>            rh.count++;  <br>        &#125;  <br>        <span class="hljs-comment">// 读锁加锁成功  </span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <br>    &#125;  <br>    <span class="hljs-comment">// 逻辑到这 应该阻塞，或者 cas 加锁失败  </span><br>    <span class="hljs-comment">// 会不断尝试 for (;;) 获取读锁, 执行过程中无阻塞  </span><br>    <span class="hljs-keyword">return</span> fullTryAcquireShared(current);  <br>&#125;  <br><span class="hljs-comment">// 非公平锁 readerShouldBlock 偏向写锁一些，看 AQS 阻塞队列中第一个节点是否是写锁，是则阻塞，反之不阻塞  </span><br><span class="hljs-comment">// 防止一直有读锁线程，导致写锁线程饥饿  </span><br><span class="hljs-comment">// true 则该阻塞, false 则不阻塞  </span><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">readerShouldBlock</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">return</span> apparentlyFirstQueuedIsExclusive();  <br>&#125;  <br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">readerShouldBlock</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">return</span> hasQueuedPredecessors();  <br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fullTryAcquireShared</span><span class="hljs-params">(Thread current)</span> &#123;  <br>    <span class="hljs-comment">// 当前读锁线程持有的读锁次数对象  </span><br>    <span class="hljs-type">HoldCounter</span> <span class="hljs-variable">rh</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;  <br>    <span class="hljs-keyword">for</span> (;;) &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();  <br>        <span class="hljs-comment">// 说明有线程持有写锁  </span><br>        <span class="hljs-keyword">if</span> (exclusiveCount(c) != <span class="hljs-number">0</span>) &#123;  <br>            <span class="hljs-comment">// 写锁不是自己则获取锁失败  </span><br>            <span class="hljs-keyword">if</span> (getExclusiveOwnerThread() != current)  <br>                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;  <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (readerShouldBlock()) &#123;  <br>            <span class="hljs-comment">// 条件成立说明当前线程是 firstReader，当前锁是读忙碌状态，而且当前线程也是读锁重入  </span><br>            <span class="hljs-keyword">if</span> (firstReader == current) &#123;  <br>                <span class="hljs-comment">// assert firstReaderHoldCount &gt; 0;  </span><br>            &#125; <span class="hljs-keyword">else</span> &#123;  <br>                <span class="hljs-keyword">if</span> (rh == <span class="hljs-literal">null</span>) &#123;  <br>                    <span class="hljs-comment">// 最后一个读锁的 HoldCounter  </span><br>                    rh = cachedHoldCounter;  <br>                    <span class="hljs-comment">// 说明当前线程也不是最后一个读锁  </span><br>                    <span class="hljs-keyword">if</span> (rh == <span class="hljs-literal">null</span> || rh.tid != getThreadId(current)) &#123;  <br>                        <span class="hljs-comment">// 获取当前线程的 HoldCounter  </span><br>                        rh = readHolds.get();  <br>                        <span class="hljs-comment">// 条件成立说明 HoldCounter 对象是上一步代码新建的  </span><br>                        <span class="hljs-comment">// 当前线程不是锁重入，在 readerShouldBlock() 返回 true 时需要去排队  </span><br>                        <span class="hljs-keyword">if</span> (rh.count == <span class="hljs-number">0</span>)  <br>                            <span class="hljs-comment">// 防止内存泄漏  </span><br>                            readHolds.remove();  <br>                    &#125;  <br>                &#125;  <br>                <span class="hljs-keyword">if</span> (rh.count == <span class="hljs-number">0</span>)  <br>                    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-comment">// 越界判断  </span><br>        <span class="hljs-keyword">if</span> (sharedCount(c) == MAX_COUNT)  <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);  <br>        <span class="hljs-comment">// 读锁加锁，条件内的逻辑与 tryAcquireShared 相同  </span><br>        <span class="hljs-keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;  <br>            <span class="hljs-keyword">if</span> (sharedCount(c) == <span class="hljs-number">0</span>) &#123;  <br>                firstReader = current;  <br>                firstReaderHoldCount = <span class="hljs-number">1</span>;  <br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (firstReader == current) &#123;  <br>                firstReaderHoldCount++;  <br>            &#125; <span class="hljs-keyword">else</span> &#123;  <br>                <span class="hljs-keyword">if</span> (rh == <span class="hljs-literal">null</span>)  <br>                    rh = cachedHoldCounter;  <br>                <span class="hljs-keyword">if</span> (rh == <span class="hljs-literal">null</span> || rh.tid != getThreadId(current))  <br>                    rh = readHolds.get();  <br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rh.count == <span class="hljs-number">0</span>)  <br>                    readHolds.set(rh);  <br>                rh.count++;  <br>                cachedHoldCounter = rh; <span class="hljs-comment">// cache for release  </span><br>            &#125;  <br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>获取读锁失败，进入 sync.doAcquireShared(1) 流程开始阻塞，首先也是调用 addWaiter 添加节点，不同之处在于节点被设置为 Node.SHARED 模式而非 Node.EXCLUSIVE 模式，注意此时 t2 仍处于活跃状态</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;  <br>    <span class="hljs-comment">// 将当前线程关联到一个 Node 对象上, 模式为共享模式  </span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addWaiter(Node.SHARED);  <br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;  <br>        <span class="hljs-keyword">for</span> (;;) &#123;  <br>            <span class="hljs-comment">// 获取前驱节点  </span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();  <br>            <span class="hljs-comment">// 如果前驱节点就头节点就去尝试获取锁  </span><br>            <span class="hljs-keyword">if</span> (p == head) &#123;  <br>                <span class="hljs-comment">// 再一次尝试获取读锁  </span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> tryAcquireShared(arg);  <br>                <span class="hljs-comment">// r &gt;= 0 表示获取成功  </span><br>                <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;  <br>                    <span class="hljs-comment">//【这里会设置自己为头节点，唤醒相连的后序的共享节点】  </span><br>                    setHeadAndPropagate(node, r);  <br>                    p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC  </span><br>                    <span class="hljs-keyword">if</span> (interrupted)  <br>                        selfInterrupt();  <br>                    failed = <span class="hljs-literal">false</span>;  <br>                    <span class="hljs-keyword">return</span>;  <br>                &#125;  <br>            &#125;  <br>            <span class="hljs-comment">// 是否在获取读锁失败时阻塞       park 当前线程  </span><br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())  <br>                interrupted = <span class="hljs-literal">true</span>;  <br>        &#125;  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        <span class="hljs-keyword">if</span> (failed)  <br>            cancelAcquire(node);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>  如果没有成功，在 doAcquireShared 内 for (;;) 循环一次，shouldParkAfterFailedAcquire 内把前驱节点的 waitStatus 改为 -1，再 for (;;) 循环一次尝试 tryAcquireShared，不成功在 parkAndCheckInterrupt() 处 park</p><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041907782.png"></p></li><li><p>这种状态下，假设又有 t3 r.lock，t4 w.lock，这期间 t1 仍然持有锁，就变成了下面的样子</p><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041907677.png"></p></li></ul><hr><h5 id="解锁原理"><a href="#解锁原理" class="headerlink" title="解锁原理"></a>解锁原理</h5><ul><li><p>t1 w.unlock， 写锁解锁</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">// 释放锁  </span><br>    sync.release(<span class="hljs-number">1</span>);  <br>&#125;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;  <br>    <span class="hljs-comment">// 尝试释放锁  </span><br>    <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;  <br>        <span class="hljs-comment">// 头节点不为空并且不是等待状态不是 0，唤醒后继的非取消节点  </span><br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)  <br>            unparkSuccessor(h);  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>&#125;  <br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;  <br>    <span class="hljs-keyword">if</span> (!isHeldExclusively())  <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> getState() - releases;  <br>    <span class="hljs-comment">// 因为可重入的原因, 写锁计数为 0, 才算释放成功  </span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">free</span> <span class="hljs-operator">=</span> exclusiveCount(nextc) == <span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">if</span> (free)  <br>        setExclusiveOwnerThread(<span class="hljs-literal">null</span>);  <br>    setState(nextc);  <br>    <span class="hljs-keyword">return</span> free;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>唤醒流程 sync.unparkSuccessor，这时 t2 在 doAcquireShared 的 parkAndCheckInterrupt() 处恢复运行，继续循环，执行 tryAcquireShared 成功则让读锁计数加一</p></li><li><p>接下来 t2 调用 setHeadAndPropagate(node, 1)，它原本所在节点被置为头节点；还会检查下一个节点是否是 shared，如果是则调用 doReleaseShared() 将 head 的状态从 -1 改为 0 并唤醒下一个节点，这时 t3 在 doAcquireShared 内 parkAndCheckInterrupt() 处恢复运行，<strong>唤醒连续的所有的共享节点</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setHeadAndPropagate</span><span class="hljs-params">(Node node, <span class="hljs-type">int</span> propagate)</span> &#123;  <br>    <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;   <br>    <span class="hljs-comment">// 设置自己为 head 节点  </span><br>    setHead(node);  <br>    <span class="hljs-comment">// propagate 表示有共享资源（例如共享读锁或信号量），为 0 就没有资源  </span><br>    <span class="hljs-keyword">if</span> (propagate &gt; <span class="hljs-number">0</span> || h == <span class="hljs-literal">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span> ||  <br>        (h = head) == <span class="hljs-literal">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span>) &#123;  <br>        <span class="hljs-comment">// 获取下一个节点  </span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;  <br>        <span class="hljs-comment">// 如果当前是最后一个节点，或者下一个节点是【等待共享读锁的节点】  </span><br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.isShared())  <br>            <span class="hljs-comment">// 唤醒后继节点  </span><br>            doReleaseShared();  <br>    &#125;  <br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doReleaseShared</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">// 如果 head.waitStatus == Node.SIGNAL ==&gt; 0 成功, 下一个节点 unpark  </span><br><span class="hljs-comment">// 如果 head.waitStatus == 0 ==&gt; Node.PROPAGATE  </span><br>    <span class="hljs-keyword">for</span> (;;) &#123;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;  <br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h != tail) &#123;  <br>            <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> h.waitStatus;  <br>            <span class="hljs-comment">// SIGNAL 唤醒后继  </span><br>            <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;  <br>                <span class="hljs-comment">// 因为读锁共享，如果其它线程也在释放读锁，那么需要将 waitStatus 先改为 0  </span><br>            <span class="hljs-comment">// 防止 unparkSuccessor 被多次执行  </span><br>                <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>))  <br>                    <span class="hljs-keyword">continue</span>;    <br>                <span class="hljs-comment">// 唤醒后继节点  </span><br>                unparkSuccessor(h);  <br>            &#125;  <br>            <span class="hljs-comment">// 如果已经是 0 了，改为 -3，用来解决传播性  </span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp; !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))  <br>                <span class="hljs-keyword">continue</span>;                  <br>        &#125;  <br>        <span class="hljs-comment">// 条件不成立说明被唤醒的节点非常积极，直接将自己设置为了新的 head，  </span><br>        <span class="hljs-comment">// 此时唤醒它的节点（前驱）执行 h == head 不成立，所以不会跳出循环，会继续唤醒新的 head 节点的后继节点  </span><br>        <span class="hljs-keyword">if</span> (h == head)                     <br>            <span class="hljs-keyword">break</span>;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041908507.png"></p></li><li><p>下一个节点不是 shared 了，因此不会继续唤醒 t4 所在节点</p></li><li><p>t2 读锁解锁，进入 sync.releaseShared(1) 中，调用 tryReleaseShared(1) 让计数减一，但计数还不为零，t3 同样让计数减一，计数为零，进入doReleaseShared() 将头节点从 -1 改为 0 并唤醒下一个节点</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;  <br>    sync.releaseShared(<span class="hljs-number">1</span>);  <br>&#125;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">releaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;  <br>    <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;  <br>        doReleaseShared();  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> unused)</span> &#123;  <br>  <br>    <span class="hljs-keyword">for</span> (;;) &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c - SHARED_UNIT;  <br>        <span class="hljs-comment">// 读锁的计数不会影响其它获取读锁线程, 但会影响其它获取写锁线程，计数为 0 才是真正释放  </span><br>        <span class="hljs-keyword">if</span> (compareAndSetState(c, nextc))  <br>            <span class="hljs-comment">// 返回是否已经完全释放了   </span><br>            <span class="hljs-keyword">return</span> nextc == <span class="hljs-number">0</span>;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>t4 在 acquireQueued 中 parkAndCheckInterrupt 处恢复运行，再次 for (;;) 这次自己是头节点的临节点，并且没有其他节点竞争，tryAcquire(1) 成功，修改头结点，流程结束</p><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041909290.png"></p></li></ul><hr><h4 id="Stamped"><a href="#Stamped" class="headerlink" title="Stamped"></a>Stamped</h4><p>StampedLock：读写锁，该类自 JDK 8 加入，是为了进一步优化读性能</p><p>特点：</p><ul><li><p>在使用读锁、写锁时都必须配合戳使用</p></li><li><p>StampedLock 不支持条件变量</p></li><li><p>StampedLock <strong>不支持重入</strong></p></li></ul><p>基本用法</p><ul><li><p>加解读锁：</p><p>  long stamp &#x3D; lock.readLock();<br>  lock.unlockRead(stamp);&#x2F;&#x2F; 类似于 unpark，解指定的锁</p></li><li><p>加解写锁：</p><p>  long stamp &#x3D; lock.writeLock();<br>  lock.unlockWrite(stamp);</p></li><li><p>乐观读，StampedLock 支持 <code>tryOptimisticRead()</code> 方法，读取完毕后做一次<strong>戳校验</strong>，如果校验通过，表示这期间没有其他线程的写操作，数据可以安全使用，如果校验没通过，需要重新获取读锁，保证数据一致性</p><p>  long stamp &#x3D; lock.tryOptimisticRead();<br>  &#x2F;&#x2F; 验戳<br>  if(!lock.validate(stamp)){<br>  &#x2F;&#x2F; 锁升级<br>  }</p></li></ul><p>提供一个数据容器类内部分别使用读锁保护数据的 read() 方法，写锁保护数据的 write() 方法：</p><ul><li><p>读-读可以优化</p></li><li><p>读-写优化读，补加读锁</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>    <span class="hljs-type">DataContainerStamped</span> <span class="hljs-variable">dataContainer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataContainerStamped</span>(<span class="hljs-number">1</span>);  <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>    dataContainer.read(<span class="hljs-number">1000</span>);  <br>    &#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();  <br>    Thread.sleep(<span class="hljs-number">500</span>);  <br>      <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>        dataContainer.write(<span class="hljs-number">1000</span>);  <br>    &#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();  <br>&#125;  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DataContainerStamped</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> data;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">StampedLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StampedLock</span>();  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">int</span> readTime)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>        <span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> lock.tryOptimisticRead();  <br>        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>() + <span class="hljs-string">&quot; optimistic read locking&quot;</span> + stamp);  <br>        Thread.sleep(readTime);  <br>        <span class="hljs-comment">// 戳有效，直接返回数据  </span><br>        <span class="hljs-keyword">if</span> (lock.validate(stamp)) &#123;  <br>            Sout(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>() + <span class="hljs-string">&quot; optimistic read finish...&quot;</span> + stamp);  <br>            <span class="hljs-keyword">return</span> data;  <br>        &#125;  <br>  <br>        <span class="hljs-comment">// 说明其他线程更改了戳，需要锁升级了，从乐观读升级到读锁  </span><br>        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>() + <span class="hljs-string">&quot; updating to read lock&quot;</span> + stamp);  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            stamp = lock.readLock();  <br>            System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>() + <span class="hljs-string">&quot; read lock&quot;</span> + stamp);  <br>            Thread.sleep(readTime);  <br>            System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>() + <span class="hljs-string">&quot; read finish...&quot;</span> + stamp);  <br>            <span class="hljs-keyword">return</span> data;  <br>        &#125; <span class="hljs-keyword">finally</span> &#123;  <br>            System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>() + <span class="hljs-string">&quot; read unlock &quot;</span> +  stamp);  <br>            lock.unlockRead(stamp);  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">int</span> newData)</span> &#123;  <br>        <span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> lock.writeLock();  <br>        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>() + <span class="hljs-string">&quot; write lock &quot;</span> + stamp);  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            Thread.sleep(<span class="hljs-number">2000</span>);  <br>            <span class="hljs-built_in">this</span>.data = newData;  <br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>            e.printStackTrace();  <br>        &#125; <span class="hljs-keyword">finally</span> &#123;  <br>            System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>() + <span class="hljs-string">&quot; write unlock &quot;</span> + stamp);  <br>            lock.unlockWrite(stamp);  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="CountDown"><a href="#CountDown" class="headerlink" title="CountDown"></a>CountDown</h3><h4 id="基本使用-6"><a href="#基本使用-6" class="headerlink" title="基本使用"></a>基本使用</h4><p>CountDownLatch：计数器，用来进行线程同步协作，<strong>等待所有线程完成</strong></p><p>构造器：</p><ul><li><code>public CountDownLatch(int count)</code>：初始化唤醒需要的 down 几步</li></ul><p>常用API：</p><ul><li><p><code>public void await()</code>：让当前线程等待，必须 down 完初始化的数字才可以被唤醒，否则进入无限等待</p></li><li><p><code>public void countDown()</code>：计数器进行减 1（down 1）</p></li></ul><p>应用：同步等待多个 Rest 远程调用结束</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// LOL 10人进入游戏倒计时  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>    <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">latch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">10</span>);  <br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);  <br>    String[] all = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">10</span>];  <br>    <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();  <br>  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++) &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">finalJ</span> <span class="hljs-operator">=</span> j;<span class="hljs-comment">//常量  </span><br>        service.submit(() -&gt; &#123;  <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100</span>; i++) &#123;  <br>                Thread.sleep(random.nextInt(<span class="hljs-number">100</span>));<span class="hljs-comment">//随机休眠  </span><br>                all[finalJ] = i + <span class="hljs-string">&quot;%&quot;</span>;  <br>                System.out.print(<span class="hljs-string">&quot;\r&quot;</span> + Arrays.toString(all));<span class="hljs-comment">// \r代表覆盖  </span><br>            &#125;  <br>            latch.countDown();  <br>        &#125;);  <br>    &#125;  <br>    latch.await();  <br>    System.out.println(<span class="hljs-string">&quot;\n游戏开始&quot;</span>);  <br>    service.shutdown();  <br>&#125;  <br><span class="hljs-comment">/*  </span><br><span class="hljs-comment">[100%, 100%, 100%, 100%, 100%, 100%, 100%, 100%, 100%, 100%]  </span><br><span class="hljs-comment">游戏开始*/</span><br></code></pre></td></tr></table></figure><hr><h4 id="实现原理-6"><a href="#实现原理-6" class="headerlink" title="实现原理"></a>实现原理</h4><p>阻塞等待：</p><ul><li><p>线程调用 await() 等待其他线程完成任务：支持打断</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>    sync.acquireSharedInterruptibly(<span class="hljs-number">1</span>);  <br>&#125;  <br><span class="hljs-comment">// AbstractQueuedSynchronizer#acquireSharedInterruptibly  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireSharedInterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>    <span class="hljs-comment">// 判断线程是否被打断，抛出打断异常  </span><br>    <span class="hljs-keyword">if</span> (Thread.interrupted())  <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();  <br>    <span class="hljs-comment">// 尝试获取共享锁，条件成立说明 state &gt; 0，此时线程入队阻塞等待，等待其他线程获取共享资源  </span><br>    <span class="hljs-comment">// 条件不成立说明 state = 0，此时不需要阻塞线程，直接结束函数调用  </span><br>    <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)  <br>        doAcquireSharedInterruptibly(arg);  <br>&#125;  <br><span class="hljs-comment">// CountDownLatch.Sync#tryAcquireShared  </span><br><span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;  <br>    <span class="hljs-keyword">return</span> (getState() == <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>线程进入 AbstractQueuedSynchronizer#doAcquireSharedInterruptibly 函数阻塞挂起，等待 latch 变为 0：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAcquireSharedInterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>    <span class="hljs-comment">// 将调用latch.await()方法的线程 包装成 SHARED 类型的 node 加入到 AQS 的阻塞队列中  </span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addWaiter(Node.SHARED);  <br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-keyword">for</span> (;;) &#123;  <br>            <span class="hljs-comment">// 获取当前节点的前驱节点  </span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();  <br>            <span class="hljs-comment">// 前驱节点时头节点就可以尝试获取锁  </span><br>            <span class="hljs-keyword">if</span> (p == head) &#123;  <br>                <span class="hljs-comment">// 再次尝试获取锁，获取成功返回 1  </span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> tryAcquireShared(arg);  <br>                <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;  <br>                    <span class="hljs-comment">// 获取锁成功，设置当前节点为 head 节点，并且向后传播  </span><br>                    setHeadAndPropagate(node, r);  <br>                    p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC  </span><br>                    failed = <span class="hljs-literal">false</span>;  <br>                    <span class="hljs-keyword">return</span>;  <br>                &#125;  <br>            &#125;  <br>            <span class="hljs-comment">// 阻塞在这里  </span><br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())  <br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();  <br>        &#125;  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        <span class="hljs-comment">// 阻塞线程被中断后抛出异常，进入取消节点的逻辑  </span><br>        <span class="hljs-keyword">if</span> (failed)  <br>            cancelAcquire(node);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>获取共享锁成功，进入唤醒阻塞队列中与头节点相连的 SHARED 模式的节点：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setHeadAndPropagate</span><span class="hljs-params">(Node node, <span class="hljs-type">int</span> propagate)</span> &#123;  <br>    <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;  <br>    <span class="hljs-comment">// 将当前节点设置为新的 head 节点，前驱节点和持有线程置为 null  </span><br>    setHead(node);  <br><span class="hljs-comment">// propagate = 1，条件一成立  </span><br>    <span class="hljs-keyword">if</span> (propagate &gt; <span class="hljs-number">0</span> || h == <span class="hljs-literal">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span> || (h = head) == <span class="hljs-literal">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span>) &#123;  <br>        <span class="hljs-comment">// 获取当前节点的后继节点  </span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;  <br>        <span class="hljs-comment">// 当前节点是尾节点时 next 为 null，或者后继节点是 SHARED 共享模式  </span><br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.isShared())  <br>            <span class="hljs-comment">// 唤醒所有的等待共享锁的节点  </span><br>            doReleaseShared();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>计数减一：</p><ul><li><p>线程进入 countDown() 完成计数器减一（释放锁）的操作</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">countDown</span><span class="hljs-params">()</span> &#123;  <br>    sync.releaseShared(<span class="hljs-number">1</span>);  <br>&#125;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">releaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;  <br>    <span class="hljs-comment">// 尝试释放共享锁  </span><br>    <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;  <br>        <span class="hljs-comment">// 释放锁成功开始唤醒阻塞节点  </span><br>        doReleaseShared();  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>更新 state 值，每调用一次，state 值减一，当 state -1 正好为 0 时，返回 true</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;  <br>    <span class="hljs-keyword">for</span> (;;) &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();  <br>        <span class="hljs-comment">// 条件成立说明前面【已经有线程触发唤醒操作】了，这里返回 false  </span><br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>)  <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>        <span class="hljs-comment">// 计数器减一  </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c-<span class="hljs-number">1</span>;  <br>        <span class="hljs-keyword">if</span> (compareAndSetState(c, nextc))  <br>            <span class="hljs-comment">// 计数器为 0 时返回 true  </span><br>            <span class="hljs-keyword">return</span> nextc == <span class="hljs-number">0</span>;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>state &#x3D; 0 时，当前线程需要执行<strong>唤醒阻塞节点的任务</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doReleaseShared</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">for</span> (;;) &#123;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;  <br>        <span class="hljs-comment">// 判断队列是否是空队列  </span><br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h != tail) &#123;  <br>            <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> h.waitStatus;  <br>            <span class="hljs-comment">// 头节点的状态为 signal，说明后继节点没有被唤醒过  </span><br>            <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;  <br>                <span class="hljs-comment">// cas 设置头节点的状态为 0，设置失败继续自旋  </span><br>                <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>))  <br>                    <span class="hljs-keyword">continue</span>;  <br>                <span class="hljs-comment">// 唤醒后继节点  </span><br>                unparkSuccessor(h);  <br>            &#125;  <br>            <span class="hljs-comment">// 如果有其他线程已经设置了头节点的状态，重新设置为 PROPAGATE 传播属性  </span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp; !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))  <br>                <span class="hljs-keyword">continue</span>;  <br>        &#125;  <br>        <span class="hljs-comment">// 条件不成立说明被唤醒的节点非常积极，直接将自己设置为了新的head，  </span><br>        <span class="hljs-comment">// 此时唤醒它的节点（前驱）执行 h == head 不成立，所以不会跳出循环，会继续唤醒新的 head 节点的后继节点  </span><br>        <span class="hljs-keyword">if</span> (h == head)  <br>            <span class="hljs-keyword">break</span>;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><h4 id="基本使用-7"><a href="#基本使用-7" class="headerlink" title="基本使用"></a>基本使用</h4><p>CyclicBarrier：循环屏障，用来进行线程协作，等待线程满足某个计数，才能触发自己执行</p><p>常用方法：</p><ul><li><p><code>public CyclicBarrier(int parties, Runnable barrierAction)</code>：用于在线程到达屏障 parties 时，执行 barrierAction</p><ul><li><p>parties：代表多少个线程到达屏障开始触发线程任务</p></li><li><p>barrierAction：线程任务</p></li></ul></li><li><p><code>public int await()</code>：线程调用 await 方法通知 CyclicBarrier 本线程已经到达屏障</p></li></ul><p>与 CountDownLatch 的区别：CyclicBarrier 是可以重用的</p><p>应用：可以实现多线程中，某个任务在等待其他线程执行完毕以后触发</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">2</span>);  <br>    <span class="hljs-type">CyclicBarrier</span> <span class="hljs-variable">barrier</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CyclicBarrier</span>(<span class="hljs-number">2</span>, () -&gt; &#123;  <br>        System.out.println(<span class="hljs-string">&quot;task1 task2 finish...&quot;</span>);  <br>    &#125;);  <br>  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123; <span class="hljs-comment">// 循环重用  </span><br>        service.submit(() -&gt; &#123;  <br>            System.out.println(<span class="hljs-string">&quot;task1 begin...&quot;</span>);  <br>            <span class="hljs-keyword">try</span> &#123;  <br>                Thread.sleep(<span class="hljs-number">1000</span>);  <br>                barrier.await();    <span class="hljs-comment">// 2 - 1 = 1  </span><br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;  <br>                e.printStackTrace();  <br>            &#125;  <br>        &#125;);  <br>  <br>        service.submit(() -&gt; &#123;  <br>            System.out.println(<span class="hljs-string">&quot;task2 begin...&quot;</span>);  <br>            <span class="hljs-keyword">try</span> &#123;  <br>                Thread.sleep(<span class="hljs-number">2000</span>);  <br>                barrier.await();    <span class="hljs-comment">// 1 - 1 = 0  </span><br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;  <br>                e.printStackTrace();  <br>            &#125;  <br>        &#125;);  <br>    &#125;  <br>    service.shutdown();  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="实现原理-7"><a href="#实现原理-7" class="headerlink" title="实现原理"></a>实现原理</h4><h5 id="成员属性-6"><a href="#成员属性-6" class="headerlink" title="成员属性"></a>成员属性</h5><ul><li><p>全局锁：利用可重入锁实现的工具类</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// barrier 实现是依赖于Condition条件队列，condition 条件队列必须依赖lock才能使用  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();  <br><span class="hljs-comment">// 线程挂起实现使用的 condition 队列，当前代所有线程到位，这个条件队列内的线程才会被唤醒  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">trip</span> <span class="hljs-operator">=</span> lock.newCondition();<br></code></pre></td></tr></table></figure></li><li><p>线程数量：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> parties;<span class="hljs-comment">// 代表多少个线程到达屏障开始触发线程任务  </span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> count;<span class="hljs-comment">// 表示当前“代”还有多少个线程未到位，初始值为 parties</span><br></code></pre></td></tr></table></figure></li><li><p>当前代中最后一个线程到位后要执行的事件：</p><p>  <code>private final Runnable barrierCommand;</code></p></li><li><p>代：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// 表示 barrier 对象当前 代  </span><br><span class="hljs-keyword">private</span> <span class="hljs-type">Generation</span> <span class="hljs-variable">generation</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Generation</span>();  <br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Generation</span> &#123;  <br>    <span class="hljs-comment">// 表示当前“代”是否被打破，如果被打破再来到这一代的线程 就会直接抛出 BrokenException 异常  </span><br>    <span class="hljs-comment">// 且在这一代挂起的线程都会被唤醒，然后抛出 BrokerException 异常。  </span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">broken</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>构造方法：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">CyclicBarrie</span><span class="hljs-params">(<span class="hljs-type">int</span> parties, Runnable barrierAction)</span> &#123;  <br>    <span class="hljs-comment">// 因为小于等于 0 的 barrier 没有任何意义  </span><br>    <span class="hljs-keyword">if</span> (parties &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();  <br>  <br>    <span class="hljs-built_in">this</span>.parties = parties;  <br>    <span class="hljs-built_in">this</span>.count = parties;  <br>    <span class="hljs-comment">// 可以为 null  </span><br>    <span class="hljs-built_in">this</span>.barrierCommand = barrierAction;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041913080.png"></p><hr><h5 id="成员方法-5"><a href="#成员方法-5" class="headerlink" title="成员方法"></a>成员方法</h5><ul><li><p>await()：阻塞等待所有线程到位</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, BrokenBarrierException &#123;  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-keyword">return</span> dowait(<span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);  <br>    &#125; <span class="hljs-keyword">catch</span> (TimeoutException toe) &#123;  <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(toe); <span class="hljs-comment">// cannot happen  </span><br>    &#125;  <br>&#125;<br><br><span class="hljs-comment">// timed：表示当前调用await方法的线程是否指定了超时时长，如果 true 表示线程是响应超时的  </span><br><span class="hljs-comment">// nanos：线程等待超时时长，单位是纳秒  </span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dowait</span><span class="hljs-params">(<span class="hljs-type">boolean</span> timed, <span class="hljs-type">long</span> nanos)</span> &#123;  <br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;  <br>    <span class="hljs-comment">// 加锁  </span><br>    lock.lock();  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-comment">// 获取当前代  </span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Generation</span> <span class="hljs-variable">g</span> <span class="hljs-operator">=</span> generation;  <br>​  <br>        <span class="hljs-comment">// 【如果当前代是已经被打破状态，则当前调用await方法的线程，直接抛出Broken异常】  </span><br>        <span class="hljs-keyword">if</span> (g.broken)  <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BrokenBarrierException</span>();  <br>        <span class="hljs-comment">// 如果当前线程被中断了，则打破当前代，然后当前线程抛出中断异常  </span><br>        <span class="hljs-keyword">if</span> (Thread.interrupted()) &#123;  <br>            <span class="hljs-comment">// 设置当前代的状态为 broken 状态，唤醒在 trip 条件队列内的线程  </span><br>            breakBarrier();  <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();  <br>        &#125;  <br>​  <br>        <span class="hljs-comment">// 逻辑到这说明，当前线程中断状态是 false， 当前代的 broken 为 false（未打破状态）  </span><br>          <br>        <span class="hljs-comment">// 假设 parties 给的是 5，那么index对应的值为 4,3,2,1,0  </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> --count;  <br>        <span class="hljs-comment">// 条件成立说明当前线程是最后一个到达 barrier 的线程，【需要开启新代，唤醒阻塞线程】  </span><br>        <span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span>) &#123;  <br>            <span class="hljs-comment">// 栅栏任务启动标记  </span><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">ranAction</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;  <br>            <span class="hljs-keyword">try</span> &#123;  <br>                <span class="hljs-keyword">final</span> <span class="hljs-type">Runnable</span> <span class="hljs-variable">command</span> <span class="hljs-operator">=</span> barrierCommand;  <br>                <span class="hljs-keyword">if</span> (command != <span class="hljs-literal">null</span>)  <br>                    <span class="hljs-comment">// 启动触发的任务  </span><br>                    command.run();  <br>                <span class="hljs-comment">// run()未抛出异常的话，启动标记设置为 true  </span><br>                ranAction = <span class="hljs-literal">true</span>;  <br>                <span class="hljs-comment">// 开启新的一代，这里会【唤醒所有的阻塞队列】  </span><br>                nextGeneration();  <br>                <span class="hljs-comment">// 返回 0 因为当前线程是此代最后一个到达的线程，index == 0  </span><br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>            &#125; <span class="hljs-keyword">finally</span> &#123;  <br>                <span class="hljs-comment">// 如果 command.run() 执行抛出异常的话，会进入到这里  </span><br>                <span class="hljs-keyword">if</span> (!ranAction)  <br>                    breakBarrier();  <br>            &#125;  <br>        &#125;  <br>​  <br>        <span class="hljs-comment">// 自旋，一直到条件满足、当前代被打破、线程被中断，等待超时  </span><br>        <span class="hljs-keyword">for</span> (;;) &#123;  <br>            <span class="hljs-keyword">try</span> &#123;  <br>                <span class="hljs-comment">// 根据是否需要超时等待选择阻塞方法  </span><br>                <span class="hljs-keyword">if</span> (!timed)  <br>                    <span class="hljs-comment">// 当前线程释放掉 lock，【进入到 trip 条件队列的尾部挂起自己】，等待被唤醒  </span><br>                    trip.await();  <br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nanos &gt; <span class="hljs-number">0L</span>)  <br>                    nanos = trip.awaitNanos(nanos);  <br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException ie) &#123;  <br>                <span class="hljs-comment">// 被中断后来到这里的逻辑  </span><br>                  <br>                <span class="hljs-comment">// 当前代没有变化并且没有被打破  </span><br>                <span class="hljs-keyword">if</span> (g == generation &amp;&amp; !g.broken) &#123;  <br>                    <span class="hljs-comment">// 打破屏障  </span><br>                    breakBarrier();  <br>                    <span class="hljs-comment">// node 节点在【条件队列】内收到中断信号时 会抛出中断异常  </span><br>                    <span class="hljs-keyword">throw</span> ie;  <br>                &#125; <span class="hljs-keyword">else</span> &#123;  <br>                    <span class="hljs-comment">// 等待过程中代变化了，完成一次自我打断  </span><br>                    Thread.currentThread().interrupt();  <br>                &#125;  <br>            &#125;  <br>            <span class="hljs-comment">// 唤醒后的线程，【判断当前代已经被打破，线程唤醒后依次抛出 BrokenBarrier 异常】  </span><br>            <span class="hljs-keyword">if</span> (g.broken)  <br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BrokenBarrierException</span>();  <br>​  <br>            <span class="hljs-comment">// 当前线程挂起期间，最后一个线程到位了，然后触发了开启新的一代的逻辑  </span><br>            <span class="hljs-keyword">if</span> (g != generation)  <br>                <span class="hljs-keyword">return</span> index;  <br>            <span class="hljs-comment">// 当前线程 trip 中等待超时，然后主动转移到阻塞队列  </span><br>            <span class="hljs-keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="hljs-number">0L</span>) &#123;  <br>                breakBarrier();  <br>                <span class="hljs-comment">// 抛出超时异常  </span><br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimeoutException</span>();  <br>            &#125;  <br>        &#125;  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        <span class="hljs-comment">// 解锁  </span><br>        lock.unlock();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>breakBarrier()：打破 Barrier 屏障</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">breakBarrier</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">// 将代中的 broken 设置为 true，表示这一代是被打破了，再来到这一代的线程，直接抛出异常  </span><br>    generation.broken = <span class="hljs-literal">true</span>;  <br>    <span class="hljs-comment">// 重置 count 为 parties  </span><br>    count = parties;  <br>    <span class="hljs-comment">// 将在trip条件队列内挂起的线程全部唤醒，唤醒后的线程会检查当前是否是打破的，然后抛出异常  </span><br>    trip.signalAll();  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>nextGeneration()：开启新的下一代</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">nextGeneration</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">// 将在 trip 条件队列内挂起的线程全部唤醒  </span><br>    trip.signalAll();  <br>    <span class="hljs-comment">// 重置 count 为 parties  </span><br>    count = parties;  <br>  <br>    <span class="hljs-comment">// 开启新的一代，使用一个新的generation对象，表示新的一代，新的一代和上一代【没有任何关系】  </span><br>    generation = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Generation</span>();  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><h4 id="基本使用-8"><a href="#基本使用-8" class="headerlink" title="基本使用"></a>基本使用</h4><p>synchronized 可以起到锁的作用，但某个时间段内，只能有一个线程允许执行</p><p>Semaphore（信号量）用来限制能同时访问共享资源的线程上限，非重入锁</p><p>构造方法：</p><ul><li><p><code>public Semaphore(int permits)</code>：permits 表示许可线程的数量（state）</p></li><li><p><code>public Semaphore(int permits, boolean fair)</code>：fair 表示公平性，如果设为 true，下次执行的线程会是等待最久的线程</p></li></ul><p>常用API：</p><ul><li><p><code>public void acquire()</code>：表示获取许可</p></li><li><p><code>public void release()</code>：表示释放许可，acquire() 和 release() 方法之间的代码为同步代码</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    <span class="hljs-comment">// 1.创建Semaphore对象  </span><br>    <span class="hljs-type">Semaphore</span> <span class="hljs-variable">semaphore</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">3</span>);  <br>  <br>    <span class="hljs-comment">// 2. 10个线程同时运行  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;  <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>            <span class="hljs-keyword">try</span> &#123;  <br>                <span class="hljs-comment">// 3. 获取许可  </span><br>                semaphore.acquire();  <br>                sout(Thread.currentThread().getName() + <span class="hljs-string">&quot; running...&quot;</span>);  <br>                Thread.sleep(<span class="hljs-number">1000</span>);  <br>                sout(Thread.currentThread().getName() + <span class="hljs-string">&quot; end...&quot;</span>);  <br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>                e.printStackTrace();  <br>            &#125; <span class="hljs-keyword">finally</span> &#123;  <br>                <span class="hljs-comment">// 4. 释放许可  </span><br>                semaphore.release();  <br>            &#125;  <br>        &#125;).start();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="实现原理-8"><a href="#实现原理-8" class="headerlink" title="实现原理"></a>实现原理</h4><p>加锁流程：</p><ul><li><p>Semaphore 的 permits（state）为 3，这时 5 个线程来获取资源</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Sync(<span class="hljs-type">int</span> permits) &#123;  <br>    setState(permits);  <br>&#125;<br></code></pre></td></tr></table></figure><p>  假设其中 Thread-1，Thread-2，Thread-4 CAS 竞争成功，permits 变为 0，而 Thread-0 和 Thread-3 竞争失败，进入 AQS 队列park 阻塞</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// acquire() -&gt; sync.acquireSharedInterruptibly(1)，可中断  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireSharedInterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;  <br>    <span class="hljs-keyword">if</span> (Thread.interrupted())  <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();  <br>    <span class="hljs-comment">// 尝试获取通行证，获取成功返回 &gt;= 0的值  </span><br>    <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)  <br>        <span class="hljs-comment">// 获取许可证失败，进入阻塞  </span><br>        doAcquireSharedInterruptibly(arg);  <br>&#125;  <br>  <br><span class="hljs-comment">// tryAcquireShared() -&gt; nonfairTryAcquireShared()  </span><br><span class="hljs-comment">// 非公平，公平锁会在循环内 hasQueuedPredecessors()方法判断阻塞队列是否有临头节点(第二个节点)  </span><br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nonfairTryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;  <br>    <span class="hljs-keyword">for</span> (;;) &#123;  <br>        <span class="hljs-comment">// 获取 state ，state 这里【表示通行证】  </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">available</span> <span class="hljs-operator">=</span> getState();  <br>        <span class="hljs-comment">// 计算当前线程获取通行证完成之后，通行证还剩余数量  </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">remaining</span> <span class="hljs-operator">=</span> available - acquires;  <br>        <span class="hljs-comment">// 如果许可已经用完, 返回负数, 表示获取失败,  </span><br>        <span class="hljs-keyword">if</span> (remaining &lt; <span class="hljs-number">0</span> ||  <br>            <span class="hljs-comment">// 许可证足够分配的，如果 cas 重试成功, 返回正数, 表示获取成功  </span><br>            compareAndSetState(available, remaining))  <br>            <span class="hljs-keyword">return</span> remaining;  <br>    &#125;  <br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAcquireSharedInterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;  <br>    <span class="hljs-comment">// 将调用 Semaphore.aquire 方法的线程，包装成 node 加入到 AQS 的阻塞队列中  </span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addWaiter(Node.SHARED);  <br>    <span class="hljs-comment">// 获取标记  </span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-keyword">for</span> (;;) &#123;  <br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();  <br>            <span class="hljs-comment">// 前驱节点是头节点可以再次获取许可  </span><br>            <span class="hljs-keyword">if</span> (p == head) &#123;  <br>                <span class="hljs-comment">// 再次尝试获取许可，【返回剩余的许可证数量】  </span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> tryAcquireShared(arg);  <br>                <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;  <br>                    <span class="hljs-comment">// 成功后本线程出队（AQS）, 所在 Node设置为 head  </span><br>                    <span class="hljs-comment">// r 表示【可用资源数】, 为 0 则不会继续传播  </span><br>                    setHeadAndPropagate(node, r);   <br>                    p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC  </span><br>                    failed = <span class="hljs-literal">false</span>;  <br>                    <span class="hljs-keyword">return</span>;  <br>                &#125;  <br>            &#125;  <br>            <span class="hljs-comment">// 不成功, 设置上一个节点 waitStatus = Node.SIGNAL, 下轮进入 park 阻塞  </span><br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())  <br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();  <br>        &#125;  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        <span class="hljs-comment">// 被打断后进入该逻辑  </span><br>        <span class="hljs-keyword">if</span> (failed)  <br>            cancelAcquire(node);  <br>    &#125;  <br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setHeadAndPropagate</span><span class="hljs-params">(Node node, <span class="hljs-type">int</span> propagate)</span> &#123;      <br>    <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;  <br>    <span class="hljs-comment">// 设置自己为 head 节点  </span><br>    setHead(node);  <br>    <span class="hljs-comment">// propagate 表示有【共享资源】（例如共享读锁或信号量）  </span><br>    <span class="hljs-comment">// head waitStatus == Node.SIGNAL 或 Node.PROPAGATE，doReleaseShared 函数中设置的  </span><br>    <span class="hljs-keyword">if</span> (propagate &gt; <span class="hljs-number">0</span> || h == <span class="hljs-literal">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span> ||  <br>        (h = head) == <span class="hljs-literal">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span>) &#123;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;  <br>        <span class="hljs-comment">// 如果是最后一个节点或者是等待共享读锁的节点，做一次唤醒  </span><br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.isShared())  <br>            doReleaseShared();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041916624.png"></p></li><li><p>这时 Thread-4 释放了 permits，状态如下</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// release() -&gt; releaseShared()  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">releaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;  <br>    <span class="hljs-comment">// 尝试释放锁  </span><br>    <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;  <br>        doReleaseShared();  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    &#125;      <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>&#125;  <br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;      <br>    <span class="hljs-keyword">for</span> (;;) &#123;  <br>        <span class="hljs-comment">// 获取当前锁资源的可用许可证数量  </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> getState();  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> current + releases;  <br>        <span class="hljs-comment">// 索引越界判断  </span><br>        <span class="hljs-keyword">if</span> (next &lt; current)              <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum permit count exceeded&quot;</span>);          <br>        <span class="hljs-comment">// 释放锁  </span><br>        <span class="hljs-keyword">if</span> (compareAndSetState(current, next))              <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;      <br>    &#125;  <br>&#125;  <br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doReleaseShared</span><span class="hljs-params">()</span> &#123;      <br>    <span class="hljs-comment">// PROPAGATE 详解      </span><br>    <span class="hljs-comment">// 如果 head.waitStatus == Node.SIGNAL ==&gt; 0 成功, 下一个节点 unpark  </span><br>    <span class="hljs-comment">// 如果 head.waitStatus == 0 ==&gt; Node.PROPAGATE  </span><br>&#125;<br></code></pre></td></tr></table></figure><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041917776.png"></p></li><li><p>接下来 Thread-0 竞争成功，permits 再次设置为 0，设置自己为 head 节点，并且 unpark 接下来的共享状态的 Thread-3 节点，但由于 permits 是 0，因此 Thread-3 在尝试不成功后再次进入 park 状态</p></li></ul><hr><h4 id="PROPAGATE"><a href="#PROPAGATE" class="headerlink" title="PROPAGATE"></a>PROPAGATE</h4><p>假设存在某次循环中队列里排队的结点情况为 <code>head(-1) → t1(-1) → t2(0)</code>，存在将要释放信号量的 T3 和 T4，释放顺序为先 T3 后 T4</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// 老版本代码  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setHeadAndPropagate</span><span class="hljs-params">(Node node, <span class="hljs-type">int</span> propagate)</span> &#123;      <br>    setHead(node);      <br>    <span class="hljs-comment">// 有空闲资源      </span><br>    <span class="hljs-keyword">if</span> (propagate &gt; <span class="hljs-number">0</span> &amp;&amp; node.waitStatus != <span class="hljs-number">0</span>) &#123;      <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;          <br>        <span class="hljs-comment">// 下一个          </span><br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.isShared())              <br>            unparkSuccessor(node);          <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>正常流程：</p><ul><li><p>T3 调用 releaseShared(1)，直接调用了 unparkSuccessor(head)，head.waitStatus 从 -1 变为 0</p></li><li><p>T1 由于 T3 释放信号量被唤醒，然后 T4 释放，唤醒 T2</p></li></ul><p>BUG 流程：</p><ul><li><p>T3 调用 releaseShared(1)，直接调用了 unparkSuccessor(head)，head.waitStatus 从 -1 变为 0</p></li><li><p>T1 由于 T3 释放信号量被唤醒，调用 tryAcquireShared，返回值为 0（获取锁成功，但没有剩余资源量）</p></li><li><p>T1 还没调用 setHeadAndPropagate 方法，T4 调用 releaseShared(1)，此时 head.waitStatus 为 0（此时读到的 head 和 1 中为同一个 head），不满足条件，因此不调用 unparkSuccessor(head)</p></li><li><p>T1 获取信号量成功，调用 setHeadAndPropagate(t1.node, 0) 时，因为不满足 propagate &gt; 0（剩余资源量 &#x3D;&#x3D; 0），从而不会唤醒后继结点， <strong>T2 线程得不到唤醒</strong></p></li></ul><p>更新后流程：</p><ul><li><p>T3 调用 releaseShared(1)，直接调用了 unparkSuccessor(head)，head.waitStatus 从 -1 变为 0</p></li><li><p>T1 由于 T3 释放信号量被唤醒，调用 tryAcquireShared，返回值为 0（获取锁成功，但没有剩余资源量）</p></li><li><p>T1 还没调用 setHeadAndPropagate 方法，T4 调用 releaseShared()，此时 head.waitStatus 为 0（此时读到的 head 和 1 中为同一个 head），调用 doReleaseShared() 将等待状态置为 <strong>PROPAGATE（-3）</strong></p></li><li><p>T1 获取信号量成功，调用 setHeadAndPropagate 时，读到 h.waitStatus &lt; 0，从而调用 doReleaseShared() 唤醒 T2</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setHeadAndPropagate</span><span class="hljs-params">(Node node, <span class="hljs-type">int</span> propagate)</span> &#123;      <br>    <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;  <br>    <span class="hljs-comment">// 设置自己为 head 节点  </span><br>    setHead(node);  <br>    <span class="hljs-comment">// propagate 表示有共享资源（例如共享读锁或信号量）  </span><br>    <span class="hljs-comment">// head waitStatus == Node.SIGNAL 或 Node.PROPAGATE  </span><br>    <span class="hljs-keyword">if</span> (propagate &gt; <span class="hljs-number">0</span> || h == <span class="hljs-literal">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span> ||  <br>        (h = head) == <span class="hljs-literal">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span>) &#123;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;  <br>        <span class="hljs-comment">// 如果是最后一个节点或者是等待共享读锁的节点，做一次唤醒  </span><br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.isShared())  <br>            doReleaseShared();  <br>    &#125;  <br>&#125;<br><br><span class="hljs-comment">// 唤醒  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doReleaseShared</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">// 如果 head.waitStatus == Node.SIGNAL ==&gt; 0 成功, 下一个节点 unpark  </span><br>    <span class="hljs-comment">// 如果 head.waitStatus == 0 ==&gt; Node.PROPAGATE      </span><br>    <span class="hljs-keyword">for</span> (;;) &#123;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;  <br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h != tail) &#123;  <br>            <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> h.waitStatus;  <br>            <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;  <br>                <span class="hljs-comment">// 防止 unparkSuccessor 被多次执行  </span><br>                <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>))  <br>                    <span class="hljs-keyword">continue</span>;  <br>                <span class="hljs-comment">// 唤醒后继节点  </span><br>                unparkSuccessor(h);  <br>            &#125;  <br>            <span class="hljs-comment">// 如果已经是 0 了，改为 -3，用来解决传播性  </span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp; !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))  <br>                <span class="hljs-keyword">continue</span>;  <br>        &#125;  <br>        <span class="hljs-keyword">if</span> (h == head)  <br>            <span class="hljs-keyword">break</span>;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h3><p>Exchanger：交换器，是一个用于线程间协作的工具类，用于进行线程间的数据交换</p><p>工作流程：两个线程通过 exchange 方法交换数据，如果第一个线程先执行 exchange() 方法，它会一直等待第二个线程也执行 exchange 方法，当两个线程都到达同步点时，这两个线程就可以交换数据</p><p>常用方法：</p><ul><li><p><code>public Exchanger()</code>：创建一个新的交换器</p></li><li><p><code>public V exchange(V x)</code>：等待另一个线程到达此交换点</p></li><li><p><code>public V exchange(V x, long timeout, TimeUnit unit)</code>：等待一定的时间</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExchangerDemo</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-comment">// 创建交换对象（信使）  </span><br>        Exchanger&lt;String&gt; exchanger = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exchanger</span>&lt;&gt;();  <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadA</span>(exchanger).start();  <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadB</span>(exchanger).start();  <br>    &#125;   <br>&#125;  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;  <br>    <span class="hljs-keyword">private</span> Exchanger&lt;String&gt; <span class="hljs-title function_">exchanger</span><span class="hljs-params">()</span>;  <br>      <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadA</span><span class="hljs-params">(Exchanger&lt;String&gt; exchanger)</span>&#123;  <br>        <span class="hljs-built_in">this</span>.exchanger = exchanger;  <br>    &#125;  <br>      <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">try</span>&#123;  <br>            sout(<span class="hljs-string">&quot;线程A，做好了礼物A，等待线程B送来的礼物B&quot;</span>);  <br>            <span class="hljs-comment">//如果等待了5s还没有交换就死亡（抛出异常）！  </span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> exchanger.exchange(<span class="hljs-string">&quot;礼物A&quot;</span>,<span class="hljs-number">5</span>,TimeUnit.SECONDS);  <br>            sout(<span class="hljs-string">&quot;线程A收到线程B的礼物：&quot;</span> + s);  <br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;  <br>            System.out.println(<span class="hljs-string">&quot;线程A等待了5s，没有收到礼物,最终就执行结束了!&quot;</span>);  <br>        &#125;  <br>    &#125;  <br>&#125;  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;  <br>    <span class="hljs-keyword">private</span> Exchanger&lt;String&gt; exchanger;  <br>      <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadB</span><span class="hljs-params">(Exchanger&lt;String&gt; exchanger)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.exchanger = exchanger;  <br>    &#125;  <br>      <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            sout(<span class="hljs-string">&quot;线程B,做好了礼物B,等待线程A送来的礼物A.....&quot;</span>);  <br>            <span class="hljs-comment">// 开始交换礼物。参数是送给其他线程的礼物!  </span><br>            sout(<span class="hljs-string">&quot;线程B收到线程A的礼物：&quot;</span> + exchanger.exchange(<span class="hljs-string">&quot;礼物B&quot;</span>));  <br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;  <br>            e.printStackTrace();  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并发</tag>
      
      <tag>JVM</tag>
      
      <tag>内存模型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于并发编程（上）</title>
    <link href="/posts/6aabc494/"/>
    <url>/posts/6aabc494/</url>
    
    <content type="html"><![CDATA[<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402211423293.png"></p><hr><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>进程：程序是静止的，进程实体的运行过程就是进程，是系统进行<strong>资源分配的基本单位</strong></p><p>进程的特征：并发性、异步性、动态性、独立性、结构性</p><p><strong>线程</strong>：线程是属于进程的，是一个基本的 CPU 执行单元，是程序执行流的最小单元。线程是进程中的一个实体，是系统<strong>独立调度的基本单位</strong>，线程本身不拥有系统资源，只拥有一点在运行中必不可少的资源，与同属一个进程的其他线程共享进程所拥有的全部资源</p><p>关系：一个进程可以包含多个线程，这就是多线程，比如看视频是进程，图画、声音、广告等就是多个线程</p><p>线程的作用：使多道程序更好的并发执行，提高资源利用率和系统吞吐量，增强操作系统的并发性能</p><p>并发并行：</p><ul><li><p>并行：在同一时刻，有多个指令在多个 CPU 上同时执行</p></li><li><p>并发：在同一时刻，有多个指令在单个 CPU 上交替执行</p></li></ul><p>同步异步：</p><ul><li><p>需要等待结果返回，才能继续运行就是同步</p></li><li><p>不需要等待结果返回，就能继续运行就是异步</p></li></ul><hr><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>线程进程对比：</p><ul><li><p>进程基本上相互独立的，而线程存在于进程内，是进程的一个子集</p></li><li><p>进程拥有共享的资源，如内存空间等，供其<strong>内部的线程共享</strong></p></li><li><p>进程间通信较为复杂</p><p>  同一台计算机的进程通信称为 IPC（Inter-process communication）</p><ul><li><p>信号量：信号量是一个计数器，用于多进程对共享数据的访问，解决同步相关的问题并避免竞争条件</p></li><li><p>共享存储：多个进程可以访问同一块内存空间，需要使用信号量用来同步对共享存储的访问</p></li><li><p>管道通信：管道是用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件 pipe 文件，该文件同一时间只允许一个进程访问，所以只支持<strong>半双工通信</strong></p><ul><li><p>匿名管道（Pipes）：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信</p></li><li><p>命名管道（Names Pipes）：以磁盘文件的方式存在，可以实现本机任意两个进程通信，遵循 FIFO</p></li></ul></li><li><p>消息队列：内核中存储消息的链表，由消息队列标识符标识，能在不同进程之间提供<strong>全双工通信</strong>，对比管道：</p><ul><li><p>匿名管道存在于内存中的文件；命名管道存在于实际的磁盘介质或者文件系统；消息队列存放在内核中，只有在内核重启（操作系统重启）或者显示地删除一个消息队列时，该消息队列才被真正删除</p></li><li><p>读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收</p></li></ul></li></ul><p>  不同计算机之间的<strong>进程通信</strong>，需要通过网络，并遵守共同的协议，例如 HTTP</p><ul><li>套接字：与其它通信机制不同的是，可用于不同机器间的互相通信</li></ul></li><li><p>线程通信相对简单，因为线程之间共享进程内的内存，一个例子是多个线程可以访问同一个共享变量</p><p>  <strong>Java 中的通信机制</strong>：volatile、等待&#x2F;通知机制、join 方式、InheritableThreadLocal、MappedByteBuffer</p></li><li><p>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低</p></li></ul><hr><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><h4 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h4><p>Thread 创建线程方式：创建线程类，匿名内部类方式</p><ul><li><p><strong>start() 方法底层其实是给 CPU 注册当前线程，并且触发 run() 方法执行</strong></p></li><li><p>线程的启动必须调用 start() 方法，如果线程直接调用 run() 方法，相当于变成了普通类的执行，此时主线程将只有执行该线程</p></li><li><p>建议线程先创建子线程，主线程的任务放在之后，否则主线程（main）永远是先执行完</p></li></ul><p>Thread 构造器：</p><ul><li><p><code>public Thread()</code></p></li><li><p><code>public Thread(String name)</code></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadDemo</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();  <br>        t.start();  <br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">100</span> ; i++ )&#123;  <br>            System.out.println(<span class="hljs-string">&quot;main线程&quot;</span> + i)  <br>        &#125;  <br>        <span class="hljs-comment">// main线程输出放在上面 就变成有先后顺序了，因为是 main 线程驱动的子线程运行  </span><br>    &#125;  <br>&#125;  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">100</span> ; i++ ) &#123;  <br>            System.out.println(<span class="hljs-string">&quot;子线程输出：&quot;</span>+i)  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>继承 Thread 类的优缺点：</p><ul><li><p>优点：编码简单</p></li><li><p>缺点：线程类已经继承了 Thread 类无法继承其他类了，功能不能通过继承拓展（单继承的局限性）</p></li></ul><hr><h4 id="Runnable"><a href="#Runnable" class="headerlink" title="Runnable"></a>Runnable</h4><p>Runnable 创建线程方式：创建线程类，匿名内部类方式</p><p>Thread 的构造器：</p><ul><li><p><code>public Thread(Runnable target)</code></p></li><li><p><code>public Thread(Runnable target, String name)</code></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadDemo</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>();  <br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(target,<span class="hljs-string">&quot;1号线程&quot;</span>);  <br>t1.start();  <br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(target);<span class="hljs-comment">//Thread-0  </span><br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">10</span> ; i++ )&#123;  <br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;-&gt;&quot;</span> + i);  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Thread 类本身也是实现了 Runnable 接口</strong>，Thread 类中持有 Runnable 的属性，执行线程 run 方法底层是调用 Runnable run：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;  <br>    <span class="hljs-keyword">private</span> Runnable target;  <br>      <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">if</span> (target != <span class="hljs-literal">null</span>) &#123;  <br>          <span class="hljs-comment">// 底层调用的是 Runnable 的 run 方法  </span><br>            target.run();  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>Runnable 方式的优缺点：</p><ul><li><p>缺点：代码复杂一点。</p></li><li><p>优点：</p><ol><li><p>线程任务类只是实现了 Runnable 接口，可以继续继承其他类，避免了单继承的局限性</p></li><li><p>同一个线程任务对象可以被包装成多个线程对象</p></li><li><p>适合多个多个线程去共享同一个资源</p></li><li><p>实现解耦操作，线程任务代码可以被多个线程共享，线程任务代码和线程独立</p></li><li><p>线程池可以放入实现 Runnable 或 Callable 线程任务对象</p></li></ol></li></ul><hr><h4 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h4><p>实现 Callable 接口：</p><ol><li><p>定义一个线程任务类实现 Callable 接口，申明线程执行的结果类型</p></li><li><p>重写线程任务类的 call 方法，这个方法可以直接返回执行的结果</p></li><li><p>创建一个 Callable 的线程任务对象</p></li><li><p>把 Callable 的线程任务对象<strong>包装成一个未来任务对象</strong></p></li><li><p>把未来任务对象包装成线程对象</p></li><li><p>调用线程的 start() 方法启动线程</p></li></ol><p><code>public FutureTask(Callable&lt;V&gt; callable)</code>：未来任务对象，在线程执行完后得到线程的执行结果</p><ul><li><p>FutureTask 就是 Runnable 对象，因为 <strong>Thread 类只能执行 Runnable 实例的任务对象</strong>，所以把 Callable 包装成未来任务对象</p></li><li><p>线程池部分详解了 FutureTask 的源码</p></li></ul><p><code>public V get()</code>：同步等待 task 执行完毕的结果，如果在线程中获取另一个线程执行结果，会阻塞等待，用于线程同步</p><ul><li><p>get() 线程会阻塞等待任务执行完成</p></li><li><p>run() 执行完后会把结果设置到 FutureTask 的一个成员变量，get() 线程可以获取到该变量的值</p></li></ul><p>优缺点：</p><ul><li><p>优点：同 Runnable，并且能得到线程执行的结果</p></li><li><p>缺点：编码复杂</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadDemo</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">Callable</span> <span class="hljs-variable">call</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>();  <br>        FutureTask&lt;String&gt; task = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(call);  <br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task);  <br>        t.start();  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> task.get(); <span class="hljs-comment">// 获取call方法返回的结果（正常/异常结果）  </span><br>            System.out.println(s);  <br>        &#125;  <span class="hljs-keyword">catch</span> (Exception e) &#123;  <br>            e.printStackTrace();  <br>        &#125;  <br>    &#125;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;String&gt; &#123;  <br>    <span class="hljs-meta">@Override</span><span class="hljs-comment">//重写线程任务类方法  </span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;  <br>        <span class="hljs-keyword">return</span> Thread.currentThread().getName() + <span class="hljs-string">&quot;-&gt;&quot;</span> + <span class="hljs-string">&quot;Hello World&quot;</span>;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="线程方法"><a href="#线程方法" class="headerlink" title="线程方法"></a>线程方法</h3><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><p>Thread 类 API：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public void start()</td><td>启动一个新线程，Java虚拟机调用此线程的 run 方法</td></tr><tr><td>public void run()</td><td>线程启动后调用该方法</td></tr><tr><td>public void setName(String name)</td><td>给当前线程取名字</td></tr><tr><td>public void getName()</td><td>获取当前线程的名字 线程存在默认名称：子线程是 Thread-索引，主线程是 main</td></tr><tr><td>public static Thread currentThread()</td><td>获取当前线程对象，代码在哪个线程中执行</td></tr><tr><td>public static void sleep(long time)</td><td>让当前线程休眠多少毫秒再继续执行 <strong>Thread.sleep(0)</strong> : 让操作系统立刻重新进行一次 CPU 竞争</td></tr><tr><td>public static native void yield()</td><td>提示线程调度器让出当前线程对 CPU 的使用</td></tr><tr><td>public final int getPriority()</td><td>返回此线程的优先级</td></tr><tr><td>public final void setPriority(int priority)</td><td>更改此线程的优先级，常用 1 5 10</td></tr><tr><td>public void interrupt()</td><td>中断这个线程，异常处理机制</td></tr><tr><td>public static boolean interrupted()</td><td>判断当前线程是否被打断，清除打断标记</td></tr><tr><td>public boolean isInterrupted()</td><td>判断当前线程是否被打断，不清除打断标记</td></tr><tr><td>public final void join()</td><td>等待这个线程结束</td></tr><tr><td>public final void join(long millis)</td><td>等待这个线程死亡 millis 毫秒，0 意味着永远等待</td></tr><tr><td>public final native boolean isAlive()</td><td>线程是否存活（还没有运行完毕）</td></tr><tr><td>public final void setDaemon(boolean on)</td><td>将此线程标记为守护线程或用户线程</td></tr></tbody></table><hr><h4 id="run-start"><a href="#run-start" class="headerlink" title="run start"></a>run start</h4><p>run：称为线程体，包含了要执行的这个线程的内容，方法运行结束，此线程随即终止。直接调用 run 是在主线程中执行了 run，没有启动新的线程，需要顺序执行</p><p>start：使用 start 是启动新的线程，此线程处于就绪（可运行）状态，通过新的线程间接执行 run 中的代码</p><p>说明：<strong>线程控制资源类</strong></p><p>run() 方法中的异常不能抛出，只能 try&#x2F;catch</p><ul><li><p>因为父类中没有抛出任何异常，子类不能比父类抛出更多的异常</p></li><li><p><strong>异常不能跨线程传播回 main() 中</strong>，因此必须在本地进行处理</p></li></ul><hr><h4 id="sleep-yield"><a href="#sleep-yield" class="headerlink" title="sleep yield"></a>sleep yield</h4><p>sleep：</p><ul><li><p>调用 sleep 会让当前线程从 <code>Running</code> 进入 <code>Timed Waiting</code> 状态（阻塞）</p></li><li><p>sleep() 方法的过程中，<strong>线程不会释放对象锁</strong></p></li><li><p>其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException</p></li><li><p>睡眠结束后的线程未必会立刻得到执行，需要抢占 CPU</p></li><li><p>建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性</p></li></ul><p>yield：</p><ul><li><p>调用 yield 会让提示线程调度器让出当前线程对 CPU 的使用</p></li><li><p>具体的实现依赖于操作系统的任务调度器</p></li><li><p><strong>会放弃 CPU 资源，锁资源不会释放</strong></p></li></ul><hr><h4 id="join"><a href="#join" class="headerlink" title="join"></a>join</h4><p>public final void join()：等待这个线程结束</p><p>原理：调用者轮询检查线程 alive 状态，t1.join() 等价于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">join</span><span class="hljs-params">(<span class="hljs-type">long</span> millis)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>    <span class="hljs-comment">// 调用者线程进入 thread 的 waitSet 等待, 直到当前线程运行结束  </span><br>    <span class="hljs-keyword">while</span> (isAlive()) &#123;  <br>        wait(<span class="hljs-number">0</span>);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>join 方法是被 synchronized 修饰的，本质上是一个对象锁，其内部的 wait 方法调用也是释放锁的，但是<strong>释放的是当前的线程对象锁，而不是外面的锁</strong></p></li><li><p>当调用某个线程（t1）的 join 方法后，该线程（t1）抢占到 CPU 资源，就不再释放，直到线程执行完毕</p></li></ul><p>线程同步：</p><ul><li><p>join 实现线程同步，因为会阻塞等待另一个线程的结束，才能继续向下运行</p><ul><li><p>需要外部共享变量，不符合面向对象封装的思想</p></li><li><p>必须等待线程结束，不能配合线程池使用</p></li></ul></li><li><p>Future 实现（同步）：get() 方法阻塞等待执行结果</p><ul><li><p>main 线程接收结果</p></li><li><p>get 方法是让调用线程同步等待</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;  <br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>        test1();  <br>    &#125;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>            <span class="hljs-keyword">try</span> &#123;  <br>                Thread.sleep(<span class="hljs-number">1000</span>);  <br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>                e.printStackTrace();  <br>            &#125;  <br>            r = <span class="hljs-number">10</span>;  <br>        &#125;);  <br>        t1.start();  <br>        t1.join();<span class="hljs-comment">//不等待线程执行结束，输出的10  </span><br>        System.out.println(r);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h4><h5 id="打断线程"><a href="#打断线程" class="headerlink" title="打断线程"></a>打断线程</h5><p><code>public void interrupt()</code>：打断这个线程，异常处理机制</p><p><code>public static boolean interrupted()</code>：判断当前线程是否被打断，打断返回 true，<strong>清除打断标记</strong>，连续调用两次一定返回 false</p><p><code>public boolean isInterrupted()</code>：判断当前线程是否被打断，不清除打断标记</p><p>打断的线程会发生上下文切换，操作系统会保存线程信息，抢占到 CPU 后会从中断的地方接着运行（打断不是停止）</p><ul><li>sleep、wait、join 方法都会让线程进入阻塞状态，打断线程<strong>会清空打断状态</strong>（false）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            Thread.sleep(<span class="hljs-number">1000</span>);  <br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>            e.printStackTrace();  <br>        &#125;  <br>    &#125;, <span class="hljs-string">&quot;t1&quot;</span>);  <br>    t1.start();  <br>    Thread.sleep(<span class="hljs-number">500</span>);  <br>    t1.interrupt();  <br>    System.out.println(<span class="hljs-string">&quot; 打断状态: &#123;&#125;&quot;</span> + t1.isInterrupted());<span class="hljs-comment">// 打断状态: &#123;&#125;false  </span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>打断正常运行的线程：不会清空打断状态（true）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;  <br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;  <br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;  <br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();  <br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> current.isInterrupted();  <br>            <span class="hljs-keyword">if</span>(interrupted) &#123;  <br>                System.out.println(<span class="hljs-string">&quot; 打断状态: &#123;&#125;&quot;</span> + interrupted);<span class="hljs-comment">//打断状态: &#123;&#125;true  </span><br>                <span class="hljs-keyword">break</span>;  <br>            &#125;  <br>        &#125;  <br>    &#125;, <span class="hljs-string">&quot;t2&quot;</span>);  <br>    t2.start();  <br>    Thread.sleep(<span class="hljs-number">500</span>);  <br>    t2.interrupt();  <br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h5 id="打断-park"><a href="#打断-park" class="headerlink" title="打断 park"></a>打断 park</h5><p>park 作用类似 sleep，打断 park 线程，不会清空打断状态（true）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;  <br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>        System.out.println(<span class="hljs-string">&quot;park...&quot;</span>);  <br>        LockSupport.park();  <br>        System.out.println(<span class="hljs-string">&quot;unpark...&quot;</span>);  <br>        System.out.println(<span class="hljs-string">&quot;打断状态：&quot;</span> + Thread.currentThread().isInterrupted());<span class="hljs-comment">//打断状态：true  </span><br>    &#125;, <span class="hljs-string">&quot;t1&quot;</span>);  <br>    t1.start();  <br>    Thread.sleep(<span class="hljs-number">2000</span>);  <br>    t1.interrupt();  <br>&#125;<br></code></pre></td></tr></table></figure><p>如果打断标记已经是 true, 则 park 会失效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">LockSupport.park();  <br>System.out.println(<span class="hljs-string">&quot;unpark...&quot;</span>);  <br>LockSupport.park();<span class="hljs-comment">//失效，不会阻塞  </span><br>System.out.println(<span class="hljs-string">&quot;unpark...&quot;</span>);<span class="hljs-comment">//和上一个unpark同时执行</span><br></code></pre></td></tr></table></figure><p>可以修改获取打断状态方法，使用 <code>Thread.interrupted()</code>，清除打断标记</p><p>LockSupport 类在 同步 → park-un 详解</p><hr><h5 id="终止模式"><a href="#终止模式" class="headerlink" title="终止模式"></a>终止模式</h5><p>终止模式之两阶段终止模式：Two Phase Termination</p><p>目标：在一个线程 T1 中如何优雅终止线程 T2？优雅指的是给 T2 一个后置处理器</p><p>错误思想：</p><ul><li><p>使用线程对象的 stop() 方法停止线程：stop 方法会真正杀死线程，如果这时线程锁住了共享资源，当它被杀死后就再也没有机会释放锁，其它线程将永远无法获取锁</p></li><li><p>使用 System.exit(int) 方法停止线程：目的仅是停止一个线程，但这种做法会让整个程序都停止</p></li></ul><p>两阶段终止模式图示：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041617846.png"></p><p>打断线程可能在任何时间，所以需要考虑在任何时刻被打断的处理方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>        <span class="hljs-type">TwoPhaseTermination</span> <span class="hljs-variable">tpt</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TwoPhaseTermination</span>();  <br>        tpt.start();  <br>        Thread.sleep(<span class="hljs-number">3500</span>);  <br>        tpt.stop();  <br>    &#125;  <br>&#125;  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TwoPhaseTermination</span> &#123;  <br>    <span class="hljs-keyword">private</span> Thread monitor;  <br>    <span class="hljs-comment">// 启动监控线程  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;  <br>        monitor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;  <br>            <span class="hljs-meta">@Override</span>  <br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;  <br>                    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> Thread.currentThread();  <br>                    <span class="hljs-keyword">if</span> (thread.isInterrupted()) &#123;  <br>                        System.out.println(<span class="hljs-string">&quot;后置处理&quot;</span>);  <br>                        <span class="hljs-keyword">break</span>;  <br>                    &#125;  <br>                    <span class="hljs-keyword">try</span> &#123;  <br>                        Thread.sleep(<span class="hljs-number">1000</span>);<span class="hljs-comment">// 睡眠  </span><br>                        System.out.println(<span class="hljs-string">&quot;执行监控记录&quot;</span>);<span class="hljs-comment">// 在此被打断不会异常  </span><br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<span class="hljs-comment">// 在睡眠期间被打断，进入异常处理的逻辑  </span><br>                        e.printStackTrace();  <br>                        <span class="hljs-comment">// 重新设置打断标记，打断 sleep 会清除打断状态  </span><br>                        thread.interrupt();  <br>                    &#125;  <br>                &#125;  <br>            &#125;  <br>        &#125;);  <br>        monitor.start();  <br>    &#125;  <br>    <span class="hljs-comment">// 停止监控线程  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">()</span> &#123;  <br>        monitor.interrupt();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="daemon"><a href="#daemon" class="headerlink" title="daemon"></a>daemon</h4><p><code>public final void setDaemon(boolean on)</code>：如果是 true ，将此线程标记为守护线程</p><p>线程<strong>启动前</strong>调用此方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>() &#123;  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;running&quot;</span>);  <br>    &#125;  <br>&#125;;  <br><span class="hljs-comment">// 设置该线程为守护线程  </span><br>t.setDaemon(<span class="hljs-literal">true</span>);  <br>t.start();<br></code></pre></td></tr></table></figure><p>用户线程：平常创建的普通线程</p><p>守护线程：服务于用户线程，只要其它非守护线程运行结束了，即使守护线程代码没有执行完，也会强制结束。守护进程是<strong>脱离于终端并且在后台运行的进程</strong>，脱离终端是为了避免在执行的过程中的信息在终端上显示</p><p>说明：当运行的线程都是守护线程，Java 虚拟机将退出，因为普通线程执行完后，JVM 是守护线程，不会继续运行下去</p><p>常见的守护线程：</p><ul><li><p>垃圾回收器线程就是一种守护线程</p></li><li><p>Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等待它们处理完当前请求</p></li></ul><hr><h4 id="不推荐"><a href="#不推荐" class="headerlink" title="不推荐"></a>不推荐</h4><p>不推荐使用的方法，这些方法已过时，容易破坏同步代码块，造成线程死锁：</p><ul><li><p><code>public final void stop()</code>：停止线程运行</p><p>  废弃原因：方法粗暴，除非可能执行 finally 代码块以及释放 synchronized 外，线程将直接被终止，如果线程持有 JUC 的互斥锁可能导致锁来不及释放，造成其他线程永远等待的局面</p></li><li><p><code>public final void suspend()</code>：<strong>挂起（暂停）线程运行</strong></p><p>  废弃原因：如果目标线程在暂停时对系统资源持有锁，则在目标线程恢复之前没有线程可以访问该资源，如果<strong>恢复目标线程的线程</strong>在调用 resume 之前会尝试访问此共享资源，则会导致死锁</p></li><li><p><code>public final void resume()</code>：恢复线程运行</p></li></ul><hr><h3 id="线程原理"><a href="#线程原理" class="headerlink" title="线程原理"></a>线程原理</h3><h4 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h4><p>Java Virtual Machine Stacks（Java 虚拟机栈）：每个线程启动后，虚拟机就会为其分配一块栈内存</p><ul><li><p>每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存</p></li><li><p>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</p></li></ul><p>线程上下文切换（Thread Context Switch）：一些原因导致 CPU 不再执行当前线程，转而执行另一个线程</p><ul><li><p>线程的 CPU 时间片用完</p></li><li><p>垃圾回收</p></li><li><p>有更高优先级的线程需要运行</p></li><li><p>线程自己调用了 sleep、yield、wait、join、park 等方法</p></li></ul><p>程序计数器（Program Counter Register）：记住下一条 JVM 指令的执行地址，是线程私有的</p><p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态（PCB 中），并恢复另一个线程的状态，包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等</p><p>JVM 规范并没有限定线程模型，以 HotSopot 为例：</p><ul><li><p>Java 的线程是内核级线程（1:1 线程模型），每个 Java 线程都映射到一个操作系统原生线程，需要消耗一定的内核资源（堆栈）</p></li><li><p><strong>线程的调度是在内核态运行的，而线程中的代码是在用户态运行</strong>，所以线程切换（状态改变）会导致用户与内核态转换进行系统调用，这是非常消耗性能</p></li></ul><p>Java 中 main 方法启动的是一个进程也是一个主线程，main 方法里面的其他线程均为子线程，main 线程是这些线程的父线程</p><hr><h4 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h4><p>线程调度指系统为线程分配处理器使用权的过程，方式有两种：协同式线程调度、抢占式线程调度（Java 选择）</p><p>协同式线程调度：线程的执行时间由线程本身控制</p><ul><li><p>优点：线程做完任务才通知系统切换到其他线程，相当于所有线程串行执行，不会出现线程同步问题</p></li><li><p>缺点：线程执行时间不可控，如果代码编写出现问题，可能导致程序一直阻塞，引起系统的奔溃</p></li></ul><p>抢占式线程调度：线程的执行时间由系统分配</p><ul><li><p>优点：线程执行时间可控，不会因为一个线程的问题而导致整体系统不可用</p></li><li><p>缺点：无法主动为某个线程多分配时间</p></li></ul><p>Java 提供了线程优先级的机制，优先级会提示（hint）调度器优先调度该线程，但这仅仅是一个提示，调度器可以忽略它。在线程的就绪状态时，如果 CPU 比较忙，那么优先级高的线程会获得更多的时间片，但 CPU 闲时，优先级几乎没作用</p><p>说明：并不能通过优先级来判断线程执行的先后顺序</p><hr><h4 id="未来优化"><a href="#未来优化" class="headerlink" title="未来优化"></a>未来优化</h4><p>内核级线程调度的成本较大，所以引入了更轻量级的协程。用户线程的调度由用户自己实现（多对一的线程模型，多<strong>个用户线程映射到一个内核级线程</strong>），被设计为协同式调度，所以叫协程</p><ul><li><p>有栈协程：协程会完整的做调用栈的保护、恢复工作，所以叫有栈协程</p></li><li><p>无栈协程：本质上是一种有限状态机，状态保存在闭包里，比有栈协程更轻量，但是功能有限</p></li></ul><p>有栈协程中有一种特例叫纤程，在新并发模型中，一段纤程的代码被分为两部分，执行过程和调度器：</p><ul><li><p>执行过程：用于维护执行现场，保护、恢复上下文状态</p></li><li><p>调度器：负责编排所有要执行的代码顺序</p></li></ul><hr><h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><p>进程的状态参考操作系统：创建态、就绪态、运行态、阻塞态、终止态</p><p>线程由生到死的完整过程（生命周期）：当线程被创建并启动以后，既不是一启动就进入了执行状态，也不是一直处于执行状态，在 API 中 <code>java.lang.Thread.State</code> 这个枚举中给出了六种线程状态：</p><table><thead><tr><th>线程状态</th><th>导致状态发生条件</th></tr></thead><tbody><tr><td>NEW（新建）</td><td>线程刚被创建，但是并未启动，还没调用 start 方法，只有线程对象，没有线程特征</td></tr><tr><td>Runnable（可运行）</td><td>线程可以在 Java 虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操作系统处理器，调用了 t.start() 方法：就绪（经典叫法）</td></tr><tr><td>Blocked（阻塞）</td><td>当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入 Blocked 状态；当该线程持有锁时，该线程将变成 Runnable 状态</td></tr><tr><td>Waiting（无限等待）</td><td>一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入 Waiting 状态，进入这个状态后不能自动唤醒，必须等待另一个线程调用 notify 或者 notifyAll 方法才能唤醒</td></tr><tr><td>Timed Waiting （限期等待）</td><td>有几个方法有超时参数，调用将进入 Timed Waiting 状态，这一状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有 Thread.sleep 、Object.wait</td></tr><tr><td>Teminated（结束）</td><td>run 方法正常退出而死亡，或者因为没有捕获的异常终止了 run 方法而死亡</td></tr></tbody></table><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041618351.png"></p><ul><li><p>NEW → RUNNABLE：当调用 t.start() 方法时，由 NEW → RUNNABLE</p></li><li><p>RUNNABLE &lt;–&gt; WAITING：</p><ul><li><p>调用 obj.wait() 方法时</p><p>  调用 obj.notify()、obj.notifyAll()、t.interrupt()：</p><ul><li><p>竞争锁成功，t 线程从 WAITING → RUNNABLE</p></li><li><p>竞争锁失败，t 线程从 WAITING → BLOCKED</p></li></ul></li><li><p>当前线程调用 t.join() 方法，注意是当前线程在 t 线程对象的监视器上等待</p></li><li><p>当前线程调用 LockSupport.park() 方法</p></li></ul></li><li><p>RUNNABLE &lt;–&gt; TIMED_WAITING：调用 obj.wait(long n) 方法、当前线程调用 t.join(long n) 方法、当前线程调用 Thread.sleep(long n)</p></li><li><p>RUNNABLE &lt;–&gt; BLOCKED：t 线程用 synchronized(obj) 获取了对象锁时竞争失败</p></li></ul><hr><h3 id="查看线程"><a href="#查看线程" class="headerlink" title="查看线程"></a>查看线程</h3><p>Windows：</p><ul><li><p>任务管理器可以查看进程和线程数，也可以用来杀死进程</p></li><li><p>tasklist 查看进程</p></li><li><p>taskkill 杀死进程</p></li></ul><p>Linux：</p><ul><li><p>ps -ef 查看所有进程</p></li><li><p>ps -fT -p &lt; PID&gt; 查看某个进程（PID）的所有线程</p></li><li><p>kill 杀死进程</p></li><li><p>top 按大写 H 切换是否显示线程</p></li><li><p>top -H -p &lt; PID&gt; 查看某个进程（PID）的所有线程</p></li></ul><p>Java：</p><ul><li><p>jps 命令查看所有 Java 进程</p></li><li><p>jstack &lt; PID&gt; 查看某个 Java 进程（PID）的所有线程状态</p></li><li><p>jconsole 来查看某个 Java 进程中线程的运行情况（图形界面）</p></li></ul><hr><h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><p>临界资源：一次仅允许一个进程使用的资源成为临界资源</p><p>临界区：访问临界资源的代码块</p><p>竞态条件：多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了竞态条件</p><p>一个程序运行多个线程是没有问题，多个线程读共享资源也没有问题，在多个线程对共享资源读写操作时发生指令交错，就会出现问题</p><p>为了避免临界区的竞态条件发生（解决线程安全问题）：</p><ul><li><p>阻塞式的解决方案：synchronized，lock</p></li><li><p>非阻塞式的解决方案：原子变量</p></li></ul><p>管程（monitor）：由局部于自己的若干公共变量和所有访问这些公共变量的过程所组成的软件模块，保证同一时刻只有一个进程在管程内活动，即管程内定义的操作在同一时刻只被一个进程调用（由编译器实现）</p><p><strong>synchronized：对象锁，保证了临界区内代码的原子性</strong>，采用互斥的方式让同一时刻至多只有一个线程能持有对象锁，其它线程获取这个对象锁时会阻塞，保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换</p><p>互斥和同步都可以采用 synchronized 关键字来完成，区别：</p><ul><li><p>互斥是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区代码</p></li><li><p>同步是由于线程执行的先后、顺序不同、需要一个线程等待其它线程运行到某个点</p></li></ul><p>性能：</p><ul><li><p>线程安全，性能差</p></li><li><p>线程不安全性能好，假如开发中不会存在多线程安全问题，建议使用线程不安全的设计类</p></li></ul><hr><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><h4 id="使用锁"><a href="#使用锁" class="headerlink" title="使用锁"></a>使用锁</h4><h5 id="同步块"><a href="#同步块" class="headerlink" title="同步块"></a>同步块</h5><p>锁对象：理论上可以是<strong>任意的唯一对象</strong></p><p>synchronized 是可重入、不公平的重量级锁</p><p>原则上：</p><ul><li><p>锁对象建议使用共享资源</p></li><li><p>在实例方法中使用 this 作为锁对象，锁住的 this 正好是共享资源</p></li><li><p>在静态方法中使用类名 .class 字节码作为锁对象，因为静态成员属于类，被所有实例对象共享，所以需要锁住类</p></li></ul><p>同步代码块格式：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">synchronized</span><span class="hljs-params">(锁对象)</span></span>&#123;  <br><span class="hljs-comment">// 访问共享资源的核心代码  </span><br>&#125;<br></code></pre></td></tr></table></figure><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">demo</span> &#123;  <br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br>    <span class="hljs-comment">//static修饰，则元素是属于类本身的，不属于对象  ，与类一起加载一次，只有一个  </span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">room</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;  <br>                <span class="hljs-keyword">synchronized</span> (room) &#123;  <br>                    counter++;  <br>                &#125;  <br>            &#125;  <br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);  <br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;  <br>                <span class="hljs-keyword">synchronized</span> (room) &#123;  <br>                    counter--;  <br>                &#125;  <br>            &#125;  <br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>);  <br>        t1.start();  <br>        t2.start();  <br>        t1.join();  <br>        t2.join();  <br>        System.out.println(counter);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h5><p>把出现线程安全问题的核心方法锁起来，每次只能一个线程进入访问</p><p>synchronized 修饰的方法的不具备继承性，所以子类是线程不安全的，如果子类的方法也被 synchronized 修饰，两个锁对象其实是一把锁，而且是<strong>子类对象作为锁</strong></p><p>用法：直接给方法加上一个修饰符 synchronized</p><p>&#x2F;&#x2F;同步方法  </p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada">修饰符 <span class="hljs-keyword">synchronized</span> 返回值类型 方法名(方法参数) &#123;   <br>方法体；  <br>&#125;  <br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F;同步静态方法  </p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino">修饰符 <span class="hljs-type">static</span> <span class="hljs-keyword">synchronized</span> 返回值类型 方法名(方法参数) &#123;   <br>方法体；  <br>&#125;<br></code></pre></td></tr></table></figure><p>同步方法底层也是有锁对象的：</p><ul><li>如果方法是实例方法：同步方法默认用 this 作为的锁对象</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> synchronized <span class="hljs-built_in">void</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;&#125; <span class="hljs-comment">//等价于  </span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;  <br><span class="hljs-title function_">synchronized</span>(<span class="hljs-params"><span class="hljs-variable language_">this</span></span>) &#123;&#125;  <br> &#125;<br></code></pre></td></tr></table></figure><ul><li>如果方法是静态方法：同步方法默认用类名 .class 作为的锁对象</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;  <br><span class="hljs-keyword">public</span> synchronized <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;&#125;  <br>&#125;  <br><span class="hljs-comment">//等价于  </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;  <br>        <span class="hljs-title function_">synchronized</span>(<span class="hljs-params">Test.<span class="hljs-keyword">class</span></span>) &#123;&#125;  <br>&#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="线程八锁"><a href="#线程八锁" class="headerlink" title="线程八锁"></a>线程八锁</h5><p>线程八锁就是考察 synchronized 锁住的是哪个对象，直接百度搜索相关的实例</p><p>说明：主要关注锁住的对象是不是同一个</p><ul><li><p>锁住类对象，所有类的实例的方法都是安全的，类的所有实例都相当于同一把锁</p></li><li><p>锁住 this 对象，只有在当前实例对象的线程内是安全的，如果有多个实例就不安全</p></li></ul><p>线程不安全：因为锁住的不是同一个对象，线程 1 调用 a 方法锁住的n1对象，线程 2 调用 b 方法锁住的 n2 对象，不是同一个对象</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Number</span>&#123;  <br>    public <span class="hljs-keyword">static</span> synchronized <span class="hljs-literal">void</span> a()&#123;  <br>        Thread.sleep(<span class="hljs-number">1000</span>);  <br>        System.out.println(<span class="hljs-string">&quot;1&quot;</span>);  <br>    &#125;  <br>    public synchronized <span class="hljs-literal">void</span> b() &#123;  <br>        System.out.println(<span class="hljs-string">&quot;2&quot;</span>);  <br>    &#125;  <br>&#125;  <br>public <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> main(<span class="hljs-built_in">String</span>[] args) &#123;  <br>    <span class="hljs-built_in">Number</span> n1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>();  <br>    <span class="hljs-built_in">Number</span> n2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>();  <br>    <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(()-&gt;&#123; n1.a(); &#125;)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;  </span><br><span class="hljs-function">    <span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(()-&gt;&#123; n2.b(); &#125;)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;  </span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><p>线程安全：因为 n1 调用 a() 方法，锁住的是类对象，n2 调用 b() 方法，锁住的也是类对象，所以线程安全</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Number</span>&#123;  <br>    public <span class="hljs-keyword">static</span> synchronized <span class="hljs-literal">void</span> a()&#123;  <br>        Thread.sleep(<span class="hljs-number">1000</span>);  <br>        System.out.println(<span class="hljs-string">&quot;1&quot;</span>);  <br>    &#125;  <br>    public <span class="hljs-keyword">static</span> synchronized <span class="hljs-literal">void</span> b() &#123;  <br>        System.out.println(<span class="hljs-string">&quot;2&quot;</span>);  <br>    &#125;  <br>&#125;  <br>public <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> main(<span class="hljs-built_in">String</span>[] args) &#123;  <br>    <span class="hljs-built_in">Number</span> n1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>();  <br>    <span class="hljs-built_in">Number</span> n2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>();  <br>    <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(()-&gt;&#123; n1.a(); &#125;)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;  </span><br><span class="hljs-function">    <span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(()-&gt;&#123; n2.b(); &#125;)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;  </span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><hr><h4 id="锁原理"><a href="#锁原理" class="headerlink" title="锁原理"></a>锁原理</h4><h5 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h5><p>Monitor 被翻译为监视器或管程</p><p>每个 Java 对象都可以关联一个 Monitor 对象，Monitor 也是 class，其<strong>实例存储在堆中</strong>，如果使用 synchronized 给对象上锁（重量级）之后，该对象头的 Mark Word 中就被设置指向 Monitor 对象的指针，这就是重量级锁</p><ul><li>Mark Word 结构：最后两位是<strong>锁标志位</strong></li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041620782.png"></p><ul><li>64 位虚拟机 Mark Word：</li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041620048.png"></p><p>工作流程：</p><ul><li><p>开始时 Monitor 中 Owner 为 null</p></li><li><p>当 Thread-2 执行 synchronized(obj) 就会将 Monitor 的所有者 Owner 置为 Thread-2，Monitor 中只能有一个 Owner，<strong>obj 对象的 Mark Word 指向 Monitor</strong>，把<strong>对象原有的 MarkWord 存入线程栈中的锁记录</strong>中（轻量级锁部分详解）<br><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041621477.png">    </p></li><li><p>在 Thread-2 上锁的过程，Thread-3、Thread-4、Thread-5 也执行 synchronized(obj)，就会进入 EntryList BLOCKED（双向链表）</p></li><li><p>Thread-2 执行完同步代码块的内容，根据 obj 对象头中 Monitor 地址寻找，设置 Owner 为空，把线程栈的锁记录中的对象头的值设置回 MarkWord</p></li><li><p>唤醒 EntryList 中等待的线程来竞争锁，竞争是<strong>非公平的</strong>，如果这时有新的线程想要获取锁，可能直接就抢占到了，阻塞队列的线程就会继续阻塞</p></li><li><p>WaitSet 中的 Thread-0，是以前获得过锁，但条件不满足进入 WAITING 状态的线程（wait-notify 机制）</p></li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041621372.png"></p><p>注意：</p><ul><li><p>synchronized 必须是进入同一个对象的 Monitor 才有上述的效果</p></li><li><p>不加 synchronized 的对象不会关联监视器，不遵从以上规则</p></li></ul><hr><h5 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h5><p>代码：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) &#123;  <br>    Object lock = <span class="hljs-keyword">new</span> Object();  <br>    <span class="hljs-keyword">synchronized</span> (lock) &#123;  <br>        System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;ok&quot;</span>);  <br>    &#125;  <br>&#125;<br><br><span class="hljs-number">0</span>: <span class="hljs-keyword">new</span>#<span class="hljs-number">2</span><span class="hljs-comment">// new Object  </span><br><span class="hljs-number">3</span>: dup  <br><span class="hljs-number">4</span>: invokespecial #<span class="hljs-number">1</span> <span class="hljs-comment">// invokespecial &lt;init&gt;:()V，非虚方法  </span><br><span class="hljs-number">7</span>: astore_1 <span class="hljs-comment">// lock引用 -&gt; lock  </span><br><span class="hljs-number">8</span>: aload_1<span class="hljs-comment">// lock （synchronized开始）  </span><br><span class="hljs-number">9</span>: dup<span class="hljs-comment">// 一份用来初始化，一份用来引用  </span><br><span class="hljs-number">10</span>: astore_2 <span class="hljs-comment">// lock引用 -&gt; slot 2  </span><br><span class="hljs-number">11</span>: monitorenter <span class="hljs-comment">// 【将 lock对象 MarkWord 置为 Monitor 指针】  </span><br><span class="hljs-number">12</span>: getstatic #<span class="hljs-number">3</span><span class="hljs-comment">// System.out  </span><br><span class="hljs-number">15</span>: ldc #<span class="hljs-number">4</span><span class="hljs-comment">// &quot;ok&quot;  </span><br><span class="hljs-number">17</span>: invokevirtual #<span class="hljs-number">5</span> <span class="hljs-comment">// invokevirtual println:(Ljava/lang/String;)V  </span><br><span class="hljs-number">20</span>: aload_2 <span class="hljs-comment">// slot 2(lock引用)  </span><br><span class="hljs-number">21</span>: monitorexit <span class="hljs-comment">// 【将 lock对象 MarkWord 重置, 唤醒 EntryList】  </span><br><span class="hljs-number">22</span>: goto <span class="hljs-number">30</span>  <br><span class="hljs-number">25</span>: astore_3 <span class="hljs-comment">// any -&gt; slot 3  </span><br><span class="hljs-number">26</span>: aload_2 <span class="hljs-comment">// slot 2(lock引用)  </span><br><span class="hljs-number">27</span>: monitorexit <span class="hljs-comment">// 【将 lock对象 MarkWord 重置, 唤醒 EntryList】  </span><br><span class="hljs-number">28</span>: aload_3  <br><span class="hljs-number">29</span>: athrow  <br><span class="hljs-number">30</span>: <span class="hljs-keyword">return</span>  <br>Exception table:  <br>    <span class="hljs-keyword">from</span> to target type  <br>      <span class="hljs-number">12</span> <span class="hljs-number">22</span> <span class="hljs-number">25</span> <span class="hljs-keyword">any</span>  <br>      <span class="hljs-number">25</span> <span class="hljs-number">28</span> <span class="hljs-number">25</span> <span class="hljs-keyword">any</span>  <br>LineNumberTable: ...  <br>LocalVariableTable:  <br>    Start Length Slot Name Signature  <br>    <span class="hljs-number">0</span> <span class="hljs-number">31</span> <span class="hljs-number">0</span> args [Ljava<span class="hljs-regexp">/lang/</span>String;  <br>    <span class="hljs-number">8</span> <span class="hljs-number">23</span> <span class="hljs-number">1</span> lock Ljava<span class="hljs-regexp">/lang/</span>Object;<br><br></code></pre></td></tr></table></figure><p>说明：</p><ul><li><p>通过异常 <strong>try-catch 机制</strong>，确保一定会被解锁</p></li><li><p>方法级别的 synchronized 不会在字节码指令中有所体现</p></li></ul><hr><h4 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h4><h5 id="升级过程"><a href="#升级过程" class="headerlink" title="升级过程"></a>升级过程</h5><p><strong>synchronized 是可重入、不公平的重量级锁</strong>，所以可以对其进行优化</p><p>无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁&#x2F;&#x2F; 随着竞争的增加，只能锁升级，不能降级</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041622328.png"></p><hr><h5 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h5><p>偏向锁的思想是偏向于让第一个获取锁对象的线程，这个线程之后重新获取该锁不再需要同步操作：</p><ul><li><p>当锁对象第一次被线程获得的时候进入偏向状态，标记为 101，同时<strong>使用 CAS 操作将线程 ID 记录到 Mark Word</strong>。如果 CAS 操作成功，这个线程以后进入这个锁相关的同步块，查看这个线程 ID 是自己的就表示没有竞争，就不需要再进行任何同步操作</p></li><li><p>当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向（Revoke Bias）后恢复到未锁定或轻量级锁状态</p></li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041622764.png"></p><p>一个对象创建时：</p><ul><li><p>如果开启了偏向锁（默认开启），那么对象创建后，MarkWord 值为 0x05 即最后 3 位为 101，thread、epoch、age 都为 0</p></li><li><p>偏向锁是默认是延迟的，不会在程序启动时立即生效，如果想避免延迟，可以加 VM 参数 <code>-XX:BiasedLockingStartupDelay=0</code> 来禁用延迟。JDK 8 延迟 4s 开启偏向锁原因：在刚开始执行代码时，会有好多线程来抢锁，如果开偏向锁效率反而降低</p></li><li><p>当一个对象已经计算过 hashCode，就再也无法进入偏向状态了</p></li><li><p>添加 VM 参数 <code>-XX:-UseBiasedLocking</code> 禁用偏向锁</p></li></ul><p>撤销偏向锁的状态：</p><ul><li><p>调用对象的 hashCode：偏向锁的对象 MarkWord 中存储的是线程 id，调用 hashCode 导致偏向锁被撤销</p></li><li><p>当有其它线程使用偏向锁对象时，会将偏向锁升级为轻量级锁</p></li><li><p>调用 wait&#x2F;notify，需要申请 Monitor，进入 WaitSet</p></li></ul><p><strong>批量撤销</strong>：如果对象被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，重偏向会重置对象的 Thread ID</p><ul><li><p>批量重偏向：当撤销偏向锁阈值超过 20 次后，JVM 会觉得是不是偏向错了，于是在给这些对象加锁时重新偏向至加锁线程</p></li><li><p>批量撤销：当撤销偏向锁阈值超过 40 次后，JVM 会觉得自己确实偏向错了，根本就不该偏向，于是整个类的所有对象都会变为不可偏向的，新建的对象也是不可偏向的</p></li></ul><hr><h5 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h5><p>一个对象有多个线程要加锁，但加锁的时间是错开的（没有竞争），可以使用轻量级锁来优化，轻量级锁对使用者是透明的（不可见）</p><p>可重入锁：线程可以进入任何一个它已经拥有的锁所同步着的代码块，可重入锁最大的作用是<strong>避免死锁</strong></p><p>轻量级锁在没有竞争时（锁重入时），每次重入仍然需要执行 CAS 操作，Java 6 才引入的偏向锁来优化</p><p>锁重入实例：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">static</span> final <span class="hljs-title class_">Object</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">method1</span>(<span class="hljs-params"></span>) &#123;  <br>    <span class="hljs-title function_">synchronized</span>(<span class="hljs-params"> obj </span>) &#123;  <br>        <span class="hljs-comment">// 同步块 A  </span><br>        <span class="hljs-title function_">method2</span>();  <br>    &#125;  <br>&#125;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">method2</span>(<span class="hljs-params"></span>) &#123;  <br>    <span class="hljs-title function_">synchronized</span>(<span class="hljs-params"> obj </span>) &#123;  <br>    <span class="hljs-comment">// 同步块 B  </span><br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>创建锁记录（Lock Record）对象，每个线程的<strong>栈帧</strong>都会包含一个锁记录的结构，存储锁定对象的 Mark Word</li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041622396.png"></p><ul><li><p>让锁记录中 Object reference 指向锁住的对象，并尝试用 CAS 替换 Object 的 Mark Word，将 Mark Word 的值存入锁记录</p></li><li><p>如果 CAS 替换成功，对象头中存储了锁记录地址和状态 00（轻量级锁） ，表示由该线程给对象加锁<br><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041623035.png"></p></li><li><p>如果 CAS 失败，有两种情况：</p><ul><li><p>如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入锁膨胀过程</p></li><li><p>如果是线程自己执行了 synchronized 锁重入，就添加一条 Lock Record 作为重入的计数</p></li></ul></li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041623988.png"></p><ul><li><p>当退出 synchronized 代码块（解锁时）</p><ul><li><p>如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减 1</p></li><li><p>如果锁记录的值不为 null，这时使用 CAS <strong>将 Mark Word 的值恢复给对象头</strong></p><ul><li><p>成功，则解锁成功</p></li><li><p>失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</p></li></ul></li></ul></li></ul><hr><h5 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h5><p>在尝试加轻量级锁的过程中，CAS 操作无法成功，可能是其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为<strong>重量级锁</strong></p><ul><li>当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁</li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041623875.png"></p><ul><li>Thread-1 加轻量级锁失败，进入锁膨胀流程：为 Object 对象申请 Monitor 锁，<strong>通过 Object 对象头获取到持锁线程</strong>，将 Monitor 的 Owner 置为 Thread-0，将 Object 的对象头指向重量级锁地址，然后自己进入 Monitor 的 EntryList BLOCKED</li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041624894.png"></p><ul><li>当 Thread-0 退出同步块解锁时，使用 CAS 将 Mark Word 的值恢复给对象头失败，这时进入重量级解锁流程，即按照 Monitor 地址找到 Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中 BLOCKED 线程</li></ul><hr><h4 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h4><h5 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h5><p>重量级锁竞争时，尝试获取锁的线程不会立即阻塞，可以使用<strong>自旋</strong>（默认 10 次）来进行优化，采用循环的方式去尝试获取锁</p><p>注意：</p><ul><li><p>自旋占用 CPU 时间，单核 CPU 自旋就是浪费时间，因为同一时刻只能运行一个线程，多核 CPU 自旋才能发挥优势</p></li><li><p>自旋失败的线程会进入阻塞状态</p></li></ul><p>优点：不会进入阻塞状态，<strong>减少线程上下文切换的消耗</strong></p><p>缺点：当自旋的线程越来越多时，会不断的消耗 CPU 资源</p><p>自旋锁情况：</p><ul><li><p>自旋成功的情况：<br><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041624183.png"></p></li><li><p>自旋失败的情况：</p></li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041625916.png"></p><p>自旋锁说明：</p><ul><li><p>在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，比较智能</p></li><li><p>Java 7 之后不能控制是否开启自旋功能，由 JVM 控制</p></li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><br><span class="hljs-comment">//手写自旋锁  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SpinLock</span> &#123;  <br>    <span class="hljs-comment">// 泛型装的是Thread，原子引用线程  </span><br>    AtomicReference&lt;Thread&gt; atomicReference = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;();  <br>  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span>()</span> &#123;  <br>        Thread thread = Thread.currentThread();  <br>        System.<span class="hljs-keyword">out</span>.println(thread.getName() + <span class="hljs-string">&quot; come in&quot;</span>);  <br>  <br>        <span class="hljs-comment">//开始自旋，期望值为null，更新值是当前线程  </span><br>        <span class="hljs-keyword">while</span> (!atomicReference.compareAndSet(<span class="hljs-literal">null</span>, thread)) &#123;  <br>            Thread.sleep(<span class="hljs-number">1000</span>);  <br>            System.<span class="hljs-keyword">out</span>.println(thread.getName() + <span class="hljs-string">&quot; 正在自旋&quot;</span>);  <br>        &#125;  <br>        System.<span class="hljs-keyword">out</span>.println(thread.getName() + <span class="hljs-string">&quot; 自旋成功&quot;</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span>()</span> &#123;  <br>        Thread thread = Thread.currentThread();  <br>  <br>        <span class="hljs-comment">//线程使用完锁把引用变为null  </span><br>atomicReference.compareAndSet(thread, <span class="hljs-literal">null</span>);  <br>        System.<span class="hljs-keyword">out</span>.println(thread.getName() + <span class="hljs-string">&quot; invoke unlock&quot;</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>) throws InterruptedException</span> &#123;  <br>        SpinLock <span class="hljs-keyword">lock</span> = <span class="hljs-keyword">new</span> SpinLock();  <br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;  <br>            <span class="hljs-comment">//占有锁  </span><br>            <span class="hljs-keyword">lock</span>.<span class="hljs-keyword">lock</span>();  <br>            Thread.sleep(<span class="hljs-number">10000</span>);   <br>  <br>            <span class="hljs-comment">//释放锁  </span><br>            <span class="hljs-keyword">lock</span>.unlock();  <br>        &#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();  <br>  <br>        <span class="hljs-comment">// 让main线程暂停1秒，使得t1线程，先执行  </span><br>        Thread.sleep(<span class="hljs-number">1000</span>);  <br>  <br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;  <br>            <span class="hljs-keyword">lock</span>.<span class="hljs-keyword">lock</span>();  <br>            <span class="hljs-keyword">lock</span>.unlock();  <br>        &#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h5><p>锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除，这是 JVM <strong>即时编译器的优化</strong></p><p>锁消除主要是通过<strong>逃逸分析</strong>来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除（同步消除：JVM 逃逸分析）</p><hr><h5 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h5><p>对相同对象多次加锁，导致线程发生多次重入，频繁的加锁操作就会导致性能损耗，可以使用锁粗化方式优化</p><p>如果虚拟机探测到一串的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部</p><ul><li><p>一些看起来没有加锁的代码，其实隐式的加了很多锁：</p><p>  public static String concatString(String s1, String s2, String s3) {<br>  return s1 + s2 + s3;<br>  }</p></li><li><p>String 是一个不可变的类，编译器会对 String 的拼接自动优化。在 JDK 1.5 之前，转化为 StringBuffer 对象的连续 append() 操作，每个 append() 方法中都有一个同步块</p><p>  public static String concatString(String s1, String s2, String s3) {<br>  StringBuffer sb &#x3D; new StringBuffer();<br>  sb.append(s1);<br>  sb.append(s2);<br>  sb.append(s3);<br>  return sb.toString();<br>  }</p></li></ul><p>扩展到第一个 append() 操作之前直至最后一个 append() 操作之后，只需要加锁一次就可以</p><hr><h4 id="多把锁"><a href="#多把锁" class="headerlink" title="多把锁"></a>多把锁</h4><p>多把不相干的锁：一间大屋子有两个功能睡觉、学习，互不相干。现在一人要学习，一人要睡觉，如果只用一间屋子（一个对象锁）的话，那么并发度很低</p><p>将锁的粒度细分：</p><ul><li><p>好处，是可以增强并发度</p></li><li><p>坏处，如果一个线程需要同时获得多把锁，就容易发生死锁</p></li></ul><p>解决方法：准备多个对象锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    <span class="hljs-type">BigRoom</span> <span class="hljs-variable">bigRoom</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigRoom</span>();  <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123; bigRoom.study(); &#125;).start();  <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123; bigRoom.sleep(); &#125;).start();  <br>&#125;  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BigRoom</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">studyRoom</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">sleepRoom</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>        <span class="hljs-keyword">synchronized</span> (sleepRoom) &#123;  <br>            System.out.println(<span class="hljs-string">&quot;sleeping 2 小时&quot;</span>);  <br>            Thread.sleep(<span class="hljs-number">2000</span>);  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>        <span class="hljs-keyword">synchronized</span> (studyRoom) &#123;  <br>            System.out.println(<span class="hljs-string">&quot;study 1 小时&quot;</span>);  <br>            Thread.sleep(<span class="hljs-number">1000</span>);  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="活跃性"><a href="#活跃性" class="headerlink" title="活跃性"></a>活跃性</h4><h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><h6 id="形成"><a href="#形成" class="headerlink" title="形成"></a>形成</h6><p>死锁：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放，由于线程被无限期地阻塞，因此程序不可能正常终止</p><p>Java 死锁产生的四个必要条件：</p><ol><li><p>互斥条件，即当资源被一个线程使用（占有）时，别的线程不能使用</p></li><li><p>不可剥夺条件，资源请求者不能强制从资源占有者手中夺取资源，资源只能由资源占有者主动释放</p></li><li><p>请求和保持条件，即当资源请求者在请求其他的资源的同时保持对原有资源的占有</p></li><li><p>循环等待条件，即存在一个等待循环队列：p1 要 p2 的资源，p2 要 p1 的资源，形成了一个等待环路</p></li></ol><p>四个条件都成立的时候，便形成死锁。死锁情况下打破上述任何一个条件，便可让死锁消失</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dead</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">resources1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">resources2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>            <span class="hljs-comment">// 线程1：占用资源1 ，请求资源2  </span><br>            <span class="hljs-keyword">synchronized</span>(resources1)&#123;  <br>                System.out.println(<span class="hljs-string">&quot;线程1已经占用了资源1，开始请求资源2&quot;</span>);  <br>                Thread.sleep(<span class="hljs-number">2000</span>);<span class="hljs-comment">//休息两秒，防止线程1直接运行完成。  </span><br>                <span class="hljs-comment">//2秒内线程2肯定可以锁住资源2  </span><br>                <span class="hljs-keyword">synchronized</span> (resources2)&#123;  <br>                    System.out.println(<span class="hljs-string">&quot;线程1已经占用了资源2&quot;</span>);  <br>                &#125;  <br>        &#125;).start();  <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>            <span class="hljs-comment">// 线程2：占用资源2 ，请求资源1  </span><br>            <span class="hljs-keyword">synchronized</span>(resources2)&#123;  <br>                System.out.println(<span class="hljs-string">&quot;线程2已经占用了资源2，开始请求资源1&quot;</span>);  <br>                Thread.sleep(<span class="hljs-number">2000</span>);  <br>                <span class="hljs-keyword">synchronized</span> (resources1)&#123;  <br>                    System.out.println(<span class="hljs-string">&quot;线程2已经占用了资源1&quot;</span>);  <br>                &#125;  <br>            &#125;&#125;  <br>        &#125;).start();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h6 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h6><p>定位死锁的方法：</p><ul><li><p>使用 jps 定位进程 id，再用 <code>jstack id</code> 定位死锁，找到死锁的线程去查看源码，解决优化</p><p>  “Thread-1” #12 prio&#x3D;5 os_prio&#x3D;0 tid&#x3D;0x000000001eb69000 nid&#x3D;0xd40 waiting formonitor entry [0x000000001f54f000]<br>  java.lang.Thread.State: BLOCKED (on object monitor)<br>  #省略<br>  “Thread-1” #12 prio&#x3D;5 os_prio&#x3D;0 tid&#x3D;0x000000001eb69000 nid&#x3D;0xd40 waiting for monitor entry [0x000000001f54f000]<br>  java.lang.Thread.State: BLOCKED (on object monitor)<br>  #省略<br>  Found one Java-level deadlock:<br>  “Thread-1”:<br>  waiting to lock monitor 0x000000000361d378 (object 0x000000076b5bf1c0, a java.lang.Object),<br>  which is held by “Thread-0”<br>  “Thread-0”:<br>  waiting to lock monitor 0x000000000361e768 (object 0x000000076b5bf1d0, a java.lang.Object),<br>  which is held by “Thread-1”<br><br>  Java stack information for the threads listed above:<br>  “Thread-1”:<br>  at thread.TestDeadLock.lambda$main$1(TestDeadLock.java:28)<br>  - waiting to lock &lt;0x000000076b5bf1c0&gt; (a java.lang.Object)<br>  - locked &lt;0x000000076b5bf1d0&gt; (a java.lang.Object)<br>  at thread.TestDeadLock$$Lambda$2&#x2F;883049899.run(Unknown Source)<br>  at java.lang.Thread.run(Thread.java:745)<br>  “Thread-0”:<br>  at thread.TestDeadLock.lambda$main$0(TestDeadLock.java:15)<br>  - waiting to lock &lt;0x000000076b5bf1d0&gt; (a java.lang.Object)<br>  - locked &lt;0x000000076b5bf1c0&gt; (a java.lang.Object)<br>  at thread.TestDeadLock$$Lambda$1&#x2F;495053715</p></li><li><p>Linux 下可以通过 top 先定位到 CPU 占用高的 Java 进程，再利用 <code>top -Hp 进程id</code> 来定位是哪个线程，最后再用 jstack &lt; pid&gt;的输出来看各个线程栈</p></li><li><p>避免死锁：避免死锁要注意加锁顺序</p></li><li><p>可以使用 jconsole 工具，在 <code>jdk\bin</code> 目录下</p></li></ul><hr><h5 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h5><p>活锁：指的是任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试—失败—尝试—失败的过程</p><p>两个线程互相改变对方的结束条件，最后谁也无法结束：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestLiveLock</span> &#123;  <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;  <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>            <span class="hljs-comment">// 期望减到 0 退出循环  </span><br>            <span class="hljs-keyword">while</span> (count &gt; <span class="hljs-number">0</span>) &#123;  <br>                Thread.sleep(<span class="hljs-number">200</span>);  <br>                count--;  <br>                System.out.println(<span class="hljs-string">&quot;线程一count:&quot;</span> + count);  <br>            &#125;  <br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();  <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>            <span class="hljs-comment">// 期望超过 20 退出循环  </span><br>            <span class="hljs-keyword">while</span> (count &lt; <span class="hljs-number">20</span>) &#123;  <br>                Thread.sleep(<span class="hljs-number">200</span>);  <br>                count++;  <br>                System.out.println(<span class="hljs-string">&quot;线程二count:&quot;</span>+ count);  <br>            &#125;  <br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h5><p>饥饿：一个线程由于优先级太低，始终得不到 CPU 调度执行，也不能够结束</p><hr><h3 id="wait-ify"><a href="#wait-ify" class="headerlink" title="wait-ify"></a>wait-ify</h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>需要获取对象锁后才可以调用 <code>锁对象.wait()</code>，notify 随机唤醒一个线程，notifyAll 唤醒所有线程去竞争 CPU</p><p>Object 类 API：</p><p>public final void notify():唤醒正在等待对象监视器的单个线程。<br>public final void notifyAll():唤醒正在等待对象监视器的所有线程。<br>public final void wait():导致当前线程等待，直到另一个线程调用该对象的 notify() 方法或 notifyAll()方法。<br>public final native void wait(long timeout):有时限的等待, 到n毫秒后结束等待，或是被唤醒</p><p>说明：<strong>wait 是挂起线程，需要唤醒的都是挂起操作</strong>，阻塞线程可以自己去争抢锁，挂起的线程需要唤醒后去争抢锁</p><p>对比 sleep()：</p><ul><li><p>原理不同：sleep() 方法是属于 Thread 类，是线程用来控制自身流程的，使此线程暂停执行一段时间而把执行机会让给其他线程；wait() 方法属于 Object 类，用于线程间通信</p></li><li><p>对<strong>锁的处理机制</strong>不同：调用 sleep() 方法的过程中，线程不会释放对象锁，当调用 wait() 方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池（不释放锁其他线程怎么抢占到锁执行唤醒操作），但是都会释放 CPU</p></li><li><p>使用区域不同：wait() 方法必须放在<strong>同步控制方法和同步代码块（先获取锁）</strong>中使用，sleep() 方法则可以放在任何地方使用</p></li></ul><p>底层原理：</p><ul><li><p>Owner 线程发现条件不满足，调用 wait 方法，即可进入 WaitSet 变为 WAITING 状态</p></li><li><p>BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片</p></li><li><p>BLOCKED 线程会在 Owner 线程释放锁时唤醒</p></li><li><p>WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，唤醒后并不意味者立刻获得锁，<strong>需要进入 EntryList 重新竞争</strong></p></li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041625177.png"></p><hr><h4 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h4><p>虚假唤醒：notify 只能随机唤醒一个 WaitSet 中的线程，这时如果有其它线程也在等待，那么就可能唤醒不了正确的线程</p><p>解决方法：采用 notifyAll</p><p>notifyAll 仅解决某个线程的唤醒问题，使用 if + wait 判断仅有一次机会，一旦条件不成立，无法重新判断</p><p>解决方法：用 while + wait，当条件不成立，再次 wait</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@Slf4j(topic = &quot;c.demo&quot;)</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">demo</span> &#123;  <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">room</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();  <br>    <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">hasCigarette</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;    <span class="hljs-comment">//有没有烟  </span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">hasTakeout</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>            <span class="hljs-keyword">synchronized</span> (room) &#123;  <br>                log.debug(<span class="hljs-string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);  <br>                <span class="hljs-keyword">while</span> (!hasCigarette) &#123;<span class="hljs-comment">//while防止虚假唤醒  </span><br>                    log.debug(<span class="hljs-string">&quot;没烟，先歇会！&quot;</span>);  <br>                    <span class="hljs-keyword">try</span> &#123;  <br>                        room.wait();  <br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>                        e.printStackTrace();  <br>                    &#125;  <br>                &#125;  <br>                log.debug(<span class="hljs-string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);  <br>                <span class="hljs-keyword">if</span> (hasCigarette) &#123;  <br>                    log.debug(<span class="hljs-string">&quot;可以开始干活了&quot;</span>);  <br>                &#125; <span class="hljs-keyword">else</span> &#123;  <br>                    log.debug(<span class="hljs-string">&quot;没干成活...&quot;</span>);  <br>                &#125;  <br>            &#125;  <br>        &#125;, <span class="hljs-string">&quot;小南&quot;</span>).start();  <br>  <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>            <span class="hljs-keyword">synchronized</span> (room) &#123;  <br>                <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> Thread.currentThread();  <br>                log.debug(<span class="hljs-string">&quot;外卖送到没？[&#123;&#125;]&quot;</span>, hasTakeout);  <br>                <span class="hljs-keyword">if</span> (!hasTakeout) &#123;  <br>                    log.debug(<span class="hljs-string">&quot;没外卖，先歇会！&quot;</span>);  <br>                    <span class="hljs-keyword">try</span> &#123;  <br>                        room.wait();  <br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>                        e.printStackTrace();  <br>                    &#125;  <br>                &#125;  <br>                log.debug(<span class="hljs-string">&quot;外卖送到没？[&#123;&#125;]&quot;</span>, hasTakeout);  <br>                <span class="hljs-keyword">if</span> (hasTakeout) &#123;  <br>                    log.debug(<span class="hljs-string">&quot;可以开始干活了&quot;</span>);  <br>                &#125; <span class="hljs-keyword">else</span> &#123;  <br>                    log.debug(<span class="hljs-string">&quot;没干成活...&quot;</span>);  <br>                &#125;  <br>            &#125;  <br>        &#125;, <span class="hljs-string">&quot;小女&quot;</span>).start();  <br>  <br>  <br>        Thread.sleep(<span class="hljs-number">1000</span>);  <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>        <span class="hljs-comment">// 这里能不能加 synchronized (room)？  </span><br>            <span class="hljs-keyword">synchronized</span> (room) &#123;  <br>                hasTakeout = <span class="hljs-literal">true</span>;  <br><span class="hljs-comment">//log.debug(&quot;烟到了噢！&quot;);  </span><br>                log.debug(<span class="hljs-string">&quot;外卖到了噢！&quot;</span>);  <br>                room.notifyAll();  <br>            &#125;  <br>        &#125;, <span class="hljs-string">&quot;送外卖的&quot;</span>).start();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="park-un"><a href="#park-un" class="headerlink" title="park-un"></a>park-un</h3><p>LockSupport 是用来创建锁和其他同步类的<strong>线程原语</strong></p><p>LockSupport 类方法：</p><ul><li><p><code>LockSupport.park()</code>：暂停当前线程，挂起原语</p></li><li><p><code>LockSupport.unpark(暂停的线程对象)</code>：恢复某个线程的运行</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>        System.out.println(<span class="hljs-string">&quot;start...&quot;</span>);<span class="hljs-comment">//1  </span><br>Thread.sleep(<span class="hljs-number">1000</span>);<span class="hljs-comment">// Thread.sleep(3000)  </span><br>        <span class="hljs-comment">// 先 park 再 unpark 和先 unpark 再 park 效果一样，都会直接恢复线程的运行  </span><br>        System.out.println(<span class="hljs-string">&quot;park...&quot;</span>);<span class="hljs-comment">//2  </span><br>        LockSupport.park();  <br>        System.out.println(<span class="hljs-string">&quot;resume...&quot;</span>);<span class="hljs-comment">//4  </span><br>    &#125;,<span class="hljs-string">&quot;t1&quot;</span>);  <br>    t1.start();  <br>   Thread.sleep(<span class="hljs-number">2000</span>);  <br>    System.out.println(<span class="hljs-string">&quot;unpark...&quot;</span>);<span class="hljs-comment">//3  </span><br>    LockSupport.unpark(t1);  <br>&#125;<br></code></pre></td></tr></table></figure><p>LockSupport 出现就是为了增强 wait &amp; notify 的功能：</p><ul><li><p>wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park、unpark 不需要</p></li><li><p>park &amp; unpark <strong>以线程为单位</strong>来阻塞和唤醒线程，而 notify 只能随机唤醒一个等待线程，notifyAll 是唤醒所有等待线程</p></li><li><p>park &amp; unpark 可以先 unpark，而 wait &amp; notify 不能先 notify。类比生产消费，先消费发现有产品就消费，没有就等待；先生产就直接产生商品，然后线程直接消费</p></li><li><p>wait 会释放锁资源进入等待队列，<strong>park 不会释放锁资源</strong>，只负责阻塞当前线程，会释放 CPU</p></li></ul><p>原理：类似生产者消费者</p><ul><li><p>先 park：</p><ol><li><p>当前线程调用 Unsafe.park() 方法</p></li><li><p>检查 _counter ，本情况为 0，这时获得 _mutex 互斥锁</p></li><li><p>线程进入 _cond 条件变量挂起</p></li><li><p>调用 Unsafe.unpark(Thread_0) 方法，设置 _counter 为 1</p></li><li><p>唤醒 _cond 条件变量中的 Thread_0，Thread_0 恢复运行，设置 _counter 为 0</p></li></ol></li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041626876.png"></p><ul><li><p>先 unpark：</p><ol><li><p>调用 Unsafe.unpark(Thread_0) 方法，设置 _counter 为 1</p></li><li><p>当前线程调用 Unsafe.park() 方法</p></li><li><p>检查 _counter ，本情况为 1，这时线程无需挂起，继续运行，设置 _counter 为 0</p></li></ol></li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041626568.png"></p><hr><h3 id="安全分析"><a href="#安全分析" class="headerlink" title="安全分析"></a>安全分析</h3><p>成员变量和静态变量：</p><ul><li><p>如果它们没有共享，则线程安全</p></li><li><p>如果它们被共享了，根据它们的状态是否能够改变，分两种情况：</p><ul><li><p>如果只有读操作，则线程安全</p></li><li><p>如果有读写操作，则这段代码是临界区，需要考虑线程安全问题</p></li></ul></li></ul><p>局部变量：</p><ul><li><p>局部变量是线程安全的</p></li><li><p>局部变量引用的对象不一定线程安全（逃逸分析）：</p><ul><li><p>如果该对象没有逃离方法的作用访问，它是线程安全的（每一个方法有一个栈帧）</p></li><li><p>如果该对象逃离方法的作用范围，需要考虑线程安全问题（暴露引用）</p></li></ul></li></ul><p>常见线程安全类：String、Integer、StringBuffer、Random、Vector、Hashtable、java.util.concurrent 包</p><ul><li><p>线程安全的是指，多个线程调用它们同一个实例的某个方法时，是线程安全的</p></li><li><p><strong>每个方法是原子的，但多个方法的组合不是原子的</strong>，只能保证调用的方法内部安全：</p><p>  Hashtable table &#x3D; new Hashtable();<br>  &#x2F;&#x2F; 线程1，线程2<br>  if(table.get(“key”) &#x3D;&#x3D; null) {<br>  table.put(“key”, value);<br>  }</p></li></ul><p>无状态类线程安全，就是没有成员变量的类</p><p>不可变类线程安全：String、Integer 等都是不可变类，<strong>内部的状态不可以改变</strong>，所以方法是线程安全</p><ul><li><p>replace 等方法底层是新建一个对象，复制过去</p><p>  Map&lt;String,Object&gt; map &#x3D; new HashMap&lt;&gt;();&#x2F;&#x2F; 线程不安全<br>  String S1 &#x3D; “…”;&#x2F;&#x2F; 线程安全<br>  final String S2 &#x3D; “…”;&#x2F;&#x2F; 线程安全<br>  Date D1 &#x3D; new Date();&#x2F;&#x2F; 线程不安全<br>  final Date D2 &#x3D; new Date();&#x2F;&#x2F; 线程不安全，final让D2引用的对象不能变，但对象的内容可以变</p></li></ul><p>抽象方法如果有参数，被重写后行为不确定可能造成线程不安全，被称之为外星方法：<code>public abstract foo(Student s);</code></p><hr><h3 id="同步模式"><a href="#同步模式" class="headerlink" title="同步模式"></a>同步模式</h3><h4 id="保护性暂停"><a href="#保护性暂停" class="headerlink" title="保护性暂停"></a>保护性暂停</h4><h5 id="单任务版"><a href="#单任务版" class="headerlink" title="单任务版"></a>单任务版</h5><p>Guarded Suspension，用在一个线程等待另一个线程的执行结果</p><ul><li><p>有一个结果需要从一个线程传递到另一个线程，让它们关联同一个 GuardedObject</p></li><li><p>如果有结果不断从一个线程到另一个线程那么可以使用消息队列（见生产者&#x2F;消费者）</p></li><li><p>JDK 中，join 的实现、Future 的实现，采用的就是此模式</p></li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041627568.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    <span class="hljs-type">GuardedObject</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GuardedObjectV2</span>();  <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>        sleep(<span class="hljs-number">1</span>);  <br>        object.complete(Arrays.asList(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>));  <br>    &#125;).start();  <br>      <br>    <span class="hljs-type">Object</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> object.get(<span class="hljs-number">2500</span>);  <br>    <span class="hljs-keyword">if</span> (response != <span class="hljs-literal">null</span>) &#123;  <br>        log.debug(<span class="hljs-string">&quot;get response: [&#123;&#125;] lines&quot;</span>, ((List&lt;String&gt;) response).size());  <br>    &#125; <span class="hljs-keyword">else</span> &#123;  <br>        log.debug(<span class="hljs-string">&quot;can&#x27;t get response&quot;</span>);  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GuardedObject</span> &#123;  <br>    <span class="hljs-keyword">private</span> Object response;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();  <br>  <br>    <span class="hljs-comment">//获取结果  </span><br>    <span class="hljs-comment">//timeout :最大等待时间  </span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> millis)</span> &#123;  <br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;  <br>            <span class="hljs-comment">// 1) 记录最初时间  </span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> System.currentTimeMillis();  <br>            <span class="hljs-comment">// 2) 已经经历的时间  </span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">timePassed</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br>            <span class="hljs-keyword">while</span> (response == <span class="hljs-literal">null</span>) &#123;  <br>                <span class="hljs-comment">// 4) 假设 millis 是 1000，结果在 400 时唤醒了，那么还有 600 要等  </span><br>                <span class="hljs-type">long</span> <span class="hljs-variable">waitTime</span> <span class="hljs-operator">=</span> millis - timePassed;  <br>                log.debug(<span class="hljs-string">&quot;waitTime: &#123;&#125;&quot;</span>, waitTime);  <br>                <span class="hljs-comment">//经历时间超过最大等待时间退出循环  </span><br>                <span class="hljs-keyword">if</span> (waitTime &lt;= <span class="hljs-number">0</span>) &#123;  <br>                    log.debug(<span class="hljs-string">&quot;break...&quot;</span>);  <br>                    <span class="hljs-keyword">break</span>;  <br>                &#125;  <br>                <span class="hljs-keyword">try</span> &#123;  <br>                    lock.wait(waitTime);  <br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>                    e.printStackTrace();  <br>                &#125;  <br>                <span class="hljs-comment">// 3) 如果提前被唤醒，这时已经经历的时间假设为 400  </span><br>                timePassed = System.currentTimeMillis() - begin;  <br>                log.debug(<span class="hljs-string">&quot;timePassed: &#123;&#125;, object is null &#123;&#125;&quot;</span>,  <br>                        timePassed, response == <span class="hljs-literal">null</span>);  <br>            &#125;  <br>            <span class="hljs-keyword">return</span> response;  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//产生结果  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">complete</span><span class="hljs-params">(Object response)</span> &#123;  <br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;  <br>            <span class="hljs-comment">// 条件满足，通知等待线程  </span><br>            <span class="hljs-built_in">this</span>.response = response;  <br>            log.debug(<span class="hljs-string">&quot;notify...&quot;</span>);  <br>            lock.notifyAll();  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="多任务版"><a href="#多任务版" class="headerlink" title="多任务版"></a>多任务版</h5><p>多任务版保护性暂停：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041627603.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;  <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">People</span>().start();  <br>    &#125;  <br>    Thread.sleep(<span class="hljs-number">1000</span>);  <br>    <span class="hljs-keyword">for</span> (Integer id : Mailboxes.getIds()) &#123;  <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Postman</span>(id, id + <span class="hljs-string">&quot;号快递到了&quot;</span>).start();  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-meta">@Slf4j(topic = &quot;c.People&quot;)</span>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-comment">// 收信  </span><br>        <span class="hljs-type">GuardedObject</span> <span class="hljs-variable">guardedObject</span> <span class="hljs-operator">=</span> Mailboxes.createGuardedObject();  <br>        log.debug(<span class="hljs-string">&quot;开始收信i d:&#123;&#125;&quot;</span>, guardedObject.getId());  <br>        <span class="hljs-type">Object</span> <span class="hljs-variable">mail</span> <span class="hljs-operator">=</span> guardedObject.get(<span class="hljs-number">5000</span>);  <br>        log.debug(<span class="hljs-string">&quot;收到信id:&#123;&#125;，内容:&#123;&#125;&quot;</span>, guardedObject.getId(),mail);  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Postman</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;  <br>    <span class="hljs-keyword">private</span> String mail;  <br>    <span class="hljs-comment">//构造方法  </span><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-type">GuardedObject</span> <span class="hljs-variable">guardedObject</span> <span class="hljs-operator">=</span> Mailboxes.getGuardedObject(id);  <br>        log.debug(<span class="hljs-string">&quot;开始送信i d:&#123;&#125;，内容:&#123;&#125;&quot;</span>, guardedObject.getId(),mail);  <br>        guardedObject.complete(mail);  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-keyword">class</span>  <span class="hljs-title class_">Mailboxes</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;Integer, GuardedObject&gt; boxes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hashtable</span>&lt;&gt;();  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;  <br>  <br>    <span class="hljs-comment">//产生唯一的id  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">int</span> <span class="hljs-title function_">generateId</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> id++;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GuardedObject <span class="hljs-title function_">getGuardedObject</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;  <br>        <span class="hljs-keyword">return</span> boxes.remove(id);  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GuardedObject <span class="hljs-title function_">createGuardedObject</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-type">GuardedObject</span> <span class="hljs-variable">go</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GuardedObject</span>(generateId());  <br>        boxes.put(go.getId(), go);  <br>        <span class="hljs-keyword">return</span> go;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Set&lt;Integer&gt; <span class="hljs-title function_">getIds</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> boxes.keySet();  <br>    &#125;  <br>&#125;  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GuardedObject</span> &#123;  <br>    <span class="hljs-comment">//标识，Guarded Object  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<span class="hljs-comment">//添加get set方法  </span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="顺序输出"><a href="#顺序输出" class="headerlink" title="顺序输出"></a>顺序输出</h4><p>顺序输出 2 1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;  <br>            <span class="hljs-comment">//try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; &#125;  </span><br>            <span class="hljs-comment">// 当没有许可时，当前线程暂停运行；有许可时，用掉这个许可，当前线程恢复运行  </span><br>            LockSupport.park();  <br>            System.out.println(<span class="hljs-string">&quot;1&quot;</span>);  <br>        &#125;  <br>    &#125;);  <br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;  <br>            System.out.println(<span class="hljs-string">&quot;2&quot;</span>);  <br>            <span class="hljs-comment">// 给线程 t1 发放『许可』（多次连续调用 unpark 只会发放一个『许可』）  </span><br>            LockSupport.unpark(t1);  <br>            <span class="hljs-keyword">try</span> &#123; Thread.sleep(<span class="hljs-number">500</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; &#125;  <br>        &#125;  <br>    &#125;);  <br>    t1.start();  <br>    t2.start();  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="交替输出"><a href="#交替输出" class="headerlink" title="交替输出"></a>交替输出</h4><p>连续输出 5 次 abc</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">day2_14</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>        <span class="hljs-type">AwaitSignal</span> <span class="hljs-variable">awaitSignal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AwaitSignal</span>(<span class="hljs-number">5</span>);  <br>        <span class="hljs-type">Condition</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> awaitSignal.newCondition();  <br>        <span class="hljs-type">Condition</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> awaitSignal.newCondition();  <br>        <span class="hljs-type">Condition</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> awaitSignal.newCondition();  <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>            awaitSignal.print(<span class="hljs-string">&quot;a&quot;</span>, a, b);  <br>        &#125;).start();  <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>            awaitSignal.print(<span class="hljs-string">&quot;b&quot;</span>, b, c);  <br>        &#125;).start();  <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>            awaitSignal.print(<span class="hljs-string">&quot;c&quot;</span>, c, a);  <br>        &#125;).start();  <br>  <br>        Thread.sleep(<span class="hljs-number">1000</span>);  <br>        awaitSignal.lock();  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            a.signal();  <br>        &#125; <span class="hljs-keyword">finally</span> &#123;  <br>            awaitSignal.unlock();  <br>        &#125;  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AwaitSignal</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ReentrantLock</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> loopNumber;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AwaitSignal</span><span class="hljs-params">(<span class="hljs-type">int</span> loopNumber)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.loopNumber = loopNumber;  <br>    &#125;  <br>    <span class="hljs-comment">//参数1：打印内容  参数二：条件变量  参数二：唤醒下一个  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(String str, Condition condition, Condition next)</span> &#123;  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;  <br>            lock();  <br>            <span class="hljs-keyword">try</span> &#123;  <br>                condition.await();  <br>                System.out.print(str);  <br>                next.signal();  <br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>                e.printStackTrace();  <br>            &#125; <span class="hljs-keyword">finally</span> &#123;  <br>                unlock();  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="异步模式"><a href="#异步模式" class="headerlink" title="异步模式"></a>异步模式</h3><h4 id="传统版"><a href="#传统版" class="headerlink" title="传统版"></a>传统版</h4><p>异步模式之生产者&#x2F;消费者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ShareData</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">condition</span> <span class="hljs-operator">=</span> lock.newCondition();  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;  <br>        <span class="hljs-comment">// 同步代码块，加锁  </span><br>        lock.lock();  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            <span class="hljs-comment">// 判断  防止虚假唤醒  </span><br>            <span class="hljs-keyword">while</span>(number != <span class="hljs-number">0</span>) &#123;  <br>                <span class="hljs-comment">// 等待不能生产  </span><br>                condition.await();  <br>            &#125;  <br>            <span class="hljs-comment">// 干活  </span><br>            number++;  <br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t &quot;</span> + number);  <br>            <span class="hljs-comment">// 通知 唤醒  </span><br>            condition.signalAll();  <br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;  <br>            e.printStackTrace();  <br>        &#125; <span class="hljs-keyword">finally</span> &#123;  <br>            lock.unlock();  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decrement</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;  <br>        <span class="hljs-comment">// 同步代码块，加锁  </span><br>        lock.lock();  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            <span class="hljs-comment">// 判断 防止虚假唤醒  </span><br>            <span class="hljs-keyword">while</span>(number == <span class="hljs-number">0</span>) &#123;  <br>                <span class="hljs-comment">// 等待不能消费  </span><br>                condition.await();  <br>            &#125;  <br>            <span class="hljs-comment">// 干活  </span><br>            number--;  <br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t &quot;</span> + number);  <br>            <span class="hljs-comment">// 通知 唤醒  </span><br>            condition.signalAll();  <br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;  <br>            e.printStackTrace();  <br>        &#125; <span class="hljs-keyword">finally</span> &#123;  <br>            lock.unlock();  <br>        &#125;  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TraditionalProducerConsumer</span> &#123;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">ShareData</span> <span class="hljs-variable">shareData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ShareData</span>();  <br>        <span class="hljs-comment">// t1线程，生产  </span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;  <br>            shareData.increment();  <br>            &#125;  <br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();  <br>  <br>        <span class="hljs-comment">// t2线程，消费  </span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;  <br>shareData.decrement();  <br>            &#125;  <br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();   <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="改进版"><a href="#改进版" class="headerlink" title="改进版"></a>改进版</h4><p>异步模式之生产者&#x2F;消费者：</p><ul><li><p>消费队列可以用来平衡生产和消费的线程资源，不需要产生结果和消费结果的线程一一对应</p></li><li><p>生产者仅负责产生结果数据，不关心数据该如何处理，而消费者专心处理结果数据</p></li><li><p>消息队列是有容量限制的，满时不会再加入数据，空时不会再消耗数据</p></li><li><p>JDK 中各种阻塞队列，采用的就是这种模式</p></li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041627710.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">demo</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">MessageQueue</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageQueue</span>(<span class="hljs-number">2</span>);  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;  <br>            <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> i;  <br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>                queue.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(id,<span class="hljs-string">&quot;值&quot;</span>+id));  <br>            &#125;, <span class="hljs-string">&quot;生产者&quot;</span> + i).start();  <br>        &#125;  <br>          <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;  <br>                <span class="hljs-keyword">try</span> &#123;  <br>                    Thread.sleep(<span class="hljs-number">1000</span>);  <br>                    <span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> queue.take();  <br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>                    e.printStackTrace();  <br>                &#125;  <br>            &#125;  <br>        &#125;,<span class="hljs-string">&quot;消费者&quot;</span>).start();  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-comment">//消息队列类，Java间线程之间通信  </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageQueue</span> &#123;  <br>    <span class="hljs-keyword">private</span> LinkedList&lt;Message&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<span class="hljs-comment">//消息的队列集合  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capacity;<span class="hljs-comment">//队列容量  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MessageQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.capacity = capacity;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//获取消息  </span><br>    <span class="hljs-keyword">public</span> Message <span class="hljs-title function_">take</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-comment">//检查队列是否为空  </span><br>        <span class="hljs-keyword">synchronized</span> (list) &#123;  <br>            <span class="hljs-keyword">while</span> (list.isEmpty()) &#123;  <br>                <span class="hljs-keyword">try</span> &#123;  <br>                    sout(Thread.currentThread().getName() + <span class="hljs-string">&quot;:队列为空，消费者线程等待&quot;</span>);  <br>                    list.wait();  <br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>                    e.printStackTrace();  <br>                &#125;  <br>            &#125;  <br>            <span class="hljs-comment">//从队列的头部获取消息返回  </span><br>            <span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> list.removeFirst();  <br>            sout(Thread.currentThread().getName() + <span class="hljs-string">&quot;：已消费消息--&quot;</span> + message);  <br>            list.notifyAll();  <br>            <span class="hljs-keyword">return</span> message;  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//存入消息  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(Message message)</span> &#123;  <br>        <span class="hljs-keyword">synchronized</span> (list) &#123;  <br>            <span class="hljs-comment">//检查队列是否满  </span><br>            <span class="hljs-keyword">while</span> (list.size() == capacity) &#123;  <br>                <span class="hljs-keyword">try</span> &#123;  <br>                    sout(Thread.currentThread().getName()+<span class="hljs-string">&quot;:队列为已满，生产者线程等待&quot;</span>);  <br>                    list.wait();  <br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>                    e.printStackTrace();  <br>                &#125;  <br>            &#125;  <br>            <span class="hljs-comment">//将消息加入队列尾部  </span><br>            list.addLast(message);  <br>            sout(Thread.currentThread().getName() + <span class="hljs-string">&quot;:已生产消息--&quot;</span> + message);  <br>            list.notifyAll();  <br>        &#125;  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Message</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;  <br>    <span class="hljs-keyword">private</span> Object value;  <br><span class="hljs-comment">//get set  </span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">1</span>);  <br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">producer</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">1</span>);  <br>    BlockingQueue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;&gt;();  <br>    producer.submit(() -&gt; &#123;  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            System.out.println(<span class="hljs-string">&quot;生产...&quot;</span>);  <br>            Thread.sleep(<span class="hljs-number">1000</span>);  <br>            queue.put(<span class="hljs-number">10</span>);  <br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>            e.printStackTrace();  <br>        &#125;  <br>    &#125;);  <br>    consumer.submit(() -&gt; &#123;  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            System.out.println(<span class="hljs-string">&quot;等待消费...&quot;</span>);  <br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> queue.take();  <br>            System.out.println(<span class="hljs-string">&quot;结果为:&quot;</span> + result);  <br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>            e.printStackTrace();  <br>        &#125;  <br>    &#125;);  <br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并发</tag>
      
      <tag>并行</tag>
      
      <tag>同步</tag>
      
      <tag>异步</tag>
      
      <tag>互斥</tag>
      
      <tag>线程安全</tag>
      
      <tag>悲观锁</tag>
      
      <tag>乐观锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重拾设计模式（三）</title>
    <link href="/posts/bd826a18/"/>
    <url>/posts/bd826a18/</url>
    
    <content type="html"><![CDATA[<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><blockquote><p>实现一个商场收银软件，营业员根据客户购买的商品单价和数量收费。</p></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201056028.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201057372.png"></p><blockquote><p>如果要去商场对商品搞活动，所有商品打八折呢。<br>那不就是totalPrices后面乘以0.8么？<br>那难道商场活动结束了，再改造一次代码么？然后再用改后的程序把所有机器全部安装一次么？还有可能周年庆，打五折的情况，如何处理？<br>那再加一个下拉框，选择商品活动呢？</p></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201100218.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201059095.png"></p><blockquote><p>这比刚才灵活性上是好多了，不过重复代码很多，像Convert.ToDouble()，你这里就写了8遍，而且4个分支要执行的语句除了打折多少以外几乎没什么不同，应该考虑重构一下。不过这还不是最主要的，现在我的需求又来了，商场的活动加大，需要有满300返100的促销算法，怎么办？</p></blockquote><h3 id="简单工厂实现"><a href="#简单工厂实现" class="headerlink" title="简单工厂实现"></a>简单工厂实现</h3><blockquote><p>面向对象的编程，并不是类越多越好，类的划分是为了封装，但分类的基础是抽象，具有相同属性和功能的对象的抽象集合才是类。打一折和打九折只是形式的不同，抽象分析出来，所有的打折算法都是一样的，所以打折算法应该是一个类。好了，空话已说了太多，写出来才是真的懂。</p></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201104978.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201105121.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201105619.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201105338.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201105903.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201106421.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201106166.png"></p><blockquote><p>简单工厂模式虽然也能解决这个问题，但这个模式只是解决对象的创建问题，而且由于工厂本身包括了所有的收费方式，商场是可能经常性地更改打折额度和返利额度，每次维护或扩展收费方式都要改动这个工厂，以致代码需重新编译部署，这真的是很糟糕的处理方式，所以用它不是最好的办法。面对算法的时常变动，应该有更好的办法。</p></blockquote><h3 id="策略模式实现"><a href="#策略模式实现" class="headerlink" title="策略模式实现"></a>策略模式实现</h3><blockquote><p>策略模式（Strategy）：它定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。</p></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201114498.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201115485.png"><br><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201115807.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201115497.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201116484.png"></p><blockquote><p>写的CashSuper就是抽象策略，而正常收费CashNormal、打折收费CashRebate和返利收费CashReturn就是三个具体策略，也就是策略模式中说的具体算法。</p><p>模仿策略模式的基本代码，改写一下你的程序。<br>其实不麻烦，原来写的CashSuper、CashNormal、CashRebate和CashReturn都不用更改了，只要加一个CashContext类，并改写一下客户端就行了。</p></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201118128.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201119104.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201119863.png"></p><blockquote><p>代码是模仿着写出来了。但我感觉这样子做不又回到了原来的老路了吗，在客户端去判断用哪一个算法？<br>有没有什么好办法，把这个判断的过程从客户端程序转移走呢？<br>难道简单工厂就一定要是一个单独的类吗？难道不可以与策略模式的Context结合？</p></blockquote><h3 id="策略与简单工厂结合"><a href="#策略与简单工厂结合" class="headerlink" title="策略与简单工厂结合"></a>策略与简单工厂结合</h3><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201121336.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201122776.png"></p><blockquote><p>原来简单工厂模式并非只有建一个工厂类的做法，还可以这样子做。此时比刚才的模仿策略模式的写法要清楚多了，客户端代码简单明了。</p></blockquote><blockquote><p>观察一下，找出它们的不同之处。<br><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201123227.png"></p></blockquote><blockquote><p>简单工厂模式我需要让客户端认识两个类， CashSuper和CashFactory，而策略模式与简单工厂结合的用法，客户端就只需要认识一个类CashContext就可以了。耦合更加降低。</p><p>在客户端实例化的是CashContext的对象，调用的是CashContext的方法GetResult，这使得具体的收费算法彻底地与客户端分离。连算法的父类CashSuper都不让客户端认识了。</p></blockquote><hr><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p class="note note-primary">观察者模式是一种行为设计模式，用于定义对象之间的一对多依赖关系，当一个对象的状态发生变化时，其所有依赖对象都会自动收到通知并进行相应的更新。</p><p>一个软件系统里面包含了各种对象，就像一片欣欣向荣的森林充满了各种生物一样。在一片森林中，各种生物彼此依赖和约束，形成一个个生物链。一种生物的状态变化会造成其他一些生物的相应行动，每一个生物都处于别的生物的互动之中。</p><p>同样，一个软件系统常常要求在某一个对象的状态发生变化的时候，某些其他的对象做出相应的改变。做到这一点的设计方案有很多，但是为了使系统能够易于复用，应该选择低耦合度的设计方案。减少对象之间的耦合有利于系统的复用，但是同时设计师需要使这些低耦合度的对象之间能够维持行动的协调一致，保证高度的协作。观察者模式是满足这一要求的各种设计方案中最重要的一种。</p><p>下面以一个简单的示意性实现为例，讨论观察者模式的结构。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402211139342.png"></p><p>观察者模式所涉及的角色有：</p><p>●　　<strong>抽象主题(Subject)角色：</strong> 抽象主题角色把所有对观察者对象的引用保存在一个聚集（比如ArrayList对象）里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象，抽象主题角色又叫做抽象被观察者(Observable)角色。</p><p>●　　<strong>具体主题(ConcreteSubject)角色：</strong> 将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。具体主题角色又叫做具体被观察者(Concrete Observable)角色。</p><p>●　　<strong>抽象观察者(Observer)角色：</strong> 为所有的具体观察者定义一个接口，在得到主题的通知时更新自己，这个接口叫做更新接口。</p><p>●　　<strong>具体观察者(ConcreteObserver)角色：</strong> 存储与主题的状态自恰的状态。具体观察者角色实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态 像协调。如果需要，具体观察者角色可以保持一个指向具体主题对象的引用。</p><p><strong>抽象主题角色类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Subject</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用来保存注册的观察者对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> List&lt;Observer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Observer&gt;();<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 注册观察者对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> observer    观察者对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attach</span><span class="hljs-params">(Observer observer)</span>&#123;<br>        <br>        list.add(observer);<br>        System.out.println(<span class="hljs-string">&quot;Attached an observer&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除观察者对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> observer    观察者对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">detach</span><span class="hljs-params">(Observer observer)</span>&#123;<br>        <br>        list.remove(observer);<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 通知所有注册的观察者对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyObservers</span><span class="hljs-params">(String newState)</span>&#123;<br>        <br>        <span class="hljs-keyword">for</span>(Observer observer : list)&#123;<br>            observer.update(newState);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>具体主题角色类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteSubject</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Subject</span>&#123;<br>    <br>    <span class="hljs-keyword">private</span> String state;<br>    <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getState</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> state;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">change</span><span class="hljs-params">(String newState)</span>&#123;<br>        state = newState;<br>        System.out.println(<span class="hljs-string">&quot;主题状态为：&quot;</span> + state);<br>        <span class="hljs-comment">//状态发生改变，通知各个观察者</span><br>        <span class="hljs-built_in">this</span>.nodifyObservers(state);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>抽象观察者角色类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Observer</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 更新接口</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> state    更新的状态</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(String state)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>具体观察者角色类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteObserver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Observer</span> &#123;<br>    <span class="hljs-comment">//观察者的状态</span><br>    <span class="hljs-keyword">private</span> String observerState;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(String state)</span> &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 更新观察者的状态，使其与目标的状态保持一致</span><br><span class="hljs-comment">         */</span><br>        observerState = state;<br>        System.out.println(<span class="hljs-string">&quot;状态为：&quot;</span>+observerState);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>客户端类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建主题对象</span><br>        <span class="hljs-type">ConcreteSubject</span> <span class="hljs-variable">subject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteSubject</span>();<br>        <span class="hljs-comment">//创建观察者对象</span><br>        <span class="hljs-type">Observer</span> <span class="hljs-variable">observer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteObserver</span>();<br>        <span class="hljs-comment">//将观察者对象登记到主题对象上</span><br>        subject.attach(observer);<br>        <span class="hljs-comment">//改变主题对象的状态</span><br>        subject.change(<span class="hljs-string">&quot;new state&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出结果</strong>：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402211146366.png"></p><p>在运行时，这个客户端首先创建了具体主题类的实例，以及一个观察者对象。然后，它调用主题对象的attach()方法，将这个观察者对象向主题对象登记，也就是将它加入到主题对象的聚集中去。</p><p>这时，客户端调用主题的change()方法，改变了主题对象的内部状态。主题对象在状态发生变化时，调用超类的notifyObservers()方法，通知所有登记过的观察者对象。</p><h3 id="推模型和拉模型"><a href="#推模型和拉模型" class="headerlink" title="推模型和拉模型"></a>推模型和拉模型</h3><p>在观察者模式中，又分为推模型和拉模型两种方式。<br>●　　<strong>推模型</strong><br>主题对象向观察者推送主题的详细信息，不管观察者是否需要，推送的信息通常是主题对象的全部或部分数据。<br>●　　<strong>拉模型</strong><br>主题对象在通知观察者的时候，只传递少量信息。如果观察者需要更具体的信息，由观察者主动到主题对象中获取，相当于是观察者从主题对象中拉数据。一般这种模型的实现中，会把主题对象自身通过update()方法传递给观察者，这样在观察者需要获取数据的时候，就可以通过这个引用来获取了。</p><p>根据上面的描述，发现前面的例子就是典型的推模型，下面给出一个拉模型的实例。</p><p><strong>拉模型的抽象观察者类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Observer</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 更新接口</span><br><span class="hljs-comment">     * 拉模型通常都是把主题对象当做参数传递。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> subject 传入主题对象，方面获取相应的主题对象的状态</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Subject subject)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>拉模型的具体观察者类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteObserver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Observer</span> &#123;<br>    <span class="hljs-comment">//观察者的状态</span><br>    <span class="hljs-keyword">private</span> String observerState;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Subject subject)</span> &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 更新观察者的状态，使其与目标的状态保持一致</span><br><span class="hljs-comment">         */</span><br>        observerState = ((ConcreteSubject)subject).getState();<br>        System.out.println(<span class="hljs-string">&quot;观察者状态为：&quot;</span>+observerState);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>拉模型的抽象主题类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">　　拉模型的抽象主题类主要的改变是nodifyObservers()方法。在循环通知观察者的时候，也就是循环调用观察者的update()方法的时候，传入的参数不同了。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Subject</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用来保存注册的观察者对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span>    List&lt;Observer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Observer&gt;();<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 注册观察者对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> observer    观察者对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attach</span><span class="hljs-params">(Observer observer)</span>&#123;<br>        <br>        list.add(observer);<br>        System.out.println(<span class="hljs-string">&quot;Attached an observer&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除观察者对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> observer    观察者对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">detach</span><span class="hljs-params">(Observer observer)</span>&#123;<br>        <br>        list.remove(observer);<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 通知所有注册的观察者对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">nodifyObservers</span><span class="hljs-params">()</span>&#123;<br>        <br>        <span class="hljs-keyword">for</span>(Observer observer : list)&#123;<br>            observer.update(<span class="hljs-built_in">this</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>拉模型的具体主题类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">　　跟推模型相比，有一点变化，就是调用通知观察者的方法的时候，不需要传入参数了。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteSubject</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Subject</span>&#123;<br>    <br>    <span class="hljs-keyword">private</span> String state;<br>    <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getState</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> state;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">change</span><span class="hljs-params">(String newState)</span>&#123;<br>        state = newState;<br>        System.out.println(<span class="hljs-string">&quot;主题状态为：&quot;</span> + state);<br>        <span class="hljs-comment">//状态发生改变，通知各个观察者</span><br>        <span class="hljs-built_in">this</span>.nodifyObservers();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="两种模式的比较"><a href="#两种模式的比较" class="headerlink" title="两种模式的比较"></a>两种模式的比较</h3><p>■　　推模型是假定主题对象知道观察者需要的数据；而拉模型是主题对象不知道观察者具体需要什么数据，没有办法的情况下，干脆把自身传递给观察者，让观察者自己去按需要取值。</p><p>■　　推模型可能会使得观察者对象难以复用，因为观察者的update()方法是按需要定义的参数，可能无法兼顾没有考虑到的使用情况。这就意味着出现新情况的时候，就可能提供新的update()方法，或者是干脆重新实现观察者；而拉模型就不会造成这样的情况，因为拉模型下，update()方法的参数是主题对象本身，这基本上是主题对象能传递的最大数据集合了，基本上可以适应各种情况的需要。</p><hr><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p class="note note-primary">命令模式是一种行为设计模式，它允许您将请求封装成对象，使得请求的发送者和接收者彻底解耦。在命令模式中，请求被封装成一个命令对象，这个命令对象可以被传递和存储，从而允许对请求进行参数化和延迟执行。</p><p>命令模式包含以下关键角色：</p><ul><li><strong>Command（命令）</strong>：定义了执行请求的接口。</li><li><strong>ConcreteCommand（具体命令）</strong>：实现了 Command 接口，并封装了请求的接收者。</li><li><strong>Receiver（接收者）</strong>：执行实际操作的对象。</li><li><strong>Invoker（调用者）</strong>：负责调用命令对象执行请求。</li><li><strong>Client（客户端）</strong>：创建命令对象并设置其接收者。</li></ul><p>下面是一个简单的 Java 代码示例，演示了如何使用命令模式来实现一个简单的遥控器控制灯泡的场景：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Command 接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Command</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">// ConcreteCommand 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LightOnCommand</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Command</span> &#123;<br>    <span class="hljs-keyword">private</span> Light light;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LightOnCommand</span><span class="hljs-params">(Light light)</span> &#123;<br>        <span class="hljs-built_in">this</span>.light = light;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span> &#123;<br>        light.turnOn();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Receiver 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Light</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">turnOn</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Light is on&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">turnOff</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Light is off&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Invoker 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RemoteControl</span> &#123;<br>    <span class="hljs-keyword">private</span> Command command;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCommand</span><span class="hljs-params">(Command command)</span> &#123;<br>        <span class="hljs-built_in">this</span>.command = command;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pressButton</span><span class="hljs-params">()</span> &#123;<br>        command.execute();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Client 类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建接收者对象</span><br>        <span class="hljs-type">Light</span> <span class="hljs-variable">light</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Light</span>();<br><br>        <span class="hljs-comment">// 创建命令对象并设置其接收者</span><br>        <span class="hljs-type">Command</span> <span class="hljs-variable">lightOnCommand</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LightOnCommand</span>(light);<br><br>        <span class="hljs-comment">// 创建调用者对象并设置命令对象</span><br>        <span class="hljs-type">RemoteControl</span> <span class="hljs-variable">remoteControl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RemoteControl</span>();<br>        remoteControl.setCommand(lightOnCommand);<br><br>        <span class="hljs-comment">// 模拟按下按钮，执行命令</span><br>        remoteControl.pressButton(); <span class="hljs-comment">// 输出：Light is on</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>在这个示例中，我们创建了一个遥控器（Invoker），并设置了一个命令（Command）来控制灯泡（Receiver）。当我们按下按钮时，调用者会执行命令，命令又会调用接收者执行相应的操作。</p><p>命令模式是一种非常有用的设计模式，它可以将请求封装成对象，从而允许您以参数化的方式进行方法调用、队列请求、日志记录和撤销操作等。</p><p>命令模式非常灵活，允许您轻松地扩展和修改功能。例如，您可以添加新的具体命令类来实现不同的操作，而不需要修改现有的代码。这种可扩展性使得命令模式在面对变化需求时非常有用。</p></blockquote><hr><h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><p class="note note-primary">模板方法模式是一种行为设计模式，它在一个方法中定义了一个算法的骨架，而将一些步骤的具体实现延迟到子类中。这样，可以在不改变算法结构的情况下，重新定义算法的某些步骤。模板方法模式提供了一种代码复用的方式，同时允许更容易地对算法进行定制。</p><p>模板方法模式包含以下关键角色：</p><ul><li><strong>AbstractClass（抽象类）</strong>：定义了一个模板方法，其中包含算法的骨架和一些步骤的具体实现。</li><li><strong>ConcreteClass（具体类）</strong>：实现了抽象类中的某些步骤，完成算法的具体实现。</li></ul><p>下面是一个简单的示例，演示了如何使用模板方法模式来制作咖啡和茶：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 抽象类：饮料</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Beverage</span> &#123;<br>    <span class="hljs-comment">// 模板方法，定义了制作饮料的步骤</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">prepareBeverage</span><span class="hljs-params">()</span> &#123;<br>        boilWater();<br>        brew();<br>        pourInCup();<br>        <span class="hljs-keyword">if</span> (customerWantsCondiments()) &#123;<br>            addCondiments();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 抽象方法，由子类实现</span><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">brew</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addCondiments</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">// 具体方法，共享实现</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">boilWater</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Boiling water&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">pourInCup</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Pouring into cup&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 钩子方法，子类可以选择性地覆盖</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">customerWantsCondiments</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 具体类：咖啡</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Coffee</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Beverage</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">brew</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Dripping Coffee through filter&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">addCondiments</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Adding Sugar and Milk&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 具体类：茶</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tea</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Beverage</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">brew</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Steeping the tea&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">addCondiments</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Adding Lemon&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">customerWantsCondiments</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 茶不加调料</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 客户端代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Beverage</span> <span class="hljs-variable">coffee</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Coffee</span>();<br>        System.out.println(<span class="hljs-string">&quot;Making coffee...&quot;</span>);<br>        coffee.prepareBeverage();<br><br>        System.out.println();<br><br>        <span class="hljs-type">Beverage</span> <span class="hljs-variable">tea</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Tea</span>();<br>        System.out.println(<span class="hljs-string">&quot;Making tea...&quot;</span>);<br>        tea.prepareBeverage();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在这个示例中，<code>Beverage</code> 是抽象类，定义了制作饮料的模板方法 <code>prepareBeverage()</code>，以及一些共享的具体方法。<code>Coffee</code> 和 <code>Tea</code> 是具体类，分别实现了 <code>brew()</code> 和 <code>addCondiments()</code> 方法，以完成制作咖啡和茶的过程。</p><p><strong>JDK 中的应用</strong></p><p>在 JDK 中，模板方法模式被广泛应用。其中一个典型的例子就是在 <code>java.util.AbstractList</code> 类中。这个类实现了 <code>java.util.List</code> 接口，提供了 <code>equals()</code> 和 <code>hashCode()</code> 方法的默认实现，这些方法都是模板方法。以下是 <code>AbstractList</code> 类中的部分核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// java.util.AbstractList 类中的部分代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractList</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractCollection</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">List</span>&lt;E&gt; &#123;<br>    <span class="hljs-comment">// 省略其他方法</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!(o <span class="hljs-keyword">instanceof</span> List)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        Iterator&lt;E&gt; e1 = iterator();<br>        ListIterator&lt;?&gt; e2 = ((List&lt;?&gt;) o).listIterator();<br>        <span class="hljs-keyword">while</span> (e1.hasNext() &amp;&amp; e2.hasNext()) &#123;<br>            <span class="hljs-type">E</span> <span class="hljs-variable">o1</span> <span class="hljs-operator">=</span> e1.next();<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">o2</span> <span class="hljs-operator">=</span> e2.next();<br>            <span class="hljs-keyword">if</span> (!(o1==<span class="hljs-literal">null</span> ? o2==<span class="hljs-literal">null</span> : o1.equals(o2))) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> !(e1.hasNext() || e2.hasNext());<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">hashCode</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (E e : <span class="hljs-built_in">this</span>) &#123;<br>            hashCode = <span class="hljs-number">31</span> * hashCode + (e == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : e.hashCode());<br>        &#125;<br>        <span class="hljs-keyword">return</span> hashCode;<br>    &#125;<br><br>    <span class="hljs-comment">// 省略其他方法</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>equals()</code> 和 <code>hashCode()</code> 方法就是模板方法，它们定义了算法的骨架，具体的比较和哈希计算操作由子类实现。</p><p>模板方法模式是一种非常有用的设计模式，它提供了一种代码复用的方式，并允许在不改变算法结构的情况下，重新定义算法的某些步骤。在 JDK 中，模板方法模式被广泛应用于各种类库和框架中，如集合框架、IO 操作等。</p><hr><h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><p class="note note-primary">状态模式（State Pattern）是一种行为设计模式，它允许对象在其内部状态改变时改变其行为。这种模式的关键是将对象的状态封装成不同的类，并将行为委托给当前状态对象。状态模式可以使得对象的状态转换更加清晰、简单，并且避免了使用大量的条件语句。</p><p><strong>角色介绍</strong></p><ul><li><strong>Context（上下文）</strong>：定义客户端感兴趣的接口，维护一个当前状态对象。</li><li><strong>State（状态）</strong>：定义一个接口，用于封装与 Context 相关的行为。</li><li><strong>ConcreteState（具体状态）</strong>：实现 State 接口的具体状态类，负责处理与状态相关的操作。</li></ul><p><strong>应用示例</strong></p><p>下面是一个简单的示例，演示了如何使用状态模式来实现一个电梯控制器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 上下文类：电梯</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Elevator</span> &#123;<br>    <span class="hljs-keyword">private</span> State state;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Elevator</span><span class="hljs-params">()</span> &#123;<br>        state = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClosedState</span>(); <span class="hljs-comment">// 初始化为关闭状态</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setState</span><span class="hljs-params">(State state)</span> &#123;<br>        <span class="hljs-built_in">this</span>.state = state;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">open</span><span class="hljs-params">()</span> &#123;<br>        state.open(<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> &#123;<br>        state.close(<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">()</span> &#123;<br>        state.move(<span class="hljs-built_in">this</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 状态接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">State</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">open</span><span class="hljs-params">(Elevator elevator)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">(Elevator elevator)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">(Elevator elevator)</span>;<br>&#125;<br><br><span class="hljs-comment">// 具体状态类：关闭状态</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClosedState</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">State</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">open</span><span class="hljs-params">(Elevator elevator)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Opening the door...&quot;</span>);<br>        elevator.setState(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OpenState</span>());<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">(Elevator elevator)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;The door is already closed.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">(Elevator elevator)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Moving the elevator...&quot;</span>);<br>        elevator.setState(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MovingState</span>());<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 具体状态类：打开状态</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">OpenState</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">State</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">open</span><span class="hljs-params">(Elevator elevator)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;The door is already open.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">(Elevator elevator)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Closing the door...&quot;</span>);<br>        elevator.setState(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClosedState</span>());<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">(Elevator elevator)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Cannot move while the door is open.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 具体状态类：运行状态</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MovingState</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">State</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">open</span><span class="hljs-params">(Elevator elevator)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Cannot open the door while the elevator is moving.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">(Elevator elevator)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Cannot close the door while the elevator is moving.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">(Elevator elevator)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;The elevator is already moving.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 客户端代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Elevator</span> <span class="hljs-variable">elevator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Elevator</span>();<br><br>        elevator.open();<br>        elevator.close();<br>        elevator.move();<br>        elevator.open();<br>        elevator.move();<br>        elevator.close();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在这个示例中，<code>Elevator</code> 类是上下文类，负责维护当前状态，并将状态相关的操作委托给当前状态对象。<code>State</code> 接口定义了状态的行为，具体状态类实现了该接口，并负责处理与状态相关的操作。</p><p><strong>JDK 中的应用</strong></p><p>在 JDK 中，状态模式被广泛应用。其中一个典型的例子就是在 <code>java.awt.Component</code> 类中。这个类表示可视化组件，其中的 <code>setVisible()</code> 方法就是使用了状态模式。以下是 <code>Component</code> 类中的部分核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// java.awt.Component 类中的部分代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Component</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> visible;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setVisible</span><span class="hljs-params">(<span class="hljs-type">boolean</span> visible)</span> &#123;<br>        <span class="hljs-built_in">this</span>.visible = visible;<br>        <span class="hljs-keyword">if</span> (visible) &#123;<br>            <span class="hljs-comment">// 显示组件的相关操作</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 隐藏组件的相关操作</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 其他方法</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>Component</code> 类维护了一个 <code>visible</code> 属性，用于表示组件的可见状态。根据这个状态的改变，<code>setVisible()</code> 方法会执行不同的操作，从而改变组件的行为。</p><p>状态模式是一种非常有用的设计模式，它可以使得对象在其内部状态改变时改变其行为。通过将状态封装成不同的类，并委托给当前状态对象处理相关操作，状态模式使得代码更加清晰、简单，并且避免了使用大量的条件语句。</p><hr><h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><p class="note note-primary">责任链模式（Chain of Responsibility Pattern）是一种行为设计模式，它允许多个对象都有机会处理请求，从而避免了请求的发送者和接收者之间的耦合关系。在责任链模式中，请求沿着一个链条传递，直到有一个对象处理它为止。</p><p><strong>角色介绍</strong></p><ul><li><strong>Handler（处理器）</strong>：定义了处理请求的接口，并维护了一个指向下一个处理器的引用。</li><li><strong>ConcreteHandler（具体处理器）</strong>：实现了处理器接口的具体处理器类，负责处理它所能处理的请求，并在不能处理时将请求传递给下一个处理器</li></ul><p><strong>应用示例</strong></p><p>考虑一个简单的购买审批系统，其中包含三个级别的审批人：经理、副总裁和总裁。如果购买金额小于等于1000元，经理可以直接批准；如果金额在1000到5000元之间，需要副总裁审批；如果金额超过5000元，需要总裁审批。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 处理器接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Approver</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">processRequest</span><span class="hljs-params">(PurchaseRequest request)</span>;<br>&#125;<br><br><span class="hljs-comment">// 具体处理器类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Manager</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Approver</span> &#123;<br>    <span class="hljs-keyword">private</span> Approver nextApprover;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processRequest</span><span class="hljs-params">(PurchaseRequest request)</span> &#123;<br>        <span class="hljs-keyword">if</span> (request.getAmount() &lt;= <span class="hljs-number">1000</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Manager approves purchase request #&quot;</span> + request.getId());<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nextApprover != <span class="hljs-literal">null</span>) &#123;<br>            nextApprover.processRequest(request);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;No one can handle the purchase request #&quot;</span> + request.getId());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNextApprover</span><span class="hljs-params">(Approver nextApprover)</span> &#123;<br>        <span class="hljs-built_in">this</span>.nextApprover = nextApprover;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">VicePresident</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Approver</span> &#123;<br>    <span class="hljs-keyword">private</span> Approver nextApprover;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processRequest</span><span class="hljs-params">(PurchaseRequest request)</span> &#123;<br>        <span class="hljs-keyword">if</span> (request.getAmount() &lt;= <span class="hljs-number">5000</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Vice President approves purchase request #&quot;</span> + request.getId());<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nextApprover != <span class="hljs-literal">null</span>) &#123;<br>            nextApprover.processRequest(request);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;No one can handle the purchase request #&quot;</span> + request.getId());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNextApprover</span><span class="hljs-params">(Approver nextApprover)</span> &#123;<br>        <span class="hljs-built_in">this</span>.nextApprover = nextApprover;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">President</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Approver</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processRequest</span><span class="hljs-params">(PurchaseRequest request)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;President approves purchase request #&quot;</span> + request.getId());<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 请求类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PurchaseRequest</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> amount;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PurchaseRequest</span><span class="hljs-params">(<span class="hljs-type">int</span> id, <span class="hljs-type">double</span> amount)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.amount = amount;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getAmount</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> amount;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 客户端代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 构建责任链</span><br>        <span class="hljs-type">Approver</span> <span class="hljs-variable">manager</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Manager</span>();<br>        <span class="hljs-type">Approver</span> <span class="hljs-variable">vicePresident</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VicePresident</span>();<br>        <span class="hljs-type">Approver</span> <span class="hljs-variable">president</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">President</span>();<br><br>        manager.setNextApprover(vicePresident);<br>        vicePresident.setNextApprover(president);<br><br>        <span class="hljs-comment">// 创建购买请求</span><br>        <span class="hljs-type">PurchaseRequest</span> <span class="hljs-variable">request1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PurchaseRequest</span>(<span class="hljs-number">1</span>, <span class="hljs-number">800</span>);<br>        <span class="hljs-type">PurchaseRequest</span> <span class="hljs-variable">request2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PurchaseRequest</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3500</span>);<br>        <span class="hljs-type">PurchaseRequest</span> <span class="hljs-variable">request3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PurchaseRequest</span>(<span class="hljs-number">3</span>, <span class="hljs-number">7000</span>);<br><br>        <span class="hljs-comment">// 处理购买请求</span><br>        manager.processRequest(request1);<br>        manager.processRequest(request2);<br>        manager.processRequest(request3);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>JDK 中的应用</strong></p><p>在 JDK 中，责任链模式被广泛应用。其中一个典型的例子是 Servlet 中的过滤器链。Servlet 过滤器链是一系列过滤器按照顺序链接在一起，每个过滤器负责处理请求或者将请求传递给下一个过滤器。以下是 Servlet 过滤器链的核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Filter</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">FilterChain</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response)</span> <span class="hljs-keyword">throws</span> IOException, ServletException;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>Filter</code> 接口代表一个过滤器，其中的 <code>doFilter()</code> 方法负责处理请求或者将请求传递给下一个过滤器。而 <code>FilterChain</code> 接口表示一个过滤器链，其中的 <code>doFilter()</code> 方法将请求传递给下一个过滤器。</p><hr><h2 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h2><p class="note note-primary">解释器模式（Interpreter Pattern）是一种行为设计模式，用于定义一个语言的文法，并且提供解释器来解释该语言中的语句。这种模式将语言中的语句表示为抽象语法树，并提供一种方式来递归地解释该树中的节点。</p><p><strong>角色介绍</strong></p><ul><li><strong>AbstractExpression（抽象表达式）</strong>：声明了一个抽象的解释方法 <code>interpret()</code>，所有的具体表达式都继承自该抽象类。</li><li><strong>TerminalExpression（终结符表达式）</strong>：实现了抽象表达式接口，表示语言中的终结符，即不可再分解的最小单元。</li><li><strong>NonterminalExpression（非终结符表达式）</strong>：实现了抽象表达式接口，表示语言中的非终结符，即可再分解的复合单元。</li><li><strong>Context（上下文）</strong>：包含解释器需要的一些全局信息或状态。</li></ul><p><strong>应用示例</strong></p><p>假设我们需要实现一个简单的表达式解析器，可以解析简单的四则运算表达式，例如 <code>1 + 2 - 3 * 4</code>。我们可以使用解释器模式来实现这个功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 抽象表达式接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Expression</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">interpret</span><span class="hljs-params">(Context context)</span>;<br>&#125;<br><br><span class="hljs-comment">// 终结符表达式：数字</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumberExpression</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Expression</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> number;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NumberExpression</span><span class="hljs-params">(<span class="hljs-type">int</span> number)</span> &#123;<br>        <span class="hljs-built_in">this</span>.number = number;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">interpret</span><span class="hljs-params">(Context context)</span> &#123;<br>        <span class="hljs-keyword">return</span> number;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 非终结符表达式：加法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddExpression</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Expression</span> &#123;<br>    <span class="hljs-keyword">private</span> Expression left;<br>    <span class="hljs-keyword">private</span> Expression right;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AddExpression</span><span class="hljs-params">(Expression left, Expression right)</span> &#123;<br>        <span class="hljs-built_in">this</span>.left = left;<br>        <span class="hljs-built_in">this</span>.right = right;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">interpret</span><span class="hljs-params">(Context context)</span> &#123;<br>        <span class="hljs-keyword">return</span> left.interpret(context) + right.interpret(context);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 非终结符表达式：减法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubstractExpression</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Expression</span> &#123;<br>    <span class="hljs-keyword">private</span> Expression left;<br>    <span class="hljs-keyword">private</span> Expression right;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SubstractExpression</span><span class="hljs-params">(Expression left, Expression right)</span> &#123;<br>        <span class="hljs-built_in">this</span>.left = left;<br>        <span class="hljs-built_in">this</span>.right = right;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">interpret</span><span class="hljs-params">(Context context)</span> &#123;<br>        <span class="hljs-keyword">return</span> left.interpret(context) - right.interpret(context);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 非终结符表达式：乘法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MultiplyExpression</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Expression</span> &#123;<br>    <span class="hljs-keyword">private</span> Expression left;<br>    <span class="hljs-keyword">private</span> Expression right;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MultiplyExpression</span><span class="hljs-params">(Expression left, Expression right)</span> &#123;<br>        <span class="hljs-built_in">this</span>.left = left;<br>        <span class="hljs-built_in">this</span>.right = right;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">interpret</span><span class="hljs-params">(Context context)</span> &#123;<br>        <span class="hljs-keyword">return</span> left.interpret(context) * right.interpret(context);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">// 上下文类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Context</span> &#123;<br>    <span class="hljs-comment">// 如果需要的话，可以在这里添加一些上下文信息</span><br>&#125;<br><br><span class="hljs-comment">// 客户端代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 构建解释器表达式树：1 + 2 - 3 * 4</span><br>        <span class="hljs-type">Expression</span> <span class="hljs-variable">expression</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubstractExpression</span>(<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">AddExpression</span>( <br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">NumberExpression</span>(<span class="hljs-number">1</span>), <br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">NumberExpression</span>(<span class="hljs-number">2</span>) <br>            ), <br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">MultiplyExpression</span>( <br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">NumberExpression</span>(<span class="hljs-number">3</span>), <br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">NumberExpression</span>(<span class="hljs-number">4</span>) <br>            )<br>        );<br><br>        <span class="hljs-comment">// 创建上下文对象</span><br>        <span class="hljs-type">Context</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Context</span>();<br><br>        <span class="hljs-comment">// 解释表达式并输出结果</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> expression.interpret(context);<br>        System.out.println(<span class="hljs-string">&quot;Result: &quot;</span> + result); <span class="hljs-comment">// 输出：-9</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>解释器模式是一种在特定场景下非常有用的设计模式，它可以帮助我们构建简单的语言解释器，实现对特定语言的解析和执行。通过将语言表示为抽象语法树，并提供一种递归的解释方式，解释器模式使得对复杂语言的处理变得简单、清晰。</p><hr><h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><p class="note note-primary">中介者模式（Mediator Pattern）是一种行为设计模式，它允许对象之间通过一个中介对象进行通信，而不直接相互引用。这种模式可以减少对象之间的耦合，使系统更易于维护和扩展。</p><p><strong>角色介绍</strong></p><ul><li><strong>Mediator（中介者）</strong>：定义了一个接口用于与各个同事对象通信。</li><li><strong>ConcreteMediator（具体中介者）</strong>：实现了中介者接口，负责协调各个同事对象之间的交互。</li><li><strong>Colleague（同事）</strong>：定义了一个接口用于与中介者进行通信。</li><li><strong>ConcreteColleague（具体同事）</strong>：实现了同事接口，每个具体同事对象都知道中介者对象，并通过中介者对象来与其他同事对象通信。</li></ul><p><strong>应用示例</strong></p><p>考虑一个简单的聊天室系统，其中有多个用户可以在聊天室中发送消息。我们可以使用中介者模式来实现该聊天室系统。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 中介者接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ChatMediator</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMessage</span><span class="hljs-params">(String message, User user)</span>;<br>&#125;<br><br><span class="hljs-comment">// 具体中介者类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ChatRoom</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ChatMediator</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMessage</span><span class="hljs-params">(String message, User user)</span> &#123;<br>        System.out.println(user.getName() + <span class="hljs-string">&quot; sends message: &quot;</span> + message);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 同事接口</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">protected</span> ChatMediator mediator;<br>    <span class="hljs-keyword">protected</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(ChatMediator mediator, String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.mediator = mediator;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMessage</span><span class="hljs-params">(String message)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiveMessage</span><span class="hljs-params">(String message)</span>;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 具体同事类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BasicUser</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BasicUser</span><span class="hljs-params">(ChatMediator mediator, String name)</span> &#123;<br>        <span class="hljs-built_in">super</span>(mediator, name);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMessage</span><span class="hljs-params">(String message)</span> &#123;<br>        mediator.sendMessage(message, <span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiveMessage</span><span class="hljs-params">(String message)</span> &#123;<br>        System.out.println(name + <span class="hljs-string">&quot; receives message: &quot;</span> + message);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 客户端代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ChatMediator</span> <span class="hljs-variable">mediator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChatRoom</span>();<br><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BasicUser</span>(mediator, <span class="hljs-string">&quot;Alice&quot;</span>);<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BasicUser</span>(mediator, <span class="hljs-string">&quot;Bob&quot;</span>);<br><br>        mediator.sendMessage(<span class="hljs-string">&quot;Hello, everyone!&quot;</span>, user1);<br>        user2.sendMessage(<span class="hljs-string">&quot;Hi, Alice!&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>中介者模式是一种非常有用的设计模式，它可以帮助我们降低系统中对象之间的耦合度，提高代码的可维护性和可扩展性。通过引入一个中介者对象来管理对象之间的通信，中介者模式使得系统更易于理解和修改。</p><hr><h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><p class="note note-primary">访问者模式（Visitor Pattern）是一种行为设计模式，用于在不修改现有代码的情况下，向对象结构中添加新操作。该模式将操作封装到访问者对象中，并在对象结构中的每个元素上应用访问者，从而实现新的操作。</p><p><strong>角色介绍</strong></p><ul><li><strong>Visitor（访问者）</strong>：定义了一个访问方法，用于接受不同类型元素的访问。</li><li><strong>ConcreteVisitor（具体访问者）</strong>：实现了访问者接口，提供了对元素的具体访问逻辑。</li><li><strong>Element（元素）</strong>：定义了一个接受访问者的方法，用于接受访问者的访问。</li><li><strong>ConcreteElement（具体元素）</strong>：实现了元素接口，提供了对访问者的具体接受方法。</li><li><strong>ObjectStructure（对象结构）</strong>：维护了一个元素的集合，并提供了一个接受访问者的方法。</li></ul><p><strong>应用示例</strong></p><p>假设我们有一个简单的图形界面系统，其中包含不同类型的图形元素，如圆形、矩形等。我们希望对这些图形元素进行不同的操作，比如计算面积、绘制等。我们可以使用访问者模式来实现这个功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 访问者接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ShapeVisitor</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(Circle circle)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(Rectangle rectangle)</span>;<br>&#125;<br><br><span class="hljs-comment">// 具体访问者类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AreaVisitor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ShapeVisitor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(Circle circle)</span> &#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">area</span> <span class="hljs-operator">=</span> Math.PI * Math.pow(circle.getRadius(), <span class="hljs-number">2</span>);<br>        System.out.println(<span class="hljs-string">&quot;Area of circle: &quot;</span> + area);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(Rectangle rectangle)</span> &#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">area</span> <span class="hljs-operator">=</span> rectangle.getWidth() * rectangle.getHeight();<br>        System.out.println(<span class="hljs-string">&quot;Area of rectangle: &quot;</span> + area);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 元素接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(ShapeVisitor visitor)</span>;<br>&#125;<br><br><span class="hljs-comment">// 具体元素类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> radius;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Circle</span><span class="hljs-params">(<span class="hljs-type">double</span> radius)</span> &#123;<br>        <span class="hljs-built_in">this</span>.radius = radius;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getRadius</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> radius;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(ShapeVisitor visitor)</span> &#123;<br>        visitor.visit(<span class="hljs-built_in">this</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> width;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> height;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Rectangle</span><span class="hljs-params">(<span class="hljs-type">double</span> width, <span class="hljs-type">double</span> height)</span> &#123;<br>        <span class="hljs-built_in">this</span>.width = width;<br>        <span class="hljs-built_in">this</span>.height = height;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getWidth</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> width;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getHeight</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> height;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(ShapeVisitor visitor)</span> &#123;<br>        visitor.visit(<span class="hljs-built_in">this</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 对象结构类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ShapeCollection</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;Shape&gt; shapes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addShape</span><span class="hljs-params">(Shape shape)</span> &#123;<br>        shapes.add(shape);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(ShapeVisitor visitor)</span> &#123;<br>        <span class="hljs-keyword">for</span> (Shape shape : shapes) &#123;<br>            shape.accept(visitor);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 客户端代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ShapeCollection</span> <span class="hljs-variable">collection</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ShapeCollection</span>();<br>        collection.addShape(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Circle</span>(<span class="hljs-number">5</span>));<br>        collection.addShape(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Rectangle</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>));<br><br>        <span class="hljs-type">ShapeVisitor</span> <span class="hljs-variable">areaVisitor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AreaVisitor</span>();<br>        collection.accept(areaVisitor);<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>访问者模式是一种非常有用的设计模式，它可以帮助我们在不修改现有代码的情况下，向对象结构中添加新的操作。通过将操作封装到访问者对象中，并在对象结构中的每个元素上应用访问者，访问者模式使得代码更加灵活和易于扩展。</p><hr><h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><p class="note note-primary">备忘录模式（Memento Pattern）是一种行为设计模式，用于捕获对象的内部状态，并在不破坏对象封装性的情况下将其保存在外部，并在需要时恢复对象状态。这种模式有助于实现撤销操作和历史记录功能。</p><p><strong>角色介绍</strong></p><ul><li><strong>Originator（发起人）</strong>：负责创建备忘录对象，并可以使用备忘录对象恢复自身状态。</li><li><strong>Memento（备忘录）</strong>：负责存储发起人对象的内部状态。</li><li><strong>Caretaker（管理者）</strong>：负责保存备忘录对象，并在需要时将其返回给发起人对象。</li></ul><p><strong>应用示例</strong></p><p>假设我们有一个简单的文本编辑器，用户可以在其中输入文本，并且可以通过撤销功能回到之前的状态。我们可以使用备忘录模式来实现这个功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 备忘录类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TextMemento</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String text;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TextMemento</span><span class="hljs-params">(String text)</span> &#123;<br>        <span class="hljs-built_in">this</span>.text = text;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getText</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> text;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 发起人类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TextEditor</span> &#123;<br>    <span class="hljs-keyword">private</span> String text;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setText</span><span class="hljs-params">(String text)</span> &#123;<br>        <span class="hljs-built_in">this</span>.text = text;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getText</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> text;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> TextMemento <span class="hljs-title function_">save</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextMemento</span>(text);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">restore</span><span class="hljs-params">(TextMemento memento)</span> &#123;<br>        <span class="hljs-built_in">this</span>.text = memento.getText();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 管理者类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">History</span> &#123;<br>    <span class="hljs-keyword">private</span> Stack&lt;TextMemento&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(TextMemento memento)</span> &#123;<br>        stack.push(memento);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> TextMemento <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> stack.pop();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 客户端代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">TextEditor</span> <span class="hljs-variable">editor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextEditor</span>();<br>        <span class="hljs-type">History</span> <span class="hljs-variable">history</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">History</span>();<br><br>        editor.setText(<span class="hljs-string">&quot;Hello, world!&quot;</span>);<br>        history.push(editor.save());<br>        System.out.println(<span class="hljs-string">&quot;Current text: &quot;</span> + editor.getText());<br><br>        editor.setText(<span class="hljs-string">&quot;Java Design Patterns&quot;</span>);<br>        history.push(editor.save());<br>        System.out.println(<span class="hljs-string">&quot;Current text: &quot;</span> + editor.getText());<br><br>        <span class="hljs-comment">// 撤销一次</span><br>        editor.restore(history.pop());<br>        System.out.println(<span class="hljs-string">&quot;Current text after undo: &quot;</span> + editor.getText());<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>在这个示例中，<code>TextEditor</code> 类充当了发起人角色，负责创建备忘录对象并保存和恢复状态。</li><li><code>TextMemento</code> 类充当了备忘录角色，负责存储发起人对象的内部状态。</li><li><code>History</code> 类充当了管理者角色，负责保存备忘录对象，并在需要时将其返回给发起人对象。</li></ul><p>备忘录模式是一种非常有用的设计模式，它可以帮助我们实现撤销操作和历史记录功能，而不破坏对象的封装性。通过将对象的状态保存在外部，并在需要时恢复状态，备忘录模式使得程序更加灵活和易于维护。</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>行为型模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重拾设计模式（二）</title>
    <link href="/posts/509408b0/"/>
    <url>/posts/509408b0/</url>
    
    <content type="html"><![CDATA[<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p class="note note-primary">适配器模式（Adapter Pattern）将一个类的接口转换成客户端所希望的另一个接口，适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p><blockquote><p>用电器做例子，笔记本电脑的插头一般都是三相的，即除了阳极、阴极外，还有一个地极。而有些地方的电源插座却只有两极，没有地极。电源插座与笔记本电脑的电源插头不匹配使得笔记本电脑无法使用。这时候一个三相到两相的转换器（适配器）就能解决此问题，而这正像是本模式所做的事情。</p></blockquote><p>适配器模式有<strong>类的适配器模式</strong>和<strong>对象的适配器模式</strong>两种不同的形式。</p><h3 id="类的适配器模式"><a href="#类的适配器模式" class="headerlink" title="类的适配器模式"></a>类的适配器模式</h3><p class="note note-primary">类的适配器模式把适配的类的API转换成为目标类的API。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201630926.png"></p><p>在上图中可以看出，Adaptee类并没有sampleOperation2()方法，而客户端则期待这个方法。为使客户端能够使用Adaptee类，提供一个中间环节，即类Adapter，把Adaptee的API与Target类的API衔接起来。Adapter与Adaptee是继承关系，这决定了这个适配器模式是类的。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201631845.png"></p><p><strong>Target</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Target</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 这是源类Adaptee也有的方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sampleOperation1</span><span class="hljs-params">()</span>; <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 这是源类Adapteee没有的方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sampleOperation2</span><span class="hljs-params">()</span>; <br>&#125;<br></code></pre></td></tr></table></figure><p>上面给出的是目标角色的源代码，这个角色是以一个JAVA接口的形式实现的。可以看出，这个接口声明了两个方法：sampleOperation1()和sampleOperation2()。而源角色Adaptee是一个具体类，它有一个sampleOperation1()方法，但是没有sampleOperation2()方法。</p><p><strong>Adaptee</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Adaptee</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sampleOperation1</span><span class="hljs-params">()</span>&#123;&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>适配器角色Adapter扩展了Adaptee,同时又实现了目标(Target)接口。由于Adaptee没有提供sampleOperation2()方法，而目标接口又要求这个方法，因此适配器角色Adapter实现了这个方法。</p><p><strong>Adapter</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Adapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Adaptee</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Target</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 由于源类Adaptee没有方法sampleOperation2()</span><br><span class="hljs-comment">     * 因此适配器补充上这个方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sampleOperation2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//写相关的代码</span><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="对象的适配器模式"><a href="#对象的适配器模式" class="headerlink" title="对象的适配器模式"></a>对象的适配器模式</h3><p class="note note-primary">与类的适配器模式一样，对象的适配器模式把被适配的类的API转换成为目标类的API，与类的适配器模式不同的是，对象的适配器模式不是使用继承关系连接到Adaptee类，而是使用委派关系连接到Adaptee类</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201634934.png"></p><p>从上图可以看出，Adaptee类并没有sampleOperation2()方法，而客户端则期待这个方法。为使客户端能够使用Adaptee类，需要提供一个包装(Wrapper)类Adapter。这个包装类包装了一个Adaptee的实例，从而此包装类能够把Adaptee的API与Target类的API衔接起来。Adapter与Adaptee是委派关系，这决定了适配器模式是对象的。</p><p><strong>Target</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Target</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 这是源类Adaptee也有的方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sampleOperation1</span><span class="hljs-params">()</span>; <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 这是源类Adapteee没有的方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sampleOperation2</span><span class="hljs-params">()</span>; <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Adaptee</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Adaptee</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sampleOperation1</span><span class="hljs-params">()</span>&#123;&#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Adapter</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Adapter</span> &#123;<br>    <span class="hljs-keyword">private</span> Adaptee adaptee;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Adapter</span><span class="hljs-params">(Adaptee adaptee)</span>&#123;<br>        <span class="hljs-built_in">this</span>.adaptee = adaptee;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 源类Adaptee有方法sampleOperation1</span><br><span class="hljs-comment">     * 因此适配器类直接委派即可</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sampleOperation1</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-built_in">this</span>.adaptee.sampleOperation1();<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 源类Adaptee没有方法sampleOperation2</span><br><span class="hljs-comment">     * 因此由适配器类需要补充此方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sampleOperation2</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//写相关的代码</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="类适配器和对象适配器"><a href="#类适配器和对象适配器" class="headerlink" title="类适配器和对象适配器"></a>类适配器和对象适配器</h3><p>●<strong>类适配器</strong>使用对象继承的方式，是静态的定义方式；而<strong>对象适配器</strong>使用对象组合的方式，是动态组合的方式。</p><p>●<strong>对于类适配器</strong>，由于适配器直接继承了Adaptee，使得适配器不能和Adaptee的子类一起工作，因为继承是静态的关系，当适配器继承了Adaptee后，就不可能再去处理  Adaptee的子类了。</p><p> <strong>对于对象适配器</strong>，一个适配器可以把多种不同的源适配到同一个目标。换言之，同一个适配器可以把源类和它的子类都适配到目标接口。因为对象适配器采用的是对象组合的关系，只要对象类型正确，是不是子类都无所谓。</p><p>●<strong>对于类适配器</strong>，适配器可以重定义Adaptee的部分行为，相当于子类覆盖父类的部分实现方法。</p><p> <strong>对于对象适配器</strong>，要重定义Adaptee的行为比较困难，这种情况下，需要定义Adaptee的子类来实现重定义，然后让适配器组合子类。虽然重定义Adaptee的行为比较困难，但是想要增加一些新的行为则方便的很，而且新增加的行为可同时适用于所有的源。</p><p>●<strong>对于类适配器</strong>，仅仅引入了一个对象，并不需要额外的引用来间接得到Adaptee。</p><p> <strong>对于对象适配器</strong>，需要额外的引用来间接得到Adaptee。</p><p><strong>建议尽量使用对象适配器的实现方式</strong>，多用合成&#x2F;聚合、少用继承。当然，具体问题具体分析，根据需要来选用实现方式，最适合的才是最好的。</p><h3 id="缺省适配模式"><a href="#缺省适配模式" class="headerlink" title="缺省适配模式"></a>缺省适配模式</h3><p class="note note-primary">缺省适配(Default Adapter)模式为一个接口提供缺省实现，这样子类型可以从这个缺省实现进行扩展，而不必从原有接口进行扩展。作为适配器模式的一个特例，缺省是适配模式在JAVA语言中有着特殊的应用。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201706389.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">AbstractService</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serviceOperation1</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">serviceOperation2</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">serviceOperation3</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AbstractService</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serviceOperation1</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">serviceOperation2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">serviceOperation3</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>可以看到，接口AbstractService要求定义三个方法，分别是serviceOperation1()、serviceOperation2()、serviceOperation3()；而抽象适配器类ServiceAdapter则为这三种方法都提供了平庸的实现。因此，任何继承自抽象类ServiceAdapter的具体类都可以选择它所需要的方法实现，而不必理会其他的不需要的方法。</p><p><strong>适配器模式的用意</strong>是要改变源的接口，以便于目标接口相容。<strong>缺省适配的用意稍有不同</strong>，它是为了方便建立一个不平庸的适配器类而提供的一种平庸实现。</p><p>在任何时候，如果不准备实现一个接口的所有方法时，就可以使用“缺省适配模式”制造一个抽象类，给出所有方法的平庸的具体实现。这样，从这个抽象类再继承下去的子类就不必实现所有的方法了。</p></blockquote><hr><h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><p class="note note-primary">桥接模式的本质是把抽象(Abstraction)与行为实现(Implementation)分离开来，从而可以保持各部分的独立性以及应对他们的功能扩展，基于类的最小设计原则，通过使用封装、聚合及继承等行为让不同的类承担不同的职责。</p><p><strong>示例</strong></p><p>一个咖啡店卖咖啡，卖出的咖啡可以从几个角度来看：</p><ol><li><p>口味：摩卡、拿铁、美式等；</p></li><li><p>容量：大杯、中杯、小杯等；</p></li><li><p>添加物：牛奶、糖、蜂蜜等；</p></li><li><p>温度：热、常温、冷等；</p></li></ol><p>如果需要设计一个点餐系统，来生成咖啡订单，如何在系统中将上面说到的拥有4个属性的咖啡生成呢？</p><p><strong>第一种方法</strong></p><p>为每种咖啡组合编写不同的类，如下</p><ol><li><p>大杯热牛奶摩卡类；</p></li><li><p>中杯热牛奶摩卡类；</p></li><li><p>小杯热牛奶摩卡类；</p></li><li><p>大杯热蜂蜜摩卡类； ……</p></li></ol><p>试想一下，需要多少各类？假设4个维度分别可选的值是a、b、c、d，那么需要定义的类就是a x b x c x d种。而且每种属性都是固化到特定的类，没法复用，按照这个方法要定义3x3x3x3&#x3D;81个类。</p><p><strong>第二种方法</strong></p><p>针对第一种方法，我们能不能单独定义每种属性，并让每种属性能够复用，然后将他们组合&#x2F;聚合起来形成一杯咖啡呢？这样就减少每个属性的重复定义了。 例如： 1. 口味：摩卡、拿铁、美式等分别定义一个类；3个类 2. 容量：大杯、中杯、小杯等分别定义一个类；3个类 3. 添加物：牛奶、糖、蜂蜜等分别定义一个类；3个类 4. 温度：热、常温、冷等分别定义一个类；3个类</p><p>如果能够找到一种方法把这4个维度组合起来，是不是总的类数就变成a+b+c+d&#x3D;3+3+3+3&#x3D;12个类？类的数量锐减。</p><p>那么如何将这个4个维度组合起来实现一杯咖啡呢？</p><p><strong>桥接模式的原理</strong></p><p class="note note-primary">桥接模式就是为了实现上面的第二种方法的，先进行抽象，然后通过桥接将属性连接起来。</p><p>看一下下面原理图（初步思路）：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201725509.png"></p><p>再优化一下，进一步思路如下图：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201726170.png"></p><p>想一下，咖啡的最重要的属性就是口味（也可以说是本质的属性），其它的属性相对来说不是最重要的，那么我们就让口味直接通过继承的方式实现属性的集成，其它三个属性为了提升替换性&#x2F;重用性，可以也进行一个抽象类的定义，然后去具体实现。</p><p>这样设计后，通过组合&#x2F;聚合实现了咖啡多个属性的集成，减少了类的数量。</p><p>图中组合&#x2F;聚合关系就是桥接模式中Bridge的核心要义，通过组合&#x2F;聚合将多个属性连接起来的。</p><p>最后就形成了桥接模式的通用示意图，如下：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201730057.png"></p><p>**桥接模式的角色：</p><ul><li><p> <strong>抽象化(Abstraction)角色</strong>：抽象化给出的定义，并保存一个对实现化对象的引用，就是上面所说的Coffe抽象类。</p></li><li><p><strong>修正抽象化(RefinedAbstraction)角色</strong>：扩展抽象化角色，改变和修正父类对抽象化的定义，就是上面的<strong>口味实现类</strong>。  </p></li><li><p><strong>实现化(Implementor)角色</strong>：这个角色给出实现化角色的接口，但不给出具体的实现。必须指出的是，这个接口不一定和抽象化角色的接口定义相同，实际上，这两个接口可以非常不一样。实现化角色应当只给出底层操作，而抽象化角色应当只给出基于底层操作的更高一层的操作。就是上面的<strong>容量、温度、添加物抽象类</strong>。  </p></li><li><p><strong>具体实现化(ConcreteImplementor)角色</strong>：这个角色给出实现化角色接口的具体实现，就是上面的<strong>容量、温度、添加物实现类</strong>。</p></li></ul><blockquote><ol><li>抽象化(Abstraction)角色：Coffe抽象类-AbstractCoffe类的定义</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractCoffe</span> &#123;<br>    <span class="hljs-comment">// 重点：此处就是连接其它属性的关键，通过成员变量的方式聚合了其它属性</span><br>    ICapacity capacity;<br>    IAdditives additives;<br>    ITemperature temperature;<br><br>    <span class="hljs-comment">// 此处通过有参构造的方式接受客户端想要的咖啡属性</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AbstractCoffe</span><span class="hljs-params">(ICapacity capacity,IAdditives additives,ITemperature temperature)</span>&#123;<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>        <span class="hljs-built_in">this</span>.additives = additives;<br>        <span class="hljs-built_in">this</span>.temperature = temperature;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Order</span><span class="hljs-params">(<span class="hljs-type">int</span> count)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ol start="2"><li>修正抽象化(RefinedAbstraction)角色:口味实现类-MocaCoffe类定义</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MocaCoffe</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractCoffe</span>&#123;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">MocaCoffe</span><span class="hljs-params">(ICapacity capacity,IAdditives additives,ITemperature temperature)</span>&#123;<br>        <span class="hljs-built_in">super</span>(capacity, additives, temperature);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Order</span><span class="hljs-params">(<span class="hljs-type">int</span> count)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;开始制作摩卡咖啡：&quot;</span>);<br>        capacity.SetCupCapacity();<br>        additives.AddAdditives();<br>        temperature.SetTemperature();<br>        System.out.println(count+<span class="hljs-string">&quot; 杯Moca Coffe制作完成！&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//本例中就实现了一种类型，就是摩卡，还可以实现其它的口味类型，代码类似，此处就省略了。</span><br></code></pre></td></tr></table></figure><blockquote><ol start="3"><li>实现化(Implementor)角色:容量、温度、添加物抽象类-ICapacity、ITemperature、IAdditives抽象类定义</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//（1）容量抽象类ICapacity</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ICapacity</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">SetCupCapacity</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//（2）温度抽象类ITemperature</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ITemperature</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">SetTemperature</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//（3）添加物抽象类IAdditives</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IAdditives</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">AddAdditives</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ol start="4"><li>具体实现化(ConcreteImplementor)角色:容量、温度、添加物实现类-Capacity、Temperature、Additives抽象类定义</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">（1）Capacity实现类-3种</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// 大杯</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LargeCapacity</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ICapacity</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">SetCupCapacity</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;制作杯子尺寸：Large&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//中杯</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MiddleCapacity</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ICapacity</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">SetCupCapacity</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;制作杯子尺寸：Middle&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//小杯</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SmallCapacity</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ICapacity</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">SetCupCapacity</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;制作杯子尺寸：Small&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">（2）Temperature实现类-3种</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// 热饮</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HotTemperature</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ITemperature</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">SetTemperature</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;加热温度至：Hot&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 冷饮</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NormalTemperature</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ITemperature</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">SetTemperature</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;加热温度至：Normal&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 常温</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ColdTemperature</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ITemperature</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">SetTemperature</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;加热温度至：Cold&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">（3）Additives实现类-2种</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// 加奶</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MilkAdditives</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IAdditives</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">AddAdditives</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;添加 MILK 成功！&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 加糖</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SugarAdditives</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IAdditives</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">AddAdditives</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;添加 SUGAR 成功！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ol start="5"><li>客户端类定义</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 客户端传入想要的咖啡各个属性的具体对象</span><br>        <span class="hljs-type">AbstractCoffe</span> <span class="hljs-variable">mocaCoffe</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MocaCoffe</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MiddleCapacity</span>(),<span class="hljs-keyword">new</span> <span class="hljs-title class_">SugarAdditives</span>(),<span class="hljs-keyword">new</span> <span class="hljs-title class_">ColdTemperature</span>());<br>        mocaCoffe.Order(<span class="hljs-number">4</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li><p>抽象与实现分离，扩展能力强，符合开闭原则。  </p></li><li><p>实现细节对客户透明。  </p></li><li><p>减少了因为继承带来的类爆炸。</p></li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li><p>抽象难度大；  </p></li><li><p>类之间的关系变得复杂。</p></li></ul><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li><p>某个类有多个的维度的变化，如果用继承就会使项目变的臃肿，会产生许多的子类。  </p></li><li><p>抽象的部分和实现的部分都应该可以扩展。</p></li></ul><hr><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p class="note note-primary">组合模式（Composite Pattern）是一种结构型设计模式，允许你将对象组合成树形结构以表示“整体-部分”关系。组合模式使得客户端对单个对象和组合对象的使用具有一致性，从而可以将复杂的对象结构简化为一组简单的递归关系。<br/>在组合模式中，对象被组织成树形结构，其中包括复合对象（组合）和叶子对象。复合对象可以包含多个叶子对象和其他复合对象，而叶子对象不能包含任何其他对象。这些对象具有相同的接口，客户端可以通过相同的方式使用它们。</p><p>组合模式通过以下几个组件实现：</p><ol><li>抽象组件（Component）：定义了组合对象和叶子对象的公共接口。</li><li>叶子组件（Leaf Component）：表示组合中的叶子对象，不能包含任何子对象。</li><li>复合组件（Composite Component）：表示组合中的复合对象，可以包含其他叶子对象和复合对象。</li><li>客户端（Client）：使用组合对象的客户端，通过组件的公共接口与组合对象进行交互。</li></ol><p>组合模式的优点包括：</p><ol><li>简化客户端代码：客户端可以像处理单个对象一样处理组合对象，无需关心其内部结构和类型。</li><li>灵活性：可以动态地添加或删除组合对象，而无需更改现有代码。</li><li>可扩展性：可以通过添加新的叶子和复合对象扩展现有组合对象。</li><li>符合单一职责原则：组合对象只负责管理其子对象，而具体的对象操作则交由叶子对象或复合对象实现。</li></ol><p>一个简单的组合模式示例是一个文件系统，其中目录可以包含其他目录和文件。在这种情况下，文件和目录都可以看作是组合对象，它们具有相同的接口，可以相互组合。这种结构可以通过组合模式实现，并将目录和文件表示为组合对象的复合和叶子。</p><p><strong>在Java中实现的简单demo</strong></p><blockquote><p>1.定义抽象组件（Component）接口，它是组合对象和叶子对象的公共接口。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Component</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>2.定义叶子组件（Leaf Component）类，它表示组合中的叶子对象。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Leaf</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Component</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 叶子对象的具体操作</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>3.定义复合组件（Composite Component）类，它表示组合中的复合对象，可以包含其他叶子对象和复合对象。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Composite</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Component</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;Component&gt; children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 复合对象的具体操作</span><br>        <span class="hljs-keyword">for</span> (Component child : children) &#123;<br>            child.operation();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Component component)</span> &#123;<br>        children.add(component);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Component component)</span> &#123;<br>        children.remove(component);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Component <span class="hljs-title function_">getChild</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">return</span> children.get(index);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>4.定义客户端（Client）类，使用组合对象的客户端，通过组件的公共接口与组合对象进行交互。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Component</span> <span class="hljs-variable">leaf1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Leaf</span>();<br>        <span class="hljs-type">Component</span> <span class="hljs-variable">leaf2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Leaf</span>();<br><br>        <span class="hljs-type">Composite</span> <span class="hljs-variable">composite1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Composite</span>();<br>        composite1.add(leaf1);<br>        composite1.add(leaf2);<br><br>        <span class="hljs-type">Component</span> <span class="hljs-variable">leaf3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Leaf</span>();<br>        <span class="hljs-type">Component</span> <span class="hljs-variable">leaf4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Leaf</span>();<br><br>        <span class="hljs-type">Composite</span> <span class="hljs-variable">composite2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Composite</span>();<br>        composite2.add(leaf3);<br>        composite2.add(leaf4);<br>        composite2.add(composite1);<br><br>        composite2.operation();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>在这个例子中，我们创建了一个复合对象，它包含两个叶子对象和一个嵌套的复合对象。客户端代码可以像处理单个对象一样处理组合对象，而无需关心其内部结构和类型。在这个例子中，我们通过调用 <code>composite2.operation()</code> 方法，递归调用了复合对象和叶子对象的 <code>operation()</code> 方法。</p></blockquote><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol><li>当你需要表示对象的整体-部分层次结构时，可以使用组合模式。例如，文件系统中的目录和文件，GUI中的窗口和控件，组织结构图中的部门和员工等。</li><li>当你希望客户端能够统一处理复合对象和叶子对象时，可以使用组合模式。例如，你<strong>希望像处理单个对象一样处理组合对象，而无需区分它们的内部结构和类型</strong>。</li><li>当你需要以递归方式遍历复合对象中的所有元素时，可以使用组合模式。例如，你希望对文件系统中的目录和文件进行递归遍历，或对组织结构图中的部门和员工进行递归遍历。</li><li>当你需要添加或删除组合对象中的子元素时，可以使用组合模式。例如，你需要在文件系统中添加或删除目录和文件，或在组织结构图中添加或删除部门和员工。</li></ol><p>总之，组合模式适用于需要表示对象的整体-部分层次结构，并希望以统一的方式处理复合对象和叶子对象的场景。它可以使得代码更加灵活、易于扩展，并且符合面向对象设计的开闭原则。</p><hr><h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><p class="note note-primary">装饰器模式（Decorator Pattern）属于设计模式中的结构型模式，它是作为现有的类的一个包装。实现方式一般是创建一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。在想要增强某个对象的功能但是又不想改变该对象的代码时，可以引入装饰器模式。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201753494.png"></p><p>抽象组件（Component）：定义了原始对象和装饰器对象的共同接口，可以是抽象类或接口。<br>具体组件（ConcreteComponent）：实现了抽象组件接口，是需要被装饰的原始对象。<br>抽象装饰器（Decorator）：继承了抽象组件，持有一个抽象组件对象的引用，并定义了与抽象组件相同的接口。<br>具体装饰器（ConcreteDecorator）：继承了抽象装饰器，通过对抽象组件进行装饰，添加额外的功能。</p><p><strong>Component</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Coffee</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">drink</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>ConcreteComponent</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cappuccino</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Coffee</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drink</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;上一杯卡布奇诺！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Decorator</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Decorator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Coffee</span> &#123;<br>    Coffee coffee;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Decorator</span><span class="hljs-params">(Coffee coffee)</span> &#123;<br>        <span class="hljs-built_in">this</span>.coffee = coffee;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drink</span><span class="hljs-params">()</span> &#123;<br>        coffee.drink();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>ConcreteDecorator</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteDecorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Decorator</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcreteDecorator</span><span class="hljs-params">(Coffee coffee)</span> &#123;<br>        <span class="hljs-built_in">super</span>(coffee);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drink</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;上一杯加糖后的卡布奇诺！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">//原对象</span><br>    <span class="hljs-type">Coffee</span> <span class="hljs-variable">cappuccino</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cappuccino</span>();<br>    cappuccino.drink();<br>    <span class="hljs-comment">//装饰对象</span><br>    <span class="hljs-type">Coffee</span> <span class="hljs-variable">decorator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteDecorator</span>(cappuccino);<br>    decorator.drink();<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><p class="note note-primary">为子系统的接口提供一组统一的入口。外观模式定义了一个高层接口，这个接口使得子系统的更加容易使用。</p><p>在外观模式中，一个子系统的外部与其内部通信通过一个统一的外观类进行，外观类将客户类与子系统的内部复杂性分隔，使得客户类只需要与外观角色打交道，而不需要与子系统内部的很多其他对象交互。</p><p>外观模式是<strong>迪米特法则</strong>的一种具体实现，通过引入一个外观角色降低原有系统的复杂度，同时降低客户类与子系统的耦合度。</p><blockquote><p><strong>迪米特法则：</strong> 每一个软件单元对其他单元都只有最少的信息，而且局限于那些与本单元密切相关的软件单元。迪米特法则要求一个软件实体应该尽可能少地与其他实体发生相互作用。</p></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402202050224.png"></p><p>一个典型的用户与一个系统（汽车）中的多个子系统（动力系统，离合器，变速器，油门）进行交互的情形，用户需要和所有的子系统交互，才能完成自己想要实现的功能，这其实是极不合理的，也极容易出错。</p><p>首先来看看各个子系统的定义，包括：动力系统、离合器、加速器、变速器四个子系统。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 动力系统</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PowerSystem</span> &#123;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 汽车发动</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startUp</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;汽车发动。。。。&quot;</span>);<br>&#125;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 汽车熄火</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">closeDown</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;汽车熄火。。。。&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 离合器</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClutchSystem</span> &#123;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 踩下离合</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">press</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;踩下离合。。。。&quot;</span>);<br>&#125;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 松开离合</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">release</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;松开离合。。。。&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 变速器</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TransmissionSystem</span> &#123;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 挂挡操作</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> gear 所挂档位</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shift</span><span class="hljs-params">(<span class="hljs-type">int</span> gear)</span> &#123;<br><span class="hljs-keyword">switch</span> (gear) &#123;<br><span class="hljs-keyword">case</span> -<span class="hljs-number">1</span>:<br>System.out.println(<span class="hljs-string">&quot;挂倒档。。。。&quot;</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>System.out.println(<span class="hljs-string">&quot;挂空档。。。。&quot;</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>System.out.println(<span class="hljs-string">&quot;挂一档。。。。&quot;</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>System.out.println(<span class="hljs-string">&quot;挂二档。。。。&quot;</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>System.out.println(<span class="hljs-string">&quot;挂三档。。。。&quot;</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>System.out.println(<span class="hljs-string">&quot;挂四档。。。。&quot;</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>System.out.println(<span class="hljs-string">&quot;挂五档。。。。&quot;</span>);<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 加速器，即油门</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AcceleratorSystem</span> &#123;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 踩下油门</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">press</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;踩下油门。。。。&quot;</span>);<br>&#125;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 松开油门</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">release</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;松开油门。。。。&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来该看看外观的定义了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 外观类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Facade</span> &#123;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 示意方法，停车起步</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parkingStart</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">// 创建需要转调的子系统对象实例</span><br><span class="hljs-type">ClutchSystem</span> <span class="hljs-variable">clutchSystem</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClutchSystem</span>();<br><span class="hljs-type">TransmissionSystem</span> <span class="hljs-variable">transmissionSystem</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransmissionSystem</span>();<br><span class="hljs-type">AcceleratorSystem</span> <span class="hljs-variable">acceleratorSystem</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AcceleratorSystem</span>();<br><span class="hljs-comment">// 转调子系统的功能</span><br>clutchSystem.press();<br>transmissionSystem.shift(<span class="hljs-number">1</span>);<br>clutchSystem.release();<br>acceleratorSystem.press();<br>System.out.println(<span class="hljs-string">&quot;汽车开始动了。。。。&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建一个客户端类测试一下，示例代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br> <br><span class="hljs-type">PowerSystem</span> <span class="hljs-variable">powerSystem</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PowerSystem</span>();<br><span class="hljs-comment">// 发动汽车</span><br><span class="hljs-comment">// 此处作为示意，用户可以跳过外观，直接与子系统进行交互</span><br>powerSystem.startUp();<br><span class="hljs-comment">// 创建外观实例</span><br><span class="hljs-type">Facade</span> <span class="hljs-variable">facade</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Facade</span>();<br><span class="hljs-comment">// 停车起步</span><br>facade.parkingStart();<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">并未把“发动汽车”这个步骤一并加入的Facade对象中，主要是为了作一个示意：根据实际需要，用户是可以越过Facade层，直接与子系统进行交互的。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">汽车发动。。。。<br>踩下离合。。。。<br>挂一档。。。。<br>松开离合。。。。<br>踩下油门。。。。<br>汽车开始动了。。。。<br></code></pre></td></tr></table></figure><h3 id="抽象外观类"><a href="#抽象外观类" class="headerlink" title="抽象外观类"></a>抽象外观类</h3><p class="note note-primary">在上述外观模式中，如果需要增加或删除与外观类交互的子系统类，必须修改原有代码，**违背开闭原则**，因此可以通过引入**抽象外观类**对系统进行改进。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402202056641.png"></p><p>引入抽象外观类之后，客户端可以针对抽象层编程，对于新的业务需求，不需要修改原有的外观类，直接增加一个新的具体外观类即可，符合开闭原则。</p><hr><h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p class="note note-primary">享元模式（Flyweight Pattern）是一种结构型设计模式，它旨在通过共享对象来最大限度地减少内存使用和提高性能。</p>>享元模式的核心思想是将对象的状态（内部数据）分为内部状态（Intrinsic State）和外部状态（Extrinsic State）。内部状态是对象可以共享的状态，它独立于对象的场景，可以被多个对象共享。外部状态是对象特定于场景的状态，它不可共享，每个对象需要自己管理。>>享元模式的关键是引入一个享元工厂（Flyweight Factory），它负责创建和管理享元对象。当客户端需要对象时，它首先向享元工厂请求对象。如果对象已存在，享元工厂直接返回现有对象；如果对象不存在，享元工厂创建一个新的对象，并在需要时进行共享。<p>以下是享元模式的组成部分：</p><ol><li>享元接口（Flyweight）：定义共享对象的接口，包括操作共享状态的方法。</li><li>具体享元（Concrete Flyweight）：实现享元接口，并存储内部状态。</li><li>享元工厂（Flyweight Factory）：负责创建和管理享元对象，确保对象的共享和复用。</li></ol><p>下面是一个简单的 Java 代码示例，演示了如何使用享元模式来共享数字对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-comment">// Flyweight 接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Number</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">printNumber</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">// ConcreteFlyweight 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteNumber</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Number</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> value;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcreteNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-built_in">this</span>.value = value;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printNumber</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Printing number: &quot;</span> + value);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// FlyweightFactory 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumberFactory</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;Integer, Number&gt; numberMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Number <span class="hljs-title function_">getNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!numberMap.containsKey(value)) &#123;<br>            numberMap.put(value, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteNumber</span>(value));<br>        &#125;<br>        <span class="hljs-keyword">return</span> numberMap.get(value);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 客户端代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 获取共享的数字对象</span><br>        <span class="hljs-type">Number</span> <span class="hljs-variable">number1</span> <span class="hljs-operator">=</span> NumberFactory.getNumber(<span class="hljs-number">5</span>);<br>        <span class="hljs-type">Number</span> <span class="hljs-variable">number2</span> <span class="hljs-operator">=</span> NumberFactory.getNumber(<span class="hljs-number">10</span>);<br><br>        <span class="hljs-comment">// 输出结果</span><br>        number1.printNumber(); <span class="hljs-comment">// 输出：Printing number: 5</span><br>        number2.printNumber(); <span class="hljs-comment">// 输出：Printing number: 10</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在这个示例中，<code>NumberFactory</code> 充当享元工厂的角色，负责创建和管理数字对象。当客户端请求一个数字时，工厂首先检查对象是否已存在，如果存在则返回已有的对象，如果不存在则创建一个新的对象并添加到工厂中。这样就实现了数字对象的共享，避免了重复创建，节省了内存资源。</p><p>享元模式是一种非常有用的设计模式，可以在系统中存在大量相似对象时节省内存资源。通过共享对象的状态，可以显著减少对象的数量，提高系统的性能和效率。在实际开发中，我们可以根据具体的需求来应用享元模式，从而优化系统的设计和实现。</p><hr><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p class="note note-primary">代理模式是一种结构型设计模式，其主要目的是为其他对象提供一种代理以控制对这个对象的访问。代理对象通常充当客户端和实际对象之间的中介，它可以在访问实际对象之前或之后执行一些额外的操作，例如权限控制、延迟加载、缓存等。</p><p>代理模式包含以下关键角色：</p><ul><li><strong>Subject（抽象主题）</strong>：定义了代理对象和真实对象的公共接口，客户端通过这个接口访问真实对象和代理对象。</li><li><strong>RealSubject（真实主题）</strong>：定义了真实对象，是代理对象所代表的真实内容。</li><li><strong>Proxy（代理）</strong>：保存了一个引用，使得代理可以访问实际主题，同时提供了与主题相同的接口，客户端通过代理访问真实主题。</li></ul><p>下面是一个简单的 Java 代码示例，演示了如何使用代理模式来控制对实际对象的访问，并在访问前后执行额外的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Subject 接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Image</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">// RealSubject 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RealImage</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Image</span> &#123;<br>    <span class="hljs-keyword">private</span> String filename;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RealImage</span><span class="hljs-params">(String filename)</span> &#123;<br>        <span class="hljs-built_in">this</span>.filename = filename;<br>        loadFromDisk(filename);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Displaying &quot;</span> + filename);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadFromDisk</span><span class="hljs-params">(String filename)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Loading &quot;</span> + filename + <span class="hljs-string">&quot; from disk&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Proxy 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyImage</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Image</span> &#123;<br>    <span class="hljs-keyword">private</span> RealImage realImage;<br>    <span class="hljs-keyword">private</span> String filename;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ProxyImage</span><span class="hljs-params">(String filename)</span> &#123;<br>        <span class="hljs-built_in">this</span>.filename = filename;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//延迟加载</span><br>        <span class="hljs-keyword">if</span> (realImage == <span class="hljs-literal">null</span>) &#123;<br>            realImage = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RealImage</span>(filename);<br>        &#125;<br>        realImage.display();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 客户端代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Image</span> <span class="hljs-variable">image</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProxyImage</span>(<span class="hljs-string">&quot;test.jpg&quot;</span>);<br><br>        <span class="hljs-comment">// 图像将从磁盘加载</span><br>        image.display();<br>        System.out.println();<br><br>        <span class="hljs-comment">// 图像将不会从磁盘加载</span><br>        image.display();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在这个示例中，<code>Image</code> 接口定义了图片展示的公共方法 <code>display()</code>。<code>RealImage</code> 类表示真实的图片对象，而 <code>ProxyImage</code> 类充当了代理，负责控制对真实图片对象的访问。当客户端首次调用 <code>display()</code> 方法时，<code>ProxyImage</code> 会创建一个真实图片对象，并调用其 <code>display()</code> 方法展示图片。之后再次调用 <code>display()</code> 方法时，由于已经创建了真实图片对象，代理将直接调用真实图片对象的 <code>display()</code> 方法展示图片。</p><p>再来看一个关于缓存的示例，<strong>缓存</strong>是指将经常使用的数据存储在临时存储区域中，以加快数据访问速度。通过代理模式，我们可以在代理类中添加缓存逻辑，然后在访问真实对象之前先检查缓存是否存在。下面是一个简单的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-comment">// 接口：数据访问</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">DataAccessor</span> &#123;<br>    String <span class="hljs-title function_">getData</span><span class="hljs-params">(String key)</span>;<br>&#125;<br><br><span class="hljs-comment">// 具体实现类：真实数据访问</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RealDataAccessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DataAccessor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getData</span><span class="hljs-params">(String key)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Fetching data from database for key: &quot;</span> + key);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Data for &quot;</span> + key;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 代理类：缓存代理</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CachingProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DataAccessor</span> &#123;<br>    <span class="hljs-keyword">private</span> DataAccessor realDataAccessor;<br>    <span class="hljs-keyword">private</span> Map&lt;String, String&gt; cache;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CachingProxy</span><span class="hljs-params">()</span> &#123;<br>        realDataAccessor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RealDataAccessor</span>();<br>        cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getData</span><span class="hljs-params">(String key)</span> &#123;<br>        <span class="hljs-keyword">if</span> (cache.containsKey(key)) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Retrieving data from cache for key: &quot;</span> + key);<br>            <span class="hljs-keyword">return</span> cache.get(key);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> realDataAccessor.getData(key);<br>            cache.put(key, data);<br>            <span class="hljs-keyword">return</span> data;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 客户端代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建缓存代理</span><br>        <span class="hljs-type">DataAccessor</span> <span class="hljs-variable">dataAccessor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CachingProxy</span>();<br><br>        <span class="hljs-comment">// 第一次访问时从数据库获取数据，并缓存起来</span><br>        System.out.println(dataAccessor.getData(<span class="hljs-string">&quot;key1&quot;</span>));<br><br>        <span class="hljs-comment">// 第二次访问时直接从缓存获取数据</span><br>        System.out.println(dataAccessor.getData(<span class="hljs-string">&quot;key1&quot;</span>));<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在这个示例中，<code>CachingProxy</code> 是缓存代理类，它在访问真实对象之前先检查缓存是否存在数据。</p><p>通过代理模式，我们可以很容易地实现延迟加载、权限控制、缓存等功能，并且不需要修改原始对象的代码，从而增强了代码的可维护性和灵活性。</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>结构性模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重拾设计模式（一）</title>
    <link href="/posts/b138f59e/"/>
    <url>/posts/b138f59e/</url>
    
    <content type="html"><![CDATA[<h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><blockquote><p>请用C++、Java、C#或VB.NET任意一种面向对象语言实现一个计算器控制台程序，要求输入两个数和运算符号，得到结果。</p></blockquote><p>可以直接写，如下所示：<br><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041828241.png"></p><p>“且先不说出题人的意思，单就你现在的代码，就有很多不足的地方需要改进。”</p><ul><li>A、B、C、D命名不规范；</li><li>判断分支全用if，意味着每个条件都要判断；</li><li>除数为0会产生错误；</li><li>等等；</li></ul><p>最重要一点是，<strong>没有体现出面向对象</strong>的意思。</p><p><strong>考虑通过封装、继承、多态把程序的耦合度降低；<br>考虑用设计模式使得程序更加的灵活，容易修改，并且易于复用；</strong></p><p>试着以面向对象的形式改写例子：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402042113078.png"><br><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402042113911.png"></p><p>首先是一个运算类，它有两个Number属性，主要用于计算器的前后数，然后有一个虚方法GetResult()，用于得到结果，然后我把加减乘除都写成了运算类的子类，继承它后，重写了GetResult()方法，这样如果要修改任何一个算法，就不需要提供其他算法的代码了。但问题来了，<strong>我如何让计算器知道我是希望用哪一个算法呢</strong>？</p><p>现在的问题其实就是如何去实例化对象的问题，教你一招‘简单工厂模式’，也就是说，到底要实例化谁，将来会不会增加实例化的对象，比如增加开根运算，这是很容易变化的地方，应该考虑用一个单独的类来做这个创造实例的过程，这就是工厂，来，我们看看这个类如何写。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402042117297.png"></p><p>只需要输入特定的符号，工厂就实例化出合适的对象，通过多态，返回父类的方式实现计算器的结果：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402042118942.png"></p><p>Q：如果有一天我们需要更改加法运算，我们只需要改哪里；</p><p>A：改OperationAdd就可以了。</p><p>Q：那么我们需要增加各种复杂运算，比如平方根，立方根，自然对数，正弦余弦等，如何做？</p><p>A：只要增加相应的运算子类，并且还需要去修改运算类工厂，在switch中增加分支。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402042121776.png"></p><hr><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>再来看看工厂方法模式，与简单工厂模式还是有些差异。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402042125151.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402042126986.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402042126723.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402042126384.png"></p><p><strong>简单工厂VS工厂方法</strong></p><blockquote><p>如果我现在需要增加其他运算，比如求M数的N次方，或者求M数的N次方根，这些功能的增加，在简单工厂里，我是先去加‘求M数的N次方’功能类，然后去更改工厂方法，当中加‘Case’语句来做判断，现在用了工厂方法，加功能类没问题，再加相关的工厂类，这也没问题，但要我再去更改客户端，这不等于不但没有减化难度，反而增加了很多类和方法，把复杂性增加了吗？为什么要这样？</p></blockquote><p>这其实就是工厂方法模式和简单工厂的区别所在。<strong>简单工厂模式的最大优点在于工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，对于客户端来说，去除了与具体产品的依赖。</strong></p><p>但问题也就在这里，如你所说，如果要加一个‘求M数的N次方’的功能，我们是一定需要给运算工厂类的方法里加‘Case’的分支条件的，修改原有的类？这可不是好办法，这就等于说，我们不但对扩展开放了，对修改也开放了，<strong>违背了开闭原则</strong>。</p><p>而<strong>工厂方法模式实现时，客户端需要决定实例化哪一个工厂来实现运算类，选择判断的问题还是存在的，也就是说，工厂方法把简单工厂的内部逻辑判断移到了客户端代码来进行。你想要加功<br>能，本来是改工厂类的，而现在是修改客户端</strong>！</p><p><strong>工厂方法克服了简单工厂违背开放-封闭原则的缺点，又保持了封装对象创建过程的优点。</strong></p><hr><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><blockquote><p>通常我们可以让一个全局变量使得一个对象被访问，但它不能防止你实例化多个对象。一个最好的办法就是，让类自身负责保存它的唯一实例。这个类可以保证没有其他实例可以被创建，并且它可以提供一个访问该实例的方法。</p></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201501805.png"></p><blockquote><p>Singleton类，定义一个GetInstance操作，允许客户访问它的唯一实例。GetInstance是一个静态方法，主要负责创建自己的唯一实例。</p></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201502791.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201502277.png"></p><h4 id="多线程时的单例"><a href="#多线程时的单例" class="headerlink" title="多线程时的单例"></a>多线程时的单例</h4><p class="note note-warning">多线程的程序中，多个线程同时，注意是同时访问Singleton类，调用GetInstance()方法，会有可能造成创建多个实例的。</p><blockquote><p>可以给进程一把锁来处理。这里需要解释一下lock语句的涵义，lock是确保当一个线程位于代码的临界区时，另一个线程不进入临界区。如果其他线程试图进入锁定的代码，则它将一直等待（即被阻止），直到该对象被释放。</p></blockquote><blockquote><p>线程安全的单例实现方式有很多，这里记录四种常见的。</p></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201511950.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201511780.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201515253.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201512884.png"></p><h4 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h4><blockquote><p>虽然静态内部类方式实现单例模式通常被认为是线程安全的，但是有一种情况可能会导致它不安全，即在反序列化时。</p><p>在 Java 中，如果一个类可序列化（即实现了 <code>Serializable</code> 接口），那么它的实例可以被序列化为字节流，并在需要时反序列化成对象。但是，在反序列化过程中，会通过调用类的无参构造函数来创建对象，而不会调用类的任何其他构造函数。这就意味着，如果我们不小心让一个静态内部类单例模式的外部类可序列化，然后尝试对其进行反序列化，就会产生一个新的实例。</p><p>以静态内部类方式举例，要解决这个问题，可以通过增加一个特殊的方法 <code>readResolve()</code> 来解决。<code>readResolve()</code> 方法会在反序列化后调用，它允许我们返回原始的单例实例，而不是新创建的实例。</p></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201518754.png"></p><hr><h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><blockquote><p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示的意图时，我们需要应用于一个设计模式，‘建造者（Builder）模式’，又叫生成器模式。主要解决在软件系统中，有时候面临着”一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。</p></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201520989.png"></p><blockquote><p>比如创建一个手机，需要cpu，主板、内存、屏幕等，通过一个代码示例可以很清晰的得知建造者模式的用途：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.pattern.builder3;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Phone</span> &#123;<br>    <span class="hljs-keyword">private</span> String cpu;<br>    <span class="hljs-keyword">private</span> String screen;<br>    <span class="hljs-keyword">private</span> String memory;<br>    <span class="hljs-keyword">private</span> String mainboard;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Phone&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;cpu=&#x27;&quot;</span> + cpu + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, screen=&#x27;&quot;</span> + screen + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, memory=&#x27;&quot;</span> + memory + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, mainboard=&#x27;&quot;</span> + mainboard + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//私有构造</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Phone</span><span class="hljs-params">(Builder builder)</span> &#123;<br>        <span class="hljs-built_in">this</span>.cpu = builder.cpu;<br>        <span class="hljs-built_in">this</span>.screen = builder.screen;<br>        <span class="hljs-built_in">this</span>.memory = builder.memory;<br>        <span class="hljs-built_in">this</span>.mainboard = builder.mainboard;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Builder</span> &#123;<br>        <span class="hljs-keyword">private</span> String cpu;<br>        <span class="hljs-keyword">private</span> String screen;<br>        <span class="hljs-keyword">private</span> String memory;<br>        <span class="hljs-keyword">private</span> String mainboard;<br><br>        <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">cpu</span><span class="hljs-params">(String cpu)</span> &#123;<br>            <span class="hljs-built_in">this</span>.cpu = cpu;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">screen</span><span class="hljs-params">(String screen)</span> &#123;<br>            <span class="hljs-built_in">this</span>.screen = screen;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">memory</span><span class="hljs-params">(String memory)</span> &#123;<br>            <span class="hljs-built_in">this</span>.memory = memory;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">mainboard</span><span class="hljs-params">(String mainboard)</span> &#123;<br>            <span class="hljs-built_in">this</span>.mainboard = mainboard;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> Phone <span class="hljs-title function_">build</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone</span>(<span class="hljs-built_in">this</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.pattern.builder3;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Phone</span> <span class="hljs-variable">phone</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone</span>.Builder()<br>                .cpu(<span class="hljs-string">&quot;intel&quot;</span>)<br>                .mainboard(<span class="hljs-string">&quot;华硕&quot;</span>)<br>                .memory(<span class="hljs-string">&quot;金士顿&quot;</span>)<br>                .screen(<span class="hljs-string">&quot;三星&quot;</span>).build();<br>        System.out.println(phone);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><blockquote><p>用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型对象相同的新对象<br>1.如果你需要复制一些对象， 同时又希望代码独立于这些对象所属的具体类， 可以使用原型模式。<br>2.如果子类的区别仅在于其对象的初始化方式， 那么你可以使用该模式来减少子类的数量。 别人创建这些子类的目的可能是为了创建特定类型的对象。<br>3.Spring中原型bean的创建，就是原型模式的应用</p></blockquote><blockquote><p>原型模式的克隆分为浅克隆和深克隆。<br>浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原  有属性所指向的对象的内存地址。<br>深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。</p></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201536440.png"></p><h4 id="古老方法"><a href="#古老方法" class="headerlink" title="古老方法"></a>古老方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 羊 实体类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sheep</span> &#123;<br> <br>    <span class="hljs-comment">// 名称</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-comment">// 产地</span><br>    <span class="hljs-keyword">public</span> SheepAddress sheepAddress;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Sheep</span><span class="hljs-params">()</span>&#123;&#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Sheep</span><span class="hljs-params">(String name, SheepAddress sheepAddress)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.sheepAddress = sheepAddress;<br>    &#125;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Sheep&#123;name=&#x27;&quot;</span> + name + <span class="hljs-string">&quot;, sheepAddress=&quot;</span> + sheepAddress +<span class="hljs-string">&quot;&#125;&quot;</span>;<br>    &#125;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Objects.hash(name, sheepAddress);<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> SheepAddress <span class="hljs-title function_">getSheepAddress</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sheepAddress;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSheepAddress</span><span class="hljs-params">(SheepAddress sheepAddress)</span> &#123;<br>        <span class="hljs-built_in">this</span>.sheepAddress = sheepAddress;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 羊产地</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SheepAddress</span> &#123;<br> <br>    <span class="hljs-comment">//省</span><br>    <span class="hljs-keyword">private</span> String province;<br>    <span class="hljs-comment">//市</span><br>    <span class="hljs-keyword">private</span> String city;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SheepAddress</span><span class="hljs-params">()</span>&#123;&#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SheepAddress</span><span class="hljs-params">(String province, String city)</span> &#123;<br>        <span class="hljs-built_in">this</span>.province = province;<br>        <span class="hljs-built_in">this</span>.city = city;<br>    &#125;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;SheepAddress&#123;province=&quot;</span> + province + <span class="hljs-string">&quot;, city=&#x27;&quot;</span> + city + <span class="hljs-string">&quot;&#125;&quot;</span>;<br>    &#125;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Objects.hash(province, city);<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getProvince</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> province;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setProvince</span><span class="hljs-params">(String province)</span> &#123;<br>        <span class="hljs-built_in">this</span>.province = province;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getCity</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> city;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCity</span><span class="hljs-params">(String city)</span> &#123;<br>        <span class="hljs-built_in">this</span>.city = city;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProtTest</span> &#123;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Sheep</span> <span class="hljs-variable">sheep</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sheep</span>(<span class="hljs-string">&quot;多莉&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">SheepAddress</span>(<span class="hljs-string">&quot;内蒙古&quot;</span>, <span class="hljs-string">&quot;呼和浩特市&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;sheep对象的hashcode:&quot;</span> + sheep.hashCode() + <span class="hljs-string">&quot; sheepAddress对象的hashcode:&quot;</span> + sheep.sheepAddress.hashCode() + <span class="hljs-string">&quot; 属性值：&quot;</span> + sheep);<br> <br>        <span class="hljs-type">Sheep</span> <span class="hljs-variable">sheep1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sheep</span>(<span class="hljs-string">&quot;多莉1&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">SheepAddress</span>(<span class="hljs-string">&quot;内蒙古1&quot;</span>, <span class="hljs-string">&quot;呼和浩特市1&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;sheep对象的hashcode:&quot;</span> + sheep1.hashCode() + <span class="hljs-string">&quot; sheepAddress对象的hashcode:&quot;</span> + sheep1.sheepAddress.hashCode() + <span class="hljs-string">&quot; 属性值：&quot;</span> + sheep1);<br> <br>        <span class="hljs-type">Sheep</span> <span class="hljs-variable">sheep2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sheep</span>(<span class="hljs-string">&quot;多莉2&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">SheepAddress</span>(<span class="hljs-string">&quot;内蒙古2&quot;</span>, <span class="hljs-string">&quot;呼和浩特市2&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;sheep对象的hashcode:&quot;</span> + sheep2.hashCode() + <span class="hljs-string">&quot; sheepAddress对象的hashcode:&quot;</span> + sheep2.sheepAddress.hashCode() + <span class="hljs-string">&quot; 属性值：&quot;</span> + sheep2);<br> <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs log">sheep对象的hashcode:-150317243 sheepAddress对象的hashcode:-173282477 属性值：Sheep&#123;name=&#x27;多莉, sheepAddress=SheepAddress&#123;province=内蒙古, city=&#x27;呼和浩特市&#125;&#125;<br>sheep对象的hashcode:-364921810 sheepAddress对象的hashcode:-1076816753 属性值：Sheep&#123;name=&#x27;多莉1, sheepAddress=SheepAddress&#123;province=内蒙古1, city=&#x27;呼和浩特市1&#125;&#125;<br>sheep对象的hashcode:-364921747 sheepAddress对象的hashcode:-1076816721 属性值：Sheep&#123;name=&#x27;多莉2, sheepAddress=SheepAddress&#123;province=内蒙古2, city=&#x27;呼和浩特市2&#125;&#125;<br></code></pre></td></tr></table></figure><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 原型设计模式：浅拷贝，创建一只多莉羊并实现其Cloneable接口</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SheepClone06</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span>&#123;<br> <br>    <span class="hljs-comment">// 名称</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-comment">// 产地</span><br>    <span class="hljs-keyword">public</span> SheepAddress06 sheepAddress;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SheepClone06</span><span class="hljs-params">()</span>&#123;&#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SheepClone06</span><span class="hljs-params">(String name, SheepAddress06 sheepAddress)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.sheepAddress = sheepAddress;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printSheep</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(name + <span class="hljs-string">&quot;:&quot;</span> + <span class="hljs-string">&quot;是一只克隆羊！&quot;</span>);<br>    &#125;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Objects.hash(name, sheepAddress);<br>    &#125;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;SheepClone06&#123;name=&#x27;&quot;</span> + name + <span class="hljs-string">&quot;, sheepAddress=&quot;</span> + sheepAddress + <span class="hljs-string">&quot;&#125;&quot;</span>;<br>    &#125;<br> <br>    <span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.clone();<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> SheepAddress06 <span class="hljs-title function_">getSheepAddress</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sheepAddress;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSheepAddress</span><span class="hljs-params">(SheepAddress06 sheepAddress)</span> &#123;<br>        <span class="hljs-built_in">this</span>.sheepAddress = sheepAddress;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 羊的产区</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SheepAddress06</span> &#123;<br> <br>    <span class="hljs-comment">//省</span><br>    <span class="hljs-keyword">private</span> String province;<br>    <span class="hljs-comment">//市</span><br>    <span class="hljs-keyword">private</span> String city;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SheepAddress06</span><span class="hljs-params">()</span>&#123;&#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SheepAddress06</span><span class="hljs-params">(String province, String city)</span> &#123;<br>        <span class="hljs-built_in">this</span>.province = province;<br>        <span class="hljs-built_in">this</span>.city = city;<br>    &#125;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;SheepAddress06&#123;province=&#x27;&quot;</span> + province + <span class="hljs-string">&quot;&#x27;, city=&#x27;&quot;</span> + city + <span class="hljs-string">&quot;&#125;&quot;</span>;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getProvince</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> province;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setProvince</span><span class="hljs-params">(String province)</span> &#123;<br>        <span class="hljs-built_in">this</span>.province = province;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getCity</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> city;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCity</span><span class="hljs-params">(String city)</span> &#123;<br>        <span class="hljs-built_in">this</span>.city = city;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 原型设计模式是一种创建型设计模式，允许一个对象再创建另一个可定制的对象，无需知道如何创建对象的细节，</span><br><span class="hljs-comment"> * springmvc框架中的单例（singleton）与多例（prototype）正是基于该设计模式而设计的。</span><br><span class="hljs-comment"> * 原型设计模式分为俩种，一种是浅拷贝，另一种是深拷贝。浅拷贝指的是对于基本数据类型和引用类型的变量通过值传递和引用传递，</span><br><span class="hljs-comment"> * 通俗易懂的说法就是，原对象的任何更改都会影响到克隆对象。而深拷贝是通过完整的克隆，重新创建一个新的对象，</span><br><span class="hljs-comment"> * 原对象的更改不会影响到克隆对象。浅拷贝通过实现Cloneable接口，重写clone方法实现。</span><br><span class="hljs-comment"> * 深拷贝可以通过重写clone方法或者实现Serializable序列化接口，通过序列化实现对象深拷贝。</span><br><span class="hljs-comment"> * 多用于复杂对象的创建，简化对象创建过程。本节我们以克隆多莉羊为例，实现原型模式的一个案例。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 原型设计模式：浅拷贝，创建一只多莉羊并实现其Cloneable接口</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProtTest06</span> &#123;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>        <span class="hljs-type">SheepClone06</span> <span class="hljs-variable">sheep</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SheepClone06</span>(<span class="hljs-string">&quot;多莉&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">SheepAddress06</span>(<span class="hljs-string">&quot;内蒙古&quot;</span>, <span class="hljs-string">&quot;呼和浩特市&quot;</span>));<br>        sheep.printSheep();<br>        System.out.println(<span class="hljs-string">&quot;sheep对象--&gt;hashcode值:&quot;</span> + sheep.hashCode() + <span class="hljs-string">&quot; sheepAddress对象的hashcode值:&quot;</span> + sheep.sheepAddress.hashCode() + <span class="hljs-string">&quot; 属性值：&quot;</span> + sheep);<br>        <span class="hljs-comment">//调用克隆方法克隆一只多莉羊</span><br>        System.out.println();<br>        System.out.println(<span class="hljs-string">&quot;开始浅拷贝SheepClone对象...&quot;</span>);<br>        <span class="hljs-type">SheepClone06</span> <span class="hljs-variable">cloneSheep</span> <span class="hljs-operator">=</span> (SheepClone06) sheep.clone();<br>        cloneSheep.printSheep();<br>        <span class="hljs-comment">//更改多莉羊的产地</span><br>        sheep.getSheepAddress().setProvince(<span class="hljs-string">&quot;新疆&quot;</span>);<br>        sheep.getSheepAddress().setCity(<span class="hljs-string">&quot;乌鲁木齐&quot;</span>);<br>        <span class="hljs-comment">//克隆的多莉羊属性</span><br>        System.out.println(<span class="hljs-string">&quot;克隆sheep对象--&gt;hashcode值:&quot;</span> + cloneSheep.hashCode() + <span class="hljs-string">&quot; sheepAddress对象的hashcode值:&quot;</span> + cloneSheep.sheepAddress.hashCode() + <span class="hljs-string">&quot; 属性值: &quot;</span> + cloneSheep);<br> <br>        System.out.println();<br>        System.out.println(<span class="hljs-string">&quot;两个对象值分别为 sheep=&quot;</span> + sheep +<span class="hljs-string">&quot; cloneSheep=&quot;</span>+cloneSheep);<br>    &#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：<br><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201540459.png"></p><blockquote><p> 从上面的案例可以看出，修改复制的新对象属性内容，会影响之前的对象属性值。<br> 1) 对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将 该属性值复制一份给新的对象。<br> 2) 对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数组、某个类 的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用值（内存地址）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成 员变量值<br> 3) 前面我们克隆羊就是浅拷贝<br> 4) 浅拷贝是使用默认的 clone()方法来实现 sheep &#x3D; (Sheep) super.clone(); </p></blockquote><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs java"> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SheepClone07</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span>, Serializable &#123;<br> <br>    <span class="hljs-comment">// 名称</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-comment">// 产地</span><br>    <span class="hljs-keyword">public</span> SheepAddress07 sheepAddress;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SheepClone07</span><span class="hljs-params">()</span>&#123;&#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SheepClone07</span><span class="hljs-params">(String name, SheepAddress07 sheepAddress)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.sheepAddress = sheepAddress;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printSheep</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(name + <span class="hljs-string">&quot;:&quot;</span> + <span class="hljs-string">&quot;是一只克隆羊！&quot;</span>);<br>    &#125;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Objects.hash(name, sheepAddress);<br>    &#125;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;SheepClone07&#123;name=&#x27;&quot;</span> + name + <span class="hljs-string">&quot;, sheepAddress=&quot;</span> + sheepAddress + <span class="hljs-string">&quot;&#125;&quot;</span>;<br>    &#125;<br> <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 方式一： 通过重写clone方法实现深拷贝</span><br><span class="hljs-comment">     **/</span><br>    <span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>        <span class="hljs-comment">//完成对属性为基本数据类型和String的克隆</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">deep</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">super</span>.clone();<br>        <span class="hljs-type">SheepClone07</span> <span class="hljs-variable">sheepClone</span> <span class="hljs-operator">=</span> (SheepClone07) deep;<br>        sheepClone.sheepAddress = (SheepAddress07) sheepAddress.clone();<br>        <span class="hljs-keyword">return</span> sheepClone;<br>    &#125;<br> <br> <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 方式二： 通过序列化反序列化实现深拷贝(推荐使用)</span><br><span class="hljs-comment">     **/</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">deepClone</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//创建流对象</span><br>        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ByteArrayInputStream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//序列化</span><br>            bos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>            oos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(bos);<br>            oos.writeObject(<span class="hljs-built_in">this</span>);<br>            <span class="hljs-comment">//反序列化</span><br>            bis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(bos.toByteArray());<br>            ois = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(bis);<br>            <span class="hljs-type">SheepClone07</span> <span class="hljs-variable">sheepClone</span> <span class="hljs-operator">=</span> (SheepClone07) ois.readObject();<br>            <span class="hljs-keyword">return</span> sheepClone;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">//关闭流</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                bos.close();<br>                oos.close();<br>                bis.close();<br>                ois.close();<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>                System.out.println(e2.getMessage());<br>            &#125;<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> SheepAddress07 <span class="hljs-title function_">getSheepAddress</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sheepAddress;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSheepAddress</span><span class="hljs-params">(SheepAddress07 sheepAddress)</span> &#123;<br>        <span class="hljs-built_in">this</span>.sheepAddress = sheepAddress;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SheepAddress07</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span>, Serializable &#123;<br> <br>    <span class="hljs-comment">//省</span><br>    <span class="hljs-keyword">private</span> String province;<br>    <span class="hljs-comment">//市</span><br>    <span class="hljs-keyword">private</span> String city;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SheepAddress07</span><span class="hljs-params">()</span>&#123;&#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SheepAddress07</span><span class="hljs-params">(String province, String city)</span> &#123;<br>        <span class="hljs-built_in">this</span>.province = province;<br>        <span class="hljs-built_in">this</span>.city = city;<br>    &#125;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.clone();<br>    &#125;<br> <br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;SheepAddress07&#123;province=&#x27;&quot;</span> + province + <span class="hljs-string">&quot;&#x27;, city=&#x27;&quot;</span> + city + <span class="hljs-string">&quot;&#125;&quot;</span>;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getProvince</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> province;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setProvince</span><span class="hljs-params">(String province)</span> &#123;<br>        <span class="hljs-built_in">this</span>.province = province;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getCity</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> city;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCity</span><span class="hljs-params">(String city)</span> &#123;<br>        <span class="hljs-built_in">this</span>.city = city;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProtTest07</span> &#123;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>        <span class="hljs-type">SheepClone07</span> <span class="hljs-variable">sheep</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SheepClone07</span>(<span class="hljs-string">&quot;多莉&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">SheepAddress07</span>(<span class="hljs-string">&quot;内蒙古&quot;</span>, <span class="hljs-string">&quot;呼和浩特市&quot;</span>));<br>        sheep.printSheep();<br>        System.out.println(<span class="hljs-string">&quot;sheep对象--&gt;hashcode值:&quot;</span> + sheep.hashCode() + <span class="hljs-string">&quot; sheepAddress对象的hashcode值:&quot;</span> + sheep.sheepAddress.hashCode() + <span class="hljs-string">&quot; 属性值：&quot;</span> + sheep);<br> <br>        System.out.println();<br>        System.out.println(<span class="hljs-string">&quot;开始深拷贝方式一SheepClone对象(通过重写clone方法实现深拷贝)...&quot;</span>);<br>        <span class="hljs-type">SheepClone07</span> <span class="hljs-variable">cloneSheepOne</span> <span class="hljs-operator">=</span> (SheepClone07) sheep.clone();<br>        cloneSheepOne.setName(<span class="hljs-string">&quot;绵羊&quot;</span>);<br>        cloneSheepOne.printSheep();<br>        System.out.println(<span class="hljs-string">&quot;克隆sheep对象--&gt;hashcode值:&quot;</span> + cloneSheepOne.hashCode() + <span class="hljs-string">&quot; sheepAddress对象的hashcode值:&quot;</span> + cloneSheepOne.sheepAddress.hashCode() + <span class="hljs-string">&quot; 属性值: &quot;</span> + cloneSheepOne);<br> <br>        System.out.println();<br>        System.out.println(<span class="hljs-string">&quot;开始深拷贝方式二序列化SheepClone对象(通过序列化反序列化实现深拷贝)...&quot;</span>);<br>        <span class="hljs-type">SheepClone07</span> <span class="hljs-variable">cloneSheepTwo</span> <span class="hljs-operator">=</span> (SheepClone07) sheep.deepClone();<br>        cloneSheepTwo.printSheep();<br>        System.out.println(<span class="hljs-string">&quot;克隆sheep对象--&gt;hashcode值:&quot;</span> + cloneSheepTwo.hashCode() + <span class="hljs-string">&quot; sheepAddress对象的hashcode值:&quot;</span> + cloneSheepTwo.sheepAddress.hashCode() + <span class="hljs-string">&quot; 属性值: &quot;</span> + cloneSheepTwo);<br> <br>        System.out.println();<br>        System.out.println(<span class="hljs-string">&quot;两个对象值分别为 sheep=&quot;</span> + sheep +<span class="hljs-string">&quot; cloneSheepOne=&quot;</span>+cloneSheepOne+<span class="hljs-string">&quot; cloneSheepTwo=&quot;</span>+cloneSheepTwo);<br> <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：<br><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201543458.png"></p><blockquote><p>深拷贝基本介绍</p><ol><li>复制对象的所有基本数据类型的成员变量值</li><li>为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变 量所引用的对象，直到该对象可达的所有对象。也就是说，对象进行深拷贝要对 整个对象进行拷贝</li><li>深拷贝实现方式</li></ol><ul><li>重写clone方法来实现深拷贝</li><li>通过对象序列化实现深拷贝(推荐)</li></ul><p>原型模式的注意事项和细节</p><ol><li>创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提高效率。</li><li>不用重新初始化对象，而是动态地获得对象运行时的状态。</li><li>如果原始对象发生变化(增加或者减少属性)，其它克隆对象的也会发生相应的变化，无需修改代码。</li><li>在实现深克隆的时候可能需要比较复杂的代码。</li><li>缺点：需要为每一个类配备一个克隆方法，这对全新的类来说不是很难，但对已有 的类进行改造时，需要修改其源代码，违背了ocp原则。</li></ol></blockquote><hr><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>抽象工厂模式为一个产品家族提供了统一的创建接口。当需要这个产品家族的某一系列的时候，可以从抽象工厂中选出相对应的系列来创建一个具体的工厂类别。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。</p><p><strong>相关术语：</strong></p><ul><li><p><strong>产品等级结构：</strong>产品的继承结构，与类的继承相似。例如笔记本是一个抽象的类，那么华为笔记本、苹果和联想笔记本就是其子类。</p></li><li><p><strong>产品族：</strong>指同一个工厂生产的，位于不同的产品等级结构的一组产品。例如华为笔记本、手机、路由器等都产自华为，笔记本的等级结构不同，构成一个产品族。</p></li><li><p><strong>抽象工厂：</strong>是一个接口，抽象工厂模式的核心，包含对多个产品等级结构的声明，任何工厂类都必须实现这个接口。</p></li><li><p><strong>具体工厂：</strong>是抽象工厂的实现，负责实例化某个产品族中的产品对象。例如华为工厂生产华为笔记本、手机、路由器等。</p></li></ul><h3 id="产品族和产品等级结构图"><a href="#产品族和产品等级结构图" class="headerlink" title="产品族和产品等级结构图"></a>产品族和产品等级结构图</h3><p>我们以一个品牌为一个产品族，电脑、手机、路由器为产品等级，每一个品牌都有自己的产品族，这就构成一个完整产品群；</p><p>横向代表一族，纵向代表一个等级，横纵交集代表某一个品牌的某一个产品（比如下图中交集的点为电脑），请看下图；</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201602502.png"></p><h3 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h3><p>这个类图其实比较简单，简单说明下：</p><p><strong>产品顶级接口</strong>：主要被产品抽象类实现；</p><p><strong>产品抽象类</strong>：某个具体产品要实现的类；</p><p><strong>具体实现类</strong>：具体产品实现，比如华为路由器实现自抽象类AbstractRouter；</p><p><strong>工厂接口</strong>：工厂接口中定义创建每个产品方法；</p><p><strong>具体华为工厂</strong>：实现工厂接口，创建华为一族产品（路由器、手机、电脑）；</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201604768.png"></p><h3 id="具体代码实现"><a href="#具体代码实现" class="headerlink" title="具体代码实现"></a>具体代码实现</h3><blockquote><p>代码中我们以华为产品为例，分别定义华为电脑、手机、路由器产品，从UML类图中可以看出我们的产品结构层级比较清晰，现在我们先设计我们产品。</p></blockquote><p><strong>产品顶级接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> pattern.abstractfactory.product;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 定义产品接口</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">InterfaceProduct</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>定义计算机抽象类并实现产品InterfaceProduct 接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> pattern.abstractfactory.product;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 定义计算机产品抽象类，并实现产品接口InterfaceProduct</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractComputers</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InterfaceProduct</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>定义手机抽象类并实现产品InterfaceProduct 接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> pattern.abstractfactory.product;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 定义手机抽象类，并实现产品接口InterfaceProduct</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractPhone</span>  <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InterfaceProduct</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>定义路由器抽象类并实现产品InterfaceProduct 接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> pattern.abstractfactory.product;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 定义路由器产品抽象类，并实现InterfaceProduct接口</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractRouter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InterfaceProduct</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>定义华为电脑具体实现类，继承AbstractComputers抽象类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> pattern.abstractfactory.product;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 华为电脑实现类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HuaWeiComputer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractComputers</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;华为笔记本&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>定义华为手机具体实现类，继承AbstractPhone抽象类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> pattern.abstractfactory.product;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  *  华为手机实现类，</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HuaWeiPhone</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractPhone</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;华为手机&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>定义华为路由器具体实现类，继承AbstractRouter抽象类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> pattern.abstractfactory.product;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 华为路由器</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HuaWeiRouter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractRouter</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;华为品牌路由器&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-primary">下面开始定义工厂</p><p><strong>定义工厂接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> pattern.abstractfactory.factory;<br><span class="hljs-keyword">import</span> pattern.abstractfactory.product.InterfaceProduct;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 定义产品工厂接口,</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">InterfactFactory</span> &#123;<br>    <span class="hljs-comment">//手机产品</span><br>    InterfaceProduct <span class="hljs-title function_">createPhone</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">//电脑产品</span><br>    InterfaceProduct <span class="hljs-title function_">createComputer</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">//路由器产品</span><br>    InterfaceProduct <span class="hljs-title function_">createRouter</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>具体工厂实现类，实现 InterfactFactory  接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> pattern.abstractfactory.factory;<br><span class="hljs-keyword">import</span> pattern.abstractfactory.product.HuaWeiComputer;<br><span class="hljs-keyword">import</span> pattern.abstractfactory.product.HuaWeiPhone;<br><span class="hljs-keyword">import</span> pattern.abstractfactory.product.HuaWeiRouter;<br><span class="hljs-keyword">import</span> pattern.abstractfactory.product.InterfaceProduct;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * **华为工厂**</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HuaWeiFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InterfactFactory</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建电脑对象并返回</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> InterfaceProduct <span class="hljs-title function_">createComputer</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HuaWeiComputer</span>();<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建手机对象并返回</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> InterfaceProduct <span class="hljs-title function_">createPhone</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HuaWeiPhone</span>();<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建路由器对象并返回</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> InterfaceProduct <span class="hljs-title function_">createRouter</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HuaWeiRouter</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>客户端类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> pattern.abstractfactory;<br><span class="hljs-keyword">import</span> pattern.abstractfactory.factory.HuaWeiFactory;<br><span class="hljs-keyword">import</span> pattern.abstractfactory.factory.InterfactFactory;<br><span class="hljs-keyword">import</span> pattern.abstractfactory.product.InterfaceProduct;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 抽象工厂模式测试类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建华为品牌工厂</span><br>        <span class="hljs-type">InterfactFactory</span> <span class="hljs-variable">huawei</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HuaWeiFactory</span>();<br>        <span class="hljs-comment">//通过华为工厂获取华为电脑对象</span><br>        <span class="hljs-type">InterfaceProduct</span> <span class="hljs-variable">computer</span> <span class="hljs-operator">=</span> huawei.createComputer();<br>        computer.get();<br>        <span class="hljs-comment">//通过华为工厂获取华为手机对象</span><br>        <span class="hljs-type">InterfaceProduct</span> <span class="hljs-variable">phone</span> <span class="hljs-operator">=</span> huawei.createPhone();<br>        phone.get();<br>        <span class="hljs-comment">//通过华为工厂获取华为路由器对象</span><br>        <span class="hljs-type">InterfaceProduct</span> <span class="hljs-variable">router</span> <span class="hljs-operator">=</span> huawei.createRouter();<br>        router.get();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201611533.png"></p><h3 id="扩展展品族"><a href="#扩展展品族" class="headerlink" title="扩展展品族"></a>扩展展品族</h3><blockquote><p>抽象工厂模式<strong>对于横向扩展方便，对于纵向扩展非常困难</strong>，也就是说：假如我们要扩展一个新的品牌，比如扩展一个小米品牌，小米产品有电脑、手机、路由器，扩展新品牌就是横向扩展，非常方便，但是我们要给小米添加一个电饭煲产品却非常困难，这就是纵向扩展，所以在使用抽象工厂模式时一定要选择合适的场景，也就是在不同场景中使用最适合的模式才是设计模式的精髓。</p></blockquote><p><strong>小米电脑</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> pattern.abstractfactory.product;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 小米电脑，继承自 AbstractComputers 抽象类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MiComputer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractComputers</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;小米电脑&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>小米手机</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> pattern.abstractfactory.product;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 小米手机，继承自 AbstractPhone 抽象类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MiPhone</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractPhone</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;小米手机&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>小米路由器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> pattern.abstractfactory.product;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 小米路由器，继承自 AbstractRouter 抽象类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MiRouter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractRouter</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;小米路由器&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>添加小米具体工厂类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> pattern.abstractfactory.factory;<br><span class="hljs-keyword">import</span> pattern.abstractfactory.product.InterfaceProduct;<br><span class="hljs-keyword">import</span> pattern.abstractfactory.product.MiComputer;<br><span class="hljs-keyword">import</span> pattern.abstractfactory.product.MiPhone;<br><span class="hljs-keyword">import</span> pattern.abstractfactory.product.MiRouter;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 小米工厂，实现 InterfactFactory 接口</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MiFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InterfactFactory</span>&#123;<br>    <span class="hljs-comment">//小米手机</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> InterfaceProduct <span class="hljs-title function_">createPhone</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MiPhone</span>();<br>    &#125;<br>    <span class="hljs-comment">//小米电脑</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> InterfaceProduct <span class="hljs-title function_">createComputer</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MiComputer</span>();<br>    &#125;<br>    <span class="hljs-comment">//小米路由器</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> InterfaceProduct <span class="hljs-title function_">createRouter</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MiRouter</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后编写测试类，<strong>代码中红色字体为新扩展的品牌产品</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> pattern.abstractfactory;<br><span class="hljs-keyword">import</span> pattern.abstractfactory.factory.HuaWeiFactory;<br><span class="hljs-keyword">import</span> pattern.abstractfactory.factory.InterfactFactory;<br><span class="hljs-keyword">import</span> pattern.abstractfactory.factory.MiFactory;<br><span class="hljs-keyword">import</span> pattern.abstractfactory.product.InterfaceProduct;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 抽象工厂模式测试类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建华为品牌工厂</span><br>        <span class="hljs-type">InterfactFactory</span> <span class="hljs-variable">huawei</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HuaWeiFactory</span>();<br>        <span class="hljs-comment">// 通过华为工厂获取华为电脑对象</span><br>        <span class="hljs-type">InterfaceProduct</span> <span class="hljs-variable">computer</span> <span class="hljs-operator">=</span> huawei.createComputer();<br>        computer.get();<br>        <span class="hljs-comment">// 通过华为工厂获取华为手机对象</span><br>        <span class="hljs-type">InterfaceProduct</span> <span class="hljs-variable">phone</span> <span class="hljs-operator">=</span> huawei.createPhone();<br>        phone.get();<br>        <span class="hljs-comment">// 通过华为工厂获取华为路由器对象</span><br>        <span class="hljs-type">InterfaceProduct</span> <span class="hljs-variable">router</span> <span class="hljs-operator">=</span> huawei.createRouter();<br>        router.get();<br><br>        <span class="hljs-comment">// 创建小米品牌工厂</span><br>        <span class="hljs-type">InterfactFactory</span> <span class="hljs-variable">Mifactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MiFactory</span>();<br>        <span class="hljs-comment">// 通过小米工厂获取小米电脑对象</span><br>        <span class="hljs-type">InterfaceProduct</span> <span class="hljs-variable">micomputer</span> <span class="hljs-operator">=</span> Mifactory.createComputer();<br>        micomputer.get();<br>        <span class="hljs-comment">// 通过小米工厂获取小米手机对象</span><br>        <span class="hljs-type">InterfaceProduct</span> <span class="hljs-variable">miphone</span> <span class="hljs-operator">=</span> Mifactory.createPhone();<br>        miphone.get();<br>        <span class="hljs-comment">// 通过小米工厂获取小米路由器对象</span><br>        <span class="hljs-type">InterfaceProduct</span> <span class="hljs-variable">mirouter</span> <span class="hljs-operator">=</span> Mifactory.createRouter();<br>        mirouter.get();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201615661.png"></p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>创建者模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重拾设计模式（零）- 朝花夕拾</title>
    <link href="/posts/77e3381c/"/>
    <url>/posts/77e3381c/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>设计模式是在软件设计中经常出现的问题的通用解决方案。这些解决方案是经过反复验证和证明的，并且被广泛接受和应用于软件开发中。设计模式提供了一种可重用的思想框架，可以帮助开发人员更有效地解决常见问题，并提高代码的可维护性、可读性和可扩展性。</p><p>编程是一门技术，更加是一门艺术，不能只满足于写完代码运行结果正确就完事，时常考虑如何让代码更加简练，更加容易维护，容易扩展和复用，只有这样才可以真正得到提高。</p><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><p>设计模式的使用应该遵循一些基本的设计原则，这些原则有助于编写更清晰、灵活、可维护和可扩展的代码。以下是一些常见的设计原则：</p><ol><li><p><strong>单一职责原则（Single Responsibility Principle - SRP）：</strong> 一个类应该只有一个修改的理由。每个类都应该专注于一项任务，避免一个类担负过多的职责。</p></li><li><p><strong>开闭原则（Open-Closed Principle - OCP）：</strong> 软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。可以通过接口和抽象类实现。</p></li><li><p><strong>里氏替换原则（Liskov Substitution Principle - LSP）：</strong> 派生类应该能够替换其基类而不影响程序的正确性。即，子类应该能够替代父类并保持程序的行为一致性。</p></li><li><p><strong>依赖倒置原则（Dependency Inversion Principle - DIP）：</strong> 高层模块不应该依赖于底层模块，二者都应该依赖于抽象。抽象不应该依赖于细节，而细节应该依赖于抽象。</p></li><li><p><strong>接口隔离原则（Interface Segregation Principle - ISP）：</strong> 客户端不应该强制依赖于它们不使用的接口。一个类不应该被强制实现它用不到的接口。</p></li><li><p><strong>迪米特法则（Law of Demeter，LoD，又称最少知识原则）：</strong> 一个对象应该对其他对象有最少的了解。避免在一个类中调用过多其他类的方法，减少耦合性。</p></li><li><p><strong>合成复用原则（Composition&#x2F;Aggregation Reuse Principle - CARP）：</strong> 首选使用组合&#x2F;聚合而不是继承来实现复用。通过组合可以更灵活地实现对象间的关系。</p></li><li><p><strong>优先使用对象组合，而不是类继承（Favor Composition Over Inheritance）：</strong> 对象组合通常比类继承更加灵活，能够减少耦合性并支持代码重用。</p></li></ol><p>这些原则通常被认为是良好面向对象设计的基石，它们相互交织，协同工作，帮助设计出符合软件工程最佳实践的系统结构。在实践中，根据具体情况灵活运用这些原则，有助于构建更健壮和可维护的软件系统。</p><h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041803749.png"></p><p>UML（Unified Modeling Language）类图是一种用于描述系统中的类、对象及它们之间关系的图形化建模工具。它是一种强大的面向对象的建模语言，被广泛用于软件开发和系统设计。以下是类图的主要元素和介绍：</p><ol><li><p><strong>类（Class）：</strong> 类是对现实世界中一组相似对象的抽象，它定义了对象的属性和行为。在类图中，类通常用一个矩形框表示，矩形框分为三个部分：类名、属性（字段）和方法。</p></li><li><p><strong>关联（Association）：</strong> 关联表示类之间的关系，描述一个类的实例和另一个类的实例之间的连接。关联可以是单向的或双向的，可以具有方向性，也可以是多重性的，表示一个类中的实例与另一个类中的实例之间的关系。</p></li><li><p><strong>聚合（Aggregation）：</strong> 表示一种弱的拥有关系，整体对象可以包含部分对象，但部分对象并不是整体对象的一部分。聚合用一条带有空心菱形的直线表示。</p></li><li><p><strong>组合（Composition）：</strong> 表示一种强的拥有关系，整体对象包含部分对象，部分对象是整体对象的一部分。组合用一条带有实心菱形的直线表示。</p></li><li><p><strong>泛化（Generalization）：</strong> 表示类之间的继承关系，其中一个类是另一个类的子类。泛化用一条带有空心三角箭头的直线表示。</p></li><li><p><strong>接口（Interface）：</strong> 表示一个类或一组类的契约，它规定了这些类应该实现的一组方法。接口用带有&lt;<interface>&gt;标记的小矩形表示。</p></li><li><p><strong>依赖（Dependency）：</strong> 表示一个类使用了另一个类的服务，但是并不拥有对方的对象。依赖关系用一条带有箭头的虚线表示。</p></li><li><p><strong>多重性（Multiplicity）：</strong> 表示关联、聚合或组合关系中每个端点的实例数目。例如，1..* 表示一个或多个实例。</p></li></ol><p>UML类图是软件开发中非常有用的工具，它能够清晰地展示系统中的类、对象和它们之间的关系，帮助开发人员理解系统结构、设计和实现。通过类图，开发团队能够更好地沟通和协作，确保系统的正确性和可维护性。</p><h2 id="先说结论"><a href="#先说结论" class="headerlink" title="先说结论"></a>先说结论</h2><p><strong>创建型模式</strong></p><ol><li><p><strong>工厂方法模式（Factory Method Pattern）</strong> ：定义一个创建对象的接口，但是让子类决定实例化哪个类。工厂方法使得一个类的实例化延迟到其子类。</p></li><li><p><strong>抽象工厂模式（Abstract Factory Pattern）</strong> ：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p></li><li><p><strong>单例模式（Singleton Pattern）</strong> ：确保一个类只有一个实例，并提供一个全局访问点。</p></li><li><p><strong>建造者模式（Builder Pattern）</strong> ：将一个复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示。</p></li><li><p><strong>原型模式（Prototype Pattern）</strong> ：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p></li></ol><p><strong>结构型模式</strong></p><ol><li><p><strong>适配器模式（Adapter Pattern）</strong> ：将一个类的接口转换成客户希望的另一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的类可以一起工作。</p></li><li><p><strong>桥接模式（Bridge Pattern）</strong> ：将抽象部分与它的实现部分分离，使它们可以独立变化。</p></li><li><p><strong>组合模式（Composite Pattern）</strong> ：将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p></li><li><p><strong>装饰器模式（Decorator Pattern）</strong> ：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。</p></li><li><p><strong>外观模式（Facade Pattern）</strong> ：为子系统中的一组接口提供一个统一的接口。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p></li><li><p><strong>享元模式（Flyweight Pattern）</strong> ：运用共享技术有效地支持大量细粒度的对象。</p></li><li><p><strong>代理模式（Proxy Pattern）</strong> ：为其他对象提供一种代理以控制对这个对象的访问。</p></li></ol><p><strong>行为型模式</strong></p><ol><li><p><strong>责任链模式（Chain of Responsibility Pattern）</strong> ：为请求创建一个接收者对象的链，使得多个对象都有机会处理该请求。在请求发送者和接收者之间解耦。</p></li><li><p><strong>命令模式（Command Pattern）</strong> ：将一个请求封装成一个对象，从而使用户可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。</p></li><li><p><strong>解释器模式（Interpreter Pattern）</strong> ：给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。</p></li><li><p><strong>迭代器模式（Iterator Pattern）</strong> ：提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。</p></li><li><p><strong>中介者模式（Mediator Pattern）</strong> ：用一个中介对象封装一系列对象的交互，中介者使各对象不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p></li><li><p><strong>备忘录模式（Memento Pattern）</strong> ：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。</p></li><li><p><strong>观察者模式（Observer Pattern）</strong> ：定义对象间的一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并自动更新。</p></li><li><p><strong>状态模式（State Pattern）</strong> ：允许对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。</p></li><li><p><strong>策略模式（Strategy Pattern）</strong> ：定义一系列的算法，把它们封装起来，并且使它们可以相互替换。策略模式使得算法可以独立于使用它的客户而变化。</p></li><li><p><strong>模板方法模式（Template Method Pattern）</strong> ：定义一个操作中的算法的框架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p></li><li><p><strong>访问者模式（Visitor Pattern）</strong> ：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式相关</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构和算法之旅（十二）- 其他</title>
    <link href="/posts/98b3bf1e/"/>
    <url>/posts/98b3bf1e/</url>
    
    <content type="html"><![CDATA[<blockquote><p>最近看到一本很有趣的书，《算法图解》。对一些算法描述的非常清晰、直观、有趣。这里简单记录一些读书笔记。</p></blockquote><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>假设你的计算机存储了很多乐曲。对于每个乐队，你都记录了其作品被播放的次数。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041629883.png"></p><p>你要将这个列表按播放次数从多到少的顺序排列，从而将你喜欢的乐队排序。该如何做呢？一种办法是遍历这个列表，找出作品播放次数最多的乐队，并将该乐队添加到一个新列表中。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041630942.png"><br>继续这样做，找出播放次数第二多的乐队。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041631736.png"></p><p>继续这样做，将得到一个有序的列表。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041631559.png"></p><p>接下来，分析一下它时间复杂度。要找出播放次数最多的乐队，必须检查列表中的每个元素。正如你刚才看到的，这需要的时间为O(n)。因此对于这种时间为O(n)的操作，你需要执行n次。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041634338.png"><br>需要的总时间为O(n×n)，即O(n²)。</p><p>排序算法很有用。你现在可以对如下内容进行排序：</p><ul><li>电话薄中的人名</li><li>旅行日期</li><li>电子邮件，从新到旧</li><li>等等</li></ul><p>示例代码</p><p>将数组元素按从小到大的顺序排列。先编写一个用于找出数组中最小元素的函数。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041639433.png"></p><p>现在可以使用这个函数来编写选择排序算法了。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041640898.png"></p><p>选择排序是一种灵巧的算法，但是速度不是很快。快速排序是一种更快的排序算法，其运行时间为O(n log n)。</p><h2 id="分而治之D-amp-C"><a href="#分而治之D-amp-C" class="headerlink" title="分而治之D&amp;C"></a>分而治之D&amp;C</h2><blockquote><p>一种著名的递归式问题解决方法。</p><p>分而治之的原理：<br>1.找出简单的基线条件；<br>2.确定如何缩小问题的规模，使其符合基线条件；<br>D&amp;C并非用于解决问题的算法，而是一种解决问题的思路。</p></blockquote><p>一个简单的例子，给定一个数组，</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041646083.png"><br>需要将这些数字相加，并返回结果。使用循环很容易完成这种任务。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">defsum(arr): <br>total=<span class="hljs-number">0</span> <br>forx <span class="hljs-keyword">in</span> arr: <br>total+= x <br><span class="hljs-keyword">return</span> total <br><span class="hljs-built_in">print</span> <span class="hljs-built_in">sum</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>])<br></code></pre></td></tr></table></figure><p>但如何使用递归函数来完成这种任务呢？</p><p><strong>第一步</strong>：找出基线条件。最简单的数组什么样呢？请想想这个问题，再接着往下读。如果数组不包含任何元素或只包含一个元素，计算总和将非常容易。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041649064.png"><br>因此，这就是基线条件。</p><p><strong>第二步</strong>：每次递归调用都必须离空数组更近一步。如何缩小问题的规模呢？下面是一种办法。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041650285.png"></p><p>这两个版本的结果都为12，但在第二个版本中，给函数sum传递的数组更短。换言之，这缩小了问题的规模！</p><p>函数sum的工作原理类似于下面这样。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041651529.png"></p><p>这个函数的运行过程如下。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041651359.png"></p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><blockquote><p>快速排序是一种常用的排序算法，比选择排序快得多。例如，C语言标准库中的函数qsort实现的就是快速排序。快速排序也使用了D&amp;C。</p></blockquote><p>下面来使用快速排序对数组进行排序。对排序算法来说，最简单的数组什么样呢？还记得前一节的“提示”吗？就是根本不需要排序的数组。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041657372.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">quicksort</span>(<span class="hljs-params">array</span>): <br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(array)&lt;<span class="hljs-number">2</span>: <br><span class="hljs-keyword">return</span> array<br></code></pre></td></tr></table></figure><p>因此，基线条件为数组为空或只包含<strong>一</strong>个元素。在这种情况下，只需原样返回数组——根本就不用排序。</p><p>我们来看看更长的数组。对包含<strong>两</strong>个元素的数组进行排序也很容易。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041659123.png"><br>包含三个元素的数组呢？</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041700889.png"></p><p>别忘了，你要使用D&amp;C，因此需要将数组分解，直到满足基线条件。下面介绍<strong>快速排序的工作原理</strong>。首先，从数组中<strong>选择一个元素</strong>，这个元素被称为<strong>基准值</strong>(pivot)。稍后再介绍如何选择合适的基准值。我们暂时将数组的第一个元素用作基准值。接下来，找出比基准值小的元素以及比基准值大的元素。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041701782.png"><br><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041701748.png"></p><p>这被称为分区(partitioning)。现在你有：</p><ul><li>一个由所有小于基准值的数字组成的子数组；</li><li>基准值；</li><li>一个由所有大于基准值的数组组成的子数组。</li></ul><p>这里只是进行了分区，得到的两个子数组是无序的。但如果这两个数组是有序的，对整个数组进行排序将非常容易。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041702668.png"></p><p>如果子数组是有序的，就可以像下面这样合并得到一个有序的数组：左边的数组+基准值+右边的数组。在这里，就是[10,15]+[33]+[]，结果为有序数组[10,15,33]。</p><p>如何对子数组进行排序呢？对于包含两个元素的数组（左边的子数组）以及空数组（右边的子数组），快速排序知道如何将它们排序，因此只要对这两个子数组进行快速排序，再合并结果，就能得到一个有序数组！</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041704511.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041705539.png"></p><p>快速排序的性能高度依赖于你选择的基准值。假设你总是将第一个元素用作基准值，且要处理的数组是有序的。由于快速排序算法不检查输入数组是否有序，因此它依然尝试对其进行排序。最糟糕的情况运行时间是O(n²)。</p>]]></content>
    
    
    <categories>
      
      <category>data&amp;algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构和算法之旅（十一）- 哈希表</title>
    <link href="/posts/3cbe22a9/"/>
    <url>/posts/3cbe22a9/</url>
    
    <content type="html"><![CDATA[<blockquote><p>哈希表是一种功能强大的数据结构，其操作速度快，还能以不同的方式建立数据模型。</p><p>结合散列函数和数组来创建散列表。<br>散列表的查找、插入和删除都非常快。<br>散列表适用于模拟映射关系。<br>负载因子一旦超过0.7，就该调整散列表的长度。<br>散列表可用于缓存数据，例如Web服务器的缓存。<br>散列表非常适合用于防止重复。</p></blockquote><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><blockquote><p>几乎根本不需要自己去实现散列表，因为各种编程语言基本都会提供。不过为了为了掌握，还是敲一边加深印象把。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.datastructure;  <br>  <br><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * 哈希表  </span><br><span class="hljs-comment"> * &lt;p&gt;  </span><br><span class="hljs-comment"> * 给每份数据分配一个编号，放入数组、  </span><br><span class="hljs-comment"> * 建立编号与数组索引的关系，将来可以通过编号快速查找到数据。  </span><br><span class="hljs-comment"> * 存在问题：  </span><br><span class="hljs-comment"> * 1.理想情况下，数组容纳所有数据，但是不现实，因为数组需要连续内存存储的；  </span><br><span class="hljs-comment"> * 2.现实是不能说为了容纳所有数据造一个超大数组，编号也有可能重复的；  </span><br><span class="hljs-comment"> * 解决：  </span><br><span class="hljs-comment"> * 1.有限长度的数组，以【拉链】方式存储数据；  </span><br><span class="hljs-comment"> * 2.允许编号适当重复，通过数据自身进行区分；  </span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashTable</span> &#123;  <br>  <br>    <span class="hljs-comment">//节点类  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> &#123;  <br>        <span class="hljs-type">int</span> hash;<span class="hljs-comment">//哈希码  </span><br>        Object key;<span class="hljs-comment">//键  </span><br>        <span class="hljs-keyword">public</span> Object value;<span class="hljs-comment">//值  </span><br>        <span class="hljs-keyword">public</span> Entry next;<span class="hljs-comment">//下一个节点  </span><br>  <br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Entry</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, Object key, Object value)</span> &#123;  <br>            <span class="hljs-built_in">this</span>.hash = hash;  <br>            <span class="hljs-built_in">this</span>.key = key;  <br>            <span class="hljs-built_in">this</span>.value = value;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> Entry[] table = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[<span class="hljs-number">16</span>];<span class="hljs-comment">//哈希表，数组，每个元素是一个链表的头节点  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//元素个数  </span><br>    <span class="hljs-type">float</span> <span class="hljs-variable">loadFactor</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.75f</span>;<span class="hljs-comment">//负载因子 16*0.75=12  也叫阈值  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">threshold</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (table.length * loadFactor);<span class="hljs-comment">//阈值 用变量记录，后面可以复用  </span><br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * ！！！  </span><br><span class="hljs-comment">     * 求模运算替换为位运算  </span><br><span class="hljs-comment">     *  -前提：数组长度必须是2的n次方  </span><br><span class="hljs-comment">     *  -hash % 数组长度 等价与 hash &amp; (数组长度-1)  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-comment">/**     * 查询  </span><br><span class="hljs-comment">     * 根据hash码获取Value  </span><br><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, Object key)</span> &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> hash &amp; (table.length - <span class="hljs-number">1</span>);  <br>        <span class="hljs-keyword">if</span> (table[idx] == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>        <span class="hljs-type">Entry</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> table[idx];<span class="hljs-comment">//头节点  </span><br>        <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-keyword">if</span> (p.key == key) <span class="hljs-keyword">return</span> p.value;  <br>            p = p.next;  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 向hash表存入新key value，  </span><br><span class="hljs-comment">     * 分三种情况：  </span><br><span class="hljs-comment">     * 找到空位，直接插入  </span><br><span class="hljs-comment">     * 找链表，如果key已存在，替换value  </span><br><span class="hljs-comment">     * 找链表，如果key不存在，插入链表尾部  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, Object key, Object value)</span> &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> hash &amp; (table.length - <span class="hljs-number">1</span>);<span class="hljs-comment">//hash &amp; (数组长度-1)  </span><br>        <span class="hljs-keyword">if</span> (table[idx] == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//1.找到空位 直接插入  </span><br>            table[idx] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(hash, key, value);  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            <span class="hljs-comment">//2.无空位，找链表。如果key已存在，替换value  </span><br>            <span class="hljs-type">Entry</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> table[idx];  <br>            <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span>) &#123;  <br>                <span class="hljs-keyword">if</span> (p.key.equals(key)) &#123;  <br>                    p.value = value;<span class="hljs-comment">//更新  </span><br>                    <span class="hljs-keyword">return</span>;  <br>                &#125;  <br>                <span class="hljs-keyword">if</span> (p.next == <span class="hljs-literal">null</span>) <span class="hljs-keyword">break</span>;  <br>                p = p.next;  <br>            &#125;  <br>            <span class="hljs-comment">//3.找链表，如果key不存在，插入链表尾部  </span><br>            p.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(hash, key, value);  <br>        &#125;  <br>        size++;  <br>        <span class="hljs-keyword">if</span> (size &gt; threshold) &#123;  <br>            resize();  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 根据hash 删除，返回删除的value  </span><br><span class="hljs-comment">     */</span>    Object <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, Object key)</span> &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> hash &amp; (table.length - <span class="hljs-number">1</span>);<span class="hljs-comment">//hash &amp; (数组长度-1)  </span><br>        <span class="hljs-keyword">if</span> (table[idx] == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>        <span class="hljs-type">Entry</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> table[idx];<span class="hljs-comment">//头节点  </span><br>        <span class="hljs-type">Entry</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<span class="hljs-comment">//前一个节点  </span><br>        <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-keyword">if</span> (p.key.equals(key)) &#123;<span class="hljs-comment">//找到了 删除  </span><br>                <span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> p.value;  <br>                <span class="hljs-keyword">if</span> (prev == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//删除的是头节点  </span><br>                    table[idx] = p.next;  <br>                &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//删除的是中间节点  </span><br>                    prev.next = p.next;  <br>                &#125;  <br>                size--;  <br>                <span class="hljs-keyword">return</span> value;  <br>            &#125;  <br>            prev = p;<span class="hljs-comment">//记录前一个节点  </span><br>            p = p.next;  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 扩容  </span><br><span class="hljs-comment">     * &lt;p&gt;  </span><br><span class="hljs-comment">     * 负载因子 = size / table.length  </span><br><span class="hljs-comment">     * 不易过小也不易过大，  </span><br><span class="hljs-comment">     * 过小，浪费，空间利用率低  </span><br><span class="hljs-comment">     * 过大，快满了，效率低  </span><br><span class="hljs-comment">     * &lt;p&gt;  </span><br><span class="hljs-comment">     * 3/4 也是 0.75是经验值 比较合适  </span><br><span class="hljs-comment">     * 扩容之后，会重新计算每个元素的位置  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">resize</span><span class="hljs-params">()</span> &#123;  <br>        Entry[] newTable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[table.length &lt;&lt; <span class="hljs-number">2</span>];<span class="hljs-comment">//新数组 容量是原来的2倍  </span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; table.length; i++) &#123;  <br>            <span class="hljs-type">Entry</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> table[i];<span class="hljs-comment">//头节点  </span><br>            <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">null</span>) &#123;  <br>                <span class="hljs-type">Entry</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;  <br>                <span class="hljs-type">Entry</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;  <br>                <span class="hljs-type">Entry</span> <span class="hljs-variable">aHead</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;  <br>                <span class="hljs-type">Entry</span> <span class="hljs-variable">bHead</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;  <br>                <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span>) &#123;  <br>                    <span class="hljs-comment">//拆分链表 移动到新数组  </span><br>                <span class="hljs-comment">/*  </span><br><span class="hljs-comment">                拆分规律：  </span><br><span class="hljs-comment">                    一个链表最多拆分成两个链表  </span><br><span class="hljs-comment">                    hash&amp;table.length 为0的一组  </span><br><span class="hljs-comment">                    hash&amp;table.length 为1的一组  </span><br><span class="hljs-comment">                 */</span>                    <span class="hljs-keyword">if</span> ((p.hash &amp; table.length) == <span class="hljs-number">0</span>) &#123;  <br>                        <span class="hljs-comment">//a组  </span><br>                        <span class="hljs-keyword">if</span> (a != <span class="hljs-literal">null</span>) &#123;  <br>                            a.next = p;  <br>                        &#125; <span class="hljs-keyword">else</span> &#123;  <br>                            aHead = p;<span class="hljs-comment">//记录头节点  </span><br>                        &#125;  <br>                        a = p;  <br>                    &#125; <span class="hljs-keyword">else</span> &#123;  <br>                        <span class="hljs-comment">//b组  </span><br>                        <span class="hljs-keyword">if</span> (b != <span class="hljs-literal">null</span>) &#123;  <br>                            b.next = p;  <br>                        &#125; <span class="hljs-keyword">else</span> &#123;  <br>                            bHead = p;<span class="hljs-comment">//记录头节点  </span><br>                        &#125;  <br>                        b = p;  <br>                    &#125;  <br>                    p = p.next;  <br>                &#125;  <br>                <span class="hljs-comment">//a、b组，各自的头节点重置规律  </span><br>                <span class="hljs-comment">//a:保持索引位置不变  </span><br>                <span class="hljs-comment">//b:索引位置=原索引位置+原数组长度  </span><br>                <span class="hljs-keyword">if</span> (a != <span class="hljs-literal">null</span>) &#123;  <br>                    a.next = <span class="hljs-literal">null</span>;  <br>                    newTable[i] = aHead;  <br>                &#125;  <br>                <span class="hljs-keyword">if</span> (b != <span class="hljs-literal">null</span>) &#123;  <br>                    b.next = <span class="hljs-literal">null</span>;  <br>                    newTable[i + table.length] = bHead;  <br>                &#125;  <br>            &#125;        &#125;        table = newTable;  <br>        threshold = (<span class="hljs-type">int</span>) (table.length * loadFactor);<span class="hljs-comment">//更新阈值size  </span><br>    &#125;  <br>  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * hash 改造  </span><br><span class="hljs-comment">     * &lt;p&gt;  </span><br><span class="hljs-comment">     * hash码，一种简单的方式，可以直接使用jdk的 object.hashCode()  </span><br><span class="hljs-comment">     * 所以上述 get、put、remove方法都可以加一个重载，去掉hash参数  </span><br><span class="hljs-comment">     */</span>  <br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;  <br>        <span class="hljs-keyword">return</span> key.hashCode();  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">get</span><span class="hljs-params">(Object key)</span> &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> hash(key);  <br>        <span class="hljs-keyword">return</span> get(hash, key);  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(Object key, Object value)</span> &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> hash(key);  <br>        put(hash, key, value);  <br>    &#125;  <br>  <br>    Object <span class="hljs-title function_">remove</span><span class="hljs-params">(Object key)</span> &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> hash(key);  <br>        <span class="hljs-keyword">return</span> remove(hash, key);  <br>    &#125;  <br>  <br>  <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>data&amp;algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构和算法之旅（十）- 红黑树</title>
    <link href="/posts/c47e1f8e/"/>
    <url>/posts/c47e1f8e/</url>
    
    <content type="html"><![CDATA[<blockquote><p>红黑树也是一种自平衡的二叉搜索树，较之AVL，插入和删除旋转次数更少。性能上要稍微高一些。因为判断平衡的依据是不同的，之前AVL树是判断左右子树高度差是不是超过了1，超过1表示不平衡。而红黑树判断平衡是另一种规则。</p></blockquote><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>红黑树特性：</p><ul><li>1.所有节点都有俩种颜色：红与黑</li><li>2.所有null视为黑色</li><li>3.红色节点不能相邻，(判断平衡的主要依据)</li><li>4.根节点时黑色</li><li>5.从根到任意一个叶子节点，路径中的黑色节点数一样(判断平衡的主要依据)</li></ul><p>不满足这些特性的都是不平衡的红黑树。</p></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309220920490.png"></p><h2 id="是否是红黑树？"><a href="#是否是红黑树？" class="headerlink" title="是否是红黑树？"></a>是否是红黑树？</h2><h3 id="树1"><a href="#树1" class="headerlink" title="树1"></a>树1</h3><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309221519546.png"></p><p class="note note-danger">不是红黑树。因为违反了第3条：红色节点不能相邻。</p><h3 id="树2"><a href="#树2" class="headerlink" title="树2"></a>树2</h3><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309221521761.png"></p><p class="note note-danger">不是红黑树。因为违反了第5条：从根到任意一个叶子节点，路径中黑色节点数一样。右边重，左边轻，是不平衡的。</p><h3 id="树3"><a href="#树3" class="headerlink" title="树3"></a>树3</h3><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309221522358.png"></p><p class="note note-success">是红黑树。关键的3,4,5条特性都满足。</p><h3 id="树4"><a href="#树4" class="headerlink" title="树4"></a>树4</h3><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309221524531.png"></p><p class="note note-danger">这个和上一个类似，但是它并不是平衡的。<br>因为没有考虑null值。<br>那什么时候需要考虑null呢，就是当叶子节点没有自己的兄弟的时候，这个时候就需要把null加进来考虑。</p><p>如果加入null值，如下图， 6到2的右孩子只有俩个黑色，而6到1或者8的孩子都是3个黑色，所以是不平衡的。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309221526990.png"></p><p class="note note-warning">那为什么树3是平衡的红黑树呢？可以把null考虑进来，可以看出根到任意叶子节点的黑色数都是3，所以是平衡的。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309221531405.png"></p><p class="note note-primary">判断是否平衡有一点经验总结。<br>如果叶子节点是红色，可以不用不用care。<br>如果叶子节点就一个黑色，没有兄弟节点，那肯定是不平衡的。<br>红色节点无所谓，黑色节点肯定要成对出现的。</p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309221539104.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> redblack;  <br>  <br><span class="hljs-keyword">import</span> com.sun.org.apache.regexp.internal.RE;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedBlackTree</span> &#123;  <br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> &#123;  <br>        RED, BLACK;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">private</span> Node root;  <br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;  <br>        <span class="hljs-type">int</span> key;  <br>        Object value;  <br>        Node left;  <br>        Node right;  <br>        Node parent;<span class="hljs-comment">//父节点 因为红黑树的删除和新增经常用到父节点  </span><br>        <span class="hljs-type">Color</span> <span class="hljs-variable">color</span> <span class="hljs-operator">=</span> Color.RED;<span class="hljs-comment">//默认刚创建出来新节点是为红色  </span><br>  <br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> key, Object value)</span> &#123;  <br>            <span class="hljs-built_in">this</span>.key = key;  <br>            <span class="hljs-built_in">this</span>.value = value;  <br>        &#125;  <br>  <br>        <span class="hljs-comment">//是否是左孩子 常用工具方法  </span><br>        <span class="hljs-type">boolean</span> <span class="hljs-title function_">isLeftChild</span><span class="hljs-params">()</span> &#123;  <br>            <span class="hljs-comment">//如果父节点不为空且父节点的left是自身则是左孩子  </span><br>            <span class="hljs-keyword">return</span> parent != <span class="hljs-literal">null</span> &amp;&amp; parent.left == <span class="hljs-built_in">this</span>;  <br>        &#125;  <br>  <br>        <span class="hljs-comment">//叔叔 常用工具方法  </span><br>        Node <span class="hljs-title function_">uncle</span><span class="hljs-params">()</span> &#123;  <br>            <span class="hljs-keyword">if</span> (parent == <span class="hljs-literal">null</span> || parent.parent == <span class="hljs-literal">null</span>) &#123;  <br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<span class="hljs-comment">//没有爷爷就没有叔叔  </span><br>            &#125;  <br>            <span class="hljs-keyword">if</span> (parent.isLeftChild()) &#123;  <br>                <span class="hljs-keyword">return</span> parent.parent.right;  <br>            &#125; <span class="hljs-keyword">else</span> &#123;  <br>                <span class="hljs-keyword">return</span> parent.parent.left;  <br>            &#125;  <br>        &#125;  <br>  <br>        <span class="hljs-comment">//兄弟 常用工具方法  </span><br>        Node <span class="hljs-title function_">sibling</span><span class="hljs-params">()</span> &#123;  <br>            <span class="hljs-keyword">if</span> (parent == <span class="hljs-literal">null</span>) &#123;  <br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<span class="hljs-comment">//没父亲就没兄弟  </span><br>            &#125;  <br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.isLeftChild()) &#123;  <br>                <span class="hljs-keyword">return</span> parent.right;  <br>            &#125; <span class="hljs-keyword">else</span> &#123;  <br>                <span class="hljs-keyword">return</span> parent.left;  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//判断红、黑  </span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isRed</span><span class="hljs-params">(Node node)</span> &#123;  <br>        <span class="hljs-keyword">return</span> node != <span class="hljs-literal">null</span> &amp;&amp; node.color == Color.RED;  <br>    &#125;  <br>  <br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBlack</span><span class="hljs-params">(Node node)</span> &#123;  <br>        <span class="hljs-keyword">return</span> node == <span class="hljs-literal">null</span> || node.color == Color.BLACK;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//右选 1.parent的处理 2.旋转后新根的父子关系  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rightRotate</span><span class="hljs-params">(Node pink)</span> &#123;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> pink.parent;<span class="hljs-comment">//pink不平衡的节点  </span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">yellow</span> <span class="hljs-operator">=</span> pink.left;<span class="hljs-comment">//yellow新根  </span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">green</span> <span class="hljs-operator">=</span> yellow.right;<span class="hljs-comment">//green要换爹的  </span><br>        <span class="hljs-keyword">if</span> (green != <span class="hljs-literal">null</span>) &#123;  <br>            green.parent = pink;  <br>        &#125;  <br>        yellow.right = pink;<span class="hljs-comment">//顶上去  </span><br>        yellow.parent = parent;  <br>        pink.left = green;  <br>        pink.parent = yellow;  <br>        <span class="hljs-keyword">if</span> (parent == <span class="hljs-literal">null</span>) &#123;  <br>            root = yellow;  <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (parent.left == pink) &#123;  <br>            parent.left = yellow;  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            parent.right = yellow;  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//左旋  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">leftRotate</span><span class="hljs-params">(Node pink)</span> &#123;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> pink.parent;<span class="hljs-comment">//pink不平衡的节点  </span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">yellow</span> <span class="hljs-operator">=</span> pink.right;<span class="hljs-comment">//yellow新根  </span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">green</span> <span class="hljs-operator">=</span> yellow.left;<span class="hljs-comment">//green要换爹的  </span><br>        <span class="hljs-keyword">if</span> (green != <span class="hljs-literal">null</span>) &#123;  <br>            green.parent = pink;  <br>        &#125;  <br>        yellow.left = pink;<span class="hljs-comment">//顶上去  </span><br>        yellow.parent = parent;  <br>        pink.right = green;  <br>        pink.parent = yellow;  <br>        <span class="hljs-keyword">if</span> (parent == <span class="hljs-literal">null</span>) &#123;  <br>            root = yellow;  <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (parent.right == pink) &#123;  <br>            parent.right = yellow;  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            parent.left = yellow;  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 新增或更新  </span><br><span class="hljs-comment">     * 找空位，找到之后根据k-v创建新的节点对象，然后根父节点建立好父子关系，新增操作就算完成了。  </span><br><span class="hljs-comment">     * 如果没有找到空位，就根据key的大小不断的向左找向右找。  </span><br><span class="hljs-comment">     * 如果找相同的key，就是更新。  </span><br><span class="hljs-comment">     * &lt;p&gt;  </span><br><span class="hljs-comment">     * 正常增，遇到红红不平衡进行调整  </span><br><span class="hljs-comment">     * 红红不平衡细分有四种case。  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, Object value)</span> &#123;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> root;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<span class="hljs-comment">//记录新增节点的父节点  </span><br>        <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span>) &#123;  <br>            parent = p;  <br>            <span class="hljs-keyword">if</span> (key &lt; p.key) &#123;  <br>                p = p.left;  <br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p.key &lt; key) &#123;  <br>                p = p.right;  <br>            &#125; <span class="hljs-keyword">else</span> &#123;  <br>                p.value = value;<span class="hljs-comment">//更新  </span><br>                <span class="hljs-keyword">return</span>;  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">inserted</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(key, value);  <br>        <span class="hljs-keyword">if</span> (parent == <span class="hljs-literal">null</span>) root = inserted;  <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &lt; parent.key) &#123;  <br>            parent.left = inserted;  <br>            inserted.parent = parent;<span class="hljs-comment">//1.维护parent属性  </span><br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            parent.right = inserted;  <br>            inserted.parent = parent;<span class="hljs-comment">//1.维护parent属性  </span><br>        &#125;  <br>        fixRedRed(inserted);  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//修复红红  </span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">fixRedRed</span><span class="hljs-params">(Node x)</span> &#123;  <br>        <span class="hljs-comment">//case 1.插入节点是根节点，变黑集合  </span><br>        <span class="hljs-keyword">if</span> (x == root) &#123;  <br>            x.color = Color.BLACK;  <br>            <span class="hljs-keyword">return</span>;  <br>        &#125;  <br>        <span class="hljs-comment">//case 2.插入节点父亲是黑色，无需调整  </span><br>        <span class="hljs-keyword">if</span> (isBlack(x.parent)) &#123;  <br>            <span class="hljs-keyword">return</span>;  <br>        &#125;  <br>        <span class="hljs-comment">/*  </span><br><span class="hljs-comment">        case 3.当红红相邻，叔叔为红色时  </span><br><span class="hljs-comment">        需要将父亲、叔叔变黑、祖父变红，然后对祖父做递归处理  </span><br><span class="hljs-comment">         */</span>        <span class="hljs-type">Node</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> x.parent;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">uncle</span> <span class="hljs-operator">=</span> x.uncle();  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">grandparent</span> <span class="hljs-operator">=</span> parent.parent;  <br>        <span class="hljs-keyword">if</span> (isRed(uncle)) &#123;  <br>            parent.color = Color.BLACK;  <br>            uncle.color = Color.BLACK;  <br>            grandparent.color = Color.RED;  <br>            fixRedRed(grandparent);  <br>        &#125;  <br>  <br>        <span class="hljs-comment">//case 4.  </span><br>        <span class="hljs-keyword">if</span> (parent.isLeftChild() &amp;&amp; x.isLeftChild()) &#123;<span class="hljs-comment">//LL  </span><br>            parent.color = Color.BLACK;  <br>            grandparent.color = Color.RED;  <br>            rightRotate(grandparent);  <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (parent.isLeftChild() &amp;&amp; !x.isLeftChild()) &#123;<span class="hljs-comment">//RL  </span><br>            leftRotate(parent);<span class="hljs-comment">//使之变成LL case  </span><br>            x.color = Color.BLACK;  <br>            grandparent.color = Color.RED;  <br>            rightRotate(grandparent);  <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!parent.isLeftChild() &amp;&amp; !x.isLeftChild()) &#123;<span class="hljs-comment">//RR  </span><br>            parent.color = Color.BLACK;  <br>            grandparent.color = Color.RED;  <br>            leftRotate(grandparent);  <br>        &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//LR  </span><br>            rightRotate(parent);<span class="hljs-comment">////使之变成RR case  </span><br>            x.color = Color.BLACK;  <br>            grandparent.color = Color.RED;  <br>            leftRotate(grandparent);  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 查找删除节点  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">private</span> Node <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> root;  <br>        <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-keyword">if</span> (key &lt; p.key) &#123;  <br>                p = p.left;  <br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p.key &lt; key) &#123;  <br>                p = p.right;  <br>            &#125; <span class="hljs-keyword">else</span> &#123;  <br>                <span class="hljs-keyword">return</span> p;  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 查找剩余节点  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">private</span> Node <span class="hljs-title function_">findReplaced</span><span class="hljs-params">(Node deleted)</span> &#123;  <br>        <span class="hljs-keyword">if</span> (deleted.left == <span class="hljs-literal">null</span> &amp;&amp; deleted.right == <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>        &#125;  <br>        <span class="hljs-keyword">if</span> (deleted.left == <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-keyword">return</span> deleted.right;  <br>        &#125;  <br>        <span class="hljs-keyword">if</span> (deleted.right == <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-keyword">return</span> deleted.left;  <br>        &#125;  <br>        <span class="hljs-comment">//有俩个孩子，要找后继节点(右子树的最左)  </span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> deleted.right;  <br>        <span class="hljs-keyword">while</span> (s.left != <span class="hljs-literal">null</span>) &#123;  <br>            s = s.left;  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> s;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 删除  </span><br><span class="hljs-comment">     * 正常删、会用到李代桃僵的技巧，遇到黑黑不平衡进行调整  </span><br><span class="hljs-comment">     * 黑黑不平衡细分有6种case。  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">deleted</span> <span class="hljs-operator">=</span> find(key);  <br>        <span class="hljs-keyword">if</span> (deleted == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;  <br>        doRemove(deleted);  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doRemove</span><span class="hljs-params">(Node deleted)</span> &#123;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">replaced</span> <span class="hljs-operator">=</span> findReplaced(deleted);  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> deleted.parent;  <br>        <span class="hljs-keyword">if</span> (replaced == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//没有孩子  </span><br>            <span class="hljs-comment">//case 1.删的根节点  </span><br>            <span class="hljs-keyword">if</span> (deleted == root) &#123;  <br>                root = <span class="hljs-literal">null</span>;  <br>            &#125; <span class="hljs-keyword">else</span> &#123;  <br>                <span class="hljs-keyword">if</span> (isBlack(deleted)) &#123;<span class="hljs-comment">//删除到节点时黑，剩余的也是黑，双黑(null也是黑)  </span><br>                    <span class="hljs-comment">//复杂调整  </span><br>                    fixDoubleBlack(deleted);<span class="hljs-comment">//先调整平衡，下面在删除  </span><br>                &#125; <span class="hljs-keyword">else</span> &#123;  <br>                    <span class="hljs-comment">//红色叶子，无需任何处理  </span><br>                &#125;  <br>                <span class="hljs-comment">//case 2.不是根节点 并没有孩子  </span><br>                <span class="hljs-keyword">if</span> (deleted.isLeftChild()) &#123;  <br>                    parent.left = <span class="hljs-literal">null</span>;  <br>                &#125; <span class="hljs-keyword">else</span> &#123;  <br>                    parent.right = <span class="hljs-literal">null</span>;  <br>                &#125;  <br>                deleted.parent = <span class="hljs-literal">null</span>;<span class="hljs-comment">//help GC  </span><br>            &#125;  <br>            <span class="hljs-keyword">return</span>;  <br>        &#125;  <br>        <span class="hljs-keyword">if</span> (deleted.left == <span class="hljs-literal">null</span> || deleted.right == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//有一个孩子  </span><br>            <span class="hljs-keyword">if</span> (deleted == root) &#123;  <br>                <span class="hljs-comment">//case 1.删的根节点  </span><br>                root.key = replaced.key;  <br>                root.value = replaced.value;  <br>                root.left = root.right = <span class="hljs-literal">null</span>;  <br>            &#125; <span class="hljs-keyword">else</span> &#123;  <br>                <span class="hljs-comment">//case 2.不是根节点 并有一个孩子  </span><br>                <span class="hljs-keyword">if</span> (deleted.isLeftChild()) &#123;  <br>                    parent.left = replaced;  <br>                &#125; <span class="hljs-keyword">else</span> &#123;  <br>                    parent.right = replaced;  <br>                &#125;  <br>                replaced.parent = parent;  <br>                deleted.left = deleted.right = deleted.parent = <span class="hljs-literal">null</span>;<span class="hljs-comment">//help GC  </span><br>                <span class="hljs-keyword">if</span> (isBlack(deleted) &amp;&amp; isBlack(replaced)) &#123;<span class="hljs-comment">//删除到节点时黑，剩余的也是黑，双黑  </span><br>                    <span class="hljs-comment">//复杂调整  </span><br>                    fixDoubleBlack(replaced);<span class="hljs-comment">//上面先删除了，再调整  </span><br>                &#125; <span class="hljs-keyword">else</span> &#123;  <br>                    <span class="hljs-comment">//case 2  </span><br>                    replaced.color = Color.BLACK;  <br>                &#125;  <br>            &#125;  <br>            <span class="hljs-keyword">return</span>;  <br>        &#125;  <br>        <span class="hljs-comment">//有俩个孩子，找到后继，替换，删除后继节点  </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> deleted.key;  <br>        deleted.key = replaced.key;  <br>        replaced.key = t;  <br>  <br>        <span class="hljs-type">Object</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> deleted.value;  <br>        deleted.value = replaced.value;  <br>        replaced.value = v;  <br>        doRemove(replaced);  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 处理双黑  </span><br><span class="hljs-comment">     * 删除到节点和剩下的节点都是黑，触发双黑，双黑的意思是，整个路径上少一个黑！需要调整  </span><br><span class="hljs-comment">     * case 3：被调整节点的兄弟为红，此时俩个侄子定为黑（过度情况，需要转换成4或5，通过旋转）  </span><br><span class="hljs-comment">     * case 4：被调整节点的兄弟为黑，俩个侄子都为黑  </span><br><span class="hljs-comment">     * case 5：被调整节点的兄弟为黑，至少一个红侄子  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fixDoubleBlack</span><span class="hljs-params">(Node x)</span> &#123;  <br>        <span class="hljs-keyword">if</span> (x == root) &#123;<span class="hljs-comment">//递归结束条件  </span><br>            <span class="hljs-keyword">return</span>;  <br>        &#125;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> x.parent;<span class="hljs-comment">//父  </span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">sibling</span> <span class="hljs-operator">=</span> x.sibling();<span class="hljs-comment">//兄弟  </span><br>        <span class="hljs-comment">//case 3:兄弟节点是红色  </span><br>        <span class="hljs-keyword">if</span> (isRed(sibling)) &#123;  <br>            <span class="hljs-keyword">if</span> (x.isLeftChild()) &#123;<span class="hljs-comment">//旋转  </span><br>                leftRotate(parent);  <br>            &#125; <span class="hljs-keyword">else</span> &#123;  <br>                rightRotate(parent);  <br>            &#125;  <br>            parent.color = Color.RED;<span class="hljs-comment">//换色  </span><br>            sibling.color = Color.BLACK;  <br>            fixDoubleBlack(x);  <br>            <span class="hljs-keyword">return</span>;  <br>        &#125;  <br>        <span class="hljs-comment">//case 4:兄弟节点是黑色，俩个侄子都是黑  </span><br>        <span class="hljs-keyword">if</span> (sibling != <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-keyword">if</span> (isBlack(sibling.left) &amp;&amp; isBlack(sibling.right)) &#123;  <br>                sibling.color = Color.RED;  <br>                <span class="hljs-keyword">if</span> (isRed(parent)) &#123;  <br>                    parent.color = Color.BLACK;  <br>                &#125; <span class="hljs-keyword">else</span> &#123;  <br>                    fixDoubleBlack(parent);  <br>                &#125;  <br>            &#125; <span class="hljs-keyword">else</span> &#123;  <br>                <span class="hljs-comment">//case 5:兄弟是黑色，但是侄子有红色  </span><br>                <span class="hljs-comment">//LL 兄弟是左孩子，左侄子是红  </span><br>                <span class="hljs-keyword">if</span> (sibling.isLeftChild() &amp;&amp; isRed(sibling.left)) &#123;  <br>                    rightRotate(parent);  <br>                    sibling.left.color = Color.BLACK;  <br>                    sibling.color = parent.color;  <br>                &#125;  <br>                <span class="hljs-comment">//LR 兄弟是左孩子，右侄子是红  </span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sibling.isLeftChild() &amp;&amp; isRed(sibling.right)) &#123;  <br>                    sibling.right.color = parent.color;  <br>                    leftRotate(sibling);  <br>                    rightRotate(parent);  <br>                &#125;  <br>                <span class="hljs-comment">//RR 兄弟是右孩子，右侄子是红  </span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!sibling.isLeftChild() &amp;&amp; isRed(sibling.left)) &#123;  <br>                    sibling.left.color = parent.color;  <br>                    rightRotate(sibling);  <br>                    leftRotate(parent);  <br>                &#125;  <br>                <span class="hljs-comment">//RL 兄弟是右孩子，左侄子是红  </span><br>                <span class="hljs-keyword">else</span> &#123;  <br>                    leftRotate(parent);  <br>                    sibling.right.color = Color.BLACK;  <br>                    sibling.color = parent.color;  <br>                &#125;  <br>                parent.color = Color.BLACK;  <br>            &#125;  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            fixDoubleBlack(parent);  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h3><p><strong>旋转前</strong></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309221548839.png"></p><p><strong>旋转后</strong></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309221550900.png"></p><p>理解旋转，对照图，标记颜色有助于帮助理解，和代码实现。</p><p>📌<em>旋转前</em>：<br>yellow是pink的左孩子；<code>Node yellow = pink.left</code><br>green是yellow的右孩子；<code>Node green = yellow.right</code><br>📌<em>旋转后</em>：<br>yellow要顶上去，成为新根；<br>pink要下去，成为yellow的右孩子；<code>yellow.right = pink</code><br>而且pink的左孩子变成了green； <code>pink.left = green</code></p><p>到这一步，如果是AVL树就完事了，不过红黑树还要维护一个parent，🙃 还需要继续处理，并且要把新根yellow的父子关系直接在旋转这个方法里给搭建好；</p><p>接下来就把pink、yellow、green的parent属性处理好。</p><p>1️⃣ 处理green的parent：<br>旋转前，green的parent是yellow；<br>旋转后，green的parent是pink；<br>所以green的parent要重新赋值，当然green并不一定存在，所以需要一个判断：<br><code>if(green != null) green.parent = pink;</code></p><p>2️⃣ 处理yellow的parent：<br>旋转前，yellow的parent是pink；<br>旋转后，yellow成了pink的parent；<br>该图列不存在5,8的parent，但是可能存在，所以，<br><code>yellow.parent = pink.parent</code> 等价于 <code>yellow.parent = parent</code>，<br>因为这个parent就是通过<code>Node parent = pink.parent</code>拿到的。</p><p>3️⃣ 处理pink的parent：<br>旋转后，pink的parent变成了yellow；<br>所以<code>pink.parent = yellow</code></p><p><strong>还有一件事</strong>，就是处理好新根的父子关系，该图例有些特殊，直接就是根了，看一下下面图例：</p><p><strong>旋转前</strong></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309221605459.png"></p><p><strong>旋转后</strong></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309221606180.png"></p><p>要维护yellow顶上去之后的parent父子关系。<br>旋转前，通过<code>Node parent = pink.parent;</code> 拿到之前的根。<br>旋转后，需要判断之前pink是它的父的左还是右孩子，就可以判断之后，决定yellow是之前根到左还是右，所以：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(parent.left == pink)&#123;<br>parent.left = yellow;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>parent.right = yellow;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后再考虑之前的特殊情况，<br><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309221548839.png"></p><p>pink是之前的根，它的parent是null，那去给它的left、right赋值肯定是有问题的，所以应该排除这种情况，直接把yellow作为root即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(parent == <span class="hljs-literal">null</span>) root = yellow;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(parent.left == pink)&#123;<span class="hljs-comment">//把上面的非根情况逻辑补充上</span><br>parent.left = yellow;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>parent.right = yellow;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h3><p>其实左旋类似右旋，只不过反过来。可以通过着色法搞一下，比对右旋加深理解。</p><h3 id="新增或更新"><a href="#新增或更新" class="headerlink" title="新增或更新"></a>新增或更新</h3><p>新增的时候，跟基本的二叉搜索树一致，只不过多两件事</p><ul><li>1.要维护新增节点的parent属性</li><li>2.要维护红红的不平衡，因为新增的是默认红色</li></ul><p>红红不平衡，细分有四种case：<br>因为插入节点均视为红色🔴</p><ul><li>case 1.插入节点为根节点，将根节点变黑⚫️</li><li>case 2.插入节点的父节点若为黑色⚫️，树的红黑性质不变，无序调整<br>插入节点的父节点为红色🔴，触发红红相邻</li><li>case 3.叔叔为红色🔴<ul><li>1.父亲变为黑色⚫️，为了保证黑色平衡，连带叔叔也变成黑色⚫️</li><li>2.祖父如果是黑色不变，会造成这个子树黑色过多，因此祖父也变为红色🔴</li><li>3.祖父如果变成红色，可能会接着触发红红相邻，因此继续对祖父进行递归调整</li><li>4.直到根节点，如果root变为红色，改为红色就完成了</li></ul></li><li>case 4.叔叔为黑色⚫️<ul><li>1.父亲为左孩子，插入节点也是左孩子，此时即LL不平衡</li><li>2.父亲为左孩子，插入节点是右孩子，此时即LR不平衡</li><li>3.父亲为右孩子，插入节点也是右孩子，此时即RR不平衡</li><li>4.父亲为右孩子，插入节点是左孩子，此时即RL不平衡</li></ul></li></ul><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>删除可能触发双黑的情况，触发双黑，双黑的意思是，整个路径上少一个黑！需要调整也有很多case如下：</p><ul><li>case 0：如果删除节点有俩个孩子，化简成只有一个孩子或没有孩子（替换删除）</li><li>csae 1：删除到是根节点</li><li>case 2：删除的是黑⚫️，剩下的红🔴，剩下这个红节点变黑⚫️</li><li>case 3：被调整节点的兄弟为红🔴，此时俩个侄子定为黑⚫️</li><li>case 4：被调整节点的兄弟是黑⚫️，俩个侄子都为黑⚫️</li><li>case 5：被调整节点的兄弟是黑⚫️，至少一个红🔴侄子<ul><li>如果兄弟是左孩子，左侄子是红🔴，LL不平衡</li><li>如果兄弟是左孩子，右侄子是红🔴，LR不平衡</li><li>如果兄弟是右孩子，右侄子是红🔴，RR不平衡</li><li>如果兄弟是右孩子，左侄子是红🔴，RL不平衡</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>data&amp;algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>红黑树</tag>
      
      <tag>左旋</tag>
      
      <tag>右旋</tag>
      
      <tag>变色</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构和算法之旅（九）- AVL树</title>
    <link href="/posts/cbf454fc/"/>
    <url>/posts/cbf454fc/</url>
    
    <content type="html"><![CDATA[<p class="note note-light">二叉搜索树，如果不平衡，那么查找效率就会从对数级降级成O(n)。<br>可以通过旋转来恢复平衡，而且旋转并不影响二叉搜索树的特性。<br>那么，如何判断是否不平衡呢，是有个结论的：<br>如果一个节点的左右孩子，高度差超过1，则此节点失衡，才需要旋转。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309212107467.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309212109106.png"></p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><ul><li>二叉搜索树在插入和删除时，节点可能失衡。</li><li>如果在插入和删除时通过旋转，始终让二叉搜索树保持平衡，称为自平衡的二叉搜索树。</li><li>AVL是自平衡二叉搜索树的实现之一。</li></ul></blockquote><h2 id="旋转分析"><a href="#旋转分析" class="headerlink" title="旋转分析"></a>旋转分析</h2><p>失衡有四种情况LL、LR、RL、RR，但基本的选择操作有俩种就是左旋或右旋。</p><h3 id="LL"><a href="#LL" class="headerlink" title="LL"></a>LL</h3><blockquote><ul><li>失衡节点（图中5红色）的bf &gt; 1，即左边更高</li><li>失衡节点的左孩子（图中3黄色）的bf &gt;&#x3D; 0，即左孩子也是左边更高或等高</li></ul></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309212134218.png"></p><h3 id="LR"><a href="#LR" class="headerlink" title="LR"></a>LR</h3><blockquote><ul><li>失衡节点（图中6）的bf &gt; 1，即左边高</li><li>失衡节点的左孩子（图中2红色）的bf &lt; 0，即左孩子是右边高</li></ul></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309212135453.png"></p><h3 id="RL"><a href="#RL" class="headerlink" title="RL"></a>RL</h3><blockquote><ul><li>失衡节点（图中2）的bf &lt; -1 ，即右边高</li><li>失衡节点的右孩子（图中6红色）的bf &gt; 0 ，即右孩子的左边更高</li></ul></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309212135743.png"></p><h3 id="RR"><a href="#RR" class="headerlink" title="RR"></a>RR</h3><blockquote><ul><li>失衡节点（图中2红色）的bf &lt; -1 ，即右边更高</li><li>失衡节点（图中6黄色）的bf &lt;&#x3D; 0，即右孩子的右边更高或等高</li></ul></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309212135380.png"></p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> avl;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AVLTree</span> &#123;  <br>  <br>    AVLNode root;  <br>  <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AVLNode</span> &#123;  <br>        <span class="hljs-type">int</span> key;  <br>        Object value;  <br>        AVLNode left;  <br>        AVLNode right;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">height</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//高度  </span><br>  <br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">AVLNode</span><span class="hljs-params">(<span class="hljs-type">int</span> key, Object value)</span> &#123;  <br>            <span class="hljs-built_in">this</span>.key = key;  <br>            <span class="hljs-built_in">this</span>.value = value;  <br>        &#125;  <br>  <br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">AVLNode</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;  <br>            <span class="hljs-built_in">this</span>.key = key;  <br>        &#125;  <br>  <br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">AVLNode</span><span class="hljs-params">(<span class="hljs-type">int</span> key, Object value, AVLNode left, AVLNode right)</span> &#123;  <br>            <span class="hljs-built_in">this</span>.key = key;  <br>            <span class="hljs-built_in">this</span>.value = value;  <br>            <span class="hljs-built_in">this</span>.left = left;  <br>            <span class="hljs-built_in">this</span>.right = right;  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//求节点的高度  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">height</span><span class="hljs-params">(AVLNode node)</span> &#123;  <br>        <span class="hljs-keyword">return</span> node == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : node.height;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//更新节点高度(新增、删除、旋转)  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateHeight</span><span class="hljs-params">(AVLNode node)</span> &#123;  <br>        <span class="hljs-comment">//就是找左或右深度加1  </span><br>        node.height = Integer.max(height(node.left), height(node.right)) + <span class="hljs-number">1</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 平衡因子balance factor = 左子树高度-右子树高度  </span><br><span class="hljs-comment">     * 0 , -1, 1 都是平衡的  </span><br><span class="hljs-comment">     * bf&gt;1，不平衡，表示左边高  </span><br><span class="hljs-comment">     * bf&lt;-1，不平衡，表示右边高  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">bf</span><span class="hljs-params">(AVLNode node)</span> &#123;  <br>        <span class="hljs-keyword">return</span> height(node.left) - height(node.right);  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 右旋，就是把根旋转下去，把左子树旋转上来  </span><br><span class="hljs-comment">     *  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> node 要旋转的节点  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 选装上去的新的根节点  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">private</span> AVLNode <span class="hljs-title function_">rightRotate</span><span class="hljs-params">(AVLNode node)</span> &#123;  <br>        <span class="hljs-type">AVLNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> node.left;<span class="hljs-comment">//找到左子树  </span><br>        left.right = node;<span class="hljs-comment">//顶上去  </span><br>        node.left = left.right;<span class="hljs-comment">//换爹的  </span><br>        updateHeight(node);<span class="hljs-comment">//更新高度  </span><br>        updateHeight(left);<span class="hljs-comment">//更新高度  </span><br>        <span class="hljs-keyword">return</span> left;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 左旋，就是把根旋转下去，把右子树旋转上来  </span><br><span class="hljs-comment">     *  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> node 要旋转的节点  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 选装上去的新的根节点  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">private</span> AVLNode <span class="hljs-title function_">leftRotate</span><span class="hljs-params">(AVLNode node)</span> &#123;  <br>        <span class="hljs-type">AVLNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> node.right;<span class="hljs-comment">//找到右子树  </span><br>        right.left = node;<span class="hljs-comment">//顶上去  </span><br>        node.right = right.left;<span class="hljs-comment">//换爹的  </span><br>        updateHeight(node);<span class="hljs-comment">//更新高度  </span><br>        updateHeight(right);<span class="hljs-comment">//更新高度  </span><br>        <span class="hljs-keyword">return</span> right;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//先左旋左子树，再右旋根节点  </span><br>    <span class="hljs-keyword">private</span> AVLNode <span class="hljs-title function_">leftRightRotate</span><span class="hljs-params">(AVLNode node)</span> &#123;  <br>        node.left = leftRotate(node.left);  <br>        <span class="hljs-keyword">return</span> rightRotate(node);  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//先右旋右子树，在左旋根节点  </span><br>    <span class="hljs-keyword">private</span> AVLNode <span class="hljs-title function_">rightLeftRotate</span><span class="hljs-params">(AVLNode node)</span> &#123;  <br>        node.right = rightRotate(node.right);  <br>        <span class="hljs-keyword">return</span> leftRotate(node);  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 检查节点是否失衡，重新平衡  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">private</span> AVLNode <span class="hljs-title function_">balance</span><span class="hljs-params">(AVLNode node)</span> &#123;  <br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">bf</span> <span class="hljs-operator">=</span> bf(node);  <br>        <span class="hljs-keyword">if</span> (bf &gt; <span class="hljs-number">1</span> &amp;&amp; bf(node.left) &gt;= <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//LL 考虑删除引发的不平衡，加个等号  </span><br>            <span class="hljs-keyword">return</span> leftRotate(node);  <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bf &gt; <span class="hljs-number">1</span> &amp;&amp; bf(node.left) &lt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//LR  </span><br>            <span class="hljs-keyword">return</span> leftRightRotate(node);  <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bf &lt; -<span class="hljs-number">1</span> &amp;&amp; bf(node.right) &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//RL  </span><br>            <span class="hljs-keyword">return</span> rightLeftRotate(node);  <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bf &lt; -<span class="hljs-number">1</span> &amp;&amp; bf(node.right) &lt;= <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//RR 考虑删除引发的不平衡，加个等号  </span><br>            <span class="hljs-keyword">return</span> rightRotate(node);  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> node;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 新增&amp;更新  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, Object value)</span> &#123;  <br>        root = doPut(root, key, value);  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 递归实现put  </span><br><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> AVLNode <span class="hljs-title function_">doPut</span><span class="hljs-params">(AVLNode node, <span class="hljs-type">int</span> key, Object value)</span> &#123;  <br>        <span class="hljs-comment">//1.找到空位，创建新节点  </span><br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AVLNode</span>(key, value);  <br>        &#125;  <br>        <span class="hljs-comment">//2.key已存在，更新  </span><br>        <span class="hljs-keyword">if</span> (key == node.key) &#123;  <br>            node.value = value;  <br>            <span class="hljs-keyword">return</span> node;  <br>        &#125;  <br>        <span class="hljs-comment">//3.继续查找  </span><br>        <span class="hljs-keyword">if</span> (key &lt; node.key) &#123;  <br>            node.left = doPut(node.left, key, value);  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            node.right = doPut(node.right, key, value);  <br>        &#125;  <br>        updateHeight(node);  <br>        <span class="hljs-keyword">return</span> balance(node);  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 删除  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;  <br>        root = doRemove(root, root.key);  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">private</span> AVLNode <span class="hljs-title function_">doRemove</span><span class="hljs-params">(AVLNode node, <span class="hljs-type">int</span> key)</span> &#123;  <br>        <span class="hljs-comment">//1.node==null  </span><br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>        <span class="hljs-comment">//2.没找到key继续递归  </span><br>        <span class="hljs-keyword">if</span> (key &lt; node.key) &#123;  <br>            node.left = doRemove(node.left, key);  <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.key &lt; key) &#123;  <br>            node.right = doRemove(node.right, key);  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            <span class="hljs-comment">//3.找到key  1.没有孩子  2.只有一个孩子  3有俩个孩子  </span><br>            <span class="hljs-keyword">if</span> (node.left == <span class="hljs-literal">null</span> &amp;&amp; node.right == <span class="hljs-literal">null</span>) &#123;  <br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.left == <span class="hljs-literal">null</span>) &#123;  <br>                node = node.right;<span class="hljs-comment">//暂存给node 等待更新高度和平衡  </span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.right == <span class="hljs-literal">null</span>) &#123;  <br>                node = node.left;<span class="hljs-comment">//暂存给node 等待更新高度和平衡  </span><br>            &#125; <span class="hljs-keyword">else</span> &#123;  <br>                <span class="hljs-comment">//找后续：右子树的最左  </span><br>                <span class="hljs-comment">//处理后事  </span><br>                <span class="hljs-comment">//顶替  </span><br>                <span class="hljs-type">AVLNode</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.right;  <br>                <span class="hljs-keyword">while</span> (s.left != <span class="hljs-literal">null</span>) &#123;  <br>                    s = s.left;  <br>                &#125;  <br>                s.right = doRemove(node.right, s.key);  <br>                s.left = node.left;  <br>                node = s;  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-comment">//4.更新高度  </span><br>        updateHeight(node);  <br>        <span class="hljs-comment">//5.balance  </span><br>        <span class="hljs-keyword">return</span> balance(node);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>data&amp;algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AVL树</tag>
      
      <tag>失衡</tag>
      
      <tag>高度</tag>
      
      <tag>旋转</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构和算法之旅（八）- 二叉搜索树</title>
    <link href="/posts/6ed67d4e/"/>
    <url>/posts/6ed67d4e/</url>
    
    <content type="html"><![CDATA[<blockquote><p>之前接触过了很多数据结果，包括动态数组、单向链表、双向链表、环形链表、优先级队列、大顶堆等等，在这些数据结构里查找一个元素效率都不太高，都是线性的时间。如果想实现快速查找，就得引入新的算法或者数据结构了。最早了解的二分查找算法查找效率不错，是logn的。但是排序也是成本比较高的，先排序再查找有些得不偿失。<br>那么有什么新的算法或数据结构呢，答案是有的。<br>接下来就来看一下二叉搜索树，也称为二叉排序树。</p></blockquote><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309211606403.png"></p><p class="note note-primary">二叉搜索树有俩个特点：<br>1.树节点增加key属性，用来比较谁大谁小，key不可重复。<br>2.对于任意一个树节点，它的key比左子树的key都大，同时也比右子树的key都小。</p><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><blockquote><p>查找的性能是对数级别的，但是有些情况比如树不平衡的时候，时间复杂度又回到了O(n)。</p></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309211610963.png"></p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309212009913.png"></p><p class="note note-light">以下是几个提前准备的算法基础。</p><p><strong>前任的算法</strong></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309211951386.png"></p><p><strong>后任的算法</strong>（与前任相反）<br><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309212008791.png"></p><p><strong>删除的算法</strong>（稍微复杂）<br><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309212014389.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> bst;  <br>  <br><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * Binary Search Tree二叉搜索树  </span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BSTTree</span>&lt;K <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;K&gt;, V&gt; &#123;  <br>  <br>    BSTNode&lt;K, V&gt; root;<span class="hljs-comment">//根节点  </span><br>  <br>  <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BSTNode</span>&lt;K, V&gt; &#123;  <br>        K key;  <br>        V value;  <br>        BSTNode&lt;K, V&gt; left;  <br>        BSTNode&lt;K, V&gt; right;  <br>  <br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">BSTNode</span><span class="hljs-params">(K key)</span> &#123;  <br>            <span class="hljs-built_in">this</span>.key = key;  <br>        &#125;  <br>  <br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">BSTNode</span><span class="hljs-params">(K key, V value)</span> &#123;  <br>            <span class="hljs-built_in">this</span>.key = key;  <br>            <span class="hljs-built_in">this</span>.value = value;  <br>        &#125;  <br>  <br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">BSTNode</span><span class="hljs-params">(K key, V value, BSTNode&lt;K, V&gt; left, BSTNode&lt;K, V&gt; right)</span> &#123;  <br>            <span class="hljs-built_in">this</span>.key = key;  <br>            <span class="hljs-built_in">this</span>.value = value;  <br>            <span class="hljs-built_in">this</span>.left = left;  <br>            <span class="hljs-built_in">this</span>.right = right;  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 查找关键字对应的值  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(K key)</span> &#123;  <br>        <span class="hljs-comment">//对外隐藏了BSTNode的参数，不用暴露给外界  </span><br>        <span class="hljs-keyword">return</span> doGet(root, key);  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 递归方式实现get  </span><br><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> V <span class="hljs-title function_">doGet</span><span class="hljs-params">(BSTNode&lt;K, V&gt; p, K key)</span> &#123;  <br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<span class="hljs-comment">//没有节点了，没找到，结束递归  </span><br>        &#125;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> key.compareTo(p.key);  <br>        <span class="hljs-keyword">if</span> (result &lt; <span class="hljs-number">0</span>) &#123;  <br>            <span class="hljs-keyword">return</span> doGet(p.left, key);<span class="hljs-comment">//如果待查找的key小于node，向左找  </span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result &gt; <span class="hljs-number">0</span>) &#123;  <br>            <span class="hljs-keyword">return</span> doGet(p.right, key);<span class="hljs-comment">//向右找  </span><br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            <span class="hljs-keyword">return</span> p.value;<span class="hljs-comment">//找到了就返回value  </span><br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 非递归实现get  </span><br><span class="hljs-comment">     * 尾递归的代码转换成非递归的实现非常简单，这样性能更好一些  </span><br><span class="hljs-comment">     * 比较java不支持尾递归自动优化，不妨都转换成循环的方式。  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">_get</span><span class="hljs-params">(K key)</span> &#123;  <br>        BSTNode&lt;K, V&gt; p = root;  <br>        <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> key.compareTo(p.key);  <br>            <span class="hljs-comment">/*  </span><br><span class="hljs-comment">            compareTo            -1 key &lt; node.key            0 key == node.key            1 key &gt; node.key             */</span>            <span class="hljs-keyword">if</span> (result &lt; <span class="hljs-number">0</span>) &#123;  <br>                p = p.left;  <br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result &gt; <span class="hljs-number">0</span>) &#123;  <br>                p = p.right;  <br>            &#125; <span class="hljs-keyword">else</span> &#123;  <br>                <span class="hljs-keyword">return</span> p.value;  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 查找最小关键字的值  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">min</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> doMin(root);  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 递归实现min  </span><br><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">doMin</span><span class="hljs-params">(BSTNode&lt;K, V&gt; node)</span> &#123;  <br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>        <span class="hljs-keyword">if</span> (node.left == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//最小节点  </span><br>            <span class="hljs-keyword">return</span> node.value;  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> doMin(node.left);  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 非递归实现min  </span><br><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">_doMin1</span><span class="hljs-params">(BSTNode node)</span> &#123;  <br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>        <span class="hljs-keyword">while</span> (node.left != <span class="hljs-literal">null</span>) &#123;  <br>            node = node.left;  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> node.value;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 查找最大关键字对应的值  </span><br><span class="hljs-comment">     * 最最小值类似，换找right即可，此处就省略了  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">max</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> _doMax(root);  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 非递归实现max  </span><br><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">_doMax</span><span class="hljs-params">(BSTNode&lt;K, V&gt; node)</span> &#123;  <br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>        <span class="hljs-keyword">while</span> (node.right != <span class="hljs-literal">null</span>) &#123;  <br>            node = node.right;  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> node.value;  <br>    &#125;  <br>  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 存储关键字和对应值  </span><br><span class="hljs-comment">     * 先比较，再判断是更新还是新增  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;  <br>        <span class="hljs-comment">//1.key存在，更新  </span><br>        <span class="hljs-comment">//2.key不存在，新增  </span><br>  <br>        <span class="hljs-comment">//get的实现拿过来  </span><br>        BSTNode&lt;K, V&gt; p = root;  <br>        BSTNode&lt;K, V&gt; parent = <span class="hljs-literal">null</span>;  <br>  <br>        <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span>) &#123;  <br>            parent = p;  <br>            <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> key.compareTo(p.key);  <br>            <span class="hljs-keyword">if</span> (result &lt; <span class="hljs-number">0</span>) &#123;  <br>                p = p.left;  <br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result &gt; <span class="hljs-number">0</span>) &#123;  <br>                p = p.right;  <br>            &#125; <span class="hljs-keyword">else</span> &#123;  <br>                <span class="hljs-comment">//找到了，更新  </span><br>                p.value = value;  <br>                <span class="hljs-keyword">return</span>;  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-comment">//没找到，新增  </span><br>        <span class="hljs-comment">//父节点就是parent，因为if、else if变成null之后parent就是目标父节点  </span><br>        <span class="hljs-keyword">if</span> (parent == <span class="hljs-literal">null</span>) &#123;  <br>            root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BSTNode</span>&lt;&gt;(key, value);  <br>        &#125;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">compareTo</span> <span class="hljs-operator">=</span> key.compareTo(parent.key);  <br>        <span class="hljs-keyword">if</span> (compareTo &lt; <span class="hljs-number">0</span>) &#123;  <br>            parent.left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BSTNode</span>&lt;&gt;(key, value);  <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (compareTo &gt; <span class="hljs-number">0</span>) &#123;  <br>            parent.right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BSTNode</span>&lt;&gt;(key, value);  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 查找关键字的前驱值（前任，比它小的里面最大的）  </span><br><span class="hljs-comment">     * 对二叉搜索树做一次中序遍历一下即可得到升序的结果，但这样不高效。  </span><br><span class="hljs-comment">     * &lt;p&gt;  </span><br><span class="hljs-comment">     * 而是要通过一下总结下来的规律得出的。  </span><br><span class="hljs-comment">     * 情况1：节点有左子树，此时前任就是左子树的最大值  </span><br><span class="hljs-comment">     * 情况2：节点没有左子树，若离它最近的、自左而来的祖先就是前任  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">predecessor</span><span class="hljs-params">(K key)</span> &#123;  <br>        BSTNode&lt;K, V&gt; p = root;  <br>        BSTNode&lt;K, V&gt; fromLeft = <span class="hljs-literal">null</span>;  <br>  <br>        <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> key.compareTo(p.key);  <br>            <span class="hljs-keyword">if</span> (result &lt; <span class="hljs-number">0</span>) &#123;  <br>                p = p.left;<span class="hljs-comment">//向左走，祖先自右而来  </span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result &gt; <span class="hljs-number">0</span>) &#123;  <br>                p = p.right;<span class="hljs-comment">//向右走，祖先自左而来  </span><br>                fromLeft = p;  <br>            &#125; <span class="hljs-keyword">else</span> &#123;  <br>                <span class="hljs-keyword">break</span>;  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-comment">//没找到节点  </span><br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>        &#125;  <br>        <span class="hljs-comment">//情况1  </span><br>        <span class="hljs-keyword">if</span> (p.left != <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-keyword">return</span> _doMax(p.left);<span class="hljs-comment">//左子树最大值  </span><br>        &#125;  <br>        <span class="hljs-comment">//情况2  </span><br>        <span class="hljs-keyword">return</span> fromLeft != <span class="hljs-literal">null</span> ? fromLeft.value : <span class="hljs-literal">null</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 查找关键字的后驱值（后任，比它大的里面最小的）  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">successor</span><span class="hljs-params">(K key)</span> &#123;  <br>        BSTNode&lt;K, V&gt; p = root;  <br>        BSTNode&lt;K, V&gt; fromRight = <span class="hljs-literal">null</span>;  <br>  <br>        <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> key.compareTo(p.key);  <br>            <span class="hljs-keyword">if</span> (result &lt; <span class="hljs-number">0</span>) &#123;  <br>                p = p.left;<span class="hljs-comment">//向左走，祖先自右而来  </span><br>                fromRight = p;  <br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result &gt; <span class="hljs-number">0</span>) &#123;  <br>                p = p.right;<span class="hljs-comment">//向右走，祖先自左而来  </span><br>            &#125; <span class="hljs-keyword">else</span> &#123;  <br>                <span class="hljs-keyword">break</span>;  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-comment">//没找到节点  </span><br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>        &#125;  <br>        <span class="hljs-comment">//情况1 节点有右子树，此时后任就是右子树的最小值  </span><br>        <span class="hljs-keyword">if</span> (p.right != <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-keyword">return</span> doMin(p.right);<span class="hljs-comment">//右子树最小值  </span><br>        &#125;  <br>        <span class="hljs-comment">//情况2 节点数没有右子树，若离它最近的、自右而来的祖先就是后任  </span><br>        <span class="hljs-keyword">return</span> fromRight != <span class="hljs-literal">null</span> ? fromRight.value : <span class="hljs-literal">null</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 根据关键字删除  </span><br><span class="hljs-comment">     * 核心概念：把被删除的节点的后继节点顶上去  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">delete</span><span class="hljs-params">(K key)</span> &#123;  <br>        BSTNode&lt;K, V&gt; p = root;  <br>        BSTNode&lt;K, V&gt; parent = <span class="hljs-literal">null</span>;  <br>        <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> key.compareTo(p.key);  <br>            <span class="hljs-keyword">if</span> (result &lt; <span class="hljs-number">0</span>) &#123;  <br>                parent = p;  <br>                p = p.left;<span class="hljs-comment">//向左走，祖先自右而来  </span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result &gt; <span class="hljs-number">0</span>) &#123;  <br>                parent = p;  <br>                p = p.right;<span class="hljs-comment">//向右走，祖先自左而来  </span><br>            &#125; <span class="hljs-keyword">else</span> &#123;  <br>                <span class="hljs-keyword">break</span>;  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>        <span class="hljs-comment">//删除操作  </span><br>        <span class="hljs-keyword">if</span> (p.left == <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-comment">//删除情况1(含情况3，走1,2都可以)  </span><br>            shift(parent, p, p.right);  <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p.right == <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-comment">//删除情况2  </span><br>            shift(parent, p, p.left);  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            <span class="hljs-comment">//删除情况4  </span><br>            <span class="hljs-comment">//4.1被删除节点找后继  </span><br>            BSTNode&lt;K, V&gt; s = p.right;  <br>            BSTNode&lt;K, V&gt; sPrent = p;<span class="hljs-comment">//后继父亲  </span><br>            <span class="hljs-keyword">while</span> (s.left != <span class="hljs-literal">null</span>) &#123;  <br>                sPrent = s;  <br>                s = s.left;  <br>            &#125;<span class="hljs-comment">//s就是后继节点  </span><br>            <span class="hljs-comment">//4.2删除节点与后继节点不相邻处理后继的后事  </span><br>            <span class="hljs-keyword">if</span> (sPrent != p) &#123;<span class="hljs-comment">//不相邻  </span><br>                shift(sPrent, s, s.right);<span class="hljs-comment">//不可能有左孩子  </span><br>                s.right = p.right;<span class="hljs-comment">//顶上去的右  </span><br>            &#125;  <br>            <span class="hljs-comment">//4.3后继取代被删除节点  </span><br>            shift(parent, p, s);  <br>            s.left = p.left;<span class="hljs-comment">//顶上去的左  </span><br>        &#125;  <br>        <span class="hljs-keyword">return</span> p.value;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 托孤方法 shift  </span><br><span class="hljs-comment">     *     * <span class="hljs-doctag">@param</span> parent  被删除节点的父节点  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> deleted 被删除到节点  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> child   被顶上去的节点  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shift</span><span class="hljs-params">(BSTNode&lt;K, V&gt; parent, BSTNode&lt;K, V&gt; deleted, BSTNode&lt;K, V&gt; child)</span> &#123;  <br>        <span class="hljs-keyword">if</span> (parent == <span class="hljs-literal">null</span>) &#123;  <br>            root = child;  <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (deleted == parent.left) &#123;  <br>            parent.left = child;  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            parent.right = child;  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>data&amp;algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉搜索树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构和算法之旅（七）- 二叉树</title>
    <link href="/posts/d9d84fdb/"/>
    <url>/posts/d9d84fdb/</url>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p class="note note-light">树中每个节点最多俩个子节点，不同于完全二叉树，不需要每层都满。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309211458897.png"></p><p class="note note-secondary">这种数据结构表示方式有俩种：<br>一种是TreeNode。<br>一种是数组。</p><h3 id="TreeNode"><a href="#TreeNode" class="headerlink" title="TreeNode"></a>TreeNode</h3><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309211459204.png"></p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309211459847.png"></p><h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309211500904.png"></p><p class="note note-secondary">层序遍历即是广度优先遍历，需要配合队列实现。<br>注：<br>以队列来层序遍历时针对TreeNode这种方式表示的二叉树。<br>如果用数组形式实现二叉树，则直接遍历数组即可，自然为层序遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.datastructure.treetraversal;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 递归方式遍历二叉树，前序、中序、后序</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeTraversal</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         *         1</span><br><span class="hljs-comment">         *       /  \</span><br><span class="hljs-comment">         *      2    3</span><br><span class="hljs-comment">         *    /     /\</span><br><span class="hljs-comment">         *   4      5  6</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         */</span><br><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<br>                        <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">4</span>), <span class="hljs-number">2</span>, <span class="hljs-literal">null</span>), <span class="hljs-number">1</span>,<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">5</span>), <span class="hljs-number">3</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">6</span>)<br>                )<br>        );<br><br>        System.out.println(<span class="hljs-string">&quot;前序遍历：&quot;</span>);<br>        preOrder(root);<br>        System.out.println(<span class="hljs-string">&quot;\n中序遍历：&quot;</span>);<br>        inOrder(root);<br>        System.out.println(<span class="hljs-string">&quot;\n后序遍历：&quot;</span>);<br>        postOrder(root);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 前序遍历</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preOrder</span><span class="hljs-params">(TreeNode node)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        System.out.print(node.val + <span class="hljs-string">&quot;\t&quot;</span>);<br>        preOrder(node.left);<br>        preOrder(node.right);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 中序遍历</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inOrder</span><span class="hljs-params">(TreeNode node)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        inOrder(node.left);<br>        System.out.print(node.val + <span class="hljs-string">&quot;\t&quot;</span>);<br>        inOrder(node.right);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 后序遍历</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postOrder</span><span class="hljs-params">(TreeNode node)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        postOrder(node.left);<br>        postOrder(node.right);<br>        System.out.print(node.val + <span class="hljs-string">&quot;\t&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>data&amp;algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
      <tag>广度优先遍历</tag>
      
      <tag>深度优先遍历</tag>
      
      <tag>前序</tag>
      
      <tag>中序</tag>
      
      <tag>后序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构和算法之旅（六）- 堆</title>
    <link href="/posts/88ba86b6/"/>
    <url>/posts/88ba86b6/</url>
    
    <content type="html"><![CDATA[<p class="note note-light">在了解优先级队列中，接触过堆的概念，了解了堆的特性以及如何使用，这里看如何建立一个堆。</p><h2 id="大顶堆"><a href="#大顶堆" class="headerlink" title="大顶堆"></a>大顶堆</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.datastructure;<br><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 大顶堆</span><br><span class="hljs-comment"> * heapify建堆，使用弗洛伊德算符，时间复杂度O(n)</span><br><span class="hljs-comment"> * 1.找到最后一个非叶子节点</span><br><span class="hljs-comment"> * 2.从最后一个非叶子节点开始，依次下沉</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * heapify、down、up这是三个核心方法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MaxHeap</span> &#123;<br>    <span class="hljs-type">int</span>[] array;<br>    <span class="hljs-type">int</span> size;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MaxHeap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array)</span> &#123;<br>        <span class="hljs-built_in">this</span>.array = array;<br>        <span class="hljs-built_in">this</span>.size = array.length;<br>        heapify();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 建堆</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">heapify</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//如何找到最后一个非叶子节点    size/2-1</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> size / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            down(i);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除堆顶元素</span><br><span class="hljs-comment">     * 直接从索引0位置移除效率不高，所以先将它最后一个元素交换，</span><br><span class="hljs-comment">     * 尾部移除，size-1就可以了，但可能导致不满足大顶堆特性，</span><br><span class="hljs-comment">     * 需要做一次下潜</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">poll</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">top</span> <span class="hljs-operator">=</span> array[<span class="hljs-number">0</span>];<br>        swap(<span class="hljs-number">0</span>, size - <span class="hljs-number">1</span>);<br>        size--;<br>        down(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> top;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除指定索引处元素</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">poll</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">deleted</span> <span class="hljs-operator">=</span> array[index];<br>        swap(index, size - <span class="hljs-number">1</span>);<br>        size--;<br>        down(index);<br>        <span class="hljs-keyword">return</span> deleted;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 替换堆顶元素</span><br><span class="hljs-comment">     * 替换后可能不满足大顶堆特性，需要做一次下潜</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">replace</span><span class="hljs-params">(<span class="hljs-type">int</span> replaced)</span> &#123;<br>        array[<span class="hljs-number">0</span>] = replaced;<br>        down(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取堆顶元素</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> array[<span class="hljs-number">0</span>];<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 向堆的尾部添加元素</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(<span class="hljs-type">int</span> offered)</span> &#123;<br>        <span class="hljs-keyword">if</span> (size == array.length) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        up(offered);<br>        size++;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将inserted元素上浮：直至offered小于父元素或到堆顶</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">up</span><span class="hljs-params">(<span class="hljs-type">int</span> offered)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">child</span> <span class="hljs-operator">=</span> size;<br>        <span class="hljs-keyword">while</span> (child &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> (child - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<span class="hljs-comment">//父节点 公式</span><br>            <span class="hljs-keyword">if</span> (array[parent] &gt;= offered)<br>                array[child] = array[parent];<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">break</span>;<br>            child = parent;<br>        &#125;<br>        array[child] = offered;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将parent索引处元素下沉：与俩个孩子较大者交换，直至没孩子或孩子没它大</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">down</span><span class="hljs-params">(<span class="hljs-type">int</span> parent)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> parent * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<span class="hljs-comment">//左孩子 公式</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> left + <span class="hljs-number">1</span>;<span class="hljs-comment">//右孩子 公式</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> parent;<br>        <span class="hljs-keyword">if</span> (left &lt; size &amp;&amp; array[left] &gt; array[max]) max = left;<br>        <span class="hljs-keyword">if</span> (right &lt; size &amp;&amp; array[right] &gt; array[max]) max = right;<br>        <span class="hljs-keyword">if</span> (max != parent) &#123;<span class="hljs-comment">//如果孩子比父亲大，就交换</span><br>            swap(max, parent);<br>            down(max);<span class="hljs-comment">//递归</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 交换俩个索引处元素</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> array[i];<br>        array[i] = array[j];<br>        array[j] = t;<br>    &#125;<br><br><br>    <span class="hljs-comment">//test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] array = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125;;<br>        <span class="hljs-type">MaxHeap</span> <span class="hljs-variable">maxHeap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MaxHeap</span>(array);<br>        System.out.println(Arrays.toString(maxHeap.array));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309211454884.png"></p>]]></content>
    
    
    <categories>
      
      <category>data&amp;algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>堆</tag>
      
      <tag>大顶堆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构和算法之旅（五）- 栈</title>
    <link href="/posts/a110ea6d/"/>
    <url>/posts/a110ea6d/</url>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p class="note note-primary">栈是一种线性数据结构，只能在其一端添加数据和移除数据。习惯来说，这一端称为栈顶，另一端不能操作数据的称为栈底，就如同生活中的一摞书籍。<br>还是老样子，看一下用不同方式实现栈。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*先定义一个Stack接口*/</span><br><span class="hljs-keyword">package</span> org.example.datastructure;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Stack</span>&lt;E&gt; &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 向栈顶压入元素</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 待压入元素</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 压入成功返回true，否则返回false</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">push</span><span class="hljs-params">(E value)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从栈顶弹出元素</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 栈非空返回栈顶元素，否则返回null</span><br><span class="hljs-comment">     */</span><br>    E <span class="hljs-title function_">pop</span><span class="hljs-params">()</span>;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回栈顶元素，但不弹出</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 栈非空返回栈顶元素，否则返回null</span><br><span class="hljs-comment">     */</span><br>    E <span class="hljs-title function_">peek</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断栈是否为空</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 空返回true，否则返回false</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断栈是否已满</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 已满返回true，否则返回false</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="链表实现"><a href="#链表实现" class="headerlink" title="链表实现"></a>链表实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.datastructure;<br><br><span class="hljs-keyword">import</span> java.util.Iterator;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 链表实现栈</span><br><span class="hljs-comment"> * 含哨兵单向链表</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedListStack</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Stack</span>&lt;E&gt;, Iterable&lt;E&gt; &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;E&gt; &#123;<br>        E value;<br>        Node&lt;E&gt; next;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(E value, Node&lt;E&gt; next)</span> &#123;<br>            <span class="hljs-built_in">this</span>.value = value;<br>            <span class="hljs-built_in">this</span>.next = next;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capacity;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 哨兵节点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Node&lt;E&gt; head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedListStack</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * head -&gt; 1 -&gt; null</span><br><span class="hljs-comment">     * head -&gt; 2 -&gt; 1 -&gt; null</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">push</span><span class="hljs-params">(E value)</span> &#123;<br>        <span class="hljs-keyword">if</span> (isFull()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">//        Node&lt;E&gt; added = new Node&lt;&gt;(value, head.next);</span><br><span class="hljs-comment">//        head.next = added;</span><br>        head.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(value, head.next);<br>        size++;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        Node&lt;E&gt; first = head.next;<span class="hljs-comment">//找到第一个节点</span><br>        head.next = first.next;<span class="hljs-comment">//跳过(删除)第一个节点</span><br>        size--;<br>        <span class="hljs-keyword">return</span> first.value;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        Node&lt;E&gt; first = head.next;<span class="hljs-comment">//找到第一个节点</span><br>        <span class="hljs-keyword">return</span> first.value;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//        return head.next == null;</span><br>        <span class="hljs-keyword">return</span> size == <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> size == capacity;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Iterator&lt;E&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt;() &#123;<br>            Node&lt;E&gt; p = head.next;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> p != <span class="hljs-literal">null</span>;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> E <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-type">E</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> p.value;<br>                p = p.next;<br>                <span class="hljs-keyword">return</span> value;<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="数组实现"><a href="#数组实现" class="headerlink" title="数组实现"></a>数组实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.datastructure;<br><br><span class="hljs-keyword">import</span> java.util.Iterator;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayStack</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Stack</span>&lt;E&gt;, Iterable&lt;E&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> E[] array;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> top;<span class="hljs-comment">//栈顶指针</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 底            顶</span><br><span class="hljs-comment">     * 0  1  2  3  4</span><br><span class="hljs-comment">     * 因为右边数组更好操作，与链表是反方向的</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-meta">@SuppressWarnings(&quot;all&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayStack</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.array = (E[]) <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[capacity];<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">push</span><span class="hljs-params">(E value)</span> &#123;<br>        <span class="hljs-keyword">if</span> (isFull()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        array[top++] = value;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> array[--top];<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> array[top - <span class="hljs-number">1</span>];<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> top == <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> top == array.length;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Iterator&lt;E&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt;() &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> top;<span class="hljs-comment">//指向栈顶，从右往左遍历</span><br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> p &gt; <span class="hljs-number">0</span>;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> E <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> array[--p];<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="有效括号"><a href="#有效括号" class="headerlink" title="有效括号"></a>有效括号</h2><p class="note note-secondary">这个很简单：<br>遇到左括号，把要配对的右括号压入栈。<br>遇到右括号，把它与栈顶元素比对。<br>- 若相等，栈顶元素弹出，继续比对下一组。<br>- 若不等，无效括号直接返回false。<br></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309202202374.png"></p><h2 id="逆波兰表达式"><a href="#逆波兰表达式" class="headerlink" title="逆波兰表达式"></a>逆波兰表达式</h2><p class="note note-secondary">1 + 2 ，这是中缀表达式。<br>1 2 +，这是后缀表达式。<br>后缀表达式交给计算机计算非常方便，因为从左向右计算，且不需要考虑优先级，优先级就是从左到右给定的顺序。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309202204129.png"></p><p class="note note-primary">解题思路：<br>遇到数字就放入栈，如果遇到运算符就从栈中取出前俩个元素计算，计算结果再压入栈，栈中剩余的一个元素就是运算结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">evalRPN</span><span class="hljs-params">(String[] tokens)</span> &#123;<br>        LinkedList&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (String t : tokens) &#123;<br>            <span class="hljs-keyword">switch</span> (t) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;+&quot;</span> -&gt; &#123;<br>                    <span class="hljs-type">Integer</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> stack.pop();<br>                    <span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> stack.pop();<br>                    stack.push(a + b);<br>                &#125;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;-&quot;</span> -&gt; &#123;<br>                    <span class="hljs-type">Integer</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> stack.pop();<br>                    <span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> stack.pop();<br>                    stack.push(a - b);<br>                &#125;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;*&quot;</span> -&gt; &#123;<br>                    <span class="hljs-type">Integer</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> stack.pop();<br>                    <span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> stack.pop();<br>                    stack.push(a * b);<br>                &#125;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/&quot;</span> -&gt; &#123;<br>                    <span class="hljs-type">Integer</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> stack.pop();<br>                    <span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> stack.pop();<br>                    stack.push(a / b);<br>                &#125;<br>                <span class="hljs-keyword">default</span> -&gt; &#123;<span class="hljs-comment">//数字</span><br>                    stack.push(Integer.parseInt(t));<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stack.pop();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>data&amp;algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
      <tag>有效括号</tag>
      
      <tag>逆波兰表达式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构和算法之旅（四）- 队列</title>
    <link href="/posts/18ca4eee/"/>
    <url>/posts/18ca4eee/</url>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p class="note note-primary">计算机科学中，queue是以顺序的方式维护一组数据集合，在一端添加数据，从另一个端移除数据。习惯来说，添加的一端称为尾，移除的一端称为头，就如同生活中排队购买商品。</p><h2 id="链表实现队列"><a href="#链表实现队列" class="headerlink" title="链表实现队列"></a>链表实现队列</h2><p class="note note-secondary">下面以单向环形含哨兵链表方式来实现队列。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309202026177.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//首先定义队列的接口</span><br><span class="hljs-keyword">package</span> org.example.datastructure;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 队列</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Queue</span>&lt;E&gt; &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 向队列尾部添加一个元素</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> val 待插入值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 插入成功返回true，否则返回false</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E val)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从队列头部取出一个元素，并移除</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 如果队列非空，返回队列头部元素，否则返回null</span><br><span class="hljs-comment">     */</span><br>    E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从队列头部取出一个元素，但不移除</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 如果队列非空，返回队列头部元素，否则返回null</span><br><span class="hljs-comment">     */</span><br>    E <span class="hljs-title function_">peek</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断队列是否为空</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 空返回true，否则返回false</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span>;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断队列是否已满</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 已满返回true，否则返回false</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.datastructure;<br><br><span class="hljs-keyword">import</span> java.util.Iterator;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 基于单向环形链表实现的队列</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * 队列只需要操作头，尾部不需要操作，所以只需要一个指针即可</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &lt;E&gt;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedListQueue</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Queue</span>&lt;E&gt;, Iterable&lt;E&gt; &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 节点类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;E&gt; &#123;<br>        E value;<br>        Node&lt;E&gt; next;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(E value, Node&lt;E&gt; next)</span> &#123;<br>            <span class="hljs-built_in">this</span>.value = value;<br>            <span class="hljs-built_in">this</span>.next = next;<br>        &#125;<br>    &#125;<br><br>    Node&lt;E&gt; head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>    Node&lt;E&gt; tail = head;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<span class="hljs-comment">// 节点数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">capacity</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<span class="hljs-comment">// 队列容量</span><br><br>    &#123;<br>    <span class="hljs-comment">//构成环</span><br>        tail.next = head;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedListQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedListQueue</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E val)</span> &#123;<br>        <span class="hljs-keyword">if</span> (isFull()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        Node&lt;E&gt; added = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(val, head);<br>        tail.next = added;<br>        tail = added;<span class="hljs-comment">//让新节点作为新的tail</span><br>        size++;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        Node&lt;E&gt; first = head.next;<br>        head.next = first.next;<br>        <span class="hljs-keyword">if</span> (first == tail) tail = head;<br>        size--;<br>        <span class="hljs-keyword">return</span> first.value;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> head.next.value;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> head == tail;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> size == capacity;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Iterator&lt;E&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt;() &#123;<br>            Node&lt;E&gt; p = head.next;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> p != head;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> E <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-type">E</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> p.value;<br>                p = p.next;<br>                <span class="hljs-keyword">return</span> value;<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="环形数组实现队列"><a href="#环形数组实现队列" class="headerlink" title="环形数组实现队列"></a>环形数组实现队列</h2><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309202148425.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309202148648.png"></p><p class="note note-secondary">判断头指针和尾指针是否指向同一个就是判空。<br>当尾指针+1等于头指针就是判断满，(tail+1)%5 == head。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.datastructure;<br><br><span class="hljs-keyword">import</span> java.util.Iterator;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayQueue1</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Queue</span>&lt;E&gt;, Iterable&lt;E&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> E[] array;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> head;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> tail;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capacity;<br><br>    <span class="hljs-meta">@SuppressWarnings(&quot;all&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayQueue1</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        array = (E[]) <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-built_in">this</span>.capacity + <span class="hljs-number">1</span>];<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E val)</span> &#123;<br>        <span class="hljs-keyword">if</span> (isFull()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        array[tail] = val;<br>        tail = (tail + <span class="hljs-number">1</span>) % array.length;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">E</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> array[head];<br>        head = (head + <span class="hljs-number">1</span>) % array.length;<br>        <span class="hljs-keyword">return</span> val;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> array[head];<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> head == tail;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> (tail + <span class="hljs-number">1</span>) % array.length == head;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Iterator&lt;E&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt;() &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> head;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> p != tail;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> E <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-type">E</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> array[p];<br>                p = (p + <span class="hljs-number">1</span>) % array.length;<br>                <span class="hljs-keyword">return</span> e;<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h2><p class="note note-primary">双端队列特点：俩端都可以添加、删除</p><h3 id="基于双向环形链表实现"><a href="#基于双向环形链表实现" class="headerlink" title="基于双向环形链表实现"></a>基于双向环形链表实现</h3><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309210856606.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.datastructure;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 双端队列</span><br><span class="hljs-comment"> * 两端都可以操作添加和删除</span><br><span class="hljs-comment"> * queue 普通队列</span><br><span class="hljs-comment"> * deque 双端队列   double-ended queue</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Deque</span>&lt;E&gt; &#123;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 向头部添加元素</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> e 待添加元素</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 添加成功返回true</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">offerFirst</span><span class="hljs-params">(E e)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 向尾部添加元素</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> e 待添加元素</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 添加成功返回true</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">offerLast</span><span class="hljs-params">(E e)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从队列头部删除元素</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 头部元素</span><br><span class="hljs-comment">     */</span><br>    E <span class="hljs-title function_">pollFirst</span><span class="hljs-params">()</span>;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从尾部获取元素并删除</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 尾部元素</span><br><span class="hljs-comment">     */</span><br>    E <span class="hljs-title function_">pollLast</span><span class="hljs-params">()</span>;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从头部获取元素但不删除</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 头部元素</span><br><span class="hljs-comment">     */</span><br>    E <span class="hljs-title function_">peekFirst</span><span class="hljs-params">()</span>;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从尾部获取元素但不删除</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 尾部元素</span><br><span class="hljs-comment">     */</span><br>    E <span class="hljs-title function_">peekLast</span><span class="hljs-params">()</span>;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 队列是否为空</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 空返回true, 否则返回false</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 队列是否已满</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 满返回true, 否则返回false</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.datastructure;<br><br><span class="hljs-keyword">import</span> java.util.Iterator;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 基于双向环形链表实现的双端队列</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * 注：双向和双端是两个概念，</span><br><span class="hljs-comment"> * 双向是指链表节点有两个指针，一个指向前一个节点，一个指向后一个节点；</span><br><span class="hljs-comment"> * 双端是指队列两端都可以操作添加和删除。</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * 为什么要用双向链表？</span><br><span class="hljs-comment"> * 因为双端队列需要操作尾端，所以需要尾指针，而单向链表只有头指针，所以需要双向链表。</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * 为什么要用环形链表？</span><br><span class="hljs-comment"> * 因为环形链表可以用一个哨兵，即充当头指针又充当尾指针，这样就可以省去一个指针。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedListDeque</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Deque</span>&lt;E&gt;, Iterable&lt;E&gt; &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;E&gt; &#123;<br>        Node&lt;E&gt; prev;<br>        E value;<br>        Node&lt;E&gt; next;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(Node&lt;E&gt; prev, E value, Node&lt;E&gt; next)</span> &#123;<br>            <span class="hljs-built_in">this</span>.prev = prev;<br>            <span class="hljs-built_in">this</span>.value = value;<br>            <span class="hljs-built_in">this</span>.next = next;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">capacity</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>    <span class="hljs-type">int</span> size;<br>    Node&lt;E&gt; sentinel = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<span class="hljs-comment">//哨兵</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedListDeque</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>        <span class="hljs-comment">//初始化哨兵</span><br>        sentinel.prev = sentinel;<br>        sentinel.next = sentinel;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * a added b</span><br><span class="hljs-comment">     * 向头部添加</span><br><span class="hljs-comment">     * a就是哨兵，b就是哨兵的next</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offerFirst</span><span class="hljs-params">(E e)</span> &#123;<br>        <span class="hljs-keyword">if</span> (isFull()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        Node&lt;E&gt; a = sentinel;<br>        Node&lt;E&gt; b = sentinel.next;<br>        Node&lt;E&gt; added = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(a, e, b);<br>        a.next = added;<br>        b.prev = added;<br>        size++;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * a added b</span><br><span class="hljs-comment">     * 向尾部添加</span><br><span class="hljs-comment">     * b就是哨兵，a就是哨兵的prev</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offerLast</span><span class="hljs-params">(E e)</span> &#123;<br>        <span class="hljs-keyword">if</span> (isFull()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        Node&lt;E&gt; a = sentinel.prev;<br>        Node&lt;E&gt; b = sentinel;<br>        Node&lt;E&gt; added = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(a, e, b);<br>        a.next = added;<br>        b.prev = added;<br>        size++;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * a removed b</span><br><span class="hljs-comment">     * 移除头部</span><br><span class="hljs-comment">     * a就是哨兵，b就是哨兵的next</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">pollFirst</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        Node&lt;E&gt; a = sentinel;<br>        Node&lt;E&gt; removed = sentinel.next;<br>        Node&lt;E&gt; b = removed.next;<br>        a.next = b;<br>        b.prev = a;<br>        size--;<br>        <span class="hljs-keyword">return</span> removed.value;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * a removed b</span><br><span class="hljs-comment">     * 移除尾部</span><br><span class="hljs-comment">     * b就是哨兵，a就是哨兵的prev</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">pollLast</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        Node&lt;E&gt; b = sentinel;<br>        Node&lt;E&gt; removed = sentinel.prev;<br>        Node&lt;E&gt; a = removed.prev;<br>        a.next = b;<br>        b.prev = a;<br>        size--;<br>        <span class="hljs-keyword">return</span> removed.value;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">peekFirst</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> sentinel.next.value;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">peekLast</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> sentinel.prev.value;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> size == <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> size == capacity;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Iterator&lt;E&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt;() &#123;<br>            Node&lt;E&gt; p = sentinel.next;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> p != sentinel;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> E <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-type">E</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> p.value;<br>                p = p.next;<br>                <span class="hljs-keyword">return</span> value;<br>            &#125;<br>        &#125;;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="基于数组实现"><a href="#基于数组实现" class="headerlink" title="基于数组实现"></a>基于数组实现</h3><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309210857074.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.datastructure;<br><br><span class="hljs-keyword">import</span> java.util.Iterator;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 基于循环数组实现的双端队列</span><br><span class="hljs-comment"> * 循环数组动的是头尾指针，不动的是数组元素</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * tail 停下来的位置不存储，会浪费一个位置</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * h - head</span><br><span class="hljs-comment"> * tail - tail</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * h</span><br><span class="hljs-comment"> * t</span><br><span class="hljs-comment"> * 0  1  2  3</span><br><span class="hljs-comment"> * a  b     c</span><br><span class="hljs-comment"> * offerLast(a)     先添加元素 tail++</span><br><span class="hljs-comment"> * offerLast(b)</span><br><span class="hljs-comment"> * offerFirst(c)    先head-- 再添加元素</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * pollFirst()      先取元素 head++</span><br><span class="hljs-comment"> * pollLast()       先tail-- 再取元素</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * head==tail 空</span><br><span class="hljs-comment"> * head~tail == 数组长度-1 满</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayDeque1</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Deque</span>&lt;E&gt;, Iterable&lt;E&gt; &#123;<br><br>    E[] array;<br>    <span class="hljs-type">int</span> head;<br>    <span class="hljs-type">int</span> tail;<br><br>    <span class="hljs-meta">@SuppressWarnings(&quot;all&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayDeque1</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        array = (E[]) <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[capacity + <span class="hljs-number">1</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">inc</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> length)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &gt;= length)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dec</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> length)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i - <span class="hljs-number">1</span> &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> i - <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offerFirst</span><span class="hljs-params">(E e)</span> &#123;<br>        <span class="hljs-keyword">if</span> (isFull()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        head = dec(head, array.length);<br>        array[head] = e;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offerLast</span><span class="hljs-params">(E e)</span> &#123;<br>        <span class="hljs-keyword">if</span> (isFull()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        array[tail] = e;<br>        tail = inc(tail, array.length);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">pollFirst</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">E</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> array[head];<br>        array[head] = <span class="hljs-literal">null</span>;<span class="hljs-comment">//help gc</span><br>        head = inc(head, array.length);<br>        <span class="hljs-keyword">return</span> e;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">pollLast</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        tail = dec(tail, array.length);<br>        <span class="hljs-type">E</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> array[tail];<br>        array[tail] = <span class="hljs-literal">null</span>;<span class="hljs-comment">//help gc</span><br>        <span class="hljs-keyword">return</span> e;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">peekFirst</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> array[head];<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">peekLast</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> array[dec(tail, array.length)];<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> head == tail;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (tail &gt; head) &#123;<br>            <span class="hljs-keyword">return</span> tail - head == array.length - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tail &lt; head) &#123;<br>            <span class="hljs-keyword">return</span> head - tail == <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Iterator&lt;E&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt;() &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> head;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> p != tail;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> E <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-type">E</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> array[p];<br>                p = inc(p, array.length);<br>                <span class="hljs-keyword">return</span> e;<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h2><p class="note note-primary">优先级队列特点：一端进，另一端出，但出的时候按照优先级出！</p><h3 id="基于无序数组实现"><a href="#基于无序数组实现" class="headerlink" title="基于无序数组实现"></a>基于无序数组实现</h3><p class="note note-success">无序数组实现的优势：<br>入队就直接加入对尾。<br>出队就遍历找到最大值，并删除，然后把后续的往前顺延。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> priorityqueue;  <br>  <br><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * 队列接口</span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Queue</span>&lt;E&gt; &#123;  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 向队列尾部添加一个元素  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> val 待插入值  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 插入成功返回true，否则返回false  </span><br><span class="hljs-comment">     */</span>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E val)</span>;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 从队列头部取出一个元素，并移除  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 如果队列非空，返回队列头部元素，否则返回null  </span><br><span class="hljs-comment">     */</span>    E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span>;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 从队列头部取出一个元素，但不移除  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 如果队列非空，返回队列头部元素，否则返回null  </span><br><span class="hljs-comment">     */</span>    E <span class="hljs-title function_">peek</span><span class="hljs-params">()</span>;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 判断队列是否为空  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 空返回true，否则返回false  </span><br><span class="hljs-comment">     */</span>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span>;  <br>  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 判断队列是否已满  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 已满返回true，否则返回false  </span><br><span class="hljs-comment">     */</span>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> priorityqueue;  <br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 优先级接口</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Priority</span> &#123;  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 返回对象的优先级，约定数字越大，优先级越高  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-type">int</span> <span class="hljs-title function_">priority</span><span class="hljs-params">()</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> priorityqueue;  <br>  <br><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * 基于无序数组实现  </span><br><span class="hljs-comment"> * 入队：把元素加到数组末尾  </span><br><span class="hljs-comment"> * 出队：找到最大优先级元素，删除，相当于进行了一次选择排序  </span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PriorityQueue</span>&lt;E <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Priority</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Queue</span>&lt;E&gt; &#123;  <br>  <br>    Priority[] array;  <br>    <span class="hljs-type">int</span> size;  <br>  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PriorityQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;  <br>        array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Priority</span>[capacity];  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//O(1)  </span><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e)</span> &#123;  <br>        <span class="hljs-keyword">if</span> (isFull()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>        array[size++] = e;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//返回优先级最高的索引值  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">selectMax</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;  <br>            <span class="hljs-keyword">if</span> (array[i].priority() &gt; array[max].priority()) &#123;  <br>                max = i;  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> max;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;  <br>        <span class="hljs-keyword">if</span> (index &lt; size - <span class="hljs-number">1</span>) &#123;  <br>            <span class="hljs-comment">//移动  </span><br>            System.arraycopy(array, index + <span class="hljs-number">1</span>, array, index, size - <span class="hljs-number">1</span> - index);  <br>        &#125;  <br>        array[--size]=<span class="hljs-literal">null</span>;<span class="hljs-comment">//help GC </span><br>    &#125;  <br>  <br>    <span class="hljs-comment">//O(n)  </span><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">if</span> (isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> selectMax();  <br>        <span class="hljs-type">E</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> (E) array[max];  <br>        remove(max);  <br>        <span class="hljs-keyword">return</span> e;  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">if</span> (isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> selectMax();  <br>        <span class="hljs-keyword">return</span> (E) array[max];  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> size == <span class="hljs-number">0</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> size == array.length;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="基于有序数组实现"><a href="#基于有序数组实现" class="headerlink" title="基于有序数组实现"></a>基于有序数组实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> priorityqueue;  <br>  <br><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * 基于有序数组实现  </span><br><span class="hljs-comment"> * 优先级最高的在队尾，优点是出队操作变的简单，直接size--就行。  </span><br><span class="hljs-comment"> * 缺点是，入队操作需要做一次排序，插入到正确位置。相当于一次插入排序。  </span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PriorityQueue2</span>&lt;E <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Priority</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Queue</span>&lt;E&gt; &#123;  <br>  <br>    Priority[] array;  <br>    <span class="hljs-type">int</span> size;  <br>  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PriorityQueue2</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;  <br>        array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Priority</span>[capacity];  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//O(n)  </span><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e)</span> &#123;  <br>        <span class="hljs-keyword">if</span> (isFull()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br><span class="hljs-comment">//        array[size++] = e;  </span><br>        insert(e);  <br>        size++;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 插入排序  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(E e)</span> &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> size - <span class="hljs-number">1</span>;  <br>        <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; array[i].priority() &gt; e.priority()) &#123;  <br>            array[i + <span class="hljs-number">1</span>] = array[i];  <br>            i--;  <br>        &#125;  <br>        array[i + <span class="hljs-number">1</span>] = e;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//O(1)  </span><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">if</span> (isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br><span class="hljs-comment">//        int max = selectMax();  </span><br><span class="hljs-comment">//        E e = (E) array[max];  </span><br><span class="hljs-comment">//        remove(max);  </span><br>        <span class="hljs-type">E</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> (E) array[size - <span class="hljs-number">1</span>];  <br>        array[--size] = <span class="hljs-literal">null</span>;<span class="hljs-comment">//help GC  </span><br>        <span class="hljs-keyword">return</span> e;  <br>    &#125;  <br><span class="hljs-comment">//O(1)  </span><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">if</span> (isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br><span class="hljs-comment">//        int max = selectMax();  </span><br><span class="hljs-comment">//        return (E) array[max];  </span><br>        <span class="hljs-keyword">return</span> (E) array[size - <span class="hljs-number">1</span>];  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> size == <span class="hljs-number">0</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> size == array.length;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-primary">基于无序和基于有序数组实现俩种的差别在于：<br>无序：入队O(1)，出队O(n)<br>有序：入队O(n)，出队O(1)<br><br>BUT，这俩种都不是最优的实现方式，接下来看看更优解。</p><h3 id="基于堆实现"><a href="#基于堆实现" class="headerlink" title="基于堆实现"></a>基于堆实现</h3><blockquote><p>堆是一种基于树的数据结构，通常用完全二叉树实现。堆的特性如下：</p><ul><li>在大顶堆中，任意节点C与它的父节点P符合P.value &gt;&#x3D; C.value。</li><li>在小顶堆中，任意节点C与它的父节点P符合P.vlaue &lt;&#x3D; C.value。</li><li>最顶层节点(没有父亲)称之为root根节点。</li></ul></blockquote><blockquote><p>二叉树，简单理解就是一个节点最多有俩个子节点。</p></blockquote><blockquote><p>完全二叉树，就是说树的每一层除了最后一层都是填满的（都是俩个子节点）。<br>另外，向完全二叉树加入节点时，必须从左开始添加。</p></blockquote><p class="note note-info">它是非线性的数据结构，但是存储的时候可以使用线性的数组结构存储。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309210937016.png"></p><p class="note note-primary">这种数据结构具备一些特征，前辈总结了一些规律公式，可以在已知父节点的时候快速找到子节点，或者已知子节点的时候快速找到父节点。<br>堆存在数组中有俩种方式，一种是从索引0直接存根，另一种是索引0空着从1开始存根节点。<br>- 如果从索引0开始存储节点数据<br>    1. 节点 i 的父节点为 (i-1)/2，当i>0时。<br>    2. 节点 i 的左子节点为 2i+1 ，右子节点为 2i+2，当然它们得小于size。<br>- 如果从索引1开始存储节点数据<br>    1. 节点i的父节点为 i/2 ，当 i>1 时。<br>    2. 节点 i 的左子节点为 2i ，右子节点为 2i+1 ，同样得小于size。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309210948549.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> priorityqueue;  <br>  <br><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * 基于大顶堆实现  </span><br><span class="hljs-comment"> * &lt;p&gt;  </span><br><span class="hljs-comment"> * 入队  </span><br><span class="hljs-comment"> * 1.入堆新元素，加入到数组末尾  </span><br><span class="hljs-comment"> * 2.不断比较新元素与它父节点优先级  </span><br><span class="hljs-comment"> * （上浮）  </span><br><span class="hljs-comment"> * - 如果父节点优先级低，则向下移动，并找到下一个parent  </span><br><span class="hljs-comment"> * - 直至父节点优先级更高或child==0为止。  </span><br><span class="hljs-comment"> * &lt;p&gt;  </span><br><span class="hljs-comment"> * 出队  </span><br><span class="hljs-comment"> * 1.交换堆顶和尾部元素，让尾部出队  </span><br><span class="hljs-comment"> * 2.（下潜）  </span><br><span class="hljs-comment"> * - 从堆顶开始，将父元素与俩个孩子较大者交换  </span><br><span class="hljs-comment"> * - 直到父元素大于俩个孩子，或者没有孩子为止。  </span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PriorityQueue3</span>&lt;E <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Priority</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Queue</span>&lt;E&gt; &#123;  <br>  <br>    Priority[] array;  <br>    <span class="hljs-type">int</span> size;  <br>  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PriorityQueue3</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;  <br>        array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Priority</span>[capacity];  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//O(logn)  </span><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E offered)</span> &#123;  <br>        <span class="hljs-keyword">if</span> (isFull()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">child</span> <span class="hljs-operator">=</span> size++;<span class="hljs-comment">//确定索引，先不同填充值，可能要调整堆  </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> (child - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<span class="hljs-comment">//找到父节点  </span><br>        <span class="hljs-keyword">while</span> (child &gt; <span class="hljs-number">0</span> &amp;&amp; offered.priority() &gt; array[parent].priority()) &#123;  <br>            array[child] = array[parent];<span class="hljs-comment">//下移  </span><br>            child = parent;  <br>            parent = (child - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;  <br>        &#125;  <br>        <span class="hljs-comment">//循环结束找到目标待插入节点  </span><br>        array[child] = offered;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 交换  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;  <br>        <span class="hljs-type">Priority</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> array[i];  <br>        array[i] = array[j];  <br>        array[j] = t;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * O(logn)     * 下潜  </span><br><span class="hljs-comment">     * 因为可以通过公式，已知父节点可以得到子节点，所以参数一个即可  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">down</span><span class="hljs-params">(<span class="hljs-type">int</span> parent)</span> &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> * parent + <span class="hljs-number">1</span>;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> left + <span class="hljs-number">1</span>;<span class="hljs-comment">//等价于 2*parent+2  </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> parent;<span class="hljs-comment">//假设父元素优先级更高  </span><br>        <span class="hljs-keyword">if</span> (left &lt; size &amp;&amp; array[left].priority() &gt; array[max].priority()) &#123;<span class="hljs-comment">//left&lt;size因为通过公式得到的不一定存在  </span><br>            max = left;  <br>        &#125;  <br>        <span class="hljs-keyword">if</span> (right &lt; size &amp;&amp; array[right].priority() &gt; array[max].priority()) &#123;  <br>            max = right;  <br>        &#125;  <br>        <span class="hljs-keyword">if</span> (max != parent) &#123;  <br>            <span class="hljs-comment">//说明被更新了  </span><br>            swap(max, parent);  <br>            <span class="hljs-comment">//递归调用  </span><br>            down(max);  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">if</span> (isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>        swap(<span class="hljs-number">0</span>, size - <span class="hljs-number">1</span>);<span class="hljs-comment">//交换堆顶和尾元素  </span><br>        size--;<span class="hljs-comment">//移除数组尾部元素,就是把size减1即可  </span><br>        <span class="hljs-type">Priority</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> array[size];  <br>        array[size] = <span class="hljs-literal">null</span>;<span class="hljs-comment">//help GC  </span><br>        <span class="hljs-comment">//下潜  </span><br>        down(<span class="hljs-number">0</span>);  <br>        <span class="hljs-keyword">return</span> (E) e;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//O(1)  </span><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">if</span> (isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>        <span class="hljs-keyword">return</span> (E) array[<span class="hljs-number">0</span>];  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> size == <span class="hljs-number">0</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> size == array.length;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-primary">三种实现区别<br>无序：入队O(1)，出队O(n)<br>有序：入队O(n)，出队O(1)<br>堆：入队O(logn)，出队O(logn)  推荐<br></p><h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><blockquote><p>目前队列存在的问题<br>1.很多场景要求分离生产者、消费者俩个角色，它们由不同的线程来担当，而之前的实现并没有考虑线程安全问题。<br>2.队列为空，那么在之前的实现里会返回null，如果就是硬要拿到一个元素呢？只能不能循环尝试。<br>3.队列为满，那么在之前的实现里会返回false，如果就是硬要塞入一个元素呢？只能不断循环尝试。</p></blockquote><h3 id="单锁实现"><a href="#单锁实现" class="headerlink" title="单锁实现"></a>单锁实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> blockqueue;  <br>  <br><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * 目前队列存在的问题  </span><br><span class="hljs-comment"> * &gt; 1.很多场景要求分离生产者、消费者俩个角色，它们由不同的线程来担当，而之前的实现并没有考虑线程安全问题。  </span><br><span class="hljs-comment"> * &gt; 2.队列为空，那么在之前的实现里会返回null，如果就是硬要拿到一个元素呢？只能不能循环尝试。  </span><br><span class="hljs-comment"> * &gt; 3.队列为满，那么在之前的实现里会返回false，如果就是硬要塞入一个元素呢？只能不断循环尝试。  </span><br><span class="hljs-comment"> * &lt;p&gt;  </span><br><span class="hljs-comment"> * 解决方法：  </span><br><span class="hljs-comment"> * 1.用锁保证线程安全  </span><br><span class="hljs-comment"> * 2.用条件变量让poll或offer线程进入等待状态  </span><br><span class="hljs-comment"> */</span>  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BlockQueue</span>&lt;E&gt; &#123;<span class="hljs-comment">//阻塞队列  </span><br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 入队不再需要返回值，因为会进入阻塞状态  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e)</span> <span class="hljs-keyword">throws</span> InterruptedException;  <br>  <br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e, <span class="hljs-type">long</span> timeout)</span> <span class="hljs-keyword">throws</span> InterruptedException;  <br>  <br>    E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException;  <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> blockqueue;  <br>  <br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;  <br><span class="hljs-keyword">import</span> java.util.concurrent.locks.Condition;  <br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;  <br>  <br><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * 单锁实现  </span><br><span class="hljs-comment"> *  </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &lt;E&gt;  </span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlockQueue1</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BlockQueue</span>&lt;E&gt; &#123;  <br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> E[] array;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> head;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> tail;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;  <br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">headWaits</span> <span class="hljs-operator">=</span> lock.newCondition();<span class="hljs-comment">//配合poll方法使用 因为队列先入先出，出队的时候就用head表示  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">tailWaits</span> <span class="hljs-operator">=</span> lock.newCondition();<span class="hljs-comment">//配合offer方法使用 入队  </span><br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> size == <span class="hljs-number">0</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> size == array.length;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BlockQueue1</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;  <br>        array = (E[]) <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[capacity];  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>        lock.lockInterruptibly();  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            <span class="hljs-keyword">while</span> (isFull()) &#123;  <br>                <span class="hljs-comment">//不能用if，防止虚假唤醒  </span><br>                tailWaits.await();<span class="hljs-comment">//进入阻塞状态  </span><br>            &#125;  <br>            <span class="hljs-comment">//不满，可以添加  </span><br>            array[tail] = e;  <br>            <span class="hljs-keyword">if</span> (++tail == array.length) &#123;  <br>                tail = <span class="hljs-number">0</span>;  <br>            &#125;  <br>            size++;  <br>            <span class="hljs-comment">//此时，poll可能在等待队列非空要取数据，所以要去唤醒  </span><br>            headWaits.signal();  <br>        &#125; <span class="hljs-keyword">finally</span> &#123;  <br>            lock.unlock();  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 可以设置等待时间，上面的offer会一直等  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e, <span class="hljs-type">long</span> timeout)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>        lock.lockInterruptibly();  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            <span class="hljs-type">long</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> TimeUnit.MILLISECONDS.toNanos(timeout);<span class="hljs-comment">//传过来毫秒转换一下  </span><br>            <span class="hljs-keyword">while</span> (isFull()) &#123;  <br>                <span class="hljs-keyword">if</span> (t &lt;= <span class="hljs-number">0</span>) &#123;  <br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>                &#125;  <br>                t = tailWaits.awaitNanos(t);<span class="hljs-comment">//最多等待多少纳秒 1s 4s 返回值代表剩余时间  </span><br>            &#125;  <br>            <span class="hljs-comment">//不满，可以添加  </span><br>            array[tail] = e;  <br>            <span class="hljs-keyword">if</span> (++tail == array.length) &#123;  <br>                tail = <span class="hljs-number">0</span>;  <br>            &#125;  <br>            size++;  <br>            <span class="hljs-comment">//此时，poll可能在等待队列非空要取数据，所以要去唤醒  </span><br>            headWaits.signal();  <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>        &#125; <span class="hljs-keyword">finally</span> &#123;  <br>            lock.unlock();  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>        lock.lockInterruptibly();  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            <span class="hljs-keyword">while</span> (isEmpty()) &#123;  <br>                headWaits.await();  <br>            &#125;  <br>            <span class="hljs-type">E</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> array[head];  <br>            array[head] = <span class="hljs-literal">null</span>;<span class="hljs-comment">//help GC  </span><br>            <span class="hljs-keyword">if</span> (++head == array.length) &#123;  <br>                head = <span class="hljs-number">0</span>;  <br>            &#125;  <br>            size--;  <br>            <span class="hljs-comment">//此时，offer可能在等待队列不满要取数据，所以要去唤醒  </span><br>            tailWaits.signal();  <br>            <span class="hljs-keyword">return</span> e;  <br>        &#125; <span class="hljs-keyword">finally</span> &#123;  <br>            lock.unlock();  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="双锁实现"><a href="#双锁实现" class="headerlink" title="双锁实现"></a>双锁实现</h3><blockquote><p>上面单锁实现加锁是为了多线程下产生指令交错，结果达不到预期，所以加了一一把锁来实现。<br><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309211132224.png"><br>加锁来保证多行代码的原子性，保证左边执行完，右边再执行。这是为什么加锁。</p><p>但是加锁后，会产生新的问题，offer和poll都需要加锁，而且用到同一把锁。<br><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309211134026.png"><br>offer和poll线程是互相影响的，offer在加锁状态下，poll加不上锁会处于阻塞状态，得等offer执行完了解锁，poll才能获得锁。读写不能同时进行！这样是不合理的。一个操作头，一个操作尾，按理来讲应该互不干扰。所以可以用双锁来实现。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> blockqueue;  <br>  <br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;  <br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;  <br><span class="hljs-keyword">import</span> java.util.concurrent.locks.Condition;  <br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;  <br>  <br><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * 双锁实现  </span><br><span class="hljs-comment"> *  </span><br><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlockQueue2</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BlockQueue</span>&lt;E&gt; &#123;  <br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> E[] array;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> head;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> tail;  <br>    <span class="hljs-comment">//    private int size;  </span><br>    <span class="hljs-keyword">private</span> AtomicInteger size;  <br>  <br>    <span class="hljs-comment">//    private ReentrantLock lock = new ReentrantLock();  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">tailLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<span class="hljs-comment">//给offer用  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">tailWaits</span> <span class="hljs-operator">=</span> tailLock.newCondition();  <br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">headLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<span class="hljs-comment">//给poll方法用  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">headWaits</span> <span class="hljs-operator">=</span> headLock.newCondition();  <br>  <br><span class="hljs-comment">//    private Condition headWaits = lock.newCondition();//配合poll方法使用 因为队列先入先出，出队的时候就用head表示  </span><br><span class="hljs-comment">//    private Condition tailWaits = lock.newCondition();//配合offer方法使用 入队  </span><br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> size.get() == <span class="hljs-number">0</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> size.get() == array.length;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BlockQueue2</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;  <br>        array = (E[]) <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[capacity];  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>        <span class="hljs-type">int</span> c;<span class="hljs-comment">//添加前元素个数 c=0的时候进行加锁和唤醒操作  </span><br>        tailLock.lockInterruptibly();  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            <span class="hljs-keyword">while</span> (isFull()) &#123;  <br>                <span class="hljs-comment">//不能用if，防止虚假唤醒  </span><br>                tailWaits.await();<span class="hljs-comment">//进入阻塞状态  </span><br>            &#125;  <br>            <span class="hljs-comment">//不满，可以添加  </span><br>            array[tail] = e;  <br>            <span class="hljs-keyword">if</span> (++tail == array.length) &#123;  <br>                tail = <span class="hljs-number">0</span>;  <br>            &#125;  <br>            <span class="hljs-comment">//修改size  </span><br>            <span class="hljs-comment">/*             * 1.读取成员变量size的值  </span><br><span class="hljs-comment">             * 2.自增  </span><br><span class="hljs-comment">             * 3.结果写会成员变量size  </span><br><span class="hljs-comment">             */</span>            c = size.getAndIncrement();<span class="hljs-comment">//size++ 但能保证原子性  </span><br>            <span class="hljs-keyword">if</span> (c + <span class="hljs-number">1</span> &lt; array.length) &#123;  <br>                tailWaits.signal();  <br>            &#125;  <br>  <br>        &#125; <span class="hljs-keyword">finally</span> &#123;  <br>            tailLock.unlock();  <br>        &#125;  <br>        <span class="hljs-keyword">if</span> (c &gt; <span class="hljs-number">0</span>) &#123;  <br>            <span class="hljs-comment">//解决死锁的方法很简单，不要写成嵌套的方式即可  </span><br>            headLock.lock();  <br>            <span class="hljs-keyword">try</span> &#123;  <br>                headWaits.signal();<span class="hljs-comment">//signal和await必须搭配对应的锁  </span><br>            &#125; <span class="hljs-keyword">finally</span> &#123;  <br>                headLock.unlock();  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 可以设置等待时间，上面的offer会一直等  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e, <span class="hljs-type">long</span> timeout)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>        <span class="hljs-type">int</span> c;<span class="hljs-comment">//添加前元素个数 c=0的时候进行加锁和唤醒操作  </span><br>        tailLock.lockInterruptibly();  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            <span class="hljs-type">long</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> TimeUnit.MILLISECONDS.toNanos(timeout);<span class="hljs-comment">//传过来毫秒转换一下  </span><br>            <span class="hljs-keyword">while</span> (isFull()) &#123;  <br>                <span class="hljs-keyword">if</span> (t &lt;= <span class="hljs-number">0</span>) &#123;  <br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>                &#125;  <br>                t = tailWaits.awaitNanos(t);<span class="hljs-comment">//最多等待多少纳秒 1s 4s 返回值代表剩余时间  </span><br>            &#125;  <br>            <span class="hljs-comment">//不满，可以添加  </span><br>            array[tail] = e;  <br>            <span class="hljs-keyword">if</span> (++tail == array.length) &#123;  <br>                tail = <span class="hljs-number">0</span>;  <br>            &#125;  <br>            <span class="hljs-comment">//修改size  </span><br>            <span class="hljs-comment">/*             * 1.读取成员变量size的值  </span><br><span class="hljs-comment">             * 2.自增  </span><br><span class="hljs-comment">             * 3.结果写会成员变量size  </span><br><span class="hljs-comment">             */</span><span class="hljs-comment">//            size++;  </span><br>            c = size.getAndIncrement();<span class="hljs-comment">//size++ 但能保证原子性  </span><br>            <span class="hljs-comment">//此时，poll可能在等待队列非空要取数据，所以要去唤醒  </span><br><span class="hljs-comment">//            headWaits.signal();  </span><br>            <span class="hljs-keyword">if</span> (c + <span class="hljs-number">1</span> &lt; array.length) &#123;<span class="hljs-comment">//如果不是从满到不满，自己唤醒剩余的  </span><br>                tailWaits.signal();  <br>            &#125;  <br>  <br>        &#125; <span class="hljs-keyword">finally</span> &#123;  <br>            tailLock.unlock();  <br>        &#125;  <br>  <br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;  <br>            <span class="hljs-comment">//唤醒等待的poll线程  </span><br>            headLock.lock();<span class="hljs-comment">// offer_3 offer_3  </span><br>            <span class="hljs-keyword">try</span> &#123;  <br>                headWaits.signal();<span class="hljs-comment">// offer_1 让offer_1唤醒一次，offer_2和3不做唤醒操作，让poll自己内部唤醒，减少锁的使用  </span><br>            &#125; <span class="hljs-keyword">finally</span> &#123;  <br>                headLock.unlock();  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>        E e;  <br>        <span class="hljs-type">int</span> c;<span class="hljs-comment">//取走前的元素个数  </span><br>        headLock.lockInterruptibly();  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            <span class="hljs-keyword">while</span> (isEmpty()) &#123;  <br>                headWaits.await();<span class="hljs-comment">// poll_1 poll_2 poll_3  .   poll_1被唤醒后，自己唤醒poll2和3，这种思想叫做级联通知。  </span><br>            &#125;  <br>            e = array[head];  <br>            array[head] = <span class="hljs-literal">null</span>;<span class="hljs-comment">//help GC  </span><br>            <span class="hljs-keyword">if</span> (++head == array.length) &#123;  <br>                head = <span class="hljs-number">0</span>;  <br>            &#125;  <br>            <span class="hljs-comment">//修改size  </span><br>            <span class="hljs-comment">/*             * 1.读取成员变量size的值  </span><br><span class="hljs-comment">             * 2.自增  </span><br><span class="hljs-comment">             * 3.结果写会成员变量size  </span><br><span class="hljs-comment">             */</span><span class="hljs-comment">//            size--;  </span><br>            c = size.getAndDecrement();  <br>            <span class="hljs-keyword">if</span> (c &gt; <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//如果还有剩余元素，级联通知去唤醒剩下的  </span><br>                headWaits.signal();  <br>            &#125;  <br>        &#125; <span class="hljs-keyword">finally</span> &#123;  <br>            headLock.unlock();  <br>        &#125;  <br>        <span class="hljs-comment">//但是这样写，可能会产生死锁！！offer和poll中tailLock和headLock交叉引用了！  </span><br>        <span class="hljs-comment">//所以要改成平级的，不要嵌套的。  </span><br>        <span class="hljs-comment">//唤醒等待的offer线程  </span><br>        <span class="hljs-keyword">if</span> (c == array.length) &#123;<span class="hljs-comment">//从队列满到不满时，由poll唤醒等待不满offer线程  </span><br>            tailLock.lock();  <br>            <span class="hljs-keyword">try</span> &#123;  <br>                tailWaits.signal();<span class="hljs-comment">//signal和await必须搭配对应的锁  </span><br>            &#125; <span class="hljs-keyword">finally</span> &#123;  <br>                tailLock.unlock();  <br>            &#125;  <br>        &#125;  <br>  <br>        <span class="hljs-keyword">return</span> e;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-primary">其实这也是阻塞队列的源码，我们自己实现之后，就会更加清晰。双锁实现的阻塞队列的设计思想是值得反复去斟酌学习的。</p>]]></content>
    
    
    <categories>
      
      <category>data&amp;algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>队列</tag>
      
      <tag>双端队列</tag>
      
      <tag>优先级队列</tag>
      
      <tag>阻塞队列</tag>
      
      <tag>级联通知</tag>
      
      <tag>可重入锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构和算法之旅（三）- 递归</title>
    <link href="/posts/1bf3c967/"/>
    <url>/posts/1bf3c967/</url>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p class="note note-primary">在计算机科学中，递归是一种解决计算问题的方法，其中解决方案取决于同一类问题的更小子集。<br>比如，单链表递归遍历的例子。<br>void f(Node node){<br>&nbsp;&nbsp;f(node.next);<br>}<br>说明：<br>1.自己调用自己，如果每个函数对应着一种解决方案，自己调用自己意味着解决方案是一样的（有规律的）<br>2.每次调用，函数处理的数据会比上次缩减（子集），而且最后会缩减至无需继续递归。<br>3.内存函数调用（子集处理）完成，外层函数才能算调用完成！</p><h2 id="单链表递归分析"><a href="#单链表递归分析" class="headerlink" title="单链表递归分析"></a>单链表递归分析</h2><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309201838927.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309201839255.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309201839734.png"></p><h2 id="递归思路"><a href="#递归思路" class="headerlink" title="递归思路"></a>递归思路</h2><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309201840039.png"></p><p class="note note-primary">深入到最里面叫做递。<br>从最里面出来叫做归。<br>在递的过程中，外层函数的局部变量以及方法参数并未消失，归的时候还可以使用。</p><h2 id="阶乘"><a href="#阶乘" class="headerlink" title="阶乘"></a>阶乘</h2><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309201841987.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br><span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> n * f(n-<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-secondary">伪代码，分析执行流程如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">f(<span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">3</span> * f(<span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * f(<span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>)&#123;<br><span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="反向打印字符串"><a href="#反向打印字符串" class="headerlink" title="反向打印字符串"></a>反向打印字符串</h2><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309201844478.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309201845599.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">因为递的时候是正序的，归的时候逆序的，所以把递归调用放在前面，打印放在后面，即可实现</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReversePrintString</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span> n, String str)</span>&#123;<br><span class="hljs-keyword">if</span>(n == str.length()) <span class="hljs-keyword">return</span>;<br>f(n + <span class="hljs-number">1</span>, str);<span class="hljs-comment">//递</span><br>System.out.println(str.charAt(n));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309201848656.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">递归实现二分查找</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RecursionBinarySearch</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br><span class="hljs-type">int</span>[] a = &#123;<span class="hljs-number">7</span>,<span class="hljs-number">13</span>,<span class="hljs-number">21</span>,<span class="hljs-number">30</span>,<span class="hljs-number">38</span>,<span class="hljs-number">44</span>,<span class="hljs-number">52</span>,<span class="hljs-number">53</span>&#125;;<br>System.out.println(search(a, <span class="hljs-number">7</span>)); <span class="hljs-comment">//0</span><br>System.out.println(search(a, <span class="hljs-number">13</span>));<span class="hljs-comment">//1</span><br>System.out.println(search(a, <span class="hljs-number">21</span>));<span class="hljs-comment">//2</span><br>System.out.println(search(a, <span class="hljs-number">53</span>));<span class="hljs-comment">//7</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> target)</span>&#123;<br><span class="hljs-comment">//让调用者少传参数, 隐藏具体实现</span><br><span class="hljs-keyword">return</span> f(a, target, <span class="hljs-number">0</span>, a.length - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* left和right不对外暴露，让调用者使用更简单</span><br><span class="hljs-comment">* 返回目标索引</span><br><span class="hljs-comment">* 找不到返回-1</span><br><span class="hljs-comment">*/</span><br>priavte <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span>&#123;<br><span class="hljs-keyword">if</span>(left &gt; right) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">//递归终止条件</span><br><span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> (left + right) &gt;&gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(target &lt; a[m])&#123;<br><span class="hljs-keyword">return</span> f(a, target, left, m - <span class="hljs-number">1</span>);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[m] &lt; target)&#123;<br><span class="hljs-keyword">return</span> f(a, targetm m + <span class="hljs-number">1</span>, right);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">return</span> m;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="冒泡排序0-n-2"><a href="#冒泡排序0-n-2" class="headerlink" title="冒泡排序0(n^2)"></a>冒泡排序0(n^2)</h2><p>以下是冒泡排序的实现原理步骤：</p><ol><li>从列表的第一个元素开始，比较它与下一个元素的大小。</li><li>如果第一个元素大于第二个元素（逆序），则交换它们的位置。</li><li>移动到下一个元素，重复步骤1和步骤2，直到列表的末尾。</li><li>重复上述步骤，每次内部循环将最大的元素 “冒泡” 到列表的最后一个位置。</li><li>外部循环减小待排序元素的范围，直到没有需要交换的元素为止，表示排序完成。</li></ol><p>冒泡排序的特点是每一轮内部循环都将当前未排序部分中的最大元素移动到了最后。这意味着在每一轮后，最后的元素都会是当前未排序部分的最大值。排序过程中，如果一轮内部循环没有发生任何交换，就可以提前结束排序，因为列表已经是有序的。</p><p class="note note-info">用递归实现冒泡过程分析：<br>1.将数组划分成俩部分 [0..j]，[j+1 .. a.length-1]。<br>2.左边[0..j] 是未排序的部分。<br>3.右边[j+1 .. a.length-1]是已排序部分。<br>4.未排序区间内，相邻俩个元素比较，如果前一个大，则交换位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BubbleSort</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a)</span>&#123;<br>bubble(a, a.length-<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">//j 代表未排序区域的右边界</span><br><span class="hljs-comment">//bubble内部首先是递归结束条件，然后for循环是一次冒泡，然后调用自身</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bubble</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> j)</span>&#123;<br><span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; j; i++)&#123;<br><span class="hljs-keyword">if</span>(a[i] &gt; a[i+<span class="hljs-number">1</span>])&#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> a[i];<br>a[i] = a[i+<span class="hljs-number">1</span>];<br>a[i+<span class="hljs-number">1</span>] = t;<br>&#125;<br>&#125;<br>bubble(a, j-<span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309201908139.png"></p><blockquote><p>这种情况下，未排序区域还很大，但是只需要在冒泡一次，把2和1交换就达到目的了，但是未排序边界 j 还没有到 0 ，会做很多无用功。尝试优化一下。</p></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309201910581.png"></p><blockquote><p>可以搞一个 x ，初始为0，如果当次产生交换，就让所以 i 的索引赋给 x，如果没有产生交换，x 就保持上一次的不变，那么 x 就能当做无序和有序的边界了，下次递归就不用 j 去递减了。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BubbleSort</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a)</span>&#123;<br>bubble(a, a.length-<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">//j 代表未排序区域的右边界</span><br><span class="hljs-comment">//bubble内部首先是递归结束条件，然后for循环是一次冒泡，然后调用自身</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bubble</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> j)</span>&#123;<br><span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; j; i++)&#123;<br><span class="hljs-keyword">if</span>(a[i] &gt; a[i+<span class="hljs-number">1</span>])&#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> a[i];<br>a[i] = a[i+<span class="hljs-number">1</span>];<br>a[i+<span class="hljs-number">1</span>] = t;<br>x = i;<br>&#125;<br>&#125;<br>bubble(a, x);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="插入排序O-n-2"><a href="#插入排序O-n-2" class="headerlink" title="插入排序O(n^2)"></a>插入排序O(n^2)</h2><p>它的工作方式优点像整理一手扑克牌，以下是插入排序的实现原理步骤：</p><ol><li>从第二个元素开始（索引为1），将当前元素视为待插入的元素。</li><li>将待插入的元素与已排序部分的元素逐个比较，直到找到一个比待插入元素小的元素，或者已经遍历完已排序部分。</li><li>将待插入元素插入到找到的位置，使得已排序部分仍然保持有序。</li><li>重复上述步骤，逐个处理未排序部分的元素，直到整个列表都有序。</li></ol><p>插入排序的特点是在每一轮内部循环中，将当前未排序元素插入到已排序部分的合适位置，逐步扩展已排序部分。这使得已排序部分始终保持有序。插入排序适用于小型数据集或基本有序的数据集，因为它的时间复杂度为 O(n^2)，在大型数据集上性能较差。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a)</span>&#123;<br>insertion(a, <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">用递归实现</span><br><span class="hljs-comment">low是未排序的左边界，从1开始</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertion</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> low)</span>&#123;<br><span class="hljs-keyword">if</span>(low == a.length)&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> a[low];<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> low - <span class="hljs-number">1</span>;<span class="hljs-comment">//已排序区域指针</span><br><span class="hljs-keyword">while</span>(i&gt;=<span class="hljs-number">0</span> &amp;&amp; a[i]&gt;t)&#123;<span class="hljs-comment">//没有找到插入位置</span><br>a[i+<span class="hljs-number">1</span>] = a[i];<span class="hljs-comment">//空出插入位置</span><br>i--;<br>&#125;<br><span class="hljs-comment">//找到插入位置</span><br>a[i+<span class="hljs-number">1</span>] = t;<br><br>insertion(a, low+<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="斐波那契数列-多路递归"><a href="#斐波那契数列-多路递归" class="headerlink" title="斐波那契数列(多路递归)"></a>斐波那契数列(多路递归)</h2><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309201931055.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Fibonacci</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br><span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> f(n - <span class="hljs-number">1</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> f(n - <span class="hljs-number">2</span>)；<br><span class="hljs-keyword">return</span> x + y;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-danger">斐波那契是多路递归的典型案例，整个计算过程相当于二叉树了，其中很多重复的步骤，造成时间复杂度很差。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309201934609.png"></p><p class="note note-success">可以看出，上面计算过程有很多重复，可以定义一个数组，存储 f(n) 的解，将来计算到哪一项的时候，如果数组有就直接从数组取，可以大大优化；<br>这种方式称为记忆法，也称为备忘录，其实就是剪枝的过程。<br>改进之后时间复杂度从O(1.68n)优化为O(n)。但因额外产生数组，这就是空间换时间。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309201936305.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fbonacci</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br><span class="hljs-type">int</span>[] cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>Arrays.fill(cache, -<span class="hljs-number">1</span>);<span class="hljs-comment">//都填充-1</span><br>cache[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>cache[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> f(n, cache);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[] cache)</span>&#123;<br><span class="hljs-keyword">if</span>(cache[n] != -<span class="hljs-number">1</span>)&#123;<br><span class="hljs-keyword">return</span> cache[n];<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> f(n-<span class="hljs-number">1</span>, cache);<br><span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> f(n-<span class="hljs-number">2</span>, cache);<br>cache[n] = x + y;<span class="hljs-comment">//存入数组</span><br><span class="hljs-keyword">return</span> cache[n];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="递归求和"><a href="#递归求和" class="headerlink" title="递归求和"></a>递归求和</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sum</span>&#123;<br><span class="hljs-comment">//f(n) = f(n-1) + n;</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">long</span> n)</span>&#123;<br><span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> sum(n-<span class="hljs-number">1</span>) + n;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309201948253.png"></p><p class="note note-danger">递归求和，属于单路递归，很容易就想到了思路，为什么贴上这个呢。可以把n等于15000试一下，就很发现为什么了。因为栈内存溢出了！也就是爆栈了！<br>只有最内层的sum(n = 1)的函数执行完了，才能一层一层往外归。也就是说递的过程必须递到最深处才能归！！！每个方法调用是需要消耗内存的，需要存储方法的相关信息，比如说方法的参数信息，方法内的局部变量，方法的返回地址，这些信息都需要存放在栈内存中，在最内层n = 1没有结束之前，前面14999个方法都需要等着！！它们占用的内存也不能得到释放。所以会导致占内存溢出。</p><h3 id="尾调用-amp-尾递归"><a href="#尾调用-amp-尾递归" class="headerlink" title="尾调用&amp;尾递归"></a>尾调用&amp;尾递归</h3><p class="note note-success">在解决爆栈问题之前，需要掌握几个其他知识。<br>尾调用：如果函数的最后一步是调用一个函数，称为尾调用。<br>尾递归：在函数内部最后调用自己，称为尾递归。<br>能对尾递归优化的语言有c++、scala，它们会把逐级递归的方式改成平级的形式。scala也属于java的近亲，也是编译成class类在JVM上运行，有幸了解过一些。<br>当然，从根本上避免爆栈问题，就是避免使用递归。把递归代码改成循环代码。理论上所有递归都能改写成循环代码。</p><p class="note note-secondary">经典白学，哈哈哈哈</p>]]></content>
    
    
    <categories>
      
      <category>data&amp;algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
      <tag>多路递归</tag>
      
      <tag>尾递归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构和算法之旅（二）- 链表</title>
    <link href="/posts/60be154/"/>
    <url>/posts/60be154/</url>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p class="note note-primary">在计算机科学中，链表是数据元素的线性集合，其每个元素都指向下一个元素，元素存储上并不连续。<br>可分类为：<br>- 单向链表：每个元素只知道其下一个元素<br>- 双向链表：每个元素知道其上一个元素和下一个元素<br>- 循环链表：通常的链表尾节点tail指向null，而循环链表的tail指向的头结点head<br><br>链表内还有一种特殊的节点，称为哨兵(Sentinel)节点，也叫做哑元(Dummy)节点，它不存储数据，通常用作头尾，用来简化边界判断。<br></p><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><h3 id="随机访问"><a href="#随机访问" class="headerlink" title="随机访问"></a>随机访问</h3><p>根据index查找，时间复杂度O(n)，因为需要一个节点next、next找到目标。</p><h3 id="插入或删除"><a href="#插入或删除" class="headerlink" title="插入或删除"></a>插入或删除</h3><ul><li>起始位置：O(1)。</li><li>结束位置：如果已知tail节点则是O(1)，不知道tail节点则是O(n)。</li><li>中间位置：根据index查找时间+O(1)。</li></ul><h2 id="单向链表之无哨兵节点"><a href="#单向链表之无哨兵节点" class="headerlink" title="单向链表之无哨兵节点"></a>单向链表之无哨兵节点</h2><p class="note note-light">talk is cheap, show me the code.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.datastructure;<br><br><span class="hljs-keyword">import</span> java.util.Iterator;<br><span class="hljs-keyword">import</span> java.util.function.Consumer;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 单向链表 基础实现 无哨兵节点</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BasicSingleLinkedList</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterable</span> &#123;<span class="hljs-comment">//整体</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Node</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<span class="hljs-comment">//头节点，默认为null</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 内部类关系，对外隐藏实现细节</span><br><span class="hljs-comment">     * 对外部调用者只需要LinkedList即可</span><br><span class="hljs-comment">     * 内部类一半都加上static</span><br><span class="hljs-comment">     * 节点类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<span class="hljs-comment">//节点</span><br>        <span class="hljs-type">int</span> value;<span class="hljs-comment">//值</span><br>        Node next;<span class="hljs-comment">//下一个节点</span><br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> value, Node next)</span> &#123;<br>            <span class="hljs-built_in">this</span>.value = value;<br>            <span class="hljs-built_in">this</span>.next = next;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 向链表头添加元素</span><br><span class="hljs-comment">     * 多理解！！</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addFirst</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-comment">//链表为空</span><br><span class="hljs-comment">//        head = new Node(value, null);</span><br>        <span class="hljs-comment">//链表非空</span><br>        <span class="hljs-comment">//因为head默认为null，所以不需要判断，链表空不空都能能用</span><br>        head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(value, head);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 向列表尾添加元素</span><br><span class="hljs-comment">     * 先找到尾节点，再添加</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addLast</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> findLast();<br>        <span class="hljs-keyword">if</span> (last == <span class="hljs-literal">null</span>) &#123;<br>            addFirst(value);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        last.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(value, <span class="hljs-literal">null</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 向索引位置插入节点</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> index 索引位置</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 待插入值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span>) &#123;<br>            addFirst(value);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> findNode(index - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (prev == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//找不到前一个节点</span><br>            <span class="hljs-keyword">throw</span> illegalIndex();<br>        &#125;<br>        prev.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(value, prev.next);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除头节点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeFirst</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> illegalIndex();<br>        &#125;<br>        head = head.next;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据索引删除节点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span>) &#123;<br>            removeFirst();<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> findNode(index - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (prev == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//找不到前一个节点</span><br>            <span class="hljs-keyword">throw</span> illegalIndex();<br>        &#125;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">removed</span> <span class="hljs-operator">=</span> prev.next;<br>        <span class="hljs-keyword">if</span> (removed == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> illegalIndex();<br>        &#125;<br>        prev.next = removed.next;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> IllegalArgumentException <span class="hljs-title function_">illegalIndex</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;index illegal&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 找到最后一个节点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Node <span class="hljs-title function_">findLast</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//链表为空，没有最后一个节点</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">//利用for循环特性获取最后一个节点</span><br>        Node p;<br>        <span class="hljs-keyword">for</span> (p = head; p.next != <span class="hljs-literal">null</span>; p = p.next) &#123;<br>        &#125;<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查询指定位置元素</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Node <span class="hljs-title function_">findNode</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//利用for循环特性获取指定index位置节点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> head; p != <span class="hljs-literal">null</span>; p = p.next, i++) &#123;<br>            <span class="hljs-keyword">if</span> (i == index) &#123;<br>                <span class="hljs-keyword">return</span> p;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * get方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> findNode(index);<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> illegalIndex();<br>        &#125;<br>        <span class="hljs-keyword">return</span> node.value;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 循环1 while</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loop1</span><span class="hljs-params">(Consumer&lt;Integer&gt; consumer)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">pointer</span> <span class="hljs-operator">=</span> head;<span class="hljs-comment">//初始值指向头节点</span><br>        <span class="hljs-keyword">while</span> (pointer != <span class="hljs-literal">null</span>) &#123;<br>            consumer.accept(pointer.value);<span class="hljs-comment">//提供给外部的方法</span><br>            pointer = pointer.next;<span class="hljs-comment">//指向下一个节点</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 循环2 for</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loop2</span><span class="hljs-params">(Consumer&lt;Integer&gt; consumer)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">pointer</span> <span class="hljs-operator">=</span> head; pointer != <span class="hljs-literal">null</span>; pointer = pointer.next) &#123;<br>            consumer.accept(pointer.value);<span class="hljs-comment">//提供给外部的方法</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 循环3 iterator</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Iterator <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 匿名内部类 -&gt; 带名字的内部类</span><br><span class="hljs-comment">         * 这个抽取出来的内部类MyIterator，它是不加static的</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * 当内部类用到了外部类的成员变量时候，就不能加static</span><br><span class="hljs-comment">         * 因为static的意思是不依赖外部类实例的存在，而成员变量是依赖外部类的对象的</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * 而Node节点类是可以加static的，因为它不依赖外部类的对象的</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * 内部类能加就加，不能加就不加，建议加static</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyIterator</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">pointer</span> <span class="hljs-operator">=</span> head;<span class="hljs-comment">//初始值指向头节点</span><br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<span class="hljs-comment">//是否有下一个元素</span><br>            <span class="hljs-keyword">return</span> pointer != <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<span class="hljs-comment">//返回当前值，并指向下一个元素</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> pointer.value;<br>            pointer = pointer.next;<br>            <span class="hljs-keyword">return</span> v;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="单向链表之含哨兵节点"><a href="#单向链表之含哨兵节点" class="headerlink" title="单向链表之含哨兵节点"></a>单向链表之含哨兵节点</h2><p class="note note-light">talk is cheap, show me the code.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.datastructure;<br><br><span class="hljs-keyword">import</span> java.util.Iterator;<br><span class="hljs-keyword">import</span> java.util.function.Consumer;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 单向链表 优化实现 含哨兵节点</span><br><span class="hljs-comment"> * 带哨兵节点的单向链表可以减少很多边界判断</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SentinelSinglyLinkedList</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterable</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 头指针指向哨兵节点，哨兵节点值无所谓</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Node</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">111</span>, <span class="hljs-literal">null</span>);<span class="hljs-comment">//头节点</span><br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 内部类关系，对外隐藏实现细节</span><br><span class="hljs-comment">     * 对外部调用者只需要LinkedList即可</span><br><span class="hljs-comment">     * 内部类一般都加上static</span><br><span class="hljs-comment">     * 节点类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<span class="hljs-comment">//节点</span><br>        <span class="hljs-type">int</span> value;<span class="hljs-comment">//值</span><br>        Node next;<span class="hljs-comment">//下一个节点</span><br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> value, Node next)</span> &#123;<br>            <span class="hljs-built_in">this</span>.value = value;<br>            <span class="hljs-built_in">this</span>.next = next;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 加哨兵后修改</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * 向链表头添加元素</span><br><span class="hljs-comment">     * 多理解！！</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addFirst</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-comment">//不需要判断链表是否为空，因为链表一定不为空</span><br><span class="hljs-comment">//        //1.链表为空</span><br><span class="hljs-comment">////        head = new Node(value, null);</span><br><span class="hljs-comment">//        //2.链表非空</span><br><span class="hljs-comment">//        //因为head默认为null，所以不需要判断，链表空不空都能能用</span><br><span class="hljs-comment">//        head = new Node(value, head);</span><br>        insert(<span class="hljs-number">0</span>, value);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 加哨兵后修改</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * 向列表尾添加元素</span><br><span class="hljs-comment">     * 先找到尾节点，再添加</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addLast</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> findLast();<br>        <span class="hljs-comment">//含哨兵节点，不需要判断链表是否为空，因为链表一定不为空</span><br><span class="hljs-comment">//        if (last == null) &#123;</span><br><span class="hljs-comment">//            addFirst(value);</span><br><span class="hljs-comment">//            return;</span><br><span class="hljs-comment">//        &#125;</span><br>        last.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(value, <span class="hljs-literal">null</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 加哨兵后修改</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * 向索引位置插入节点</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> index 索引位置</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 待插入值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> value)</span> &#123;<br><span class="hljs-comment">//        if (index == 0) &#123;</span><br><span class="hljs-comment">//            addFirst(value);</span><br><span class="hljs-comment">//            return;</span><br><span class="hljs-comment">//        &#125;</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> findNode(index - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (prev == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//找不到前一个节点</span><br>            <span class="hljs-keyword">throw</span> illegalIndex();<br>        &#125;<br>        prev.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(value, prev.next);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 加哨兵后修改</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * 删除头节点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeFirst</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//        if (head == null) &#123;</span><br><span class="hljs-comment">//            throw illegalIndex();</span><br><span class="hljs-comment">//        &#125;</span><br><span class="hljs-comment">//        head = head.next;</span><br>        remove(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 加哨兵后修改</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * 根据索引删除节点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br><span class="hljs-comment">//        if (index == 0) &#123;</span><br><span class="hljs-comment">//            removeFirst();</span><br><span class="hljs-comment">//            return;</span><br><span class="hljs-comment">//        &#125;</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> findNode(index - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (prev == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//找不到前一个节点</span><br>            <span class="hljs-keyword">throw</span> illegalIndex();<br>        &#125;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">removed</span> <span class="hljs-operator">=</span> prev.next;<br>        <span class="hljs-keyword">if</span> (removed == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> illegalIndex();<br>        &#125;<br>        prev.next = removed.next;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> IllegalArgumentException <span class="hljs-title function_">illegalIndex</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;index illegal&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 加哨兵后修改</span><br><span class="hljs-comment">     * 找到最后一个节点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Node <span class="hljs-title function_">findLast</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//含哨兵节点，不需要判断链表是否为空，因为链表一定不为空</span><br><span class="hljs-comment">//        if (head == null) &#123;</span><br><span class="hljs-comment">//            //链表为空，没有最后一个节点</span><br><span class="hljs-comment">//            return null;</span><br><span class="hljs-comment">//        &#125;</span><br>        Node p;<br>        <span class="hljs-keyword">for</span> (p = head; p.next != <span class="hljs-literal">null</span>; p = p.next) &#123;<br>        &#125;<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 加哨兵后修改</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * 查询指定位置元素</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Node <span class="hljs-title function_">findNode</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//为什么i=-1？ 因为哨兵节点也占一位。</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> head; p != <span class="hljs-literal">null</span>; p = p.next, i++) &#123;<br>            <span class="hljs-keyword">if</span> (i == index) &#123;<br>                <span class="hljs-keyword">return</span> p;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * get方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> findNode(index);<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> illegalIndex();<br>        &#125;<br>        <span class="hljs-keyword">return</span> node.value;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 加哨兵后修改</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * 循环1 while</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loop1</span><span class="hljs-params">(Consumer&lt;Integer&gt; consumer)</span> &#123;<br>        <span class="hljs-comment">//遍历的起点变了</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">pointer</span> <span class="hljs-operator">=</span> head.next;<span class="hljs-comment">//初始值指向头节点</span><br>        <span class="hljs-keyword">while</span> (pointer != <span class="hljs-literal">null</span>) &#123;<br>            consumer.accept(pointer.value);<span class="hljs-comment">//提供给外部的方法</span><br>            pointer = pointer.next;<span class="hljs-comment">//指向下一个节点</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 加哨兵后修改</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * 循环2 for</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loop2</span><span class="hljs-params">(Consumer&lt;Integer&gt; consumer)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">pointer</span> <span class="hljs-operator">=</span> head.next; pointer != <span class="hljs-literal">null</span>; pointer = pointer.next) &#123;<br>            consumer.accept(pointer.value);<span class="hljs-comment">//提供给外部的方法</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 循环3 iterator</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Iterator <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 匿名内部类 -&gt; 带名字的内部类</span><br><span class="hljs-comment">         * 这个抽取出来的内部类MyIterator，它是不加static的</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * 当内部类用到了外部类的成员变量时候，就不能加static</span><br><span class="hljs-comment">         * 因为static的意思是不依赖外部类实例的存在，而成员变量是依赖外部类的对象的</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * 而Node节点类是可以加static的，因为它不依赖外部类的对象的</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * 内部类能加就加，不能加就不加，建议加static</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyIterator</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">pointer</span> <span class="hljs-operator">=</span> head.next;<span class="hljs-comment">//初始值指向头节点</span><br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<span class="hljs-comment">//是否有下一个元素</span><br>            <span class="hljs-keyword">return</span> pointer != <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<span class="hljs-comment">//返回当前值，并指向下一个元素</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> pointer.value;<br>            pointer = pointer.next;<br>            <span class="hljs-keyword">return</span> v;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="双向链表之含哨兵节点"><a href="#双向链表之含哨兵节点" class="headerlink" title="双向链表之含哨兵节点"></a>双向链表之含哨兵节点</h2><p class="note note-light">talk is cheap, show me the code.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.datastructure;<br><br><span class="hljs-keyword">import</span> java.util.Iterator;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 双向链表 带哨兵节点</span><br><span class="hljs-comment"> * 俩个哨兵节点，一个头哨兵，一个尾哨兵</span><br><span class="hljs-comment"> * 也就是说，链表中至少有俩个节点</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * 双向链表的优点：从尾部直接能获取最后一个节点</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DoublyLinkedListSentinel</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterable</span>&lt;Integer&gt; &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>        Node prev;<span class="hljs-comment">//上一个节点</span><br>        <span class="hljs-type">int</span> value;<span class="hljs-comment">//值</span><br>        Node next;<span class="hljs-comment">//下一个节点</span><br><br>        <span class="hljs-comment">//构造方法 方便初始化</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(Node prev, <span class="hljs-type">int</span> value, Node next)</span> &#123;<br>            <span class="hljs-built_in">this</span>.prev = prev;<br>            <span class="hljs-built_in">this</span>.value = value;<br>            <span class="hljs-built_in">this</span>.next = next;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Node head;<span class="hljs-comment">//头哨兵</span><br>    <span class="hljs-keyword">private</span> Node tail;<span class="hljs-comment">//尾哨兵</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DoublyLinkedListSentinel</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//头尾节点随便给个值就行</span><br>        head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-literal">null</span>, <span class="hljs-number">666</span>, <span class="hljs-literal">null</span>);<br>        tail = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-literal">null</span>, <span class="hljs-number">888</span>, <span class="hljs-literal">null</span>);<br>        head.next = tail;<br>        tail.prev = head;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据索引查找节点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Node <span class="hljs-title function_">findNode</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<span class="hljs-comment">//头哨兵也要参与遍历所以从-1开始</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> head; p != tail; p = p.next, i++) &#123;<br>            <span class="hljs-keyword">if</span> (i == index) &#123;<br>                <span class="hljs-keyword">return</span> p;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addFirst</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        insert(<span class="hljs-number">0</span>, value);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeFirst</span><span class="hljs-params">()</span> &#123;<br>        remove(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 向列表尾添加元素</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addLast</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> tail.prev;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">added</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(last, value, tail);<br>        last.next = added;<br>        tail.prev = added;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除列表尾元素</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeLast</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">removed</span> <span class="hljs-operator">=</span> tail.prev;<br>        <span class="hljs-keyword">if</span> (removed == head) &#123;<br>            <span class="hljs-keyword">throw</span> illegalIndex();<br>        &#125;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> removed.prev;<br>        prev.next = tail;<br>        tail.prev = prev;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 向索引位置插入节点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> findNode(index - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (prev == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> illegalIndex();<br>        &#125;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> prev.next;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">inserted</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(prev, value, next);<span class="hljs-comment">//新节点的上一个节点是prev，下一个节点是next</span><br>        prev.next = inserted;<span class="hljs-comment">//prev的下一个节点是inserted</span><br>        next.prev = inserted;<span class="hljs-comment">//next的上一个节点是inserted</span><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除索引位置的节点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> findNode(index - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (prev == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> illegalIndex();<br>        &#125;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">removed</span> <span class="hljs-operator">=</span> prev.next;<br>        <span class="hljs-keyword">if</span> (removed == tail) &#123;<br>            <span class="hljs-keyword">throw</span> illegalIndex();<br>        &#125;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> removed.next;<br><br>        prev.next = next;<br>        next.prev = prev;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> IllegalArgumentException <span class="hljs-title function_">illegalIndex</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;index illegal&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Iterator&lt;Integer&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Iterator</span>&lt;Integer&gt;() &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> head.next;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> p != tail;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> p.value;<br>                p = p.next;<br>                <span class="hljs-keyword">return</span> v;<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="双向环形含哨兵链表"><a href="#双向环形含哨兵链表" class="headerlink" title="双向环形含哨兵链表"></a>双向环形含哨兵链表</h2><p class="note note-light">talk is cheap, show me the code.<br> 这个有些特殊，此时哨兵即作为头，也作为尾。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309201522659.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.datastructure;<br><br><span class="hljs-keyword">import</span> java.util.Iterator;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 环形双向含哨兵链表</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RingDoublyLinkedListSentinel</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterable</span>&lt;Integer&gt; &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>        Node prev;<br>        <span class="hljs-type">int</span> value;<br>        Node next;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(Node prev, <span class="hljs-type">int</span> value, Node next)</span> &#123;<br>            <span class="hljs-built_in">this</span>.prev = prev;<br>            <span class="hljs-built_in">this</span>.value = value;<br>            <span class="hljs-built_in">this</span>.next = next;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Node</span> <span class="hljs-variable">sentinel</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-literal">null</span>, <span class="hljs-number">666</span>, <span class="hljs-literal">null</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RingDoublyLinkedListSentinel</span><span class="hljs-params">()</span> &#123;<br>        sentinel.next = sentinel;<br>        sentinel.prev = sentinel;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 添加到链表头部</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addFirst</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> sentinel;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> sentinel.next;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">added</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(a, value, b);<br>        a.next = added;<br>        b.prev = added;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 添加到链表尾部</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addLast</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> sentinel.prev;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> sentinel;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">added</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(a, value, b);<br>        a.next = added;<br>        b.prev = added;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除第一个</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeFirst</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">removed</span> <span class="hljs-operator">=</span> sentinel.next;<br>        <span class="hljs-keyword">if</span> (removed == sentinel) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal argument&quot;</span>);<br>        &#125;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> removed.prev;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> removed.next;<br>        a.next = b;<br>        b.prev = a;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除最后一个</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeLast</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">removed</span> <span class="hljs-operator">=</span> sentinel.prev;<br>        <span class="hljs-keyword">if</span> (removed == sentinel) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal argument&quot;</span>);<br>        &#125;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> removed.prev;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> removed.next;<br>        a.next = b;<br>        b.prev = a;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据值删除节点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeByValue</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">removed</span> <span class="hljs-operator">=</span> findByValue(value);<br>        <span class="hljs-keyword">if</span> (removed == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal argument&quot;</span>);<br>        &#125;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> removed.prev;<span class="hljs-comment">//前一个节点</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> removed.next;<span class="hljs-comment">//后一个节点</span><br>        a.next = b;<span class="hljs-comment">//前一个节点的next指向后一个节点</span><br>        b.prev = a;<span class="hljs-comment">//后一个节点的prev指向前一个节点</span><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据值找到节点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Node <span class="hljs-title function_">findByValue</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> sentinel.next;<br>        <span class="hljs-keyword">while</span> (p != sentinel) &#123;<br>            <span class="hljs-keyword">if</span> (p.value == value) &#123;<br>                <span class="hljs-keyword">return</span> p;<br>            &#125;<br>            p = p.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Iterator&lt;Integer&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Iterator</span>&lt;Integer&gt;() &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">pointer</span> <span class="hljs-operator">=</span> sentinel.next;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> pointer != sentinel;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> pointer.value;<br>                pointer = pointer.next;<br>                <span class="hljs-keyword">return</span> v;<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="单向链表的递归遍历"><a href="#单向链表的递归遍历" class="headerlink" title="单向链表的递归遍历"></a>单向链表的递归遍历</h2><p class="note note-light">talk is cheap, show me the code.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><code class="hljs java">  <br><span class="hljs-keyword">import</span> java.util.Iterator;  <br><span class="hljs-keyword">import</span> java.util.function.Consumer;  <br>  <br><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * 单向链表 基础实现  </span><br><span class="hljs-comment"> * &lt;p&gt;  </span><br><span class="hljs-comment"> * ！！！递归遍历！！！  </span><br><span class="hljs-comment"> * 它是链表的一种非常重要的遍历方式  </span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RecursionLinkedList</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterable</span> &#123;<span class="hljs-comment">//整体  </span><br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Node</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<span class="hljs-comment">//头节点，默认为null  </span><br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 内部类关系，对外隐藏实现细节  </span><br><span class="hljs-comment">     * 对外部调用者只需要LinkedList即可  </span><br><span class="hljs-comment">     * 内部类一半都加上static  </span><br><span class="hljs-comment">     * 节点类  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<span class="hljs-comment">//节点  </span><br>        <span class="hljs-type">int</span> value;<span class="hljs-comment">//值  </span><br>        Node next;<span class="hljs-comment">//下一个节点  </span><br>  <br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> value, Node next)</span> &#123;  <br>            <span class="hljs-built_in">this</span>.value = value;  <br>            <span class="hljs-built_in">this</span>.next = next;  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 向链表头添加元素  </span><br><span class="hljs-comment">     * 多理解！！  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addFirst</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;  <br>        <span class="hljs-comment">//1.链表为空  </span><br><span class="hljs-comment">//        head = new Node(value, null);  </span><br>        <span class="hljs-comment">//2.链表非空  </span><br>        <span class="hljs-comment">//因为head默认为null，所以不需要判断，链表空不空都能能用  </span><br>        head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(value, head);  <br>    &#125;  <br>  <br>  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 向列表尾添加元素  </span><br><span class="hljs-comment">     * 先找到尾节点，再添加  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addLast</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> findLast();  <br>        <span class="hljs-keyword">if</span> (last == <span class="hljs-literal">null</span>) &#123;  <br>            addFirst(value);  <br>            <span class="hljs-keyword">return</span>;  <br>        &#125;  <br>        last.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(value, <span class="hljs-literal">null</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 向索引位置插入节点  </span><br><span class="hljs-comment">     *  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> index 索引位置  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 待插入值  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> value)</span> &#123;  <br>        <span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span>) &#123;  <br>            addFirst(value);  <br>            <span class="hljs-keyword">return</span>;  <br>        &#125;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> findNode(index - <span class="hljs-number">1</span>);  <br>        <span class="hljs-keyword">if</span> (prev == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//找不到前一个节点  </span><br>            <span class="hljs-keyword">throw</span> illegalIndex();  <br>        &#125;  <br>        prev.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(value, prev.next);  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 删除头节点  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeFirst</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-keyword">throw</span> illegalIndex();  <br>        &#125;  <br>        head = head.next;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 根据索引删除节点  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;  <br>        <span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span>) &#123;  <br>            removeFirst();  <br>            <span class="hljs-keyword">return</span>;  <br>        &#125;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> findNode(index - <span class="hljs-number">1</span>);  <br>        <span class="hljs-keyword">if</span> (prev == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//找不到前一个节点  </span><br>            <span class="hljs-keyword">throw</span> illegalIndex();  <br>        &#125;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">removed</span> <span class="hljs-operator">=</span> prev.next;  <br>        <span class="hljs-keyword">if</span> (removed == <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-keyword">throw</span> illegalIndex();  <br>        &#125;  <br>        prev.next = removed.next;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> IllegalArgumentException <span class="hljs-title function_">illegalIndex</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;index illegal&quot;</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 找到最后一个节点  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">private</span> Node <span class="hljs-title function_">findLast</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-comment">//链表为空，没有最后一个节点  </span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>        &#125;  <br>        Node p;  <br>        <span class="hljs-keyword">for</span> (p = head; p.next != <span class="hljs-literal">null</span>; p = p.next) &#123;  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> p;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 查询指定位置元素  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">private</span> Node <span class="hljs-title function_">findNode</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> head; p != <span class="hljs-literal">null</span>; p = p.next, i++) &#123;  <br>            <span class="hljs-keyword">if</span> (i == index) &#123;  <br>                <span class="hljs-keyword">return</span> p;  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * get方法  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> findNode(index);  <br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-keyword">throw</span> illegalIndex();  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> node.value;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 循环3 iterator  </span><br><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> Iterator <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-comment">/**  </span><br><span class="hljs-comment">         * 匿名内部类 -&gt; 带名字的内部类  </span><br><span class="hljs-comment">         * 这个抽取出来的内部类MyIterator，它是不加static的  </span><br><span class="hljs-comment">         *  </span><br><span class="hljs-comment">         * 当内部类用到了外部类的成员变量时候，就不能加static  </span><br><span class="hljs-comment">         * 因为static的意思是不依赖外部类实例的存在，而成员变量是依赖外部类的对象的  </span><br><span class="hljs-comment">         *  </span><br><span class="hljs-comment">         * 而Node节点类是可以加static的，因为它不依赖外部类的对象的  </span><br><span class="hljs-comment">         *  </span><br><span class="hljs-comment">         * 内部类能加就加，不能加就不加，建议加static  </span><br><span class="hljs-comment">         */</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyIterator</span>();  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span> &#123;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">pointer</span> <span class="hljs-operator">=</span> head;<span class="hljs-comment">//初始值指向头节点  </span><br>  <br>        <span class="hljs-meta">@Override</span>  <br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<span class="hljs-comment">//是否有下一个元素  </span><br>            <span class="hljs-keyword">return</span> pointer != <span class="hljs-literal">null</span>;  <br>        &#125;  <br>  <br>        <span class="hljs-meta">@Override</span>  <br>        <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<span class="hljs-comment">//返回当前值，并指向下一个元素  </span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> pointer.value;  <br>            pointer = pointer.next;  <br>            <span class="hljs-keyword">return</span> v;  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recursion</span><span class="hljs-params">(Node curr, Consumer&lt;String&gt; before, Consumer&lt;String&gt; after)</span>&#123; <br>        <span class="hljs-keyword">if</span> (curr == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//递归需要一个终止条件  </span><br>            <span class="hljs-keyword">return</span>;  <br>        &#125;  <br>        before.accept(<span class="hljs-string">&quot;before: &quot;</span> + curr.value);  <br>        recursion(curr.next, before, after);<span class="hljs-comment">//这样自己调用自己称为递归  </span><br>        after.accept(<span class="hljs-string">&quot;after: &quot;</span> + curr.value);  <br>    &#125;  <br>  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    <span class="hljs-type">RecursionLinkedList</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RecursionLinkedList</span>();  <br>    list.addLast(<span class="hljs-number">55</span>);  <br>    list.addLast(<span class="hljs-number">66</span>);  <br>    list.addLast(<span class="hljs-number">77</span>);  <br>    list.addLast(<span class="hljs-number">88</span>);  <br>    list.recursion(list.findNode(<span class="hljs-number">0</span>),System.out::println, System.out::println);  <br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>通过递归方式遍历打印的时候，发现了有趣的现象，不同情况，打印结果却不同<br>打印在前，递归在后<br>递归在前，递归在后<br>俩种情况的呈现方式相差很大，如下图。</p></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309201607691.png"></p><blockquote><p>下一篇，会详细探讨一下递归，来解释为什么有这种现象。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>data&amp;algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
      <tag>链表</tag>
      
      <tag>单向链表</tag>
      
      <tag>双向链表</tag>
      
      <tag>环形链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构和算法之旅（一）- 数组</title>
    <link href="/posts/743df8dd/"/>
    <url>/posts/743df8dd/</url>
    
    <content type="html"><![CDATA[<blockquote><p>在计算机科学中，数组是由一组元素(值或变量)组成的数据结构，每个元素有至少一个索引来标识；因为数组内元素是连续存储的，所以数组中的元素的地址，可以通过其索引计算出来，例如：<img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309201048552.png"></p><p>数组的特点：<strong>随机访问</strong>。即根据索引查找元素，时间复杂度是O(1)。</p></blockquote><h2 id="自定义动态数组"><a href="#自定义动态数组" class="headerlink" title="自定义动态数组"></a>自定义动态数组</h2><p class="note note-info">数组是静态数组，不能够动态调整大小。Java是有提供好的动态数组，其实就是ArrayList，但目前是为了学习数据结构，下面自己来实现一个动态数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.datastructure;<br><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Iterator;<br><span class="hljs-keyword">import</span> java.util.function.Consumer;<br><span class="hljs-keyword">import</span> java.util.stream.IntStream;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 动态数组</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DynamicArray</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterable</span>&lt;Integer&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//逻辑大小</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">capacity</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<span class="hljs-comment">//容量 ,java中arraylist默认是10</span><br><br>    <span class="hljs-comment">//    private int[] array = new int[capacity];//延迟加载</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] array = &#123;&#125;;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 添加元素到数组末尾</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> element 待添加的元素</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addLast</span><span class="hljs-params">(<span class="hljs-type">int</span> element)</span> &#123;<br>        <span class="hljs-comment">//array[size] = element;</span><br>        <span class="hljs-comment">//size++;</span><br>        add(size, element);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 添加元素到指定位置</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> index   索引位置</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> element 待添加的元素</span><br><span class="hljs-comment">     * 时间复杂度</span><br><span class="hljs-comment">     *    头部插入：O(n)</span><br><span class="hljs-comment">     *    中间插入：O(n)</span><br><span class="hljs-comment">     *    尾部插入：O(1)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> element)</span> &#123;<br>        <span class="hljs-comment">//扩容检查</span><br>        checkAndGrow();<br>        <span class="hljs-comment">//检查index是否合法</span><br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt; size) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>(<span class="hljs-string">&quot;index:&quot;</span> + index + <span class="hljs-string">&quot;,size:&quot;</span> + size);<br>        &#125;<br>        <span class="hljs-comment">//拷贝，把目标index后的元素都往后移动一位</span><br>        System.arraycopy(array, index, array, index + <span class="hljs-number">1</span>, size - index);<br>        array[index] = element;<br>        size++;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 扩容检查</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkAndGrow</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>) &#123;<br>            array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[capacity];<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (size == capacity) &#123;<br>            <span class="hljs-comment">//扩容，1.5倍、1.618倍、2倍：建议这些</span><br>            capacity += capacity &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span>[] newArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[capacity];<br>            <span class="hljs-comment">//拷贝</span><br>            System.arraycopy(array, <span class="hljs-number">0</span>, newArray, <span class="hljs-number">0</span>, size);<br>            <span class="hljs-comment">//替换</span><br>            array = newArray;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除指定位置的元素</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> index</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<span class="hljs-comment">//[0..size)</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">removed</span> <span class="hljs-operator">=</span> array[index];<br>        <span class="hljs-keyword">if</span> (index &lt; size - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">//拷贝，把目标index后的元素都往前移动一位</span><br>            System.arraycopy(array, index + <span class="hljs-number">1</span>, array, index, size - index - <span class="hljs-number">1</span>);<br>            size--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> removed;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查询指定位置的元素</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> index 索引</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 时间复杂度：O(1)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<span class="hljs-comment">// [0..size)</span><br>        <span class="hljs-keyword">return</span> array[index];<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 使用函数式接口Consumer,遍历数组，</span><br><span class="hljs-comment">     * 对每个元素执行consumer.accept(array[i])，令调用方执行自定义的操作</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> consumer</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">foreach</span><span class="hljs-params">(Consumer&lt;Integer&gt; consumer)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            <span class="hljs-comment">// 提供array[i]</span><br>            <span class="hljs-comment">// 返回void</span><br>            consumer.accept(array[i]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 迭代器遍历</span><br><span class="hljs-comment">     * 实现Iterable接口，使得DynamicArray可以使用foreach语法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Iterator&lt;Integer&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Iterator</span>&lt;Integer&gt;() &#123;<br>            <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> index &lt; size;<span class="hljs-comment">//index &lt; size表示还有元素</span><br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> array[index++];<br>            &#125;<br>        &#125;;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取流对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> IntStream <span class="hljs-title function_">stream</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> IntStream.of(Arrays.copyOfRange(array, <span class="hljs-number">0</span>, size));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="System-arraycopy"><a href="#System-arraycopy" class="headerlink" title="System.arraycopy"></a>System.arraycopy</h2><p class="note note-warning">注：System.arraycopy(Object src, int srcPos, Object dest, int destPos, int length);</br>- src：源数组，即要复制的数组。</br>- srcPos：源数组的起始位置，从源数组的哪个索引开始复制。</br>- dest：目标数组，即复制到的数组。</br>- destPos：目标数组的起始位置，复制到目标数组的哪个索引位置。</br>- length：要复制的元素数量。</br></br>System.arrayCopy 的主要特点和注意事项：</br>1. **低级别操作：** 这是一种低级别的数组操作，直接在内存中复制数组内容，效率较高。    </br>2. **复制范围控制：** 你可以控制复制的范围，包括源数组的起始位置、目标数组的起始位置和要复制的元素数量。    </br>3. **原地复制：** 它允许在不创建新数组的情况下，将源数组的一部分复制到目标数组中，适用于需要在原地进行数据移动的情况。    </br>4. **数据类型检查：** `System.arrayCopy` 不会进行数据类型检查，因此要确保源和目标数组的数据类型一致，否则可能会导致运行时异常。    </br>5. **不会自动扩展：** 它不会自动扩展目标数组，如果目标数组长度不足以容纳复制的数据，会导致数组越界异常。    </br>6. **效率高：** 由于是底层操作，因此通常情况下比使用迭代或循环来复制数组要更高效</p><h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p class="note note-primary">这个很有趣，推荐平常多使用函数式接口来优化代码，这里总结汇总一下吧。</p><h3 id="Runnable-和-Callable"><a href="#Runnable-和-Callable" class="headerlink" title="Runnable 和 Callable"></a>Runnable 和 Callable</h3><ul><li><code>Runnable</code> 通常用于<strong>多线程编程，用于定义线程要执行的任务</strong>。它没有输入参数，也没有返回值。</li><li><code>Callable</code> 类似于 <code>Runnable</code>，但<strong>允许任务返回结果</strong>。通常与线程池一起使用，可以获得任务执行的结果。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用Runnable创建线程任务</span><br><span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> () -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;Hello from Runnable&quot;</span>);<br>&#125;;<br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable);<br>thread.start();<br><br><span class="hljs-comment">// 使用Callable和ExecutorService获取线程任务的返回值</span><br>Callable&lt;Integer&gt; callable = () -&gt; &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;<br>&#125;;<br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newSingleThreadExecutor();<br>Future&lt;Integer&gt; result = executorService.submit(callable);<br>System.out.println(<span class="hljs-string">&quot;Result from Callable: &quot;</span> + result.get());<br>executorService.shutdown();<br></code></pre></td></tr></table></figure><h3 id="Comparator"><a href="#Comparator" class="headerlink" title="Comparator"></a>Comparator</h3><ul><li><code>Comparator</code> 用于<strong>比较两个对象的顺序</strong>。它通常用于集合的排序操作。</li><li>可以使用 <code>Comparator</code> 的 <code>comparing</code> 方法创建比较器，也可以使用 <code>reversed</code> 方法反转比较器的顺序。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; names = Arrays.asList(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;Charlie&quot;</span>);<br>names.sort((s1, s2) -&gt; s1.compareTo(s2));<br><span class="hljs-comment">// 或者使用Comparator.comparing方法</span><br>names.sort(Comparator.comparing(String::length));<br></code></pre></td></tr></table></figure><h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><ul><li>直译有”消费者”的含义。</li><li><code>Consumer</code> 用于<strong>接受一个参数并执行操作，通常没有返回值</strong>。它常用于集合的遍历和元素处理。</li><li>可以使用 <code>andThen</code> 方法组合多个 <code>Consumer</code>，形成一个连续的操作链。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; numbers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br>Consumer&lt;Integer&gt; printSquare = (num) -&gt; System.out.println(num * num);<br>numbers.forEach(printSquare);<br></code></pre></td></tr></table></figure><h3 id="Supplier"><a href="#Supplier" class="headerlink" title="Supplier"></a>Supplier</h3><ul><li>直译有“供应者”的含义。</li><li><code>Supplier</code> <strong>通常不接受参数，用于生成一个值</strong>。它可以用于延迟加载或惰性计算。</li><li>可以在需要值的地方<strong>调用 <code>get</code> 方法来获取值</strong>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Supplier&lt;Double&gt; randomNumberSupplier = () -&gt; Math.random();<br><span class="hljs-type">double</span> <span class="hljs-variable">randomValue</span> <span class="hljs-operator">=</span> randomNumberSupplier.get();<br>System.out.println(<span class="hljs-string">&quot;Random Value: &quot;</span> + randomValue);<br></code></pre></td></tr></table></figure><h3 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h3><ul><li>直译有”谓语”的含义。</li><li><code>Predicate</code> <strong>接受一个参数并返回布尔值，用于进行条件判断</strong>。它通常用于过滤和筛选数据。</li><li>可以使用 <code>and</code>、<code>or</code> 和 <code>negate</code> 方法来组合多个谓词。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; numbers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br>Predicate&lt;Integer&gt; isEven = (num) -&gt; num % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;<br>List&lt;Integer&gt; evenNumbers = numbers.stream().filter(isEven).collect(Collectors.toList());<br></code></pre></td></tr></table></figure><h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h3><ul><li><code>Function</code> <strong>接受一个参数并返回一个值，用于将输入映射到输出</strong>。它通常用于数据转换和处理。</li><li>可以使用 <code>andThen</code> 和 <code>compose</code> 方法来组合多个函数，形成一个函数链。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Function&lt;Integer, String&gt; intToString = (i) -&gt; String.valueOf(i);<br><span class="hljs-type">String</span> <span class="hljs-variable">stringValue</span> <span class="hljs-operator">=</span> intToString.apply(<span class="hljs-number">42</span>);<br>System.out.println(<span class="hljs-string">&quot;String Value: &quot;</span> + stringValue);<br></code></pre></td></tr></table></figure><h3 id="BiFunction"><a href="#BiFunction" class="headerlink" title="BiFunction"></a>BiFunction</h3><ul><li><code>BiFunction</code> <strong>接受两个参数并返回一个值，用于处理两个输入并产生一个输出</strong>。它通常用于需要两个输入的操作。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">BiFunction&lt;Integer, Integer, Integer&gt; add = (a, b) -&gt; a + b;<br><span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> add.apply(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>);<br>System.out.println(<span class="hljs-string">&quot;Sum: &quot;</span> + sum);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>data&amp;algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>二维数组</tag>
      
      <tag>函数式接口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构和算法之旅（零）- 认识算法</title>
    <link href="/posts/24ec10c/"/>
    <url>/posts/24ec10c/</url>
    
    <content type="html"><![CDATA[<p class="note note-secondary">通过二分查找算法，认识算法。</br>需求：在有序数组A内，查找值target：</br>1.如果找到返回索引；</br>2.如果找不到返回-1；</p><h2 id="二分查找算法"><a href="#二分查找算法" class="headerlink" title="二分查找算法"></a>二分查找算法</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>根据需求，可以直观的想出来的解法如下：</p><ul><li>前提：给定一个内含n个元素的有序数组A，查找指定值target;</li><li>1.设置<code>i = 0</code>为左边界索引，<code>j = n - 1</code>为右边界索引;</li><li>2.如果<code>i &gt; j</code>，结束查找，没找到；</li><li>3.设置<code>m = medium((i+j)/2)</code>，m为中间索引，medium是向下取整的最小整数；</li><li>4.如果<code>target &lt; A[m]</code>，设置 <code>j = m - 1</code>，转第二步；</li><li>5.如果<code>A[m] &lt; target</code>，设置<code>i = m + 1</code>，转第二步；</li><li>6.如果<code>A[m] = target</code>，结束查找，说明找到了；</li></ul><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearchBasic</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> target)</span>&#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = a.length - <span class="hljs-number">1</span>;<span class="hljs-comment">//设置指针和初值</span><br><span class="hljs-keyword">while</span>(i&lt;=j)&#123;<br><span class="hljs-comment">//int m = (i+j)/2;//java除法自动取整，但除法有隐患，当然数值范围不大可以忽略</span><br><span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> (i+j)&gt;&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-comment">//无符号右移，相当于除以2，且能避免隐患</span><br><span class="hljs-keyword">if</span>(target&lt;a[m])&#123;<br><span class="hljs-comment">//如果目标在中间值的左边，设置右边界指针为中间索引-1</span><br>j = m - <span class="hljs-number">1</span>;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[m]&lt;target)&#123;<br><span class="hljs-comment">//如果目标在中间值的右边，设置左边界指针为中间索引+1</span><br>i = m + <span class="hljs-number">1</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">//找到了</span><br><span class="hljs-keyword">return</span> m;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="why"><a href="#why" class="headerlink" title="why"></a>why</h3><p class="note note-danger">Q：为什么是i <= j 意味着区间内有未比较的元素，而不是i < j ？</p><p class="note note-success">A：因为i=j 指向的元素也有可能是要查找的目标，如果没有等号，就会漏掉一次比较；</p><p class="note note-danger">Q：(i+j)/2 有没有问题？为什么使用右移代替？</p><p class="note note-success">A：因为如果数组无限大，j初始是Integer.MAX_VALUE - 1。第一次(i+j)/2没问题，但是如果此时，目标值比中间值大，需要把左侧i边界设置为m+1，那么此时，再进行取中间索引时候，(i+j)/2. 一个是Integer.MAX_VALUE的一半，一个是MAX_VALUE就会超过正整数能表达的范围，就会得到一个负数。负数是补码的形式，符号位不变，数值为取反。所以会得到一个负数；java里面二进制数都是有符号的，最高位是符号位。</p><p class="note note-danger">Q：为什么判断条件都写小于符号？</p><p class="note note-success">A：因为这里数组a是升序排列的，写成小于符号，相当于与数组排列的顺序是一致的。</p><h2 id="二分查找的应用"><a href="#二分查找的应用" class="headerlink" title="二分查找的应用"></a>二分查找的应用</h2><h3 id="重复元素"><a href="#重复元素" class="headerlink" title="重复元素"></a>重复元素</h3><p class="note note-secondary">需求，如果存在重复元素，希望找到最左侧的第一个元素</br>这种形式称为LeftMost，找最右侧的第一个元素，即为RightMost</p><p class="note note-info">首先，还是二分查找的解法，只不过在找到了的分支，追加向左区间继续找或向右区间继续找目标值的逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * 二分查找 - LeftMost  </span><br><span class="hljs-comment"> * 重复元素的数组中，查找最左侧的  </span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearchLeftMost</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> target)</span> &#123;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = a.length - <span class="hljs-number">1</span>;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">candidate</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">//候选  </span><br>    <span class="hljs-keyword">while</span> (i &lt;= j) &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> (i + j) &gt;&gt;&gt; <span class="hljs-number">1</span>;  <br>        <span class="hljs-keyword">if</span> (target &lt; a[m]) &#123;  <br>            j = m - <span class="hljs-number">1</span>;  <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a[m] &lt; target) &#123;  <br>            i = m + <span class="hljs-number">1</span>;  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            <span class="hljs-comment">//只需要修改这里，找到目标需要存为候选，然后继续向左边找  </span><br>            candidate = m;  <br>            <span class="hljs-comment">//继续向左边找，则需要设置右侧指针移至中间索引-1  </span><br>            j = m - <span class="hljs-number">1</span>;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> candidate;  <br>&#125;<br><br><br><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * 二分查找 - RightMost  </span><br><span class="hljs-comment"> * 重复元素的数组中，查找最右侧的  </span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearchRightMost</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> target)</span> &#123;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = a.length - <span class="hljs-number">1</span>;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">candidate</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">//候选  </span><br>    <span class="hljs-keyword">while</span> (i &lt;= j) &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> (i + j) &gt;&gt;&gt; <span class="hljs-number">1</span>;  <br>        <span class="hljs-keyword">if</span> (target &lt; a[m]) &#123;  <br>            j = m - <span class="hljs-number">1</span>;  <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a[m] &lt; target) &#123;  <br>            i = m + <span class="hljs-number">1</span>;  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            <span class="hljs-comment">//只需要修改这里，找到目标需要存为候选，然后继续向右边找  </span><br>            candidate = m;  <br>            <span class="hljs-comment">//继续向右边找，则需要设置左侧指针移至中间索引+1  </span><br>            i = m + <span class="hljs-number">1</span>;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> candidate;  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="求排名"><a href="#求排名" class="headerlink" title="求排名"></a>求排名</h3><p class="note note-secondary">求排名，其实是LeftMost的应用，看一个图就了解了</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309201022852.png"></p><p class="note note-info">所以，求排名的解法就是：LeftMost+1。</p><h3 id="求前任后任"><a href="#求前任后任" class="headerlink" title="求前任后任"></a>求前任后任</h3><p class="note note-secondary">还是这张图，也是最左和最右的应用。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309201022852.png"></p><p class="note note-info">分析可知，</br>求前任解法即：LeftMost-1</br>求后任解法即：RightMost+1</p><h3 id="最近邻居"><a href="#最近邻居" class="headerlink" title="最近邻居"></a>最近邻居</h3><p class="note note-info">比如5的最近邻居是4，因为4和5差1，5和7差2，</br>就是找到前任和后任，然后比对，找到其中最小的。</p><h3 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h3><p class="note note-info">比如想找所有小于4的目标，0 .. LeftMost(4) - 1</br>比如找所有小于等于4的目标， 0 .. RightMost(4)</br>比如找所有大于4的目标， RightMost(4)+1 .. 无穷大</br>比如找所有大于等于4的目标，LeftMost(4) .. 无穷大</br>找 4 <= x <=7 ，LeftMost(4) .. RightMost(7)</br>找 4 < x <=7，RightMost(4)+1 .. LeftMost(7)-1</p><h3 id="leetcode"><a href="#leetcode" class="headerlink" title="leetcode"></a>leetcode</h3><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309201038568.png"></p><p class="note note-info">抱一丝，仍然是leftMost和rightMost的应用，有了最左和最右就可以得到结果，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">pubic <span class="hljs-type">int</span>[] searchRange(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> target)&#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> leftMost(a, target);<br><span class="hljs-keyword">if</span>(left == -<span class="hljs-number">1</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;left, rightMost(a, traget)&#125;;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>data&amp;algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
