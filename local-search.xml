<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>备忘系列-zookeeper</title>
    <link href="/posts/5326b2b2/"/>
    <url>/posts/5326b2b2/</url>
    
    <content type="html"><![CDATA[<p>sadasd</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>云原生之DevOps</title>
    <link href="/posts/9393e822/"/>
    <url>/posts/9393e822/</url>
    
    <content type="html"><![CDATA[<p>123123ss拾叁</p>]]></content>
    
    
    <categories>
      
      <category>云原生</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DevOps</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>云原生之kubeSphere</title>
    <link href="/posts/68893475/"/>
    <url>/posts/68893475/</url>
    
    <content type="html"><![CDATA[<p>1111222</p>]]></content>
    
    
    <categories>
      
      <category>云原生</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kubeSphere</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>云原生之k8s</title>
    <link href="/posts/7b28abd7/"/>
    <url>/posts/7b28abd7/</url>
    
    <content type="html"><![CDATA[<p>kkk8s<br>11</p>]]></content>
    
    
    <categories>
      
      <category>云原生</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kubernetes</tag>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>备忘系列-nginx</title>
    <link href="/posts/c06c050/"/>
    <url>/posts/c06c050/</url>
    
    <content type="html"><![CDATA[<p>2323</p>]]></content>
    
    
    <categories>
      
      <category>网络应用组件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线程安全</tag>
      
      <tag>nginx</tag>
      
      <tag>反向代理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>备忘系列-netty</title>
    <link href="/posts/75dbf2b5/"/>
    <url>/posts/75dbf2b5/</url>
    
    <content type="html"><![CDATA[<p>是sadasd</p>]]></content>
    
    
    <categories>
      
      <category>网络应用组件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>netty</tag>
      
      <tag>io</tag>
      
      <tag>nio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>备忘系列-mongodb</title>
    <link href="/posts/c9d19155/"/>
    <url>/posts/c9d19155/</url>
    
    <content type="html"><![CDATA[<p>1212</p>]]></content>
    
    
    <categories>
      
      <category>nosql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mongodb</tag>
      
      <tag>nosql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>备忘系列-solr</title>
    <link href="/posts/7aa76e65/"/>
    <url>/posts/7aa76e65/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>nosql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nosql</tag>
      
      <tag>solr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>备忘系列-xxl-job</title>
    <link href="/posts/89b2e006/"/>
    <url>/posts/89b2e006/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>xxl-job</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通关微服务-mysql</title>
    <link href="/posts/bb4eda82/"/>
    <url>/posts/bb4eda82/</url>
    
    <content type="html"><![CDATA[<p>333311</p>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通关微服务-redis</title>
    <link href="/posts/554b12af/"/>
    <url>/posts/554b12af/</url>
    
    <content type="html"><![CDATA[<p>redis is good<br>2333</p>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通关微服务-seata</title>
    <link href="/posts/6235e4a0/"/>
    <url>/posts/6235e4a0/</url>
    
    <content type="html"><![CDATA[<p>asd221</p>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>seata</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通关微服务-sentinel</title>
    <link href="/posts/60bdb85a/"/>
    <url>/posts/60bdb85a/</url>
    
    <content type="html"><![CDATA[<p>收到22111</p>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sentinel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通关微服务-ELK</title>
    <link href="/posts/9b53a343/"/>
    <url>/posts/9b53a343/</url>
    
    <content type="html"><![CDATA[<p>elk…ss</p>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
      <category>nosql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nosql</tag>
      
      <tag>elasticsearch</tag>
      
      <tag>logstash</tag>
      
      <tag>kibana</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通关微服务-SpringAMQP</title>
    <link href="/posts/8e215a30/"/>
    <url>/posts/8e215a30/</url>
    
    <content type="html"><![CDATA[<p>11ss</p>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AMQP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通关微服务-rabbitMQ</title>
    <link href="/posts/d4befa93/"/>
    <url>/posts/d4befa93/</url>
    
    <content type="html"><![CDATA[<p>啊啊啊啊啊啊</p>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rabbitMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通关微服务-gateway</title>
    <link href="/posts/4d88743d/"/>
    <url>/posts/4d88743d/</url>
    
    <content type="html"><![CDATA[<p>112</p>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>gateway</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通关微服务-nacos</title>
    <link href="/posts/2c2c4e78/"/>
    <url>/posts/2c2c4e78/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nacos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通关微服务-dubbo</title>
    <link href="/posts/198ade24/"/>
    <url>/posts/198ade24/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dubbo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>认识微服务体系</title>
    <link href="/posts/ffffd0ab/"/>
    <url>/posts/ffffd0ab/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>单体应用的困境</title>
    <link href="/posts/6fe0354c/"/>
    <url>/posts/6fe0354c/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2020终章</title>
    <link href="/posts/bd0587f7/"/>
    <url>/posts/bd0587f7/</url>
    
    <content type="html"><![CDATA[<p>奥术大师发的</p>]]></content>
    
    
    <categories>
      
      <category>年度总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>2020年度总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>elementUI case</title>
    <link href="/posts/2c7fc5c1/"/>
    <url>/posts/2c7fc5c1/</url>
    
    <content type="html"><![CDATA[<p>爱上大时代elementUI</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>elementUI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue case</title>
    <link href="/posts/888f2d51/"/>
    <url>/posts/888f2d51/</url>
    
    <content type="html"><![CDATA[<p>是vueasdad</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>bootstrap case</title>
    <link href="/posts/acf88edb/"/>
    <url>/posts/acf88edb/</url>
    
    <content type="html"><![CDATA[<p>bootstrapss112</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>bootstrap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>angular case</title>
    <link href="/posts/2f5c2e2e/"/>
    <url>/posts/2f5c2e2e/</url>
    
    <content type="html"><![CDATA[<p>爱上大时代sss</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>angular</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重构法则节选(下)</title>
    <link href="/posts/915cdc75/"/>
    <url>/posts/915cdc75/</url>
    
    <content type="html"><![CDATA[<blockquote><p>重构，并不是额外动作，理应伴随开发流程。并不是无意义，如果只是堆积垃圾代码，迭代多次之后，可能原开发人员也会失去本来的方向。作为开发人员理应重视这样的份内之事。最近重读《重构-改善既有代码的设计》。还是觉得需要落到笔端，吃书也是一种学习方式吧，这里节选认为必要的内容，还是需要反复阅读才能理解其真意。学习重构，是为了减少重构。</p></blockquote><hr><h1 id="10-简化条件逻辑"><a href="#10-简化条件逻辑" class="headerlink" title="10.简化条件逻辑"></a>10.简化条件逻辑</h1><p>程序的大部分威力来自条件逻辑，但很不幸，程序的复杂度也大多来自条件逻辑。我经常借助重构把条件逻辑变得更容易理解。我常用分解条件表达式（260）处理复杂的条件表达式，用合并条件表达式（263）厘清逻辑组合。我会用以卫语句取代嵌套条件表达式（266）清晰表达“在主要处理逻辑之前先做检查”的意图。如果我发现一处 switch 逻辑处理了几种情况，可以考虑拿出以多态取代条件表达式（272）重构手法。</p><p>很多条件逻辑是用于处理特殊情况的，例如处理 null 值。如果对某种特殊情况的处理逻辑大多相同，那么可以用引入特例（289）（常被称作引入空对象）消除重复代码。另外，虽然我很喜欢去除条件逻辑，但如果我想明确地表述（以及检查）程序的状态，引入断言（302）是一个不错的补充。</p><h2 id="10-1-分解条件表达式（Decompose-Conditional）"><a href="#10-1-分解条件表达式（Decompose-Conditional）" class="headerlink" title="10.1 分解条件表达式（Decompose Conditional）"></a>10.1 分解条件表达式（Decompose Conditional）</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">if</span> (!aDate.is<span class="hljs-constructor">Before(<span class="hljs-params">plan</span>.<span class="hljs-params">summerStart</span>)</span> &amp;amp;&amp;amp; !aDate.is<span class="hljs-constructor">After(<span class="hljs-params">plan</span>.<span class="hljs-params">summerEnd</span>)</span>)<br> charge = quantity<span class="hljs-operator"> * </span>plan.summerRate;<br><span class="hljs-keyword">else</span><br> charge = quantity<span class="hljs-operator"> * </span>plan.regularRate + plan.regularServiceCharge;<br><br><br><span class="hljs-keyword">if</span> (summer<span class="hljs-literal">()</span>)<br> charge = summer<span class="hljs-constructor">Charge()</span>;<br><span class="hljs-keyword">else</span><br> charge = regular<span class="hljs-constructor">Charge()</span>;<br></code></pre></td></tr></table></figure><h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><p>程序之中，复杂的条件逻辑是最常导致复杂度上升的地点之一。我必须编写代码来检查不同的条件分支，根据不同的条件做不同的事，然后，我很快就会得到一个相当长的函数。大型函数本身就会使代码的可读性下降，而条件逻辑则会使代码更难阅读。在带有复杂条件逻辑的函数中，代码（包括检查条件分支的代码和真正实现功能的代码）会告诉我发生的事，但常常让我弄不清楚为什么会发生这样的事，这就说明代码的可读性的确大大降低了。</p><p>和任何大块头代码一样，我可以将它分解为多个独立的函数，根据每个小块代码的用途，为分解而得的新函数命名，并将原函数中对应的代码改为调用新函数，从而更清楚地表达自己的意图。对于条件逻辑，将每个分支条件分解成新函数还可以带来更多好处：可以突出条件逻辑，更清楚地表明每个分支的作用，并且突出每个分支的原因。</p><p>本重构手法其实只是提炼函数（106）的一个应用场景。但我要特别强调这个场景，因为我发现它经常会带来很大的价值。</p><h3 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h3><p>对条件判断和每个条件分支分别运用提炼函数（106）手法。</p><h3 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h3><p>假设我要计算购买某样商品的总价（总价&#x3D;数量 × 单价），而这个商品在冬季和夏季的单价是不同的：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">if</span> (!aDate.is<span class="hljs-constructor">Before(<span class="hljs-params">plan</span>.<span class="hljs-params">summerStart</span>)</span> &amp;amp;&amp;amp; !aDate.is<span class="hljs-constructor">After(<span class="hljs-params">plan</span>.<span class="hljs-params">summerEnd</span>)</span>)<br> charge = quantity<span class="hljs-operator"> * </span>plan.summerRate;<br><span class="hljs-keyword">else</span><br> charge = quantity<span class="hljs-operator"> * </span>plan.regularRate + plan.regularServiceCharge;<br></code></pre></td></tr></table></figure><p>我把条件判断提炼到一个独立的函数中：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">if</span> (summer<span class="hljs-literal">()</span>)<br> charge = quantity<span class="hljs-operator"> * </span>plan.summerRate;<br><span class="hljs-keyword">else</span><br> charge = quantity<span class="hljs-operator"> * </span>plan.regularRate + plan.regularServiceCharge;<br><br><span class="hljs-keyword">function</span> summer<span class="hljs-literal">()</span> &#123;<br> return !aDate.is<span class="hljs-constructor">Before(<span class="hljs-params">plan</span>.<span class="hljs-params">summerStart</span>)</span> &amp;amp;&amp;amp; !aDate.is<span class="hljs-constructor">After(<span class="hljs-params">plan</span>.<span class="hljs-params">summerEnd</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后提炼条件判断为真的分支：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">if</span> (summer())<br> charge = summerCharge();<br><span class="hljs-keyword">else</span><br> charge = quantity * plan.regularRate + plan.regularServiceCharge;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title">summer</span>() &#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-type">!aDate.isBefore(plan.summerStart)</span> &amp;amp;&amp;amp; !aDate.isAfter(plan.summerEnd);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title">summerCharge</span>() &#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-type">quantity</span> * plan.summerRate;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后提炼条件判断为假的分支：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">if</span> (summer())<br> charge = summerCharge();<br><span class="hljs-keyword">else</span><br> charge = regularCharge();<br><br><span class="hljs-keyword">function</span> <span class="hljs-title">summer</span>() &#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-type">!aDate.isBefore(plan.summerStart)</span> &amp;amp;&amp;amp; !aDate.isAfter(plan.summerEnd);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title">summerCharge</span>() &#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-type">quantity</span> * plan.summerRate;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title">regularCharge</span>() &#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-type">quantity</span> * plan.regularRate + plan.regularServiceCharge;<br>&#125;<br></code></pre></td></tr></table></figure><p>提炼完成后，我喜欢用三元运算符重新安排条件语句。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ada">  charge = summer() ? summerCharge() : <span class="hljs-type">regularCharge</span>();<br><br><span class="hljs-keyword">function</span> <span class="hljs-title">summer</span>() &#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-type">!aDate.isBefore(plan.summerStart)</span> &amp;amp;&amp;amp; !aDate.isAfter(plan.summerEnd);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title">summerCharge</span>() &#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-type">quantity</span> * plan.summerRate;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title">regularCharge</span>() &#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-type">quantity</span> * plan.regularRate + plan.regularServiceCharge;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="10-2-合并条件表达式（Consolidate-Conditional-Expression）"><a href="#10-2-合并条件表达式（Consolidate-Conditional-Expression）" class="headerlink" title="10.2 合并条件表达式（Consolidate Conditional Expression）"></a>10.2 合并条件表达式（Consolidate Conditional Expression）</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">if</span> (anEmployee.seniority &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (anEmployee.monthsDisabled &gt; <span class="hljs-number">12</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (anEmployee.isPartTime) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br><br><span class="hljs-keyword">if</span> (isNotEligibleForDisability()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>function isNotEligibleForDisability() &#123;<br> <span class="hljs-keyword">return</span> ((anEmployee.seniority &lt; <span class="hljs-number">2</span>)<br>     || (anEmployee.monthsDisabled &gt; <span class="hljs-number">12</span>)<br>     || (anEmployee.isPartTime));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="动机-1"><a href="#动机-1" class="headerlink" title="动机"></a>动机</h3><p>有时我会发现这样一串条件检查：检查条件各不相同，最终行为却一致。如果发现这种情况，就应该使用“逻辑或”和“逻辑与”将它们合并为一个条件表达式。</p><p>之所以要合并条件代码，有两个重要原因。首先，合并后的条件代码会表述“实际上只有一次条件检查，只不过有多个并列条件需要检查而已”，从而使这一次检查的用意更清晰。当然，合并前和合并后的代码有着相同的效果，但原先代码传达出的信息却是“这里有一些各自独立的条件测试，它们只是恰好同时发生”。其次，这项重构往往可以为使用提炼函数（106）做好准备。将检查条件提炼成一个独立的函数对于厘清代码意义非常有用，因为它把描述“做什么”的语句换成了“为什么这样做”。</p><p>条件语句的合并理由也同时指出了不要合并的理由：如果我认为这些检查的确彼此独立，的确不应该被视为同一次检查，我就不会使用本项重构。</p><h3 id="做法-1"><a href="#做法-1" class="headerlink" title="做法"></a>做法</h3><p>确定这些条件表达式都没有副作用。</p><p>如果某个条件表达式有副作用，可以先用将查询函数和修改函数分离（306）处理。</p><p>使用适当的逻辑运算符，将两个相关条件表达式合并为一个。</p><p>顺序执行的条件表达式用逻辑或来合并，嵌套的 if 语句用逻辑与来合并。</p><p>测试。</p><p>重复前面的合并过程，直到所有相关的条件表达式都合并到一起。</p><p>可以考虑对合并后的条件表达式实施提炼函数（106）。</p><h3 id="范例-1"><a href="#范例-1" class="headerlink" title="范例"></a>范例</h3><p>在走读代码的过程中，我看到了下面的代码片段：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">function disabilityAmount(anEmployee) &#123;<br> <span class="hljs-keyword">if</span> (anEmployee.seniority &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> <span class="hljs-keyword">if</span> (anEmployee.monthsDisabled &gt; <span class="hljs-number">12</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> <span class="hljs-keyword">if</span> (anEmployee.isPartTime) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> <span class="hljs-comment">// compute the disability amount</span><br></code></pre></td></tr></table></figure><p>这里有一连串的条件检查，都指向同样的结果。既然结果是相同的，就应该把这些条件检查合并成一条表达式。对于这样顺序执行的条件检查，可以用逻辑或运算符来合并。</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-variable">function</span> <span class="hljs-title function_">disabilityAmount</span>(<span class="hljs-params">anEmployee</span>) &#123;<br> <span class="hljs-keyword">if</span> ((<span class="hljs-variable">anEmployee</span>.<span class="hljs-property">seniority</span> <span class="hljs-operator">&lt;</span> <span class="hljs-number">2</span>)<br>   <span class="hljs-operator">||</span> (<span class="hljs-variable">anEmployee</span>.<span class="hljs-property">monthsDisabled</span> <span class="hljs-operator">&gt;</span> <span class="hljs-number">12</span>)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> <span class="hljs-keyword">if</span> (<span class="hljs-variable">anEmployee</span>.<span class="hljs-property">isPartTime</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> <span class="hljs-comment">// compute the disability amount</span><br></code></pre></td></tr></table></figure><p>测试，然后把下一个条件检查也合并进来：</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-variable">function</span> <span class="hljs-title function_">disabilityAmount</span>(<span class="hljs-params">anEmployee</span>) &#123;<br> <span class="hljs-keyword">if</span> ((<span class="hljs-variable">anEmployee</span>.<span class="hljs-property">seniority</span> <span class="hljs-operator">&lt;</span> <span class="hljs-number">2</span>)<br>   <span class="hljs-operator">||</span> (<span class="hljs-variable">anEmployee</span>.<span class="hljs-property">monthsDisabled</span> <span class="hljs-operator">&gt;</span> <span class="hljs-number">12</span>)<br>   <span class="hljs-operator">||</span> (<span class="hljs-variable">anEmployee</span>.<span class="hljs-property">isPartTime</span>)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> <span class="hljs-comment">// compute the disability amount</span><br></code></pre></td></tr></table></figure><p>合并完成后，再对这句条件表达式使用提炼函数（106）。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">disabilityAmount</span>(anEmployee) &#123;<br> if (<span class="hljs-keyword">is</span>NotEligableForDisability()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> // compute the disability amount<br><br><span class="hljs-keyword">function</span> <span class="hljs-title">isNotEligableForDisability</span>() &#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-type">((anEmployee.seniority</span> &lt; <span class="hljs-number">2</span>)<br>     || (anEmployee.monthsDisabled &gt; <span class="hljs-number">12</span>)<br>     || (anEmployee.isPartTime));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="范例：使用逻辑与"><a href="#范例：使用逻辑与" class="headerlink" title="范例：使用逻辑与"></a>范例：使用逻辑与</h3><p>上面的例子展示了用逻辑或合并条件表达式的做法。不过，我有可能遇到需要逻辑与的情况。例如，嵌套 if 语句的情况：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">if</span> (anEmployee.onVacation)<br> <span class="hljs-attribute">if</span> (anEmployee.seniority &gt; <span class="hljs-number">10</span>)<br>  <span class="hljs-attribute">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-attribute">return</span> <span class="hljs-number">0</span>.<span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><p>可以用逻辑与运算符将其合并。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">if</span> ((anEmployee.onVacation)<br>  &amp;amp;&amp;amp; (anEmployee.seniority &gt; <span class="hljs-number">10</span>)) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0.5</span>;<br></code></pre></td></tr></table></figure><p>如果原来的条件逻辑混杂了这两种情况，我也会根据需要组合使用逻辑与和逻辑或运算符。在这种时候，代码很可能变得混乱，所以我会频繁使用提炼函数（106），把代码变得可读。</p><h2 id="10-3-以卫语句取代嵌套条件表达式（Replace-Nested-Conditional-with-Guard-Clauses）"><a href="#10-3-以卫语句取代嵌套条件表达式（Replace-Nested-Conditional-with-Guard-Clauses）" class="headerlink" title="10.3 以卫语句取代嵌套条件表达式（Replace Nested Conditional with Guard Clauses）"></a>10.3 以卫语句取代嵌套条件表达式（Replace Nested Conditional with Guard Clauses）</h2><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">function</span> <span class="hljs-function"><span class="hljs-title">getPayAmount</span>() &#123;</span><br><span class="hljs-function">  <span class="hljs-variable">let</span> <span class="hljs-variable"><span class="hljs-class">result</span></span>;</span><br><span class="hljs-function">  <span class="hljs-variable"><span class="hljs-keyword">if</span></span> (<span class="hljs-variable">isDead</span>) <span class="hljs-variable"><span class="hljs-class">result</span></span> = <span class="hljs-title">deadAmount</span>();</span><br><span class="hljs-function">  <span class="hljs-variable"><span class="hljs-keyword">else</span></span> &#123;</span><br><span class="hljs-function">    <span class="hljs-variable"><span class="hljs-keyword">if</span></span> (<span class="hljs-variable">isSeparated</span>) <span class="hljs-variable"><span class="hljs-class">result</span></span> = <span class="hljs-title">separatedAmount</span>();</span><br><span class="hljs-function">    <span class="hljs-variable"><span class="hljs-keyword">else</span></span> &#123;</span><br><span class="hljs-function">      <span class="hljs-variable"><span class="hljs-keyword">if</span></span> (<span class="hljs-variable">isRetired</span>) <span class="hljs-variable"><span class="hljs-class">result</span></span> = <span class="hljs-title">retiredAmount</span>();</span><br><span class="hljs-function">      <span class="hljs-variable"><span class="hljs-keyword">else</span></span> <span class="hljs-variable"><span class="hljs-class">result</span></span> = <span class="hljs-title">normalPayAmount</span>();</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function">  &#125;</span><br><span class="hljs-function">  <span class="hljs-variable">return</span> <span class="hljs-variable"><span class="hljs-class">result</span></span>;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-variable">function</span> <span class="hljs-title">getPayAmount</span>() &#123;</span><br><span class="hljs-function">  <span class="hljs-variable"><span class="hljs-keyword">if</span></span> (<span class="hljs-variable">isDead</span>) <span class="hljs-variable">return</span> <span class="hljs-title">deadAmount</span>();</span><br><span class="hljs-function">  <span class="hljs-variable"><span class="hljs-keyword">if</span></span> (<span class="hljs-variable">isSeparated</span>) <span class="hljs-variable">return</span> <span class="hljs-title">separatedAmount</span>();</span><br><span class="hljs-function">  <span class="hljs-variable"><span class="hljs-keyword">if</span></span> (<span class="hljs-variable">isRetired</span>) <span class="hljs-variable">return</span> <span class="hljs-title">retiredAmount</span>();</span><br><span class="hljs-function">  <span class="hljs-variable">return</span> <span class="hljs-title">normalPayAmount</span>();</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="动机-2"><a href="#动机-2" class="headerlink" title="动机"></a>动机</h3><p>根据我的经验，条件表达式通常有两种风格。第一种风格是：两个条件分支都属于正常行为。第二种风格则是：只有一个条件分支是正常行为，另一个分支则是异常的情况。</p><p>这两类条件表达式有不同的用途，这一点应该通过代码表现出来。如果两条分支都是正常行为，就应该使用形如 if…else…的条件表达式；如果某个条件极其罕见，就应该单独检查该条件，并在该条件为真时立刻从函数中返回。这样的单独检查常常被称为“卫语句”（guard clauses）。</p><p>以卫语句取代嵌套条件表达式的精髓就是：给某一条分支以特别的重视。如果使用 if-then-else 结构，你对 if 分支和 else 分支的重视是同等的。这样的代码结构传递给阅读者的消息就是：各个分支有同样的重要性。卫语句就不同了，它告诉阅读者：“这种情况不是本函数的核心逻辑所关心的，如果它真发生了，请做一些必要的整理工作，然后退出。”</p><p>“每个函数只能有一个入口和一个出口”的观念，根深蒂固于某些程序员的脑海里。我发现，当我处理他们编写的代码时，经常需要使用以卫语句取代嵌套条件表达式。现今的编程语言都会强制保证每个函数只有一个入口，至于“单一出口”规则，其实不是那么有用。在我看来，保持代码清晰才是最关键的：如果单一出口能使这个函数更清楚易读，那么就使用单一出口；否则就不必这么做。</p><h3 id="做法-2"><a href="#做法-2" class="headerlink" title="做法"></a>做法</h3><p>选中最外层需要被替换的条件逻辑，将其替换为卫语句。</p><p>测试。</p><p>有需要的话，重复上述步骤。</p><p>如果所有卫语句都引发同样的结果，可以使用合并条件表达式（263）合并之。</p><h3 id="范例-2"><a href="#范例-2" class="headerlink" title="范例"></a>范例</h3><p>下面的代码用于计算要支付给员工（employee）的工资。只有还在公司上班的员工才需要支付工资，所以这个函数需要检查两种“员工已经不在公司上班”的情况。</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs nim">function payAmount(employee) &#123;<br> <span class="hljs-keyword">let</span> <span class="hljs-built_in">result</span>;<br> <span class="hljs-keyword">if</span>(employee.isSeparated) &#123;<br>  <span class="hljs-built_in">result</span> = &#123;amount: <span class="hljs-number">0</span>, reasonCode:<span class="hljs-string">&quot;SEP&quot;</span>&#125;;<br> &#125;<br> <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-keyword">if</span> (employee.isRetired) &#123;<br>   <span class="hljs-built_in">result</span> = &#123;amount: <span class="hljs-number">0</span>, reasonCode: <span class="hljs-string">&quot;RET&quot;</span>&#125;;<br>  &#125;<br>  <span class="hljs-keyword">else</span> &#123;<br>   // logic to compute amount<br>   lorem.ipsum(dolor.sitAmet);<span class="hljs-number">1</span><br>   consectetur(adipiscing).elit();<br>   sed.<span class="hljs-keyword">do</span>.eiusmod = tempor.incididunt.ut(labore) &amp;amp;&amp;amp; dolore(magna.aliqua);<br>   ut.enim.ad(minim.veniam);<br>   <span class="hljs-built_in">result</span> = someFinalComputation();<br>  &#125;<br> &#125;<br> <span class="hljs-keyword">return</span> <span class="hljs-built_in">result</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>嵌套的条件逻辑让我们看不清代码真实的含义。只有当前两个条件表达式都不为真的时候，这段代码才真正开始它的主要工作。所以，卫语句能让代码更清晰地阐述自己的意图。</p><p>一如既往地，我喜欢小步前进，所以我先处理最顶上的条件逻辑。</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs nim">function payAmount(employee) &#123;<br> <span class="hljs-keyword">let</span> <span class="hljs-built_in">result</span>;<br> <span class="hljs-keyword">if</span> (employee.isSeparated) <span class="hljs-keyword">return</span> &#123;amount: <span class="hljs-number">0</span>, reasonCode: <span class="hljs-string">&quot;SEP&quot;</span>&#125;;<br> <span class="hljs-keyword">if</span> (employee.isRetired) &#123;<br>  <span class="hljs-built_in">result</span> = &#123;amount: <span class="hljs-number">0</span>, reasonCode: <span class="hljs-string">&quot;RET&quot;</span>&#125;;<br> &#125;<br> <span class="hljs-keyword">else</span> &#123;<br>  // logic to compute amount<br>  lorem.ipsum(dolor.sitAmet);<br>  consectetur(adipiscing).elit();<br>  sed.<span class="hljs-keyword">do</span>.eiusmod = tempor.incididunt.ut(labore) &amp;amp;&amp;amp; dolore(magna.aliqua);<br>  ut.enim.ad(minim.veniam);<br>  <span class="hljs-built_in">result</span> = someFinalComputation();<br> &#125;<br> <span class="hljs-keyword">return</span> <span class="hljs-built_in">result</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>做完这步修改，我执行测试，然后继续下一步。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">function payAmount(employee) &#123;<br> let result;<br> <span class="hljs-keyword">if</span> (employee.isSeparated) <span class="hljs-keyword">return</span> &#123;amount: <span class="hljs-number">0</span>, reasonCode: <span class="hljs-string">&quot;SEP&quot;</span>&#125;;<br> <span class="hljs-keyword">if</span> (employee.isRetired)   <span class="hljs-keyword">return</span> &#123;amount: <span class="hljs-number">0</span>, reasonCode: <span class="hljs-string">&quot;RET&quot;</span>&#125;;<br> <span class="hljs-comment">// logic to compute amount</span><br> lorem.ipsum(dolor.sitAmet);<br> consectetur(adipiscing).elit();<br> sed.<span class="hljs-keyword">do</span>.eiusmod = tempor.incididunt.ut(labore) &amp;amp;&amp;amp; dolore(magna.aliqua);<br> ut.enim.ad(minim.veniam);<br> result = someFinalComputation();<br> <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时，result 变量已经没有用处了，所以我把它删掉：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">function payAmount(employee) &#123;<br> let result;<br> <span class="hljs-keyword">if</span> (employee.isSeparated) <span class="hljs-keyword">return</span> &#123;amount: <span class="hljs-number">0</span>, reasonCode: <span class="hljs-string">&quot;SEP&quot;</span>&#125;;<br> <span class="hljs-keyword">if</span> (employee.isRetired)   <span class="hljs-keyword">return</span> &#123;amount: <span class="hljs-number">0</span>, reasonCode: <span class="hljs-string">&quot;RET&quot;</span>&#125;;<br> <span class="hljs-comment">// logic to compute amount</span><br> lorem.ipsum(dolor.sitAmet);<br> consectetur(adipiscing).elit();<br> sed.<span class="hljs-keyword">do</span>.eiusmod = tempor.incididunt.ut(labore) &amp;amp;&amp;amp; dolore(magna.aliqua);<br> ut.enim.ad(minim.veniam);<br> <span class="hljs-keyword">return</span> someFinalComputation();<br>&#125;<br></code></pre></td></tr></table></figure><p>能减少一个可变变量总是好的。</p><h3 id="范例：将条件反转"><a href="#范例：将条件反转" class="headerlink" title="范例：将条件反转"></a>范例：将条件反转</h3><p>审阅本书第 1 版的初稿时，Joshua Kerievsky 指出：我们常常可以将条件表达式反转，从而实现以卫语句取代嵌套条件表达式。为了拯救我可怜的想象力，他还好心帮我想了一个例子：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">adjustedCapital</span>(anInstrument) &#123;<br> let result = 0;<br> if (anInstrument.capital &gt; 0) &#123;<br>  if (anInstrument.interestRate &gt; 0 &amp;amp;&amp;amp; anInstrument.duration &gt; 0) &#123;<br>   result = (anInstrument.income / anInstrument.duration) * anInstrument.adjustmentFactor;<br>  &#125;<br> &#125;<br> <span class="hljs-keyword">return</span> <span class="hljs-type">result</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样地，我逐一进行替换。不过这次在插入卫语句时，我需要将相应的条件反转过来：</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nim">function adjustedCapital(anInstrument) &#123;<br> <span class="hljs-keyword">let</span> <span class="hljs-built_in">result</span> = <span class="hljs-number">0</span>;<br> <span class="hljs-keyword">if</span> (anInstrument.capital &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">result</span>;<br> <span class="hljs-keyword">if</span> (anInstrument.interestRate &gt; <span class="hljs-number">0</span> &amp;amp;&amp;amp; anInstrument.duration &gt; <span class="hljs-number">0</span>) &#123;<br>  <span class="hljs-built_in">result</span> = (anInstrument.income / anInstrument.duration) * anInstrument.adjustmentFactor;<br> &#125;<br> <span class="hljs-keyword">return</span> <span class="hljs-built_in">result</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>下一个条件稍微复杂一点，所以我分两步进行反转。首先加入一个逻辑非操作：</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nim">function adjustedCapital(anInstrument) &#123;<br> <span class="hljs-keyword">let</span> <span class="hljs-built_in">result</span> = <span class="hljs-number">0</span>;<br> <span class="hljs-keyword">if</span> (anInstrument.capital &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">result</span>;<br> <span class="hljs-keyword">if</span> (!(anInstrument.interestRate &gt; <span class="hljs-number">0</span> &amp;amp;&amp;amp; anInstrument.duration &gt; <span class="hljs-number">0</span>)) <span class="hljs-keyword">return</span> <span class="hljs-built_in">result</span>;<br> <span class="hljs-built_in">result</span> = (anInstrument.income / anInstrument.duration) * anInstrument.adjustmentFactor;<br> <span class="hljs-keyword">return</span> <span class="hljs-built_in">result</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是在这样的条件表达式中留下一个逻辑非，会把我的脑袋拧成一团乱麻，所以我把它简化成下面这样：</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nim">  function adjustedCapital(anInstrument) &#123;<br> <span class="hljs-keyword">let</span> <span class="hljs-built_in">result</span> = <span class="hljs-number">0</span>;<br> <span class="hljs-keyword">if</span> (anInstrument.capital &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">result</span>;<br> <span class="hljs-keyword">if</span> (anInstrument.interestRate &lt;= <span class="hljs-number">0</span> || anInstrument.duration &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">result</span>;<br> <span class="hljs-built_in">result</span> = (anInstrument.income / anInstrument.duration) * anInstrument.adjustmentFactor;<br> <span class="hljs-keyword">return</span> <span class="hljs-built_in">result</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这两行逻辑语句引发的结果一样，所以我可以用合并条件表达式（263）将其合并。</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nim">function adjustedCapital(anInstrument) &#123;<br> <span class="hljs-keyword">let</span> <span class="hljs-built_in">result</span> = <span class="hljs-number">0</span>;<br> <span class="hljs-keyword">if</span> (   anInstrument.capital      &lt;= <span class="hljs-number">0</span><br>   || anInstrument.interestRate &lt;= <span class="hljs-number">0</span><br>   || anInstrument.duration     &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">result</span>;<br> <span class="hljs-built_in">result</span> = (anInstrument.income / anInstrument.duration) * anInstrument.adjustmentFactor;<br> <span class="hljs-keyword">return</span> <span class="hljs-built_in">result</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时 result 变量做了两件事：一开始我把它设为 0，代表卫语句被触发时的返回值；然后又用最终计算的结果给它赋值。我可以彻底移除这个变量，避免用一个变量承担两重责任，而且又减少了一个可变变量。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">adjustedCapital</span>(anInstrument) &#123;<br> if (   anInstrument.capital     &lt;= 0<br>   || anInstrument.interestRate &lt;= 0<br>   || anInstrument.duration   &lt;= 0) <span class="hljs-keyword">return</span> <span class="hljs-type">0</span>;<br> <span class="hljs-keyword">return</span> (anInstrument.income / anInstrument.duration) * anInstrument.adjustmentFactor;<br>&#125;<br></code></pre></td></tr></table></figure><p>1 “lorem.ipsum……”是一篇常见于排版设计领域的文章，其内容为不具可读性的字符组合，目的是使阅读者只专注于观察段落的字型和版型。——译者注</p><h2 id="10-4-以多态取代条件表达式（Replace-Conditional-with-Polymorphism）"><a href="#10-4-以多态取代条件表达式（Replace-Conditional-with-Polymorphism）" class="headerlink" title="10.4 以多态取代条件表达式（Replace Conditional with Polymorphism）"></a>10.4 以多态取代条件表达式（Replace Conditional with Polymorphism）</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">switch (bird.type) &#123;<br> case <span class="hljs-string">&#x27;EuropeanSwallow&#x27;</span>:<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;average&quot;</span>;<br> case <span class="hljs-string">&#x27;AfricanSwallow&#x27;</span>:<br>  <span class="hljs-keyword">return</span> (bird.numberOfCoconuts &gt; <span class="hljs-number">2</span>) ? <span class="hljs-string">&quot;tired&quot;</span> : <span class="hljs-string">&quot;average&quot;</span>;<br> case <span class="hljs-string">&#x27;NorwegianBlueParrot&#x27;</span>:<br>  <span class="hljs-keyword">return</span> (bird.voltage &gt; <span class="hljs-number">100</span>) ? <span class="hljs-string">&quot;scorched&quot;</span> : <span class="hljs-string">&quot;beautiful&quot;</span>;<br> default:<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;unknown&quot;</span>;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EuropeanSwallow</span> &#123;<br> <span class="hljs-keyword">get</span> plumage() &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;average&quot;</span>;<br> &#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AfricanSwallow</span> &#123;<br> <span class="hljs-keyword">get</span> plumage() &#123;<br>   <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.numberOfCoconuts &gt; <span class="hljs-number">2</span>) ? <span class="hljs-string">&quot;tired&quot;</span> : <span class="hljs-string">&quot;average&quot;</span>;<br> &#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NorwegianBlueParrot</span> &#123;<br> <span class="hljs-keyword">get</span> plumage() &#123;<br>   <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.voltage &gt; <span class="hljs-number">100</span>) ? <span class="hljs-string">&quot;scorched&quot;</span> : <span class="hljs-string">&quot;beautiful&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="动机-3"><a href="#动机-3" class="headerlink" title="动机"></a>动机</h3><p>复杂的条件逻辑是编程中最难理解的东西之一，因此我一直在寻求给条件逻辑添加结构。很多时候，我发现可以将条件逻辑拆分到不同的场景（或者叫高阶用例），从而拆解复杂的条件逻辑。这种拆分有时用条件逻辑本身的结构就足以表达，但使用类和多态能把逻辑的拆分表述得更清晰。</p><p>一个常见的场景是：我可以构造一组类型，每个类型处理各自的一种条件逻辑。例如，我会注意到，图书、音乐、食品的处理方式不同，这是因为它们分属不同类型的商品。最明显的征兆就是有好几个函数都有基于类型代码的 switch 语句。若果真如此，我就可以针对 switch 语句中的每种分支逻辑创建一个类，用多态来承载各个类型特有的行为，从而去除重复的分支逻辑。</p><p>另一种情况是：有一个基础逻辑，在其上又有一些变体。基础逻辑可能是最常用的，也可能是最简单的。我可以把基础逻辑放进超类，这样我可以首先理解这部分逻辑，暂时不管各种变体，然后我可以把每种变体逻辑单独放进一个子类，其中的代码着重强调与基础逻辑的差异。</p><p>多态是面向对象编程的关键特性之一。跟其他一切有用的特性一样，它也很容易被滥用。我曾经遇到有人争论说所有条件逻辑都应该用多态取代。我不赞同这种观点。我的大部分条件逻辑只用到了基本的条件语句——if&#x2F;else 和 switch&#x2F;case，并不需要劳师动众地引入多态。但如果发现如前所述的复杂条件逻辑，多态是改善这种情况的有力工具。</p><h3 id="做法-3"><a href="#做法-3" class="headerlink" title="做法"></a>做法</h3><p>如果现有的类尚不具备多态行为，就用工厂函数创建之，令工厂函数返回恰当的对象实例。</p><p>在调用方代码中使用工厂函数获得对象实例。</p><p>将带有条件逻辑的函数移到超类中。</p><p>如果条件逻辑还未提炼至独立的函数，首先对其使用提炼函数（106）。</p><p>任选一个子类，在其中建立一个函数，使之覆写超类中容纳条件表达式的那个函数。将与该子类相关的条件表达式分支复制到新函数中，并对它进行适当调整。</p><p>重复上述过程，处理其他条件分支。</p><p>在超类函数中保留默认情况的逻辑。或者，如果超类应该是抽象的，就把该函数声明为 abstract，或在其中直接抛出异常，表明计算责任都在子类中。</p><h3 id="范例-3"><a href="#范例-3" class="headerlink" title="范例"></a>范例</h3><p>我的朋友有一群鸟儿，他想知道这些鸟飞得有多快，以及它们的羽毛是什么样的。所以我们写了一小段程序来判断这些信息。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">plumages</span>(<span class="hljs-params">birds</span>) &#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>(birds.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">b</span> =&gt;</span> [b.<span class="hljs-property">name</span>, <span class="hljs-title function_">plumage</span>(b)]));<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">speeds</span>(<span class="hljs-params">birds</span>) &#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>(birds.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">b</span> =&gt;</span> [b.<span class="hljs-property">name</span>, <span class="hljs-title function_">airSpeedVelocity</span>(b)]));<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">plumage</span>(<span class="hljs-params">bird</span>) &#123;<br> <span class="hljs-keyword">switch</span> (bird.<span class="hljs-property">type</span>) &#123;<br> <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;EuropeanSwallow&#x27;</span>:<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;average&quot;</span>;<br> <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;AfricanSwallow&#x27;</span>:<br>  <span class="hljs-keyword">return</span> (bird.<span class="hljs-property">numberOfCoconuts</span> &gt; <span class="hljs-number">2</span>) ? <span class="hljs-string">&quot;tired&quot;</span> : <span class="hljs-string">&quot;average&quot;</span>;<br> <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;NorwegianBlueParrot&#x27;</span>:<br>  <span class="hljs-keyword">return</span> (bird.<span class="hljs-property">voltage</span> &gt; <span class="hljs-number">100</span>) ? <span class="hljs-string">&quot;scorched&quot;</span> : <span class="hljs-string">&quot;beautiful&quot;</span>;<br> <span class="hljs-attr">default</span>:<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;unknown&quot;</span>;<br> &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">airSpeedVelocity</span>(<span class="hljs-params">bird</span>) &#123;<br> <span class="hljs-keyword">switch</span> (bird.<span class="hljs-property">type</span>) &#123;<br> <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;EuropeanSwallow&#x27;</span>:<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">35</span>;<br> <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;AfricanSwallow&#x27;</span>:<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">40</span> - <span class="hljs-number">2</span> * bird.<span class="hljs-property">numberOfCoconuts</span>;<br> <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;NorwegianBlueParrot&#x27;</span>:<br>  <span class="hljs-keyword">return</span> (bird.<span class="hljs-property">isNailed</span>) ? <span class="hljs-number">0</span> : <span class="hljs-number">10</span> + bird.<span class="hljs-property">voltage</span> / <span class="hljs-number">10</span>;<br> <span class="hljs-attr">default</span>:<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>有两个不同的操作，其行为都随着“鸟的类型”发生变化，因此可以创建出对应的类，用多态来处理各类型特有的行为。</p><p>我先对 airSpeedVelocity 和 plumage 两个函数使用函数组合成类（144）。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">function plumage(bird) &#123;<br> <span class="hljs-keyword">return</span> new Bird(bird).plumage;<br>&#125;<br><br>function airSpeedVelocity(bird) &#123;<br> <span class="hljs-keyword">return</span> new Bird(bird).airSpeedVelocity;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bird</span> &#123;<br> <span class="hljs-keyword">constructor</span>(birdObject) &#123;<br>  Object.assign(<span class="hljs-keyword">this</span>, birdObject);<br> &#125;<br> <span class="hljs-keyword">get</span> plumage() &#123;<br>  switch (<span class="hljs-keyword">this</span>.type) &#123;<br>  case <span class="hljs-string">&#x27;EuropeanSwallow&#x27;</span>:<br>   <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;average&quot;</span>;<br>  case <span class="hljs-string">&#x27;AfricanSwallow&#x27;</span>:<br>   <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.numberOfCoconuts &gt; <span class="hljs-number">2</span>) ? <span class="hljs-string">&quot;tired&quot;</span> : <span class="hljs-string">&quot;average&quot;</span>;<br>  case <span class="hljs-string">&#x27;NorwegianBlueParrot&#x27;</span>:<br>   <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.voltage &gt; <span class="hljs-number">100</span>) ? <span class="hljs-string">&quot;scorched&quot;</span> : <span class="hljs-string">&quot;beautiful&quot;</span>;<br>  default:<br>   <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;unknown&quot;</span>;<br>  &#125;<br> &#125;<br> <span class="hljs-keyword">get</span> airSpeedVelocity() &#123;<br>  switch (<span class="hljs-keyword">this</span>.type) &#123;<br>  case <span class="hljs-string">&#x27;EuropeanSwallow&#x27;</span>:<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">35</span>;<br>  case <span class="hljs-string">&#x27;AfricanSwallow&#x27;</span>:<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">40</span> - <span class="hljs-number">2</span> * <span class="hljs-keyword">this</span>.numberOfCoconuts;<br>  case <span class="hljs-string">&#x27;NorwegianBlueParrot&#x27;</span>:<br>   <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.isNailed) ? <span class="hljs-number">0</span> : <span class="hljs-number">10</span> + <span class="hljs-keyword">this</span>.voltage / <span class="hljs-number">10</span>;<br>  default:<br>   <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后针对每种鸟创建一个子类，用一个工厂函数来实例化合适的子类对象。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs scala">function plumage(bird) &#123;<br>  <span class="hljs-keyword">return</span> createBird(bird).plumage;<br>&#125;<br><br>function airSpeedVelocity(bird) &#123;<br>  <span class="hljs-keyword">return</span> createBird(bird).airSpeedVelocity;<br>&#125;<br><br>function createBird(bird) &#123;<br>  switch (bird.<span class="hljs-keyword">type</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;EuropeanSwallow&quot;</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">EuropeanSwallow</span>(bird);<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;AfricanSwallow&quot;</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">AfricanSwallow</span>(bird);<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;NorweigianBlueParrot&quot;</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">NorwegianBlueParrot</span>(bird);<br>    <span class="hljs-keyword">default</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">Bird</span>(bird);<br>  &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EuropeanSwallow</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Bird</span> </span>&#123;&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AfricanSwallow</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Bird</span> </span>&#123;&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NorwegianBlueParrot</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Bird</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>现在我已经有了需要的类结构，可以处理两个条件逻辑了。先从 plumage 函数开始，我从 switch 语句中选一个分支，在适当的子类中覆写这个逻辑。</p><p><strong>class EuropeanSwallow…</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">get</span> <span class="hljs-title">plumage</span>()</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;average&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>class Bird…</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">get</span> <span class="hljs-title">plumage</span>()</span> &#123;<br> <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">this</span>.type) &#123;<br> <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;EuropeanSwallow&#x27;</span>:<br>  <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;oops&quot;</span>;<br> <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;AfricanSwallow&#x27;</span>:<br>  <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.numberOfCoconuts &gt; <span class="hljs-number">2</span>) ? <span class="hljs-string">&quot;tired&quot;</span> : <span class="hljs-string">&quot;average&quot;</span>;<br> <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;NorwegianBlueParrot&#x27;</span>:<br>  <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.voltage &gt; <span class="hljs-number">100</span>) ? <span class="hljs-string">&quot;scorched&quot;</span> : <span class="hljs-string">&quot;beautiful&quot;</span>;<br> <span class="hljs-literal">default</span>:<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;unknown&quot;</span>;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在超类中，我把对应的逻辑分支改为抛出异常，因为我总是偏执地担心出错。</p><p>此时我就可以编译并测试。如果一切顺利的话，我可以接着处理下一个分支。</p><p><strong>class AfricanSwallow…</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">get</span> <span class="hljs-title">plumage</span>()</span> &#123;<br>   <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.numberOfCoconuts &gt; <span class="hljs-number">2</span>) ? <span class="hljs-string">&quot;tired&quot;</span> : <span class="hljs-string">&quot;average&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后是挪威蓝鹦鹉（Norwegian Blue）的分支。</p><p><strong>class NorwegianBlueParrot…</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">get</span> <span class="hljs-title">plumage</span>()</span> &#123;<br>   <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.voltage &gt;<span class="hljs-number">100</span>) ? <span class="hljs-string">&quot;scorched&quot;</span> : <span class="hljs-string">&quot;beautiful&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>超类函数保留下来处理默认情况。</p><p><strong>class Bird…</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">get</span> <span class="hljs-title">plumage</span>()</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;unknown&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>airSpeedVelocity 也如法炮制。完成以后，代码大致如下（我还对顶层的 airSpeedVelocity 和 plumage 函数做了内联处理）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">plumages</span>(<span class="hljs-params">birds</span>) &#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>(birds<br>         .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">b</span> =&gt;</span> <span class="hljs-title function_">createBird</span>(b))<br>         .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">bird</span> =&gt;</span> [bird.<span class="hljs-property">name</span>, bird.<span class="hljs-property">plumage</span>]));<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">speeds</span>(<span class="hljs-params">birds</span>) &#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>(birds<br>         .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">b</span> =&gt;</span> <span class="hljs-title function_">createBird</span>(b))<br>         .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">bird</span> =&gt;</span> [bird.<span class="hljs-property">name</span>, bird.<span class="hljs-property">airSpeedVelocity</span>]));<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createBird</span>(<span class="hljs-params">bird</span>) &#123;<br> <span class="hljs-keyword">switch</span> (bird.<span class="hljs-property">type</span>) &#123;<br> <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;EuropeanSwallow&#x27;</span>:<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EuropeanSwallow</span>(bird);<br> <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;AfricanSwallow&#x27;</span>:<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AfricanSwallow</span>(bird);<br> <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;NorwegianBlueParrot&#x27;</span>:<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NorwegianBlueParrot</span>(bird);<br> <span class="hljs-attr">default</span>:<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bird</span>(bird);<br> &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bird</span> &#123;<br> <span class="hljs-title function_">constructor</span>(<span class="hljs-params">birdObject</span>) &#123;<br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(<span class="hljs-variable language_">this</span>, birdObject);<br> &#125;<br> <span class="hljs-keyword">get</span> <span class="hljs-title function_">plumage</span>() &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;unknown&quot;</span>;<br> &#125;<br> <span class="hljs-keyword">get</span> <span class="hljs-title function_">airSpeedVelocity</span>() &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br> &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EuropeanSwallow</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Bird</span> &#123;<br> <span class="hljs-keyword">get</span> <span class="hljs-title function_">plumage</span>() &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;average&quot;</span>;<br> &#125;<br> <span class="hljs-keyword">get</span> <span class="hljs-title function_">airSpeedVelocity</span>() &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">35</span>;<br> &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AfricanSwallow</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Bird</span> &#123;<br> <span class="hljs-keyword">get</span> <span class="hljs-title function_">plumage</span>() &#123;<br>  <span class="hljs-keyword">return</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">numberOfCoconuts</span> &gt; <span class="hljs-number">2</span>) ? <span class="hljs-string">&quot;tired&quot;</span> : <span class="hljs-string">&quot;average&quot;</span>;<br> &#125;<br> <span class="hljs-keyword">get</span> <span class="hljs-title function_">airSpeedVelocity</span>() &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">40</span> - <span class="hljs-number">2</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">numberOfCoconuts</span>;<br> &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NorwegianBlueParrot</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Bird</span> &#123;<br> <span class="hljs-keyword">get</span> <span class="hljs-title function_">plumage</span>() &#123;<br>  <span class="hljs-keyword">return</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">voltage</span> &gt; <span class="hljs-number">100</span>) ? <span class="hljs-string">&quot;scorched&quot;</span> : <span class="hljs-string">&quot;beautiful&quot;</span>;<br> &#125;<br> <span class="hljs-keyword">get</span> <span class="hljs-title function_">airSpeedVelocity</span>() &#123;<br>  <span class="hljs-keyword">return</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">isNailed</span>) ? <span class="hljs-number">0</span> : <span class="hljs-number">10</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">voltage</span> / <span class="hljs-number">10</span>;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>看着最终的代码，可以看出 Bird 超类并不是必需的。在 JavaScript 中，多态不一定需要类型层级，只要对象实现了适当的函数就行。但在这个例子中，我愿意保留这个不必要的超类，因为它能帮助阐释各个子类与问题域之间的关系。</p><h3 id="范例：用多态处理变体逻辑"><a href="#范例：用多态处理变体逻辑" class="headerlink" title="范例：用多态处理变体逻辑"></a>范例：用多态处理变体逻辑</h3><p>在前面的例子中，“鸟”的类型体系是一个清晰的泛化体系：超类是抽象的“鸟”，子类是各种具体的鸟。这是教科书（包括我写的书）中经常讨论的继承和多态，但并不是实践中使用继承的唯一方式。实际上，这种方式很可能不是最常用或最好的方式。另一种使用继承的情况是：我想表达某个对象与另一个对象大体类似，但又有一些不同之处。</p><p>下面有一个这样的例子：有一家评级机构，要对远洋航船的航行进行投资评级。这家评级机构会给出“A”或者“B”两种评级，取决于多种风险和盈利潜力的因素。在评估风险时，既要考虑航程本身的特征，也要考虑船长过往航行的历史。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">rating</span>(<span class="hljs-params">voyage, history</span>) &#123;<br> const vpf = voyageProfitFactor(voyage, history);<br> const vr = voyageRisk(voyage);<br> const chr = captainHistoryRisk(voyage, history);<br> <span class="hljs-keyword">if</span> (vpf * <span class="hljs-number">3</span> &gt; (vr + chr * <span class="hljs-number">2</span>)) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;A&quot;</span>;<br> <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;B&quot;</span>;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">voyageRisk</span>(<span class="hljs-params">voyage</span>) &#123;<br> let result = <span class="hljs-number">1</span>;<br> <span class="hljs-keyword">if</span> (voyage.<span class="hljs-built_in">length</span> &gt; <span class="hljs-number">4</span>) result += <span class="hljs-number">2</span>;<br> <span class="hljs-keyword">if</span> (voyage.<span class="hljs-built_in">length</span> &gt; <span class="hljs-number">8</span>) result += voyage.<span class="hljs-built_in">length</span> - <span class="hljs-number">8</span>;<br> <span class="hljs-keyword">if</span> ([<span class="hljs-string">&quot;china&quot;</span>, <span class="hljs-string">&quot;east-indies&quot;</span>].<span class="hljs-built_in">includes</span>(voyage.zone)) result += <span class="hljs-number">4</span>;<br> <span class="hljs-keyword">return</span> Math.<span class="hljs-built_in">max</span>(result, <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">captainHistoryRisk</span>(<span class="hljs-params">voyage, history</span>) &#123;<br> let result = <span class="hljs-number">1</span>;<br> <span class="hljs-keyword">if</span> (history.<span class="hljs-built_in">length</span> &lt; <span class="hljs-number">5</span>) result += <span class="hljs-number">4</span>;<br> result += history.<span class="hljs-built_in">filter</span>(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> v.profit &lt; <span class="hljs-number">0</span>).<span class="hljs-built_in">length</span>;<br> <span class="hljs-keyword">if</span> (voyage.zone === <span class="hljs-string">&quot;china&quot;</span> &amp;amp;&amp;amp; hasChina(history)) result -= <span class="hljs-number">2</span>;<br> <span class="hljs-keyword">return</span> Math.<span class="hljs-built_in">max</span>(result, <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">hasChina</span>(<span class="hljs-params">history</span>) &#123;<br> <span class="hljs-keyword">return</span> history.some(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> <span class="hljs-string">&quot;china&quot;</span> === v.zone);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">voyageProfitFactor</span>(<span class="hljs-params">voyage, history</span>) &#123;<br> let result = <span class="hljs-number">2</span>;<br> <span class="hljs-keyword">if</span> (voyage.zone === <span class="hljs-string">&quot;china&quot;</span>) result += <span class="hljs-number">1</span>;<br> <span class="hljs-keyword">if</span> (voyage.zone === <span class="hljs-string">&quot;east-indies&quot;</span>) result += <span class="hljs-number">1</span>;<br> <span class="hljs-keyword">if</span> (voyage.zone === <span class="hljs-string">&quot;china&quot;</span> &amp;amp;&amp;amp; hasChina(history)) &#123;<br>  result += <span class="hljs-number">3</span>;<br>  <span class="hljs-keyword">if</span> (history.<span class="hljs-built_in">length</span> &gt; <span class="hljs-number">10</span>) result += <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (voyage.<span class="hljs-built_in">length</span> &gt; <span class="hljs-number">12</span>) result += <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (voyage.<span class="hljs-built_in">length</span> &gt; <span class="hljs-number">18</span>) result -= <span class="hljs-number">1</span>;<br> &#125;<br> <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-keyword">if</span> (history.<span class="hljs-built_in">length</span> &gt; <span class="hljs-number">8</span>) result += <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (voyage.<span class="hljs-built_in">length</span> &gt; <span class="hljs-number">14</span>) result -= <span class="hljs-number">1</span>;<br> &#125;<br> <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>voyageRisk 和 captainHistoryRisk 两个函数负责打出风险分数，voyageProfitFactor 负责打出盈利潜力分数，rating 函数将 3 个分数组合到一起，给出一次航行的综合评级。</p><p>调用方的代码大概是这样：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">const voyage</span> = &#123; zone: <span class="hljs-string">&quot;west-indies&quot;</span>, length: 10 &#125;;<br><span class="hljs-attribute">const history</span> = [<br>  &#123; zone: <span class="hljs-string">&quot;east-indies&quot;</span>, profit: 5 &#125;,<br>  &#123; zone: <span class="hljs-string">&quot;west-indies&quot;</span>, profit: 15 &#125;,<br>  &#123; zone: <span class="hljs-string">&quot;china&quot;</span>, profit: -2 &#125;,<br>  &#123; zone: <span class="hljs-string">&quot;west-africa&quot;</span>, profit: 7 &#125;,<br>];<br><br><span class="hljs-attribute">const myRating</span> = rating(voyage, history);<br></code></pre></td></tr></table></figure><p>代码中有两处同样的条件逻辑，都在询问“是否有到中国的航程”以及“船长是否曾去过中国”。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">rating</span>(<span class="hljs-params">voyage, history</span>) &#123;<br> const vpf = voyageProfitFactor(voyage, history);<br> const vr = voyageRisk(voyage);<br> const chr = captainHistoryRisk(voyage, history);<br> <span class="hljs-keyword">if</span> (vpf * <span class="hljs-number">3</span> &gt; (vr + chr * <span class="hljs-number">2</span>)) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;A&quot;</span>;<br> <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;B&quot;</span>;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">voyageRisk</span>(<span class="hljs-params">voyage</span>) &#123;<br> let result = <span class="hljs-number">1</span>;<br> <span class="hljs-keyword">if</span> (voyage.<span class="hljs-built_in">length</span> &gt; <span class="hljs-number">4</span>) result += <span class="hljs-number">2</span>;<br> <span class="hljs-keyword">if</span> (voyage.<span class="hljs-built_in">length</span> &gt; <span class="hljs-number">8</span>) result += voyage.<span class="hljs-built_in">length</span> - <span class="hljs-number">8</span>;<br> <span class="hljs-keyword">if</span> ([<span class="hljs-string">&quot;china&quot;</span>, <span class="hljs-string">&quot;east-indies&quot;</span>].<span class="hljs-built_in">includes</span>(voyage.zone)) result += <span class="hljs-number">4</span>;<br> <span class="hljs-keyword">return</span> Math.<span class="hljs-built_in">max</span>(result, <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">captainHistoryRisk</span>(<span class="hljs-params">voyage, history</span>) &#123;<br> let result = <span class="hljs-number">1</span>;<br> <span class="hljs-keyword">if</span> (history.<span class="hljs-built_in">length</span> &lt; <span class="hljs-number">5</span>) result += <span class="hljs-number">4</span>;<br> result += history.<span class="hljs-built_in">filter</span>(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> v.profit &lt; <span class="hljs-number">0</span>).<span class="hljs-built_in">length</span>;<br> <span class="hljs-keyword">if</span> (voyage.zone === <span class="hljs-string">&quot;china&quot;</span> &amp;amp;&amp;amp; hasChina(history)) result -= <span class="hljs-number">2</span>;<br> <span class="hljs-keyword">return</span> Math.<span class="hljs-built_in">max</span>(result, <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">hasChina</span>(<span class="hljs-params">history</span>) &#123;<br> <span class="hljs-keyword">return</span> history.some(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> <span class="hljs-string">&quot;china&quot;</span> === v.zone);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">voyageProfitFactor</span>(<span class="hljs-params">voyage, history</span>) &#123;<br> let result = <span class="hljs-number">2</span>;<br> <span class="hljs-keyword">if</span> (voyage.zone === <span class="hljs-string">&quot;china&quot;</span>) result += <span class="hljs-number">1</span>;<br> <span class="hljs-keyword">if</span> (voyage.zone === <span class="hljs-string">&quot;east-indies&quot;</span>) result += <span class="hljs-number">1</span>;<br> <span class="hljs-keyword">if</span> (voyage.zone === <span class="hljs-string">&quot;china&quot;</span> &amp;amp;&amp;amp; hasChina(history)) &#123;<br>  result += <span class="hljs-number">3</span>;<br>  <span class="hljs-keyword">if</span> (history.<span class="hljs-built_in">length</span> &gt; <span class="hljs-number">10</span>) result += <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (voyage.<span class="hljs-built_in">length</span> &gt; <span class="hljs-number">12</span>) result += <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (voyage.<span class="hljs-built_in">length</span> &gt; <span class="hljs-number">18</span>) result -= <span class="hljs-number">1</span>;<br> &#125;<br> <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-keyword">if</span> (history.<span class="hljs-built_in">length</span> &gt; <span class="hljs-number">8</span>) result += <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (voyage.<span class="hljs-built_in">length</span> &gt; <span class="hljs-number">14</span>) result -= <span class="hljs-number">1</span>;<br> &#125;<br> <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>我会用继承和多态将处理“中国因素”的逻辑从基础逻辑中分离出来。如果还要引入更多的特殊逻辑，这个重构就很有用——这些重复的“中国因素”会混淆视听，让基础逻辑难以理解。</p><p>起初代码里只有一堆函数，如果要引入多态的话，我需要先建立一个类结构，因此我首先使用函数组合成类（144）。这一步重构的结果如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">function rating(voyage, history) &#123;<br> <span class="hljs-keyword">return</span> new Rating(voyage, history).value;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rating</span> &#123;<br> <span class="hljs-keyword">constructor</span>(voyage, history) &#123;<br>  <span class="hljs-keyword">this</span>.voyage = voyage;<br>  <span class="hljs-keyword">this</span>.history = history;<br> &#125;<br> <span class="hljs-keyword">get</span> value() &#123;<br>  <span class="hljs-keyword">const</span> vpf = <span class="hljs-keyword">this</span>.voyageProfitFactor;<br>  <span class="hljs-keyword">const</span> vr = <span class="hljs-keyword">this</span>.voyageRisk;<br>  <span class="hljs-keyword">const</span> chr = <span class="hljs-keyword">this</span>.captainHistoryRisk;<br>  <span class="hljs-keyword">if</span> (vpf * <span class="hljs-number">3</span> &gt; (vr + chr * <span class="hljs-number">2</span>)) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;A&quot;</span>;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;B&quot;</span>;<br> &#125;<br> <span class="hljs-keyword">get</span> voyageRisk() &#123;<br>  let result = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.length &gt; <span class="hljs-number">4</span>) result += <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.length &gt; <span class="hljs-number">8</span>) result += <span class="hljs-keyword">this</span>.voyage.length - <span class="hljs-number">8</span>;<br>  <span class="hljs-keyword">if</span> ([<span class="hljs-string">&quot;china&quot;</span>, <span class="hljs-string">&quot;east-indies&quot;</span>].includes(<span class="hljs-keyword">this</span>.voyage.zone)) result += <span class="hljs-number">4</span>;<br>  <span class="hljs-keyword">return</span> Math.max(result, <span class="hljs-number">0</span>);<br> &#125;<br> <span class="hljs-keyword">get</span> captainHistoryRisk() &#123;<br>  let result = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.history.length &lt; <span class="hljs-number">5</span>) result += <span class="hljs-number">4</span>;<br>  result += <span class="hljs-keyword">this</span>.history.filter(v =&gt; v.profit &lt; <span class="hljs-number">0</span>).length;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.zone === <span class="hljs-string">&quot;china&quot;</span> &amp;amp;&amp;amp; <span class="hljs-keyword">this</span>.hasChinaHistory) result -= <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">return</span> Math.max(result, <span class="hljs-number">0</span>);<br> &#125;<br> <span class="hljs-keyword">get</span> voyageProfitFactor() &#123;<br>  let result = <span class="hljs-number">2</span>;<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.zone === <span class="hljs-string">&quot;china&quot;</span>) result += <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.zone === <span class="hljs-string">&quot;east-indies&quot;</span>) result += <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.zone === <span class="hljs-string">&quot;china&quot;</span> &amp;amp;&amp;amp; <span class="hljs-keyword">this</span>.hasChinaHistory) &#123;<br>   result += <span class="hljs-number">3</span>;<br>   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.history.length &gt; <span class="hljs-number">10</span>) result += <span class="hljs-number">1</span>;<br>   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.length &gt; <span class="hljs-number">12</span>) result += <span class="hljs-number">1</span>;<br>   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.length &gt; <span class="hljs-number">18</span>) result -= <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">else</span> &#123;<br>   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.history.length &gt; <span class="hljs-number">8</span>) result += <span class="hljs-number">1</span>;<br>   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.length &gt; <span class="hljs-number">14</span>) result -= <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br> &#125;<br> <span class="hljs-keyword">get</span> hasChinaHistory() &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.history.some(v =&gt; <span class="hljs-string">&quot;china&quot;</span> === v.zone);<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>于是我就有了一个类，用来安放基础逻辑。现在我需要另建一个空的子类，用来安放与超类不同的行为。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExperiencedChinaRating</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Rating</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>然后，建立一个工厂函数，用于在需要时返回变体类。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> create<span class="hljs-constructor">Rating(<span class="hljs-params">voyage</span>, <span class="hljs-params">history</span>)</span> &#123;<br> <span class="hljs-keyword">if</span> (voyage.zone<span class="hljs-operator"> === </span><span class="hljs-string">&quot;china&quot;</span> &amp;amp;&amp;amp; history.some(v =&gt; <span class="hljs-string">&quot;china&quot;</span><span class="hljs-operator"> === </span>v.zone))<br>  return <span class="hljs-keyword">new</span> <span class="hljs-constructor">ExperiencedChinaRating(<span class="hljs-params">voyage</span>, <span class="hljs-params">history</span>)</span>;<br> <span class="hljs-keyword">else</span> return <span class="hljs-keyword">new</span> <span class="hljs-constructor">Rating(<span class="hljs-params">voyage</span>, <span class="hljs-params">history</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我需要修改所有调用方代码，让它们使用该工厂函数，而不要直接调用构造函数。还好现在调用构造函数的只有 rating 函数一处。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">rating</span>(voyage, history) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">createRating(voyage,</span> history).value;<br>&#125;<br></code></pre></td></tr></table></figure><p>有两处行为需要移入子类中。我先处理 captainHistoryRisk 中的逻辑。</p><p><strong>class Rating…</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">get</span> captainHistoryRisk() &#123;<br> let result = <span class="hljs-number">1</span>;<br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.history.length &lt; <span class="hljs-number">5</span>) result += <span class="hljs-number">4</span>;<br> result += <span class="hljs-keyword">this</span>.history.filter(v =&gt; v.profit &lt; <span class="hljs-number">0</span>).length;<br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.zone === <span class="hljs-string">&quot;china&quot;</span> &amp;amp;&amp;amp; <span class="hljs-keyword">this</span>.hasChinaHistory) result -= <span class="hljs-number">2</span>;<br> <span class="hljs-keyword">return</span> Math.max(result, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在子类中覆写这个函数。</p><p>class ExperiencedChinaRating</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">get</span> <span class="hljs-title function_">captainHistoryRisk</span>() &#123;<br>  <span class="hljs-keyword">const</span> result = <span class="hljs-variable language_">super</span>.<span class="hljs-property">captainHistoryRisk</span> - <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(result, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>class Rating…</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">get</span> captainHistoryRisk() &#123;<br> let result = <span class="hljs-number">1</span>;<br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.history.length &lt; <span class="hljs-number">5</span>) result += <span class="hljs-number">4</span>;<br> result += <span class="hljs-keyword">this</span>.history.filter(v =&gt; v.profit &lt; <span class="hljs-number">0</span>).length;<br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.zone === <span class="hljs-string">&quot;china&quot;</span> &amp;amp;&amp;amp; <span class="hljs-keyword">this</span>.hasChinaHistory) result -= <span class="hljs-number">2</span>;<br> <span class="hljs-keyword">return</span> Math.max(result, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>分离 voyageProfitFactor 函数中的变体行为要更麻烦一些。我不能直接从超类中删掉变体行为，因为在超类中还有另一条执行路径。我又不想把整个超类中的函数复制到子类中。</p><p><strong>class Rating…</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">get</span> voyageProfitFactor() &#123;<br> let result = <span class="hljs-number">2</span>;<br><br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.zone === <span class="hljs-string">&quot;china&quot;</span>) result += <span class="hljs-number">1</span>;<br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.zone === <span class="hljs-string">&quot;east-indies&quot;</span>) result += <span class="hljs-number">1</span>;<br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.zone === <span class="hljs-string">&quot;china&quot;</span> &amp;amp;&amp;amp; <span class="hljs-keyword">this</span>.hasChinaHistory) &#123;<br>  result += <span class="hljs-number">3</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.history.length &gt; <span class="hljs-number">10</span>) result += <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.length &gt; <span class="hljs-number">12</span>) result += <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.length &gt; <span class="hljs-number">18</span>) result -= <span class="hljs-number">1</span>;<br> &#125;<br> <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.history.length &gt; <span class="hljs-number">8</span>) result += <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.length &gt; <span class="hljs-number">14</span>) result -= <span class="hljs-number">1</span>;<br> &#125;<br> <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以我先用提炼函数（106）将整个条件逻辑块提炼出来。</p><p><strong>class Rating…</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">get</span> voyageProfitFactor() &#123;<br> let result = <span class="hljs-number">2</span>;<br><br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.zone === <span class="hljs-string">&quot;china&quot;</span>) result += <span class="hljs-number">1</span>;<br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.zone === <span class="hljs-string">&quot;east-indies&quot;</span>) result += <span class="hljs-number">1</span>;<br> result += <span class="hljs-keyword">this</span>.voyageAndHistoryLengthFactor;<br> <span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-keyword">get</span> voyageAndHistoryLengthFactor() &#123;<br> let result = <span class="hljs-number">0</span>;<br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.zone === <span class="hljs-string">&quot;china&quot;</span> &amp;amp;&amp;amp; <span class="hljs-keyword">this</span>.hasChinaHistory) &#123;<br>  result += <span class="hljs-number">3</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.history.length &gt; <span class="hljs-number">10</span>) result += <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.length &gt; <span class="hljs-number">12</span>) result += <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.length &gt; <span class="hljs-number">18</span>) result -= <span class="hljs-number">1</span>;<br> &#125;<br> <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.history.length &gt; <span class="hljs-number">8</span>) result += <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.length &gt; <span class="hljs-number">14</span>) result -= <span class="hljs-number">1</span>;<br> &#125;<br> <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数名中出现“And”字样是一个很不好的味道，不过我会暂时容忍它，先聚焦子类化操作。</p><p><strong>class Rating…</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-keyword">get</span> voyageAndHistoryLengthFactor() &#123;<br> let <span class="hljs-literal">result</span> = <span class="hljs-number">0</span>;<br> <span class="hljs-keyword">if</span> (this.history.<span class="hljs-built_in">length</span> &gt; <span class="hljs-number">8</span>) <span class="hljs-literal">result</span> += <span class="hljs-number">1</span>;<br> <span class="hljs-keyword">if</span> (this.voyage.<span class="hljs-built_in">length</span> &gt; <span class="hljs-number">14</span>) <span class="hljs-literal">result</span> -= <span class="hljs-number">1</span>;<br><span class="hljs-built_in"> return</span> <span class="hljs-literal">result</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>class ExperiencedChinaRating…</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-keyword">get</span> voyageAndHistoryLengthFactor() &#123;<br> let <span class="hljs-literal">result</span> = <span class="hljs-number">0</span>;<br> <span class="hljs-literal">result</span> += <span class="hljs-number">3</span>;<br> <span class="hljs-keyword">if</span> (this.history.<span class="hljs-built_in">length</span> &gt; <span class="hljs-number">10</span>) <span class="hljs-literal">result</span> += <span class="hljs-number">1</span>;<br> <span class="hljs-keyword">if</span> (this.voyage.<span class="hljs-built_in">length</span> &gt; <span class="hljs-number">12</span>) <span class="hljs-literal">result</span> += <span class="hljs-number">1</span>;<br> <span class="hljs-keyword">if</span> (this.voyage.<span class="hljs-built_in">length</span> &gt; <span class="hljs-number">18</span>) <span class="hljs-literal">result</span> -= <span class="hljs-number">1</span>;<br><span class="hljs-built_in"> return</span> <span class="hljs-literal">result</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>严格说来，重构到这儿就结束了——我已经把变体行为分离到了子类中，超类的逻辑理解和维护起来更简单了，只有在进入子类代码时我才需要操心变体逻辑。子类的代码表述了它与超类的差异。</p><p>但我觉得至少应该谈谈如何处理这个丑陋的新函数。引入一个函数以便子类覆写，这在处理这种“基础和变体”的继承关系时是常见操作。但这样一个难看的函数只会妨碍——而不是帮助——别人理解其中的逻辑。</p><p>函数名中的“And”字样说明其中包含了两件事，所以我觉得应该将它们分开。我会用提炼函数（106）把“历史航行数”（history length）的相关逻辑提炼出来。这一步提炼在超类和子类中都要发生，我首先从超类开始。</p><p><strong>class Rating…</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">get</span> <span class="hljs-title">voyageAndHistoryLengthFactor</span>()</span> &#123;<br> <span class="hljs-keyword">let</span> result = <span class="hljs-number">0</span>;<br> result += <span class="hljs-keyword">this</span>.historyLengthFactor;<br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.length &gt; <span class="hljs-number">14</span>) result -= <span class="hljs-number">1</span>;<br> <span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">get</span> <span class="hljs-title">historyLengthFactor</span>()</span> &#123;<br> <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.history.length &gt; <span class="hljs-number">8</span>) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在子类中也如法炮制。</p><p><strong>class ExperiencedChinaRating…</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">get</span> voyageAndHistoryLengthFactor() &#123;<br> let result = <span class="hljs-number">0</span>;<br> result += <span class="hljs-number">3</span>;<br> result += <span class="hljs-keyword">this</span>.historyLengthFactor;<br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.length &gt; <span class="hljs-number">12</span>) result += <span class="hljs-number">1</span>;<br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.length &gt; <span class="hljs-number">18</span>) result -= <span class="hljs-number">1</span>;<br> <span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-keyword">get</span> historyLengthFactor() &#123;<br> <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.history.length &gt; <span class="hljs-number">10</span>) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在超类中使用搬移语句到调用者（217）。</p><p><strong>class Rating…</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">get</span> voyageProfitFactor() &#123;<br> let result = <span class="hljs-number">2</span>;<br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.zone === <span class="hljs-string">&quot;china&quot;</span>) result += <span class="hljs-number">1</span>;<br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.zone === <span class="hljs-string">&quot;east-indies&quot;</span>) result += <span class="hljs-number">1</span>;<br> result += <span class="hljs-keyword">this</span>.historyLengthFactor;<br> result += <span class="hljs-keyword">this</span>.voyageAndHistoryLengthFactor;<br> <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-keyword">get</span> voyageAndHistoryLengthFactor() &#123;<br> let result = <span class="hljs-number">0</span>;<br> result += <span class="hljs-keyword">this</span>.historyLengthFactor;<br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.length &gt; <span class="hljs-number">14</span>) result -= <span class="hljs-number">1</span>;<br> <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>class ExperiencedChinaRating…</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-keyword">get</span> voyageAndHistoryLengthFactor() &#123;<br> let <span class="hljs-literal">result</span> = <span class="hljs-number">0</span>;<br> <span class="hljs-literal">result</span> += <span class="hljs-number">3</span>;<br> <span class="hljs-literal">result</span> += this.historyLengthFactor;<br> <span class="hljs-keyword">if</span> (this.voyage.<span class="hljs-built_in">length</span> &gt; <span class="hljs-number">12</span>) <span class="hljs-literal">result</span> += <span class="hljs-number">1</span>;<br> <span class="hljs-keyword">if</span> (this.voyage.<span class="hljs-built_in">length</span> &gt; <span class="hljs-number">18</span>) <span class="hljs-literal">result</span> -= <span class="hljs-number">1</span>;<br><span class="hljs-built_in"> return</span> <span class="hljs-literal">result</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>再用函数改名（124）改掉这个难听的名字。</p><p><strong>class Rating…</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">get</span> voyageProfitFactor() &#123;<br> let result = <span class="hljs-number">2</span>;<br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.zone === <span class="hljs-string">&quot;china&quot;</span>) result += <span class="hljs-number">1</span>;<br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.zone === <span class="hljs-string">&quot;east-indies&quot;</span>) result += <span class="hljs-number">1</span>;<br> result += <span class="hljs-keyword">this</span>.historyLengthFactor;<br> result += <span class="hljs-keyword">this</span>.voyageLengthFactor;<br> <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-keyword">get</span> voyageLengthFactor() &#123;<br> <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.voyage.length &gt; <span class="hljs-number">14</span>) ? - <span class="hljs-number">1</span>: <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>改为三元表达式，以简化 voyageLengthFactor 函数。</p><p><strong>class ExperiencedChinaRating…</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-keyword">get</span> voyageLengthFactor() &#123;<br> let <span class="hljs-literal">result</span> = <span class="hljs-number">0</span>;<br> <span class="hljs-literal">result</span> += <span class="hljs-number">3</span>;<br> <span class="hljs-keyword">if</span> (this.voyage.<span class="hljs-built_in">length</span> &gt; <span class="hljs-number">12</span>) <span class="hljs-literal">result</span> += <span class="hljs-number">1</span>;<br> <span class="hljs-keyword">if</span> (this.voyage.<span class="hljs-built_in">length</span> &gt; <span class="hljs-number">18</span>) <span class="hljs-literal">result</span> -= <span class="hljs-number">1</span>;<br><span class="hljs-built_in"> return</span> <span class="hljs-literal">result</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后一件事：在“航程数”（voyage length）因素上加上 3 分，我认为这个逻辑不合理，应该把这 3 分加在最终的结果上。</p><p><strong>class ExperiencedChinaRating…</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-keyword">get</span> voyageProfitFactor() &#123;<br><span class="hljs-built_in">  return</span> super.voyageProfitFactor + <span class="hljs-number">3</span>;<br>&#125;<br><br><span class="hljs-keyword">get</span> voyageLengthFactor() &#123;<br>  let <span class="hljs-literal">result</span> = <span class="hljs-number">0</span>;<br>  <span class="hljs-literal">result</span> += <span class="hljs-number">3</span>;<br>  <span class="hljs-keyword">if</span> (this.voyage.<span class="hljs-built_in">length</span> &gt; <span class="hljs-number">12</span>) <span class="hljs-literal">result</span> += <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (this.voyage.<span class="hljs-built_in">length</span> &gt; <span class="hljs-number">18</span>) <span class="hljs-literal">result</span> -= <span class="hljs-number">1</span>;<br><span class="hljs-built_in">  return</span> <span class="hljs-literal">result</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>重构结束，我得到了如下代码。首先，我有一个基本的 Rating 类，其中不考虑与“中国经验”相关的复杂性：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rating</span> &#123;<br> <span class="hljs-keyword">constructor</span>(voyage, history) &#123;<br>  <span class="hljs-keyword">this</span>.voyage = voyage;<br>  <span class="hljs-keyword">this</span>.history = history;<br> &#125;<br> <span class="hljs-keyword">get</span> value() &#123;<br>  <span class="hljs-keyword">const</span> vpf = <span class="hljs-keyword">this</span>.voyageProfitFactor;<br>  <span class="hljs-keyword">const</span> vr = <span class="hljs-keyword">this</span>.voyageRisk;<br>  <span class="hljs-keyword">const</span> chr = <span class="hljs-keyword">this</span>.captainHistoryRisk;<br>  <span class="hljs-keyword">if</span> (vpf * <span class="hljs-number">3</span> &gt; (vr + chr * <span class="hljs-number">2</span>)) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;A&quot;</span>;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;B&quot;</span>;<br> &#125;<br> <span class="hljs-keyword">get</span> voyageRisk() &#123;<br>  let result = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.length &gt; <span class="hljs-number">4</span>) result += <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.length &gt; <span class="hljs-number">8</span>) result += <span class="hljs-keyword">this</span>.voyage.length - <span class="hljs-number">8</span>;<br>  <span class="hljs-keyword">if</span> ([<span class="hljs-string">&quot;china&quot;</span>, <span class="hljs-string">&quot;east-indies&quot;</span>].includes(<span class="hljs-keyword">this</span>.voyage.zone)) result += <span class="hljs-number">4</span>;<br>  <span class="hljs-keyword">return</span> Math.max(result, <span class="hljs-number">0</span>);<br> &#125;<br> <span class="hljs-keyword">get</span> captainHistoryRisk() &#123;<br>  let result = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.history.length &lt; <span class="hljs-number">5</span>) result += <span class="hljs-number">4</span>;<br>  result += <span class="hljs-keyword">this</span>.history.filter(v =&gt; v.profit &lt; <span class="hljs-number">0</span>).length;<br>  <span class="hljs-keyword">return</span> Math.max(result, <span class="hljs-number">0</span>);<br> &#125;<br> <span class="hljs-keyword">get</span> voyageProfitFactor() &#123;<br>  let result = <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.zone === <span class="hljs-string">&quot;china&quot;</span>) result += <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.zone === <span class="hljs-string">&quot;east-indies&quot;</span>) result += <span class="hljs-number">1</span>;<br>  result += <span class="hljs-keyword">this</span>.historyLengthFactor;<br>  result += <span class="hljs-keyword">this</span>.voyageLengthFactor;<br>  <span class="hljs-keyword">return</span> result;<br> &#125;<br> <span class="hljs-keyword">get</span> voyageLengthFactor() &#123;<br>  <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.voyage.length &gt; <span class="hljs-number">14</span>) ? - <span class="hljs-number">1</span>: <span class="hljs-number">0</span>;<br> &#125;<br> <span class="hljs-keyword">get</span> historyLengthFactor() &#123;<br>  <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.history.length &gt; <span class="hljs-number">8</span>) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>与“中国经验”相关的代码则清晰表述出在基本逻辑之上的一系列变体逻辑：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ExperiencedChinaRating</span> <span class="hljs-title">extends</span> <span class="hljs-title">Rating</span> &#123;<br> <span class="hljs-keyword">get</span> captainHistoryRisk() &#123;<br>  <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">super</span>.captainHistoryRisk - <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">return</span> Math.max(result, <span class="hljs-number">0</span>);<br> &#125;<br> <span class="hljs-keyword">get</span> voyageLengthFactor() &#123;<br>  let result = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.length &gt; <span class="hljs-number">12</span>) result += <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.voyage.length &gt; <span class="hljs-number">18</span>) result -= <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">return</span> result;<br> &#125;<br> <span class="hljs-keyword">get</span> historyLengthFactor() &#123;<br>  <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.history.length &gt; <span class="hljs-number">10</span>) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br> &#125;<br> <span class="hljs-keyword">get</span> voyageProfitFactor() &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.voyageProfitFactor + <span class="hljs-number">3</span>;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="10-5-引入特例（Introduce-Special-Case）"><a href="#10-5-引入特例（Introduce-Special-Case）" class="headerlink" title="10.5 引入特例（Introduce Special Case）"></a>10.5 引入特例（Introduce Special Case）</h2><p>曾用名：引入 Null 对象（Introduce Null Object）</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">if (aCustomer <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-string">&quot;unknown&quot;</span>) customerName <span class="hljs-operator">=</span> <span class="hljs-string">&quot;occupant&quot;</span><span class="hljs-comment">;</span><br><br><br>class UnknownCustomer &#123;<br>  get name() &#123;return <span class="hljs-string">&quot;occupant&quot;</span><span class="hljs-comment">;&#125;</span><br></code></pre></td></tr></table></figure><h3 id="动机-4"><a href="#动机-4" class="headerlink" title="动机"></a>动机</h3><p>一种常见的重复代码是这种情况：一个数据结构的使用者都在检查某个特殊的值，并且当这个特殊值出现时所做的处理也都相同。如果我发现代码库中有多处以同样方式应对同一个特殊值，我就会想要把这个处理逻辑收拢到一处。</p><p>处理这种情况的一个好办法是使用“特例”（Special Case）模式：创建一个特例元素，用以表达对这种特例的共用行为的处理。这样我就可以用一个函数调用取代大部分特例检查逻辑。</p><p>特例有几种表现形式。如果我只需要从这个对象读取数据，可以提供一个字面量对象（literal object），其中所有的值都是预先填充好的。如果除简单的数值之外还需要更多的行为，就需要创建一个特殊对象，其中包含所有共用行为所对应的函数。特例对象可以由一个封装类来返回，也可以通过变换插入一个数据结构。</p><p>一个通常需要特例处理的值就是 null，这也是这个模式常被叫作“Null 对象”（Null Object）模式的原因——我喜欢说：Null 对象是特例的一种特例。</p><h3 id="做法-4"><a href="#做法-4" class="headerlink" title="做法"></a>做法</h3><p>我们从一个作为容器的数据结构（或者类）开始，其中包含一个属性，该属性就是我们要重构的目标。容器的客户端每次使用这个属性时，都需要将其与某个特例值做比对。我们希望把这个特例值替换为代表这种特例情况的类或数据结构。</p><p>给重构目标添加检查特例的属性，令其返回 false。</p><p>创建一个特例对象，其中只有检查特例的属性，返回 true。</p><p>对“与特例值做比对”的代码运用提炼函数（106），确保所有客户端都使用这个新函数，而不再直接做特例值的比对。</p><p>将新的特例对象引入代码中，可以从函数调用中返回，也可以在变换函数中生成。</p><p>修改特例比对函数的主体，在其中直接使用检查特例的属性。</p><p>测试。</p><p>使用函数组合成类（144）或函数组合成变换（149），把通用的特例处理逻辑都搬移到新建的特例对象中。</p><p>特例类对于简单的请求通常会返回固定的值，因此可以将其实现为字面记录（literal record）。</p><p>对特例比对函数使用内联函数（115），将其内联到仍然需要的地方。</p><h3 id="范例-4"><a href="#范例-4" class="headerlink" title="范例"></a>范例</h3><p>一家提供公共事业服务的公司将自己的服务安装在各个场所（site）。</p><p><strong>class Site…</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">get</span> <span class="hljs-title">customer</span>()</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._customer;&#125;<br></code></pre></td></tr></table></figure><p>代表“顾客”的 Customer 类有多个属性，我只考虑其中 3 个。</p><p><strong>class Customer…</strong></p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nim">get name()           <span class="hljs-meta">&#123;...&#125;</span><br>get billingPlan()    <span class="hljs-meta">&#123;...&#125;</span><br><span class="hljs-type">set</span> billingPlan(arg) <span class="hljs-meta">&#123;...&#125;</span><br>get paymentHistory() <span class="hljs-meta">&#123;...&#125;</span><br></code></pre></td></tr></table></figure><p>大多数情况下，一个场所会对应一个顾客，但有些场所没有与之对应的顾客，可能是因为之前的住户搬走了，而新搬来的住户我还不知道是谁。这种情况下，数据记录中的 customer 字段会被填充为字符串”unknown”。因为这种情况时有发生，所以 Site 对象的客户端必须有办法处理“顾客未知”的情况。下面是一些示例代码片段。</p><p><strong>客户端 1…</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">const aCustomer <span class="hljs-operator">=</span> site.customer<span class="hljs-comment">;</span><br>// ... lots of intervening code ...<br>let customerName<span class="hljs-comment">;</span><br>if (aCustomer <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-string">&quot;unknown&quot;</span>) customerName <span class="hljs-operator">=</span> <span class="hljs-string">&quot;occupant&quot;</span><span class="hljs-comment">;</span><br>else customerName <span class="hljs-operator">=</span> aCustomer.name<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><strong>客户端 2…</strong></p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-keyword">const</span> plan =<br>  aCustomer === <span class="hljs-string">&quot;unknown&quot;</span> ? registry.billingPlans.<span class="hljs-keyword">basic</span> : aCustomer.billingPlan;<br></code></pre></td></tr></table></figure><p><strong>客户端 3…</strong></p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">if</span> (aCustomer !== <span class="hljs-string">&quot;unknown&quot;</span>) aCustomer.billingPlan = <span class="hljs-keyword">new</span><span class="hljs-type">Plan</span>;<br></code></pre></td></tr></table></figure><p><strong>客户端 4…</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">const</span> weeksDelinquent =<br>  aCustomer === <span class="hljs-string">&quot;unknown&quot;</span><br>    ? <span class="hljs-number">0</span><br>    : aCustomer.paymentHistory.weeksDelinquentInLastYear;<br></code></pre></td></tr></table></figure><p>浏览整个代码库，我看到有很多使用 Site 对象的客户端在处理“顾客未知”的情况，大多数都用了同样的应对方式：用”occupant”（居民）作为顾客名，使用基本的计价套餐，并认为这家顾客没有欠费。到处都在检查这种特例，再加上对特例的处理方式高度一致，这些现象告诉我：是时候使用特例对象（Special Case Object）模式了。</p><p>我首先给 Customer 添加一个函数，用于指示“这个顾客是否未知”。</p><p><strong>class Customer…</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">get</span> <span class="hljs-title">isUnknown</span>()</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<br></code></pre></td></tr></table></figure><p>然后我给“未知的顾客”专门创建一个类。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">UnknownCustomer</span> &#123;<br>  <span class="hljs-function"><span class="hljs-keyword">get</span> <span class="hljs-title">isUnknown</span>()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，我没有把 UnknownCustomer 类声明为 Customer 的子类。在其他编程语言（尤其是静态类型的编程语言）中，我会需要继承关系。但 JavaScript 是一种动态类型语言，按照它的子类化规则，这里不声明继承关系反而更好。</p><p>下面就是麻烦之处了。我必须在所有期望得到”unknown”值的地方返回这个新的特例对象，并修改所有检查”unknown”值的地方，令其使用新的 isUnknown 函数。一般而言，我总是希望细心安排修改过程，使我可以每次做一点小修改，然后马上测试。但如果我修改了 Customer 类，使其返回 UnknownCustomer 对象（而非”unknown”字符串），那么就必须同时修改所有客户端，让它们不要检查”unknown”字符串，而是调用 isUnknown 函数——这两个修改必须一次完成。我感觉这一大步修改就像一大块难吃的食物一样难以下咽。</p><p>还好，遇到这种困境时，有一个常用的技巧可以帮忙。如果有一段代码需要在很多地方做修改（例如我们这里的“与特例做比对”的代码），我会先对其使用提炼函数（106）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isUnknown</span>(<span class="hljs-params">arg</span>) &#123;<br>  <span class="hljs-keyword">if</span> (!(arg <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Customer</span> || arg === <span class="hljs-string">&quot;unknown&quot;</span>))<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`investigate bad value: &lt;<span class="hljs-subst">$&#123;arg&#125;</span>&gt;`</span>);<br>  <span class="hljs-keyword">return</span> arg === <span class="hljs-string">&quot;unknown&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我会放一个陷阱，捕捉意料之外的值。如果在重构过程中我犯了错误，引入了奇怪的行为，这个陷阱会帮我发现。</p><p>现在，凡是检查未知顾客的地方，都可以改用这个函数了。我可以逐一修改这些地方，每次修改之后都可以执行测试。</p><p><strong>客户端 1…</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">let customerName<span class="hljs-comment">;</span><br>if (isUnknown(aCustomer)) customerName <span class="hljs-operator">=</span> <span class="hljs-string">&quot;occupant&quot;</span><span class="hljs-comment">;</span><br>else customerName <span class="hljs-operator">=</span> aCustomer.name<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>没用多久，就全部修改完了。</p><p><strong>客户端 2…</strong></p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-keyword">const</span> plan = isUnknown(aCustomer)<br>  ? registry.billingPlans.<span class="hljs-keyword">basic</span><br>  : aCustomer.billingPlan;<br></code></pre></td></tr></table></figure><p><strong>客户端 3…</strong></p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">if</span> (!isUnknown(aCustomer)) aCustomer.billingPlan = <span class="hljs-keyword">new</span><span class="hljs-type">Plan</span>;<br></code></pre></td></tr></table></figure><p><strong>客户端 4…</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">const weeksDelinquent = is<span class="hljs-constructor">Unknown(<span class="hljs-params">aCustomer</span>)</span><br>  ? <span class="hljs-number">0</span><br>  : aCustomer.paymentHistory.weeksDelinquentInLastYear;<br></code></pre></td></tr></table></figure><p>将所有调用处都改为使用 isUnknown 函数之后，就可以修改 Site 类，令其在顾客未知时返回 UnknownCustomer 对象。</p><p><strong>class Site…</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">get</span> <span class="hljs-title">customer</span>()</span> &#123;<br>  <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>._customer === <span class="hljs-string">&quot;unknown&quot;</span>) ? <span class="hljs-keyword">new</span> UnknownCustomer() : <span class="hljs-keyword">this</span>._customer;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后修改 isUnknown 函数的判断逻辑。做完这步修改之后我可以做一次全文搜索，应该没有任何地方使用”unknown”字符串了。</p><p><strong>客户端 1…</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isUnknown</span>(<span class="hljs-params">arg</span>) &#123;<br>  <span class="hljs-keyword">if</span> (!(arg <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Customer</span> || arg <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">UnknownCustomer</span>))<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`investigate bad value: &lt;<span class="hljs-subst">$&#123;arg&#125;</span>&gt;`</span>);<br>  <span class="hljs-keyword">return</span> arg.<span class="hljs-property">isUnknown</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试，以确保一切运转如常。</p><p>现在，有趣的部分开始了。我可以逐一查看客户端检查特例的代码，看它们处理特例的逻辑，并考虑是否能用函数组合成类（144）将其替换为一个共同的、符合预期的值。此刻，有多处客户端代码用字符串”occupant”来作为未知顾客的名字，就像下面这样。</p><p><strong>客户端 1…</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">let customerName<span class="hljs-comment">;</span><br>if (isUnknown(aCustomer)) customerName <span class="hljs-operator">=</span> <span class="hljs-string">&quot;occupant&quot;</span><span class="hljs-comment">;</span><br>else customerName <span class="hljs-operator">=</span> aCustomer.name<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>我可以在 UnknownCustomer 类中添加一个合适的函数。</p><p><strong>class UnknownCustomer…</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">get</span> <span class="hljs-title">name</span>()</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;occupant&quot;</span>;&#125;<br></code></pre></td></tr></table></figure><p>然后我就可以去掉所有条件代码。</p><p><strong>客户端 1…</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">const customerName <span class="hljs-operator">=</span> aCustomer.name<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>测试通过之后，我可能会用内联变量（123）把 customerName 变量也消除掉。</p><p>接下来处理代表“计价套餐”的 billingPlan 属性。</p><p><strong>客户端 2…</strong></p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-keyword">const</span> plan = isUnknown(aCustomer)<br>  ? registry.billingPlans.<span class="hljs-keyword">basic</span><br>  : aCustomer.billingPlan;<br></code></pre></td></tr></table></figure><p><strong>客户端 3…</strong></p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">if</span> (!isUnknown(aCustomer)) aCustomer.billingPlan = <span class="hljs-keyword">new</span><span class="hljs-type">Plan</span>;<br></code></pre></td></tr></table></figure><p>对于读取该属性的行为，我的处理方法跟前面处理 name 属性一样——找到通用的应对方式，并在 UnknownCustomer 中使用之。至于对该属性的写操作，当前的代码没有对未知顾客调用过设值函数，所以在特例对象中，我会保留设值函数，但其中什么都不做。</p><p><strong>class UnknownCustomer…</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">get</span> <span class="hljs-title">billingPlan</span>()</span>  &#123;<span class="hljs-keyword">return</span> registry.billingPlans.basic;&#125;<br><span class="hljs-function"><span class="hljs-keyword">set</span> <span class="hljs-title">billingPlan</span>(<span class="hljs-params">arg</span>)</span> &#123; <span class="hljs-comment">/* ignore */</span> &#125;<br></code></pre></td></tr></table></figure><p><strong>读取的例子…</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">const plan <span class="hljs-operator">=</span> aCustomer.billingPlan<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><strong>更新的例子…</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">aCustomer.billingPlan</span> = newPlan<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>特例对象是值对象，因此应该始终是不可变的，即便它们替代的原对象本身是可变的。</p><p>最后一个例子则更麻烦一些，因为特例对象需要返回另一个对象，后者又有其自己的属性。</p><p><strong>客户端…</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">const weeksDelinquent = is<span class="hljs-constructor">Unknown(<span class="hljs-params">aCustomer</span>)</span><br>  ? <span class="hljs-number">0</span><br>  : aCustomer.paymentHistory.weeksDelinquentInLastYear;<br></code></pre></td></tr></table></figure><p>一般的原则是：如果特例对象需要返回关联对象，被返回的通常也是特例对象。所以，我需要创建一个代表“空支付记录”的特例类 NullPaymentHistory。</p><p><strong>class UnknownCustomer…</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">get</span> <span class="hljs-title">paymentHistory</span>()</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> NullPaymentHistory();&#125;<br></code></pre></td></tr></table></figure><p><strong>class NullPaymentHistory…</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">get</span> <span class="hljs-title">weeksDelinquentInLastYear</span>()</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br></code></pre></td></tr></table></figure><p><strong>客户端…</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">const weeksDelinquent <span class="hljs-operator">=</span> aCustomer.paymentHistory.weeksDelinquentInLastYear<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>我继续查看客户端代码，寻找是否有能用多态行为取代的地方。但也会有例外情况——客户端不想使用特例对象提供的逻辑，而是想做一些别的处理。我可能有 23 处客户端代码用”occupant”作为未知顾客的名字，但还有一处用了别的值。</p><p><strong>客户端…</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">const <span class="hljs-type">name</span> = !isUnknown(aCustomer) ? aCustomer.name : &quot;unknown occupant&quot;;<br></code></pre></td></tr></table></figure><p>这种情况下，我只能在客户端保留特例检查的逻辑。我会对其做些修改，让它使用 aCustomer 对象身上的 isUnknown 函数，也就是对全局的 isUnknown 函数使用内联函数（115）。</p><p><strong>客户端…</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">const <span class="hljs-type">name</span> = aCustomer.isUnknown ? &quot;unknown occupant&quot; : aCustomer.name;<br></code></pre></td></tr></table></figure><p>处理完所有客户端代码后，全局的 isUnknown 函数应该没人再调用了，可以用移除死代码（237）将其移除。</p><h3 id="范例：使用对象字面量"><a href="#范例：使用对象字面量" class="headerlink" title="范例：使用对象字面量"></a>范例：使用对象字面量</h3><p>我们在上面处理的其实是一些很简单的值，却要创建一个这样的类，未免有点儿大动干戈。但在上面这个例子中，我必须创建这样一个类，因为 Customer 类是允许使用者更新其内容的。但如果面对一个只读的数据结构，我就可以改用字面量对象（literal object）。</p><p>还是前面这个例子——几乎完全一样，除了一件事：这次没有客户端对 Customer 对象做更新操作：</p><p><strong>class Site…</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">get</span> <span class="hljs-title">customer</span>()</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._customer;&#125;<br></code></pre></td></tr></table></figure><p><strong>class Customer…</strong></p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nim">get name()           <span class="hljs-meta">&#123;...&#125;</span><br>get billingPlan()    <span class="hljs-meta">&#123;...&#125;</span><br><span class="hljs-type">set</span> billingPlan(arg) <span class="hljs-meta">&#123;...&#125;</span><br>get paymentHistory() <span class="hljs-meta">&#123;...&#125;</span><br></code></pre></td></tr></table></figure><p><strong>客户端 1…</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">const aCustomer <span class="hljs-operator">=</span> site.customer<span class="hljs-comment">;</span><br>// ... lots of intervening code ...<br>let customerName<span class="hljs-comment">;</span><br>if (aCustomer <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-string">&quot;unknown&quot;</span>) customerName <span class="hljs-operator">=</span> <span class="hljs-string">&quot;occupant&quot;</span><span class="hljs-comment">;</span><br>else customerName <span class="hljs-operator">=</span> aCustomer.name<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><strong>客户端 2…</strong></p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-keyword">const</span> plan =<br>  aCustomer === <span class="hljs-string">&quot;unknown&quot;</span> ? registry.billingPlans.<span class="hljs-keyword">basic</span> : aCustomer.billingPlan;<br></code></pre></td></tr></table></figure><p><strong>客户端 3…</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">const</span> weeksDelinquent =<br>  aCustomer === <span class="hljs-string">&quot;unknown&quot;</span><br>    ? <span class="hljs-number">0</span><br>    : aCustomer.paymentHistory.weeksDelinquentInLastYear;<br></code></pre></td></tr></table></figure><p>和前面的例子一样，我首先在 Customer 中添加 isUnknown 属性，并创建一个包含同名字段的特例对象。这次的区别在于，特例对象是一个字面量。</p><p><strong>class Customer…</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">get</span> <span class="hljs-title">isUnknown</span>()</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<br></code></pre></td></tr></table></figure><p><strong>顶层作用域…</strong></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">createUnknownCustomer</span>() &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">&#123;</span><br>    isUnknown: <span class="hljs-literal">true</span>,<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我对检查特例的条件逻辑运用提炼函数（106）。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">isUnknown</span>(arg) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">arg</span> === <span class="hljs-string">&quot;unknown&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>客户端 1…</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">let customerName<span class="hljs-comment">;</span><br>if (isUnknown(aCustomer)) customerName <span class="hljs-operator">=</span> <span class="hljs-string">&quot;occupant&quot;</span><span class="hljs-comment">;</span><br>else customerName <span class="hljs-operator">=</span> aCustomer.name<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><strong>客户端 2…</strong></p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-keyword">const</span> plan = isUnknown(aCustomer)<br>  ? registry.billingPlans.<span class="hljs-keyword">basic</span><br>  : aCustomer.billingPlan;<br></code></pre></td></tr></table></figure><p><strong>客户端 3…</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">const weeksDelinquent = is<span class="hljs-constructor">Unknown(<span class="hljs-params">aCustomer</span>)</span><br>  ? <span class="hljs-number">0</span><br>  : aCustomer.paymentHistory.weeksDelinquentInLastYear;<br></code></pre></td></tr></table></figure><p>修改 Site 类和做条件判断的 isUnknown 函数，开始使用特例对象。</p><p><strong>class Site…</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">get</span> customer() &#123;<br>  <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>._customer === <span class="hljs-string">&quot;unknown&quot;</span>) ? createUnknownCustomer() : <span class="hljs-keyword">this</span>._customer;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>顶层作用域…</strong></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">isUnknown</span>(arg) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">arg.isUnknown</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后把“以标准方式应对特例”的地方都替换成使用特例字面量的值。首先从“名字”开始：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">createUnknownCustomer</span>() &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">&#123;</span><br>    isUnknown: <span class="hljs-literal">true</span>,<br>    name: <span class="hljs-string">&quot;occupant&quot;</span>,<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>客户端 1…</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">const customerName <span class="hljs-operator">=</span> aCustomer.name<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>接着是“计价套餐”：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">createUnknownCustomer</span>() &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">&#123;</span><br>    isUnknown: <span class="hljs-literal">true</span>,<br>    name: <span class="hljs-string">&quot;occupant&quot;</span>,<br>    billingPlan: registry.billingPlans.basic,<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>客户端 2…</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">const plan <span class="hljs-operator">=</span> aCustomer.billingPlan<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>同样，我可以在字面量对象中创建一个嵌套的空支付记录对象：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">createUnknownCustomer</span>() &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">&#123;</span><br>    isUnknown: <span class="hljs-literal">true</span>,<br>    name: <span class="hljs-string">&quot;occupant&quot;</span>,<br>    billingPlan: registry.billingPlans.basic,<br>    paymentHistory: &#123;<br>      weeksDelinquentInLastYear: <span class="hljs-number">0</span>,<br>    &#125;,<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>客户端 3…</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">const weeksDelinquent <span class="hljs-operator">=</span> aCustomer.paymentHistory.weeksDelinquentInLastYear<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>如果使用了这样的字面量，应该使用诸如 Object.freeze 的方法将其冻结，使其不可变。通常，我还是喜欢用类多一点。</p><h3 id="范例：使用变换"><a href="#范例：使用变换" class="headerlink" title="范例：使用变换"></a>范例：使用变换</h3><p>前面两个例子都涉及了一个类，其实本重构手法也同样适用于记录，只要增加一个变换步骤即可。</p><p>假设我们的输入是一个简单的记录结构，大概像这样：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol"> name:</span> <span class="hljs-string">&quot;Acme Boston&quot;</span>,<br><span class="hljs-symbol"> location:</span> <span class="hljs-string">&quot;Malden MA&quot;</span>,<br> <span class="hljs-comment">// more site details</span><br><span class="hljs-symbol"> customer:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">  name:</span> <span class="hljs-string">&quot;Acme Industries&quot;</span>,<br><span class="hljs-symbol">  billingPlan:</span> <span class="hljs-string">&quot;plan-451&quot;</span>,<br><span class="hljs-symbol">  paymentHistory:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">   weeksDelinquentInLastYear:</span> <span class="hljs-number">7</span><br>   <span class="hljs-comment">//more</span><br>  <span class="hljs-punctuation">&#125;</span>,<br>  <span class="hljs-comment">// more</span><br> <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>有时顾客的名字未知，此时标记的方式与前面一样：将 customer 字段标记为字符串”unknown”。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">name:</span> <span class="hljs-string">&quot;Warehouse Unit 15&quot;</span>,<br><span class="hljs-symbol">location:</span> <span class="hljs-string">&quot;Malden MA&quot;</span>,<br><span class="hljs-comment">// more site details</span><br><span class="hljs-symbol">customer:</span> <span class="hljs-string">&quot;unknown&quot;</span>,<br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>客户端代码也类似，会检查“未知顾客”的情况：</p><p><strong>客户端 1…</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs abnf">const site <span class="hljs-operator">=</span> acquireSiteData()<span class="hljs-comment">;</span><br>const aCustomer <span class="hljs-operator">=</span> site.customer<span class="hljs-comment">;</span><br>// ... lots of intervening code ...<br>let customerName<span class="hljs-comment">;</span><br>if (aCustomer <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-string">&quot;unknown&quot;</span>) customerName <span class="hljs-operator">=</span> <span class="hljs-string">&quot;occupant&quot;</span><span class="hljs-comment">;</span><br>else customerName <span class="hljs-operator">=</span> aCustomer.name<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><strong>客户端 2…</strong></p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-keyword">const</span> plan =<br>  aCustomer === <span class="hljs-string">&quot;unknown&quot;</span> ? registry.billingPlans.<span class="hljs-keyword">basic</span> : aCustomer.billingPlan;<br></code></pre></td></tr></table></figure><p><strong>客户端 3…</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">const</span> weeksDelinquent =<br>  aCustomer === <span class="hljs-string">&quot;unknown&quot;</span><br>    ? <span class="hljs-number">0</span><br>    : aCustomer.paymentHistory.weeksDelinquentInLastYear;<br></code></pre></td></tr></table></figure><p>我首先要让 Site 数据结构经过一次变换，目前变换中只做了深复制，没有对数据做任何处理。</p><p><strong>客户端 1…</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs abnf">const rawSite <span class="hljs-operator">=</span> acquireSiteData()<span class="hljs-comment">;</span><br>const site <span class="hljs-operator">=</span> enrichSite(rawSite)<span class="hljs-comment">;</span><br>const aCustomer <span class="hljs-operator">=</span> site.customer<span class="hljs-comment">;</span><br>// ... lots of intervening code ...<br>let customerName<span class="hljs-comment">;</span><br>if (aCustomer <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-string">&quot;unknown&quot;</span>) customerName <span class="hljs-operator">=</span> <span class="hljs-string">&quot;occupant&quot;</span><span class="hljs-comment">;</span><br>else customerName <span class="hljs-operator">=</span> aCustomer.name<span class="hljs-comment">;</span><br><br>function enrichSite(inputSite) &#123;<br>  return _.cloneDeep(inputSite)<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>然后对“检查未知顾客”的代码运用提炼函数（106）。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">isUnknown</span>(aCustomer) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">aCustomer</span> === <span class="hljs-string">&quot;unknown&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>客户端 1…</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs abnf">const rawSite <span class="hljs-operator">=</span> acquireSiteData()<span class="hljs-comment">;</span><br>const site <span class="hljs-operator">=</span> enrichSite(rawSite)<span class="hljs-comment">;</span><br>const aCustomer <span class="hljs-operator">=</span> site.customer<span class="hljs-comment">;</span><br>// ... lots of intervening code ...<br>let customerName<span class="hljs-comment">;</span><br>if (isUnknown(aCustomer)) customerName <span class="hljs-operator">=</span> <span class="hljs-string">&quot;occupant&quot;</span><span class="hljs-comment">;</span><br>else customerName <span class="hljs-operator">=</span> aCustomer.name<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><strong>客户端 2…</strong></p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-keyword">const</span> plan = isUnknown(aCustomer)<br>  ? registry.billingPlans.<span class="hljs-keyword">basic</span><br>  : aCustomer.billingPlan;<br></code></pre></td></tr></table></figure><p><strong>客户端 3…</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">const weeksDelinquent = is<span class="hljs-constructor">Unknown(<span class="hljs-params">aCustomer</span>)</span><br>  ? <span class="hljs-number">0</span><br>  : aCustomer.paymentHistory.weeksDelinquentInLastYear;<br></code></pre></td></tr></table></figure><p>然后开始对 Site 数据做增强，首先是给 customer 字段加上 isUnknown 属性。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> enrich<span class="hljs-constructor">Site(<span class="hljs-params">aSite</span>)</span> &#123;<br>  const result = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">_</span>.</span></span>clone<span class="hljs-constructor">Deep(<span class="hljs-params">aSite</span>)</span>;<br>  const unknownCustomer = &#123;<br>    isUnknown: <span class="hljs-literal">true</span>,<br>  &#125;;<br><br>  <span class="hljs-keyword">if</span> (is<span class="hljs-constructor">Unknown(<span class="hljs-params">result</span>.<span class="hljs-params">customer</span>)</span>) result.customer = unknownCustomer;<br>  <span class="hljs-keyword">else</span> result.customer.isUnknown = <span class="hljs-literal">false</span>;<br>  return result;<br>&#125;<br></code></pre></td></tr></table></figure><p>随后修改检查特例的条件逻辑，开始使用新的属性。原来的检查逻辑也保留不动，所以现在的检查逻辑应该既能应对原来的 Site 数据，也能应对增强后的 Site 数据。</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-variable">function</span> <span class="hljs-title function_">isUnknown</span>(<span class="hljs-params">aCustomer</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable">aCustomer</span> <span class="hljs-operator">==</span><span class="hljs-operator">=</span> <span class="hljs-string">&quot;unknown&quot;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-variable">aCustomer</span>.<span class="hljs-property">isUnknown</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试，确保一切正常，然后针对特例使用函数组合成变换（149）。首先把“未知顾客的名字”的处理逻辑搬进增强函数。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> enrich<span class="hljs-constructor">Site(<span class="hljs-params">aSite</span>)</span> &#123;<br>  const result = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">_</span>.</span></span>clone<span class="hljs-constructor">Deep(<span class="hljs-params">aSite</span>)</span>;<br>  const unknownCustomer = &#123;<br>    isUnknown: <span class="hljs-literal">true</span>,<br>    name: <span class="hljs-string">&quot;occupant&quot;</span>,<br>  &#125;;<br><br>  <span class="hljs-keyword">if</span> (is<span class="hljs-constructor">Unknown(<span class="hljs-params">result</span>.<span class="hljs-params">customer</span>)</span>) result.customer = unknownCustomer;<br>  <span class="hljs-keyword">else</span> result.customer.isUnknown = <span class="hljs-literal">false</span>;<br>  return result;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>客户端 1…</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">const rawSite <span class="hljs-operator">=</span> acquireSiteData()<span class="hljs-comment">;</span><br>const site <span class="hljs-operator">=</span> enrichSite(rawSite)<span class="hljs-comment">;</span><br>const aCustomer <span class="hljs-operator">=</span> site.customer<span class="hljs-comment">;</span><br>// ... lots of intervening code ...<br>const customerName <span class="hljs-operator">=</span> aCustomer.name<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>测试，然后是“未知顾客的计价套餐”的处理逻辑。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> enrich<span class="hljs-constructor">Site(<span class="hljs-params">aSite</span>)</span> &#123;<br>  const result = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">_</span>.</span></span>clone<span class="hljs-constructor">Deep(<span class="hljs-params">aSite</span>)</span>;<br>  const unknownCustomer = &#123;<br>    isUnknown: <span class="hljs-literal">true</span>,<br>    name: <span class="hljs-string">&quot;occupant&quot;</span>,<br>    billingPlan: registry.billingPlans.basic,<br>  &#125;;<br><br>  <span class="hljs-keyword">if</span> (is<span class="hljs-constructor">Unknown(<span class="hljs-params">result</span>.<span class="hljs-params">customer</span>)</span>) result.customer = unknownCustomer;<br>  <span class="hljs-keyword">else</span> result.customer.isUnknown = <span class="hljs-literal">false</span>;<br>  return result;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>客户端 2…</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">const plan <span class="hljs-operator">=</span> aCustomer.billingPlan<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>再次测试，然后处理最后一处客户端代码。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> enrich<span class="hljs-constructor">Site(<span class="hljs-params">aSite</span>)</span> &#123;<br>  const result = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">_</span>.</span></span>clone<span class="hljs-constructor">Deep(<span class="hljs-params">aSite</span>)</span>;<br>  const unknownCustomer = &#123;<br>    isUnknown: <span class="hljs-literal">true</span>,<br>    name: <span class="hljs-string">&quot;occupant&quot;</span>,<br>    billingPlan: registry.billingPlans.basic,<br>    paymentHistory: &#123;<br>      weeksDelinquentInLastYear: <span class="hljs-number">0</span>,<br>    &#125;,<br>  &#125;;<br><br>  <span class="hljs-keyword">if</span> (is<span class="hljs-constructor">Unknown(<span class="hljs-params">result</span>.<span class="hljs-params">customer</span>)</span>) result.customer = unknownCustomer;<br>  <span class="hljs-keyword">else</span> result.customer.isUnknown = <span class="hljs-literal">false</span>;<br>  return result;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>客户端 3…</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">const weeksDelinquent <span class="hljs-operator">=</span> aCustomer.paymentHistory.weeksDelinquentInLastYear<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h2 id="10-6-引入断言（Introduce-Assertion）"><a href="#10-6-引入断言（Introduce-Assertion）" class="headerlink" title="10.6 引入断言（Introduce Assertion）"></a>10.6 引入断言（Introduce Assertion）</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp">  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.discountRate)<br>  <span class="hljs-keyword">base</span> = <span class="hljs-keyword">base</span> - (<span class="hljs-keyword">this</span>.discountRate * <span class="hljs-keyword">base</span>);<br><br><br>  assert(<span class="hljs-keyword">this</span>.discountRate&gt;= <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.discountRate)<br>  <span class="hljs-keyword">base</span> = <span class="hljs-keyword">base</span> - (<span class="hljs-keyword">this</span>.discountRate * <span class="hljs-keyword">base</span>);<br></code></pre></td></tr></table></figure><h3 id="动机-5"><a href="#动机-5" class="headerlink" title="动机"></a>动机</h3><p>常常会有这样一段代码：只有当某个条件为真时，该段代码才能正常运行。例如，平方根计算只对正值才能进行，又例如，某个对象可能假设一组字段中至少有一个不等于 null。</p><p>这样的假设通常并没有在代码中明确表现出来，你必须阅读整个算法才能看出。有时程序员会以注释写出这样的假设，而我要介绍的是一种更好的技术——使用断言明确标明这些假设。</p><p>断言是一个条件表达式，应该总是为真。如果它失败，表示程序员犯了错误。断言的失败不应该被系统任何地方捕捉。整个程序的行为在有没有断言出现的时候都应该完全一样。实际上，有些编程语言中的断言可以在编译期用一个开关完全禁用掉。</p><p>我常看见有人鼓励用断言来发现程序中的错误。这固然是一件好事，但却不是使用断言的唯一理由。断言是一种很有价值的交流形式——它们告诉阅读者，程序在执行到这一点时，对当前状态做了何种假设。另外断言对调试也很有帮助。而且，因为它们在交流上很有价值，即使解决了当下正在追踪的错误，我还是倾向于把断言留着。自测试的代码降低了断言在调试方面的价值，因为逐步逼近的单元测试通常能更好地帮助调试，但我仍然看重断言在交流方面的价值。</p><h3 id="做法-5"><a href="#做法-5" class="headerlink" title="做法"></a>做法</h3><p>如果你发现代码假设某个条件始终为真，就加入一个断言明确说明这种情况。</p><p>因为断言应该不会对系统运行造成任何影响，所以“加入断言”永远都应该是行为保持的。</p><h3 id="范例-5"><a href="#范例-5" class="headerlink" title="范例"></a>范例</h3><p>下面是一个简单的例子：折扣。顾客（customer）会获得一个折扣率（discount rate），可以用于所有其购买的商品。</p><p><strong>class Customer…</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">applyDiscount(aNumber) &#123;<br>  <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.discountRate)<br>    ? aNumber - (<span class="hljs-keyword">this</span>.discountRate * aNumber)<br>    : aNumber;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里有一个假设：折扣率永远是正数。我可以用断言明确标示出这个假设。但在一个三元表达式中没办法很简单地插入断言，所以我首先要把这个表达式转换成 if-else 的形式。</p><p><strong>class Customer…</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">applyDiscount(aNumber) &#123;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.discountRate) <span class="hljs-keyword">return</span> aNumber;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> aNumber - (<span class="hljs-keyword">this</span>.discountRate * aNumber);<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我就可以轻松地加入断言了。</p><p><strong>class Customer…</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">applyDiscount(aNumber) &#123;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.discountRate) <span class="hljs-keyword">return</span> aNumber;<br>  <span class="hljs-keyword">else</span> &#123;<br>    assert(<span class="hljs-keyword">this</span>.discountRate &gt;= <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> aNumber - (<span class="hljs-keyword">this</span>.discountRate * aNumber);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对这个例子而言，我更愿意把断言放在设值函数上。如果在 applyDiscount 函数处发生断言失败，我还得先费力搞清楚非法的折扣率值起初是从哪儿放进去的。</p><p><strong>class Customer…</strong></p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-variable">set</span> <span class="hljs-title function_">discountRate</span>(<span class="hljs-params">aNumber</span>) &#123;<br>  <span class="hljs-title function_">assert</span>(<span class="hljs-literal">null</span> <span class="hljs-operator">==</span><span class="hljs-operator">=</span> <span class="hljs-variable">aNumber</span> <span class="hljs-operator">||</span> <span class="hljs-variable">aNumber</span> <span class="hljs-operator">&gt;=</span> <span class="hljs-number">0</span>);<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-variable">_discountRate</span> <span class="hljs-operator">=</span> <span class="hljs-variable">aNumber</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>真正引起错误的源头有可能很难发现——也许是输入数据中误写了一个减号，也许是某处代码做数据转换时犯了错误。像这样的断言对于发现错误源头特别有帮助。</p><p>注意，不要滥用断言。我不会使用断言来检查所有“我认为应该为真”的条件，只用来检查“必须为真”的条件。滥用断言可能会造成代码重复，尤其是在处理上面这样的条件逻辑时。所以我发现，很有必要去掉条件逻辑中的重复，通常可以借助提炼函数（106）手法。</p><p>我只用断言预防程序员的错误。如果要从某个外部数据源读取数据，那么所有对输入值的检查都应该是程序的一等公民，而不能用断言实现——除非我对这个外部数据源有绝对的信心。断言是帮助我们跟踪 bug 的最后一招，所以，或许听来讽刺，只有当我认为断言绝对不会失败的时候，我才会使用断言。</p><hr><h1 id="11-重构-API"><a href="#11-重构-API" class="headerlink" title="11.重构 API"></a>11.重构 API</h1><p>模块和函数是软件的骨肉，而 API 则是将骨肉连接起来的关节。易于理解和使用的 API 非常重要，但同时也很难获得。随着对软件理解的加深，我会学到如何改进 API，这时我便需要对 API 进行重构。</p><p>好的 API 会把更新数据的函数与只是读取数据的函数清晰分开。如果我看到这两类操作被混在一起，就会用将查询函数和修改函数分离（306）将它们分开。如果两个函数的功能非常相似、只有一些数值不同，我可以用函数参数化（310）将其统一。但有些参数其实只是一个标记，根据这个标记的不同，函数会有截然不同的行为，此时最好用移除标记参数（314）将不同的行为彻底分开。</p><p>在函数间传递时，数据结构常会毫无必要地被拆开，我更愿意用保持对象完整（319）将其聚拢。函数需要的一份信息，究竟何时应该作为参数传入、何时应该调用一个函数获得，这是一个需要反复推敲的决定，推敲的过程中常常要用到以查询取代参数（324）和以参数取代查询（327）。</p><p>类是一种常见的模块形式。我希望尽可能保持对象不可变，所以只要有可能，我就会使用移除设值函数（331）。当调用者要求一个新对象时，我经常需要比构造函数更多的灵活性，可以借助以工厂函数取代构造函数（334）获得这种灵活性。</p><p>有时你会遇到一个特别复杂的函数，围绕着它传入传出一大堆数据。最后两个重构手法专门用于破解这个难题。我可以用以命令取代函数（337）将这个函数变成对象，这样对函数体使用提炼函数（106）时会更容易。如果稍后我对该函数做了简化，不再需要将其作为命令对象了，可以用以函数取代命令（344）再把它变回函数。</p><h2 id="11-1-将查询函数和修改函数分离（Separate-Query-from-Modifier）"><a href="#11-1-将查询函数和修改函数分离（Separate-Query-from-Modifier）" class="headerlink" title="11.1 将查询函数和修改函数分离（Separate Query from Modifier）"></a>11.1 将查询函数和修改函数分离（Separate Query from Modifier）</h2><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getTotalOutstandingAndSendBill</span>(<span class="hljs-params"></span>) &#123;<br>const result = customer.invoices.<span class="hljs-built_in">reduce</span>(<span class="hljs-function">(<span class="hljs-params">total, each</span>) =&gt;</span> each.amount + total, <span class="hljs-number">0</span>);<br>sendBill();<br><span class="hljs-keyword">return</span> result;<br>&#125;<br><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">totalOutstanding</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">return</span> customer.invoices.<span class="hljs-built_in">reduce</span>(<span class="hljs-function">(<span class="hljs-params">total, each</span>) =&gt;</span> each.amount + total, <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sendBill</span>(<span class="hljs-params"></span>) &#123;<br>emailGateway.send(formatBill(customer));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="动机-6"><a href="#动机-6" class="headerlink" title="动机"></a>动机</h3><p>如果某个函数只是提供一个值，没有任何看得到的副作用，那么这是一个很有价值的东西。我可以任意调用这个函数，也可以把调用动作搬到调用函数的其他地方。这种函数的测试也更容易。简而言之，需要操心的事情少多了。</p><p>明确表现出“有副作用”与“无副作用”两种函数之间的差异，是个很好的想法。下面是一条好规则：任何有返回值的函数，都不应该有看得到的副作用——命令与查询分离（Command-Query Separation）[mf-cqs]。有些程序员甚至将此作为一条必须遵守的规则。就像对待任何东西一样，我并不绝对遵守它，不过我总是尽量遵守，而它也回报我很好的效果。</p><p>如果遇到一个“既有返回值又有副作用”的函数，我就会试着将查询动作从修改动作中分离出来。</p><p>你也许已经注意到了：我使用“看得到的副作用”这种说法。有一种常见的优化办法是：将查询所得结果缓存于某个字段中，这样一来后续的重复查询就可以大大加快速度。虽然这种做法改变了对象中缓存的状态，但这一修改是察觉不到的，因为不论如何查询，总是获得相同结果。</p><h3 id="做法-6"><a href="#做法-6" class="headerlink" title="做法"></a>做法</h3><p>复制整个函数，将其作为一个查询来命名。</p><p>如果想不出好名字，可以看看函数返回的是什么。查询的结果会被填入一个变量，这个变量的名字应该能对函数如何命名有所启发。</p><p>从新建的查询函数中去掉所有造成副作用的语句。</p><p>执行静态检查。</p><p>查找所有调用原函数的地方。如果调用处用到了该函数的返回值，就将其改为调用新建的查询函数，并在下面马上再调用一次原函数。每次修改之后都要测试。</p><p>从原函数中去掉返回值。</p><p>测试。</p><p>完成重构之后，查询函数与原函数之间常会有重复代码，可以做必要的清理。</p><h3 id="范例-6"><a href="#范例-6" class="headerlink" title="范例"></a>范例</h3><p>有这样一个函数：它会遍历一份恶棍（miscreant）名单，检查一群人（people）里是否混进了恶棍。如果发现了恶棍，该函数会返回恶棍的名字，并拉响警报。如果人群中有多名恶棍，该函数也只汇报找出的第一名恶棍（我猜这就已经够了）。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs abnf">function alertForMiscreant(people) &#123;<br>  for (const p of people) &#123;<br>    if (p <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-string">&quot;Don&quot;</span>) &#123;<br>      setOffAlarms()<span class="hljs-comment">;</span><br>      return <span class="hljs-string">&quot;Don&quot;</span><span class="hljs-comment">;</span><br>    &#125;<br>    if (p <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-string">&quot;John&quot;</span>) &#123;<br>      setOffAlarms()<span class="hljs-comment">;</span><br>      return <span class="hljs-string">&quot;John&quot;</span><span class="hljs-comment">;</span><br>    &#125;<br>  &#125;<br>  return <span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>首先我复制整个函数，用它的查询部分功能为其命名。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs abnf">function findMiscreant(people) &#123;<br>  for (const p of people) &#123;<br>    if (p <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-string">&quot;Don&quot;</span>) &#123;<br>      setOffAlarms()<span class="hljs-comment">;</span><br>      return <span class="hljs-string">&quot;Don&quot;</span><span class="hljs-comment">;</span><br>    &#125;<br>    if (p <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-string">&quot;John&quot;</span>) &#123;<br>      setOffAlarms()<span class="hljs-comment">;</span><br>      return <span class="hljs-string">&quot;John&quot;</span><span class="hljs-comment">;</span><br>    &#125;<br>  &#125;<br>  return <span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>然后在新建的查询函数中去掉副作用。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs abnf">function findMiscreant(people) &#123;<br>  for (const p of people) &#123;<br>    if (p <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-string">&quot;Don&quot;</span>) &#123;<br>      setOffAlarms()<span class="hljs-comment">;</span><br>      return <span class="hljs-string">&quot;Don&quot;</span><span class="hljs-comment">;</span><br>    &#125;<br>    if (p <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-string">&quot;John&quot;</span>) &#123;<br>      setOffAlarms()<span class="hljs-comment">;</span><br>      return <span class="hljs-string">&quot;John&quot;</span><span class="hljs-comment">;</span><br>    &#125;<br>  &#125;<br>  return <span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>然后找到所有原函数的调用者，将其改为调用新建的查询函数，并在其后调用一次修改函数（也就是原函数）。于是代码</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">const found <span class="hljs-operator">=</span> alertForMiscreant(people)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>就变成了</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">const found = find<span class="hljs-constructor">Miscreant(<span class="hljs-params">people</span>)</span>;<br>alert<span class="hljs-constructor">ForMiscreant(<span class="hljs-params">people</span>)</span>;<br></code></pre></td></tr></table></figure><p>现在可以从修改函数中去掉所有返回值了。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs abnf">function alertForMiscreant(people) &#123;<br>  for (const p of people) &#123;<br>    if (p <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-string">&quot;Don&quot;</span>) &#123;<br>      setOffAlarms()<span class="hljs-comment">;</span><br>      return<span class="hljs-comment">;</span><br>    &#125;<br>    if (p <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-string">&quot;John&quot;</span>) &#123;<br>      setOffAlarms()<span class="hljs-comment">;</span><br>      return<span class="hljs-comment">;</span><br>    &#125;<br>  &#125;<br>  return<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>现在，原来的修改函数和新建的查询函数之间有大量的重复代码，我可以使用替换算法（195），让修改函数使用查询函数。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> alert<span class="hljs-constructor">ForMiscreant(<span class="hljs-params">people</span>)</span> &#123;<br>  <span class="hljs-keyword">if</span> (find<span class="hljs-constructor">Miscreant(<span class="hljs-params">people</span>)</span> !== <span class="hljs-string">&quot;&quot;</span>) set<span class="hljs-constructor">OffAlarms()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="11-2-函数参数化（Parameterize-Function）"><a href="#11-2-函数参数化（Parameterize-Function）" class="headerlink" title="11.2 函数参数化（Parameterize Function）"></a>11.2 函数参数化（Parameterize Function）</h2><p>曾用名：令函数携带参数（Parameterize Method）</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">tenPercentRaise</span>(aPerson) &#123;<br>  aPerson.salary = aPerson.salary.multiply(1.1);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title">fivePercentRaise</span>(aPerson) &#123;<br>  aPerson.salary = aPerson.salary.multiply(1.05);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title">raise</span>(aPerson, factor) &#123;<br>  aPerson.salary = aPerson.salary.multiply(1 + factor);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="动机-7"><a href="#动机-7" class="headerlink" title="动机"></a>动机</h3><p>如果我发现两个函数逻辑非常相似，只有一些字面量值不同，可以将其合并成一个函数，以参数的形式传入不同的值，从而消除重复。这个重构可以使函数更有用，因为重构后的函数还可以用于处理其他的值。</p><h3 id="做法-7"><a href="#做法-7" class="headerlink" title="做法"></a>做法</h3><p>从一组相似的函数中选择一个。</p><p>运用改变函数声明（124），把需要作为参数传入的字面量添加到参数列表中。</p><p>修改该函数所有的调用处，使其在调用时传入该字面量值。</p><p>测试。</p><p>修改函数体，令其使用新传入的参数。每使用一个新参数都要测试。</p><p>对于其他与之相似的函数，逐一将其调用处改为调用已经参数化的函数。每次修改后都要测试。</p><p>如果第一个函数经过参数化以后不能直接替代另一个与之相似的函数，就先对参数化之后的函数做必要的调整，再做替换。</p><h3 id="范例-7"><a href="#范例-7" class="headerlink" title="范例"></a>范例</h3><p>下面是一个显而易见的例子：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">tenPercentRaise</span>(aPerson) &#123;<br>  aPerson.salary = aPerson.salary.multiply(1.1);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title">fivePercentRaise</span>(aPerson) &#123;<br>  aPerson.salary = aPerson.salary.multiply(1.05);<br>&#125;<br></code></pre></td></tr></table></figure><p>很明显我可以用下面这个函数来替换上面两个：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">raise</span>(aPerson, factor) &#123;<br>  aPerson.salary = aPerson.salary.multiply(1 + factor);<br>&#125;<br></code></pre></td></tr></table></figure><p>情况可能比这个更复杂一些。例如下列代码：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">baseCharge</span>(usage) &#123;<br> if (usage &lt; 0) <span class="hljs-keyword">return</span> <span class="hljs-type">usd(0)</span>;<br> const amount =<br>    bottomBand(usage) * <span class="hljs-number">0.03</span><br>    + middleBand(usage) * <span class="hljs-number">0.05</span><br>    + topBand(usage) * <span class="hljs-number">0.07</span>;<br> <span class="hljs-keyword">return</span> usd(amount);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title">bottomBand</span>(usage) &#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-type">Math.min(usage,</span> <span class="hljs-number">100</span>);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title">middleBand</span>(usage) &#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-type">usage</span> &gt; <span class="hljs-number">100</span> ? Math.min(usage, <span class="hljs-number">200</span>) - <span class="hljs-number">100</span> : 0;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title">topBand</span>(usage) &#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-type">usage</span> &gt; <span class="hljs-number">200</span> ? usage - <span class="hljs-number">200</span> : 0;<br>&#125;<br></code></pre></td></tr></table></figure><p>这几个函数中的逻辑明显很相似，但是不是相似到足以支撑一个参数化的计算“计费档次”（band）的函数？这次就不像前面第一个例子那样一目了然了。</p><p>在尝试对几个相关的函数做参数化操作时，我会先从中挑选一个，在上面添加参数，同时留意其他几种情况。在类似这样处理“范围”的情况下，通常从位于中间的范围开始着手较好。所以我首先选择了 middleBand 函数来添加参数，然后调整其他的调用者来适应它。</p><p>middleBand 使用了两个字面量值，即 100 和 200，分别代表“中间档次”的下界和上界。我首先用改变函数声明（124）加上这两个参数，同时顺手给函数改个名，使其更好地表述参数化之后的含义。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> within<span class="hljs-constructor">Band(<span class="hljs-params">usage</span>, <span class="hljs-params">bottom</span>, <span class="hljs-params">top</span>)</span> &#123;<br> return usage &gt; <span class="hljs-number">100</span> ? <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>min(usage, <span class="hljs-number">200</span>) - <span class="hljs-number">100</span> : <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> base<span class="hljs-constructor">Charge(<span class="hljs-params">usage</span>)</span> &#123;<br> <span class="hljs-keyword">if</span> (usage &lt; <span class="hljs-number">0</span>) return usd(<span class="hljs-number">0</span>);<br> const amount =<br>    bottom<span class="hljs-constructor">Band(<span class="hljs-params">usage</span>)</span><span class="hljs-operator"> * </span><span class="hljs-number">0.03</span><br>    + within<span class="hljs-constructor">Band(<span class="hljs-params">usage</span>, 100, 200)</span><span class="hljs-operator"> * </span><span class="hljs-number">0.05</span><br>    + top<span class="hljs-constructor">Band(<span class="hljs-params">usage</span>)</span><span class="hljs-operator"> * </span><span class="hljs-number">0.07</span>;<br> return usd(amount);<br>&#125;<br></code></pre></td></tr></table></figure><p>在函数体内部，把一个字面量改为使用新传入的参数：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">withinBand</span>(usage, bottom, top) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">usage</span> &amp; gt;<br>  bottom ? Math.min(usage, <span class="hljs-number">200</span>) - bottom : 0;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后是另一个：</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nsis"><span class="hljs-keyword">function</span> <span class="hljs-title function_">withinBand</span>(usage, <span class="hljs-literal">bottom</span>, <span class="hljs-literal">top</span>) &#123;<br>  <span class="hljs-keyword">return</span> usage &amp; gt<span class="hljs-comment">;</span><br>  <span class="hljs-literal">bottom</span> ? Math.min(usage, <span class="hljs-literal">top</span>) - <span class="hljs-literal">bottom</span> : <span class="hljs-number">0</span><span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>对于原本调用 bottomBand 函数的地方，我将其改为调用参数化了的新函数。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> baseCharge(<span class="hljs-keyword">usage</span>) &#123;<br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">usage</span> &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> usd(<span class="hljs-number">0</span>);<br> const amount =<br>    withinBand(<span class="hljs-keyword">usage</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>) * <span class="hljs-number">0.03</span><br>    + withinBand(<span class="hljs-keyword">usage</span>, <span class="hljs-number">100</span>, <span class="hljs-number">200</span>) * <span class="hljs-number">0.05</span><br>    + topBand(<span class="hljs-keyword">usage</span>) * <span class="hljs-number">0.07</span>;<br> <span class="hljs-keyword">return</span> usd(amount);<br>&#125;<br><br><span class="hljs-keyword">function</span> bottomBand(<span class="hljs-keyword">usage</span>) &#123;<br> <span class="hljs-keyword">return</span> Math.min(<span class="hljs-keyword">usage</span>, <span class="hljs-number">100</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>为了替换对 topBand 的调用，我就得用代表“无穷大”的 Infinity 作为这个范围的上界。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> baseCharge(<span class="hljs-keyword">usage</span>) &#123;<br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">usage</span> &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> usd(<span class="hljs-number">0</span>);<br> const amount =<br>    withinBand(<span class="hljs-keyword">usage</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>) * <span class="hljs-number">0.03</span><br>    + withinBand(<span class="hljs-keyword">usage</span>, <span class="hljs-number">100</span>, <span class="hljs-number">200</span>) * <span class="hljs-number">0.05</span><br>    + withinBand(<span class="hljs-keyword">usage</span>, <span class="hljs-number">200</span>, <span class="hljs-keyword">Infinity</span>) * <span class="hljs-number">0.07</span>;<br> <span class="hljs-keyword">return</span> usd(amount);<br>&#125;<br><br><span class="hljs-keyword">function</span> topBand(<span class="hljs-keyword">usage</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">usage</span> &gt; <span class="hljs-number">200</span> ? <span class="hljs-keyword">usage</span> - <span class="hljs-number">200</span> : <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>照现在的逻辑，baseCharge 一开始的卫语句已经可以去掉了。不过，尽管这条语句已经失去了逻辑上的必要性，我还是愿意把它留在原地，因为它阐明了“传入的 usage 参数为负数”这种情况是如何处理的。</p><h2 id="11-3-移除标记参数（Remove-Flag-Argument）"><a href="#11-3-移除标记参数（Remove-Flag-Argument）" class="headerlink" title="11.3 移除标记参数（Remove Flag Argument）"></a>11.3 移除标记参数（Remove Flag Argument）</h2><p>曾用名：以明确函数取代参数（Replace Parameter with Explicit Methods）</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-variable">function</span> <span class="hljs-title function_">setDimension</span>(<span class="hljs-params">name</span>, <span class="hljs-params">value</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable">name</span> <span class="hljs-operator">==</span><span class="hljs-operator">=</span> <span class="hljs-string">&quot;height&quot;</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-variable">_height</span> <span class="hljs-operator">=</span> <span class="hljs-variable">value</span>;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable">name</span> <span class="hljs-operator">==</span><span class="hljs-operator">=</span> <span class="hljs-string">&quot;width&quot;</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-variable">_width</span> <span class="hljs-operator">=</span> <span class="hljs-variable">value</span>;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-variable">function</span> <span class="hljs-title function_">setHeight</span>(<span class="hljs-params">value</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-variable">_height</span> <span class="hljs-operator">=</span> <span class="hljs-variable">value</span>;<br>&#125;<br><span class="hljs-variable">function</span> <span class="hljs-title function_">setWidth</span>(<span class="hljs-params">value</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-variable">_width</span> <span class="hljs-operator">=</span> <span class="hljs-variable">value</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="动机-8"><a href="#动机-8" class="headerlink" title="动机"></a>动机</h3><p>“标记参数”是这样的一种参数：调用者用它来指示被调函数应该执行哪一部分逻辑。例如，我可能有下面这样一个函数：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> book<span class="hljs-constructor">Concert(<span class="hljs-params">aCustomer</span>, <span class="hljs-params">isPremium</span>)</span> &#123;<br>  <span class="hljs-keyword">if</span> (isPremium) &#123;<br>    <span class="hljs-comment">// logic for premium booking</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// logic for regular booking</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>要预订一场高级音乐会（premium concert），就得这样发起调用：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">book<span class="hljs-constructor">Concert(<span class="hljs-params">aCustomer</span>, <span class="hljs-params">true</span>)</span>;<br></code></pre></td></tr></table></figure><p>标记参数也可能以枚举的形式出现：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">book<span class="hljs-constructor">Concert(<span class="hljs-params">aCustomer</span>, CustomerType.PREMIUM)</span>;<br></code></pre></td></tr></table></figure><p>或者是以字符串（或者符号，如果编程语言支持的话）的形式出现：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">book<span class="hljs-constructor">Concert(<span class="hljs-params">aCustomer</span>, <span class="hljs-string">&quot;premium&quot;</span>)</span>;<br></code></pre></td></tr></table></figure><p>我不喜欢标记参数，因为它们让人难以理解到底有哪些函数可以调用、应该怎么调用。拿到一份 API 以后，我首先看到的是一系列可供调用的函数，但标记参数却隐藏了函数调用中存在的差异性。使用这样的函数，我还得弄清标记参数有哪些可用的值。布尔型的标记尤其糟糕，因为它们不能清晰地传达其含义——在调用一个函数时，我很难弄清 true 到底是什么意思。如果明确用一个函数来完成一项单独的任务，其含义会清晰得多。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">premium<span class="hljs-constructor">BookConcert(<span class="hljs-params">aCustomer</span>)</span>;<br></code></pre></td></tr></table></figure><p>并非所有类似这样的参数都是标记参数。如果调用者传入的是程序中流动的数据，这样的参数不算标记参数；只有调用者直接传入字面量值，这才是标记参数。另外，在函数实现内部，如果参数值只是作为数据传给其他函数，这就不是标记参数；只有参数值影响了函数内部的控制流，这才是标记参数。</p><p>移除标记参数不仅使代码更整洁，并且能帮助开发工具更好地发挥作用。去掉标记参数后，代码分析工具能更容易地体现出“高级”和“普通”两种预订逻辑在使用时的区别。</p><p>如果一个函数有多个标记参数，可能就不得不将其保留，否则我就得针对各个参数的各种取值的所有组合情况提供明确函数。不过这也是一个信号，说明这个函数可能做得太多，应该考虑是否能用更简单的函数来组合出完整的逻辑。</p><h3 id="做法-8"><a href="#做法-8" class="headerlink" title="做法"></a>做法</h3><p>针对参数的每一种可能值，新建一个明确函数。</p><p>如果主函数有清晰的条件分发逻辑，可以用分解条件表达式（260）创建明确函数；否则，可以在原函数之上创建包装函数。</p><p>对于“用字面量值作为参数”的函数调用者，将其改为调用新建的明确函数。</p><h3 id="范例-8"><a href="#范例-8" class="headerlink" title="范例"></a>范例</h3><p>在浏览代码时，我发现多处代码在调用一个函数计算物流（shipment）的到货日期（delivery date）。一些调用代码类似这样：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">aShipment.deliveryDate</span> = deliveryDate(anOrder, <span class="hljs-literal">true</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>另一些调用代码则是这样：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">aShipment.deliveryDate</span> = deliveryDate(anOrder, <span class="hljs-literal">false</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>面对这样的代码，我立即开始好奇：参数里这个布尔值是什么意思？是用来干什么的？</p><p>deliveryDate 函数主体如下所示：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deliveryDate</span>(<span class="hljs-params">anOrder, isRush</span>) &#123;<br>  <span class="hljs-keyword">if</span> (isRush) &#123;<br>    let deliveryTime;<br>    <span class="hljs-keyword">if</span> ([<span class="hljs-string">&quot;MA&quot;</span>, <span class="hljs-string">&quot;CT&quot;</span>].<span class="hljs-built_in">includes</span>(anOrder.deliveryState)) deliveryTime = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ([<span class="hljs-string">&quot;NY&quot;</span>, <span class="hljs-string">&quot;NH&quot;</span>].<span class="hljs-built_in">includes</span>(anOrder.deliveryState)) deliveryTime = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">else</span> deliveryTime = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">return</span> anOrder.placedOn.plusDays(<span class="hljs-number">1</span> + deliveryTime);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    let deliveryTime;<br>    <span class="hljs-keyword">if</span> ([<span class="hljs-string">&quot;MA&quot;</span>, <span class="hljs-string">&quot;CT&quot;</span>, <span class="hljs-string">&quot;NY&quot;</span>].<span class="hljs-built_in">includes</span>(anOrder.deliveryState)) deliveryTime = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ([<span class="hljs-string">&quot;ME&quot;</span>, <span class="hljs-string">&quot;NH&quot;</span>].<span class="hljs-built_in">includes</span>(anOrder.deliveryState)) deliveryTime = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">else</span> deliveryTime = <span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">return</span> anOrder.placedOn.plusDays(<span class="hljs-number">2</span> + deliveryTime);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>原来调用者用这个布尔型字面量来判断应该运行哪个分支的代码——典型的标记参数。然而函数的重点就在于要遵循调用者的指令，所以最好是用明确函数的形式明确说出调用者的意图。</p><p>对于这个例子，我可以使用分解条件表达式（260），得到下列代码：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deliveryDate</span>(<span class="hljs-params">anOrder, isRush</span>) &#123;<br>  <span class="hljs-keyword">if</span> (isRush) <span class="hljs-keyword">return</span> rushDeliveryDate(anOrder);<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> regularDeliveryDate(anOrder);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">rushDeliveryDate</span>(<span class="hljs-params">anOrder</span>) &#123;<br>  let deliveryTime;<br>  <span class="hljs-keyword">if</span> ([<span class="hljs-string">&quot;MA&quot;</span>, <span class="hljs-string">&quot;CT&quot;</span>].<span class="hljs-built_in">includes</span>(anOrder.deliveryState)) deliveryTime = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ([<span class="hljs-string">&quot;NY&quot;</span>, <span class="hljs-string">&quot;NH&quot;</span>].<span class="hljs-built_in">includes</span>(anOrder.deliveryState)) deliveryTime = <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">else</span> deliveryTime = <span class="hljs-number">3</span>;<br>  <span class="hljs-keyword">return</span> anOrder.placedOn.plusDays(<span class="hljs-number">1</span> + deliveryTime);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">regularDeliveryDate</span>(<span class="hljs-params">anOrder</span>) &#123;<br>  let deliveryTime;<br>  <span class="hljs-keyword">if</span> ([<span class="hljs-string">&quot;MA&quot;</span>, <span class="hljs-string">&quot;CT&quot;</span>, <span class="hljs-string">&quot;NY&quot;</span>].<span class="hljs-built_in">includes</span>(anOrder.deliveryState)) deliveryTime = <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ([<span class="hljs-string">&quot;ME&quot;</span>, <span class="hljs-string">&quot;NH&quot;</span>].<span class="hljs-built_in">includes</span>(anOrder.deliveryState)) deliveryTime = <span class="hljs-number">3</span>;<br>  <span class="hljs-keyword">else</span> deliveryTime = <span class="hljs-number">4</span>;<br>  <span class="hljs-keyword">return</span> anOrder.placedOn.plusDays(<span class="hljs-number">2</span> + deliveryTime);<br>&#125;<br></code></pre></td></tr></table></figure><p>这两个函数能更好地表达调用者的意图，现在我可以修改调用方代码了。调用代码</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">aShipment.deliveryDate</span> = deliveryDate(anOrder, <span class="hljs-literal">true</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>可以改为</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">aShipment.deliveryDate</span> = rushDeliveryDate(anOrder)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>另一个分支也类似。</p><p>处理完所有调用处，我就可以移除 deliveryDate 函数。</p><p>这个参数是标记参数，不仅因为它是布尔类型，而且还因为调用方以字面量的形式直接设置参数值。如果所有调用 deliveryDate 的代码都像这样：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">const isRush = determine<span class="hljs-constructor">IfRush(<span class="hljs-params">anOrder</span>)</span>;<br>aShipment.deliveryDate = delivery<span class="hljs-constructor">Date(<span class="hljs-params">anOrder</span>, <span class="hljs-params">isRush</span>)</span>;<br></code></pre></td></tr></table></figure><p>那我对这个函数的签名没有任何意见（不过我还是想用分解条件表达式（260）清理其内部实现）。</p><p>可能有一些调用者给这个参数传入的是字面量，将其作为标记参数使用；另一些调用者则传入正常的数据。若果真如此，我还是会使用移除标记参数（314），但不修改传入正常数据的调用者，重构结束时也不删除 deliveryDate 函数。这样我就提供了两套接口，分别支持不同的用途。</p><p>直接拆分条件逻辑是实施本重构的好方法，但只有当“根据参数值做分发”的逻辑发生在函数最外层（或者可以比较容易地将其重构至函数最外层）的时候，这一招才好用。函数内部也有可能以一种更纠结的方式使用标记参数，例如下面这个版本的 deliveryDate 函数：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> delivery<span class="hljs-constructor">Date(<span class="hljs-params">anOrder</span>, <span class="hljs-params">isRush</span>)</span> &#123;<br> <span class="hljs-keyword">let</span> result;<br> <span class="hljs-keyword">let</span> deliveryTime;<br> <span class="hljs-keyword">if</span> (anOrder.deliveryState<span class="hljs-operator"> === </span><span class="hljs-string">&quot;MA&quot;</span><span class="hljs-operator"> || </span>anOrder.deliveryState<span class="hljs-operator"> === </span><span class="hljs-string">&quot;CT&quot;</span>)<br>  deliveryTime = isRush? <span class="hljs-number">1</span> : <span class="hljs-number">2</span>;<br> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (anOrder.deliveryState<span class="hljs-operator"> === </span><span class="hljs-string">&quot;NY&quot;</span><span class="hljs-operator"> || </span>anOrder.deliveryState<span class="hljs-operator"> === </span><span class="hljs-string">&quot;NH&quot;</span>) &#123;<br>  deliveryTime = <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">if</span> (anOrder.deliveryState<span class="hljs-operator"> === </span><span class="hljs-string">&quot;NH&quot;</span> &amp;amp;&amp;amp; !isRush)<br>   deliveryTime = <span class="hljs-number">3</span>;<br> &#125;<br> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isRush)<br>  deliveryTime = <span class="hljs-number">3</span>;<br> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (anOrder.deliveryState<span class="hljs-operator"> === </span><span class="hljs-string">&quot;ME&quot;</span>)<br>  deliveryTime = <span class="hljs-number">3</span>;<br> <span class="hljs-keyword">else</span><br>  deliveryTime = <span class="hljs-number">4</span>;<br> result = anOrder.placedOn.plus<span class="hljs-constructor">Days(2 + <span class="hljs-params">deliveryTime</span>)</span>;<br> <span class="hljs-keyword">if</span> (isRush) result = result.minus<span class="hljs-constructor">Days(1)</span>;<br> return result;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种情况下，想把围绕 isRush 的分发逻辑剥离到顶层，需要的工作量可能会很大。所以我选择退而求其次，在 deliveryDate 之上添加两个函数：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">rushDeliveryDate</span>(anOrder) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">deliveryDate(anOrder,</span> <span class="hljs-literal">true</span>);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title">regularDeliveryDate</span>(anOrder) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">deliveryDate(anOrder,</span> <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>本质上，这两个包装函数分别代表了 deliveryDate 函数一部分的使用方式。不过它们并非从原函数中拆分而来，而是用代码文本强行定义的。</p><p>随后，我同样可以逐一替换原函数的调用者，就跟前面分解条件表达式之后的处理一样。如果没有任何一个调用者向 isRush 参数传入正常的数据，我最后会限制原函数的可见性，或是将其改名（例如改为 deliveryDateHelperOnly），让人一见即知不应直接使用这个函数。</p><h2 id="11-4-保持对象完整（Preserve-Whole-Object）"><a href="#11-4-保持对象完整（Preserve-Whole-Object）" class="headerlink" title="11.4 保持对象完整（Preserve Whole Object）"></a>11.4 保持对象完整（Preserve Whole Object）</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">const low = aRoom.daysTempRange.low;<br>const high = aRoom.daysTempRange.high;<br><span class="hljs-keyword">if</span> (aPlan.within<span class="hljs-constructor">Range(<span class="hljs-params">low</span>, <span class="hljs-params">high</span>)</span>)<br><br><br><span class="hljs-keyword">if</span> (aPlan.within<span class="hljs-constructor">Range(<span class="hljs-params">aRoom</span>.<span class="hljs-params">daysTempRange</span>)</span>)<br></code></pre></td></tr></table></figure><h3 id="动机-9"><a href="#动机-9" class="headerlink" title="动机"></a>动机</h3><p>如果我看见代码从一个记录结构中导出几个值，然后又把这几个值一起传递给一个函数，我会更愿意把整个记录传给这个函数，在函数体内部导出所需的值。</p><p>“传递整个记录”的方式能更好地应对变化：如果将来被调的函数需要从记录中导出更多的数据，我就不用为此修改参数列表。并且传递整个记录也能缩短参数列表，让函数调用更容易看懂。如果有很多函数都在使用记录中的同一组数据，处理这部分数据的逻辑常会重复，此时可以把这些处理逻辑搬移到完整对象中去。</p><p>也有时我不想采用本重构手法，因为我不想让被调函数依赖完整对象，尤其是在两者不在同一个模块中的时候。</p><p>从一个对象中抽取出几个值，单独对这几个值做某些逻辑操作，这是一种代码坏味道（依恋情结），通常标志着这段逻辑应该被搬移到对象中。保持对象完整经常发生在引入参数对象（140）之后，我会搜寻使用原来的数据泥团的代码，代之以使用新的对象。</p><p>如果几处代码都在使用对象的一部分功能，可能意味着应该用提炼类（182）把这一部分功能单独提炼出来。</p><p>还有一种常被忽视的情况：调用者将自己的若干数据作为参数，传递给被调用函数。这种情况下，我可以将调用者的自我引用（在 JavaScript 中就是 this）作为参数，直接传递给目标函数。</p><h3 id="做法-9"><a href="#做法-9" class="headerlink" title="做法"></a>做法</h3><p>新建一个空函数，给它以期望中的参数列表（即传入完整对象作为参数）。</p><p>给这个函数起一个容易搜索的名字，这样到重构结束时方便替换。</p><p>在新函数体内调用旧函数，并把新的参数（即完整对象）映射到旧的参数列表（即来源于完整对象的各项数据）。</p><p>执行静态检查。</p><p>逐一修改旧函数的调用者，令其使用新函数，每次修改之后执行测试。</p><p>修改之后，调用处用于“从完整对象中导出参数值”的代码可能就没用了，可以用移除死代码（237）去掉。</p><p>所有调用处都修改过来之后，使用内联函数（115）把旧函数内联到新函数体内。</p><p>给新函数改名，从重构开始时的容易搜索的临时名字，改为使用旧函数的名字，同时修改所有调用处。</p><h3 id="范例-9"><a href="#范例-9" class="headerlink" title="范例"></a>范例</h3><p>我们想象一个室温监控系统，它负责记录房间一天中的最高温度和最低温度，然后将实际的温度范围与预先规定的温度控制计划（heating plan）相比较，如果当天温度不符合计划要求，就发出警告。</p><p><strong>调用方…</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">const</span> low = aRoom.daysTempRange.low;<br><span class="hljs-attribute">const</span> high = aRoom.daysTempRange.high;<br><span class="hljs-attribute">if</span> (!aPlan.withinRange(low, high))<br>  alerts.push(<span class="hljs-string">&quot;room temperature went outside range&quot;</span>);<br></code></pre></td></tr></table></figure><p><strong>class HeatingPlan…</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">withinRange(bottom, top) &#123;<br> <span class="hljs-keyword">return</span> (bottom &gt;= <span class="hljs-keyword">this</span>._temperatureRange.low) &amp;amp;&amp;amp; (top &lt;= <span class="hljs-keyword">this</span>._temperatureRange.high);<br>&#125;<br></code></pre></td></tr></table></figure><p>其实我不必将“温度范围”的信息拆开来单独传递，只需将整个范围对象传递给 withinRange 函数即可。</p><p>首先，我在 HeatingPlan 类中新添一个空函数，给它赋予我认为合理的参数列表。</p><p><strong>class HeatingPlan…</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">xxNEWwithinRange</span><span class="hljs-params">(aNumberRange)</span></span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为这个函数最终要取代现有的 withinRange 函数，所以它也用了同样的名字，再加上一个容易替换的前缀。</p><p>然后在新函数体内调用现有的 withinRange 函数。因此，新函数体就完成了从新参数列表到旧函数参数列表的映射。</p><p><strong>class HeatingPlan…</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">xx<span class="hljs-constructor">NEWwithinRange(<span class="hljs-params">aNumberRange</span>)</span> &#123;<br>  return this.within<span class="hljs-constructor">Range(<span class="hljs-params">aNumberRange</span>.<span class="hljs-params">low</span>, <span class="hljs-params">aNumberRange</span>.<span class="hljs-params">high</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在开始正式的替换工作了，我要找到调用现有函数的地方，将其改为调用新函数。</p><p><strong>调用方…</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">const</span> low = aRoom.daysTempRange.low;<br><span class="hljs-attribute">const</span> high = aRoom.daysTempRange.high;<br><span class="hljs-attribute">if</span> (!aPlan.xxNEWwithinRange(aRoom.daysTempRange))<br>  alerts.push(<span class="hljs-string">&quot;room temperature went outside range&quot;</span>);<br></code></pre></td></tr></table></figure><p>在修改调用处时，我可能会发现一些代码在修改后已经不再需要，此时可以使用移除死代码（237）。</p><p><strong>调用方…</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">const</span> low = aRoom.daysTempRange.low;<br><span class="hljs-attribute">const</span> high = aRoom.daysTempRange.high;<br><span class="hljs-attribute">if</span> (!aPlan.xxNEWwithinRange(aRoom.daysTempRange))<br>  alerts.push(<span class="hljs-string">&quot;room temperature went outside range&quot;</span>);<br></code></pre></td></tr></table></figure><p>每次替换一处调用代码，每次修改后都要测试。</p><p>调用处全部替换完成后，用内联函数（115）将旧函数内联到新函数体内。</p><p><strong>class HeatingPlan…</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">xxNEWwithinRange(aNumberRange) &#123;<br> <span class="hljs-keyword">return</span> (aNumberRange.low &gt;= <span class="hljs-keyword">this</span>._temperatureRange.low) &amp;amp;&amp;amp;<br>  (aNumberRange.high &lt;= <span class="hljs-keyword">this</span>._temperatureRange.high);<br>&#125;<br></code></pre></td></tr></table></figure><p>终于可以去掉新函数那难看的前缀了，记得同时修改所有调用者。就算我所使用的开发环境不支持可靠的函数改名操作，有这个极具特色的前缀在，我也可以很方便地全局替换。</p><p><strong>class HeatingPlan…</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">withinRange(aNumberRange) &#123;<br> <span class="hljs-keyword">return</span> (aNumberRange.low &gt;= <span class="hljs-keyword">this</span>._temperatureRange.low) &amp;amp;&amp;amp;<br>  (aNumberRange.high &lt;= <span class="hljs-keyword">this</span>._temperatureRange.high);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>调用方…</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">if</span> (!aPlan.within<span class="hljs-constructor">Range(<span class="hljs-params">aRoom</span>.<span class="hljs-params">daysTempRange</span>)</span>)<br>  alerts.push(<span class="hljs-string">&quot;room temperature went outside range&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="范例：换个方式创建新函数"><a href="#范例：换个方式创建新函数" class="headerlink" title="范例：换个方式创建新函数"></a>范例：换个方式创建新函数</h3><p>在上面的示例中，我直接编写了新函数。大多数时候，这一步非常简单，也是创建新函数最容易的方式。不过有时还会用到另一种方式：可以完全通过重构手法的组合来得到新函数。</p><p>我从一处调用现有函数的代码开始。</p><p><strong>调用方…</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">const</span> low = aRoom.daysTempRange.low;<br><span class="hljs-attribute">const</span> high = aRoom.daysTempRange.high;<br><span class="hljs-attribute">if</span> (!aPlan.withinRange(low, high))<br>  alerts.push(<span class="hljs-string">&quot;room temperature went outside range&quot;</span>);<br></code></pre></td></tr></table></figure><p>我要先对代码做一些整理，以便用提炼函数（106）来创建新函数。目前的调用者代码还不具备可提炼的函数雏形，不过我可以先做几次提炼变量（119），使其轮廓显现出来。首先，我要把对旧函数的调用从条件判断中解放出来。</p><p><strong>调用方…</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">const</span> low = aRoom.daysTempRange.low;<br><span class="hljs-attribute">const</span> high = aRoom.daysTempRange.high;<br><span class="hljs-attribute">const</span> isWithinRange = aPlan.withinRange(low, high);<br><span class="hljs-attribute">if</span> (!isWithinRange) alerts.push(<span class="hljs-string">&quot;room temperature went outside range&quot;</span>);<br></code></pre></td></tr></table></figure><p>然后把输入参数也提炼出来。</p><p><strong>调用方…</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">const</span> tempRange = aRoom.daysTempRange;<br><span class="hljs-attribute">const</span> low = tempRange.low;<br><span class="hljs-attribute">const</span> high = tempRange.high;<br><span class="hljs-attribute">const</span> isWithinRange = aPlan.withinRange(low, high);<br><span class="hljs-attribute">if</span> (!isWithinRange) alerts.push(<span class="hljs-string">&quot;room temperature went outside range&quot;</span>);<br></code></pre></td></tr></table></figure><p>完成这一步之后，就可以用提炼函数（106）来创建新函数。</p><p><strong>调用方…</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">const</span> tempRange = aRoom.daysTempRange;<br><span class="hljs-attribute">const</span> isWithinRange = xxNEWwithinRange(aPlan, tempRange);<br><span class="hljs-attribute">if</span> (!isWithinRange) alerts.push(<span class="hljs-string">&quot;room temperature went outside range&quot;</span>);<br></code></pre></td></tr></table></figure><p><strong>顶层作用域…</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> xx<span class="hljs-constructor">NEWwithinRange(<span class="hljs-params">aPlan</span>, <span class="hljs-params">tempRange</span>)</span> &#123;<br>  const low = tempRange.low;<br>  const high = tempRange.high;<br>  const isWithinRange = aPlan.within<span class="hljs-constructor">Range(<span class="hljs-params">low</span>, <span class="hljs-params">high</span>)</span>;<br>  return isWithinRange;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于旧函数属于另一个上下文（HeatingPlan 类），我需要用搬移函数（198）把新函数也搬过去。</p><p><strong>调用方…</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">const</span> tempRange = aRoom.daysTempRange;<br><span class="hljs-attribute">const</span> isWithinRange = aPlan.xxNEWwithinRange(tempRange);<br><span class="hljs-attribute">if</span> (!isWithinRange) alerts.push(<span class="hljs-string">&quot;room temperature went outside range&quot;</span>);<br></code></pre></td></tr></table></figure><p><strong>class HeatingPlan…</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">xxNEWwithinRange</span>(<span class="hljs-params">tempRange</span>) &#123;<br>  <span class="hljs-keyword">const</span> low = tempRange.<span class="hljs-property">low</span>;<br>  <span class="hljs-keyword">const</span> high = tempRange.<span class="hljs-property">high</span>;<br>  <span class="hljs-keyword">const</span> isWithinRange = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">withinRange</span>(low, high);<br>  <span class="hljs-keyword">return</span> isWithinRange;<br>&#125;<br></code></pre></td></tr></table></figure><p>剩下的过程就跟前面一样了：替换其他调用者，然后把旧函数内联到新函数中。重构刚开始的时候，为了清晰分离函数调用，以便提炼出新函数，我提炼了几个变量出来，现在可以把这些变量也内联回去。</p><p>这种方式的好处在于：它完全是由其他重构手法组合而成的。如果我使用的开发工具支持可靠的提炼和内联操作，用这种方式进行本重构会特别流畅。</p><h2 id="11-5-以查询取代参数（Replace-Parameter-with-Query）"><a href="#11-5-以查询取代参数（Replace-Parameter-with-Query）" class="headerlink" title="11.5 以查询取代参数（Replace Parameter with Query）"></a>11.5 以查询取代参数（Replace Parameter with Query）</h2><p>曾用名：以函数取代参数（Replace Parameter with Method）</p><p>反向重构：以参数取代查询（327）</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">available<span class="hljs-constructor">Vacation(<span class="hljs-params">anEmployee</span>, <span class="hljs-params">anEmployee</span>.<span class="hljs-params">grade</span>)</span>;<br><br><span class="hljs-keyword">function</span> available<span class="hljs-constructor">Vacation(<span class="hljs-params">anEmployee</span>, <span class="hljs-params">grade</span>)</span> &#123;<br>  <span class="hljs-comment">// calculate vacation...</span><br><br><br>  available<span class="hljs-constructor">Vacation(<span class="hljs-params">anEmployee</span>)</span><br><br><span class="hljs-keyword">function</span> available<span class="hljs-constructor">Vacation(<span class="hljs-params">anEmployee</span>)</span> &#123;<br>  const grade = anEmployee.grade;<br>  <span class="hljs-comment">// calculate vacation...</span><br></code></pre></td></tr></table></figure><h3 id="动机-10"><a href="#动机-10" class="headerlink" title="动机"></a>动机</h3><p>函数的参数列表应该总结该函数的可变性，标示出函数可能体现出行为差异的主要方式。和任何代码中的语句一样，参数列表应该尽量避免重复，并且参数列表越短就越容易理解。</p><p>如果调用函数时传入了一个值，而这个值由函数自己来获得也是同样容易，这就是重复。这个本不必要的参数会增加调用者的难度，因为它不得不找出正确的参数值，其实原本调用者是不需要费这个力气的。</p><p>“同样容易”四个字，划出了一条判断的界限。去除参数也就意味着“获得正确的参数值”的责任被转移：有参数传入时，调用者需要负责获得正确的参数值；参数去除后，责任就被转移给了函数本身。一般而言，我习惯于简化调用方，因此我愿意把责任移交给函数本身，但如果函数难以承担这份责任，就另当别论了。</p><p>不使用以查询取代参数最常见的原因是，移除参数可能会给函数体增加不必要的依赖关系——迫使函数访问某个程序元素，而我原本不想让函数了解这个元素的存在。这种“不必要的依赖关系”除了新增的以外，也可能是我想要稍后去除的，例如为了去除一个参数，我可能会在函数体内调用一个有问题的函数，或是从一个对象中获取某些原本想要剥离出去的数据。在这些情况下，都应该慎重考虑使用以查询取代参数。</p><p>如果想要去除的参数值只需要向另一个参数查询就能得到，这是使用以查询取代参数最安全的场景。如果可以从一个参数推导出另一个参数，那么几乎没有任何理由要同时传递这两个参数。</p><p>另外有一件事需要留意：如果在处理的函数具有引用透明性（referential transparency，即，不论任何时候，只要传入相同的参数值，该函数的行为永远一致），这样的函数既容易理解又容易测试，我不想使其失去这种优秀品质。我不会去掉它的参数，让它去访问一个可变的全局变量。</p><h3 id="做法-10"><a href="#做法-10" class="headerlink" title="做法"></a>做法</h3><p>如果有必要，使用提炼函数（106）将参数的计算过程提炼到一个独立的函数中。</p><p>将函数体内引用该参数的地方改为调用新建的函数。每次修改后执行测试。</p><p>全部替换完成后，使用改变函数声明（124）将该参数去掉。</p><h3 id="范例-10"><a href="#范例-10" class="headerlink" title="范例"></a>范例</h3><p>某些重构会使参数不再被需要，这是我最常用到以查询取代参数的场合。考虑下列代码。</p><p><strong>class Order…</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">get</span> <span class="hljs-title function_">finalPrice</span>() &#123;<br> <span class="hljs-keyword">const</span> basePrice = <span class="hljs-variable language_">this</span>.<span class="hljs-property">quantity</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">itemPrice</span>;<br> <span class="hljs-keyword">let</span> discountLevel;<br> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">quantity</span> &gt; <span class="hljs-number">100</span>) discountLevel = <span class="hljs-number">2</span>;<br> <span class="hljs-keyword">else</span> discountLevel = <span class="hljs-number">1</span>;<br> <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">discountedPrice</span>(basePrice, discountLevel);<br>&#125;<br><br><span class="hljs-title function_">discountedPrice</span>(<span class="hljs-params">basePrice, discountLevel</span>) &#123;<br> <span class="hljs-keyword">switch</span> (discountLevel) &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> basePrice * <span class="hljs-number">0.95</span>;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-keyword">return</span> basePrice * <span class="hljs-number">0.9</span>;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在简化函数逻辑时，我总是热衷于使用以查询取代临时变量（178），于是就得到了如下代码。</p><p><strong>class Order…</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">get</span> finalPrice() &#123;<br> <span class="hljs-keyword">const</span> basePrice = <span class="hljs-keyword">this</span>.quantity * <span class="hljs-keyword">this</span>.itemPrice;<br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.discountedPrice(basePrice, <span class="hljs-keyword">this</span>.discountLevel);<br>&#125;<br><br><span class="hljs-keyword">get</span> discountLevel() &#123;<br> <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.quantity &gt; <span class="hljs-number">100</span>) ? <span class="hljs-number">2</span> : <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>到这一步，已经不需要再把 discountLevel 的计算结果传给 discountedPrice 了，后者可以自己调用 discountLevel 函数，不会增加任何难度。</p><p>因此，我把 discountedPrice 函数中用到这个参数的地方全都改为直接调用 discountLevel 函数。</p><p><strong>class Order…</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">discountedPrice</span>(<span class="hljs-params">basePrice, discountLevel</span>) &#123;<br> <span class="hljs-keyword">switch</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">discountLevel</span>) &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> basePrice * <span class="hljs-number">0.95</span>;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-keyword">return</span> basePrice * <span class="hljs-number">0.9</span>;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后用改变函数声明（124）手法移除该参数。</p><p><strong>class Order…</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">get</span> finalPrice() &#123;<br> <span class="hljs-keyword">const</span> basePrice = <span class="hljs-keyword">this</span>.quantity * <span class="hljs-keyword">this</span>.itemPrice;<br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.discountedPrice(basePrice, <span class="hljs-keyword">this</span>.discountLevel);<br>&#125;<br><br>discountedPrice(basePrice, discountLevel) &#123;<br> switch (<span class="hljs-keyword">this</span>.discountLevel) &#123;<br>  case <span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> basePrice * <span class="hljs-number">0.95</span>;<br>  case <span class="hljs-number">2</span>: <span class="hljs-keyword">return</span> basePrice * <span class="hljs-number">0.9</span>;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="11-6-以参数取代查询（Replace-Query-with-Parameter）"><a href="#11-6-以参数取代查询（Replace-Query-with-Parameter）" class="headerlink" title="11.6 以参数取代查询（Replace Query with Parameter）"></a>11.6 以参数取代查询（Replace Query with Parameter）</h2><p>反向重构：以查询取代参数（324）</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">  target<span class="hljs-constructor">Temperature(<span class="hljs-params">aPlan</span>)</span><br><br><span class="hljs-keyword">function</span> target<span class="hljs-constructor">Temperature(<span class="hljs-params">aPlan</span>)</span> &#123;<br>  currentTemperature = thermostat.currentTemperature;<br>  <span class="hljs-comment">// rest of function...</span><br><br><br>  target<span class="hljs-constructor">Temperature(<span class="hljs-params">aPlan</span>, <span class="hljs-params">thermostat</span>.<span class="hljs-params">currentTemperature</span>)</span><br><br><span class="hljs-keyword">function</span> target<span class="hljs-constructor">Temperature(<span class="hljs-params">aPlan</span>, <span class="hljs-params">currentTemperature</span>)</span> &#123;<br>  <span class="hljs-comment">// rest of function...</span><br></code></pre></td></tr></table></figure><h3 id="动机-11"><a href="#动机-11" class="headerlink" title="动机"></a>动机</h3><p>在浏览函数实现时，我有时会发现一些令人不快的引用关系，例如，引用一个全局变量，或者引用另一个我想要移除的元素。为了解决这些令人不快的引用，我需要将其替换为函数参数，从而将处理引用关系的责任转交给函数的调用者。</p><p>需要使用本重构的情况大多源于我想要改变代码的依赖关系——为了让目标函数不再依赖于某个元素，我把这个元素的值以参数形式传递给该函数。这里需要注意权衡：如果把所有依赖关系都变成参数，会导致参数列表冗长重复；如果作用域之间的共享太多，又会导致函数间依赖过度。我一向不善于微妙的权衡，所以“能够可靠地改变决定”就显得尤为重要，这样随着我的理解加深，程序也能从中受益。</p><p>如果一个函数用同样的参数调用总是给出同样的结果，我们就说这个函数具有“引用透明性”（referential transparency），这样的函数理解起来更容易。如果一个函数使用了另一个元素，而后者不具引用透明性，那么包含该元素的函数也就失去了引用透明性。只要把“不具引用透明性的元素”变成参数传入，函数就能重获引用透明性。虽然这样就把责任转移给了函数的调用者，但是具有引用透明性的模块能带来很多益处。有一个常见的模式：在负责逻辑处理的模块中只有纯函数，其外再包裹处理 I&#x2F;O 和其他可变元素的逻辑代码。借助以参数取代查询，我可以提纯程序的某些组成部分，使其更容易测试、更容易理解。</p><p>不过以参数取代查询并非只有好处。把查询变成参数以后，就迫使调用者必须弄清如何提供正确的参数值，这会增加函数调用者的复杂度，而我在设计接口时通常更愿意让接口的消费者更容易使用。归根到底，这是关于程序中责任分配的问题，而这方面的决策既不容易，也不会一劳永逸——这就是我需要非常熟悉本重构（及其反向重构）的原因。</p><h3 id="做法-11"><a href="#做法-11" class="headerlink" title="做法"></a>做法</h3><p>对执行查询操作的代码使用提炼变量（119），将其从函数体中分离出来。</p><p>现在函数体代码已经不再执行查询操作（而是使用前一步提炼出的变量），对这部分代码使用提炼函数（106）。</p><p>给提炼出的新函数起一个容易搜索的名字，以便稍后改名。</p><p>使用内联变量（123），消除刚才提炼出来的变量。</p><p>对原来的函数使用内联函数（115）。</p><p>对新函数改名，改回原来函数的名字。</p><h3 id="范例-11"><a href="#范例-11" class="headerlink" title="范例"></a>范例</h3><p>我们想象一个简单却又烦人的温度控制系统。用户可以从一个温控终端（thermostat）指定温度，但指定的目标温度必须在温度控制计划（heating plan）允许的范围内。</p><p><strong>class HeatingPlan…</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">get</span> targetTemperature() &#123;<br>  <span class="hljs-keyword">if</span> (thermostat.selectedTemperature &gt; <span class="hljs-keyword">this</span>._max) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._max;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (thermostat.selectedTemperature &lt; <span class="hljs-keyword">this</span>._min) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._min;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> thermostat.selectedTemperature;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>调用方…</strong></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">if (thePlan.targetTemperature &gt; thermostat.currentTemperature) <span class="hljs-built_in">setToHeat</span>();<br>else if (thePlan.targetTemperature&lt;thermostat.currentTemperature)<span class="hljs-built_in">setToCool</span>();<br>else <span class="hljs-built_in">setOff</span>();<br></code></pre></td></tr></table></figure><p>系统的温控计划规则抑制了我的要求，作为这样一个系统的用户，我可能会感到很烦恼。不过作为程序员，我更担心的是 targetTemperature 函数依赖于全局的 thermostat 对象。我可以把需要这个对象提供的信息作为参数传入，从而打破对该对象的依赖。</p><p>首先，我要用提炼变量（119）把“希望作为参数传入的信息”提炼出来。</p><p><strong>class HeatingPlan…</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">get</span> targetTemperature() &#123;<br> <span class="hljs-keyword">const</span> selectedTemperature = thermostat.selectedTemperature;<br> <span class="hljs-keyword">if</span>      (selectedTemperature &gt; <span class="hljs-keyword">this</span>._max) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._max;<br> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (selectedTemperature &lt; <span class="hljs-keyword">this</span>._min) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._min;<br> <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> selectedTemperature;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样可以比较容易地用提炼函数（106）把整个函数体提炼出来，只剩“计算参数值”的逻辑还在原地。</p><p><strong>class HeatingPlan…</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">get</span> targetTemperature() &#123;<br> <span class="hljs-keyword">const</span> selectedTemperature = thermostat.selectedTemperature;<br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.xxNEWtargetTemperature(selectedTemperature);<br>&#125;<br><br>xxNEWtargetTemperature(selectedTemperature) &#123;<br> <span class="hljs-keyword">if</span>      (selectedTemperature &gt; <span class="hljs-keyword">this</span>._max) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._max;<br> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (selectedTemperature &lt; <span class="hljs-keyword">this</span>._min) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._min;<br> <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> selectedTemperature;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后把刚才提炼出来的变量内联回去，于是旧函数就只剩一个简单的调用。</p><p><strong>class HeatingPlan…</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">get</span> <span class="hljs-title">targetTemperature</span>()</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.xxNEWtargetTemperature(thermostat.selectedTemperature);<br>&#125;<br></code></pre></td></tr></table></figure><p>现在可以对其使用内联函数（115）。</p><p><strong>调用方…</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">if</span> (thePlan.xx<span class="hljs-constructor">NEWtargetTemperature(<span class="hljs-params">thermostat</span>.<span class="hljs-params">selectedTemperature</span>)</span> &gt;<br>   thermostat.currentTemperature)<br> set<span class="hljs-constructor">ToHeat()</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (thePlan.xx<span class="hljs-constructor">NEWtargetTemperature(<span class="hljs-params">thermostat</span>.<span class="hljs-params">selectedTemperature</span>)</span> &lt;<br>     thermostat.currentTemperature)<br> set<span class="hljs-constructor">ToCool()</span>;<br><span class="hljs-keyword">else</span><br> set<span class="hljs-constructor">Off()</span>;<br></code></pre></td></tr></table></figure><p>再把新函数改名，用回旧函数的名字。得益于之前给它起了一个容易搜索的名字，现在只要把前缀去掉就行。</p><p><strong>调用方…</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">if</span> (thePlan.target<span class="hljs-constructor">Temperature(<span class="hljs-params">thermostat</span>.<span class="hljs-params">selectedTemperature</span>)</span> &gt;<br>   thermostat.currentTemperature)<br> set<span class="hljs-constructor">ToHeat()</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (thePlan.target<span class="hljs-constructor">Temperature(<span class="hljs-params">thermostat</span>.<span class="hljs-params">selectedTemperature</span>)</span> &lt;<br>     thermostat.currentTemperature)<br> set<span class="hljs-constructor">ToCool()</span>;<br><span class="hljs-keyword">else</span><br> set<span class="hljs-constructor">Off()</span>;<br></code></pre></td></tr></table></figure><p><strong>class HeatingPlan…</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">targetTemperature(selectedTemperature) &#123;<br> <span class="hljs-keyword">if</span> (selectedTemperature &gt; <span class="hljs-keyword">this</span>._max) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._max;<br> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (selectedTemperature &lt; <span class="hljs-keyword">this</span>._min) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._min;<br> <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> selectedTemperature;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用方的代码看起来比重构之前更笨重了，这是使用本重构手法的常见情况。将一个依赖关系从一个模块中移出，就意味着将处理这个依赖关系的责任推回给调用者。这是为了降低耦合度而付出的代价。</p><p>但是，去除对 thermostat 对象的耦合，并不是本重构带来的唯一收益。HeatingPlan 类本身是不可变的——字段的值都在构造函数中设置，任何函数都不会修改它们。（不用费心去查看整个类的代码，相信我就好。）在不可变的 HeatingPlan 基础上，把对 thermostat 的依赖移出函数体之后，我又使 targetTemperature 函数具备了引用透明性。从此以后，只要在同一个 HeatingPlan 对象上用同样的参数调用 targetTemperature 函数，我会始终得到同样的结果。如果 HeatingPlan 的所有函数都具有引用透明性，这个类会更容易测试，其行为也更容易理解。</p><p>JavaScript 的类模型有一个问题：无法强制要求类的不可变性——始终有办法修改对象的内部数据。尽管如此，在编写一个类的时候明确说明并鼓励不可变性，通常也就足够了。尽量让类保持不可变通常是一个好的策略，以参数取代查询则是达成这一策略的利器。</p><h2 id="11-7-移除设值函数（Remove-Setting-Method）"><a href="#11-7-移除设值函数（Remove-Setting-Method）" class="headerlink" title="11.7 移除设值函数（Remove Setting Method）"></a>11.7 移除设值函数（Remove Setting Method）</h2><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nim">class <span class="hljs-type">Person</span> &#123;<br>get name() <span class="hljs-meta">&#123;...&#125;</span><br><span class="hljs-type">set</span> name(aString) <span class="hljs-meta">&#123;...&#125;</span><br><br><br>class <span class="hljs-type">Person</span> &#123;<br>get name() <span class="hljs-meta">&#123;...&#125;</span><br></code></pre></td></tr></table></figure><h3 id="动机-12"><a href="#动机-12" class="headerlink" title="动机"></a>动机</h3><p>如果为某个字段提供了设值函数，这就暗示这个字段可以被改变。如果不希望在对象创建之后此字段还有机会被改变，那就不要为它提供设值函数（同时将该字段声明为不可变）。这样一来，该字段就只能在构造函数中赋值，我“不想让它被修改”的意图会更加清晰，并且可以排除其值被修改的可能性——这种可能性往往是非常大的。</p><p>有两种常见的情况需要讨论。一种情况是，有些人喜欢始终通过访问函数来读写字段值，包括在构造函数内也是如此。这会导致构造函数成为设值函数的唯一使用者。若果真如此，我更愿意去除设值函数，清晰地表达“构造之后不应该再更新字段值”的意图。</p><p>另一种情况是，对象是由客户端通过创建脚本构造出来，而不是只有一次简单的构造函数调用。所谓“创建脚本”，首先是调用构造函数，然后就是一系列设值函数的调用，共同完成新对象的构造。创建脚本执行完以后，这个新生对象的部分（乃至全部）字段就不应该再被修改。设值函数只应该在起初的对象创建过程中调用。对于这种情况，我也会想办法去除设值函数，更清晰地表达我的意图。</p><h3 id="做法-12"><a href="#做法-12" class="headerlink" title="做法"></a>做法</h3><p>如果构造函数尚无法得到想要设入字段的值，就使用改变函数声明（124）将这个值以参数的形式传入构造函数。在构造函数中调用设值函数，对字段设值。</p><p>如果想移除多个设值函数，可以一次性把它们的值都传入构造函数，这能简化后续步骤。</p><p>移除所有在构造函数之外对设值函数的调用，改为使用新的构造函数。每次修改之后都要测试。</p><p>如果不能把“调用设值函数”替换为“创建一个新对象”（例如你需要更新一个多处共享引用的对象），请放弃本重构。</p><p>使用内联函数（115）消去设值函数。如果可能的话，把字段声明为不可变。</p><p>测试。</p><h3 id="范例-12"><a href="#范例-12" class="headerlink" title="范例"></a>范例</h3><p>我有一个很简单的 Person 类。</p><p><strong>class Person…</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">get</span> <span class="hljs-title">name</span>()</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._name;&#125;<br><span class="hljs-function"><span class="hljs-keyword">set</span> <span class="hljs-title">name</span>(<span class="hljs-params">arg</span>)</span> &#123;<span class="hljs-keyword">this</span>._name = arg;&#125;<br><span class="hljs-function"><span class="hljs-keyword">get</span> <span class="hljs-title">id</span>()</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._id;&#125;<br><span class="hljs-function"><span class="hljs-keyword">set</span> <span class="hljs-title">id</span>(<span class="hljs-params">arg</span>)</span> &#123;<span class="hljs-keyword">this</span>._id = arg;&#125;<br></code></pre></td></tr></table></figure><p>目前我会这样创建新对象：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">const martin <span class="hljs-operator">=</span> new Person()<span class="hljs-comment">;</span><br>martin.name <span class="hljs-operator">=</span> <span class="hljs-string">&quot;martin&quot;</span><span class="hljs-comment">;</span><br>martin.id <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1234&quot;</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>对象创建之后，name 字段可能会改变，但 id 字段不会。为了更清晰地表达这个设计意图，我希望移除对应 id 字段的设值函数。</p><p>但 id 字段还得设置初始值，所以我首先用改变函数声明（124）在构造函数中添加对应的参数。</p><p><strong>class Person…</strong></p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-function"><span class="hljs-keyword">constructor</span><span class="hljs-params">(id)</span> <span class="hljs-comment">&#123;</span></span><br><span class="hljs-comment"><span class="hljs-function">  this.id = id;</span></span><br><span class="hljs-comment"><span class="hljs-function">&#125;</span></span><br></code></pre></td></tr></table></figure><p>然后调整创建脚本，改为从构造函数设值 id 字段值。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">const martin <span class="hljs-operator">=</span> new Person(<span class="hljs-string">&quot;1234&quot;</span>)<span class="hljs-comment">;</span><br>martin.name <span class="hljs-operator">=</span> <span class="hljs-string">&quot;martin&quot;</span><span class="hljs-comment">;</span><br>martin.id <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1234&quot;</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>所有创建 Person 对象的地方都要如此修改，每次修改之后要执行测试。</p><p>全部修改完成后，就可以用内联函数（115）消去设值函数。</p><p><strong>class Person…</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">constructor</span>(id) &#123;<br>  <span class="hljs-keyword">this</span>._id = id;<br>&#125;<br><span class="hljs-keyword">get</span> name() &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._name;&#125;<br><span class="hljs-keyword">set</span> name(arg) &#123;<span class="hljs-keyword">this</span>._name = arg;&#125;<br><span class="hljs-keyword">get</span> id() &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._id;&#125;<br><span class="hljs-keyword">set</span> id(arg) &#123;<span class="hljs-keyword">this</span>._id = arg;&#125;<br></code></pre></td></tr></table></figure><h2 id="11-8-以工厂函数取代构造函数（Replace-Constructor-with-Factory-Function）"><a href="#11-8-以工厂函数取代构造函数（Replace-Constructor-with-Factory-Function）" class="headerlink" title="11.8 以工厂函数取代构造函数（Replace Constructor with Factory Function）"></a>11.8 以工厂函数取代构造函数（Replace Constructor with Factory Function）</h2><p>曾用名：以工厂函数取代构造函数（Replace Constructor with Factory Method）</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">leadEngineer = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Employee(<span class="hljs-params">document</span>.<span class="hljs-params">leadEngineer</span>, <span class="hljs-string">&quot;E&quot;</span>)</span>;<br><br>leadEngineer = create<span class="hljs-constructor">Engineer(<span class="hljs-params">document</span>.<span class="hljs-params">leadEngineer</span>)</span>;<br></code></pre></td></tr></table></figure><h3 id="动机-13"><a href="#动机-13" class="headerlink" title="动机"></a>动机</h3><p>很多面向对象语言都有特别的构造函数，专门用于对象的初始化。需要新建一个对象时，客户端通常会调用构造函数。但与一般的函数相比，构造函数又常有一些丑陋的局限性。例如，Java 的构造函数只能返回当前所调用类的实例，也就是说，我无法根据环境或参数信息返回子类实例或代理对象；构造函数的名字是固定的，因此无法使用比默认名字更清晰的函数名；构造函数需要通过特殊的操作符来调用（在很多语言中是 new 关键字），所以在要求普通函数的场合就难以使用。</p><p>工厂函数就不受这些限制。工厂函数的实现内部可以调用构造函数，但也可以换成别的方式实现。</p><h3 id="做法-13"><a href="#做法-13" class="headerlink" title="做法"></a>做法</h3><p>新建一个工厂函数，让它调用现有的构造函数。</p><p>将调用构造函数的代码改为调用工厂函数。</p><p>每修改一处，就执行测试。</p><p>尽量缩小构造函数的可见范围。</p><h3 id="范例-13"><a href="#范例-13" class="headerlink" title="范例"></a>范例</h3><p>又是那个单调乏味的例子：员工薪资系统。我还是以 Employee 类表示“员工”。</p><p><strong>class Employee…</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">constructor</span> (name, typeCode) &#123;<br>  <span class="hljs-keyword">this</span>._name = name;<br>  <span class="hljs-keyword">this</span>._typeCode = typeCode;<br>&#125;<br><span class="hljs-keyword">get</span> name() &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._name;&#125;<br><span class="hljs-keyword">get</span> type() &#123;<br>  <span class="hljs-keyword">return</span> Employee.legalTypeCodes[<span class="hljs-keyword">this</span>._typeCode];<br>&#125;<br>static <span class="hljs-keyword">get</span> legalTypeCodes() &#123;<br>  <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;E&quot;</span>: <span class="hljs-string">&quot;Engineer&quot;</span>, <span class="hljs-string">&quot;M&quot;</span>: <span class="hljs-string">&quot;Manager&quot;</span>, <span class="hljs-string">&quot;S&quot;</span>: <span class="hljs-string">&quot;Salesman&quot;</span>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用它的代码有这样的：</p><p><strong>调用方…</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">candidate = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Employee(<span class="hljs-params">document</span>.<span class="hljs-params">name</span>, <span class="hljs-params">document</span>.<span class="hljs-params">empType</span>)</span>;<br></code></pre></td></tr></table></figure><p>也有这样的：</p><p><strong>调用方…</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">const leadEngineer = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Employee(<span class="hljs-params">document</span>.<span class="hljs-params">leadEngineer</span>, <span class="hljs-string">&quot;E&quot;</span>)</span>;<br></code></pre></td></tr></table></figure><p>重构的第一步是创建工厂函数，其中把对象创建的责任直接委派给构造函数。</p><p><strong>顶层作用域…</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> create<span class="hljs-constructor">Employee(<span class="hljs-params">name</span>, <span class="hljs-params">typeCode</span>)</span> &#123;<br>  return <span class="hljs-keyword">new</span> <span class="hljs-constructor">Employee(<span class="hljs-params">name</span>, <span class="hljs-params">typeCode</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后找到构造函数的调用者，并逐一修改它们，令其使用工厂函数。</p><p>第一处的修改很简单。</p><p><strong>调用方…</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">candidate = create<span class="hljs-constructor">Employee(<span class="hljs-params">document</span>.<span class="hljs-params">name</span>, <span class="hljs-params">document</span>.<span class="hljs-params">empType</span>)</span>;<br></code></pre></td></tr></table></figure><p>第二处则可以这样使用工厂函数。</p><p><strong>调用方…</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">const leadEngineer = create<span class="hljs-constructor">Employee(<span class="hljs-params">document</span>.<span class="hljs-params">leadEngineer</span>, <span class="hljs-string">&quot;E&quot;</span>)</span>;<br></code></pre></td></tr></table></figure><p>但我不喜欢这里的类型码——以字符串字面量的形式传入类型码，一般来说都是坏味道。所以我更愿意再新建一个工厂函数，把“员工类别”的信息嵌在函数名里体现。</p><p><strong>调用方…</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">const leadEngineer = create<span class="hljs-constructor">Engineer(<span class="hljs-params">document</span>.<span class="hljs-params">leadEngineer</span>)</span>;<br></code></pre></td></tr></table></figure><p><strong>顶层作用域…</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> create<span class="hljs-constructor">Engineer(<span class="hljs-params">name</span>)</span> &#123;<br>  return <span class="hljs-keyword">new</span> <span class="hljs-constructor">Employee(<span class="hljs-params">name</span>, <span class="hljs-string">&quot;E&quot;</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="11-9-以命令取代函数（Replace-Function-with-Command）"><a href="#11-9-以命令取代函数（Replace-Function-with-Command）" class="headerlink" title="11.9 以命令取代函数（Replace Function with Command）"></a>11.9 以命令取代函数（Replace Function with Command）</h2><p>曾用名：以函数对象取代函数（Replace Method with Method Object）</p><p>反向重构：以函数取代命令（344）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">score</span>(<span class="hljs-params">candidate, medicalExam, scoringGuide</span>) &#123;<br>  <span class="hljs-keyword">let</span> result = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> healthLevel = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// long body code</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Scorer</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">candidate, medicalExam, scoringGuide</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_candidate</span> = candidate;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_medicalExam</span> = medicalExam;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_scoringGuide</span> = scoringGuide;<br>  &#125;<br><br>  <span class="hljs-title function_">execute</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_result</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_healthLevel</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// long body code</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="动机-14"><a href="#动机-14" class="headerlink" title="动机"></a>动机</h3><p>函数，不管是独立函数，还是以方法（method）形式附着在对象上的函数，是程序设计的基本构造块。不过，将函数封装成自己的对象，有时也是一种有用的办法。这样的对象我称之为“命令对象”（command object），或者简称“命令”（command）。这种对象大多只服务于单一函数，获得对该函数的请求，执行该函数，就是这种对象存在的意义。</p><p>与普通的函数相比，命令对象提供了更大的控制灵活性和更强的表达能力。除了函数调用本身，命令对象还可以支持附加的操作，例如撤销操作。我可以通过命令对象提供的方法来设值命令的参数值，从而支持更丰富的生命周期管理能力。我可以借助继承和钩子对函数行为加以定制。如果我所使用的编程语言支持对象但不支持函数作为一等公民，通过命令对象就可以给函数提供大部分相当于一等公民的能力。同样，即便编程语言本身并不支持嵌套函数，我也可以借助命令对象的方法和字段把复杂的函数拆解开，而且在测试和调试过程中可以直接调用这些方法。</p><p>所有这些都是使用命令对象的好理由，所以我要做好准备，一旦有需要，就能把函数重构成命令。不过我们不能忘记，命令对象的灵活性也是以复杂性作为代价的。所以，如果要在作为一等公民的函数和命令对象之间做个选择，95%的时候我都会选函数。只有当我特别需要命令对象提供的某种能力而普通的函数无法提供这种能力时，我才会考虑使用命令对象。</p><p>跟软件开发中的很多词汇一样，“命令”这个词承载了太多含义。在这里，“命令”是指一个对象，其中封装了一个函数调用请求。这是遵循《设计模式》[gof]一书中的命令模式（command pattern）。在这个意义上，使用“命令”一词时，我会先用完整的“命令对象”一词设定上下文，然后视情况使用简略的“命令”一词。在命令与查询分离原则（command-query separation principle）中也用到了“命令”一词，此时“命令”是一个对象所拥有的函数，调用该函数可以改变对象可观察的状态。我尽量避免使用这个意义上的“命令”一词，而更愿意称其为“修改函数”（modifier）或者“改变函数”（mutator）。</p><h3 id="做法-14"><a href="#做法-14" class="headerlink" title="做法"></a>做法</h3><p>为想要包装的函数创建一个空的类，根据该函数的名字为其命名。</p><p>使用搬移函数（198）把函数移到空的类里。</p><p>保持原来的函数作为转发函数，至少保留到重构结束之前才删除。</p><p>遵循编程语言的命名规范来给命令对象起名。如果没有合适的命名规范，就给命令对象中负责实际执行命令的函数起一个通用的名字，例如“execute”或者“call”。</p><p>可以考虑给每个参数创建一个字段，并在构造函数中添加对应的参数。</p><h3 id="范例-14"><a href="#范例-14" class="headerlink" title="范例"></a>范例</h3><p>JavaScript 语言有很多缺点，但把函数作为一等公民对待，是它最正确的设计决策之一。在不具备这种能力的编程语言中，我经常要费力为很常见的任务创建命令对象，JavaScript 则省去了这些麻烦。不过，即便在 JavaScript 中，有时也需要用到命令对象。</p><p>一个典型的应用场景就是拆解复杂的函数，以便我理解和修改。要想真正展示这个重构手法的价值，我需要一个长而复杂的函数，但这写起来太费事，你读起来也麻烦。所以我在这里展示的函数其实很短，并不真的需要本重构手法，还望读者权且包涵。下面的函数用于给一份保险申请评分。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">score</span>(<span class="hljs-params">candidate, medicalExam, scoringGuide</span>) &#123;<br>  <span class="hljs-keyword">let</span> result = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> healthLevel = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> highMedicalRiskFlag = <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-keyword">if</span> (medicalExam.<span class="hljs-property">isSmoker</span>) &#123;<br>    healthLevel += <span class="hljs-number">10</span>;<br>    highMedicalRiskFlag = <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-keyword">let</span> certificationGrade = <span class="hljs-string">&quot;regular&quot;</span>;<br>  <span class="hljs-keyword">if</span> (scoringGuide.<span class="hljs-title function_">stateWithLowCertification</span>(candidate.<span class="hljs-property">originState</span>)) &#123;<br>    certificationGrade = <span class="hljs-string">&quot;low&quot;</span>;<br>    result -= <span class="hljs-number">5</span>;<br>  &#125; <span class="hljs-comment">// lots more code like this</span><br>  result -= <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(healthLevel - <span class="hljs-number">5</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>我首先创建一个空的类，用搬移函数（198）把上述函数搬到这个类里去。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">score</span>(<span class="hljs-params">candidate, medicalExam, scoringGuide</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scorer</span>().<span class="hljs-title function_">execute</span>(candidate, medicalExam, scoringGuide);<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Scorer</span> &#123;<br>  <span class="hljs-title function_">execute</span>(<span class="hljs-params">candidate, medicalExam, scoringGuide</span>) &#123;<br>    <span class="hljs-keyword">let</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> healthLevel = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> highMedicalRiskFlag = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">if</span> (medicalExam.<span class="hljs-property">isSmoker</span>) &#123;<br>      healthLevel += <span class="hljs-number">10</span>;<br>      highMedicalRiskFlag = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">let</span> certificationGrade = <span class="hljs-string">&quot;regular&quot;</span>;<br>    <span class="hljs-keyword">if</span> (scoringGuide.<span class="hljs-title function_">stateWithLowCertification</span>(candidate.<span class="hljs-property">originState</span>)) &#123;<br>      certificationGrade = <span class="hljs-string">&quot;low&quot;</span>;<br>      result -= <span class="hljs-number">5</span>;<br>    &#125; <span class="hljs-comment">// lots more code like this</span><br>    result -= <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(healthLevel - <span class="hljs-number">5</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>大多数时候，我更愿意在命令对象的构造函数中传入参数，而不让 execute 函数接收参数。在这样一个简单的拆解场景中，这一点带来的影响不大；但如果我要处理的命令需要更复杂的参数设置周期或者大量定制，上述做法就会带来很多便利：多个命令类可以分别从各自的构造函数中获得各自不同的参数，然后又可以排成队列挨个执行，因为它们的 execute 函数签名都一样。</p><p>我可以每次搬移一个参数到构造函数。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">score</span>(candidate, medicalExam, scoringGuide) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">new</span> Scorer(candidate).execute(candidate, medicalExam, scoringGuide);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>class Scorer…</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">constructor</span>(<span class="hljs-params">candidate</span>)&#123;<br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_candidate</span> = candidate;<br>&#125;<br><br>execute (candidate, medicalExam, scoringGuide) &#123;<br> <span class="hljs-keyword">let</span> result = <span class="hljs-number">0</span>;<br> <span class="hljs-keyword">let</span> healthLevel = <span class="hljs-number">0</span>;<br> <span class="hljs-keyword">let</span> highMedicalRiskFlag = <span class="hljs-literal">false</span>;<br><br> <span class="hljs-keyword">if</span> (medicalExam.<span class="hljs-property">isSmoker</span>) &#123;<br>  healthLevel += <span class="hljs-number">10</span>;<br>  highMedicalRiskFlag = <span class="hljs-literal">true</span>;<br> &#125;<br> <span class="hljs-keyword">let</span> certificationGrade = <span class="hljs-string">&quot;regular&quot;</span>;<br> <span class="hljs-keyword">if</span> (scoringGuide.<span class="hljs-title function_">stateWithLowCertification</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">_candidate</span>.<span class="hljs-property">originState</span>)) &#123;<br>  certificationGrade = <span class="hljs-string">&quot;low&quot;</span>;<br>  result -= <span class="hljs-number">5</span>;<br> &#125;<br> <span class="hljs-comment">// lots more code like this</span><br> result -= <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(healthLevel - <span class="hljs-number">5</span>, <span class="hljs-number">0</span>);<br> <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>继续处理其他参数：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> score(candidate, medicalExam, scoringGuide) &#123;<br>  return <span class="hljs-keyword">new</span> <span class="hljs-constructor">Scorer(<span class="hljs-params">candidate</span>, <span class="hljs-params">medicalExam</span>, <span class="hljs-params">scoringGuide</span>)</span>.execute<span class="hljs-literal">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>class Scorer…</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">constructor</span>(candidate, medicalExam, scoringGuide)&#123;<br> <span class="hljs-keyword">this</span>._candidate = candidate;<br> <span class="hljs-keyword">this</span>._medicalExam = medicalExam;<br> <span class="hljs-keyword">this</span>._scoringGuide = scoringGuide;<br>&#125;<br>execute () &#123;<br> let result = <span class="hljs-number">0</span>;<br> let healthLevel = <span class="hljs-number">0</span>;<br> let highMedicalRiskFlag = <span class="hljs-literal">false</span>;<br><br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._medicalExam.isSmoker) &#123;<br>  healthLevel += <span class="hljs-number">10</span>;<br>  highMedicalRiskFlag = <span class="hljs-literal">true</span>;<br> &#125;<br> let certificationGrade = <span class="hljs-string">&quot;regular&quot;</span>;<br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._scoringGuide.stateWithLowCertification(<span class="hljs-keyword">this</span>._candidate.originState)) &#123;<br>  certificationGrade = <span class="hljs-string">&quot;low&quot;</span>;<br>  result -= <span class="hljs-number">5</span>;<br> &#125;<br> <span class="hljs-comment">// lots more code like this</span><br> result -= Math.max(healthLevel - <span class="hljs-number">5</span>, <span class="hljs-number">0</span>);<br> <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>以命令取代函数的重构到此就结束了，不过之所以要做这个重构，是为了拆解复杂的函数，所以我还是大致展示一下如何拆解。下一步是把所有局部变量都变成字段，我还是每次修改一处。</p><p><strong>class Scorer…</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">constructor</span>(candidate, medicalExam, scoringGuide)&#123;<br> <span class="hljs-keyword">this</span>._candidate = candidate;<br> <span class="hljs-keyword">this</span>._medicalExam = medicalExam;<br> <span class="hljs-keyword">this</span>._scoringGuide = scoringGuide;<br>&#125;<br><br>execute () &#123;<br> <span class="hljs-keyword">this</span>._result = <span class="hljs-number">0</span>;<br> let healthLevel = <span class="hljs-number">0</span>;<br> let highMedicalRiskFlag = <span class="hljs-literal">false</span>;<br><br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._medicalExam.isSmoker) &#123;<br>  healthLevel += <span class="hljs-number">10</span>;<br>  highMedicalRiskFlag = <span class="hljs-literal">true</span>;<br> &#125;<br> let certificationGrade = <span class="hljs-string">&quot;regular&quot;</span>;<br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._scoringGuide.stateWithLowCertification(<span class="hljs-keyword">this</span>._candidate.originState)) &#123;<br>  certificationGrade = <span class="hljs-string">&quot;low&quot;</span>;<br>  <span class="hljs-keyword">this</span>._result -= <span class="hljs-number">5</span>;<br> &#125;<br> <span class="hljs-comment">// lots more code like this</span><br> <span class="hljs-keyword">this</span>._result -= Math.max(healthLevel - <span class="hljs-number">5</span>, <span class="hljs-number">0</span>);<br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._result;<br>&#125;<br></code></pre></td></tr></table></figure><p>重复上述过程，直到所有局部变量都变成字段。（“把局部变量变成字段”这个重构手法是如此简单，以至于我都没有在重构名录中给它一席之地。对此我略感愧疚。）</p><p><strong>class Scorer…</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">constructor</span>(candidate, medicalExam, scoringGuide)&#123;<br> <span class="hljs-keyword">this</span>._candidate = candidate;<br> <span class="hljs-keyword">this</span>._medicalExam = medicalExam;<br> <span class="hljs-keyword">this</span>._scoringGuide = scoringGuide;<br>&#125;<br><br>execute () &#123;<br> <span class="hljs-keyword">this</span>._result = <span class="hljs-number">0</span>;<br> <span class="hljs-keyword">this</span>._healthLevel = <span class="hljs-number">0</span>;<br> <span class="hljs-keyword">this</span>._highMedicalRiskFlag = <span class="hljs-literal">false</span>;<br><br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._medicalExam.isSmoker) &#123;<br>  <span class="hljs-keyword">this</span>._healthLevel += <span class="hljs-number">10</span>;<br>  <span class="hljs-keyword">this</span>._highMedicalRiskFlag = <span class="hljs-literal">true</span>;<br> &#125;<br> <span class="hljs-keyword">this</span>._certificationGrade = <span class="hljs-string">&quot;regular&quot;</span>;<br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._scoringGuide.stateWithLowCertification(<span class="hljs-keyword">this</span>._candidate.originState)) &#123;<br>  <span class="hljs-keyword">this</span>._certificationGrade = <span class="hljs-string">&quot;low&quot;</span>;<br>  <span class="hljs-keyword">this</span>._result -= <span class="hljs-number">5</span>;<br> &#125;<br> <span class="hljs-comment">// lots more code like this</span><br> <span class="hljs-keyword">this</span>._result -= Math.max(<span class="hljs-keyword">this</span>._healthLevel - <span class="hljs-number">5</span>, <span class="hljs-number">0</span>);<br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._result;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在函数的所有状态都已经移到了命令对象中，我可以放心使用提炼函数（106）等重构手法，而不用纠结于局部变量的作用域之类问题。</p><p><strong>class Scorer…</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">execute () &#123;<br> <span class="hljs-keyword">this</span>._result = <span class="hljs-number">0</span>;<br> <span class="hljs-keyword">this</span>._healthLevel = <span class="hljs-number">0</span>;<br> <span class="hljs-keyword">this</span>._highMedicalRiskFlag = <span class="hljs-literal">false</span>;<br><br> <span class="hljs-keyword">this</span>.scoreSmoking();<br> <span class="hljs-keyword">this</span>._certificationGrade = <span class="hljs-string">&quot;regular&quot;</span>;<br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._scoringGuide.stateWithLowCertification(<span class="hljs-keyword">this</span>._candidate.originState)) &#123;<br>  <span class="hljs-keyword">this</span>._certificationGrade = <span class="hljs-string">&quot;low&quot;</span>;<br>  <span class="hljs-keyword">this</span>._result -= <span class="hljs-number">5</span>;<br> &#125;<br> <span class="hljs-comment">// lots more code like this</span><br> <span class="hljs-keyword">this</span>._result -= Math.max(<span class="hljs-keyword">this</span>._healthLevel - <span class="hljs-number">5</span>, <span class="hljs-number">0</span>);<br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._result;<br> &#125;<br>scoreSmoking() &#123;<br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._medicalExam.isSmoker) &#123;<br>  <span class="hljs-keyword">this</span>._healthLevel += <span class="hljs-number">10</span>;<br>  <span class="hljs-keyword">this</span>._highMedicalRiskFlag = <span class="hljs-literal">true</span>;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样我就可以像处理嵌套函数一样处理命令对象。实际上，在 JavaScript 中运用此重构手法时，的确可以考虑用嵌套函数来代替命令对象。不过我还是会使用命令对象，不仅因为我对命令对象更熟悉，而且还因为我可以针对命令对象中任何一个函数进行测试和调试。</p><h2 id="11-10-以函数取代命令（Replace-Command-with-Function）"><a href="#11-10-以函数取代命令（Replace-Command-with-Function）" class="headerlink" title="11.10 以函数取代命令（Replace Command with Function）"></a>11.10 以函数取代命令（Replace Command with Function）</h2><p>反向重构：以命令取代函数（337）</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ChargeCalculator</span> &#123;<br>  <span class="hljs-keyword">constructor</span>(customer, usage) &#123;<br>    <span class="hljs-keyword">this</span>._customer = customer;<br>    <span class="hljs-keyword">this</span>._usage = usage;<br>  &#125;<br>  execute() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._customer.rate * <span class="hljs-keyword">this</span>._usage;<br>  &#125;<br>&#125;<br><br>function charge(customer, usage) &#123;<br>  <span class="hljs-keyword">return</span> customer.rate * usage;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="动机-15"><a href="#动机-15" class="headerlink" title="动机"></a>动机</h3><p>命令对象为处理复杂计算提供了强大的机制。借助命令对象，可以轻松地将原本复杂的函数拆解为多个方法，彼此之间通过字段共享状态；拆解后的方法可以分别调用；开始调用之前的数据状态也可以逐步构建。但这种强大是有代价的。大多数时候，我只是想调用一个函数，让它完成自己的工作就好。如果这个函数不是太复杂，那么命令对象可能显得费而不惠，我就应该考虑将其变回普通的函数。</p><h3 id="做法-15"><a href="#做法-15" class="headerlink" title="做法"></a>做法</h3><p>运用提炼函数（106），把“创建并执行命令对象”的代码单独提炼到一个函数中。</p><p>这一步会新建一个函数，最终这个函数会取代现在的命令对象。</p><p>对命令对象在执行阶段用到的函数，逐一使用内联函数（115）。</p><p>如果被调用的函数有返回值，请先对调用处使用提炼变量（119），然后再使用内联函数（115）。</p><p>使用改变函数声明（124），把构造函数的参数转移到执行函数。</p><p>对于所有的字段，在执行函数中找到引用它们的地方，并改为使用参数。每次修改后都要测试。</p><p>把“调用构造函数”和“调用执行函数”两步都内联到调用方（也就是最终要替换命令对象的那个函数）。</p><p>测试。</p><p>用移除死代码（237）把命令类消去。</p><h3 id="范例-15"><a href="#范例-15" class="headerlink" title="范例"></a>范例</h3><p>假设我有一个很小的命令对象。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ChargeCalculator</span> &#123;<br>  <span class="hljs-keyword">constructor</span>(customer, usage, provider) &#123;<br>    <span class="hljs-keyword">this</span>._customer = customer;<br>    <span class="hljs-keyword">this</span>._usage = usage;<br>    <span class="hljs-keyword">this</span>._provider = provider;<br>  &#125;<br>  <span class="hljs-keyword">get</span> baseCharge() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._customer.baseRate * <span class="hljs-keyword">this</span>._usage;<br>  &#125;<br>  <span class="hljs-keyword">get</span> charge() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.baseCharge + <span class="hljs-keyword">this</span>._provider.connectionCharge;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用方的代码如下。</p><p><strong>调用方…</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">monthCharge = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ChargeCalculator(<span class="hljs-params">customer</span>, <span class="hljs-params">usage</span>, <span class="hljs-params">provider</span>)</span>.charge;<br></code></pre></td></tr></table></figure><p>命令类足够小、足够简单，变成函数更合适。</p><p>首先，我用提炼函数（106）把命令对象的创建与调用过程包装到一个函数中。</p><p><strong>调用方…</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">monthCharge</span> = charge(customer, usage, provider)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><strong>顶层作用域…</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> charge(customer, usage, provider) &#123;<br>  return <span class="hljs-keyword">new</span> <span class="hljs-constructor">ChargeCalculator(<span class="hljs-params">customer</span>, <span class="hljs-params">usage</span>, <span class="hljs-params">provider</span>)</span>.charge;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来要考虑如何处理支持函数（也就是这里的 baseCharge 函数）。对于有返回值的函数，我一般会先用提炼变量（119）把返回值提炼出来。</p><p><strong>class ChargeCalculator…</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">get</span> baseCharge() &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._customer.baseRate * <span class="hljs-keyword">this</span>._usage;<br>&#125;<br><span class="hljs-keyword">get</span> charge() &#123;<br>  <span class="hljs-keyword">const</span> baseCharge = <span class="hljs-keyword">this</span>.baseCharge;<br>  <span class="hljs-keyword">return</span> baseCharge + <span class="hljs-keyword">this</span>._provider.connectionCharge;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后对支持函数使用内联函数（115）。</p><p><strong>class ChargeCalculator…</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">get</span> charge() &#123;<br>  <span class="hljs-keyword">const</span> baseCharge = <span class="hljs-keyword">this</span>._customer.baseRate * <span class="hljs-keyword">this</span>._usage;<br>  <span class="hljs-keyword">return</span> baseCharge + <span class="hljs-keyword">this</span>._provider.connectionCharge;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在所有逻辑处理都集中到一个函数了，下一步是把构造函数传入的数据移到主函数。首先用改变函数声明（124）把构造函数的参数逐一添加到 charge 函数上。</p><p><strong>class ChargeCalculator…</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">constructor</span> (customer, usage, provider)&#123;<br> <span class="hljs-keyword">this</span>._customer = customer;<br> <span class="hljs-keyword">this</span>._usage = usage;<br> <span class="hljs-keyword">this</span>._provider = provider;<br>&#125;<br><br>charge(customer, usage, provider) &#123;<br> <span class="hljs-keyword">const</span> baseCharge = <span class="hljs-keyword">this</span>._customer.baseRate * <span class="hljs-keyword">this</span>._usage;<br> <span class="hljs-keyword">return</span> baseCharge + <span class="hljs-keyword">this</span>._provider.connectionCharge;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>顶层作用域…</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> charge(customer, <span class="hljs-keyword">usage</span>, provider) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span> ChargeCalculator(customer, <span class="hljs-keyword">usage</span>, provider).charge(<br>    customer,<br>    <span class="hljs-keyword">usage</span>,<br>    provider<br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>然后修改 charge 函数的实现，改为使用传入的参数。这个修改可以小步进行，每次使用一个参数。</p><p><strong>class ChargeCalculator…</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">constructor</span> (customer, usage, provider)&#123;<br> <span class="hljs-keyword">this</span>._customer = customer;<br> <span class="hljs-keyword">this</span>._usage = usage;<br> <span class="hljs-keyword">this</span>._provider = provider;<br>&#125;<br><br>charge(customer, usage, provider) &#123;<br> <span class="hljs-keyword">const</span> baseCharge = customer.baseRate * <span class="hljs-keyword">this</span>._usage;<br> <span class="hljs-keyword">return</span> baseCharge + <span class="hljs-keyword">this</span>._provider.connectionCharge;<br>&#125;<br></code></pre></td></tr></table></figure><p>构造函数中对 <code>this._customer</code> 字段的赋值不删除也没关系，因为反正没人使用这个字段。但我更愿意去掉这条赋值语句，因为去掉它以后，如果在函数实现中漏掉了一处对字段的使用没有修改，测试就会失败。（如果我真的犯了这个错误而测试没有失败，我就应该考虑增加测试了。）</p><p>其他参数也如法炮制，直到 charge 函数不再使用任何字段：</p><p><strong>class ChargeCalculator…</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">charge</span>(<span class="hljs-params">customer, usage, provider</span>) &#123;<br>  <span class="hljs-keyword">const</span> baseCharge = customer.<span class="hljs-property">baseRate</span> * usage;<br>  <span class="hljs-keyword">return</span> baseCharge + provider.<span class="hljs-property">connectionCharge</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我就可以把所有逻辑都内联到顶层的 charge 函数中。这是内联函数（115）的一种特殊情况，我需要把构造函数和执行函数一并内联。</p><p><strong>顶层作用域…</strong></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">charge</span>(customer, usage, provider) &#123;<br>  const baseCharge = customer.baseRate * usage;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">baseCharge</span> + provider.connectionCharge;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在命令类已经是死代码了，可以用移除死代码（237）给它一个体面的葬礼。</p>]]></content>
    
    
    <categories>
      
      <category>重构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>重构</tag>
      
      <tag>架构</tag>
      
      <tag>设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重构法则节选(上)</title>
    <link href="/posts/8847ed34/"/>
    <url>/posts/8847ed34/</url>
    
    <content type="html"><![CDATA[<blockquote><p>重构，并不是额外动作，理应伴随开发流程。并不是无意义，如果只是堆积垃圾代码，迭代多次之后，可能原开发人员也会失去本来的方向。作为开发人员理应重视这样的份内之事。最近重读《重构-改善既有代码的设计》。还是觉得需要落到笔端，吃书也是一种学习方式吧，这里节选认为必要的内容，还是需要反复阅读才能理解其真意。学习重构，是为了减少重构。</p></blockquote><hr><h1 id="2-重构的原则"><a href="#2-重构的原则" class="headerlink" title="2.重构的原则"></a>2.重构的原则</h1><p>前一章所举的例子应该已经让你对重构有了一个良好的感觉。现在，我们应该回头看看重构的一些大原则。</p><h2 id="2-1-何谓重构"><a href="#2-1-何谓重构" class="headerlink" title="2.1 何谓重构"></a>2.1 何谓重构</h2><p>一线的实践者们经常很随意地使用“重构”这个词——软件开发领域的很多词汇都有此待遇。我使用这个词的方式比较严谨，并且我发现这种严谨的方式很有好处。（下列定义与本书第 1 版中给出的定义一样。）“重构”这个词既可以用作名词也可以用作动词。名词形式的定义是：</p><p>重构（名词）：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。</p><p>这个定义适用于我在前面的例子中提到的那些有名字的重构，例如提炼函数（106）和以多态取代条件表达式（272）。</p><p>动词形式的定义是：</p><p>重构（动词）：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。</p><p>所以，我可能会花一两个小时进行重构（动词），其间我会使用几十个不同的重构（名词）。</p><p>过去十几年，这个行业里的很多人用“重构”这个词来指代任何形式的代码清理，但上面的定义所指的是一种特定的清理代码的方式。重构的关键在于运用大量微小且保持软件行为的步骤，一步步达成大规模的修改。每个单独的重构要么很小，要么由若干小步骤组合而成。因此，在重构的过程中，我的代码很少进入不可工作的状态，即便重构没有完成，我也可以在任何时刻停下来。</p><blockquote><p><strong>Tip</strong><br>如果有人说他们的代码在重构过程中有一两天时间不可用，基本上可以确定，他们在做的事不是重构。</p></blockquote><p>我会用“结构调整”（restructuring）来泛指对代码库进行的各种形式的重新组织或清理，重构则是特定的一类结构调整。刚接触重构的人看我用很多小步骤完成似乎可以一大步就能做完的事，可能会觉得这样很低效。但小步前进能让我走得更快，因为这些小步骤能完美地彼此组合，而且——更关键的是——整个过程中我不会花任何时间来调试。</p><p>在上述定义中，我用了“可观察行为”的说法。它的意思是，整体而言，经过重构之后的代码所做的事应该与重构之前大致一样。这个说法并非完全严格，并且我是故意保留这点儿空间的：重构之后的代码不一定与重构前行为完全一致。比如说，提炼函数（106）会改变函数调用栈，因此程序的性能就会有所改变；改变函数声明（124）和搬移函数（198）等重构经常会改变模块的接口。不过就用户应该关心的行为而言，不应该有任何改变。如果我在重构过程中发现了任何 bug，重构完成后同样的 bug 应该仍然存在（不过，如果潜在的 bug 还没有被任何人发现，也可以当即把它改掉）。</p><p>重构与性能优化有很多相似之处：两者都需要修改代码，并且两者都不会改变程序的整体功能。两者的差别在于其目的：重构是为了让代码“更容易理解，更易于修改”。这可能使程序运行得更快，也可能使程序运行得更慢。在性能优化时，我只关心让程序运行得更快，最终得到的代码有可能更难理解和维护，对此我有心理准备。</p><h2 id="2-2-两顶帽子"><a href="#2-2-两顶帽子" class="headerlink" title="2.2 两顶帽子"></a>2.2 两顶帽子</h2><p>Kent Beck 提出了“两顶帽子”的比喻。使用重构技术开发软件时，我把自己的时间分配给两种截然不同的行为：添加新功能和重构。添加新功能时，我不应该修改既有代码，只管添加新功能。通过添加测试并让测试正常运行，我可以衡量自己的工作进度。重构时我就不能再添加功能，只管调整代码的结构。此时我不应该添加任何测试（除非发现有先前遗漏的东西），只在绝对必要（用以处理接口变化）时才修改测试。</p><p>软件开发过程中，我可能会发现自己经常变换帽子。首先我会尝试添加新功能，然后会意识到：如果把程序结构改一下，功能的添加会容易得多。于是我换一顶帽子，做一会儿重构工作。程序结构调整好后，我又换上原先的帽子，继续添加新功能。新功能正常工作后，我又发现自己的编码造成程序难以理解，于是又换上重构帽子……整个过程或许只花 10 分钟，但无论何时我都清楚自己戴的是哪一顶帽子，并且明白不同的帽子对编程状态提出的不同要求。</p><h2 id="2-3-为何重构"><a href="#2-3-为何重构" class="headerlink" title="2.3 为何重构"></a>2.3 为何重构</h2><p>我不想把重构说成是包治百病的万灵丹，它绝对不是所谓的“银弹”。不过它的确很有价值，尽管它不是一颗“银弹”，却可以算是一把“银钳子”，可以帮你始终良好地控制自己的代码。重构是一个工具，它可以（并且应该）用于以下几个目的。</p><h3 id="重构改进软件的设计"><a href="#重构改进软件的设计" class="headerlink" title="重构改进软件的设计"></a>重构改进软件的设计</h3><p>如果没有重构，程序的内部设计（或者叫架构）会逐渐腐败变质。当人们只为短期目的而修改代码时，他们经常没有完全理解架构的整体设计，于是代码逐渐失去了自己的结构。程序员越来越难通过阅读源码来理解原来的设计。代码结构的流失有累积效应。越难看出代码所代表的设计意图，就越难保护其设计，于是设计就腐败得越快。经常性的重构有助于代码维持自己该有的形态。</p><p>完成同样一件事，设计欠佳的程序往往需要更多代码，这常常是因为代码在不同的地方使用完全相同的语句做同样的事，因此改进设计的一个重要方向就是消除重复代码。代码量减少并不会使系统运行更快，因为这对程序的资源占用几乎没有任何明显影响。然而代码量减少将使未来可能的程序修改动作容易得多。代码越多，做正确的修改就越困难，因为有更多代码需要理解。我在这里做了点儿修改，系统却不如预期那样工作，因为我没有修改另一处——那里的代码做着几乎完全一样的事情，只是所处环境略有不同。消除重复代码，我就可以确定所有事物和行为在代码中只表述一次，这正是优秀设计的根本。</p><h3 id="重构使软件更容易理解"><a href="#重构使软件更容易理解" class="headerlink" title="重构使软件更容易理解"></a>重构使软件更容易理解</h3><p>所谓程序设计，很大程度上就是与计算机对话：我编写代码告诉计算机做什么事，而它的响应是按照我的指示精确行动。一言以蔽之，我所做的就是填补“我想要它做什么”和“我告诉它做什么”之间的缝隙。编程的核心就在于“准确说出我想要的”。然而别忘了，除了计算机外，源码还有其他读者：几个月之后可能会有另一位程序员尝试读懂我的代码并对其做一些修改。我们很容易忘记这这位读者，但他才是最重要的。计算机是否多花了几个时钟周期来编译，又有什么关系呢？如果一个程序员花费一周时间来修改某段代码，那才要命呢——如果他理解了我的代码，这个修改原本只需一小时。</p><p>问题在于，当我努力让程序运转的时候，我不会想到未来出现的那个开发者。是的，我们应该改变一下开发节奏，让代码变得更易于理解。重构可以帮我让代码更易读。开始进行重构前，代码可以正常运行，但结构不够理想。在重构上花一点点时间，就可以让代码更好地表达自己的意图——更清晰地说出我想要做的。</p><p>关于这一点，我没必要表现得多么无私。很多时候那个未来的开发者就是我自己。此时重构就显得尤其重要了。我是一个很懒惰的程序员，我的懒惰表现形式之一就是：总是记不住自己写过的代码。事实上，对于任何能够立刻查阅的东西，我都故意不去记它，因为我怕把自己的脑袋塞爆。我总是尽量把该记住的东西写进代码里，这样我就不必记住它了。这么一来，下班后我还可以喝上两杯 Maudite 啤酒，不必太担心它杀光我的脑细胞。</p><h3 id="重构帮助找到-bug"><a href="#重构帮助找到-bug" class="headerlink" title="重构帮助找到 bug"></a>重构帮助找到 bug</h3><p>对代码的理解，可以帮我找到 bug。我承认我不太擅长找 bug。有些人只要盯着一大段代码就可以找出里面的 bug，我不行。但我发现，如果对代码进行重构，我就可以深入理解代码的所作所为，并立即把新的理解反映在代码当中。搞清楚程序结构的同时，我也验证了自己所做的一些假设，于是想不把 bug 揪出来都难。</p><p>这让我想起了 Kent Beck 经常形容自己的一句话：“我不是一个特别好的程序员，我只是一个有着一些特别好的习惯的还不错的程序员。”重构能够帮助我更有效地写出健壮的代码。</p><h3 id="重构提高编程速度"><a href="#重构提高编程速度" class="headerlink" title="重构提高编程速度"></a>重构提高编程速度</h3><p>最后，前面的一切都归结到了这一点：重构帮我更快速地开发程序。</p><p>听起来有点儿违反直觉。当我谈到重构时，人们很容易看出它能够提高质量。改善设计、提升可读性、减少 bug，这些都能提高质量。但花在重构上的时间，难道不是在降低开发速度吗？</p><p>当我跟那些在一个系统上工作较长时间的软件开发者交谈时，经常会听到这样的故事：一开始他们进展很快，但如今想要添加一个新功能需要的时间就要长得多。他们需要花越来越多的时间去考虑如何把新功能塞进现有的代码库，不断蹦出来的 bug 修复起来也越来越慢。代码库看起来就像补丁摞补丁，需要细致的考古工作才能弄明白整个系统是如何工作的。这份负担不断拖慢新增功能的速度，到最后程序员恨不得从头开始重写整个系统。</p><p>下面这幅图可以描绘他们经历的困境。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151638297.png"></p><p>但有些团队的境遇则截然不同。他们添加新功能的速度越来越快，因为他们能利用已有的功能，基于已有的功能快速构建新功能。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151638793.png"></p><p>两种团队的区别就在于软件的内部质量。需要添加新功能时，内部质量良好的软件让我可以很容易找到在哪里修改、如何修改。良好的模块划分使我只需要理解代码库的一小部分，就可以做出修改。如果代码很清晰，我引入 bug 的可能性就会变小，即使引入了 bug，调试也会容易得多。理想情况下，我的代码库会逐步演化成一个平台，在其上可以很容易地构造与其领域相关的新功能。</p><p>我把这种现象称为“设计耐久性假说”：通过投入精力改善内部设计，我们增加了软件的耐久性，从而可以更长时间地保持开发的快速。我还无法科学地证明这个理论，所以我说它是一个“假说”。但我的经验，以及我在职业生涯中认识的上百名优秀程序员的经验，都支持这个假说。</p><p>20 年前，行业的陈规认为：良好的设计必须在开始编程之前完成，因为一旦开始编写代码，设计就只会逐渐腐败。重构改变了这个图景。现在我们可以改善已有代码的设计，因此我们可以先做一个设计，然后不断改善它，哪怕程序本身的功能也在不断发生着变化。由于预先做出良好的设计非常困难，想要既体面又快速地开发功能，重构必不可少。</p><h2 id="2-4-何时重构"><a href="#2-4-何时重构" class="headerlink" title="2.4 何时重构"></a>2.4 何时重构</h2><p>在我编程的每个小时，我都会做重构。有几种方式可以把重构融入我的工作过程里。</p><blockquote><p><strong>Tip</strong><br>三次法则</p></blockquote><p>Don Roberts 给了我一条准则：第一次做某件事时只管去做；第二次做类似的事会产生反感，但无论如何还是可以去做；第三次再做类似的事，你就应该重构。</p><p>正如老话说的：事不过三，三则重构。</p><h3 id="预备性重构：让添加新功能更容易"><a href="#预备性重构：让添加新功能更容易" class="headerlink" title="预备性重构：让添加新功能更容易"></a>预备性重构：让添加新功能更容易</h3><p>重构的最佳时机就在添加新功能之前。在动手添加新功能之前，我会看看现有的代码库，此时经常会发现：如果对代码结构做一点微调，我的工作会容易得多。也许已经有个函数提供了我需要的大部分功能，但有几个字面量的值与我的需要略有冲突。如果不做重构，我可能会把整个函数复制过来，修改这几个值，但这就会导致重复代码——如果将来我需要做修改，就必须同时修改两处（更麻烦的是，我得先找到这两处）。而且，如果将来我还需要一个类似又略有不同的功能，就只能再复制粘贴一次，这可不是个好主意。所以我戴上重构的帽子，使用函数参数化（310）。做完这件事以后，接下来我就只需要调用这个函数，传入我需要的参数。</p><blockquote><p><strong>Tip</strong><br>这就好像我要往东去 100 公里。我不会往东一头把车开进树林，而是先往北开 20 公里上高速，然后再向东开 100 公里。后者的速度比前者要快上 3 倍。如果有人催着你“赶快直接去那儿”，有时你需要说：“等等，我要先看看地图，找出最快的路径。”这就是预备性重构于我的意义。</p></blockquote><p>——Jessica Kerr</p><p>修复 bug 时的情况也是一样。在寻找问题根因时，我可能会发现：如果把 3 段一模一样且都会导致错误的代码合并到一处，问题修复起来会容易得多。或者，如果把某些更新数据的逻辑与查询逻辑分开，会更容易避免造成错误的逻辑纠缠。用重构改善这些情况，在同样场合再次出现同样 bug 的概率也会降低。</p><h3 id="帮助理解的重构：使代码更易懂"><a href="#帮助理解的重构：使代码更易懂" class="headerlink" title="帮助理解的重构：使代码更易懂"></a>帮助理解的重构：使代码更易懂</h3><p>我需要先理解代码在做什么，然后才能着手修改。这段代码可能是我写的，也可能是别人写的。一旦我需要思考“这段代码到底在做什么”，我就会自问：能不能重构这段代码，令其一目了然？我可能看见了一段结构糟糕的条件逻辑，也可能希望复用一个函数，但花费了几分钟才弄懂它到底在做什么，因为它的函数命名实在是太糟糕了。这些都是重构的机会。</p><p>看代码时，我会在脑海里形成一些理解，但我的记性不好，记不住那么多细节。正如 Ward Cunningham 所说，通过重构，我就把脑子里的理解转移到了代码本身。随后我运行这个软件，看它是否正常工作，来检查这些理解是否正确。如果把对代码的理解植入代码中，这份知识会保存得更久，并且我的同事也能看到。</p><p>重构带来的帮助不仅发生在将来——常常是立竿见影。我会先在一些小细节上使用重构来帮助理解，给一两个变量改名，让它们更清楚地表达意图，以方便理解，或是将一个长函数拆成几个小函数。当代码变得更清晰一些时，我就会看见之前看不见的设计问题。如果不做前面的重构，我可能永远都看不见这些设计问题，因为我不够聪明，无法在脑海中推演所有这些变化。Ralph Johnson 说，这些初步的重构就像扫去窗上的尘埃，使我们得以看到窗外的风景。在研读代码时，重构会引领我获得更高层面的理解，如果只是阅读代码很难有此领悟。有些人以为这些重构只是毫无意义地把玩代码，他们没有意识到，缺少了这些细微的整理，他们就无法看到隐藏在一片混乱背后的机遇。</p><h3 id="捡垃圾式重构"><a href="#捡垃圾式重构" class="headerlink" title="捡垃圾式重构"></a>捡垃圾式重构</h3><p>帮助理解的重构还有一个变体：我已经理解代码在做什么，但发现它做得不好，例如逻辑不必要地迂回复杂，或者两个函数几乎完全相同，可以用一个参数化的函数取而代之。这里有一个取舍：我不想从眼下正要完成的任务上跑题太多，但我也不想把垃圾留在原地，给将来的修改增加麻烦。如果我发现的垃圾很容易重构，我会马上重构它；如果重构需要花一些精力，我可能会拿一张便笺纸把它记下来，完成当下的任务再回来重构它。</p><p>当然，有时这样的垃圾需要好几个小时才能解决，而我又有更紧急的事要完成。不过即便如此，稍微花一点工夫做一点儿清理，通常都是值得的。正如野营者的老话所说：至少要让营地比你到达时更干净。如果每次经过这段代码时都把它变好一点点，积少成多，垃圾总会被处理干净。重构的妙处就在于，每个小步骤都不会破坏代码——所以，有时一块垃圾在好几个月之后才终于清理干净，但即便每次清理并不完整，代码也不会被破坏。</p><h3 id="有计划的重构和见机行事的重构"><a href="#有计划的重构和见机行事的重构" class="headerlink" title="有计划的重构和见机行事的重构"></a>有计划的重构和见机行事的重构</h3><p>上面的例子——预备性重构、帮助理解的重构、捡垃圾式重构——都是见机行事的：我并不专门安排一段时间来重构，而是在添加功能或修复 bug 的同时顺便重构。这是我自然的编程流的一部分。不管是要添加功能还是修复 bug，重构对我当下的任务有帮助，而且让我未来的工作更轻松。这是一件很重要而又常被误解的事：重构不是与编程割裂的行为。你不会专门安排时间重构，正如你不会专门安排时间写 if 语句。我的项目计划上没有专门留给重构的时间，绝大多数重构都在我做其他事的过程中自然发生。</p><blockquote><p><strong>Tip</strong><br>肮脏的代码必须重构，但漂亮的代码也需要很多重构。</p></blockquote><p>还有一种常见的误解认为，重构就是人们弥补过去的错误或者清理肮脏的代码。当然，如果遇上了肮脏的代码，你必须重构，但漂亮的代码也需要很多重构。在写代码时，我会做出很多权衡取舍：参数化需要做到什么程度？函数之间的边界应该划在哪里？对于昨天的功能完全合理的权衡，在今天要添加新功能时可能就不再合理。好在，当我需要改变这些权衡以反映现实情况的变化时，整洁的代码重构起来会更容易。</p><blockquote><p><strong>Tip</strong><br>每次要修改时，首先令修改很容易（警告：这件事有时会很难），然后再进行这次容易的修改。</p></blockquote><p>——Kent Beck</p><p>长久以来，人们认为编写软件是一个累加的过程：要添加新功能，我们就应该增加新代码。但优秀的程序员知道，添加新功能最快的方法往往是先修改现有的代码，使新功能容易被加入。所以，软件永远不应该被视为“完成”。每当需要新能力时，软件就应该做出相应的改变。越是在已有代码中，这样的改变就越显重要。</p><p>不过，说了这么多，并不表示有计划的重构总是错的。如果团队过去忽视了重构，那么常常会需要专门花一些时间来优化代码库，以便更容易添加新功能。在重构上花一个星期的时间，会在未来几个月里发挥价值。有时，即便团队做了日常的重构，还是会有问题在某个区域逐渐累积长大，最终需要专门花些时间来解决。但这种有计划的重构应该很少，大部分重构应该是不起眼的、见机行事的。</p><p>我听过的一条建议是：将重构与添加新功能在版本控制的提交中分开。这样做的一大好处是可以各自独立地审阅和批准这些提交。但我并不认同这种做法。重构常常与新添功能紧密交织，不值得花工夫把它们分开。并且这样做也使重构脱离了上下文，使人看不出这些“重构提交”的价值。每个团队应该尝试并找出适合自己的工作方式，只是要记住：分离重构提交并不是毋庸置疑的原则，只有当你真的感到有益时，才值得这样做。</p><h3 id="长期重构"><a href="#长期重构" class="headerlink" title="长期重构"></a>长期重构</h3><p>大多数重构可以在几分钟——最多几小时——内完成。但有一些大型的重构可能要花上几个星期，例如要替换一个正在使用的库，或者将整块代码抽取到一个组件中并共享给另一支团队使用，再或者要处理一大堆混乱的依赖关系，等等。</p><p>即便在这样的情况下，我仍然不愿让一支团队专门做重构。可以让整个团队达成共识，在未来几周时间里逐步解决这个问题，这经常是一个有效的策略。每当有人靠近“重构区”的代码，就把它朝想要改进的方向推动一点。这个策略的好处在于，重构不会破坏代码——每次小改动之后，整个系统仍然照常工作。例如，如果想替换掉一个正在使用的库，可以先引入一层新的抽象，使其兼容新旧两个库的接口。一旦调用方已经完全改为使用这层抽象，替换下面的库就会容易得多。（这个策略叫作 Branch By Abstraction[mf-bba]。）</p><h3 id="复审代码时重构"><a href="#复审代码时重构" class="headerlink" title="复审代码时重构"></a>复审代码时重构</h3><p>一些公司会做常规的代码复审（code review），因为这种活动可以改善开发状况。代码复审有助于在开发团队中传播知识，也有助于让较有经验的开发者把知识传递给比较欠缺经验的人，并帮助更多人理解大型软件系统中的更多部分。代码复审对于编写清晰代码也很重要。我的代码也许对我自己来说很清晰，对他人则不然。这是无法避免的，因为要让开发者设身处地为那些不熟悉自己所作所为的人着想，实在太困难了。代码复审也让更多人有机会提出有用的建议，毕竟我在一个星期之内能够想出的好点子很有限。如果能得到别人的帮助，我的生活会滋润得多，所以我总是期待更多复审。</p><p>我发现，重构可以帮助我复审别人的代码。开始重构前我可以先阅读代码，得到一定程度的理解，并提出一些建议。一旦想到一些点子，我就会考虑是否可以通过重构立即轻松地实现它们。如果可以，我就会动手。这样做了几次以后，我可以更清楚地看到，当我的建议被实施以后，代码会是什么样。我不必想象代码应该是什么样，我可以真实看见。于是我可以获得更高层次的认识。如果不进行重构，我永远无法得到这样的认识。</p><p>重构还可以帮助代码复审工作得到更具体的结果。不仅获得建议，而且其中许多建议能够立刻实现。最终你将从实践中得到比以往多得多的成就感。</p><p>至于如何在代码复审的过程中加入重构，这要取决于复审的形式。在常见的 pull request 模式下，复审者独自浏览代码，代码的作者不在旁边，此时进行重构效果并不好。如果代码的原作者在旁边会好很多，因为作者能提供关于代码的上下文信息，并且充分认同复审者进行修改的意图。对我个人而言，与原作者肩并肩坐在一起，一边浏览代码一边重构，体验是最佳的。这种工作方式很自然地导向结对编程：在编程的过程中持续不断地进行代码复审。</p><h3 id="怎么对经理说"><a href="#怎么对经理说" class="headerlink" title="怎么对经理说"></a>怎么对经理说</h3><p>“该怎么跟经理说重构的事?”这是我最常被问到的一个问题。毋庸讳言，我见过一些场合，“重构”被视为一个脏词——经理（和客户）认为重构要么是在弥补过去犯下的错误，要么是不增加价值的无用功。如果团队又计划了几周时间专门做重构，情况就更糟糕了——如果他们做的其实还不是重构，而是不加小心的结构调整，然后又对代码库造成了破坏，那可就真是糟透了。</p><p>如果这位经理懂技术，能理解“设计耐久性假说”，那么向他说明重构的意义应该不会很困难。这样的经理应该会鼓励日常的重构，并主动寻找团队日常重构做得不够的征兆。虽然“团队做了太多重构”的情况确实也发生过，但比起做得不够的情况要罕见得多了。</p><p>当然，很多经理和客户不具备这样的技术意识，他们不理解代码库的健康对生产率的影响。这种情况下我会给团队一个较有争议的建议：不要告诉经理！</p><p>这是在搞破坏吗？我不这样想。软件开发者都是专业人士。我们的工作就是尽可能快速创造出高效软件。我的经验告诉我，对于快速创造软件，重构可带来巨大帮助。如果需要添加新功能，而原本设计却又使我无法方便地修改，我发现先重构再添加新功能会更快些。如果要修补错误，就得先理解软件的工作方式，而我发现重构是理解软件的最快方式。受进度驱动的经理要我尽可能快速完成任务，至于怎么完成，那就是我的事了。我领这份工资，是因为我擅长快速实现新功能；我认为最快的方式就是重构，所以我就重构。</p><h3 id="何时不应该重构"><a href="#何时不应该重构" class="headerlink" title="何时不应该重构"></a>何时不应该重构</h3><p>听起来好像我一直在提倡重构，但确实有一些不值得重构的情况。</p><p>如果我看见一块凌乱的代码，但并不需要修改它，那么我就不需要重构它。如果丑陋的代码能被隐藏在一个 API 之下，我就可以容忍它继续保持丑陋。只有当我需要理解其工作原理时，对其进行重构才有价值。</p><p>另一种情况是，如果重写比重构还容易，就别重构了。这是个困难的决定。如果不花一点儿时间尝试，往往很难真实了解重构一块代码的难度。决定到底应该重构还是重写，需要良好的判断力与丰富的经验，我无法给出一条简单的建议。</p><h2 id="2-5-重构的挑战"><a href="#2-5-重构的挑战" class="headerlink" title="2.5 重构的挑战"></a>2.5 重构的挑战</h2><p>每当有人大力推荐一种技术、工具或者架构时，我总是会观察这东西会遇到哪些挑战，毕竟生活中很少有晴空万里的好事。你需要了解一件事背后的权衡取舍，才能决定何时何地应用它。我认为重构是一种很有价值的技术，大多数团队都应该更多地重构，但它也不是完全没有挑战的。有必要充分了解重构会遇到的挑战，这样才能做出有效应对。</p><h3 id="延缓新功能开发"><a href="#延缓新功能开发" class="headerlink" title="延缓新功能开发"></a>延缓新功能开发</h3><p>如果你读了前面一小节，我对这个挑战的回应便已经很清楚了。尽管重构的目的是加快开发速度，但是，仍旧很多人认为，花在重构的时间是在拖慢新功能的开发进度。“重构会拖慢进度”这种看法仍然很普遍，这可能是导致人们没有充分重构的最大阻力所在。</p><blockquote><p><strong>Tip</strong><br>重构的唯一目的就是让我们开发更快，用更少的工作量创造更大的价值。</p></blockquote><p>有一种情况确实需要权衡取舍。我有时会看到一个（大规模的）重构很有必要进行，而马上要添加的功能非常小，这时我会更愿意先把新功能加上，然后再做这次大规模重构。做这个决定需要判断力——这是我作为程序员的专业能力之一。我很难描述决定的过程，更无法量化决定的依据。</p><p>我清楚地知道，预备性重构常会使修改更容易，所以如果做一点儿重构能让新功能实现更容易，我一定会做。如果一个问题我已经见过，此时我也会更倾向于重构它——有时我就得先看见一块丑陋的代码几次，然后才能提起劲头来重构它。也就是说，如果一块代码我很少触碰，它不会经常给我带来麻烦，那么我就倾向于不去重构它。如果我还没想清楚究竟应该如何优化代码，那么我可能会延迟重构；当然，有的时候，即便没想清楚优化的方向，我也会先做些实验，试试看能否有所改进。</p><p>我从同事那里听到的证据表明，在我们这个行业里，重构不足的情况远多于重构过度的情况。换句话说，绝大多数人应该尝试多做重构。代码库的健康与否，到底会对生产率造成多大的影响，很多人可能说不出来，因为他们没有太多在健康的代码库上工作的经历——轻松地把现有代码组合配置，快速构造出复杂的新功能，这种强大的开发方式他们没有体验过。</p><p>虽然我们经常批评管理者以“保障开发速度”的名义压制重构，其实程序员自己也经常这么干。有时他们自己觉得不应该重构，其实他们的领导还挺希望他们做一些重构的。如果你是一支团队的技术领导，一定要向团队成员表明，你重视改善代码库健康的价值。合理判断何时应该重构、何时应该暂时不重构，这样的判断力需要多年经验积累。对于重构缺乏经验的年轻人需要有意的指导，才能帮助他们加速经验积累的过程。</p><p>有些人试图用“整洁的代码”“良好的工程实践”之类道德理由来论证重构的必要性，我认为这是个陷阱。重构的意义不在于把代码库打磨得闪闪发光，而是纯粹经济角度出发的考量。我们之所以重构，因为它能让我们更快——添加功能更快，修复 bug 更快。一定要随时记住这一点，与别人交流时也要不断强调这一点。重构应该总是由经济利益驱动。程序员、经理和客户越理解这一点，“好的设计”那条曲线就会越经常出现。</p><h3 id="代码所有权"><a href="#代码所有权" class="headerlink" title="代码所有权"></a>代码所有权</h3><p>很多重构手法不仅会影响一个模块内部，还会影响该模块与系统其他部分的关系。比如我想给一个函数改名，并且我也能找到该函数的所有调用者，那么我只需运用改变函数声明（124），在一次重构中修改函数声明和调用者。但即便这么简单的一个重构，有时也无法实施：调用方代码可能由另一支团队拥有，而我没有权限写入他们的代码库；这个函数可能是一个提供给客户的 API，这时我根本无法知道是否有人使用它，至于谁在用、用得有多频繁就更是一无所知。这样的函数属于已发布接口（published interface）：接口的使用者（客户端）与声明者彼此独立，声明者无权修改使用者的代码。</p><p>代码所有权的边界会妨碍重构，因为一旦我自作主张地修改，就一定会破坏使用者的程序。这不会完全阻止重构，我仍然可以做很多重构，但确实会对重构造成约束。为了给一个函数改名，我需要使用函数改名（124），但同时也得保留原来的函数声明，使其把调用传递给新的函数。这会让接口变复杂，但这就是为了避免破坏使用者的系统而不得不付出的代价。我可以把旧的接口标记为“不推荐使用”（deprecated），等一段时间之后最终让其退休；但有些时候，旧的接口必须一直保留下去。</p><p>由于这些复杂性，我建议不要搞细粒度的强代码所有制。有些组织喜欢给每段代码都指定唯一的所有者，只有这个人能修改这段代码。我曾经见过一支只有三个人的团队以这种方式运作，每个程序员都要给另外两人发布接口，随之而来的就是接口维护的种种麻烦。如果这三个人都直接去代码库里做修改，事情会简单得多。我推荐团队代码所有制，这样一支团队里的成员都可以修改这个团队拥有的代码，即便最初写代码的是别人。程序员可能各自分工负责系统的不同区域，但这种责任应该体现为监控自己责任区内发生的修改，而不是简单粗暴地禁止别人修改。</p><p>这种较为宽容的代码所有制甚至可以应用于跨团队的场合。有些团队鼓励类似于开源的模型：B 团队的成员也可以在一个分支上修改 A 团队的代码，然后把提交发送给 A 团队去审核。这样一来，如果团队想修改自己的函数，他们就可以同时修改该函数的客户端的代码；只要客户端接受了他们的修改，就可以删掉旧的函数声明了。对于涉及多个团队的大系统开发，在“强代码所有制”和“混乱修改”两个极端之间，这种类似开源的模式常常是一个合适的折中。</p><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>很多团队采用这样的版本控制实践：每个团队成员各自在代码库的一条分支上工作，进行相当大量的开发之后，才把各自的修改合并回主线分支（这条分支通常叫 master 或 trunk），从而与整个团队分享。常见的做法是在分支上开发完整的功能，直到功能可以发布到生产环境，才把该分支合并回主线。这种做法的拥趸声称，这样能保持主线不受尚未完成的代码侵扰，能保留清晰的功能添加的版本记录，并且在某个功能出问题时能容易地撤销修改。</p><p>这样的特性分支有其缺点。在隔离的分支上工作得越久，将完成的工作集成（integrate）回主线就会越困难。为了减轻集成的痛苦，大多数人的办法是频繁地从主线合并（merge）或者变基（rebase）到分支。但如果有几个人同时在各自的特性分支上工作，这个办法并不能真正解决问题，因为合并与集成是两回事。如果我从主线合并到我的分支，这只是一个单向的代码移动——我的分支发生了修改，但主线并没有。而“集成”是一个双向的过程：不仅要把主线的修改拉（pull）到我的分支上，而且要把我这里修改的结果推（push）回到主线上，两边都会发生修改。假如另一名程序员 Rachel 正在她的分支上开发，我是看不见她的修改的，直到她将自己的修改与主线集成；此时我就必须把她的修改合并到我的特性分支，这可能需要相当的工作量。其中困难的部分是处理语义变化。现代版本控制系统都能很好地合并程序文本的复杂修改，但对于代码的语义它们一无所知。如果我修改了一个函数的名字，版本控制工具可以很轻松地将我的修改与 Rachel 的代码集成。但如果在集成之前，她在自己的分支里新添调用了这个被我改名的函数，集成之后的代码就会被破坏。</p><p>分支合并本来就是一个复杂的问题，随着特性分支存在的时间加长，合并的难度会指数上升。集成一个已经存在了 4 个星期的分支，较之集成存在了 2 个星期的分支，难度可不止翻倍。所以很多人认为，应该尽量缩短特性分支的生存周期，比如只有一两天。还有一些人（比如我本人）认为特性分支的生命还应该更短，我们采用的方法叫作持续集成（Continuous Integration，CI），也叫“基于主干开发”（Trunk-Based Development）。在使用 CI 时，每个团队成员每天至少向主线集成一次。这个实践避免了任何分支彼此差异太大，从而极大地降低了合并的难度。不过 CI 也有其代价：你必须使用相关的实践以确保主线随时处于健康状态，必须学会将大功能拆分成小块，还必须使用特性开关（feature toggle，也叫特性旗标，feature flag）将尚未完成又无法拆小的功能隐藏掉。</p><p>CI 的粉丝之所以喜欢这种工作方式，部分原因是它降低了分支合并的难度，不过最重要的原因还是 CI 与重构能良好配合。重构经常需要对代码库中的很多地方做很小的修改（例如给一个广泛使用的函数改名），这样的修改尤其容易造成合并时的语义冲突。采用特性分支的团队常会发现重构加剧了分支合并的困难，并因此放弃了重构，这种情况我们曾经见过多次。CI 和重构能够良好配合，所以 Kent Beck 在极限编程中同时包含了这两个实践。</p><p>我并不是在说绝不应该使用特性分支。如果特性分支存在的时间足够短，它们就不会造成大问题。（实际上，使用 CI 的团队往往同时也使用分支，但他们会每天将分支与主线合并。）对于开源项目，特性分支可能是合适的做法，因为不时会有你不熟悉（因此也不信任）的程序员偶尔提交修改。但对全职的开发团队而言，特性分支对重构的阻碍太严重了。即便你没有完全采用 CI，我也一定会催促你尽可能频繁地集成。而且，用上 CI 的团队在软件交付上更加高效，我真心希望你认真考虑这个客观事实[Forsgren et al]。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>不会改变程序可观察的行为，这是重构的一个重要特征。如果仔细遵循重构手法的每个步骤，我应该不会破坏任何东西，但万一我犯了个错误怎么办？（呃，就我这个粗心大意的性格来说，请去掉“万一”两字。）人总会有出错的时候，不过只要及时发现，就不会造成大问题。既然每个重构都是很小的修改，即便真的造成了破坏，我也只需要检查最后一步的小修改——就算找不到出错的原因，只要回滚到版本控制中最后一个可用的版本就行了。</p><p>这里的关键就在于“快速发现错误”。要做到这一点，我的代码应该有一套完备的测试套件，并且运行速度要快，否则我会不愿意频繁运行它。也就是说，绝大多数情况下，如果想要重构，我得先有可以自测试的代码[mf-stc]。</p><p>有些读者可能会觉得，“自测试的代码”这个要求太高，根本无法实现。但在过去 20 年中，我看到很多团队以这种方式构造软件。的确，团队必须投入时间与精力在测试上，但收益是绝对划算的。自测试的代码不仅使重构成为可能，而且使添加新功能更加安全，因为我可以很快发现并干掉新近引入的 bug。这里的关键在于，一旦测试失败，我只需要查看上次测试成功运行之后修改的这部分代码；如果测试运行得很频繁，这个查看的范围就只有几行代码。知道必定是这几行代码造成 bug 的话，排查起来会容易得多。</p><p>这也回答了“重构风险太大，可能引入 bug”的担忧。如果没有自测试的代码，这种担忧就是完全合理的，这也是为什么我如此重视可靠的测试。</p><p>缺乏测试的问题可以用另一种方式来解决。如果我的开发环境很好地支持自动化重构，我就可以信任这些重构，不必运行测试。这时即便没有完备的测试套件，我仍然可以重构，前提是仅仅使用那些自动化的、一定安全的重构手法。这会让我损失很多好用的重构手法，不过剩下可用的也不少，我还是能从中获益。当然，我还是更愿意有自测试的代码，但如果没有，自动化重构的工具包也很好。</p><p>缺乏测试的现状还催生了另一种重构的流派：只使用一组经过验证是安全的重构手法。这个流派要求严格遵循重构的每个步骤，并且可用的重构手法是特定于语言的。使用这种方法，团队得以在测试覆盖率很低的大型代码库上开展一些有用的重构。这个重构流派比较新，涉及一些很具体、特定于编程语言的技巧与做法，行业里对这种方法的介绍和了解都还不足，因此本书不对其多做介绍。（不过我希望未来在我自己的网站上多讨论这个主题。感兴趣的读者可以查看 Jay Bazuzi 关于如何在 C++中安全地运用提炼函数（106）的描述[Bazuzi]，借此获得一点儿对这个重构流派的了解。）</p><p>毫不意外，自测试代码与持续集成紧密相关——我们仰赖持续集成来及时捕获分支集成时的语义冲突。自测试代码是极限编程的另一个重要组成部分，也是持续交付的关键环节。</p><h3 id="遗留代码"><a href="#遗留代码" class="headerlink" title="遗留代码"></a>遗留代码</h3><p>大多数人会觉得，有一大笔遗产是件好事，但从程序员的角度来看就不同了。遗留代码往往很复杂，测试又不足，而且最关键的是，是别人写的（瑟瑟发抖）。</p><p>重构可以很好地帮助我们理解遗留系统。引人误解的函数名可以改名，使其更好地反映代码用途；糟糕的程序结构可以慢慢理顺，把程序从一块顽石打磨成美玉。整个故事都很棒，但我们绕不开关底的恶龙：遗留系统多半没测试。如果你面对一个庞大而又缺乏测试的遗留系统，很难安全地重构清理它。</p><p>对于这个问题，显而易见的答案是“没测试就加测试”。这事听起来简单（当然工作量必定很大），操作起来可没那么容易。一般来说，只有在设计系统时就考虑到了测试，这样的系统才容易添加测试——可要是如此，系统早该有测试了，我也不用操这份心了。</p><p>这个问题没有简单的解决办法，我能给出的最好建议就是买一本《修改代码的艺术》[Feathers]，照书里的指导来做。别担心那本书太老，尽管已经出版十多年，其中的建议仍然管用。一言以蔽之，它建议你先找到程序的接缝，在接缝处插入测试，如此将系统置于测试覆盖之下。你需要运用重构手法创造出接缝——这样的重构很危险，因为没有测试覆盖，但这是为了取得进展必要的风险。在这种情况下，安全的自动化重构简直就是天赐福音。如果这一切听起来很困难，因为它确实很困难。很遗憾，一旦跌进这个深坑，没有爬出来的捷径，这也是我强烈倡导从一开始就写能自测试的代码的原因。</p><p>就算有了测试，我也不建议你尝试一鼓作气把复杂而混乱的遗留代码重构成漂亮的代码。我更愿意随时重构相关的代码：每次触碰一块代码时，我会尝试把它变好一点点——至少要让营地比我到达时更干净。如果是一个大系统，越是频繁使用的代码，改善其可理解性的努力就能得到越丰厚的回报。</p><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>在本书的第 1 版中，我说过数据库是“重构经常出问题的一个领域”。然而在第 1 版问世之后仅仅一年，情况就发生了改变：我的同事 Pramod Sadalage 发展出一套渐进式数据库设计[mf-evodb]和数据库重构[Ambler &amp; Sadalage]的办法，如今已经被广泛使用。这项技术的精要在于：借助数据迁移脚本，将数据库结构的修改与代码相结合，使大规模的、涉及数据库的修改可以比较容易地开展。</p><p>假设我们要对一个数据库字段（列）改名。和改变函数声明（124）一样，我要找出结构的声明处和所有调用处，然后一次完成所有修改。但这里的复杂之处在于，原来基于旧字段的数据，也要转为使用新字段。我会写一小段代码来执行数据转化的逻辑，并把这段代码放进版本控制，跟数据结构声明与使用代码的修改一并提交。此后如果我想把数据库迁移到某个版本，只要执行当前数据库版本与目标版本之间的所有迁移脚本即可。</p><p>跟通常的重构一样，数据库重构的关键也是小步修改并且每次修改都应该完整，这样每次迁移之后系统仍然能运行。由于每次迁移涉及的修改都很小，写起来应该容易；将多个迁移串联起来，就能对数据库结构及其中存储的数据做很大的调整。</p><p>与常规的重构不同，很多时候，数据库重构最好是分散到多次生产发布来完成，这样即便某次修改在生产数据库上造成了问题，也比较容易回滚。比如，要改名一个字段，我的第一次提交会新添一个字段，但暂时不使用它。然后我会修改数据写入的逻辑，使其同时写入新旧两个字段。随后我就可以修改读取数据的地方，将它们逐个改为使用新字段。这步修改完成之后，我会暂停一小段时间，看看是否有 bug 冒出来。确定没有 bug 之后，我再删除已经没人使用的旧字段。这种修改数据库的方式是并行修改（Parallel Change，也叫扩展协议&#x2F;expand-contract）[mf-pc]的一个实例。</p><h2 id="2-6-重构、架构和-YAGNI"><a href="#2-6-重构、架构和-YAGNI" class="headerlink" title="2.6 重构、架构和 YAGNI"></a>2.6 重构、架构和 YAGNI</h2><p>重构极大地改变了人们考虑软件架构的方式。在我的职业生涯早期，我被告知：在任何人开始写代码之前，必须先完成软件的设计和架构。一旦代码写出来，架构就固定了，只会因为程序员的草率对待而逐渐腐败。</p><p>重构改变了这种观点。有了重构技术，即便是已经在生产环境中运行了多年的软件，我们也有能力大幅度修改其架构。正如本书的副标题所指出的，重构可以改善既有代码的设计。但我在前面也提到了，修改遗留代码经常很有挑战，尤其当遗留代码缺乏恰当的测试时。</p><p>重构对架构最大的影响在于，通过重构，我们能得到一个设计良好的代码库，使其能够优雅地应对不断变化的需求。“在编码之前先完成架构”这种做法最大的问题在于，它假设了软件的需求可以预先充分理解。但经验显示，这个假设很多时候甚至可以说大多数时候是不切实际的。只有真正使用了软件、看到了软件对工作的影响，人们才会想明白自己到底需要什么，这样的例子不胜枚举。</p><p>应对未来变化的办法之一，就是在软件里植入灵活性机制。在编写一个函数时，我会考虑它是否有更通用的用途。为了应对我预期的应用场景，我预测可以给这个函数加上十多个参数。这些参数就是灵活性机制——跟大多数“机制”一样，它不是免费午餐。把所有这些参数都加上的话，函数在当前的使用场景下就会非常复杂。另外，如果我少考虑了一个参数，已经加上的这一堆参数会使新添参数更麻烦。而且我经常会把灵活性机制弄错——可能是未来的需求变更并非以我期望的方式发生，也可能我对机制的设计不好。考虑到所有这些因素，很多时候这些灵活性机制反而拖慢了我响应变化的速度。</p><p>有了重构技术，我就可以采取不同的策略。与其猜测未来需要哪些灵活性、需要什么机制来提供灵活性，我更愿意只根据当前的需求来构造软件，同时把软件的设计质量做得很高。随着对用户需求的理解加深，我会对架构进行重构，使其能够应对新的需要。如果一种灵活性机制不会增加复杂度（比如添加几个命名良好的小函数），我可以很开心地引入它；但如果一种灵活性会增加软件复杂度，就必须先证明自己值得被引入。如果不同的调用者不会传入不同的参数值，那么就不要添加这个参数。当真的需要添加这个参数时，运用函数参数化（310）也很容易。要判断是否应该为未来的变化添加灵活性，我会评估“如果以后再重构有多困难”，只有当未来重构会很困难时，我才考虑现在就添加灵活性机制。我发现这是一个很有用的决策方法。</p><p>这种设计方法有很多名字：简单设计、增量式设计或者 YAGNI[mf-yagni]——“你不会需要它”（you arenʼt going to need it）的缩写。YAGNI 并不是“不做架构性思考”的意思，不过确实有人以这种欠考虑的方式做事。我把 YAGNI 视为将架构、设计与开发过程融合的一种工作方式，这种工作方式必须有重构作为基础才可靠。</p><p>采用 YAGNI 并不表示完全不用预先考虑架构。总有一些时候，如果缺少预先的思考，重构会难以开展。但两者之间的平衡点已经发生了很大的改变：如今我更倾向于等一等，待到对问题理解更充分，再来着手解决。演进式架构[Ford et al.]是一门仍在不断发展的学科，架构师们在不断探索有用的模式和实践，充分发挥迭代式架构决策的能力。</p><h2 id="2-7-重构与软件开发过程"><a href="#2-7-重构与软件开发过程" class="headerlink" title="2.7 重构与软件开发过程"></a>2.7 重构与软件开发过程</h2><p>读完前面“重构的挑战”一节，你大概已经有这个印象：重构是否有效，与团队采用的其他软件开发实践紧密相关。重构起初是作为极限编程（XP）[mf-xp]的一部分被人们采用的，XP 本身就融合了一组不太常见而又彼此关联的实践，例如持续集成、自测试代码以及重构（后两者融汇成了测试驱动开发）。</p><p>极限编程是最早的敏捷软件开发方法[mf-nm]之一。在一段历史时期，极限编程引领了敏捷的崛起。如今已经有很多项目使用敏捷方法，甚至敏捷的思维已经被视为主流，但实际上大部分“敏捷”项目只是徒有其名。要真正以敏捷的方式运作项目，团队成员必须在重构上有能力、有热情，他们采用的开发过程必须与常规的、持续的重构相匹配。</p><p>重构的第一块基石是自测试代码。我应该有一套自动化的测试，我可以频繁地运行它们，并且我有信心：如果我在编程过程中犯了任何错误，会有测试失败。这块基石如此重要，我会专门用一章篇幅来讨论它。</p><p>如果一支团队想要重构，那么每个团队成员都需要掌握重构技能，能在需要时开展重构，而不会干扰其他人的工作。这也是我鼓励持续集成的原因：有了 CI，每个成员的重构都能快速分享给其他同事，不会发生这边在调用一个接口那边却已把这个接口删掉的情况；如果一次重构会影响别人的工作，我们很快就会知道。自测试的代码也是持续集成的关键环节，所以这三大实践——自测试代码、持续集成、重构——彼此之间有着很强的协同效应。</p><p>有这三大实践在手，我们就能运用前一节介绍的 YAGNI 设计方法。重构和 YAGNI 交相呼应、彼此增效，重构（及其前置实践）是 YAGNI 的基础，YAGNI 又让重构更易于开展：比起一个塞满了想当然的灵活性的系统，当然是修改一个简单的系统要容易得多。在这些实践之间找到合适的平衡点，你就能进入良性循环，你的代码既牢固可靠又能快速响应变化的需求。</p><p>有这三大核心实践打下的基础，才谈得上运用敏捷思想的其他部分。持续交付确保软件始终处于可发布的状态，很多互联网团队能做到一天多次发布，靠的正是持续交付的威力。即便我们不需要如此频繁的发布，持续集成也能帮我们降低风险，并使我们做到根据业务需要随时安排发布，而不受技术的局限。有了可靠的技术根基，我们能够极大地压缩“从好点子到生产代码”的周期时间，从而更好地服务客户。这些技术实践也会增加软件的可靠性，减少耗费在 bug 上的时间。</p><p>这一切说起来似乎很简单，但实际做起来毫不容易。不管采用什么方法，软件开发都是一件复杂而微妙的事，涉及人与人之间、人与机器之间的复杂交互。我在这里描述的方法已经被证明可以应对这些复杂性，但——就跟其他所有方法一样——对使用者的实践和技能有要求。</p><h2 id="2-8-重构与性能"><a href="#2-8-重构与性能" class="headerlink" title="2.8 重构与性能"></a>2.8 重构与性能</h2><p>关于重构，有一个常被提出的问题：它对程序的性能将造成怎样的影响？为了让软件易于理解，我常会做出一些使程序运行变慢的修改。这是一个重要的问题。我并不赞成为了提高设计的纯洁性而忽视性能，把希望寄托于更快的硬件身上也绝非正道。已经有很多软件因为速度太慢而被用户拒绝，日益提高的机器速度也只不过略微放宽了速度方面的限制而已。但是，换个角度说，虽然重构可能使软件运行更慢，但它也使软件的性能优化更容易。除了对性能有严格要求的实时系统，其他任何情况下“编写快速软件”的秘密就是：先写出可调优的软件，然后调优它以求获得足够的速度。</p><p>我看过 3 种编写快速软件的方法。其中最严格的是时间预算法，这通常只用于性能要求极高的实时系统。如果使用这种方法，分解你的设计时就要做好预算，给每个组件预先分配一定资源，包括时间和空间占用。每个组件绝对不能超出自己的预算，就算拥有组件之间调度预配时间的机制也不行。这种方法高度重视性能，对于心律调节器一类的系统是必需的，因为在这样的系统中迟来的数据就是错误的数据。但对其他系统（例如我经常开发的企业信息系统）而言，如此追求高性能就有点儿过分了。</p><p>第二种方法是持续关注法。这种方法要求任何程序员在任何时间做任何事时，都要设法保持系统的高性能。这种方式很常见，感觉上很有吸引力，但通常不会起太大作用。任何修改如果是为了提高性能，通常会使程序难以维护，继而减缓开发速度。如果最终得到的软件的确更快了，那么这点损失尚有所值，可惜通常事与愿违，因为性能改善一旦被分散到程序各个角落，每次改善都只不过是从对程序行为的一个狭隘视角出发而已，而且常常伴随着对编译器、运行时环境和硬件行为的误解。</p><blockquote><p><strong>Tip</strong><br>劳而无获</p></blockquote><p>克莱斯勒综合薪资系统的支付过程太慢了。虽然我们的开发还没结束，这个问题却已经开始困扰我们，因为它已经拖累了测试速度。</p><p>Kent Beck、Martin Fowler 和我决定解决这个问题。等待大伙儿会合的时间里，凭着对这个系统的全盘了解，我开始推测：到底是什么让系统变慢了？我想到数种可能，然后和伙伴们谈了几种可能的修改方案。最后，我们就“如何让这个系统运行更快”，提出了一些真正的好点子。</p><p>然后，我们拿 Kent 的工具度量了系统性能。我一开始所想的可能性竟然全都不是问题肇因。我们发现：系统把一半时间用来创建“日期”实例（instance）。更有趣的是，所有这些实例都有相同的几个值。</p><p>于是我们观察日期对象的创建逻辑，发现有机会将它优化。这些日期对象在创建时都经过了一个字符串转换过程，然而这里并没有任何外部数据输入。之所以使用字符串转换方式，完全只是因为代码写起来简单。好，也许我们可以优化它。</p><p>然后，我们观察这些日期对象是如何被使用的。我们发现，很多日期对象都被用来产生“日期区间”实例——由一个起始日期和一个结束日期组成的对象。仔细追踪下去，我们发现绝大多数日期区间是空的！</p><p>处理日期区间时我们遵循这样一个规则：如果结束日期在起始日期之前，这个日期区间就该是空的。这是一条很好的规则，完全符合这个类的需要。采用此规则后不久，我们意识到，创建一个“起始日期在结束日期之后”的日期区间，仍然不算是清晰的代码，于是我们把这个行为提炼成一个工厂函数，由它专门创建“空的日期区间”。</p><p>我们做了上述修改，使代码更加清晰，也意外得到了一个惊喜：可以创建一个固定不变的“空日期区间”对象，并让上述调整后的工厂函数始终返回该对象，而不再每次都创建新对象。这一修改把系统速度提升了几乎一倍，足以让测试速度达到可接受的程度。这只花了我们大约五分钟。</p><p>我和团队成员（Kent 和 Martin 谢绝参加）认真推测过：我们了若指掌的这个程序中可能有什么错误？我们甚至凭空做了些改进设计，却没有先对系统的真实情况进行度量。</p><p>我们完全错了。除了一场很有趣的交谈，我们什么好事都没做。</p><p>教训是：哪怕你完全了解系统，也请实际度量它的性能，不要臆测。臆测会让你学到一些东西，但十有八九你是错的。</p><p>——Ron Jeffries</p><p>关于性能，一件很有趣的事情是：如果你对大多数程序进行分析，就会发现它把大半时间都耗费在一小半代码身上。如果你一视同仁地优化所有代码，90％的优化工作都是白费劲的，因为被你优化的代码大多很少被执行。你花时间做优化是为了让程序运行更快，但如果因为缺乏对程序的清楚认识而花费时间，那些时间就都被浪费掉了。</p><p>第三种性能提升法就是利用上述的 90%统计数据。采用这种方法时，我编写构造良好的程序，不对性能投以特别的关注，直至进入性能优化阶段——那通常是在开发后期。一旦进入该阶段，我再遵循特定的流程来调优程序性能。</p><p>在性能优化阶段，我首先应该用一个度量工具来监控程序的运行，让它告诉我程序中哪些地方大量消耗时间和空间。这样我就可以找出性能热点所在的一小段代码。然后我应该集中关注这些性能热点，并使用持续关注法中的优化手段来优化它们。由于把注意力都集中在热点上，较少的工作量便可显现较好的成果。即便如此，我还是必须保持谨慎。和重构一样，我会小幅度进行修改。每走一步都需要编译、测试，再次度量。如果没能提高性能，就应该撤销此次修改。我会继续这个“发现热点，去除热点”的过程，直到获得客户满意的性能为止。</p><p>一个构造良好的程序可从两方面帮助这一优化方式。首先，它让我有比较充裕的时间进行性能调整，因为有构造良好的代码在手，我能够更快速地添加功能，也就有更多时间用在性能问题上（准确的度量则保证我把这些时间投在恰当地点）。其次，面对构造良好的程序，我在进行性能分析时便有较细的粒度。度量工具会把我带入范围较小的代码段中，而性能的调整也比较容易些。由于代码更加清晰，因此我能够更好地理解自己的选择，更清楚哪种调整起关键作用。</p><p>我发现重构可以帮助我写出更快的软件。短期看来，重构的确可能使软件变慢，但它使优化阶段的软件性能调优更容易，最终还是会得到好的效果。</p><h2 id="2-9-重构起源何处"><a href="#2-9-重构起源何处" class="headerlink" title="2.9 重构起源何处"></a>2.9 重构起源何处</h2><p>我曾经努力想找出“重构”（refactoring）一词的真正起源，但最终失败了。优秀程序员肯定至少会花一些时间来清理自己的代码。这么做是因为，他们知道整洁的代码比杂乱无章的代码更容易修改，而且他们知道自己几乎无法一开始就写出整洁的代码。</p><p>重构不止如此。本书中我把重构看作整个软件开发过程的一个关键环节。最早认识重构重要性的两个人是 Ward Cunningham 和 Kent Beck，他们早在 20 世纪 80 年代就开始使用 Smalltalk，那是一个特别适合重构的环境。Smalltalk 是一个十分动态的环境，用它可以很快写出功能丰富的软件。Smalltalk 的“编译-链接-执行”周期非常短，因此很容易快速修改代码——要知道，当时很多编程环境做一次编译就需要整晚时间。它支持面向对象，也有强大的工具，最大限度地将修改的影响隐藏于定义良好的接口背后。Ward 和 Kent 努力探索出一套适合这类环境的软件开发过程（如今，Kent 把这种风格叫作极限编程）。他们意识到：重构对于提高生产力非常重要。从那时起他们就一直在工作中运用重构技术，在正式的软件项目中使用它，并不断精炼重构的过程。</p><p>Ward 和 Kent 的思想对 Smalltalk 社区产生了极大影响，重构概念也成为 Smalltalk 文化中的一个重要元素。Smalltalk 社区的另一位领袖是 Ralph Johnson，伊利诺伊大学厄巴纳-香槟分校教授，著名的 GoF[gof]之一。Ralph 最大的兴趣之一就是开发软件框架。他揭示了重构有助于灵活高效框架的开发。</p><p>Bill Opdyke 是 Ralph 的博士研究生，对框架也很感兴趣。他看到了重构的潜在价值，并看到重构应用于 Smalltalk 之外的其他语言的可能性。他的技术背景是电话交换系统的开发。在这种系统中，大量的复杂情况与日俱增，而且非常难以修改。Bill 的博士研究就是从工具构筑者的角度来看待重构。Bill 对 C++的框架开发中用得上的重构手法特别感兴趣。他也研究了极有必要的“语义保持的重构” （semantics-preserving refactoring），并阐明了如何证明这些重构是语义保持的，以及如何用工具实现重构。Bill 的博士论文[Opdyke]是重构领域中第一部丰硕的研究成果。</p><p>我还记得 1992 年 OOPSLA 大会上见到 Bill 的情景。我们坐在一间咖啡厅里，Bill 跟我谈起他的研究成果，我还记得自己当时的想法：“有趣，但并非真的那么重要。”唉，我完全错了。</p><p>John Brant 和 Don Roberts 将“重构工具”的构想发扬光大，开发了一个名为 Refactoring Browser （重构浏览器）的重构工具。这是第一个自动化的重构工具，多亏 Smalltalk 提供了适合重构的编程环境。</p><p>那么，我呢？我一直有清理代码的倾向，但从来没有想到这会如此重要。后来我和 Kent 一起做一个项目，看到他使用重构手法，也看到重构对开发效能和质量带来的影响。这份体验让我相信：重构是一门非常重要的技术。但是，在重构的学习和推广过程中我遇到了挫折，因为我拿不出任何一本书给程序员看，也没有任何一位专家打算写这样一本书。所以，在这些专家的帮助下，我写下了这本书的第 1 版。</p><p>幸运的是，重构的概念被行业广泛接受了。本书第 1 版销量不错，“重构”一词也走进了大多数程序员的词汇库。更多的重构工具涌现出来，尤其是在 Java 世界里。重构的流行也带来了负面效应：很多人随意地使用“重构”这个词，而他们真正做的却是不严谨的结构调整。尽管如此，重构终归成了一项主流的软件开发实践。</p><h2 id="2-10-自动化重构"><a href="#2-10-自动化重构" class="headerlink" title="2.10 自动化重构"></a>2.10 自动化重构</h2><p>过去 10 年中，重构领域最大的变化可能就是出现了一批支持自动化重构的工具。如果我想给一个 Java 的方法改名，在 IntelliJ IDEA 或者 Eclipse 这样的开发环境中，我只需要从菜单里点选对应的选项，工具会帮我完成整个重构过程，而且我通常都可以相信，工具完成的重构是可靠的，所以用不着运行测试套件。</p><p>第一个自动化重构工具是 Smalltalk 的 Refactoring Browser，由 John Brandt 和 Don Roberts 开发。在 21 世纪初，Java 世界的自动化重构工具如雨后春笋般涌现。在 JetBrains 的 IntelliJ IDEA 集成开发环境（IDE）中，自动化重构是最亮眼的特性之一。IBM 也紧随其后，在 VisualAge 的 Java 版中也提供了重构工具。VisualAge 的影响力有限，不过其中很多能力后来被 Eclipse 继承，包括对重构的支持。</p><p>重构也进入了 C#世界，起初是通过 JetBrains 的 Resharper，这是一个 Visual Studio 插件。后来 Visual Studio 团队直接在 IDE 里提供了一些重构能力。</p><p>如今的编辑器和开发工具中常能找到一些对重构的支持，不过真实的重构能力各有高低。重构能力的差异既有工具的原因，也受限于不同语言对自动化重构的支持程度。在这里，我不打算分析各种工具的能力，不过谈谈重构工具背后的原则还是有点儿意思的。</p><p>一种粗糙的自动化重构方式是文本操作，比如用查找&#x2F;替换的方式给函数改名，或者完成提炼变量（119）所需的简单结构调整。这种方法太粗糙了，做完之后必须重新运行测试，否则不能信任。但这可以是一个便捷的起步。在用 Emacs 编程时，没有那些更完善的重构支持，我也会用类似的文本操作宏来加速重构。</p><p>要支持体面的重构，工具只操作代码文本是不行的，必须操作代码的语法树，这样才能更可靠地保持代码行为。所以，今天的大多数重构功能都依附于强大的 IDE，因为这些 IDE 原本就在语法树上实现了代码导航、静态检查等功能，自然也可以用于重构。不仅能处理文本，还能处理语法树，这是 IDE 相比于文本编辑器更先进的地方。</p><p>重构工具不仅需要理解和修改语法树，还要知道如何把修改后的代码写回编辑器视图。总而言之，实现一个体面的自动化重构手法，是一个很有挑战的编程任务。尽管我一直开心地使用重构工具，对它们背后的实现却知之甚少。</p><p>在静态类型语言中，很多重构手法会更加安全。假设我想做一次简单的函数改名（124）：在 Salesman 类和 Server 类中都有一个叫作 addClient 的函数，当然两者各有其用途。我想对 Salesman 中的 addClient 函数改名，Server 类中的函数则保持不变。如果不是静态类型，工具很难识别调用 addClient 的地方到底是在使用哪个类的函数。Smalltalk 的 Refactoring Browser 会列出所有调用点，我需要手工决定修改哪些调用点。这个重构是不安全的，我必须重新运行所有测试。这样的工具仍然有用，但在 Java 中的函数改名（124）重构则可以是完全安全、完全自动的，因为在静态类型的帮助下，工具可以识别函数所属的类，所以它只会修改应该修改的那些函数调用点，对此我可以完全放心。</p><p>一些重构工具走得更远。如果我给一个变量改名，工具会提醒我修改使用了旧名字的注释。如果我使用提炼函数（106），工具会找出与新函数体重复的代码片段，建议代之以对新函数的调用。在编程时可以使用如此强大的重构功能，这就是为什么我们要使用一个体面的 IDE，而不是固执于熟悉的文本编辑器。我个人很喜欢用 Emacs，但在使用 Java 时，我更愿意用 IntelliJ IDEA 或者 Eclipse，很大程度上就是为了获得重构支持。</p><p>尽管这些强大的重构工具有着魔法般的能力，可以安全地重构代码，但还是会有闪失出现。通过反射进行的调用（例如 Java 中的 Method.invoke）会迷惑不够成熟的重构工具，但比较成熟的工具则可以很好地应对。所以，即便是最安全的重构，也应该经常运行测试套件，以确保没有什么东西在不经意间被破坏。我经常会间杂进行自动重构和手动重构，所以运行测试的频度是足够的。</p><p>能借助语法树来分析和重构程序代码，这是 IDE 与普通文本编辑器相比具有的一大优势。但很多程序员又喜欢用得顺手的文本编辑器的灵活性，希望鱼与熊掌兼得。语言服务器（Language Server）是一种正在引起关注的新技术：用软件生成语法树，给文本编辑器提供 API。语言服务器可以支持多种文本编辑器，并且为强大的代码分析和重构操作提供了命令。</p><h1 id="3-代码的坏味道"><a href="#3-代码的坏味道" class="headerlink" title="3.代码的坏味道"></a>3.代码的坏味道</h1><p>——Kent Beck 和 Martin Fowler</p><p>“如果尿布臭了，就换掉它。”</p><p>——语出 Beck 奶奶，论保持小孩清洁的哲学</p><p>现在，对于重构如何运作，你已经有了相当好的理解。但是知道“如何”不代表知道“何时”。决定何时重构及何时停止和知道重构机制如何运转一样重要。</p><p>难题来了！解释“如何删除一个实例变量”或“如何产生一个继承体系”很容易，因为这些都是很简单的事情，但要解释“该在什么时候做这些动作”就没那么顺理成章了。除了露几手含混的编程美学（说实话，这就是咱们这些顾问常做的事），我还希望让某些东西更具说服力一些。</p><p>撰写本书的第 1 版时，我正在为这个微妙的问题大伤脑筋。去苏黎世拜访 Kent Beck 的时候，也许是因为受到刚出生的女儿的气味影响吧，他提出用味道来形容重构的时机。</p><p>“味道，”你可能会说，“真的比含混的美学理论要好吗？”好吧，是的。我们看过很多很多代码，它们所属的项目从大获成功到奄奄一息都有。观察这些代码时，我们学会了从中找寻某些特定结构，这些结构指出（有时甚至就像尖叫呼喊）重构的可能性。（本章主语换成“我们”，是为了反映一个事实：Kent 和我共同撰写本章。你应该可以看出我俩的文笔差异——插科打诨的部分是我写的，其余都是他写的。）</p><p>我们并不试图给你一个何时必须重构的精确衡量标准。从我们的经验看来，没有任何量度规矩比得上见识广博者的直觉。我们只会告诉你一些迹象，它会指出“这里有一个可以用重构解决的问题”。你必须培养自己的判断力，学会判断一个类内有多少实例变量算是太大、一个函数内有多少行代码才算太长。</p><p>如果你无法确定该采用哪一种重构手法，请阅读本章内容和书后附的“重构列表”来寻找灵感。你可以阅读本章或快速浏览书后附的“坏味道与重构手法速查表”来判断自己闻到的是什么味道，然后再看看我们所建议的重构手法能否帮到你。也许这里所列的“坏味道条款”和你所检测的不尽相符，但愿它们能够为你指引正确方向。</p><h2 id="3-1-神秘命名（Mysterious-Name）"><a href="#3-1-神秘命名（Mysterious-Name）" class="headerlink" title="3.1 神秘命名（Mysterious Name）"></a>3.1 神秘命名（Mysterious Name）</h2><p>读侦探小说时，透过一些神秘的文字猜测故事情节是一种很棒的体验；但如果是在阅读代码，这样的体验就不怎么好了。我们也许会幻想自己是《王牌大贱谍》中的国际特工 1，但我们写下的代码应该直观明了。整洁代码最重要的一环就是好的名字，所以我们会深思熟虑如何给函数、模块、变量和类命名，使它们能清晰地表明自己的功能和用法。</p><p>然而，很遗憾，命名是编程中最难的两件事之一[mf-2h]。正因为如此，改名可能是最常用的重构手法，包括改变函数声明（124）（用于给函数改名）、变量改名（137）、字段改名（244）等。很多人经常不愿意给程序元素改名，觉得不值得费这个劲，但好的名字能节省未来用在猜谜上的大把时间。</p><p>改名不仅仅是修改名字而已。如果你想不出一个好名字，说明背后很可能潜藏着更深的设计问题。为一个恼人的名字所付出的纠结，常常能推动我们对代码进行精简。</p><p>1《王牌大贱谍》（International Man of Mystery）是 1997 年杰伊·罗奇执导的一部喜剧谍战片。——译者注</p><h2 id="3-2-重复代码（Duplicated-Code）"><a href="#3-2-重复代码（Duplicated-Code）" class="headerlink" title="3.2 重复代码（Duplicated Code）"></a>3.2 重复代码（Duplicated Code）</h2><p>如果你在一个以上的地点看到相同的代码结构，那么可以肯定：设法将它们合而为一，程序会变得更好。一旦有重复代码存在，阅读这些重复的代码时你就必须加倍仔细，留意其间细微的差异。如果要修改重复代码，你必须找出所有的副本来修改。</p><p>最单纯的重复代码就是“同一个类的两个函数含有相同的表达式”。这时候你需要做的就是采用提炼函数（106）提炼出重复的代码，然后让这两个地点都调用被提炼出来的那一段代码。如果重复代码只是相似而不是完全相同，请首先尝试用移动语句（223）重组代码顺序，把相似的部分放在一起以便提炼。如果重复的代码段位于同一个超类的不同子类中，可以使用函数上移（350）来避免在两个子类之间互相调用。</p><h2 id="3-3-过长函数（Long-Function）"><a href="#3-3-过长函数（Long-Function）" class="headerlink" title="3.3 过长函数（Long Function）"></a>3.3 过长函数（Long Function）</h2><p>据我们的经验，活得最长、最好的程序，其中的函数都比较短。初次接触到这种代码库的程序员常常会觉得“计算都没有发生”——程序里满是无穷无尽的委托调用。但和这样的程序共处几年之后，你就会明白这些小函数的价值所在。间接性带来的好处——更好的阐释力、更易于分享、更多的选择——都是由小函数来支持的。</p><p>早在编程的洪荒年代，程序员们就已认识到：函数越长，就越难理解。在早期的编程语言中，子程序调用需要额外开销，这使得人们不太乐意使用小函数。现代编程语言几乎已经完全免除了进程内的函数调用开销。固然，小函数也会给代码的阅读者带来一些负担，因为你必须经常切换上下文，才能看明白函数在做什么。但现代的开发环境让你可以在函数的调用处与声明处之间快速跳转，或是同时看到这两处，让你根本不用来回跳转。不过说到底，让小函数易于理解的关键还是在于良好的命名。如果你能给函数起个好名字，阅读代码的人就可以通过名字了解函数的作用，根本不必去看其中写了些什么。</p><p>最终的效果是：你应该更积极地分解函数。我们遵循这样一条原则：每当感觉需要以注释来说明点什么的时候，我们就把需要说明的东西写进一个独立函数中，并以其用途（而非实现手法）命名。我们可以对一组甚至短短一行代码做这件事。哪怕替换后的函数调用动作比函数自身还长，只要函数名称能够解释其用途，我们也该毫不犹豫地那么做。关键不在于函数的长度，而在于函数“做什么”和“如何做”之间的语义距离。</p><p>百分之九十九的场合里，要把函数变短，只需使用提炼函数（106）。找到函数中适合集中在一起的部分，将它们提炼出来形成一个新函数。</p><p>如果函数内有大量的参数和临时变量，它们会对你的函数提炼形成阻碍。如果你尝试运用提炼函数（106），最终就会把许多参数传递给被提炼出来的新函数，导致可读性几乎没有任何提升。此时，你可以经常运用以查询取代临时变量（178）来消除这些临时元素。引入参数对象（140）和保持对象完整（319）则可以将过长的参数列表变得更简洁一些。</p><p>如果你已经这么做了，仍然有太多临时变量和参数，那就应该使出我们的杀手锏——以命令取代函数（337）。</p><p>如何确定该提炼哪一段代码呢？一个很好的技巧是：寻找注释。它们通常能指出代码用途和实现手法之间的语义距离。如果代码前方有一行注释，就是在提醒你：可以将这段代码替换成一个函数，而且可以在注释的基础上给这个函数命名。就算只有一行代码，如果它需要以注释来说明，那也值得将它提炼到独立函数中去。</p><p>条件表达式和循环常常也是提炼的信号。你可以使用分解条件表达式（260）处理条件表达式。对于庞大的 switch 语句，其中的每个分支都应该通过提炼函数（106）变成独立的函数调用。如果有多个 switch 语句基于同一个条件进行分支选择，就应该使用以多态取代条件表达式（272）。</p><p>至于循环，你应该将循环和循环内的代码提炼到一个独立的函数中。如果你发现提炼出的循环很难命名，可能是因为其中做了几件不同的事。如果是这种情况，请勇敢地使用拆分循环（227）将其拆分成各自独立的任务。</p><h2 id="3-4-过长参数列表（Long-Parameter-List）"><a href="#3-4-过长参数列表（Long-Parameter-List）" class="headerlink" title="3.4 过长参数列表（Long Parameter List）"></a>3.4 过长参数列表（Long Parameter List）</h2><p>刚开始学习编程的时候，老师教我们：把函数所需的所有东西都以参数的形式传递进去。这可以理解，因为除此之外就只能选择全局数据，而全局数据很快就会变成邪恶的东西。但过长的参数列表本身也经常令人迷惑。</p><p>如果可以向某个参数发起查询而获得另一个参数的值，那么就可以使用以查询取代参数（324）去掉这第二个参数。如果你发现自己正在从现有的数据结构中抽出很多数据项，就可以考虑使用保持对象完整（319）手法，直接传入原来的数据结构。如果有几项参数总是同时出现，可以用引入参数对象（140）将其合并成一个对象。如果某个参数被用作区分函数行为的标记（flag），可以使用移除标记参数（314）。</p><p>使用类可以有效地缩短参数列表。如果多个函数有同样的几个参数，引入一个类就尤为有意义。你可以使用函数组合成类（144），将这些共同的参数变成这个类的字段。如果戴上函数式编程的帽子，我们会说，这个重构过程创造了一组部分应用函数（partially applied function）。</p><h2 id="3-5-全局数据（Global-Data）"><a href="#3-5-全局数据（Global-Data）" class="headerlink" title="3.5 全局数据（Global Data）"></a>3.5 全局数据（Global Data）</h2><p>刚开始学软件开发时，我们就听说过关于全局数据的惊悚故事——它们是如何被来自地狱第四层的恶魔发明出来，胆敢使用它们的程序员如今在何处安息。就算这些烈焰与硫黄的故事不那么可信，全局数据仍然是最刺鼻的坏味道之一。全局数据的问题在于，从代码库的任何一个角落都可以修改它，而且没有任何机制可以探测出到底哪段代码做出了修改。一次又一次，全局数据造成了那些诡异的 bug，而问题的根源却在遥远的别处，想要找到出错的代码难于登天。全局数据最显而易见的形式就是全局变量，但类变量和单例（singleton）也有这样的问题。</p><p>首要的防御手段是封装变量（132），每当我们看到可能被各处的代码污染的数据，这总是我们应对的第一招。你把全局数据用一个函数包装起来，至少你就能看见修改它的地方，并开始控制对它的访问。随后，最好将这个函数（及其封装的数据）搬移到一个类或模块中，只允许模块内的代码使用它，从而尽量控制其作用域。</p><p>可以被修改的全局数据尤其可憎。如果能保证在程序启动之后就不再修改，这样的全局数据还算相对安全，不过得有编程语言提供这样的保证才行。</p><p>全局数据印证了帕拉塞尔斯的格言：良药与毒药的区别在于剂量。有少量的全局数据或许无妨，但数量越多，处理的难度就会指数上升。即便只是少量的数据，我们也愿意将它封装起来，这是在软件演进过程中应对变化的关键所在。</p><h2 id="3-6-可变数据（Mutable-Data）"><a href="#3-6-可变数据（Mutable-Data）" class="headerlink" title="3.6 可变数据（Mutable Data）"></a>3.6 可变数据（Mutable Data）</h2><p>对数据的修改经常导致出乎意料的结果和难以发现的 bug。我在一处更新数据，却没有意识到软件中的另一处期望着完全不同的数据，于是一个功能失效了——如果故障只在很罕见的情况下发生，要找出故障原因就会更加困难。因此，有一整个软件开发流派——函数式编程——完全建立在“数据永不改变”的概念基础上：如果要更新一个数据结构，就返回一份新的数据副本，旧的数据仍保持不变。</p><p>不过这样的编程语言仍然相对小众，大多数程序员使用的编程语言还是允许修改变量值的。即便如此，我们也不应该忽视不可变性带来的优势——仍然有很多办法可以用于约束对数据的更新，降低其风险。</p><p>可以用封装变量（132）来确保所有数据更新操作都通过很少几个函数来进行，使其更容易监控和演进。如果一个变量在不同时候被用于存储不同的东西，可以使用拆分变量（240）将其拆分为各自不同用途的变量，从而避免危险的更新操作。使用移动语句（223）和提炼函数（106）尽量把逻辑从处理更新操作的代码中搬移出来，将没有副作用的代码与执行数据更新操作的代码分开。设计 API 时，可以使用将查询函数和修改函数分离（306）确保调用者不会调到有副作用的代码，除非他们真的需要更新数据。我们还乐于尽早使用移除设值函数（331）——有时只是把设值函数的使用者找出来看看，就能帮我们发现缩小变量作用域的机会。</p><p>如果可变数据的值能在其他地方计算出来，这就是一个特别刺鼻的坏味道。它不仅会造成困扰、bug 和加班，而且毫无必要。消除这种坏味道的办法很简单，使用以查询取代派生变量（248）即可。</p><p>如果变量作用域只有几行代码，即使其中的数据可变，也不是什么大问题；但随着变量作用域的扩展，风险也随之增大。可以用函数组合成类（144）或者函数组合成变换（149）来限制需要对变量进行修改的代码量。如果一个变量在其内部结构中包含了数据，通常最好不要直接修改其中的数据，而是用将引用对象改为值对象（252）令其直接替换整个数据结构。</p><h2 id="3-7-发散式变化（Divergent-Change）"><a href="#3-7-发散式变化（Divergent-Change）" class="headerlink" title="3.7 发散式变化（Divergent Change）"></a>3.7 发散式变化（Divergent Change）</h2><p>我们希望软件能够更容易被修改——毕竟软件本来就该是“软”的。一旦需要修改，我们希望能够跳到系统的某一点，只在该处做修改。如果不能做到这一点，你就嗅出两种紧密相关的刺鼻味道中的一种了。</p><p>如果某个模块经常因为不同的原因在不同的方向上发生变化，发散式变化就出现了。当你看着一个类说：“呃，如果新加入一个数据库，我必须修改这 3 个函数；如果新出现一种金融工具，我必须修改这 4 个函数。”这就是发散式变化的征兆。数据库交互和金融逻辑处理是两个不同的上下文，将它们分别搬移到各自独立的模块中，能让程序变得更好：每当要对某个上下文做修改时，我们只需要理解这个上下文，而不必操心另一个。“每次只关心一个上下文”这一点一直很重要，在如今这个信息爆炸、脑容量不够用的年代就愈发紧要。当然，往往只有在加入新数据库或新金融工具后，你才能发现这个坏味道。在程序刚开发出来还在随着软件系统的能力不断演进时，上下文边界通常不是那么清晰。</p><p>如果发生变化的两个方向自然地形成了先后次序（比如说，先从数据库取出数据，再对其进行金融逻辑处理），就可以用拆分阶段（154）将两者分开，两者之间通过一个清晰的数据结构进行沟通。如果两个方向之间有更多的来回调用，就应该先创建适当的模块，然后用搬移函数（198）把处理逻辑分开。如果函数内部混合了两类处理逻辑，应该先用提炼函数（106）将其分开，然后再做搬移。如果模块是以类的形式定义的，就可以用提炼类（182）来做拆分。</p><h2 id="3-8-霰弹式修改（Shotgun-Surgery）"><a href="#3-8-霰弹式修改（Shotgun-Surgery）" class="headerlink" title="3.8 霰弹式修改（Shotgun Surgery）"></a>3.8 霰弹式修改（Shotgun Surgery）</h2><p>霰弹式修改类似于发散式变化，但又恰恰相反。如果每遇到某种变化，你都必须在许多不同的类内做出许多小修改，你所面临的坏味道就是霰弹式修改。如果需要修改的代码散布四处，你不但很难找到它们，也很容易错过某个重要的修改。</p><p>这种情况下，你应该使用搬移函数（198）和搬移字段（207）把所有需要修改的代码放进同一个模块里。如果有很多函数都在操作相似的数据，可以使用函数组合成类（144）。如果有些函数的功能是转化或者充实数据结构，可以使用函数组合成变换（149）。如果一些函数的输出可以组合后提供给一段专门使用这些计算结果的逻辑，这种时候常常用得上拆分阶段（154）。</p><p>面对霰弹式修改，一个常用的策略就是使用与内联（inline）相关的重构——如内联函数（115）或是内联类（186）——把本不该分散的逻辑拽回一处。完成内联之后，你可能会闻到过长函数或者过大的类的味道，不过你总可以用与提炼相关的重构手法将其拆解成更合理的小块。即便如此钟爱小型的函数和类，我们也并不担心在重构的过程中暂时创建一些较大的程序单元。</p><h2 id="3-9-依恋情结（Feature-Envy）"><a href="#3-9-依恋情结（Feature-Envy）" class="headerlink" title="3.9 依恋情结（Feature Envy）"></a>3.9 依恋情结（Feature Envy）</h2><p>所谓模块化，就是力求将代码分出区域，最大化区域内部的交互、最小化跨区域的交互。但有时你会发现，一个函数跟另一个模块中的函数或者数据交流格外频繁，远胜于在自己所处模块内部的交流，这就是依恋情结的典型情况。无数次经验里，我们看到某个函数为了计算某个值，从另一个对象那儿调用几乎半打的取值函数。疗法显而易见：这个函数想跟这些数据待在一起，那就使用搬移函数（198）把它移过去。有时候，函数中只有一部分受这种依恋之苦，这时候应该使用提炼函数（106）把这一部分提炼到独立的函数中，再使用搬移函数（198）带它去它的梦想家园。</p><p>当然，并非所有情况都这么简单。一个函数往往会用到几个模块的功能，那么它究竟该被置于何处呢？我们的原则是：判断哪个模块拥有的此函数使用的数据最多，然后就把这个函数和那些数据摆在一起。如果先以提炼函数（106）将这个函数分解为数个较小的函数并分别置放于不同地点，上述步骤也就比较容易完成了。</p><p>有几个复杂精巧的模式破坏了这条规则。说起这个话题，GoF[gof]的策略（Strategy）模式和访问者（Visitor）模式立刻跳入我的脑海，Kent Beck 的 Self Delegation 模式[Beck SBPP]也在此列。使用这些模式是为了对抗发散式变化这一坏味道。最根本的原则是：将总是一起变化的东西放在一块儿。数据和引用这些数据的行为总是一起变化的，但也有例外。如果例外出现，我们就搬移那些行为，保持变化只在一地发生。策略模式和和访问者模式使你得以轻松修改函数的行为，因为它们将少量需被覆写的行为隔离开来——当然也付出了“多一层间接性”的代价。</p><h2 id="3-10-数据泥团（Data-Clumps）"><a href="#3-10-数据泥团（Data-Clumps）" class="headerlink" title="3.10 数据泥团（Data Clumps）"></a>3.10 数据泥团（Data Clumps）</h2><p>数据项就像小孩子，喜欢成群结队地待在一块儿。你常常可以在很多地方看到相同的三四项数据：两个类中相同的字段、许多函数签名中相同的参数。这些总是绑在一起出现的数据真应该拥有属于它们自己的对象。首先请找出这些数据以字段形式出现的地方，运用提炼类（182）将它们提炼到一个独立对象中。然后将注意力转移到函数签名上，运用引入参数对象（140）或保持对象完整（319）为它瘦身。这么做的直接好处是可以将很多参数列表缩短，简化函数调用。是的，不必在意数据泥团只用上新对象的一部分字段，只要以新对象取代两个（或更多）字段，就值得这么做。</p><p>一个好的评判办法是：删掉众多数据中的一项。如果这么做，其他数据有没有因而失去意义？如果它们不再有意义，这就是一个明确信号：你应该为它们产生一个新对象。</p><p>我们在这里提倡新建一个类，而不是简单的记录结构，因为一旦拥有新的类，你就有机会让程序散发出一种芳香。得到新的类以后，你就可以着手寻找“依恋情结”，这可以帮你指出能够移至新类中的种种行为。这是一种强大的动力：有用的类被创建出来，大量的重复被消除，后续开发得以加速，原来的数据泥团终于在它们的小社会中充分发挥价值。</p><h2 id="3-11-基本类型偏执（Primitive-Obsession）"><a href="#3-11-基本类型偏执（Primitive-Obsession）" class="headerlink" title="3.11 基本类型偏执（Primitive Obsession）"></a>3.11 基本类型偏执（Primitive Obsession）</h2><p>大多数编程环境都大量使用基本类型，即整数、浮点数和字符串等。一些库会引入一些小对象，如日期。但我们发现一个很有趣的现象：很多程序员不愿意创建对自己的问题域有用的基本类型，如钱、坐标、范围等。于是，我们看到了把钱当作普通数字来计算的情况、计算物理量时无视单位（如把英寸与毫米相加）的情况以及大量类似 if (a &lt; upper &amp;&amp; a &gt; lower)这样的代码。</p><p>字符串是这种坏味道的最佳培养皿，比如，电话号码不只是一串字符。一个体面的类型，至少能包含一致的显示逻辑，在用户界面上需要显示时可以使用。“用字符串来代表类似这样的数据”是如此常见的臭味，以至于人们给这类变量专门起了一个名字，叫它们“类字符串类型”（stringly typed）变量。</p><p>你可以运用以对象取代基本类型（174）将原本单独存在的数据值替换为对象，从而走出传统的洞窟，进入炙手可热的对象世界。如果想要替换的数据值是控制条件行为的类型码，则可以运用以子类取代类型码（362）加上以多态取代条件表达式（272）的组合将它换掉。</p><p>如果你有一组总是同时出现的基本类型数据，这就是数据泥团的征兆，应该运用提炼类（182）和引入参数对象（140）来处理。</p><h2 id="3-12-重复的-switch-（Repeated-Switches）"><a href="#3-12-重复的-switch-（Repeated-Switches）" class="headerlink" title="3.12 重复的 switch （Repeated Switches）"></a>3.12 重复的 switch （Repeated Switches）</h2><p>如果你跟真正的面向对象布道者交谈，他们很快就会谈到 switch 语句的邪恶。在他们看来，任何 switch 语句都应该用以多态取代条件表达式（272）消除掉。我们甚至还听过这样的观点：所有条件逻辑都应该用多态取代，绝大多数 if 语句都应该被扫进历史的垃圾桶。</p><p>即便在不知天高地厚的青年时代，我们也从未无条件地反对条件语句。在本书第 1 版中，这种坏味道被称为“switch 语句”（Switch Statements），那是因为在 20 世纪 90 年代末期，程序员们太过于忽视多态的价值，我们希望矫枉过正。</p><p>如今的程序员已经更多地使用多态，switch 语句也不再像 15 年前那样有害无益，很多语言支持更复杂的 switch 语句，而不只是根据基本类型值来做条件判断。因此，我们现在更关注重复的 switch：在不同的地方反复使用同样的 switch 逻辑（可能是以 switch&#x2F;case 语句的形式，也可能是以连续的 if&#x2F;else 语句的形式）。重复的 switch 的问题在于：每当你想增加一个选择分支时，必须找到所有的 switch，并逐一更新。多态给了我们对抗这种黑暗力量的武器，使我们得到更优雅的代码库。</p><h2 id="3-13-循环语句（Loops）"><a href="#3-13-循环语句（Loops）" class="headerlink" title="3.13 循环语句（Loops）"></a>3.13 循环语句（Loops）</h2><p>从最早的编程语言开始，循环就一直是程序设计的核心要素。但我们感觉如今循环已经有点儿过时，就像喇叭裤和植绒壁纸那样。其实在撰写本书第 1 版的时候，我们就已经开始鄙视循环语句，但和当时的大多数编程语言一样，当时的 Java 还没有提供更好的替代品。如今，函数作为一等公民已经得到了广泛的支持，因此我们可以使用以管道取代循环（231）来让这些老古董退休。我们发现，管道操作（如 filter 和 map）可以帮助我们更快地看清被处理的元素以及处理它们的动作。</p><h2 id="3-14-冗赘的元素（Lazy-Element）"><a href="#3-14-冗赘的元素（Lazy-Element）" class="headerlink" title="3.14 冗赘的元素（Lazy Element）"></a>3.14 冗赘的元素（Lazy Element）</h2><p>程序元素（如类和函数）能给代码增加结构，从而支持变化、促进复用或者哪怕只是提供更好的名字也好，但有时我们真的不需要这层额外的结构。可能有这样一个函数，它的名字就跟实现代码看起来一模一样；也可能有这样一个类，根本就是一个简单的函数。这可能是因为，起初在编写这个函数时，程序员也许期望它将来有一天会变大、变复杂，但那一天从未到来；也可能是因为，这个类原本是有用的，但随着重构的进行越变越小，最后只剩了一个函数。不论上述哪一种原因，请让这样的程序元素庄严赴义吧。通常你只需要使用内联函数（115）或是内联类（186）。如果这个类处于一个继承体系中，可以使用折叠继承体系（380）。</p><h2 id="3-15-夸夸其谈通用性（Speculative-Generality）"><a href="#3-15-夸夸其谈通用性（Speculative-Generality）" class="headerlink" title="3.15 夸夸其谈通用性（Speculative Generality）"></a>3.15 夸夸其谈通用性（Speculative Generality）</h2><p>这个令我们十分敏感的坏味道，命名者是 Brian Foote。当有人说“噢，我想我们总有一天需要做这事”，并因而企图以各式各样的钩子和特殊情况来处理一些非必要的事情，这种坏味道就出现了。这么做的结果往往造成系统更难理解和维护。如果所有装置都会被用到，就值得那么做；如果用不到，就不值得。用不上的装置只会挡你的路，所以，把它搬开吧。</p><p>如果你的某个抽象类其实没有太大作用，请运用折叠继承体系（380）。不必要的委托可运用内联函数（115）和内联类（186）除掉。如果函数的某些参数未被用上，可以用改变函数声明（124）去掉这些参数。如果有并非真正需要、只是为不知远在何处的将来而塞进去的参数，也应该用改变函数声明（124）去掉。</p><p>如果函数或类的唯一用户是测试用例，这就飘出了坏味道“夸夸其谈通用性”。如果你发现这样的函数或类，可以先删掉测试用例，然后使用移除死代码（237）。</p><h2 id="3-16-临时字段（Temporary-Field）"><a href="#3-16-临时字段（Temporary-Field）" class="headerlink" title="3.16 临时字段（Temporary Field）"></a>3.16 临时字段（Temporary Field）</h2><p>有时你会看到这样的类：其内部某个字段仅为某种特定情况而设。这样的代码让人不易理解，因为你通常认为对象在所有时候都需要它的所有字段。在字段未被使用的情况下猜测当初设置它的目的，会让你发疯。</p><p>请使用提炼类（182）给这个可怜的孤儿创造一个家，然后用搬移函数（198）把所有和这些字段相关的代码都放进这个新家。也许你还可以使用引入特例（289）在“变量不合法”的情况下创建一个替代对象，从而避免写出条件式代码。</p><h2 id="3-17-过长的消息链（Message-Chains）"><a href="#3-17-过长的消息链（Message-Chains）" class="headerlink" title="3.17 过长的消息链（Message Chains）"></a>3.17 过长的消息链（Message Chains）</h2><p>如果你看到用户向一个对象请求另一个对象，然后再向后者请求另一个对象，然后再请求另一个对象……这就是消息链。在实际代码中你看到的可能是一长串取值函数或一长串临时变量。采取这种方式，意味客户端代码将与查找过程中的导航结构紧密耦合。一旦对象间的关系发生任何变化，客户端就不得不做出相应修改。</p><p>这时候应该使用隐藏委托关系（189）。你可以在消息链的不同位置采用这种重构手法。理论上，你可以重构消息链上的所有对象，但这么做就会把所有中间对象都变成“中间人”。通常更好的选择是：先观察消息链最终得到的对象是用来干什么的，看看能否以提炼函数（106）把使用该对象的代码提炼到一个独立的函数中，再运用搬移函数（198）把这个函数推入消息链。如果还有许多客户端代码需要访问链上的其他对象，同样添加一个函数来完成此事。</p><p>有些人把任何函数链都视为坏东西，我们不这样想。我们的冷静镇定是出了名的，起码在这件事上是这样的。</p><h2 id="3-18-中间人（Middle-Man）"><a href="#3-18-中间人（Middle-Man）" class="headerlink" title="3.18 中间人（Middle Man）"></a>3.18 中间人（Middle Man）</h2><p>对象的基本特征之一就是封装——对外部世界隐藏其内部细节。封装往往伴随着委托。比如，你问主管是否有时间参加一个会议，他就把这个消息“委托”给他的记事簿，然后才能回答你。很好，你没必要知道这位主管到底使用传统记事簿还是使用电子记事簿抑或是秘书来记录自己的约会。</p><p>但是人们可能过度运用委托。你也许会看到某个类的接口有一半的函数都委托给其他类，这样就是过度运用。这时应该使用移除中间人（192），直接和真正负责的对象打交道。如果这样“不干实事”的函数只有少数几个，可以运用内联函数（115）把它们放进调用端。如果这些中间人还有其他行为，可以运用以委托取代超类（399）或者以委托取代子类（381）把它变成真正的对象，这样你既可以扩展原对象的行为，又不必负担那么多的委托动作。</p><h2 id="3-19-内幕交易（Insider-Trading）"><a href="#3-19-内幕交易（Insider-Trading）" class="headerlink" title="3.19 内幕交易（Insider Trading）"></a>3.19 内幕交易（Insider Trading）</h2><p>软件开发者喜欢在模块之间建起高墙，极其反感在模块之间大量交换数据，因为这会增加模块间的耦合。在实际情况里，一定的数据交换不可避免，但我们必须尽量减少这种情况，并把这种交换都放到明面上来。</p><p>如果两个模块总是在咖啡机旁边窃窃私语，就应该用搬移函数（198）和搬移字段（207）减少它们的私下交流。如果两个模块有共同的兴趣，可以尝试再新建一个模块，把这些共用的数据放在一个管理良好的地方；或者用隐藏委托关系（189），把另一个模块变成两者的中介。</p><p>继承常会造成密谋，因为子类对超类的了解总是超过后者的主观愿望。如果你觉得该让这个孩子独立生活了，请运用以委托取代子类（381）或以委托取代超类（399）让它离开继承体系。</p><h2 id="3-20-过大的类（Large-Class）"><a href="#3-20-过大的类（Large-Class）" class="headerlink" title="3.20 过大的类（Large Class）"></a>3.20 过大的类（Large Class）</h2><p>如果想利用单个类做太多事情，其内往往就会出现太多字段。一旦如此，重复代码也就接踵而至了。</p><p>你可以运用提炼类（182）将几个变量一起提炼至新类内。提炼时应该选择类内彼此相关的变量，将它们放在一起。例如，depositAmount 和 depositCurrency 可能应该隶属同一个类。通常，如果类内的数个变量有着相同的前缀或后缀，这就意味着有机会把它们提炼到某个组件内。如果这个组件适合作为一个子类，你会发现提炼超类（375）或者以子类取代类型码（362）（其实就是提炼子类）往往比较简单。</p><p>有时候类并非在所有时刻都使用所有字段。若果真如此，你或许可以进行多次提炼。</p><p>和“太多实例变量”一样，类内如果有太多代码，也是代码重复、混乱并最终走向死亡的源头。最简单的解决方案（还记得吗，我们喜欢简单的解决方案）是把多余的东西消弭于类内部。如果有 5 个“百行函数”，它们之中很多代码都相同，那么或许你可以把它们变成 5 个“十行函数”和 10 个提炼出来的“双行函数”。</p><p>观察一个大类的使用者，经常能找到如何拆分类的线索。看看使用者是否只用到了这个类所有功能的一个子集，每个这样的子集都可能拆分成一个独立的类。一旦识别出一个合适的功能子集，就试用提炼类（182）、提炼超类（375）或是以子类取代类型码（362）将其拆分出来。</p><h2 id="3-21-异曲同工的类（Alternative-Classes-with-Different-Interfaces）"><a href="#3-21-异曲同工的类（Alternative-Classes-with-Different-Interfaces）" class="headerlink" title="3.21 异曲同工的类（Alternative Classes with Different Interfaces）"></a>3.21 异曲同工的类（Alternative Classes with Different Interfaces）</h2><p>使用类的好处之一就在于可以替换：今天用这个类，未来可以换成用另一个类。但只有当两个类的接口一致时，才能做这种替换。可以用改变函数声明（124）将函数签名变得一致。但这往往还不够，请反复运用搬移函数（198）将某些行为移入类中，直到两者的协议一致为止。如果搬移过程造成了重复代码，或许可运用提炼超类（375）补偿一下。</p><h2 id="3-22-纯数据类（Data-Class）"><a href="#3-22-纯数据类（Data-Class）" class="headerlink" title="3.22 纯数据类（Data Class）"></a>3.22 纯数据类（Data Class）</h2><p>所谓纯数据类是指：它们拥有一些字段，以及用于访问（读写）这些字段的函数，除此之外一无长物。这样的类只是一种不会说话的数据容器，它们几乎一定被其他类过分细琐地操控着。这些类早期可能拥有 public 字段，若果真如此，你应该在别人注意到它们之前，立刻运用封装记录（162）将它们封装起来。对于那些不该被其他类修改的字段，请运用移除设值函数（331）。</p><p>然后，找出这些取值&#x2F;设值函数被其他类调用的地点。尝试以搬移函数（198）把那些调用行为搬移到纯数据类里来。如果无法搬移整个函数，就运用提炼函数（106）产生一个可被搬移的函数。</p><p>纯数据类常常意味着行为被放在了错误的地方。也就是说，只要把处理数据的行为从客户端搬移到纯数据类里来，就能使情况大为改观。但也有例外情况，一个最好的例外情况就是，纯数据记录对象被用作函数调用的返回结果，比如使用拆分阶段（154）之后得到的中转数据结构就是这种情况。这种结果数据对象有一个关键的特征：它是不可修改的（至少在拆分阶段（154）的实际操作中是这样）。不可修改的字段无须封装，使用者可以直接通过字段取得数据，无须通过取值函数。</p><h2 id="3-23-被拒绝的遗赠（Refused-Bequest）"><a href="#3-23-被拒绝的遗赠（Refused-Bequest）" class="headerlink" title="3.23 被拒绝的遗赠（Refused Bequest）"></a>3.23 被拒绝的遗赠（Refused Bequest）</h2><p>子类应该继承超类的函数和数据。但如果它们不想或不需要继承，又该怎么办呢？它们得到所有礼物，却只从中挑选几样来玩！</p><p>按传统说法，这就意味着继承体系设计错误。你需要为这个子类新建一个兄弟类，再运用函数下移（359）和字段下移（361）把所有用不到的函数下推给那个兄弟。这样一来，超类就只持有所有子类共享的东西。你常常会听到这样的建议：所有超类都应该是抽象（abstract）的。</p><p>既然使用“传统说法”这个略带贬义的词，你就可以猜到，我们不建议你这么做，起码不建议你每次都这么做。我们经常利用继承来复用一些行为，并发现这可以很好地应用于日常工作。这也是一种坏味道，我们不否认，但气味通常并不强烈，所以我们说，如果“被拒绝的遗赠”正在引起困惑和问题，请遵循传统忠告。但不必认为你每次都得那么做。十有八九这种坏味道很淡，不值得理睬。</p><p>如果子类复用了超类的行为（实现），却又不愿意支持超类的接口，“被拒绝的遗赠”的坏味道就会变得很浓烈。拒绝继承超类的实现，这一点我们不介意；但如果拒绝支持超类的接口，这就难以接受了。既然不愿意支持超类的接口，就不要虚情假意地糊弄继承体系，应该运用以委托取代子类（381）或者以委托取代超类（399）彻底划清界限。</p><h2 id="3-24-注释（Comments）"><a href="#3-24-注释（Comments）" class="headerlink" title="3.24 注释（Comments）"></a>3.24 注释（Comments）</h2><p>别担心，我们并不是说你不该写注释。从嗅觉上说，注释不但不是一种坏味道，事实上它们还是一种香味呢。我们之所以要在这里提到注释，是因为人们常把它当作“除臭剂”来使用。常常会有这样的情况：你看到一段代码有着长长的注释，然后发现，这些注释之所以存在乃是因为代码很糟糕。这种情况的发生次数之多，实在令人吃惊。</p><p>注释可以带我们找到本章先前提到的各种坏味道。找到坏味道后，我们首先应该以各种重构手法把坏味道去除。完成之后我们常常会发现：注释已经变得多余了，因为代码已经清楚地说明了一切。</p><p>如果你需要注释来解释一块代码做了什么，试试提炼函数（106）；如果函数已经提炼出来，但还是需要注释来解释其行为，试试用改变函数声明（124）为它改名；如果你需要注释说明某些系统的需求规格，试试引入断言（302）。</p><blockquote><p><strong>Tip</strong><br>当你感觉需要撰写注释时，请先尝试重构，试着让所有注释都变得多余。</p></blockquote><p>如果你不知道该做什么，这才是注释的良好运用时机。除了用来记述将来的打算之外，注释还可以用来标记你并无十足把握的区域。你可以在注释里写下自己“为什么做某某事”。这类信息可以帮助将来的修改者，尤其是那些健忘的家伙。</p>]]></content>
    
    
    <categories>
      
      <category>重构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>重构</tag>
      
      <tag>架构</tag>
      
      <tag>设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker</title>
    <link href="/posts/14e7ef72/"/>
    <url>/posts/14e7ef72/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是-Docker"><a href="#什么是-Docker" class="headerlink" title="什么是 Docker"></a>什么是 Docker</h1><p><strong>Docker</strong> 使用 <code>Google</code> 公司推出的 <a href="https://golang.google.cn/">Go 语言</a> 进行开发实现，基于 <code>Linux</code> 内核的 <a href="https://zh.wikipedia.org/wiki/Cgroups">cgroup</a>，<a href="https://en.wikipedia.org/wiki/Linux_namespaces">namespace</a>，以及 <a href="https://docs.docker.com/storage/storagedriver/overlayfs-driver/">OverlayFS</a> 类的 <a href="https://en.wikipedia.org/wiki/Union_mount">Union FS</a> 等技术，对进程进行封装隔离，属于 <a href="https://en.wikipedia.org/wiki/Operating-system-level_virtualization">操作系统层面的虚拟化技术</a>。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151505744.png"></p><p><strong>Docker</strong> 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 <code>Docker</code> 技术比虚拟机技术更为轻便、快捷。</p><p>下面的图片比较了 <strong>Docker</strong> 和传统虚拟化方式的不同之处。传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151505428.png"></p><h1 id="为什么要用-Docker"><a href="#为什么要用-Docker" class="headerlink" title="为什么要用 Docker"></a>为什么要用 Docker</h1><h2 id="更高效的利用系统资源"><a href="#更高效的利用系统资源" class="headerlink" title="更高效的利用系统资源"></a>更高效的利用系统资源</h2><p>由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，<code>Docker</code> 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。</p><h2 id="更快速的启动时间"><a href="#更快速的启动时间" class="headerlink" title="更快速的启动时间"></a>更快速的启动时间</h2><p>传统的虚拟机技术启动应用服务往往需要数分钟，而 <code>Docker</code> 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。</p><h2 id="一致的运行环境"><a href="#一致的运行环境" class="headerlink" title="一致的运行环境"></a>一致的运行环境</h2><p>开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 <code>Docker</code> 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 <em>「这段代码在我机器上没问题啊」</em> 这类问题。</p><h2 id="持续交付和部署"><a href="#持续交付和部署" class="headerlink" title="持续交付和部署"></a>持续交付和部署</h2><p>对开发和运维（<a href="https://zh.wikipedia.org/wiki/DevOps">DevOps</a>）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。</p><p>使用 <code>Docker</code> 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 <a href="https://yeasy.gitbook.io/docker_practice/image/dockerfile">Dockerfile</a> 来进行镜像构建，并结合 <a href="https://en.wikipedia.org/wiki/Continuous_integration">持续集成(Continuous Integration)</a> 系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 <a href="https://en.wikipedia.org/wiki/Continuous_delivery">持续部署(Continuous Delivery&#x2F;Deployment)</a> 系统进行自动部署。</p><p>而且使用 <a href="https://yeasy.gitbook.io/docker_practice/image/build"><code>Dockerfile</code></a> 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。</p><h2 id="更轻松的迁移"><a href="#更轻松的迁移" class="headerlink" title="更轻松的迁移"></a>更轻松的迁移</h2><p>由于 <code>Docker</code> 确保了执行环境的一致性，使得应用的迁移更加容易。<code>Docker</code> 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。</p><h2 id="更轻松的维护和扩展"><a href="#更轻松的维护和扩展" class="headerlink" title="更轻松的维护和扩展"></a>更轻松的维护和扩展</h2><p><code>Docker</code> 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，<code>Docker</code> 团队同各个开源项目团队一起维护了一大批高质量的 <a href="https://hub.docker.com/search/?type=image&image_filter=official">官方镜像</a>，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。</p><h2 id="对比传统虚拟机总结"><a href="#对比传统虚拟机总结" class="headerlink" title="对比传统虚拟机总结"></a>对比传统虚拟机总结</h2><table><thead><tr><th>特性</th><th>容器</th><th>虚拟机</th></tr></thead><tbody><tr><td>启动</td><td>秒级</td><td>分钟级</td></tr><tr><td>硬盘使用</td><td>一般为 <code>MB</code></td><td>一般为 <code>GB</code></td></tr><tr><td>性能</td><td>接近原生</td><td>弱于</td></tr><tr><td>系统支持量</td><td>单机支持上千个容器</td><td>一般几十个</td></tr></tbody></table><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><strong>Docker</strong> 包括三个基本概念</p><ul><li><p><strong>镜像</strong>（<code>Image</code>）</p></li><li><p><strong>容器</strong>（<code>Container</code>）</p></li><li><p><strong>仓库</strong>（<code>Repository</code>）</p></li></ul><h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><p>我们都知道，操作系统分为 <strong>内核</strong> 和 <strong>用户空间</strong>。对于 <code>Linux</code> 而言，内核启动后，会挂载 <code>root</code> 文件系统为其提供用户空间支持。而 <strong>Docker 镜像</strong>（<code>Image</code>），就相当于是一个 <code>root</code> 文件系统。比如官方镜像 <code>ubuntu:18.04</code> 就包含了完整的一套 Ubuntu 18.04 最小系统的 <code>root</code> 文件系统。</p><p><strong>Docker 镜像</strong> 是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像 <strong>不包含</strong> 任何动态数据，其内容在构建之后也不会被改变。</p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>镜像（<code>Image</code>）和容器（<code>Container</code>）的关系，就像是面向对象程序设计中的 <code>类</code> 和 <code>实例</code> 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p><p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。因此容器可以拥有自己的 <code>root</code> 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学 Docker 时常常会混淆容器和虚拟机。</p><p>前面讲过镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为 <strong>容器存储层</strong>。</p><p>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</p><h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><p>镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry 就是这样的服务。</p><p>一个 <strong>Docker Registry</strong> 中可以包含多个 <strong>仓库</strong>（<code>Repository</code>）；每个仓库可以包含多个 <strong>标签</strong>（<code>Tag</code>）；每个标签对应一个镜像。</p><p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 <code>&lt;仓库名&gt;:&lt;标签&gt;</code> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 <code>latest</code> 作为默认标签。</p><p>以 <a href="https://hub.docker.com/_/ubuntu">Ubuntu 镜像</a> 为例，<code>ubuntu</code> 是仓库的名字，其内包含有不同的版本标签，如，<code>16.04</code>, <code>18.04</code>。我们可以通过 <code>ubuntu:16.04</code>，或者 <code>ubuntu:18.04</code> 来具体指定所需哪个版本的镜像。如果忽略了标签，比如 <code>ubuntu</code>，那将视为 <code>ubuntu:latest</code>。</p><p>仓库名经常以 <em>两段式路径</em> 形式出现，比如 <code>jwilder/nginx-proxy</code>，前者往往意味着 Docker Registry 多用户环境下的用户名，后者则往往是对应的软件名。但这并非绝对，取决于所使用的具体 Docker Registry 的软件或服务。</p><h3 id="Docker-Registry-公开服务"><a href="#Docker-Registry-公开服务" class="headerlink" title="Docker Registry 公开服务"></a>Docker Registry 公开服务</h3><p>Docker Registry 公开服务是开放给用户使用、允许用户管理镜像的 Registry 服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。</p><p>最常使用的 Registry 公开服务是官方的 <a href="https://hub.docker.com/">Docker Hub</a>，这也是默认的 Registry，并拥有大量的高质量的 <a href="https://hub.docker.com/search?q=&type=image&image_filter=official">官方镜像</a>。除此以外，还有 Red Hat 的 <a href="https://quay.io/repository/">Quay.io</a>；Google 的 <a href="https://cloud.google.com/container-registry/">Google Container Registry</a>，<a href="https://kubernetes.io/">Kubernetes</a> 的镜像使用的就是这个服务；代码托管平台 <a href="https://github.com/">GitHub</a> 推出的 <a href="https://docs.github.com/cn/packages/working-with-a-github-packages-registry/working-with-the-container-registry">ghcr.io</a>。</p><p>由于某些原因，在国内访问这些服务可能会比较慢。国内的一些云服务商提供了针对 Docker Hub 的镜像服务（<code>Registry Mirror</code>），这些镜像服务被称为 <strong>加速器</strong>。常见的有 <a href="https://www.aliyun.com/product/acr?source=5176.11533457&userCode=8lx5zmtu">阿里云加速器</a>、<a href="https://www.daocloud.io/mirror#accelerator-doc">DaoCloud 加速器</a> 等。使用加速器会直接从国内的地址下载 Docker Hub 的镜像，比直接从 Docker Hub 下载速度会提高很多。在 <a href="https://yeasy.gitbook.io/docker_practice/install/mirror">安装 Docker</a> 一节中有详细的配置方法。</p><p>国内也有一些云服务商提供类似于 Docker Hub 的公开服务。比如 <a href="https://c.163.com/hub#/m/library/">网易云镜像服务</a>、<a href="https://hub.daocloud.io/">DaoCloud 镜像市场</a>、<a href="https://www.aliyun.com/product/acr?source=5176.11533457&userCode=8lx5zmtu">阿里云镜像库</a> 等。</p><h3 id="私有Docker-Registry"><a href="#私有Docker-Registry" class="headerlink" title="私有Docker Registry"></a>私有Docker Registry</h3><p>除了使用公开服务外，用户还可以在本地搭建私有 Docker Registry。Docker 官方提供了 <a href="https://hub.docker.com/_/registry/">Docker Registry</a> 镜像，可以直接使用做为私有 Registry 服务。在 <a href="https://yeasy.gitbook.io/docker_practice/repository/registry">私有仓库</a> 一节中，会有进一步的搭建私有 Registry 服务的讲解。</p><p>开源的 Docker Registry 镜像只提供了 <a href="https://docs.docker.com/registry/spec/api/">Docker Registry API</a> 的服务端实现，足以支持 <code>docker</code> 命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。</p><p>除了官方的 Docker Registry 外，还有第三方软件实现了 Docker Registry API，甚至提供了用户界面以及一些高级功能。比如，<a href="https://github.com/goharbor/harbor">Harbor</a> 和 <a href="https://yeasy.gitbook.io/docker_practice/repository/nexus3_registry">Sonatype Nexus</a>。</p><h1 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h1><p>Docker 分为 <code>stable</code> <code>test</code> 和 <code>nightly</code> 三个更新频道。</p><p>官方网站上有各种环境下的 <a href="https://docs.docker.com/get-docker/">安装指南</a>，这里主要介绍 Docker 在 <code>Windows 10</code> 上的安装。</p><p><strong>手动下载安装</strong></p><p>点击以下 <a href="https://desktop.docker.com/win/main/amd64/Docker%20Desktop%20Installer.exe">链接</a> 下载 Docker Desktop for Windows。</p><p>下载好之后双击 <code>Docker Desktop Installer.exe</code> 开始安装。</p><p><strong>使用</strong> <a href="https://docs.microsoft.com/zh-cn/windows/package-manager/"><strong>winget</strong></a> <strong>安装</strong></p><p>复制</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">$ winget <span class="hljs-keyword">install</span> Docker.DockerDesktop<br></code></pre></td></tr></table></figure><h2 id="在-WSL2-运行-Docker"><a href="#在-WSL2-运行-Docker" class="headerlink" title="在 WSL2 运行 Docker"></a>在 WSL2 运行 Docker</h2><p>若你的 Windows 版本为 Windows 10 专业版或家庭版 v1903 及以上版本可以使用 WSL2 运行 Docker，具体请查看 <a href="https://docs.docker.com/docker-for-windows/wsl/">Docker Desktop WSL 2 backend</a>。</p><p>在 Windows 搜索栏输入 <strong>Docker</strong> 点击 <strong>Docker Desktop</strong> 开始运行。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151514091.png"></p><p>Docker 启动之后会在 Windows 任务栏出现鲸鱼图标。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151514645.png"></p><p>等待片刻，当鲸鱼图标静止时，说明 Docker 启动成功，之后你可以打开 PowerShell 使用 Docker。</p><h1 id="使用镜像"><a href="#使用镜像" class="headerlink" title="使用镜像"></a>使用镜像</h1><h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><p>之前提到过，<a href="https://hub.docker.com/search?q=&type=image">Docker Hub</a> 上有大量的高质量的镜像可以用，这里我们就说一下怎么获取这些镜像。</p><p>从 Docker 镜像仓库获取镜像的命令是 <code>docker pull</code>。其命令格式为：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">$ docker pull <span class="hljs-comment">[选项]</span> <span class="hljs-comment">[Docker Registry 地址<span class="hljs-comment">[:端口号]</span>/]</span>仓库名<span class="hljs-comment">[:标签]</span><br></code></pre></td></tr></table></figure><p>具体的选项可以通过 <code>docker pull --help</code> 命令看到，这里我们说一下镜像名称的格式。</p><ul><li>Docker 镜像仓库地址：地址的格式一般是 <code>&lt;域名/IP&gt;[:端口号]</code>。默认地址是 Docker Hub(<code>docker.io</code>)。</li><li>仓库名：如之前所说，这里的仓库名是两段式名称，即 <code>&lt;用户名&gt;/&lt;软件名&gt;</code>。对于 Docker Hub，如果不给出用户名，则默认为 <code>library</code>，也就是官方镜像。</li></ul><p>比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker pull ubuntu:18.04<br><br>18.04: Pulling from library/ubuntu<br>92dc2a97ff99: Pull complete<br>be13a9d27eb8: Pull complete<br>c8299583700a: Pull complete<br>Digest: sha256:4bc3ae6596938cb0d9e5ac51a1152ec9dcac2a1c50829c74abd9c4361e321b26<br>Status: Downloaded newer image <span class="hljs-keyword">for</span> ubuntu:18.04<br>docker.io/library/ubuntu:18.04<br></code></pre></td></tr></table></figure><p>上面的命令中没有给出 Docker 镜像仓库地址，因此将会从 Docker Hub （<code>docker.io</code>）获取镜像。而镜像名称是 <code>ubuntu:18.04</code>，因此将会获取官方镜像 <code>library/ubuntu</code> 仓库中标签为 <code>18.04</code> 的镜像。<code>docker pull</code> 命令的输出结果最后一行给出了镜像的完整名称，即： <code>docker.io/library/ubuntu:18.04</code>。</p><p>从下载过程中可以看到我们之前提及的分层存储的概念，镜像是由多层存储所构成。下载也是一层层的去下载，并非单一文件。下载过程中给出了每一层的 ID 的前 12 位。并且下载结束后，给出该镜像完整的 <code>sha256</code> 的摘要，以确保下载一致性。</p><p>在使用上面命令的时候，你可能会发现，你所看到的层 ID 以及 <code>sha256</code> 的摘要和这里的不一样。这是因为官方镜像是一直在维护的，有任何新的 bug，或者版本更新，都会进行修复再以原来的标签发布，这样可以确保任何使用这个标签的用户可以获得更安全、更稳定的镜像。</p><p>如果从 Docker Hub 下载镜像非常缓慢，可以使用镜像加速器 配置加速器。</p><h2 id="运行镜像"><a href="#运行镜像" class="headerlink" title="运行镜像"></a>运行镜像</h2><p>有了镜像后，我们就能够以这个镜像为基础启动并运行一个容器。以上面的 <code>ubuntu:18.04</code> 为例，如果我们打算启动里面的 <code>bash</code> 并且进行交互式操作的话，可以执行下面的命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -it --<span class="hljs-built_in">rm</span> ubuntu:18.04 bash<br><br>root@e7009c6ce357:/<span class="hljs-comment"># cat /etc/os-release</span><br>NAME=<span class="hljs-string">&quot;Ubuntu&quot;</span><br>VERSION=<span class="hljs-string">&quot;18.04.1 LTS (Bionic Beaver)&quot;</span><br>ID=ubuntu<br>ID_LIKE=debian<br>PRETTY_NAME=<span class="hljs-string">&quot;Ubuntu 18.04.1 LTS&quot;</span><br>VERSION_ID=<span class="hljs-string">&quot;18.04&quot;</span><br>HOME_URL=<span class="hljs-string">&quot;https://www.ubuntu.com/&quot;</span><br>SUPPORT_URL=<span class="hljs-string">&quot;https://help.ubuntu.com/&quot;</span><br>BUG_REPORT_URL=<span class="hljs-string">&quot;https://bugs.launchpad.net/ubuntu/&quot;</span><br>PRIVACY_POLICY_URL=<span class="hljs-string">&quot;https://www.ubuntu.com/legal/terms-and-policies/privacy-policy&quot;</span><br>VERSION_CODENAME=bionic<br>UBUNTU_CODENAME=bionic<br></code></pre></td></tr></table></figure><p><code>docker run</code> 就是运行容器的命令，这里简要的说明一下上面用到的参数。</p><ul><li><code>-it</code>：这是两个参数，一个是 <code>-i</code>：交互式操作，一个是 <code>-t</code> 终端。我们这里打算进入 <code>bash</code> 执行一些命令并查看返回结果，因此我们需要交互式终端。</li><li><code>--rm</code>：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 <code>docker rm</code>。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 <code>--rm</code> 可以避免浪费空间。</li><li><code>ubuntu:18.04</code>：这是指用 <code>ubuntu:18.04</code> 镜像为基础来启动容器。</li><li><code>bash</code>：放在镜像名后的是 <strong>命令</strong>，这里我们希望有个交互式 Shell，因此用的是 <code>bash</code>。</li></ul><p>进入容器后，我们可以在 Shell 下操作，执行任何所需的命令。这里，我们执行了 <code>cat /etc/os-release</code>，这是 Linux 常用的查看当前系统版本的命令，从返回的结果可以看到容器内是 <code>Ubuntu 18.04.1 LTS</code> 系统。</p><p>最后通过 <code>exit</code> 退出了这个容器。</p><h2 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h2><p>要想列出已经下载下来的镜像，可以使用 <code>docker image ls</code> 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker image <span class="hljs-built_in">ls</span><br><br>REPOSITORY           TAG                 IMAGE ID            CREATED             SIZE<br>redis                latest              5f515359c7f8        5 days ago          183 MB<br>nginx                latest              05a60462f8ba        5 days ago          181 MB<br>mongo                3.2                 fe9198c04d62        5 days ago          342 MB<br>&lt;none&gt;               &lt;none&gt;              00285df0df87        5 days ago          342 MB<br>ubuntu               18.04               329ed837d508        3 days ago          63.3MB<br>ubuntu               bionic              329ed837d508        3 days ago          63.3MB<br></code></pre></td></tr></table></figure><p>列表包含了 <code>仓库名</code>、<code>标签</code>、<code>镜像 ID</code>、<code>创建时间</code> 以及 <code>所占用的空间</code>。</p><p>其中仓库名、标签在之前的基础概念章节已经介绍过了。<strong>镜像 ID</strong> 则是镜像的唯一标识，一个镜像可以对应多个 <strong>标签</strong>。因此，在上面的例子中，我们可以看到 <code>ubuntu:18.04</code> 和 <code>ubuntu:bionic</code> 拥有相同的 ID，因为它们对应的是同一个镜像。</p><h2 id="删除本地镜像"><a href="#删除本地镜像" class="headerlink" title="删除本地镜像"></a>删除本地镜像</h2><p>如果要删除本地的镜像，可以使用 <code>docker image rm</code> 命令，其格式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker image <span class="hljs-built_in">rm</span> [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]<br></code></pre></td></tr></table></figure><p><strong>用 ID、镜像名、摘要删除镜像</strong></p><p>其中，<code>&lt;镜像&gt;</code> 可以是 <code>镜像短 ID</code>、<code>镜像长 ID</code>、<code>镜像名</code> 或者 <code>镜像摘要</code>。</p><p>比如我们有这么一些镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker image <span class="hljs-built_in">ls</span><br>REPOSITORY                  TAG                 IMAGE ID            CREATED             SIZE<br>centos                      latest              0584b3d2cf6d        3 weeks ago         196.5 MB<br>redis                       alpine              501ad78535f0        3 weeks ago         21.03 MB<br>docker                      latest              cf693ec9b5c7        3 weeks ago         105.1 MB<br>nginx                       latest              e43d811ce2f4        5 weeks ago         181.5 MB<br></code></pre></td></tr></table></figure><p>我们可以用镜像的完整 ID，也称为 <code>长 ID</code>，来删除镜像。使用脚本的时候可能会用长 ID，但是人工输入就太累了，所以更多的时候是用 <code>短 ID</code> 来删除镜像。<code>docker image ls</code> 默认列出的就已经是短 ID 了，一般取前3个字符以上，只要足够区分于别的镜像就可以了。</p><p>比如这里，如果我们要删除 <code>redis:alpine</code> 镜像，可以执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker image <span class="hljs-built_in">rm</span> 501<br><br>Untagged: redis:alpine<br>Untagged: redis@sha256:f1ed3708f538b537eb9c2a7dd50dc90a706f7debd7e1196c9264edeea521a86d<br>Deleted: sha256:501ad78535f015d88872e13fa87a828425117e3d28075d0c117932b05bf189b7<br>Deleted: sha256:96167737e29ca8e9d74982ef2a0dda76ed7b430da55e321c071f0dbff8c2899b<br>Deleted: sha256:32770d1dcf835f192cafd6b9263b7b597a1778a403a109e2cc2ee866f74adf23<br>Deleted: sha256:127227698ad74a5846ff5153475e03439d96d4b1c7f2a449c7a826ef74a2d2fa<br>Deleted: sha256:1333ecc582459bac54e1437335c0816bc17634e131ea0cc48daa27d32c75eab3<br>Deleted: sha256:4fc455b921edf9c4aea207c51ab39b10b06540c8b4825ba57b3feed1668fa7c7<br></code></pre></td></tr></table></figure><p>我们也可以用<code>镜像名</code>，也就是 <code>&lt;仓库名&gt;:&lt;标签&gt;</code>，来删除镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker image <span class="hljs-built_in">rm</span> centos<br><br>Untagged: centos:latest<br>Untagged: centos@sha256:b2f9d1c0ff5f87a4743104d099a3d561002ac500db1b9bfa02a783a46e0d366c<br>Deleted: sha256:0584b3d2cf6d235ee310cf14b54667d889887b838d3f3d3033acd70fc3c48b8a<br>Deleted: sha256:97ca462ad9eeae25941546209454496e1d66749d53dfa2ee32bf1faabd239d38<br></code></pre></td></tr></table></figure><p>当然，更精确的是使用 <code>镜像摘要</code> 删除镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker image <span class="hljs-built_in">ls</span> --digests<br>REPOSITORY                  TAG                 DIGEST                                                                    IMAGE ID            CREATED             SIZE<br>node                        slim                sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228   6e0c4c8e3913        3 weeks ago         214 MB<br><br>$ docker image <span class="hljs-built_in">rm</span> node@sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228<br>Untagged: node@sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228<br></code></pre></td></tr></table></figure><h2 id="Untagged-和-Deleted"><a href="#Untagged-和-Deleted" class="headerlink" title="Untagged 和 Deleted"></a>Untagged 和 Deleted</h2><p>如果观察上面这几个命令的运行输出信息的话，你会注意到删除行为分为两类，一类是 <code>Untagged</code>，另一类是 <code>Deleted</code>。我们之前介绍过，镜像的唯一标识是其 ID 和摘要，而一个镜像可以有多个标签。</p><p>因此当我们使用上面命令删除镜像的时候，实际上是在要求删除某个标签的镜像。所以首先需要做的是将满足我们要求的所有镜像标签都取消，这就是我们看到的 <code>Untagged</code> 的信息。因为一个镜像可以对应多个标签，因此当我们删除了所指定的标签后，可能还有别的标签指向了这个镜像，如果是这种情况，那么 <code>Delete</code> 行为就不会发生。所以并非所有的 <code>docker image rm</code> 都会产生删除镜像的行为，有可能仅仅是取消了某个标签而已。</p><p>当该镜像所有的标签都被取消了，该镜像很可能会失去了存在的意义，因此会触发删除行为。镜像是多层存储结构，因此在删除的时候也是从上层向基础层方向依次进行判断删除。镜像的多层结构让镜像复用变得非常容易，因此很有可能某个其它镜像正依赖于当前镜像的某一层。这种情况，依旧不会触发删除该层的行为。直到没有任何层依赖当前层时，才会真实的删除当前层。这就是为什么，有时候会奇怪，为什么明明没有别的标签指向这个镜像，但是它还是存在的原因，也是为什么有时候会发现所删除的层数和自己 <code>docker pull</code> 看到的层数不一样的原因。</p><h2 id="使用Dockerfile定制镜像"><a href="#使用Dockerfile定制镜像" class="headerlink" title="使用Dockerfile定制镜像"></a>使用Dockerfile定制镜像</h2><p>镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。</p><p>Dockerfile 是一个文本文件，其内包含了一条条的 **指令(Instruction)**，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p><p>以定制 <code>nginx</code> 镜像为例，这次我们使用 Dockerfile 来定制。</p><p>在一个空白目录中，建立一个文本文件，并命名为 <code>Dockerfile</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">mkdir</span> mynginx<br>$ <span class="hljs-built_in">cd</span> mynginx<br>$ <span class="hljs-built_in">touch</span> Dockerfile<br></code></pre></td></tr></table></figure><p>其内容为：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Dockerfile"><span class="hljs-keyword">FROM</span> nginx<br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27;</span> &gt; /usr/share/nginx/html/index.html</span><br></code></pre></td></tr></table></figure><p>这个 Dockerfile 很简单，一共就两行。涉及到了两条指令，<code>FROM</code> 和 <code>RUN</code>。</p><h3 id="FROM指定基础镜像"><a href="#FROM指定基础镜像" class="headerlink" title="FROM指定基础镜像"></a>FROM指定基础镜像</h3><p>所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。就像我们之前运行了一个 <code>nginx</code> 镜像的容器，再进行修改一样，基础镜像是必须指定的。而 <code>FROM</code> 就是指定 <strong>基础镜像</strong>，因此一个 <code>Dockerfile</code> 中 <code>FROM</code> 是必备的指令，并且必须是第一条指令。</p><p>在 <a href="https://hub.docker.com/search?q=&type=image&image_filter=official">Docker Hub</a> 上有非常多的高质量的官方镜像，有可以直接拿来使用的服务类的镜像，如 <a href="https://hub.docker.com/_/nginx/"><code>nginx</code></a>、<a href="https://hub.docker.com/_/redis/"><code>redis</code></a>、<a href="https://hub.docker.com/_/mongo/"><code>mongo</code></a>、<a href="https://hub.docker.com/_/mysql/"><code>mysql</code></a>、<a href="https://hub.docker.com/_/httpd/"><code>httpd</code></a>、<a href="https://hub.docker.com/_/php/"><code>php</code></a>、<a href="https://hub.docker.com/_/tomcat/"><code>tomcat</code></a> 等；也有一些方便开发、构建、运行各种语言应用的镜像，如 <a href="https://hub.docker.com/_/node"><code>node</code></a>、<a href="https://hub.docker.com/_/openjdk/"><code>openjdk</code></a>、<a href="https://hub.docker.com/_/python/"><code>python</code></a>、<a href="https://hub.docker.com/_/ruby/"><code>ruby</code></a>、<a href="https://hub.docker.com/_/golang/"><code>golang</code></a> 等。可以在其中寻找一个最符合我们最终目标的镜像为基础镜像进行定制。</p><h3 id="RUN执行命令"><a href="#RUN执行命令" class="headerlink" title="RUN执行命令"></a>RUN执行命令</h3><p><code>RUN</code> 指令是用来执行命令行命令的。由于命令行的强大能力，<code>RUN</code> 指令在定制镜像时是最常用的指令之一。其格式有两种：</p><ul><li><em>shell</em> 格式：<code>RUN &lt;命令&gt;</code>，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 <code>RUN</code> 指令就是这种格式。</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">RUN echo <span class="hljs-string">&#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27;</span> &gt; <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/nginx/</span>html/index.html<br></code></pre></td></tr></table></figure><ul><li><em>exec</em> 格式：<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code>，这更像是函数调用中的格式。</li></ul><p>既然 <code>RUN</code> 就像 Shell 脚本一样可以执行命令，那么我们是否就可以像 Shell 脚本一样把每个命令对应一个 RUN 呢？比如这样：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Dockerfile"><span class="hljs-keyword">FROM</span> debian:stretch<br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get update</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get install -y gcc libc6-dev make wget</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> wget -O redis.tar.gz <span class="hljs-string">&quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span></span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">mkdir</span> -p /usr/src/redis</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> make -C /usr/src/redis</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> make -C /usr/src/redis install</span><br></code></pre></td></tr></table></figure><p>之前说过，Dockerfile 中每一个指令都会建立一层，<code>RUN</code> 也不例外。每一个 <code>RUN</code> 的行为，就和刚才我们手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，<code>commit</code> 这一层的修改，构成新的镜像。</p><p>上面的这种写法，创建了 7 层镜像。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。 这是很多初学 Docker 的人常犯的一个错误。</p><p><em>Union FS 是有最大层数限制的，比如 AUFS，曾经是最大不得超过 42 层，现在是不得超过 127 层。</em></p><p>上面的 <code>Dockerfile</code> 正确的写法应该是这样：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Dockerfile"><span class="hljs-keyword">FROM</span> debian:stretch<br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">set</span> -x; buildDeps=<span class="hljs-string">&#x27;gcc libc6-dev make wget&#x27;</span> \</span><br><span class="language-bash">    &amp;&amp; apt-get update \</span><br><span class="language-bash">    &amp;&amp; apt-get install -y <span class="hljs-variable">$buildDeps</span> \</span><br><span class="language-bash">    &amp;&amp; wget -O redis.tar.gz <span class="hljs-string">&quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span> \</span><br><span class="language-bash">    &amp;&amp; <span class="hljs-built_in">mkdir</span> -p /usr/src/redis \</span><br><span class="language-bash">    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \</span><br><span class="language-bash">    &amp;&amp; make -C /usr/src/redis \</span><br><span class="language-bash">    &amp;&amp; make -C /usr/src/redis install \</span><br><span class="language-bash">    &amp;&amp; <span class="hljs-built_in">rm</span> -rf /var/lib/apt/lists/* \</span><br><span class="language-bash">    &amp;&amp; <span class="hljs-built_in">rm</span> redis.tar.gz \</span><br><span class="language-bash">    &amp;&amp; <span class="hljs-built_in">rm</span> -r /usr/src/redis \</span><br><span class="language-bash">    &amp;&amp; apt-get purge -y --auto-remove <span class="hljs-variable">$buildDeps</span></span><br></code></pre></td></tr></table></figure><p>首先，之前所有的命令只有一个目的，就是编译、安装 redis 可执行文件。因此没有必要建立很多层，这只是一层的事情。因此，这里没有使用很多个 <code>RUN</code> 一一对应不同的命令，而是仅仅使用一个 <code>RUN</code> 指令，并使用 <code>&amp;&amp;</code> 将各个所需命令串联起来。将之前的 7 层，简化为了 1 层。在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建。</p><p>并且，这里为了格式化还进行了换行。Dockerfile 支持 Shell 类的行尾添加 <code>\</code> 的命令换行方式，以及行首 <code>#</code> 进行注释的格式。良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。</p><p>此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 <code>apt</code> 缓存文件。这是很重要的一步，我们之前说过，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。</p><h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><p>回到之前定制的 nginx 镜像的 Dockerfile 来。现在我们明白了这个 Dockerfile 的内容，那么让我们来构建这个镜像吧。</p><p>在 <code>Dockerfile</code> 文件所在目录执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker build -t nginx:v3 .<br>Sending build context to Docker daemon 2.048 kB<br>Step 1 : FROM nginx<br> ---&gt; e43d811ce2f4<br>Step 2 : RUN <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27;</span> &gt; /usr/share/nginx/html/index.html<br> ---&gt; Running <span class="hljs-keyword">in</span> 9cdc27646c7b<br> ---&gt; 44aa4490ce2c<br>Removing intermediate container 9cdc27646c7b<br>Successfully built 44aa4490ce2c<br></code></pre></td></tr></table></figure><p>从命令的输出结果中，我们可以清晰的看到镜像的构建过程。在 <code>Step 2</code> 中，如同我们之前所说的那样，<code>RUN</code> 指令启动了一个容器 <code>9cdc27646c7b</code>，执行了所要求的命令，并最后提交了这一层 <code>44aa4490ce2c</code>，随后删除了所用到的这个容器 <code>9cdc27646c7b</code>。</p><p>这里我们使用了 <code>docker build</code> 命令进行镜像构建。其格式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker build [选项] &lt;上下文路径/URL/-&gt;<br></code></pre></td></tr></table></figure><h3 id="镜像构建上下文"><a href="#镜像构建上下文" class="headerlink" title="镜像构建上下文"></a>镜像构建上下文</h3><p>如果注意，会看到 <code>docker build</code> 命令最后有一个 <code>.</code>。<code>.</code> 表示当前目录，而 <code>Dockerfile</code> 就在当前目录，因此不少初学者以为这个路径是在指定 <code>Dockerfile</code> 所在路径，这么理解其实是不准确的。如果对应上面的命令格式，你可能会发现，这是在指定 <strong>上下文路径</strong>。那么什么是上下文呢？</p><p>首先我们要理解 <code>docker build</code> 的工作原理。Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。Docker 的引擎提供了一组 REST API，被称为 <a href="https://docs.docker.com/develop/sdk/">Docker Remote API</a>，而如 <code>docker</code> 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 <code>docker</code> 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C&#x2F;S 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。</p><p>当我们进行镜像构建的时候，并非所有定制都会通过 <code>RUN</code> 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 <code>COPY</code> 指令、<code>ADD</code> 指令等。而 <code>docker build</code> 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种客户端&#x2F;服务端的架构中，如何才能让服务端获得本地文件呢？</p><p>这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，<code>docker build</code> 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p><h2 id="其他制作镜像的方式"><a href="#其他制作镜像的方式" class="headerlink" title="其他制作镜像的方式"></a>其他制作镜像的方式</h2><p>Docker 还提供了 <code>docker save</code> 和 <code>docker load</code> 命令，用以将镜像保存为一个文件，然后传输到另一个位置上，再加载进来。这是在没有 Docker Registry 时的做法，现在已经不推荐，镜像迁移应该直接使用 Docker Registry，无论是直接使用 Docker Hub 还是使用内网私有 Registry 都可以。</p><p>使用 <code>docker save</code> 命令可以将镜像保存为归档文件。</p><p>比如我们希望保存这个 <code>alpine</code> 镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker image <span class="hljs-built_in">ls</span> alpine<br>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE<br>alpine              latest              baa5d63471ea        5 weeks ago         4.803 MB<br></code></pre></td></tr></table></figure><p>保存镜像的命令为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker save alpine -o filename<br>$ file filename<br>filename: POSIX tar archive<br></code></pre></td></tr></table></figure><p>这里的 filename 可以为任意名称甚至任意后缀名，但文件的本质都是归档文件</p><p>若使用 <code>gzip</code> 压缩：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker save alpine | gzip &gt; alpine-latest.tar.gz<br></code></pre></td></tr></table></figure><p>然后我们将 <code>alpine-latest.tar.gz</code> 文件复制到了到了另一个机器上，可以用下面这个命令加载镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker load -i alpine-latest.tar.gz<br>Loaded image: alpine:latest<br></code></pre></td></tr></table></figure><h1 id="操作容器"><a href="#操作容器" class="headerlink" title="操作容器"></a>操作容器</h1><p>容器是 Docker 又一核心概念。</p><p>简单的说，容器是独立运行的一个或一组应用，以及它们的运行态环境。对应的，虚拟机可以理解为模拟运行的一整套操作系统（提供了运行态环境和其他系统环境）和跑在上面的应用。</p><p>具体介绍如何来管理一个容器，包括创建、启动和停止等。</p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（<code>exited</code>）的容器重新启动。</p><p>因为 Docker 的容器实在太轻量级了，很多时候用户都是随时删除和新创建容器。</p><h3 id="新建并启动"><a href="#新建并启动" class="headerlink" title="新建并启动"></a>新建并启动</h3><p>所需要的命令主要为 <code>docker run</code>。</p><p>例如，下面的命令输出一个 “Hello World”，之后终止容器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run ubuntu:18.04 /bin/echo <span class="hljs-string">&#x27;Hello world&#x27;</span><br>Hello world<br></code></pre></td></tr></table></figure><p>下面的命令则启动一个 bash 终端，允许用户进行交互。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -t -i ubuntu:18.04 /bin/bash<br>root@af8bae53bdd3:/<span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure><p>其中，<code>-t</code> 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， <code>-i</code> 则让容器的标准输入保持打开。</p><p>在交互模式下，用户可以通过所创建的终端来输入命令，例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@af8bae53bdd3:/<span class="hljs-comment"># pwd</span><br>/<br>root@af8bae53bdd3:/<span class="hljs-comment"># ls</span><br>bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var<br></code></pre></td></tr></table></figure><p>当利用 <code>docker run</code> 来创建容器时，Docker 在后台运行的标准操作包括：</p><ul><li>检查本地是否存在指定的镜像，不存在就从 <a href="https://yeasy.gitbook.io/docker_practice/repository">registry</a> 下载</li><li>利用镜像创建并启动一个容器</li><li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li><li>从地址池配置一个 ip 地址给容器</li><li>执行用户指定的应用程序</li><li>执行完毕后容器被终止</li></ul><h3 id="启动已终止容器"><a href="#启动已终止容器" class="headerlink" title="启动已终止容器"></a>启动已终止容器</h3><p>可以利用 <code>docker container start</code> 命令，直接将一个已经终止（<code>exited</code>）的容器启动运行。</p><p>容器的核心为所执行的应用程序，所需要的资源都是应用程序运行所必需的。除此之外，并没有其它的资源。可以在伪终端中利用 <code>ps</code> 或 <code>top</code> 来查看进程信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@ba267838cc1b:/<span class="hljs-comment"># ps</span><br>  PID TTY          TIME CMD<br>    1 ?        00:00:00 bash<br>   11 ?        00:00:00 ps<br></code></pre></td></tr></table></figure><p>可见，容器中仅运行了指定的 bash 应用。这种特点使得 Docker 对资源的利用率极高，是货真价实的轻量级虚拟化。</p><h2 id="守护态运行"><a href="#守护态运行" class="headerlink" title="守护态运行"></a>守护态运行</h2><p>多的时候，需要让 Docker 在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 <code>-d</code> 参数来实现。</p><p>下面举两个例子来说明一下。</p><p>如果不使用 <code>-d</code> 参数运行容器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run ubuntu:18.04 /bin/sh -c <span class="hljs-string">&quot;while true; do echo hello world; sleep 1; done&quot;</span><br>hello world<br>hello world<br>hello world<br>hello world<br></code></pre></td></tr></table></figure><p>容器会把输出的结果 (STDOUT) 打印到宿主机上面</p><p>如果使用了 <code>-d</code> 参数运行容器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -d ubuntu:18.04 /bin/sh -c <span class="hljs-string">&quot;while true; do echo hello world; sleep 1; done&quot;</span><br>77b2dc01fe0f3f1265df143181e7b9af5e05279a884f4776ee75350ea9d8017a<br></code></pre></td></tr></table></figure><p>此时容器会在后台运行并不会把输出的结果 (STDOUT) 打印到宿主机上面(输出结果可以用 <code>docker logs</code> 查看)。</p><p><strong>注：</strong> 容器是否会长久运行，是和 <code>docker run</code> 指定的命令有关，和 <code>-d</code> 参数无关。</p><p>使用 <code>-d</code> 参数启动后会返回一个唯一的 id，也可以通过 <code>docker container ls</code> 命令来查看容器信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container <span class="hljs-built_in">ls</span><br>CONTAINER ID  IMAGE         COMMAND               CREATED        STATUS       PORTS NAMES<br>77b2dc01fe0f  ubuntu:18.04  /bin/sh -c <span class="hljs-string">&#x27;while tr  2 minutes ago  Up 1 minute        agitated_wright</span><br></code></pre></td></tr></table></figure><p>要获取容器的输出信息，可以通过 <code>docker container logs</code> 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container logs [container ID or NAMES]<br>hello world<br>hello world<br>hello world<br>. . .<br></code></pre></td></tr></table></figure><h2 id="终止"><a href="#终止" class="headerlink" title="终止"></a>终止</h2><p>可以使用 <code>docker container stop</code> 来终止一个运行中的容器。</p><p>此外，当 Docker 容器中指定的应用终结时，容器也自动终止。</p><p>例如对于上一章节中只启动了一个终端的容器，用户通过 <code>exit</code> 命令或 <code>Ctrl+d</code> 来退出终端时，所创建的容器立刻终止。</p><p>终止状态的容器可以用 <code>docker container ls -a</code> 命令看到。例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container <span class="hljs-built_in">ls</span> -a<br>CONTAINER ID        IMAGE                    COMMAND                CREATED             STATUS                          PORTS               NAMES<br>ba267838cc1b        ubuntu:18.04             <span class="hljs-string">&quot;/bin/bash&quot;</span>            30 minutes ago      Exited (0) About a minute ago                       trusting_newton<br></code></pre></td></tr></table></figure><p>处于终止状态的容器，可以通过 <code>docker container start</code> 命令来重新启动。</p><p>此外，<code>docker container restart</code> 命令会将一个运行态的容器终止，然后再重新启动它。</p><h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><p>在使用 <code>-d</code> 参数时，容器启动后会进入后台。</p><p>某些时候需要进入容器进行操作，包括使用 <code>docker attach</code> 命令或 <code>docker exec</code> 命令，推荐大家使用 <code>docker exec</code> 命令，原因会在下面说明。</p><h3 id="attach"><a href="#attach" class="headerlink" title="attach"></a>attach</h3><p>下面示例如何使用 <code>docker attach</code> 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -dit ubuntu<br>243c32535da7d142fb0e6df616a3c3ada0b8ab417937c853a9e1c251f499f550<br><br>$ docker container <span class="hljs-built_in">ls</span><br>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES<br>243c32535da7        ubuntu:latest       <span class="hljs-string">&quot;/bin/bash&quot;</span>         18 seconds ago      Up 17 seconds                           nostalgic_hypatia<br><br>$ docker attach 243c<br>root@243c32535da7:/<span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure><p><em>注意：</em> 如果从这个 stdin 中 exit，会导致容器的停止。</p><h3 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h3><p><code>docker exec</code> 后边可以跟多个参数，这里主要说明 <code>-i</code> <code>-t</code> 参数。</p><p>只用 <code>-i</code> 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。</p><p>当 <code>-i</code> <code>-t</code> 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -dit ubuntu<br>69d137adef7a8a689cbcb059e94da5489d3cddd240ff675c640c8d96e84fe1f6<br><br>$ docker container <span class="hljs-built_in">ls</span><br>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES<br>69d137adef7a        ubuntu:latest       <span class="hljs-string">&quot;/bin/bash&quot;</span>         18 seconds ago      Up 17 seconds                           zealous_swirles<br><br>$ docker <span class="hljs-built_in">exec</span> -i 69d1 bash<br><span class="hljs-built_in">ls</span><br>bin<br>boot<br>dev<br>...<br><br>$ docker <span class="hljs-built_in">exec</span> -it 69d1 bash<br>root@69d137adef7a:/<span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure><p>如果从这个 stdin 中 exit，不会导致容器的停止。这就是为什么推荐大家使用 <code>docker exec</code> 的原因。</p><h2 id="导入和导出"><a href="#导入和导出" class="headerlink" title="导入和导出"></a>导入和导出</h2><h3 id="导出容器"><a href="#导出容器" class="headerlink" title="导出容器"></a>导出容器</h3><p>如果要导出本地某个容器，可以使用 <code>docker export</code> 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container <span class="hljs-built_in">ls</span> -a<br>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                    PORTS               NAMES<br>7691a814370e        ubuntu:18.04        <span class="hljs-string">&quot;/bin/bash&quot;</span>         36 hours ago        Exited (0) 21 hours ago                       <span class="hljs-built_in">test</span><br>$ docker <span class="hljs-built_in">export</span> 7691a814370e &gt; ubuntu.tar<br></code></pre></td></tr></table></figure><p>这样将导出容器快照到本地文件。</p><h3 id="导入容器快照"><a href="#导入容器快照" class="headerlink" title="导入容器快照"></a>导入容器快照</h3><p>可以使用 <code>docker import</code> 从容器快照文件中再导入为镜像，例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> ubuntu.tar | docker import - <span class="hljs-built_in">test</span>/ubuntu:v1.0<br>$ docker image <span class="hljs-built_in">ls</span><br>REPOSITORY          TAG                 IMAGE ID            CREATED              VIRTUAL SIZE<br><span class="hljs-built_in">test</span>/ubuntu         v1.0                9d37a6082e97        About a minute ago   171.3 MB<br></code></pre></td></tr></table></figure><p>此外，也可以通过指定 URL 或者某个目录来导入，例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker import http://example.com/exampleimage.tgz example/imagerepo<br></code></pre></td></tr></table></figure><p><em>注：用户既可以使用</em> <code>_docker load_</code> <em>来导入镜像存储文件到本地镜像库，也可以使用</em> <code>_docker import_</code> <em>来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</em></p><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><p>可以使用 <code>docker container rm</code> 来删除一个处于终止状态的容器。例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container <span class="hljs-built_in">rm</span> trusting_newton<br>trusting_newton<br></code></pre></td></tr></table></figure><p>如果要删除一个运行中的容器，可以添加 <code>-f</code> 参数。Docker 会发送 <code>SIGKILL</code> 信号给容器。</p><h3 id="清除所有处于终止状态的容器"><a href="#清除所有处于终止状态的容器" class="headerlink" title="清除所有处于终止状态的容器"></a>清除所有处于终止状态的容器</h3><p>用 <code>docker container ls -a</code> 命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用下面的命令可以清理掉所有处于终止状态的容器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container prune<br></code></pre></td></tr></table></figure><h1 id="访问仓库"><a href="#访问仓库" class="headerlink" title="访问仓库"></a>访问仓库</h1><h2 id="Docker-Hub"><a href="#Docker-Hub" class="headerlink" title="Docker Hub"></a>Docker Hub</h2><p>目前 Docker 官方维护了一个公共仓库 <a href="https://hub.docker.com/">Docker Hub</a>，其中已经包括了数量超过 <a href="https://hub.docker.com/search/?type=image">2,650,000</a> 的镜像。大部分需求都可以通过在 Docker Hub 中直接下载镜像来实现。</p><p>你可以在 <a href="https://hub.docker.com/">https://hub.docker.com</a> 免费注册一个 Docker 账号。</p><p>你可以通过 <code>docker search</code> 命令来查找官方仓库中的镜像，并利用 <code>docker pull</code> 命令来将它下载到本地。</p><p>例如以 <code>centos</code> 为关键词进行搜索：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker search centos<br>NAME                               DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED<br>centos                             The official build of CentOS.                   6449      [OK]<br>ansible/centos7-ansible            Ansible on Centos7                              132                  [OK]<br>consol/centos-xfce-vnc             Centos container with <span class="hljs-string">&quot;headless&quot;</span> VNC session…   126                  [OK]<br>jdeathe/centos-ssh                 OpenSSH / Supervisor / EPEL/IUS/SCL Repos - …   117                  [OK]<br>centos/systemd                     systemd enabled base container.                 96                   [OK]<br></code></pre></td></tr></table></figure><p>可以看到返回了很多包含关键字的镜像，其中包括镜像名字、描述、收藏数（表示该镜像的受关注程度）、是否官方创建（<code>OFFICIAL</code>）、是否自动构建 （<code>AUTOMATED</code>）。</p><p>根据是否是官方提供，可将镜像分为两类。</p><p>一种是类似 <code>centos</code> 这样的镜像，被称为基础镜像或根镜像。这些基础镜像由 Docker 公司创建、验证、支持、提供。这样的镜像往往使用单个单词作为名字。</p><p>还有一种类型，比如 <code>ansible/centos7-ansible</code> 镜像，它是由 Docker Hub 的注册用户创建并维护的，往往带有用户名称前缀。可以通过前缀 <code>username/</code> 来指定使用某个用户提供的镜像，比如 ansible 用户。</p><p>另外，在查找的时候通过 <code>--filter=stars=N</code> 参数可以指定仅显示收藏数量为 <code>N</code> 以上的镜像。</p><p>下载官方 <code>centos</code> 镜像到本地。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker pull centos<br>Using default tag: latest<br>latest: Pulling from library/centos<br>7a0437f04f83: Pull complete<br>Digest: sha256:5528e8b1b1719d34604c87e11dcd1c0a20bedf46e83b5632cdeac91b8c04efc1<br>Status: Downloaded newer image <span class="hljs-keyword">for</span> centos:latest<br>docker.io/library/centos:latest<br></code></pre></td></tr></table></figure><h3 id="推送镜像"><a href="#推送镜像" class="headerlink" title="推送镜像"></a>推送镜像</h3><p>用户也可以在登录后通过 <code>docker push</code> 命令来将自己的镜像推送到 Docker Hub。</p><p>以下命令中的 <code>username</code> 请替换为你的 Docker 账号用户名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker tag ubuntu:18.04 username/ubuntu:18.04<br><br>$ docker image <span class="hljs-built_in">ls</span><br><br>REPOSITORY                                               TAG                    IMAGE ID            CREATED             SIZE<br>ubuntu                                                   18.04                  275d79972a86        6 days ago          94.6MB<br>username/ubuntu                                          18.04                  275d79972a86        6 days ago          94.6MB<br><br>$ docker push username/ubuntu:18.04<br><br>$ docker search username<br><br>NAME                      DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED<br>username/ubuntu<br></code></pre></td></tr></table></figure><h2 id="私有仓库"><a href="#私有仓库" class="headerlink" title="私有仓库"></a>私有仓库</h2><p>有时候使用 Docker Hub 这样的公共仓库可能不方便，用户可以创建一个本地仓库供私人使用。</p><p>本节介绍如何使用本地仓库。</p><p><a href="https://docs.docker.com/registry/"><code>docker-registry</code></a> 是官方提供的工具，可以用于构建私有的镜像仓库。本文内容基于 <a href="https://github.com/docker/distribution"><code>docker-registry</code></a> v2.x 版本。</p><h3 id="安装运行-docker-registry"><a href="#安装运行-docker-registry" class="headerlink" title="安装运行 docker-registry"></a>安装运行 docker-registry</h3><p><strong>容器运行</strong></p><p>你可以使用官方 <code>registry</code> 镜像来运行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -d -p 5000:5000 --restart=always --name registry registry<br></code></pre></td></tr></table></figure><p>这将使用官方的 <code>registry</code> 镜像来启动私有仓库。默认情况下，仓库会被创建在容器的 <code>/var/lib/registry</code> 目录下。你可以通过 <code>-v</code> 参数来将镜像文件存放在本地的指定路径。例如下面的例子将上传的镜像放到本地的 <code>/opt/data/registry</code> 目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -d \<br>    -p 5000:5000 \<br>    -v /opt/data/registry:/var/lib/registry \<br>    registry<br></code></pre></td></tr></table></figure><h3 id="在私有仓库上传、搜索、下载镜像"><a href="#在私有仓库上传、搜索、下载镜像" class="headerlink" title="在私有仓库上传、搜索、下载镜像"></a>在私有仓库上传、搜索、下载镜像</h3><p>创建好私有仓库之后，就可以使用 <code>docker tag</code> 来标记一个镜像，然后推送它到仓库。例如私有仓库地址为 <code>127.0.0.1:5000</code>。</p><p>先在本机查看已有的镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker image <span class="hljs-built_in">ls</span><br>REPOSITORY                        TAG                 IMAGE ID            CREATED             VIRTUAL SIZE<br>ubuntu                            latest              ba5877dc9bec        6 weeks ago         192.7 MB<br></code></pre></td></tr></table></figure><p>使用 <code>docker tag</code> 将 <code>ubuntu:latest</code> 这个镜像标记为 <code>127.0.0.1:5000/ubuntu:latest</code>。</p><p>格式为 <code>docker tag IMAGE[:TAG] [REGISTRY_HOST[:REGISTRY_PORT]/]REPOSITORY[:TAG]</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker tag ubuntu:latest 127.0.0.1:5000/ubuntu:latest<br>$ docker image <span class="hljs-built_in">ls</span><br>REPOSITORY                        TAG                 IMAGE ID            CREATED             VIRTUAL SIZE<br>ubuntu                            latest              ba5877dc9bec        6 weeks ago         192.7 MB<br>127.0.0.1:5000/ubuntu:latest      latest              ba5877dc9bec        6 weeks ago         192.7 MB<br></code></pre></td></tr></table></figure><p>使用 <code>docker push</code> 上传标记的镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker push 127.0.0.1:5000/ubuntu:latest<br>The push refers to repository [127.0.0.1:5000/ubuntu]<br>373a30c24545: Pushed<br>a9148f5200b0: Pushed<br>cdd3de0940ab: Pushed<br>fc56279bbb33: Pushed<br>b38367233d37: Pushed<br>2aebd096e0e2: Pushed<br>latest: digest: sha256:fe4277621f10b5026266932ddf760f5a756d2facd505a94d2da12f4f52f71f5a size: 1568<br></code></pre></td></tr></table></figure><p>用 <code>curl</code> 查看仓库中的镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ curl 127.0.0.1:5000/v2/_catalog<br>&#123;<span class="hljs-string">&quot;repositories&quot;</span>:[<span class="hljs-string">&quot;ubuntu&quot;</span>]&#125;<br><br></code></pre></td></tr></table></figure><p>这里可以看到 <code>&#123;&quot;repositories&quot;:[&quot;ubuntu&quot;]&#125;</code>，表明镜像已经被成功上传了。</p><p>先删除已有镜像，再尝试从私有仓库中下载这个镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>$ docker image <span class="hljs-built_in">rm</span> 127.0.0.1:5000/ubuntu:latest<br><br>$ docker pull 127.0.0.1:5000/ubuntu:latest<br>Pulling repository 127.0.0.1:5000/ubuntu:latest<br>ba5877dc9bec: Download complete<br>511136ea3c5a: Download complete<br>9bad880da3d2: Download complete<br>25f11f5fb0cb: Download complete<br>ebc34468f71d: Download complete<br>2318d26665ef: Download complete<br><br>$ docker image <span class="hljs-built_in">ls</span><br>REPOSITORY                         TAG                 IMAGE ID            CREATED             VIRTUAL SIZE<br>127.0.0.1:5000/ubuntu:latest       latest              ba5877dc9bec        6 weeks ago         192.7 MB<br></code></pre></td></tr></table></figure><h3 id="配置非-https-仓库地址"><a href="#配置非-https-仓库地址" class="headerlink" title="配置非 https 仓库地址"></a>配置非 https 仓库地址</h3><p>如果你不想使用 <code>127.0.0.1:5000</code> 作为仓库地址，比如想让本网段的其他主机也能把镜像推送到私有仓库。你就得把例如 <code>192.168.199.100:5000</code> 这样的内网地址作为私有仓库地址，这时你会发现无法成功推送镜像。</p><p>这是因为 Docker 默认不允许非 <code>HTTPS</code> 方式推送镜像。我们可以通过 Docker 的配置选项来取消这个限制，或者查看下一节配置能够通过 <code>HTTPS</code> 访问的私有仓库。</p><p>对于使用 <code>systemd</code> 的系统，请在 <code>/etc/docker/daemon.json</code> 中写入如下内容（如果文件不存在请新建该文件）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">&#123;<br>  <span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<br>    <span class="hljs-string">&quot;https://hub-mirror.c.163.com&quot;</span>,<br>    <span class="hljs-string">&quot;https://mirror.baidubce.com&quot;</span><br>  ],<br>  <span class="hljs-string">&quot;insecure-registries&quot;</span>: [<br>    <span class="hljs-string">&quot;192.168.199.100:5000&quot;</span><br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：该文件必须符合 <code>json</code> 规范，否则 Docker 将不能启动。</p></blockquote><h2 id="Nexus-3"><a href="#Nexus-3" class="headerlink" title="Nexus 3"></a>Nexus 3</h2><p>使用 Docker 官方的 Registry 创建的仓库面临一些维护问题。比如某些镜像删除以后空间默认是不会回收的，需要一些命令去回收空间然后重启 Registry。在企业中把内部的一些工具包放入 <code>Nexus</code> 中是比较常见的做法，最新版本 <code>Nexus3.x</code> 全面支持 Docker 的私有镜像。所以使用 <a href="https://www.sonatype.com/product/repository-oss-download"><code>Nexus3.x</code></a> 一个软件来管理 <code>Docker</code> , <code>Maven</code> , <code>Yum</code> , <code>PyPI</code> 等是一个明智的选择。</p><h3 id="启动Nexus容器"><a href="#启动Nexus容器" class="headerlink" title="启动Nexus容器"></a>启动Nexus容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -d --name nexus3 --restart=always \<br>    -p 8081:8081 \<br>    --mount src=nexus-data,target=/nexus-data \<br>    sonatype/nexus3<br></code></pre></td></tr></table></figure><p>首次运行需等待 3-5 分钟，你可以使用 <code>docker logs nexus3 -f</code> 查看日志：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker logs nexus3 -f<br><br>2021-03-11 15:31:21,990+0000 INFO  [jetty-main-1] *SYSTEM org.sonatype.nexus.bootstrap.jetty.JettyServer -<br>-------------------------------------------------<br><br>Started Sonatype Nexus OSS 3.30.0-01<br><br>-------------------------------------------------<br></code></pre></td></tr></table></figure><p>如果你看到以上内容，说明 <code>Nexus</code> 已经启动成功，你可以使用浏览器打开 <code>http://YourIP:8081</code> 访问 <code>Nexus</code> 了。</p><p>首次运行请通过以下命令获取初始密码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker <span class="hljs-built_in">exec</span> nexus3 <span class="hljs-built_in">cat</span> /nexus-data/admin.password<br><br>9266139e-41a2-4abb-92ec-e4142a3532cb<br></code></pre></td></tr></table></figure><p>首次启动 Nexus 的默认帐号是 <code>admin</code> ，密码则是上边命令获取到的，点击右上角登录，首次登录需更改初始密码。</p><p>登录之后可以点击页面上方的齿轮按钮按照下面的方法进行设置。</p><h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><p>创建一个私有仓库的方法： <code>Repository-&gt;Repositories</code> 点击右边菜单 <code>Create repository</code> 选择 <code>docker (hosted)</code></p><ul><li><strong>Name</strong>: 仓库的名称</li><li><strong>HTTP</strong>: 仓库单独的访问端口（例如：<strong>5001</strong>）</li><li><strong>Hosted -&gt; Deployment pollcy</strong>: 请选择 <strong>Allow redeploy</strong> 否则无法上传 Docker 镜像。</li></ul><p>其它的仓库创建方法请各位自己摸索，还可以创建一个 <code>docker (proxy)</code> 类型的仓库链接到 DockerHub 上。再创建一个 <code>docker (group)</code> 类型的仓库把刚才的 <code>hosted</code> 与 <code>proxy</code> 添加在一起。主机在访问的时候默认下载私有仓库中的镜像，如果没有将链接到 DockerHub 中下载并缓存到 Nexus 中。</p><h3 id="添加访问权限"><a href="#添加访问权限" class="headerlink" title="添加访问权限"></a>添加访问权限</h3><p>菜单 <code>Security-&gt;Realms</code> 把 Docker Bearer Token Realm 移到右边的框中保存。</p><p>添加用户规则：菜单 <code>Security-&gt;Roles</code>-&gt;<code>Create role</code> 在 <code>Privlleges</code> 选项搜索 docker 把相应的规则移动到右边的框中然后保存。</p><p>添加用户：菜单 <code>Security-&gt;Users</code>-&gt;<code>Create local user</code> 在 <code>Roles</code> 选项中选中刚才创建的规则移动到右边的窗口保存。</p><h3 id="Nginx加密代理"><a href="#Nginx加密代理" class="headerlink" title="Nginx加密代理"></a>Nginx加密代理</h3><p>NGINX 示例配置如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs nginx.conf">upstream register<br>&#123;<br>    server &quot;YourHostName OR IP&quot;:5001; #端口为上面添加私有镜像仓库时设置的 HTTP 选项的端口号<br>    check interval=3000 rise=2 fall=10 timeout=1000 type=http;<br>    check_http_send &quot;HEAD / HTTP/1.0\r\n\r\n&quot;;<br>    check_http_expect_alive http_4xx;<br>&#125;<br><br>server &#123;<br>    server_name YourDomainName;#如果没有 DNS 服务器做解析，请删除此选项使用本机 IP 地址访问<br>    listen       443 ssl;<br><br>    ssl_certificate key/example.crt;<br>    ssl_certificate_key key/example.key;<br><br>    ssl_session_timeout  5m;<br>    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;<br>    ssl_ciphers  HIGH:!aNULL:!MD5;<br>    ssl_prefer_server_ciphers   on;<br>    large_client_header_buffers 4 32k;<br>    client_max_body_size 300m;<br>    client_body_buffer_size 512k;<br>    proxy_connect_timeout 600;<br>    proxy_read_timeout   600;<br>    proxy_send_timeout   600;<br>    proxy_buffer_size    128k;<br>    proxy_buffers       4 64k;<br>    proxy_busy_buffers_size 128k;<br>    proxy_temp_file_write_size 512k;<br><br>    location / &#123;<br>        proxy_set_header Host $host;<br>        proxy_set_header X-Forwarded-Proto $scheme;<br>        proxy_set_header X-Forwarded-Port $server_port;<br>        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;<br>        proxy_http_version 1.1;<br>        proxy_set_header Upgrade $http_upgrade;<br>        proxy_set_header Connection $connection_upgrade;<br>        proxy_redirect off;<br>        proxy_set_header X-Real-IP $remote_addr;<br>        proxy_pass http://register;<br>        proxy_read_timeout 900s;<br><br>    &#125;<br>    error_page   500 502 503 504  /50x.html;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="数据管理"><a href="#数据管理" class="headerlink" title="数据管理"></a>数据管理</h1><h2 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h2><p><code>数据卷</code> 是一个可供一个或多个容器使用的特殊目录，它绕过 UnionFS，可以提供很多有用的特性：</p><ul><li><code>数据卷</code> 可以在容器之间共享和重用</li><li>对 <code>数据卷</code> 的修改会立马生效</li><li>对 <code>数据卷</code> 的更新，不会影响镜像</li><li><code>数据卷</code> 默认会一直存在，即使容器被删除</li></ul><blockquote><p>注意：<code>数据卷</code> 的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会复制到数据卷中（仅数据卷为空时会复制）。</p></blockquote><h3 id="创建数据卷"><a href="#创建数据卷" class="headerlink" title="创建数据卷"></a>创建数据卷</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker volume create my-vol<br></code></pre></td></tr></table></figure><p>查看所有的 <code>数据卷</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker volume <span class="hljs-built_in">ls</span><br><br>DRIVER              VOLUME NAME<br><span class="hljs-built_in">local</span>               my-vol<br></code></pre></td></tr></table></figure><p>在主机里使用以下命令可以查看指定 <code>数据卷</code> 的信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker volume inspect my-vol<br>[<br>    &#123;<br>        <span class="hljs-string">&quot;Driver&quot;</span>: <span class="hljs-string">&quot;local&quot;</span>,<br>        <span class="hljs-string">&quot;Labels&quot;</span>: &#123;&#125;,<br>        <span class="hljs-string">&quot;Mountpoint&quot;</span>: <span class="hljs-string">&quot;/var/lib/docker/volumes/my-vol/_data&quot;</span>,<br>        <span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;my-vol&quot;</span>,<br>        <span class="hljs-string">&quot;Options&quot;</span>: &#123;&#125;,<br>        <span class="hljs-string">&quot;Scope&quot;</span>: <span class="hljs-string">&quot;local&quot;</span><br>    &#125;<br>]<br></code></pre></td></tr></table></figure><h3 id="启动一个挂载数据卷的容器"><a href="#启动一个挂载数据卷的容器" class="headerlink" title="启动一个挂载数据卷的容器"></a>启动一个挂载数据卷的容器</h3><p>在用 <code>docker run</code> 命令的时候，使用 <code>--mount</code> 标记来将 <code>数据卷</code> 挂载到容器里。在一次 <code>docker run</code> 中可以挂载多个 <code>数据卷</code>。</p><p>下面创建一个名为 <code>web</code> 的容器，并加载一个 <code>数据卷</code> 到容器的 <code>/usr/share/nginx/html</code> 目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -d -P \<br>    --name web \<br>    <span class="hljs-comment"># -v my-vol:/usr/share/nginx/html \</span><br>    --mount <span class="hljs-built_in">source</span>=my-vol,target=/usr/share/nginx/html \<br>    nginx:alpine<br></code></pre></td></tr></table></figure><h3 id="查看数据卷信息"><a href="#查看数据卷信息" class="headerlink" title="查看数据卷信息"></a>查看数据卷信息</h3><p>在主机里使用以下命令可以查看 <code>web</code> 容器的信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker inspect web<br></code></pre></td></tr></table></figure><p><code>数据卷</code> 信息在 “Mounts” Key 下面</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-string">&quot;Mounts&quot;</span>: [<br>    &#123;<br>        <span class="hljs-string">&quot;Type&quot;</span>: <span class="hljs-string">&quot;volume&quot;</span>,<br>        <span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;my-vol&quot;</span>,<br>        <span class="hljs-string">&quot;Source&quot;</span>: <span class="hljs-string">&quot;/var/lib/docker/volumes/my-vol/_data&quot;</span>,<br>        <span class="hljs-string">&quot;Destination&quot;</span>: <span class="hljs-string">&quot;/usr/share/nginx/html&quot;</span>,<br>        <span class="hljs-string">&quot;Driver&quot;</span>: <span class="hljs-string">&quot;local&quot;</span>,<br>        <span class="hljs-string">&quot;Mode&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>        <span class="hljs-string">&quot;RW&quot;</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-string">&quot;Propagation&quot;</span>: <span class="hljs-string">&quot;&quot;</span><br>    &#125;<br>],<br></code></pre></td></tr></table></figure><h3 id="删除数据卷"><a href="#删除数据卷" class="headerlink" title="删除数据卷"></a>删除数据卷</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker volume <span class="hljs-built_in">rm</span> my-vol<br></code></pre></td></tr></table></figure><p><code>数据卷</code> 是被设计用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除 <code>数据卷</code>，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的 <code>数据卷</code>。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 <code>docker rm -v</code> 这个命令。</p><p>无主的数据卷可能会占据很多空间，要清理请使用以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker volume prune<br></code></pre></td></tr></table></figure><h2 id="挂载主机目录"><a href="#挂载主机目录" class="headerlink" title="挂载主机目录"></a>挂载主机目录</h2><h3 id="挂载主机目录作为数据卷"><a href="#挂载主机目录作为数据卷" class="headerlink" title="挂载主机目录作为数据卷"></a>挂载主机目录作为数据卷</h3><p>使用 <code>--mount</code> 标记可以指定挂载一个本地主机的目录到容器中去。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -d -P \<br>    --name web \<br>    <span class="hljs-comment"># -v /src/webapp:/usr/share/nginx/html \</span><br>    --mount <span class="hljs-built_in">type</span>=<span class="hljs-built_in">bind</span>,<span class="hljs-built_in">source</span>=/src/webapp,target=/usr/share/nginx/html \<br>    nginx:alpine<br></code></pre></td></tr></table></figure><p>上面的命令加载主机的 <code>/src/webapp</code> 目录到容器的 <code>/usr/share/nginx/html</code>目录。这个功能在进行测试的时候十分方便，比如用户可以放置一些程序到本地目录中，来查看容器是否正常工作。本地目录的路径必须是绝对路径，以前使用 <code>-v</code> 参数时如果本地目录不存在 Docker 会自动为你创建一个文件夹，现在使用 <code>--mount</code> 参数时如果本地目录不存在，Docker 会报错。</p><p>Docker 挂载主机目录的默认权限是 <code>读写</code>，用户也可以通过增加 <code>readonly</code> 指定为 <code>只读</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -d -P \<br>    --name web \<br>    <span class="hljs-comment"># -v /src/webapp:/usr/share/nginx/html:ro \</span><br>    --mount <span class="hljs-built_in">type</span>=<span class="hljs-built_in">bind</span>,<span class="hljs-built_in">source</span>=/src/webapp,target=/usr/share/nginx/html,<span class="hljs-built_in">readonly</span> \<br>    nginx:alpine<br></code></pre></td></tr></table></figure><p>加了 <code>readonly</code> 之后，就挂载为 <code>只读</code> 了。如果你在容器内 <code>/usr/share/nginx/html</code> 目录新建文件，会显示如下错误</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">/usr/share/nginx/html <span class="hljs-comment"># touch new.txt</span><br><span class="hljs-built_in">touch</span>: new.txt: Read-only file system<br></code></pre></td></tr></table></figure><h3 id="查看数据卷具体信息"><a href="#查看数据卷具体信息" class="headerlink" title="查看数据卷具体信息"></a>查看数据卷具体信息</h3><p>在主机里使用以下命令可以查看 <code>web</code> 容器的信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker inspect web<br></code></pre></td></tr></table></figure><p><code>挂载主机目录</code> 的配置信息在 “Mounts” Key 下面</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-string">&quot;Mounts&quot;</span>: [<br>    &#123;<br>        <span class="hljs-string">&quot;Type&quot;</span>: <span class="hljs-string">&quot;bind&quot;</span>,<br>        <span class="hljs-string">&quot;Source&quot;</span>: <span class="hljs-string">&quot;/src/webapp&quot;</span>,<br>        <span class="hljs-string">&quot;Destination&quot;</span>: <span class="hljs-string">&quot;/usr/share/nginx/html&quot;</span>,<br>        <span class="hljs-string">&quot;Mode&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>        <span class="hljs-string">&quot;RW&quot;</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-string">&quot;Propagation&quot;</span>: <span class="hljs-string">&quot;rprivate&quot;</span><br>    &#125;<br>],<br></code></pre></td></tr></table></figure><h3 id="挂载一个本地主机文件作为数据卷"><a href="#挂载一个本地主机文件作为数据卷" class="headerlink" title="挂载一个本地主机文件作为数据卷"></a>挂载一个本地主机文件作为数据卷</h3><p><code>--mount</code> 标记也可以从主机挂载单个文件到容器中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run --<span class="hljs-built_in">rm</span> -it \<br>   <span class="hljs-comment"># -v $HOME/.bash_history:/root/.bash_history \</span><br>   --mount <span class="hljs-built_in">type</span>=<span class="hljs-built_in">bind</span>,<span class="hljs-built_in">source</span>=<span class="hljs-variable">$HOME</span>/.bash_history,target=/root/.bash_history \<br>   ubuntu:18.04 \<br>   bash<br><br>root@2affd44b4667:/<span class="hljs-comment"># history</span><br>1  <span class="hljs-built_in">ls</span><br>2  diskutil list<br></code></pre></td></tr></table></figure><p>这样就可以记录在容器输入过的命令了。</p><h1 id="使用网络"><a href="#使用网络" class="headerlink" title="使用网络"></a>使用网络</h1><h2 id="外部访问容器"><a href="#外部访问容器" class="headerlink" title="外部访问容器"></a>外部访问容器</h2><p>容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 <code>-P</code> 或 <code>-p</code> 参数来指定端口映射。</p><p>当使用 <code>-P</code> 标记时，Docker 会随机映射一个端口到内部容器开放的网络端口。</p><p>使用 <code>docker container ls</code> 可以看到，本地主机的 32768 被映射到了容器的 80 端口。此时访问本机的 32768 端口即可访问容器内 NGINX 默认页面。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -d -P nginx:alpine<br><br>$ docker container <span class="hljs-built_in">ls</span> -l<br>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                   NAMES<br>fae320d08268        nginx:alpine        <span class="hljs-string">&quot;/docker-entrypoint.…&quot;</span>   24 seconds ago      Up 20 seconds       0.0.0.0:32768-&gt;80/tcp   bold_mcnulty<br></code></pre></td></tr></table></figure><p>同样的，可以通过 <code>docker logs</code> 命令来查看访问记录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker logs fa<br>172.17.0.1 - - [25/Aug/2020:08:34:04 +0000] <span class="hljs-string">&quot;GET / HTTP/1.1&quot;</span> 200 612 <span class="hljs-string">&quot;-&quot;</span> <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:80.0) Gecko/20100101 Firefox/80.0&quot;</span> <span class="hljs-string">&quot;-&quot;</span><br></code></pre></td></tr></table></figure><p><code>-p</code> 则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有 <code>ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort</code>。</p><h3 id="映射所有接口地址"><a href="#映射所有接口地址" class="headerlink" title="映射所有接口地址"></a>映射所有接口地址</h3><p>使用 <code>hostPort:containerPort</code> 格式本地的 80 端口映射到容器的 80 端口，可以执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -d -p 80:80 nginx:alpine<br></code></pre></td></tr></table></figure><p>此时默认会绑定本地所有接口上的所有地址。</p><h3 id="映射到指定地址的指定端口"><a href="#映射到指定地址的指定端口" class="headerlink" title="映射到指定地址的指定端口"></a>映射到指定地址的指定端口</h3><p>可以使用 <code>ip:hostPort:containerPort</code> 格式指定映射使用一个特定地址，比如 localhost 地址 127.0.0.1</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -d -p 127.0.0.1:80:80 nginx:alpine<br></code></pre></td></tr></table></figure><h3 id="映射到指定地址的任意端口"><a href="#映射到指定地址的任意端口" class="headerlink" title="映射到指定地址的任意端口"></a>映射到指定地址的任意端口</h3><p>使用 <code>ip::containerPort</code> 绑定 localhost 的任意端口到容器的 80 端口，本地主机会自动分配一个端口。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -d -p 127.0.0.1::80 nginx:alpine<br></code></pre></td></tr></table></figure><p>还可以使用 <code>udp</code> 标记来指定 <code>udp</code> 端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -d -p 127.0.0.1:80:80/udp nginx:alpine<br></code></pre></td></tr></table></figure><h3 id="查看映射端口配置"><a href="#查看映射端口配置" class="headerlink" title="查看映射端口配置"></a>查看映射端口配置</h3><p>使用 <code>docker port</code> 来查看当前映射的端口配置，也可以查看到绑定的地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker port fa 80<br>0.0.0.0:32768<br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>容器有自己的内部网络和 ip 地址（使用 <code>docker inspect</code> 查看，Docker 还可以有一个可变的网络配置。）</li><li><code>-p</code> 标记可以多次使用来绑定多个端口</li></ul><p>例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -d \<br>    -p 80:80 \<br>    -p 443:443 \<br>    nginx:alpine<br></code></pre></td></tr></table></figure><h2 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h2><p>如果你之前有 <code>Docker</code> 使用经验，你可能已经习惯了使用 <code>--link</code> 参数来使容器互联。</p><p>随着 Docker 网络的完善，强烈建议大家将容器加入自定义的 Docker 网络来连接多个容器，而不是使用 <code>--link</code> 参数。</p><h3 id="新建网络"><a href="#新建网络" class="headerlink" title="新建网络"></a>新建网络</h3><p>下面先创建一个新的 Docker 网络。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker network create -d bridge my-net<br></code></pre></td></tr></table></figure><p><code>-d</code> 参数指定 Docker 网络类型，有 <code>bridge</code> <code>overlay</code>。其中 <code>overlay</code> 网络类型用于 <a href="https://yeasy.gitbook.io/docker_practice/swarm_mode">Swarm mode</a>，在本小节中你可以忽略它。</p><h3 id="连接容器"><a href="#连接容器" class="headerlink" title="连接容器"></a>连接容器</h3><p>运行一个容器并连接到新建的 <code>my-net</code> 网络</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -it --<span class="hljs-built_in">rm</span> --name busybox1 --network my-net busybox sh<br></code></pre></td></tr></table></figure><p>打开新的终端，再运行一个容器并加入到 <code>my-net</code> 网络</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -it --<span class="hljs-built_in">rm</span> --name busybox2 --network my-net busybox sh<br></code></pre></td></tr></table></figure><p>再打开一个新的终端查看容器信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container <span class="hljs-built_in">ls</span><br><br>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES<br>b47060aca56b        busybox             <span class="hljs-string">&quot;sh&quot;</span>                11 minutes ago      Up 11 minutes                           busybox2<br>8720575823ec        busybox             <span class="hljs-string">&quot;sh&quot;</span>                16 minutes ago      Up 16 minutes                           busybox1<br></code></pre></td></tr></table></figure><p>下面通过 <code>ping</code> 来证明 <code>busybox1</code> 容器和 <code>busybox2</code> 容器建立了互联关系。</p><p>在 <code>busybox1</code> 容器输入以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">/ <span class="hljs-comment"># ping busybox2</span><br>PING busybox2 (172.19.0.3): 56 data bytes<br>64 bytes from 172.19.0.3: <span class="hljs-built_in">seq</span>=0 ttl=64 time=0.072 ms<br>64 bytes from 172.19.0.3: <span class="hljs-built_in">seq</span>=1 ttl=64 time=0.118 ms<br></code></pre></td></tr></table></figure><p>用 ping 来测试连接 <code>busybox2</code> 容器，它会解析成 <code>172.19.0.3</code>。</p><p>同理在 <code>busybox2</code> 容器执行 <code>ping busybox1</code>，也会成功连接到。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">/ <span class="hljs-comment"># ping busybox1</span><br>PING busybox1 (172.19.0.2): 56 data bytes<br>64 bytes from 172.19.0.2: <span class="hljs-built_in">seq</span>=0 ttl=64 time=0.064 ms<br>64 bytes from 172.19.0.2: <span class="hljs-built_in">seq</span>=1 ttl=64 time=0.143 ms<br></code></pre></td></tr></table></figure><p>这样，<code>busybox1</code> 容器和 <code>busybox2</code> 容器建立了互联关系。</p><h3 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h3><p>如果你有多个容器之间需要互相连接，推荐使用 Docker Compose。不过目前够用了，后期有需要再详细研究。</p><h2 id="配置DNS"><a href="#配置DNS" class="headerlink" title="配置DNS"></a>配置DNS</h2><p>如何自定义配置容器的主机名和 DNS 呢？秘诀就是 Docker 利用虚拟文件来挂载容器的 3 个相关配置文件。</p><p>在容器中使用 <code>mount</code> 命令可以看到挂载信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ mount<br>/dev/disk/by-uuid/1fec...ebdf on /etc/hostname <span class="hljs-built_in">type</span> ext4 ...<br>/dev/disk/by-uuid/1fec...ebdf on /etc/hosts <span class="hljs-built_in">type</span> ext4 ...<br>tmpfs on /etc/resolv.conf <span class="hljs-built_in">type</span> tmpfs ...<br></code></pre></td></tr></table></figure><p>这种机制可以让宿主主机 DNS 信息发生更新后，所有 Docker 容器的 DNS 配置通过 <code>/etc/resolv.conf</code> 文件立刻得到更新。</p><p>配置全部容器的 DNS ，也可以在 <code>/etc/docker/daemon.json</code> 文件中增加以下内容来设置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">&#123;<br>  <span class="hljs-string">&quot;dns&quot;</span> : [<br>    <span class="hljs-string">&quot;114.114.114.114&quot;</span>,<br>    <span class="hljs-string">&quot;8.8.8.8&quot;</span><br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p>这样每次启动的容器 DNS 自动配置为 <code>114.114.114.114</code> 和 <code>8.8.8.8</code>。使用以下命令来证明其已经生效。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -it --<span class="hljs-built_in">rm</span> ubuntu:18.04  <span class="hljs-built_in">cat</span> etc/resolv.conf<br><br>nameserver 114.114.114.114<br>nameserver 8.8.8.8<br></code></pre></td></tr></table></figure><p>如果用户想要手动指定容器的配置，可以在使用 <code>docker run</code> 命令启动容器时加入如下参数：</p><p><code>-h HOSTNAME</code> 或者 <code>--hostname=HOSTNAME</code> 设定容器的主机名，它会被写到容器内的 <code>/etc/hostname</code> 和 <code>/etc/hosts</code>。但它在容器外部看不到，既不会在 <code>docker container ls</code> 中显示，也不会在其他的容器的 <code>/etc/hosts</code> 看到。</p><p><code>--dns=IP_ADDRESS</code> 添加 DNS 服务器到容器的 <code>/etc/resolv.conf</code> 中，让容器用这个服务器来解析所有不在 <code>/etc/hosts</code> 中的主机名。</p><p><code>--dns-search=DOMAIN</code> 设定容器的搜索域，当设定搜索域为 <code>.example.com</code> 时，在搜索一个名为 host 的主机时，DNS 不仅搜索 host，还会搜索 <code>host.example.com</code>。</p><blockquote><p>注意：如果在容器启动时没有指定最后两个参数，Docker 会默认用主机上的 <code>/etc/resolv.conf</code> 来配置容器。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>maven使用教程</title>
    <link href="/posts/cc2d81c9/"/>
    <url>/posts/cc2d81c9/</url>
    
    <content type="html"><![CDATA[<h1 id="下载maven"><a href="#下载maven" class="headerlink" title="下载maven"></a>下载maven</h1><p>1.进入<a href="https://maven.apache.org/download.cgi">官网</a>下载需要的版本 </p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151402306.png"></p><h1 id="安装maven"><a href="#安装maven" class="headerlink" title="安装maven"></a>安装maven</h1><p>将下载的压缩包解压到<strong>非中文、没有空格</strong>的目录 , 在解压目录中，我们需要着重关注Maven的核心配置文件：conf&#x2F;settings.xml</p><h1 id="创建本地仓库"><a href="#创建本地仓库" class="headerlink" title="创建本地仓库"></a>创建本地仓库</h1><p>本地仓库这个目录，我们手动创建一个空的目录即可。</p><h1 id="指定本地仓库"><a href="#指定本地仓库" class="headerlink" title="指定本地仓库"></a>指定本地仓库</h1><p>本地仓库默认值：用户家目录&#x2F;.m2&#x2F;repository。由于本地仓库的默认位置是在用户的家目录下，而家目录往往是在C盘，也就是系统盘。将来Maven仓库中jar包越来越多，仓库体积越来越大，可能会拖慢C盘运行速度，影响系统性能。所以建议将Maven的本地仓库放在其他盘符下。</p><p>配置方式如下：<br>打开maven里的conf文件，打开setings.xml文件，配置本地仓库文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- localRepository</span><br><span class="hljs-comment">| The path to the local repository maven will use to store artifacts.</span><br><span class="hljs-comment">|</span><br><span class="hljs-comment">| Default: $&#123;user.home&#125;/.m2/repository</span><br><span class="hljs-comment">&lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">localRepository</span>&gt;</span>D:\mavenRepository<span class="hljs-tag">&lt;/<span class="hljs-name">localRepository</span>&gt;</span><br><span class="hljs-comment">&lt;!--mavenRepository是自己创建的仓库名--&gt;</span><br></code></pre></td></tr></table></figure><p><strong>记住</strong>：一定要把localRepository标签<strong>从注释中拿出来</strong>。</p><p><strong>注意</strong>：本地仓库本身也需要使用一个<strong>非中文、没有空格</strong>的目录。</p><h1 id="配置镜像仓库"><a href="#配置镜像仓库" class="headerlink" title="配置镜像仓库"></a>配置镜像仓库</h1><blockquote><p>为什么要配置阿里云提供的镜像仓库？</p></blockquote><p>Maven下载jar包默认访问境外的中央仓库，速度很慢。改成阿里云提供的镜像仓库，访问国内网站，可以让Maven下载jar包的时候速度更快。</p><p>配置的方式是：</p><p>打开maven里的conf文件，打开setings.xml文件，</p><p>将下面mirror标签整体复制到mirrors标签的内部。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mirrors</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>nexus-aliyun<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>central<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Nexus aliyun<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mirrors</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="配置maven工厂的基础JDK版本"><a href="#配置maven工厂的基础JDK版本" class="headerlink" title="配置maven工厂的基础JDK版本"></a>配置maven工厂的基础JDK版本</h1><blockquote><p>如果按照默认配置运行，Java工程使用的JDK版本是1.5。</p></blockquote><p>配置的方式是：</p><p>打开maven里的conf文件，打开setings.xml文件，</p><p>将profile标签整个复制到profiles标签内。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">profiles</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>jdk-1.8<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">activation</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">activeByDefault</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">activeByDefault</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">jdk</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">jdk</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">activation</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.compilerVersion</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">profiles</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h1><blockquote><p>Maven是一个用Java语言开发的程序，它必须基于JDK来运行，需要通过JAVA_HOME来找到JDK的安装位置。</p></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151405660.png"></p><p>可以使用下面的命令验证：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">C:\Users\Administrator&gt;echo %JAVA_HOME%<br>D:\software\Java<br>C:\Users\Administrator&gt;java -version<br>java version &quot;1.8.0_141&quot;<br>Java(TM) SE Runtime Environment (build 1.8.0_141-b15)<br>Java HotSpot(TM) 64-Bit Server VM (build 25.141-b15, mixed mode)<br></code></pre></td></tr></table></figure><h1 id="配置MAVEN-HOME"><a href="#配置MAVEN-HOME" class="headerlink" title="配置MAVEN_HOME"></a>配置MAVEN_HOME</h1><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151406492.png"></p><p>配置环境变量的规律：</p><p>XXX_HOME指向的是bin目录的上一级</p><p>PATH指向的是bin目录</p><p><strong>配置path：</strong></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151406834.png"></p><p><strong>验证：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">C:\Users\Administrator&gt;mvn -v<br>Apache Maven 3.5.4 (1edded0938998edf8bf061f1ceb3cfdeccf443fe; 2018-06-18T02:33:14+08:00)<br>Maven home: D:\software\apache-maven-3.5.4\bin\..<br>Java version: 1.8.0_141, vendor: Oracle Corporation, runtime: D:\software\Java\jre<br>Default locale: zh_CN, platform encoding: GBK<br>OS name: &quot;windows 10&quot;, version: &quot;10.0&quot;, arch: &quot;amd64&quot;, family: &quot;windows&quot;<br></code></pre></td></tr></table></figure><h1 id="仓库和坐标"><a href="#仓库和坐标" class="headerlink" title="仓库和坐标"></a>仓库和坐标</h1><h2 id="maven仓库"><a href="#maven仓库" class="headerlink" title="maven仓库"></a>maven仓库</h2><p>maven的仓库就是maven存放jar包的位置，主要分为如下三类仓库</p><table><thead><tr><th>仓库名称</th><th>作用</th></tr></thead><tbody><tr><td>本地仓库</td><td>相当于缓存，工程第一次会从远程仓库（互联网）去下载jar 包，将jar包存在本地仓库（在程序员的电脑上）。第二次不需要从远程仓库去下载。先从本地仓库找，如果找不到才会去远程仓库找。</td></tr><tr><td>中央仓库</td><td>仓库中jar由专业团队（maven团队）统一维护。中央仓库的地址：<a href="https://link.zhihu.com/?target=https://repo1.maven.org/maven2/">https://repo1.maven.org/maven2/</a></td></tr><tr><td>远程仓库</td><td>在公司内部架设一台私服，其它公司架设一台仓库，对外公开。</td></tr></tbody></table><h2 id="maven坐标"><a href="#maven坐标" class="headerlink" title="maven坐标"></a>maven坐标</h2><p>Maven的一个核心的作用就是管理项目的依赖，引入我们所需的各种jar包等。为了能自动化的解析任何一个Java构件，Maven必须将这些Jar包或者其他资源进行唯一标识，这是管理项目的依赖的基础，也就是我们要说的坐标。包括我们自己开发的项目，也是要通过坐标进行唯一标识的，这样才能在其它项目中进行依赖引用。坐标的定义元素如下：</p><ul><li>groupId:项目组织唯一的标识符，实际对应JAVA的包的结构 (一般写公司的组织名称 eg:com.itee,com.alibaba)</li><li>artifactId: 项目的名称</li><li>version：定义项目的当前版本</li></ul><p>例如：要引入druid，只需要在pom.xml配置文件中配置引入druid的坐标即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependecies</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--druid连接池--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.9<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastjson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.39<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependecies</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="在idea中集成maven"><a href="#在idea中集成maven" class="headerlink" title="在idea中集成maven"></a>在idea中集成maven</h1><p><strong>1. 配置maven软件的安装路径和本地仓库路径</strong></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151408008.png"></p><p><strong>配置Maven的Runner参数</strong></p><p>参数一: -DarchetypeCatalog&#x3D;internal 解决使用骨架构建Maven项目时候会卡住的问题</p><p>参数二: -Dfile.encoding&#x3D;GB2312 解决Maven工程中控制台输出中文乱码的问题</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151408832.png"></p><p><strong>注意事项:</strong></p><p>上述配置如果是在settings中进行配置则只会对当前Project生效，后续创建的新的Project不会生效</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151409913.png"></p><p>如果是在New Projects Setup里面的setting for new projects中配置，则会对后续创建的所有新的Project都生效，但是无法对当前项目生效。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151409245.png"></p><h1 id="maven构建命令"><a href="#maven构建命令" class="headerlink" title="maven构建命令"></a>maven构建命令</h1><p>执行Maven构建命令有两种方式:</p><ol><li>如果是自己使用IDEA创建的Maven工程，可以自己直接在IDEA的Maven面板上执行相应的构建命令</li><li>如果是该项目是从其它地方拷贝过来的，并且没有在IDEA上打开，则可以使用命令行来进行Maven构建</li></ol><p><strong>注意事项:</strong></p><p>运行Maven中和构建操作相关的命令时，必须进入到pom.xml所在的目录。如果没有在pom.xml所在的目录运行Maven的构建命令，那么会看到下面的错误信息：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">The goal you specified requires a project to execute but there is no POM in this directory<br></code></pre></td></tr></table></figure><h2 id="清理-clean"><a href="#清理-clean" class="headerlink" title="清理 clean"></a>清理 clean</h2><p>mvn clean命令是清除项目的编译内容，具体的效果是删除target目录</p><h2 id="编译-compile"><a href="#编译-compile" class="headerlink" title="编译 compile"></a>编译 compile</h2><p>compile命令是对工程进行编译，具体效果是产生target目录，而编译又分为: 编译主程序和编译测试程序</p><h3 id="编译主程序"><a href="#编译主程序" class="headerlink" title="编译主程序"></a>编译主程序</h3><p>mvn compile 命令是编译主程序，主程序编译之后的文件会生成在 target&#x2F;classes 目录中</p><h3 id="编译测试程序"><a href="#编译测试程序" class="headerlink" title="编译测试程序"></a>编译测试程序</h3><p>mvn test-compile 命令是编译测试程序，测试程序编译之后的文件会生成在 target&#x2F;test-classes 目录中</p><h2 id="执行测试-test"><a href="#执行测试-test" class="headerlink" title="执行测试 test"></a>执行测试 test</h2><p>mvn test会执行测试程序中的所有测试用例，并且将生成的测试报告存放在target&#x2F;surefire-reports目录下。</p><p>在执行mvn test命令的过程中，会自动先执行mvn clean、mvn compile、mvn test-compile，然后再执行mvn test进行测试</p><h2 id="打包-package"><a href="#打包-package" class="headerlink" title="打包 package"></a>打包 package</h2><p>mvn package命令会对程序进行打包，如果是javase工程会打成jar包，而javaweb工程则会打成war包，打包得到的结果会生成在target目录中</p><p>在执行mvn package命令的过程中，会自动先执行mvn clean、mvn compile、mvn test-compile、mvn test，然后再执行mvn package进行打包</p><h2 id="安装-install"><a href="#安装-install" class="headerlink" title="安装 install"></a>安装 install</h2><p>mvn install 命令会将程序打成的包安装到本地仓库(针对jar包，war包安装到本地仓库意义不大)</p><p>在执行mvn install命令的过程中，会自动先执行mvn clean、mvn compile、mvn test-compile、mvn test、mvn package，然后再执行mvn package进行打包</p><p>安装的效果是将本地构建过程中生成的jar包存入Maven本地仓库。这个jar包在Maven仓库中的路径是根据它的坐标生成的。</p><p>坐标信息如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fm.maven<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>pro01-maven-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在Maven仓库中生成的路径如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">D:\mavenRepository\com\fm\maven\pro01-maven-java\1.0-SNAPSHOT\pro01-maven-java-1.0-SNAPSHOT.jar<br></code></pre></td></tr></table></figure><p>另外，安装操作还会将pom.xml文件转换为XXX.pom文件一起存入本地仓库。所以我们在Maven的本地仓库中想看一个jar包原始的pom.xml文件时，查看对应XXX.pom文件即可，它们是名字发生了改变，本质上是同一个文件。</p><h1 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h1><h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><p>在maven项目中，我们只需要通过jar包的maven坐标去引入jar包就可以了，而不需要像之前一样手动导入jar包。至于每一个jar包的坐标到底怎么写，我们不需要记忆，写代码的时候可以直接复制，如果需要查找则可以到<a href="https://link.zhihu.com/?target=http://mvnrepository.com/">http://mvnrepository.com/</a>网站查找即可</p><p>例如，引入单元测试的依赖:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>      <br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>       <br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>    <br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>当前项目的所有依赖都是放在<code>&lt;dependencies&gt;</code>标签里面，而具体每一个jar包的坐标则是放在一个<code>&lt;dependency&gt;</code>标签中</p><h2 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h2><p><code>&lt;scope&gt;</code>标签表示依赖的范围，它的位置是在dependencies&#x2F;dependency&#x2F;scope，该标签中的值可以是compile、test、provided、runtime这四个值中的一个，如果没有手动指定依赖范围，那么依赖范围默认是compile</p><p><strong>四种依赖范围的对比</strong></p><table><thead><tr><th>依赖范围</th><th>main目录（空间）</th><th>test目录（空间）</th><th>编译阶段（时间）</th><th>运行阶段（时间）</th></tr></thead><tbody><tr><td>compile</td><td>有效</td><td>有效</td><td>有效</td><td>有效</td></tr><tr><td>test</td><td>无效</td><td>有效</td><td>有效</td><td>无效</td></tr><tr><td>provided</td><td>有效</td><td>有效</td><td>有效</td><td>无效</td></tr><tr><td>runtime</td><td>无效</td><td>无效</td><td>无效</td><td>有效</td></tr></tbody></table><ol><li>compile: 该范围的依赖既可以在main目录使用，又可以在test目录使用，即在编译阶段使用，又在实际运行阶段使用(会打到war&#x2F;jar包中)，通常使用的第三方框架的jar包这样在项目实际运行时真正要用到的jar包都是以compile范围进行依赖的。比如SSM框架所需jar包。</li><li>test: 该范围的依赖只能在test目录中使用，不能在main目录中使用，只能在编译阶段使用，无法在项目运行阶段使用(不会打到war&#x2F;jar包中)，引入junit单元测试依赖的时候会使用该范围</li><li>provided: 该范围的依赖即可在main目录使用，又可以在test目录使用，但是它只能在编译阶段使用，无法在项目运行阶段使用(不会打到war&#x2F;jar包中)。比如说Tomcat服务器中内置有servlet-api、jsp-api等等依赖，所以我们在项目中引入这些依赖的时候的目标仅仅是<strong>让我们的代码编译通过</strong>， 为了避免和服务器上已有的同类jar包产生冲突，同时减轻服务器的负担我们<strong>不会选择将这些依赖打到war包中</strong>。说白了就是：“服务器上已经有了，你就别带啦！”</li><li>runtime: 该范围的依赖既不可在main目录使用，又不可在test目录使用，说白了就是它无法在编译阶段使用，只能在项目运行阶段使用(会打到war&#x2F;jar包中)。比如说MySQL驱动的依赖，我们在开发(写代码)的过程中根本不需要使用MySQL驱动中的任何类(因为都是直接用的JDBC接口)，只在运行阶段需要MySQL驱动的依赖，所以我们就可以将MySQL驱动的范围指定为runtime这样能有助于提升编译效率</li></ol><h2 id="依赖的传递性和排除"><a href="#依赖的传递性和排除" class="headerlink" title="依赖的传递性和排除"></a>依赖的传递性和排除</h2><h3 id="依赖的传递性"><a href="#依赖的传递性" class="headerlink" title="依赖的传递性"></a>依赖的传递性</h3><p>依赖的传递性指的是: A依赖B，B依赖C，那么在A没有配置对C的依赖的情况下，A里面能不能直接使用C。 在A依赖B，B依赖C的前提下，C是否能够传递到A，取决于B依赖C时使用的依赖范围。</p><ul><li>B依赖C时使用compile范围：可以传递</li><li>B依赖C时使用test或provided范围：不能传递，所以需要这样的jar包时，就必须在需要的地方明确配置依赖才可以。</li></ul><h3 id="依赖的排除"><a href="#依赖的排除" class="headerlink" title="依赖的排除"></a>依赖的排除</h3><p>当A依赖B，B依赖C而且C可以传递到A的时候，但是A不想要C，需要在A里面把C排除掉。而往往这种情况都是为了避免jar包之间的冲突。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151412051.png"></p><p>所以配置依赖的排除其实就是阻止某些jar包的传递。因为这样的jar包传递过来会和其他jar包冲突。</p><p><strong>如何排除</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-beans<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.2.4.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br>  <span class="hljs-comment">&lt;!--直接排除--&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>     <br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>   <br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>     <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>   <br>  <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="自定义属性"><a href="#自定义属性" class="headerlink" title="自定义属性"></a>自定义属性</h1><p>在pom.xml文件中的<code>&lt;properties&gt;</code>标签中添加子标签进行自定义属性，子标签的标签名就是属性名，子标签的标签体的内容就是属性值，例如:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">fm.username</span>&gt;</span>tom<span class="hljs-tag">&lt;/<span class="hljs-name">fm.username</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br></code></pre></td></tr></table></figure><p>那么我们在pom.xml中就可以使用${属性名}来获取属性值</p><h1 id="版本锁定"><a href="#版本锁定" class="headerlink" title="版本锁定"></a>版本锁定</h1><p>因为父工程在管理项目依赖的时候，需要管理非常多的依赖，而有很多依赖的版本都应该是相同的，比如spring框架的相关依赖都需要统一版本。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span>   <br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>     <br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>     <br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span> <br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>   <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>      <br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-beans<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>     <br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>   <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>      <br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>     <br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>      <br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>     <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>   <br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>       <br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>     <br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-expression<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>     <br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>   <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>   <br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>   <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果未进行版本锁定的话，我们修改spring框架的版本的时候，就需要手动将每一个依赖的版本都进行修改，这无疑是非常麻烦而且容易出错的操作</p><p>所谓版本锁定就是自定义一个属性，属性值就是要统一的版本，然后在<code>&lt;version&gt;</code>标签体中引入该属性值就行了。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">fm.spring.version</span>&gt;</span>4.0.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">fm.username</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;fm.spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-beans<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;fm.spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;fm.spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-expression<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;fm.spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;fm.spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br><span class="hljs-comment">&lt;!--进行版本锁定之后，如果有修改依赖版本的需求，则只需要取修改自定义属性的值就可以了--&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>maven</category>
      
    </categories>
    
    
    <tags>
      
      <tag>maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git使用指北</title>
    <link href="/posts/2581ce52/"/>
    <url>/posts/2581ce52/</url>
    
    <content type="html"><![CDATA[<blockquote><p>日常工作中，git操作不可或缺，一些常用命令已经充分熟练使用，不过一些配置还是需要用到的时候在看一眼，所幸就自己记录下来，再过一遍，加深印象。</p></blockquote><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="什么是git"><a href="#什么是git" class="headerlink" title="什么是git"></a>什么是git</h2><p>Git（读音为&#x2F;gɪt&#x2F;）是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。也是Linus Torvalds为了帮助管理Linux内核开发而开发的一个开放源码的版本控制软件。</p><h2 id="使用git能做什么"><a href="#使用git能做什么" class="headerlink" title="使用git能做什么"></a>使用git能做什么</h2><p>代码回溯：Git在管理文件过程中会记录日志，方便回退到历史版本。<br>版本切换：Git存在分支的概念，一个项目可以有多个分支（版本），可以任意切换。<br>多人协作：Git支持多人协作，即一个团队共同开发一个项目，每个团队成员负责一部分代码，通过Git就可以管理和协调。<br>远程备份：Git通过仓库管理文件，在Git中存在远程仓库，如果本地文件丢失还可以从远程仓库获取。</p><h2 id="git常用命令汇总"><a href="#git常用命令汇总" class="headerlink" title="git常用命令汇总"></a>git常用命令汇总</h2><p>git status查看文件状态<br>git add 文件名称将文件的修改加入暂存区<br>①git reset 文件名将暂存区的文件取消暂存<br>②git reset –hard “版本号”将暂存区的文件切换到指定版本<br>git commit -m “备注信息” 文件名将暂存区的文件修改提交到版本库<br>git log查看日志<br>git remote查看远程仓库<br>git remote add 远程仓库简称 远程仓库地址把本地仓库添加到远程<br>git clone “远程仓库地址”从远程仓库克隆<br>git push 远程仓库简称 分支名称将分支推送到远程<br>git pull从远程仓库拉取<br>git branch列出所有本地分支<br>git branch -r列出所有远程分支<br>git branch -a列出所有本地分支和远程分支<br>git checkout 分支名称切换分支<br>git merge 分支名称将两个分支文件进行合并<br>git tag查看标签<br>git tag 标签名称创建标签<br>git push origin 分支名称将标签推送到远程仓库<br>git checkout -b 分支名 标签名检出标签</p><h1 id="git概述"><a href="#git概述" class="headerlink" title="git概述"></a>git概述</h1><h2 id="git简介"><a href="#git简介" class="headerlink" title="git简介"></a>git简介</h2><p>Git 是一个分布式版本控制工具，通常用来对软件开发过程中的源代码文件进行管理。通过Git 仓库来存储和管理这些文件，Git仓库分为两种：</p><ul><li>本地仓库：开发人员自己电脑上的 Git 仓库</li><li>远程仓库：远程服务器上的 Git 仓库</li><li><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151114525.png"></li></ul><p>commit：提交,将本地文件和版本信息保存到本地仓库<br>push：推送,将本地仓库文件和版本信息上传到远程仓库<br>pull：拉取,将远程仓库文件和版本信息下载到本地仓库</p><h1 id="git常用命令"><a href="#git常用命令" class="headerlink" title="git常用命令"></a>git常用命令</h1><h2 id="git全局设置"><a href="#git全局设置" class="headerlink" title="git全局设置"></a>git全局设置</h2><p>当安装Git后首先要做的事情是设置用户名称和email地址。这是非常重要的，因为每次Git提交都会使用该用户信息。在Git 命令行中执行下面命令：  </p><p>设置用户信息</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.name</span> <span class="hljs-string">&quot;aaa&quot;</span> <br>git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.email</span> <span class="hljs-string">&quot;aaa.email&quot;</span><br></code></pre></td></tr></table></figure><p>查看配置信息</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">git <span class="hljs-built_in">config</span> <span class="hljs-comment">--list</span><br></code></pre></td></tr></table></figure><h2 id="获取git仓库"><a href="#获取git仓库" class="headerlink" title="获取git仓库"></a>获取git仓库</h2><p>要使用Git对我们的代码进行管理，首先需要获得Git仓库。<br>获取Git仓库通常有两种方式：  </p><ul><li>在本地初始化Git仓库（不常用）  </li><li>从远程仓库克隆（常用）</li></ul><h3 id="在本地初始化仓库"><a href="#在本地初始化仓库" class="headerlink" title="在本地初始化仓库"></a>在本地初始化仓库</h3><p>操作步骤如下：<br>在任意目录下创建一个空目录（例如gitTest）作为我们的本地Git仓库<br>进入这个目录中，点击右键打开Git bash窗口  </p><p>执行命令</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">git <span class="hljs-keyword">init</span><br></code></pre></td></tr></table></figure><p>如果在当前目录中看到.git文件夹（此文件夹为隐藏文件夹）则说明Git仓库创建成功</p><h3 id="从远程仓库克隆"><a href="#从远程仓库克隆" class="headerlink" title="从远程仓库克隆"></a>从远程仓库克隆</h3><p>可以通过Git提供的命令从远程仓库进行克隆，将远程仓库克隆到本地<br>命令格式：git clone 远程仓库地址</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151117285.png"></p><h2 id="工作区、暂存区、版本库"><a href="#工作区、暂存区、版本库" class="headerlink" title="工作区、暂存区、版本库"></a>工作区、暂存区、版本库</h2><p>为了更好的学习Git，我们需要了解Git相关的一些概念，这些概念在后面的学习中会经常提到。<br><strong>版本库</strong>：前面看到的.git隐藏文件夹就是版本库，版本库中存储了很多配置信息、日志信息和文件版本信息等<br><strong>工作区</strong>：包含.git文件夹的目录就是工作区，也称为工作目录，主要用于存放开发的代码<br><strong>暂存区</strong>：.git文件夹中有很多文件，其中有一个index文件就是暂存区，也可以叫做stage。暂存区是一个临时保存修改文件的地方。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151118350.png"></p><h2 id="git工作区中文件的状态"><a href="#git工作区中文件的状态" class="headerlink" title="git工作区中文件的状态"></a>git工作区中文件的状态</h2><p>Git工作区中的文件存在两种状态：<br>untracked 未跟踪（未被纳入版本控制）：文件是新创建的，git没有去管理它<br>tracked 已跟踪（被纳入版本控制）<br>（1）Unmodified 未修改状态<br>（2）Modified 已修改状态<br>（3）Staged 已暂存状态</p><p>注意：文件的状态会随着我们执行Git的命令发生变化</p><h2 id="本地仓库操作"><a href="#本地仓库操作" class="headerlink" title="本地仓库操作"></a>本地仓库操作</h2><h3 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h3><p>此时远程克隆仓库的文件状态（我们新建了user.java与user.xml文件）：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151120980.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151120790.png"></p><h3 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h3><p>git add 命令的作用是将文件的修改加入暂存区。<br>命令格式：git add fileName<br>加入暂存区后再执行 git status 命令，可以发现文件的状态已经发生变化。<br>执行add命令后查看状态：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151121480.png"></p><h3 id="取消暂存"><a href="#取消暂存" class="headerlink" title="取消暂存"></a>取消暂存</h3><p>git reset 命令的作用是将暂存区的文件取消暂存或者是切换到指定版本<br>取消暂存命令格式：<code>git reset 文件名</code></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151122824.png"></p><h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h3><p>git commit 命令的作用是将暂存区的文件修改提交到版本库<br>命令格式：git commit -m “备注信息” 文件名<br>提交了user.java文件之后，就只剩下了一个未暂存的user.xml</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151123519.png"></p><h3 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h3><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151124372.png"></p><p>通过git log命令查看日志，可以发现每次提交都会产生一个版本号，提交时设置的message、提交人、邮箱、提交时间等信息都会记录到日志中</p><h3 id="切换版本"><a href="#切换版本" class="headerlink" title="切换版本"></a>切换版本</h3><p>每次提交到版本库，都会生成对应的版本号，可以根据版本号切换到指定版本。</p><p>切换到指定版本命令格式：<code>git reset --hard 版本号</code></p><h2 id="远程仓库操作"><a href="#远程仓库操作" class="headerlink" title="远程仓库操作"></a>远程仓库操作</h2><h3 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h3><p>如果要查看已经配置的远程仓库服务器，可以执行 git remote 命令，它会列出每一个远程服务器的简称。<br>如果已经克隆了远程仓库， 至少能够看到origin，这是Git克隆的仓库服务器的默认名字。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151127586.png"></p><h3 id="git-remote-add"><a href="#git-remote-add" class="headerlink" title="git remote add"></a>git remote add</h3><p>添加远程仓库命令格式：git remote add 简称 远程仓库地址<br>把本地仓库添加到远程，远程仓库的默认名称为origin</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151127673.png"></p><h3 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h3><p>就是克隆远端仓库。</p><h3 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h3><p>将本地仓库内容推送到远程仓库。<br>命令格式：<code>git push 远程仓库简称 分支名称</code></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151128020.png"></p><h3 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h3><p>git pull 命令的作用是从远程仓库获取最新版本并合并到本地仓库<br>命令格式：git pull 远程仓库简称 分支名称<br>在本地初始化一个新的repo仓库，并在此仓库中创建new.java文件。然后把此仓库添加到远程仓库（远程仓库依然是我们上文中用到的ceshi仓库）。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151129048.png"></p><h2 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h2><p>分支是Git 使用过程中非常重要的概念。使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。<br>本地仓库和远程仓库中都有分支，同一个仓库可以有多个分支，各个分支相互独立，互不干扰。<br>通过git init 命令创建本地仓库时默认会创建一个master分支。</p><h3 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h3><p>查看分支命令：git branch<br>git branch 列出所有本地分支<br>git branch -r 列出所有远程分支<br>git branch -a 列出所有本地分支和远程分支<br>此时再回到我们的ceshi文件夹（也就是从远程拉取下来的ceshi仓库）</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151129272.png"></p><h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><p>创建分支命令格式：<code>git branch 分支名称</code></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151130249.png"></p><h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><p>一个仓库中可以有多个分支。<br>切换分支命令格式：<code>git checkout 分支名称</code></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151130374.png"></p><h3 id="推送至远程仓库分支"><a href="#推送至远程仓库分支" class="headerlink" title="推送至远程仓库分支"></a>推送至远程仓库分支</h3><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151131849.png"></p><h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><p>合并分支就是将两个分支的文件进行合并处理。<br>令格式：&#96;git merge 分支名称  &#96;&#96;<br>此时我们把user.java中的文件修改为(此时我们已经切换到b1分支)并把b1分支提交推送至远程仓库:</p><p>如果要做的是把b1合并到master，需要先切换到master分支</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151132755.png"></p><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>Git 中的标签，指的是某个分支某个特定时间点的状态。通过标签，可以很方便的切换到标记时的状态。</p><h3 id="查看标签"><a href="#查看标签" class="headerlink" title="查看标签"></a>查看标签</h3><p>查看标签命令：<code>git tag</code></p><h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3><p>命令格式: <code>git tag 标签名称</code></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151133424.png"></p><h3 id="将标签推送到远程仓库"><a href="#将标签推送到远程仓库" class="headerlink" title="将标签推送到远程仓库"></a>将标签推送到远程仓库</h3><p>命令格式：<code>git push origin 标签名称</code></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151134365.png"></p><h3 id="检出标签"><a href="#检出标签" class="headerlink" title="检出标签"></a>检出标签</h3><p>检出标签时需要新建一个分支来指向某个标签，<br>检出标签的命令格式：<code>git checkout -b 分支名 标签名  </code><br>标签完成之后，就不会再修改了。</p><p>检出标签就是在这个标签的基础上进行其他的开发或操作。<br>检出标签的操作实质 ： 就是以标签指定的版本为基础版本，新建一个分支，继续其他的操作。因此 ，就是新建分支的操作了。</p>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jenkins自动化与持续集成</title>
    <link href="/posts/aeac244/"/>
    <url>/posts/aeac244/</url>
    
    <content type="html"><![CDATA[<blockquote><p>最近因为工作需要接触了jenkins这个东西，所以花点时间了解了下。它可以在代码上传仓库（如github,gitee，gitlab）后，在jenkins（一个网站界面）中通过获取代码仓库中最新代码，进行自动化部署，而省去手动打包、上传服务器、部署这一系列步骤，非常方便。</p></blockquote><hr><h2 id="一、jenkins"><a href="#一、jenkins" class="headerlink" title="一、jenkins"></a>一、jenkins</h2><p>Jenkins是一个开源的、提供友好操作界面的持续集成(CI)工具，起源于Hudson（Hudson是商用的），主要用于持续、自动的构建&#x2F;测试软件项目、监控外部任务的运行（这个比较抽象，暂且写上，不做解释）。Jenkins用Java语言编写，可在Tomcat等流行的servlet容器中运行，也可独立运行。通常与版本管理工具(SCM)、构建工具结合使用。常用的版本控制工具有SVN、GIT，构建工具有Maven、Ant、Gradle。</p><h2 id="二、CI-x2F-CD"><a href="#二、CI-x2F-CD" class="headerlink" title="二、CI&#x2F;CD"></a>二、CI&#x2F;CD</h2><p><strong>CI</strong>(Continuous integration，中文意思是<strong>持续集成</strong>)是一种软件开发时间。持续集成强调开发人员提交了新代码之后，立刻进行构建、（单元）测试。根据测试结果，我们可以确定新代码和原有代码能否正确地集成在一起。借用网络图片对CI加以理解。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142245060.png"></p><p><strong>CD</strong>(Continuous Delivery， 中文意思<strong>持续交付</strong>)是在持续集成的基础上，将集成后的代码部署到更贴近真实运行环境(类生产环境)中。比如，我们完成单元测试后，可以把代码部署到连接数据库的Staging环境中更多的测试。如果代码没有问题，可以继续手动部署到生产环境。下图反应的是CI&#x2F;CD 的大概工作模式。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142247157.png"></p><h2 id="三、使用Jenkins进行PHP代码-单元-测试、打包。"><a href="#三、使用Jenkins进行PHP代码-单元-测试、打包。" class="headerlink" title="三、使用Jenkins进行PHP代码(单元)测试、打包。"></a>三、使用Jenkins进行PHP代码(单元)测试、打包。</h2><p>Jenkins是一个强大的CI工具，虽然本身使用Java开发，但也能用来做其他语言开发的项目CI。下面讲解如何使用Jenkins创建一个构建任务。</p><p>登录Jenkins， 点击左侧的新建，创建新的构建任务。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142254198.png"></p><p>跳转到如下界面。任务名称可以自行设定，但需要全局唯一。输入名称后选择构建一个自由风格的软件项目(其他选项不作介绍)。并点击下方的确定按钮即创建了一个构建任务。之后会自动跳转到该job的配置页面。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142255408.png"></p><p>下图是构建任务设置界面，可以看到上方的几个选项**”General”, “源码管理”， “构建触发器”，”构建环境”， “构建”， “构建后操作”**。下面逐一介绍。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142255825.png"></p><h3 id="1-General"><a href="#1-General" class="headerlink" title="1.General"></a>1.General</h3><p>General是构建任务的一些基本配置。名称，描述之类的。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151036745.png"></p><p><strong>项目名称:</strong> 是刚才创建构建任务步骤设置的，当然在这里也可以更改。</p><p><strong>描述:</strong> 对构建任务的描述。</p><p><strong>丢弃旧的构建：</strong> 服务器资源是有限的，有时候保存了太多的历史构建，会导致Jenkins速度变慢，并且服务器硬盘资源也会被占满。当然下方的”保持构建天数” 和 保持构建的最大个数是可以自定义的，需要根据实际情况确定一个合理的值。</p><p>其他几个选项在这里不做介绍，有兴趣的可以查看Jenkins”帮助信息”， 会有一个大概的介绍。</p><h3 id="2-源码管理"><a href="#2-源码管理" class="headerlink" title="2.源码管理"></a>2.源码管理</h3><p>源码管理就是配置你代码的存放位置。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151037862.png"></p><p><strong>Git:</strong> 支持主流的github 和gitlab代码仓库。因我们的研发团队使用的是gitlab，所以下面我只会对该项进行介绍。</p><p><strong>Repository URL</strong>：仓库地址</p><p><strong>Credentials</strong>：凭证。可以使用HTTP方式的用户名密码，也可以是RSA文件。 但要通过后面的”ADD”按钮添加凭证。</p><p><strong>Branches to build</strong>：构建的分支。*&#x2F;master表示master分支，也可以设置为其他分支。</p><p><strong>源码浏览器</strong>：你所使用的代码仓库管理工具，如github, gitlab.</p><p><strong>URL</strong>：填入上方的仓库地址即可。</p><p><strong>Version: 8.7</strong> 这个是我们gitlab服务器的版本。</p><p><strong>Subversion：</strong>就是SVN，这里不作介绍。</p><h3 id="3-构建触发器"><a href="#3-构建触发器" class="headerlink" title="3.构建触发器"></a><strong>3.构建触发器</strong></h3><p>构建触发器，顾名思义，就是构建任务的触发器。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151038908.png"></p><p><strong>触发远程构建(例如，使用脚本):</strong> 该选项会提供一个接口，可以用来在代码层面触发构建。这里不做介绍，后期可能会用到。</p><p><strong>Build after other projects are built：</strong> 该选项意思是”在其他projects构建后构建”。这里不作介绍，后期可能会用到该选项。</p><p><strong>Build periodically：</strong> 周期性的构建。很好理解，就是每隔一段时间进行构建。日程表类似 linux crontab书写格式。如下图的设置，表示每隔30分钟进行一次构建。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151039022.png"></p><p><strong>Build when a change is pushed to GitLab：</strong>当有更改push到gitlab代码仓库，即触发构建。后面会有一个触发构建的地址，一般被称为webhooks。需要将这个地址配置到gitlab中，webhooks如何配置后面介绍。这个是常用的构建触发器。</p><p><strong>Poll SCM：</strong>该选项是配合上面这个选项使用的。当代码仓库发生改动，jenkins并不知道。需要配置这个选项，周期性的去检查代码仓库是否发生改动。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151039070.png"></p><h3 id="4-构建环境"><a href="#4-构建环境" class="headerlink" title="4.构建环境"></a>4.构建环境</h3><p>构建环境就是构建之前的一些准备工作，如指定构建工具(在这里我使用ant)。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151040319.png"></p><p>构建环境中的构建工具</p><p><strong>With Ant：</strong>选择这个工具，并指定ant版本和jdk版本。这两个工具的版本我都事先在服务器上安装，并且在jenkins全局工具中配置好了。</p><p>其他选项不作介绍，同样可以查看”帮助信息” 获得使用帮助。</p><h3 id="5-构建"><a href="#5-构建" class="headerlink" title="5.构建"></a>5.构建</h3><p>选择下方的增加构建步骤。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151041108.png"></p><p>增加构建步骤</p><p>可以选择的项很多。这里就介绍”Invoke Ant” 和”Execute shell”.</p><p><strong>Eexcute shell</strong>： 执行shell命令，该工具是针对linux环境的，windows环境也有对应的工 具”Execute Windows batch command”。 在构建之前，可能我们需要执行一些命令，比如压缩包的解压之类的。为了演示，我就简单的执行 “echo $RANDOM” 这样的linux shell下生产随机数命令。</p><p><strong>Invoke Ant</strong>：Ant是一款java项目构建工具，当然也能用来构建php。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151041091.png"></p><p><strong>Ant Version</strong>： 选择Ant版本。这个ant版本是安装在jenkins服务器上的版本，并且需要在jenkins”系统工具”中设置好。</p><p><strong>Targets</strong>：要执行的操作，一行一个操作任务。以上图为例，build是构建，tar是打包。</p><p><strong>Build File:</strong> 是Ant构建的配置文件，如果不指定，则是在项目路径下的workspace目录中的build.xml。build.xml文件具体怎么配置，后面再细讲。</p><p><strong>properties:</strong> 设定一些变量，这些变量可以在build.xml 中被引用。</p><p><strong>Send files or execute commands over SSH：</strong>发送文件到远程主机或执行命令(脚本)</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151042528.png"></p><p><strong>Name</strong>: SSH Server的名称。SSH Server可以在jenkins-系统设置中配置。</p><p><strong>source files</strong>: 需要发送给远程主机的源文件。</p><p><strong>Remove prefix:</strong> 移除前面的路径。如果不设置这个参数，则远程主机会自动创建构建源 source files 包含的那个路径。</p><p><strong>Remote directory</strong>: 远程主机目录。</p><p><strong>Exec command</strong>：在远程主机上执行的命令，或者执行的脚本。</p><h3 id="6-构建后操作"><a href="#6-构建后操作" class="headerlink" title="6.构建后操作"></a><strong>6.构建后操作</strong></h3><p>构建后操作，就是对project构建完成后的一些后续操作，比如生成相应的代码测试报告。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151042195.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151042087.png"></p><p>邮件通知</p><p><strong>Publish Clover PHP Coverage Report：</strong>发布代码覆盖率xml格式的文件报告。路径会在”build.xml”文件中定义</p><p><strong>Publish HTML reports</strong>：发布代码覆盖率的HTML报告。</p><p><strong>Report Crap:</strong> 发布crap报告<strong>。</strong></p><p><strong>E-mail Notification:</strong> 邮件通知，构建完成后发邮件到指定的邮箱。</p><p><strong>以上配置完成后，点击保存。</strong></p><h3 id="7-其他相关配置"><a href="#7-其他相关配置" class="headerlink" title="7.其他相关配置"></a><strong>7.其他相关配置</strong></h3><p><strong>SSH Server配置</strong></p><p>登录jenkins – 系统管理 – 系统设置</p><p>配置请看下图</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151043329.png"></p><p>SSH SERVER</p><p><strong>SSH Servers:</strong> 由于jenkins服务器公钥文件我已经配置好，所以之后新增SSH Servers 只需要配置这一项即可。</p><p><strong>Name：</strong> 自定义，需要全局唯一。</p><p><strong>HostName:</strong> 主机名，直接用ip地址即可。</p><p><strong>Username:</strong> 新增Server的用户名，这里配置的是root。</p><p><strong>Remote Directory:</strong> 远程目录。jenkins服务器发送文件给新增的server默认是在这个目录。</p><h2 id="四、进行jenkins-project-构建"><a href="#四、进行jenkins-project-构建" class="headerlink" title="四、进行jenkins project 构建"></a>四、进行jenkins project 构建</h2><p>第一次配置好jenkins project之后，会自动触发一次构建。此后，每当有commit 提交到master分支（前面设置的是master分支，也可以设置为其他分支），就会触发一次构建。当然也可以在project页面手动触发构建。点击左边的”立即构建” 手动触发构建。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403151044656.png"></p><h2 id="五、构建结果说明"><a href="#五、构建结果说明" class="headerlink" title="五、构建结果说明"></a>五、构建结果说明</h2><h3 id="构建状态"><a href="#构建状态" class="headerlink" title="构建状态"></a>构建状态</h3><p><strong>Successful蓝色</strong>：构建完成，并且被认为是稳定的。</p><p><strong>Unstable黄色</strong>：构建完成，但被认为是不稳定的。</p><p><strong>Failed红色</strong>：构建失败。</p><p><strong>Disable灰色</strong>：构建已禁用</p><h3 id="构建稳定性"><a href="#构建稳定性" class="headerlink" title="构建稳定性"></a>构建稳定性</h3><p>构建稳定性用天气表示：<strong>晴、晴转多云、多云、小雨、雷阵雨</strong>。天气越好表示构建越稳定，反之亦然。</p><h3 id="构建历史界面"><a href="#构建历史界面" class="headerlink" title="构建历史界面"></a>构建历史界面</h3><p><strong>console output：</strong> 输出构建的日志信息</p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jenkins</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mybatis and plus</title>
    <link href="/posts/85fa2e33/"/>
    <url>/posts/85fa2e33/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是mybatis"><a href="#什么是mybatis" class="headerlink" title="什么是mybatis"></a>什么是mybatis</h1><blockquote><p>它是一款持久层框架，用于简化JDBC开发。</p></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141840885.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141841587.png"></p><h1 id="mybatis快速入门"><a href="#mybatis快速入门" class="headerlink" title="mybatis快速入门"></a>mybatis快速入门</h1><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141841896.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141841285.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141842111.png"></p><h1 id="mybatis代理开发"><a href="#mybatis代理开发" class="headerlink" title="mybatis代理开发"></a>mybatis代理开发</h1><p>搞一个mapper接口</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141843057.png"></p><p>把UserMapper.xml放在同样包结构目录下</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141843579.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141843679.png"></p><h1 id="mybatis核心配置文件"><a href="#mybatis核心配置文件" class="headerlink" title="mybatis核心配置文件"></a>mybatis核心配置文件</h1><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141844577.png"></p><p>比如配置别名，就不需要填写前面的包名</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141844851.png"></p><h1 id="配置文件完成增删改查"><a href="#配置文件完成增删改查" class="headerlink" title="配置文件完成增删改查"></a>配置文件完成增删改查</h1><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141845271.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141845376.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141845963.png"></p><p>多条件的可以看图，可以三种。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141845216.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141846686.png"></p><p><strong>单条件动态查询</strong></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141846009.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141847577.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141847212.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141847396.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141847217.png"></p><h1 id="注解完成增删改查"><a href="#注解完成增删改查" class="headerlink" title="注解完成增删改查"></a>注解完成增删改查</h1><p>就是把sql从xml换到注解里面书写。不过复杂的sql还是是推荐用xml来写。</p><h2 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h2><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141848767.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141849250.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141849832.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141849711.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141849859.png"></p><h1 id="什么是mybatis-plus"><a href="#什么是mybatis-plus" class="headerlink" title="什么是mybatis-plus"></a>什么是mybatis-plus</h1><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142159798.png"></p><p>其实工作中，大多数情况都是单表的CRUD简单查询，借助Mybatis-Plus可以通过简单配置，即可快速进行单表CRUD操作，从而节省大量时间。功能丰富，分页就是一个 插件。代码生成也很优秀。</p><h1 id="mp快速入门"><a href="#mp快速入门" class="headerlink" title="mp快速入门"></a>mp快速入门</h1><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142200669.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142200352.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142200893.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142200088.png"></p><blockquote><p>然后把xml里面的sql全部干掉，mapper里面的方法也不需要了，有爹了（BaseMapper）！</p></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142201487.png"></p><h1 id="常见注解"><a href="#常见注解" class="headerlink" title="常见注解"></a>常见注解</h1><p><strong>约定大于配置</strong></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142202253.png"></p><p>但有时候，名字不一致不符合约定，就需要一些注解来标柱。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142202647.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142202927.png"></p><h1 id="常见配置"><a href="#常见配置" class="headerlink" title="常见配置"></a>常见配置</h1><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142203813.png"></p><p>一般不需要配置，都走默认，需要的话看官网。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142203718.png"></p><h1 id="核心功能-条件构造器"><a href="#核心功能-条件构造器" class="headerlink" title="核心功能-条件构造器"></a>核心功能-条件构造器</h1><p>前面经历的都是通过主键id进行的CRUD，但是真是业务中，很多都是通过各种条件来CRUD，所以MP提供了条件构造器。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142204175.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142204733.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142205586.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142205232.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142206514.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142206748.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142206390.png"></p><p>为什么有了QueryWrapper、UpdateWrapper还需要Lambda~Wrapper呢，是因为，目前写的代码还存在硬编码，它基于lambda语法，能避免硬编码！</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142206898.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142206839.png"></p><h1 id="核心功能-自定义SQL"><a href="#核心功能-自定义SQL" class="headerlink" title="核心功能-自定义SQL"></a>核心功能-自定义SQL</h1><p>Mp已经提供了便捷的增删改查，并且提供了各种条件构造器，为什么还要自定义呢？</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142207991.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142207626.png"></p><p>纯xml还好，如果用mp的UpdateWrapper实现，”balance &#x3D; balance - 200”相当于业务代码，在<strong>业务代码中有sql操作是不合理的</strong>。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142208123.png"></p><p>这种也是，select中 count还起<strong>别名</strong>，如果还是<strong>硬编码</strong>就违背了开发规范。要是不用mp的话又会很麻烦，那就没有俩全的方案吗，答案就是自定义SQL。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142210892.png"></p><p><strong>保证了不在业务层编写sql 遵循了开发规范，同时又享受到了MP生成sql条件的便捷的特性。</strong></p><h1 id="核心功能-Service接口"><a href="#核心功能-Service接口" class="headerlink" title="核心功能-Service接口"></a>核心功能-Service接口</h1><p>UserMapper继承了MP提供的BaseMapper，dao层的CRUD代码不用写了，很爽。<br>现在还有一个Service接口，有了它，Service层的代码也不用写了！！！</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142212532.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142212376.png"></p><p><strong>其实就是service调用mapper里面的实现。</strong></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142214968.png"></p><h1 id="Service开发业务接口"><a href="#Service开发业务接口" class="headerlink" title="Service开发业务接口"></a>Service开发业务接口</h1><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142215893.png"></p><h1 id="扩展功能-代码生成"><a href="#扩展功能-代码生成" class="headerlink" title="扩展功能-代码生成"></a>扩展功能-代码生成</h1><p>现在使用MP需要一下这些步骤，是相对固定的</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142216921.png"></p><p>如果不是User表，而是Order表，是可以自动生成的。可以使用<strong>MyBatisPlus插件，它是Idea插件</strong>，很好用。</p><p><strong>第一步</strong>，连接数据库</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142217696.png"></p><p><strong>第二步</strong>，配置生成代码的配置</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142217225.png"></p><p><strong>cool</strong></p><h1 id="扩展功能-DB静态工具"><a href="#扩展功能-DB静态工具" class="headerlink" title="扩展功能-DB静态工具"></a>扩展功能-DB静态工具</h1><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142218597.png"></p><p>IService里面的方法都是非静态的，DB静态工具都是静态的，没有泛型。所以会多一个参数，就是Class字节码，它得知道是什么类型。需要告诉他实体类类型，其他与IService接口无区别。  但是还是有应用场景的。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142218714.png"></p><blockquote><p>有些业务，需要在UserService里面查Address，就需要注入AddressService，有些业务需要在AddressService中注入UserService，就会产生循环依赖。就可以通过静态工具来解决，不需要注入。</p></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142219561.png"></p><h1 id="扩展功能-逻辑删除"><a href="#扩展功能-逻辑删除" class="headerlink" title="扩展功能-逻辑删除"></a>扩展功能-逻辑删除</h1><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142220735.png"></p><p>那每个语句都要改么，不用，他会<strong>自动修改CRUD语句</strong>。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142221812.png"></p><p>配置之后，即便是remove删除方法，它也会自动转换成update语句，把逻辑删除自动置位已删除。</p><h1 id="扩展功能-JSON处理器"><a href="#扩展功能-JSON处理器" class="headerlink" title="扩展功能-JSON处理器"></a>扩展功能-JSON处理器</h1><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142224983.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142224473.png"></p><p><strong>开启自动的实体与java对象的映射。</strong></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142224075.png"></p><h1 id="扩展功能-分页插件"><a href="#扩展功能-分页插件" class="headerlink" title="扩展功能-分页插件"></a>扩展功能-分页插件</h1><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142225156.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142225480.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142225835.png"></p><p><strong>核心代码实现如下</strong></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403142226782.png"></p>]]></content>
    
    
    <categories>
      
      <category>mybatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mybatis</tag>
      
      <tag>mybatis-plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring深入理解</title>
    <link href="/posts/8358769a/"/>
    <url>/posts/8358769a/</url>
    
    <content type="html"><![CDATA[<h2 id="Spring基础"><a href="#Spring基础" class="headerlink" title="Spring基础"></a>Spring基础</h2><h3 id="什么是spring框架"><a href="#什么是spring框架" class="headerlink" title="什么是spring框架"></a>什么是spring框架</h3><p>Spring 是一款开源的轻量级 Java 开发框架，旨在提高开发人员的开发效率以及系统的可维护性。</p><p>我们一般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发，比如说 Spring 支持 IoC（Inverse of Control:控制反转） 和 AOP(Aspect-Oriented Programming:面向切面编程)、可以很方便地对数据库进行访问、可以很方便地集成第三方组件（电子邮件，任务，调度，缓存等等）、对单元测试支持比较好、支持 RESTful Java 应用程序的开发。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141045694.png"></p><p>Spring 最核心的思想就是不重新造轮子，开箱即用，提高开发效率。<br>Spring 提供的核心功能主要是 IoC 和 AOP。学习 Spring ，一定要把 IoC 和 AOP 的核心思想搞懂！</p><h3 id="Spring-主要模块"><a href="#Spring-主要模块" class="headerlink" title="Spring 主要模块"></a>Spring 主要模块</h3><p>Spring4.x版本</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141046323.png"></p><p>spring5.x版本</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141047202.png"></p><p>Spring5.x 版本中 Web 模块的 Portlet 组件已经被废弃掉，同时增加了用于异步响应式处理的 WebFlux 组件。</p><p>Spring 各个模块的依赖关系</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141047722.png"></p><h3 id="Core-Container"><a href="#Core-Container" class="headerlink" title="Core Container"></a>Core Container</h3><p>Spring 框架的核心模块，也可以说是基础模块，主要提供 IoC 依赖注入功能的支持。Spring 其他所有的功能基本都需要依赖于该模块，我们从上面那张 Spring 各个模块的依赖关系图就可以看出来。</p><ul><li><strong>spring-core</strong> ：Spring 框架基本的核心工具类。</li><li><strong>spring-beans</strong> ：提供对 bean 的创建、配置和管理等功能的支持。</li><li><strong>spring-context</strong> ：提供对国际化、事件传播、资源加载等功能的支持。</li><li><strong>spring-expression</strong> ：提供对表达式语言（Spring Expression Language） SpEL 的支持，只依赖于 core 模块，不依赖于其他模块，可以单独使用。</li></ul><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><ul><li><strong>spring-aspects</strong> ：该模块为与 AspectJ 的集成提供支持。</li><li><strong>spring-aop</strong> ：提供了面向切面的编程实现。</li><li><strong>spring-instrument</strong> ：提供了为 JVM 添加代理（agent）的功能。 具体来讲，它为 Tomcat 提供了一个织入代理，能够为 Tomcat 传递类文 件，就像这些文件是被类加载器加载的一样。没有理解也没关系，这个模块的使用场景非常有限。</li></ul><h3 id="Data-Access-x2F-Integration"><a href="#Data-Access-x2F-Integration" class="headerlink" title="Data Access&#x2F;Integration"></a>Data Access&#x2F;Integration</h3><ul><li><strong>spring-jdbc</strong> ：提供了对数据库访问的抽象 JDBC。不同的数据库都有自己独立的 API 用于操作数据库，而 Java 程序只需要和 JDBC API 交互，这样就屏蔽了数据库的影响。</li><li><strong>spring-tx</strong> ：提供对事务的支持。</li><li><strong>spring-orm</strong> ： 提供对 Hibernate、JPA 、iBatis 等 ORM 框架的支持。</li><li><strong>spring-oxm</strong> ：提供一个抽象层支撑 OXM(Object-to-XML-Mapping)，例如：JAXB、Castor、XMLBeans、JiBX 和 XStream 等。</li><li><strong>spring-jms</strong> : 消息服务。自 Spring Framework 4.1 以后，它还提供了对 spring-messaging 模块的继承。</li></ul><h3 id="Spring-Web"><a href="#Spring-Web" class="headerlink" title="Spring Web"></a>Spring Web</h3><ul><li><strong>spring-web</strong> ：对 Web 功能的实现提供一些最基础的支持。</li><li><strong>spring-webmvc</strong> ： 提供对 Spring MVC 的实现。</li><li><strong>spring-websocket</strong> ： 提供了对 WebSocket 的支持，WebSocket 可以让客户端和服务端进行双向通信。</li><li><strong>spring-webflux</strong> ：提供对 WebFlux 的支持。WebFlux 是 Spring Framework 5.0 中引入的新的响应式框架。与 Spring MVC 不同，它不需要 Servlet API，是完全异步。</li></ul><h3 id="Messaging"><a href="#Messaging" class="headerlink" title="Messaging"></a>Messaging</h3><p><strong>spring-messaging</strong> 是从 Spring4.0 开始新加入的一个模块，主要职责是为 Spring 框架集成一些基础的报文传送应用。</p><h3 id="Spring-Test"><a href="#Spring-Test" class="headerlink" title="Spring Test"></a>Spring Test</h3><p>Spring 团队提倡测试驱动开发（TDD）。有了控制反转 (IoC)的帮助，单元测试和集成测试变得更简单。</p><p>Spring 的测试模块对 JUnit（单元测试框架）、TestNG（类似 JUnit）、Mockito（主要用来 Mock 对象）、PowerMock（解决 Mockito 的问题比如无法模拟 final, static， private 方法）等等常用的测试框架支持的都比较好。</p><h3 id="Spring-Spring-MVC-Spring-Boot-之间的关系"><a href="#Spring-Spring-MVC-Spring-Boot-之间的关系" class="headerlink" title="Spring,Spring MVC,Spring Boot 之间的关系"></a>Spring,Spring MVC,Spring Boot 之间的关系</h3><p>很多人对 Spring,Spring MVC,Spring Boot 这三者傻傻分不清楚！这里简单介绍一下这三者，其实很简单，没有什么高深的东西。</p><p>Spring 包含了多个功能模块（上面刚刚提高过），其中最重要的是 Spring-Core（主要提供 IoC 依赖注入功能的支持） 模块， Spring 中的其他模块（比如 Spring MVC）的功能实现基本都需要依赖于该模块。</p><p>Spring MVC 是 Spring 中的一个很重要的模块，主要赋予 Spring 快速构建 MVC 架构的 Web 程序的能力。MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141053129.png"></p><p>使用 Spring 进行开发各种配置过于麻烦比如开启某些 Spring 特性时，需要用 XML 或 Java 进行显式配置。于是，Spring Boot 诞生了！</p><p>Spring 旨在简化 J2EE 企业应用程序开发。Spring Boot 旨在简化 Spring 开发（减少配置文件，开箱即用！）。</p><p>Spring Boot 只是简化了配置，如果你需要构建 MVC 架构的 Web 程序，你还是需要使用 Spring MVC 作为 MVC 框架，只是说 Spring Boot 帮你简化了 Spring MVC 的很多配置，真正做到开箱即用！</p><h2 id="Spring-IOC"><a href="#Spring-IOC" class="headerlink" title="Spring IOC"></a>Spring IOC</h2><h3 id="对Spring-IOC-的了解"><a href="#对Spring-IOC-的了解" class="headerlink" title="对Spring IOC 的了解"></a>对Spring IOC 的了解</h3><p><strong>IoC（Inverse of Control:控制反转）</strong> 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。不过， IoC 并非 Spring 特有，在其他语言中也有应用。</p><p><strong>为什么叫控制反转？</strong></p><ul><li><strong>控制</strong> ：指的是对象创建（实例化、管理）的权力</li><li><strong>反转</strong> ：控制权交给外部环境（Spring 框架、IoC 容器）</li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141054462.png"></p><p>将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件&#x2F;注解即可，完全不用考虑对象是如何被创建出来的。</p><p>在实际项目中一个 Service 类可能依赖了很多其他的类，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IoC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。</p><p>在 Spring 中， IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个 Map（key，value），Map 中存放的是各种对象。</p><p>Spring 时代我们一般通过 XML 文件来配置 Bean，后来开发人员觉得 XML 文件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流行起来。</p><h3 id="什么是-Spring-Bean？"><a href="#什么是-Spring-Bean？" class="headerlink" title="什么是 Spring Bean？"></a>什么是 Spring Bean？</h3><p>简单来说，Bean 代指的就是那些被 IoC 容器所管理的对象。</p><p>我们需要告诉 IoC 容器帮助我们管理哪些对象，这个是通过配置元数据来定义的。配置元数据可以是 XML 文件、注解或者 Java 配置类。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- Constructor-arg with &#x27;value&#x27; attribute --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;...&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;...&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>下图简单地展示了 IoC 容器如何使用配置元数据来管理对象。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141056861.png"></p><p>org.springframework.beans和 org.springframework.context 这两个包是 IoC 实现的基础，如果想要研究 IoC 相关的源码的话，可以去看看</p><h3 id="将一个类声明为-Bean-的注解有哪些"><a href="#将一个类声明为-Bean-的注解有哪些" class="headerlink" title="将一个类声明为 Bean 的注解有哪些?"></a>将一个类声明为 Bean 的注解有哪些?</h3><ul><li>@Component ：通用的注解，可标注任意类为 Spring 组件。如果一个 Bean 不知道属于哪个层，可以使用@Component 注解标注。</li><li>@Repository : 对应持久层即 Dao 层，主要用于数据库相关操作。</li><li>@Service : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。</li><li>@Controller : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。</li></ul><h3 id="Component-和-Bean-的区别是什么？"><a href="#Component-和-Bean-的区别是什么？" class="headerlink" title="@Component 和 @Bean 的区别是什么？"></a>@Component 和 @Bean 的区别是什么？</h3><ul><li>@Component 注解作用于类，而@Bean注解作用于方法。</li><li>@Component通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中（我们可以使用 @ComponentScan 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。@Bean 注解通常是我们在标有该注解的方法中定义产生这个 bean,@Bean告诉了 Spring 这是某个类的实例，当我需要用它的时候还给我。</li><li>@Bean 注解比 @Component 注解的自定义性更强，而且很多地方我们只能通过 @Bean 注解来注册 bean。比如当我们引用第三方库中的类需要装配到 Spring容器时，则只能通过 @Bean来实现。</li></ul><p>@Bean注解使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> TransferService <span class="hljs-title function_">transferService</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransferServiceImpl</span>();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码相当于下面的 xml 配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transferService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.acme.TransferServiceImpl&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>下面这个例子是通过 @Component 无法实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> OneService <span class="hljs-title function_">getService</span><span class="hljs-params">(status)</span> &#123;<br>    <span class="hljs-keyword">case</span> (status)  &#123;<br>        when <span class="hljs-number">1</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">serviceImpl1</span>();<br>        when <span class="hljs-number">2</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">serviceImpl2</span>();<br>        when <span class="hljs-number">3</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">serviceImpl3</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="注入-Bean-的注解有哪些？"><a href="#注入-Bean-的注解有哪些？" class="headerlink" title="注入 Bean 的注解有哪些？"></a>注入 Bean 的注解有哪些？</h3><p>Spring 内置的 <code>@Autowired</code> 以及 JDK 内置的 <code>@Resource</code> 和 <code>@Inject</code> 都可以用于注入 Bean。</p><table><thead><tr><th>Annotaion</th><th>Package</th><th>Source</th></tr></thead><tbody><tr><td>@Autowired</td><td>org.springframework.bean.factory</td><td>Spring 2.5+</td></tr><tr><td>@Resource</td><td>javax.annotation</td><td>Java JSR-250</td></tr><tr><td>@Inject</td><td>javax.inject</td><td>Java JSR-330</td></tr></tbody></table><p>@Autowired 和@Resource使用的比较多一些。</p><h3 id="Autowired-和-Resource-的区别是什么？"><a href="#Autowired-和-Resource-的区别是什么？" class="headerlink" title="@Autowired 和 @Resource 的区别是什么？"></a>@Autowired 和 @Resource 的区别是什么？</h3><p>Autowired 属于 Spring 内置的注解，默认的注入方式为byType（根据类型进行匹配），也就是说会优先根据接口类型去匹配并注入 Bean （接口的实现类）。</p><p><strong>这会有什么问题呢？</strong> 当一个接口存在多个实现类的话，byType这种方式就无法正确注入对象了，因为这个时候 Spring 会同时找到多个满足条件的选择，默认情况下它自己不知道选择哪一个。</p><p>这种情况下，注入方式会变为 byName（根据名称进行匹配），这个名称通常就是类名（首字母小写）。就比如说下面代码中的 smsService 就是我这里所说的名称，这样应该比较好理解了吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// smsService 就是我们上面所说的名称</span><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> SmsService smsService;<br></code></pre></td></tr></table></figure><p>举个例子，SmsService 接口有两个实现类: SmsServiceImpl1和 SmsServiceImpl2，且它们都已经被 Spring 容器所管理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 报错，byName 和 byType 都无法匹配到 bean</span><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> SmsService smsService;<br><br><span class="hljs-comment">// 正确注入 SmsServiceImpl1 对象对应的 bean</span><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> SmsService smsServiceImpl1;<br><br><span class="hljs-comment">// 正确注入  SmsServiceImpl1 对象对应的 bean</span><br><span class="hljs-comment">// smsServiceImpl1 就是我们上面所说的名称</span><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-meta">@Qualifier(value = &quot;smsServiceImpl1&quot;)</span><br><span class="hljs-keyword">private</span> SmsService smsService;<br></code></pre></td></tr></table></figure><p>还是建议通过 @Qualifier 注解来显示指定名称而不是依赖变量的名称。</p><p>@Resource属于 JDK 提供的注解，默认注入方式为 byName。如果无法通过名称匹配到对应的 Bean 的话，注入方式会变为byType。</p><p>@Resource 有两个比较重要且日常开发常用的属性：name（名称）、type（类型）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Resource &#123;<br>    String <span class="hljs-title function_">name</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>    Class&lt;?&gt; type() <span class="hljs-keyword">default</span> Object.class;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果仅指定 name 属性则注入方式为byName，如果仅指定type属性则注入方式为byType，如果同时指定name 和type属性（不建议这么做）则注入方式为byType+byName。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 报错，byName 和 byType 都无法匹配到 bean</span><br><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> SmsService smsService;<br><br><span class="hljs-comment">// 正确注入 SmsServiceImpl1 对象对应的 bean</span><br><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> SmsService smsServiceImpl1;<br><br><span class="hljs-comment">// 正确注入 SmsServiceImpl1 对象对应的 bean（比较推荐这种方式）</span><br><span class="hljs-meta">@Resource(name = &quot;smsServiceImpl1&quot;)</span><br><span class="hljs-keyword">private</span> SmsService smsService;<br></code></pre></td></tr></table></figure><p>简单总结一下：</p><ul><li>@Autowired 是 Spring 提供的注解，@Resource 是 JDK 提供的注解。</li><li>Autowired 默认的注入方式为byType（根据类型进行匹配），@Resource默认注入方式为 byName（根据名称进行匹配）。</li><li>当一个接口存在多个实现类的情况下，@Autowired 和@Resource都需要通过名称才能正确匹配到对应的 Bean。Autowired 可以通过 @Qualifier 注解来显示指定名称，@Resource可以通过 name 属性来显示指定名称。</li></ul><h3 id="Bean-的作用域有哪些"><a href="#Bean-的作用域有哪些" class="headerlink" title="Bean 的作用域有哪些?"></a>Bean 的作用域有哪些?</h3><p>Spring 中 Bean 的作用域通常有下面几种：</p><ul><li><strong>singleton</strong> : IoC 容器中只有唯一的 bean 实例。Spring 中的 bean 默认都是单例的，是对单例设计模式的应用。</li><li><strong>prototype</strong> : 每次获取都会创建一个新的 bean 实例。也就是说，连续 getBean() 两次，得到的是不同的 Bean 实例。</li><li><strong>request</strong> （仅 Web 应用可用）: 每一次 HTTP 请求都会产生一个新的 bean（请求 bean），该 bean 仅在当前 HTTP request 内有效。</li><li><strong>session</strong> （仅 Web 应用可用） : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean（会话 bean），该 bean 仅在当前 HTTP session 内有效。</li><li><strong>application&#x2F;global-session</strong> （仅 Web 应用可用）： 每个 Web 应用在启动时创建一个 Bean（应用 Bean），，该 bean 仅在当前应用启动时间内有效。</li><li><strong>websocket</strong> （仅 Web 应用可用）：每一次 WebSocket 会话产生一个新的 bean。</li></ul><p><strong>如何配置 bean 的作用域呢？</strong></p><p>xml方式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;singleton&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注解方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span><br><span class="hljs-keyword">public</span> Person <span class="hljs-title function_">personPrototype</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="单例-Bean-的线程安全问题了解吗？"><a href="#单例-Bean-的线程安全问题了解吗？" class="headerlink" title="单例 Bean 的线程安全问题了解吗？"></a>单例 Bean 的线程安全问题了解吗？</h3><p>大部分时候我们并没有在项目中使用多线程，所以很少有人会关注这个问题。单例 Bean 存在线程问题，主要是因为当多个线程操作同一个对象的时候是存在资源竞争的。</p><p>常见的有两种解决办法：</p><ol><li>在 Bean 中尽量避免定义可变的成员变量。</li><li>在类中定义一个 ThreadLocal 成员变量，将需要的可变成员变量保存在 ThreadLocal 中（推荐的一种方式）。</li></ol><p>不过，大部分 Bean 实际都是无状态（没有实例变量）的（比如 Dao、Service），这种情况下， Bean 是线程安全的。</p><h3 id="Bean-的生命周期了解么"><a href="#Bean-的生命周期了解么" class="headerlink" title="Bean 的生命周期了解么?"></a>Bean 的生命周期了解么?</h3><ul><li>Bean 容器找到配置文件中 Spring Bean 的定义。</li><li>Bean 容器利用 Java Reflection API 创建一个 Bean 的实例。</li><li>如果涉及到一些属性值 利用 set()方法设置一些属性值。</li><li>如果 Bean 实现了 BeanNameAware 接口，调用 setBeanName()方法，传入 Bean 的名字。</li><li>如果 Bean 实现了 BeanClassLoaderAware 接口，调用 setBeanClassLoader()方法，传入 ClassLoader对象的实例。</li><li>如果 Bean 实现了 BeanFactoryAware 接口，调用 setBeanFactory()方法，传入 BeanFactory对象的实例。</li><li>与上面的类似，如果实现了其他 *.Aware接口，就调用相应的方法。</li><li>如果有和加载这个 Bean 的 Spring 容器相关的 BeanPostProcessor 对象，执行postProcessBeforeInitialization() 方法</li><li>如果 Bean 实现了InitializingBean接口，执行afterPropertiesSet()方法。</li><li>如果 Bean 在配置文件中的定义包含 init-method 属性，执行指定的方法。</li><li>如果有和加载这个 Bean 的 Spring 容器相关的 BeanPostProcessor 对象，执行postProcessAfterInitialization() 方法</li><li>当要销毁 Bean 的时候，如果 Bean 实现了 DisposableBean 接口，执行 destroy() 方法。</li><li>当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含 destroy-method 属性，执行指定的方法。</li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141107712.png"></p><h2 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h2><h3 id="对Spring-AOP-的了解"><a href="#对Spring-AOP-的了解" class="headerlink" title="对Spring AOP 的了解"></a>对Spring AOP 的了解</h3><p>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p><p>Spring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 <strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理，如下图所示：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141510921.png"></p><p>当然你也可以使用 <strong>AspectJ</strong> ！Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。</p><p>AOP 切面编程设计到的一些专业术语</p><table><thead><tr><th>术语</th><th>含义</th></tr></thead><tbody><tr><td>目标(Target)</td><td>被通知的对象</td></tr><tr><td>代理(Proxy)</td><td>向目标对象应用通知之后创建的代理对象</td></tr><tr><td>连接点(JoinPoint)</td><td>目标对象的所属类中，定义的所有方法均为连接点</td></tr><tr><td>切入点(Pointcut)</td><td>被切面拦截 &#x2F; 增强的连接点（切入点一定是连接点，连接点不一定是切入点）</td></tr><tr><td>通知(Advice)</td><td>增强的逻辑 &#x2F; 代码，也即拦截到目标对象的连接点之后要做的事情</td></tr><tr><td>切面(Aspect)</td><td>切入点(Pointcut)+通知(Advice)</td></tr><tr><td>Weaving(织入)</td><td>将通知应用到目标对象，进而生成代理对象的过程动作</td></tr></tbody></table><h3 id="Spring-AOP-和-AspectJ-AOP-的区别"><a href="#Spring-AOP-和-AspectJ-AOP-的区别" class="headerlink" title="Spring AOP 和 AspectJ AOP 的区别"></a>Spring AOP 和 AspectJ AOP 的区别</h3><p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong> Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</p><p>Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，</p><p>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比 Spring AOP 快很多。</p><h3 id="AspectJ-定义的通知类型有哪些？"><a href="#AspectJ-定义的通知类型有哪些？" class="headerlink" title="AspectJ 定义的通知类型有哪些？"></a>AspectJ 定义的通知类型有哪些？</h3><ul><li><strong>Before</strong>（前置通知）：目标对象的方法调用之前触发</li><li><strong>After</strong> （后置通知）：目标对象的方法调用之后触发</li><li><strong>AfterReturning</strong>（返回通知）：目标对象的方法调用完成，在返回结果值之后触发</li><li><strong>AfterThrowing</strong>（异常通知） ：目标对象的方法运行中抛出 &#x2F; 触发异常后触发。AfterReturning 和 AfterThrowing 两者互斥。如果方法调用成功无异常，则会有返回值；如果方法抛出了异常，则不会有返回值。</li><li><strong>Around</strong>： （环绕通知）编程式控制目标对象的方法调用。环绕通知是所有通知类型中可操作范围最大的一种，因为它可以直接拿到目标对象，以及要执行的方法，所以环绕通知可以任意的在目标对象的方法调用前后搞事，甚至不调用目标对象的方法。</li></ul><h3 id="多个切面的执行顺序如何控制？"><a href="#多个切面的执行顺序如何控制？" class="headerlink" title="多个切面的执行顺序如何控制？"></a>多个切面的执行顺序如何控制？</h3><p>1、通常使用@Order 注解直接定义切面顺序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 值越小优先级越高</span><br><span class="hljs-meta">@Order(3)</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggingAspect</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Ordered</span> &#123;<br><br></code></pre></td></tr></table></figure><p><strong>2、实现Ordered 接口重写 getOrder 方法。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggingAspect</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Ordered</span> &#123;<br><br>    <span class="hljs-comment">// ....</span><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getOrder</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 返回值越小优先级越高</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h2><h3 id="对-Spring-MVC的了解"><a href="#对-Spring-MVC的了解" class="headerlink" title="对 Spring MVC的了解"></a>对 Spring MVC的了解</h3><p>MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141512947.png"></p><p><strong>Spring MVC 时代</strong></p><p>随着 Spring 轻量级开发框架的流行，Spring 生态圈出现了 Spring MVC 框架， Spring MVC 是当前最优秀的 MVC 框架。相比于 Struts2 ， Spring MVC 使用更加简单和方便，开发效率更高，并且 Spring MVC 运行速度更快。</p><p>MVC 是一种设计模式，Spring MVC 是一款很优秀的 MVC 框架。Spring MVC 可以帮助我们进行更简洁的 Web 层的开发，并且它天生与 Spring 框架集成。Spring MVC 下我们一般把后端项目分为 Service 层（处理业务）、Dao 层（数据库操作）、Entity 层（实体类）、Controller 层(控制层，返回数据给前台页面)。</p><h3 id="Spring-MVC-的核心组件有哪些？"><a href="#Spring-MVC-的核心组件有哪些？" class="headerlink" title="Spring MVC 的核心组件有哪些？"></a><strong>Spring MVC 的核心组件有哪些？</strong></h3><p>记住了下面这些组件，也就记住了 SpringMVC 的工作原理。</p><ul><li><strong>DispatcherServlet</strong> ：<strong>核心的中央处理器</strong>，负责接收请求、分发，并给予客户端响应。</li><li><strong>HandlerMapping</strong> ：<strong>处理器映射器</strong>，根据 uri 去匹配查找能处理的 Handler ，并会将请求涉及到的拦截器和 Handler 一起封装。</li><li><strong>HandlerAdapter</strong> ：<strong>处理器适配器</strong>，根据 HandlerMapping 找到的 Handler ，适配执行对应的 Handler；</li><li><strong>Handler</strong> ：<strong>请求处理器</strong>，处理实际请求的处理器。</li><li><strong>ViewResolver</strong> ：<strong>视图解析器</strong>，根据 Handler 返回的逻辑视图 &#x2F; 视图，解析并渲染真正的视图，并传递给 DispatcherServlet 响应客户端</li></ul><h3 id="SpringMVC-工作原理了解吗"><a href="#SpringMVC-工作原理了解吗" class="headerlink" title="SpringMVC 工作原理了解吗?"></a><strong>SpringMVC 工作原理了解吗?</strong></h3><p><strong>Spring MVC 原理如下图所示：</strong></p><blockquote><p>SpringMVC 工作原理的图解我没有自己画，直接图省事在网上找了一个非常清晰直观的，原出处不明。</p></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403141513812.png"></p><p><strong>流程说明（重要）：</strong></p><ol><li>客户端（浏览器）发送请求， DispatcherServlet拦截请求。</li><li>DispatcherServlet 根据请求信息调用 HandlerMapping 。HandlerMapping 根据 uri 去匹配查找能处理的 Handler（也就是我们平常说的 Controller 控制器） ，并会将请求涉及到的拦截器和 Handler 一起封装。</li><li>DispatcherServlet 调用 HandlerAdapter适配执行 Handler 。</li><li>Handler 完成对用户请求的处理后，会返回一个 ModelAndView 对象给DispatcherServlet，ModelAndView 顾名思义，包含了数据模型以及相应的视图的信息。Model 是返回的数据对象，View 是个逻辑上的 View。</li><li>ViewResolver 会根据逻辑 View 查找实际的 View。</li><li>DispaterServlet 把返回的 Model 传给 View（视图渲染）。</li><li>把 View 返回给请求者（浏览器）</li></ol><h3 id="统一异常处理怎么做？"><a href="#统一异常处理怎么做？" class="headerlink" title="统一异常处理怎么做？"></a><strong>统一异常处理怎么做？</strong></h3><p>推荐使用注解的方式统一异常处理，具体会使用到 @ControllerAdvice + @ExceptionHandler 这两个注解 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ControllerAdvice</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GlobalExceptionHandler</span> &#123;<br><br>    <span class="hljs-meta">@ExceptionHandler(BaseException.class)</span><br>    <span class="hljs-keyword">public</span> ResponseEntity&lt;?&gt; handleAppException(BaseException ex, HttpServletRequest request) &#123;<br>      <span class="hljs-comment">//......</span><br>    &#125;<br><br>    <span class="hljs-meta">@ExceptionHandler(value = ResourceNotFoundException.class)</span><br>    <span class="hljs-keyword">public</span> ResponseEntity&lt;ErrorReponse&gt; <span class="hljs-title function_">handleResourceNotFoundException</span><span class="hljs-params">(ResourceNotFoundException ex, HttpServletRequest request)</span> &#123;<br>      <span class="hljs-comment">//......</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这种异常处理方式下，会给所有或者指定的 Controller 织入异常处理的逻辑（AOP），当 Controller 中的方法抛出异常的时候，由被@ExceptionHandler 注解修饰的方法进行处理。</p><p>ExceptionHandlerMethodResolver 中 getMappedMethod 方法决定了异常具体被哪个被 @ExceptionHandler 注解修饰的方法处理异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Nullable</span><br> <span class="hljs-keyword">private</span> Method <span class="hljs-title function_">getMappedMethod</span><span class="hljs-params">(Class&lt;? extends Throwable&gt; exceptionType)</span> &#123;<br>  List&lt;Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Throwable</span>&gt;&gt; matches = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-comment">//找到可以处理的所有异常信息。mappedMethods 中存放了异常和处理异常的方法的对应关系</span><br>  <span class="hljs-keyword">for</span> (Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Throwable</span>&gt; mappedException : <span class="hljs-built_in">this</span>.mappedMethods.keySet()) &#123;<br>   <span class="hljs-keyword">if</span> (mappedException.isAssignableFrom(exceptionType)) &#123;<br>    matches.add(mappedException);<br>   &#125;<br>  &#125;<br>    <span class="hljs-comment">// 不为空说明有方法处理异常</span><br>  <span class="hljs-keyword">if</span> (!matches.isEmpty()) &#123;<br>      <span class="hljs-comment">// 按照匹配程度从小到大排序</span><br>   matches.sort(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExceptionDepthComparator</span>(exceptionType));<br>      <span class="hljs-comment">// 返回处理异常的方法</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.mappedMethods.get(matches.get(<span class="hljs-number">0</span>));<br>  &#125;<br>  <span class="hljs-keyword">else</span> &#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br> &#125;<br><br></code></pre></td></tr></table></figure><p>从源代码看出：getMappedMethod()会首先找到可以匹配处理异常的所有方法信息，然后对其进行从小到大的排序，最后取最小的那一个匹配的方法(即匹配度最高的那个)。</p><h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><h3 id="SpringBoot自动配置原理"><a href="#SpringBoot自动配置原理" class="headerlink" title="SpringBoot自动配置原理"></a>SpringBoot自动配置原理</h3><p>Spring Boot 的核心理念是约定优于配置（Convention over Configuration），旨在通过提供一系列默认配置来简化应用程序的开发和部署。其中最重要的一个特性是自动配置（Auto-configuration）。</p><p>Spring Boot 的自动配置是基于 Spring 的条件化配置（Conditional Configuration）功能实现的。Spring Boot 会根据应用程序的依赖关系和其他一些因素来决定需要自动配置哪些组件，以及如何配置这些组件。</p><p>@EnableAutoConfiguration是Spring Boot自动配置的核心，其实现原理主要包括以下几个步骤：</p><p>Spring Boot在启动时，会扫描classpath下的META-INF&#x2F;spring.factories文件，并解析其中的EnableAutoConfiguration实现类。</p><p>Spring Boot将自动配置实现类加载到容器中，并对自动配置进行条件判断。条件不满足的自动配置将被过滤掉，只有满足条件的自动配置才会生效。</p><p>Spring Boot会根据当前应用所依赖的jar包，自动配置需要的Bean，如DataSource、JdbcTemplate等。</p><p>Spring Boot还提供了一些默认的配置，如端口号、上下文路径等，这些配置也是通过自动配置实现的。</p><p>总的来说，Spring Boot自动配置的原理就是利用@EnableAutoConfiguration和条件注解实现了对Bean的自动配置，并且提供了默认的配置，可以帮助开发者快速搭建一个基于Spring Boot的Web应用程序。</p><h3 id="Spring-Boot的核心注解是哪些"><a href="#Spring-Boot的核心注解是哪些" class="headerlink" title="Spring Boot的核心注解是哪些"></a>Spring Boot的核心注解是哪些</h3><p>Spring Boot 的核心注解主要包括：</p><p>@SpringBootApplication：一个复合注解，包括了@Configuration、@EnableAutoConfiguration 和 @ComponentScan 三个注解，用于标识 Spring Boot 应用的主类。</p><p>@Configuration：表明该类是一个 Java 配置类，用于定义 Spring Bean 的配置信息。</p><p>@EnableAutoConfiguration：自动配置注解，用于开启 Spring Boot 的自动配置功能。</p><p>@ComponentScan：用于自动扫描和注册 Spring Bean。</p><p>除此之外，还有一些常用的注解，如：</p><p>@RestController：用于定义 RESTful 接口，相当于 @Controller 和 @ResponseBody 的组合。</p><p>@RequestMapping：用于定义 HTTP 请求的映射，用于处理 HTTP 请求。</p><p>@Autowired：自动注入注解，用于自动装配 Spring Bean。</p><p>@Value：属性注入注解，用于注入配置文件中的属性值。</p><p>这些注解共同组成了 Spring Boot 应用的核心框架。</p><h3 id="SpringBoot的核心配置文件有哪几个"><a href="#SpringBoot的核心配置文件有哪几个" class="headerlink" title="SpringBoot的核心配置文件有哪几个"></a>SpringBoot的核心配置文件有哪几个</h3><p>Spring Boot的核心配置文件有以下几个：</p><p>application.properties</p><p>application.yml</p><p>bootstrap.properties</p><p>bootstrap.yml</p><p>其中，application.properties和application.yml是应用程序的配置文件，而bootstrap.properties和bootstrap.yml是用于Spring Boot上下文的配置文件。它们之间的区别在于加载的优先级不同，bootstrap配置文件的优先级更高，可以用于设置一些比较敏感和重要的配置信息。</p><p>application.properties是以键值对的形式进行配置的，例如</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">server.port=8080<br>spring.datasource.url=jdbc:mysql://localhost:3306/test<br></code></pre></td></tr></table></figure><p>application.yml则采用缩进的方式进行配置，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">server:<br>port: <span class="hljs-number">8080</span><br>spring:<br>datasource:<br>url: jdbc:mysql:<span class="hljs-comment">//localhost:3306/test</span><br><br></code></pre></td></tr></table></figure><p>在Spring Boot应用程序中，我们可以使用这些配置文件来配置应用程序、数据库、日志等方面的配置信息，简化了应用程序的配置过程。在Spring Boot中，这些配置文件的属性可以通过注解@Value注入到Java类中，并且可以通过@ConfigurationProperties注解来将一组属性绑定到一个类中。</p><h3 id="什么是Spring-Boot-Starter？有哪些常用的"><a href="#什么是Spring-Boot-Starter？有哪些常用的" class="headerlink" title="什么是Spring Boot Starter？有哪些常用的"></a>什么是Spring Boot Starter？有哪些常用的</h3><p>Spring Boot Starter是一种特殊的依赖关系，它是为了方便Spring Boot应用程序的快速启动和集成而设计的。一个Starter通常会包含多个相关的依赖库，以及自动配置和其他必要的配置文件，使得我们只需引入一个Starter依赖，即可快速地集成相关的技术或库。</p><p>常用的Spring Boot Starter包括：</p><p>spring-boot-starter-web：适用于开发Web应用程序的Starter，包含Spring MVC、Tomcat和Spring Boot Web自动配置等。</p><p>spring-boot-starter-data-jpa：适用于使用JPA的Starter，包含Hibernate、Spring Data JPA、Spring ORM等依赖。</p><p>spring-boot-starter-data-redis：适用于使用Redis的Starter，包含Jedis客户端和Spring Data Redis等依赖。</p><p>spring-boot-starter-test：适用于测试的Starter，包含JUnit、Mockito、Hamcrest、Spring Test等依赖。</p><p>spring-boot-starter-actuator：适用于监控和管理Spring Boot应用程序的Starter，包含Spring Boot Actuator和Spring Boot Web等依赖。</p><p>通过使用Spring Boot Starter，我们可以非常方便地集成常用的技术和库，大大提高了开发效率和便捷性。</p><h3 id="SpringBoot-打成jar和普通的jar有什么区别"><a href="#SpringBoot-打成jar和普通的jar有什么区别" class="headerlink" title="SpringBoot 打成jar和普通的jar有什么区别"></a>SpringBoot 打成jar和普通的jar有什么区别</h3><p>Spring Boot应用打成的jar和普通的jar包在打包的方式和使用方式上有一些区别。</p><p>首先，Spring Boot打成的jar包是一种可执行的jar包，包含了内嵌的Tomcat、Jetty等Web服务器，可以直接运行。而普通的jar包只包含类、资源等，需要在外部环境中手动配置Web服务器才能运行。</p><p>其次，Spring Boot打成的jar包中包含了启动类的main方法，可以直接运行该jar包来启动应用程序。而普通的jar包中没有默认的main方法，需要手动指定启动类来运行应用程序。</p><p>此外，Spring Boot打成的jar包还包含了一些默认的配置文件，例如application.properties或application.yml，这些文件可以用于配置应用程序的属性、数据源等信息。而普通的jar包不包含这些默认的配置文件。</p><p>最后，Spring Boot打成的jar包可以使用spring-boot-maven-plugin插件来打包，该插件可以帮助我们将应用程序的依赖项、配置文件等全部打包进一个可执行的jar包中，方便部署和运行。而普通的jar包需要手动处理依赖项、配置文件等，比较繁琐。</p>]]></content>
    
    
    <categories>
      
      <category>spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于Spring</title>
    <link href="/posts/ed0120ab/"/>
    <url>/posts/ed0120ab/</url>
    
    <content type="html"><![CDATA[<h2 id="一-Spring是什么"><a href="#一-Spring是什么" class="headerlink" title="一.Spring是什么"></a>一.Spring是什么</h2><p>Spring是一个开源的轻量级Java SE（Java 标准版本）&#x2F;Java EE（Java 企业版本）开发应用框架，其目的是用于简化企业级应用程序开发。</p><p>应用程序是由一组相互协作的对象组成。而在传统应用程序开发中，一个完整的应用是由一组相互协作的对象组成。</p><p>所以开发一个应用除了要开发业务逻辑之外，最多的是关注如何使这些对象协作来完成所需功能，而且要低耦合、高内聚。</p><p>业务逻辑开发是不可避免的，那如果有个框架出来帮我们来创建对象及管理这些对象之间的依赖关系。</p><p>可能有人说了，比如“抽象工厂、工厂方法设计模式”不也可以帮我们创建对象，“生成器模式”帮我们处理对象间的依赖关系，不也能完成这些功能吗？</p><p>可是这些又需要我们创建另一些工厂类、生成器类，我们又要而外管理这些类，增加了我们的负担，如果能有种通过配置方式来创建对象，管理对象之间依赖关系，</p><p>我们不需要通过工厂和生成器来创建及管理对象之间的依赖关系，这样我们是不是减少了许多工作，加速了开发，能节省出很多时间来干其他事。</p><p>Spring框架刚出来时主要就是来完成这个功能。</p><p>Spring框架除了帮我们管理对象及其依赖关系，还提供像通用日志记录、性能统计、安全控制、异常处理等面向切面的能力，还能帮我管理最头疼的数据库事务，</p><p>本身提供了一套简单的JDBC访问实现，提供与第三方数据访问框架集成（如Hibernate、JPA），与各种Java EE技术整合（如Java Mail、任务调度等等）。</p><p>提供一套自己的web层框架Spring MVC、而且还能非常简单的与第三方web框架集成。而且不管是JAVA SE（C&#x2F;S架构）应用程序还是JAVA EE（B&#x2F;S架构）应用程序都可以使用这个平台进行开发。</p><p>从这里可以认为Spring是一个超级粘合平台，除了自己提供功能外，还提供粘合其他技术和框架的能力，从而使可以更自由的选择到底使用什么技术进行开发。</p><h2 id="二-Spring能帮我们做什么"><a href="#二-Spring能帮我们做什么" class="headerlink" title="二.Spring能帮我们做什么"></a>二.Spring能帮我们做什么</h2><p>Spring除了不能帮助写业务逻辑，其余的几乎什么都能帮助简化开发：</p><h3 id="1、传统程序开发"><a href="#1、传统程序开发" class="headerlink" title="1、传统程序开发"></a>1、传统程序开发</h3><p>创建对象及组装对象间依赖关系由我们在程序内部进行控制，这样会加大各个对象间的耦合，如果我们要修改对象间的依赖关系就必须修改源代码，重新编译、部署；而如果采用Spring，</p><p>则由Spring根据配置文件来进行创建及组装对象间依赖关系，只需要改配置文件即可，无需重新编译。所以，<strong>Spring能帮我们根据配置文件创建及组装对象之间的依赖关系。</strong></p><h3 id="2、实现日志记录，性能统计，安全控制"><a href="#2、实现日志记录，性能统计，安全控制" class="headerlink" title="2、实现日志记录，性能统计，安全控制"></a><strong>2</strong>、<strong>实现日志记录，性能统计，安全控制</strong></h3><p>当进行一些日志记录、权限控制、性能统计等时，在传统应用程序当中我们可能在需要的对象或方法中进行，而且比如权限控制、性能统计大部分是重复的，</p><p>这样代码中就存在大量重复代码，即使有人说我把通用部分提取出来，那必然存在调用还是存在重复，像性能统计我们可能只是在必要时才进行，在诊断完毕后要删除这些代码；</p><p>还有日志记录，比如记录一些方法访问日志、数据访问日志等等，这些都会渗透到各个要访问方法中；</p><p>还有权限控制，必须在方法执行开始进行审核，想想这些是多么可怕而且是多么无聊的工作。</p><p>如果采用Spring，这些日志记录、权限控制、性能统计从业务逻辑中分离出来，通过Spring支持的面向切面编程，在需要这些功能的地方动态添加这些功能，</p><p>无需渗透到各个需要的方法或对象中；有人可能说了，我们可以使用“代理设计模式”或“包装器设计模式”，你可以使用这些，</p><p>但还是需要通过编程方式来创建代理对象，还是要耦合这些代理对象，而采用Spring 面向切面编程能提供一种更好的方式来完成上述功能，</p><p>一般通过配置方式，而且不需要在现有代码中添加任何额外代码，现有代码专注业务逻辑。</p><h3 id="3、管理数据库事务"><a href="#3、管理数据库事务" class="headerlink" title="3、管理数据库事务"></a><strong>3</strong>、<strong>管理数据库事务</strong></h3><p>在传统应用程序当中，我们如何来完成数据库事务管理？需要一系列“获取连接，执行SQL，提交或回滚事务，关闭连接”，</p><p>而且还要保证在最后一定要关闭连接，多么可怕的事情，而且也很无聊；如果采用Spring，我们只需获取连接，执行SQL，其他的都交给Spring来管理了。</p><p>4、Spring还提供了与第三方数据访问框架（如Hibernate、JPA）无缝集成，而且自己也提供了一套JDBC访问模板，来方便数据库访问。</p><p>5、Spring还提供与第三方Web（如Struts、JSF）框架无缝集成，而且自己也提供了一套Spring MVC框架，来方便web层搭建。</p><p>6、Spring能方便的与Java EE（如Java Mail、任务调度）整合，与更多技术整合（比如缓存框架）。</p><p>总结：</p><p>Spring能帮我们做这么多事情，提供这么多功能和与那么多主流技术整合，而且是帮我们做了开发中比较头疼和困难的事情，那可能有人会问，</p><p>难道只有Spring这一个框架，没有其他选择？当然有，比如EJB需要依赖应用服务器、开发效率低。</p><p>在开发中小型项目是宰鸡拿牛刀，虽然发展到现在EJB比较好用了，但还是比较笨重还需要依赖应用服务器等。</p><h2 id="三-为何需要Spring"><a href="#三-为何需要Spring" class="headerlink" title="三.为何需要Spring"></a>三.为何需要Spring</h2><h3 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h3><p><strong>（1）应用程序</strong>：是能完成我们所需要功能的成品，比如购物网站、OA系统。</p><p><strong>（2）框架</strong>：是能完成一定功能的半成品，比如我们可以使用框架进行购物网站开发；框架做一部分功能，我们自己做一部分功能，这样应用程序就创建出来了。</p><p>而且框架规定了你在开发应用程序时的整体架构，提供了一些基础功能，还规定了类和对象的如何创建、如何协作等，从而简化我们开发，让我们专注于业务逻辑开发。</p><p><strong>（3）非侵入式设计</strong>：从框架角度可以这样理解，无需继承框架提供的类，这种设计就可以看作是非侵入式设计，如果继承了这些框架类，就是侵入设计，</p><p>如果以后想更换框架之前写过的代码几乎无法重用，如果非侵入式设计则之前写过的代码仍然可以继续使用。</p><p><strong>（4）轻量级及重量级</strong>：轻量级是相对于重量级而言的，轻量级一般就是非入侵性的、所依赖的东西非常少、资源占用非常少、部署简单等等，其实就是比较容易使用，而重量级正好相反。</p><p><strong>（5）POJO</strong>：POJO（Plain Old Java Objects）简单的Java对象，它可以包含业务逻辑或持久化逻辑，但不担当任何特殊角色且不继承或不实现任何其它Java框架的类或接口。</p><p><strong>（6）容器</strong>：在日常生活中容器就是一种盛放东西的器具，从程序设计角度看就是装对象的的对象，因为存在放入、拿出等操作，所以容器还要管理对象的生命周期。</p><p><strong>（7）控制反转：</strong>即Inversion of Control，缩写为IoC，控制反转还有一个名字叫做依赖注入（Dependency Injection），就是由容器控制程序之间的关系，而非传统实现中，由程序代码直接操控。</p><p><strong>（8）Bean：</strong>一般指容器管理对象，在Spring中指Spring IoC容器管理对象。</p><h3 id="2、Spring的优点"><a href="#2、Spring的优点" class="headerlink" title="2、Spring的优点"></a>2、Spring的优点</h3><p><strong>（1）非常轻量级的容器</strong>：</p><p>以集中的、自动化的方式进行应用程序对象创建和装配，负责对象创建和装配，管理对象生命周期，能组合成复杂的应用程序。</p><p>Spring容器是非侵入式的（不需要依赖任何Spring特定类），而且完全采用POJOs进行开发，使应用程序更容易测试、更容易管理。</p><p>而且核心JAR包非常小，Spring 3.0.5不到1M，而且不需要依赖任何应用服务器，可以部署在任何环境（Java SE或Java EE）。</p><p><strong>（2）AOP</strong>：</p><p>AOP是Aspect Oriented Programming的缩写，意思是面向切面编程，提供从另一个角度来考虑程序结构以完善面向对象编程（相对于OOP），</p><p>即可以通过在编译期间、装载期间或运行期间实现在不修改源代码的情况下给程序动态添加功能的一种技术。通俗点说就是把可重用的功能提取出来，</p><p>然后将这些通用功能在合适的时候织入到应用程序中；比如安全，日记记录，这些都是通用的功能，我们可以把它们提取出来，</p><p>然后在程序执行的合适地方织入这些代码并执行它们，从而完成需要的功能并复用了这些功能。</p><p><strong>（3）简单的数据库事务管理</strong>：</p><p>在使用数据库的应用程序当中，自己管理数据库事务是一项很让人头疼的事，而且很容易出现错误，Spring支持可插入的事务管理支持，</p><p>而且无需JEE环境支持，通过Spring管理事务可以把我们从事务管理中解放出来来专注业务逻辑。</p><p><strong>（4）JDBC<strong><strong>抽象及ORM</strong></strong>框架支持</strong>：</p><p>Spring使JDBC更加容易使用；提供DAO（数据访问对象）支持，非常方便集成第三方ORM框架，比如Hibernate等；</p><p>并且完全支持Spring事务和使用Spring提供的一致的异常体系。</p><p><strong>（5）灵活的Web****层支持</strong>：Spring本身提供一套非常强大的MVC框架，而且可以非常容易的与第三方MVC框架集成，比如Struts等。</p><p><strong>（6）简化各种技术集成</strong>：</p><p>提供对Java Mail、任务调度、JMX、JMS、JNDI、EJB、动态语言、远程访问、Web Service等的集成。</p><p>Spring能帮助我们简化应用程序开发，帮助我们创建和组装对象，为我们管理事务，简单的MVC框架，可以把Spring看作是一个超级粘合平台，</p><p>能把很多技术整合在一起，形成一个整体，使系统结构更优良、性能更出众，从而加速我们程序开发，有如上优点，我们没有理由不考虑使用它。</p><h2 id="四-如何学好Spring"><a href="#四-如何学好Spring" class="headerlink" title="四.如何学好Spring"></a>四.如何学好Spring</h2><p>要学好Spring，首先要明确Spring是个什么东西，能帮我们做些什么事情，知道了这些然后做个简单的例子，这样就基本知道怎么使用Spring了。</p><p>Spring核心是IoC容器，所以一定要透彻理解什么是IoC容器，以及如何配置及使用容器，其他所有技术都是基于容器实现的；</p><p>理解好IoC后，接下来是面向切面编程，首先还是明确概念，基本配置，最后是实现原理，接下来就是数据库事务管理，其实Spring管理事务是通过面向切面编程实现的，</p><p>所以基础很重要，IoC容器和面向切面编程搞定后，其余都是基于这俩东西的实现，学起来就更加轻松了。要学好Spring不能急，一定要把基础打牢，基础牢固了，这就是磨刀不误砍柴工。</p><h2 id="五-Spring架构图"><a href="#五-Spring架构图" class="headerlink" title="五.Spring架构图"></a>五.Spring架构图</h2><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403042119818.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403042120161.png"></p><h3 id="1、核心容器"><a href="#1、核心容器" class="headerlink" title="1、核心容器"></a>1、核心容器</h3><p>包括Core、Beans、Context、EL模块。</p><p><strong>（1）Core模块：</strong>封装了框架依赖的最底层部分，包括资源访问、类型转换及一些常用工具类。</p><p><strong>（2）Beans模块：</strong></p><p>提供了框架的基础部分，包括反转控制和依赖注入。其中Bean Factory是容器核心，本质是“工厂设计模式”的实现，而且无需编程实现“单例设计模式”，</p><p>单例完全由容器控制，而且提倡面向接口编程，而非面向实现编程；所有应用程序对象及对象间关系由框架管理，</p><p>从而真正把你从程序逻辑中把维护对象之间的依赖关系提取出来，所有这些依赖关系都由BeanFactory来维护。</p><p><strong><strong><strong>（3）</strong></strong>Context</strong><strong>模块：</strong>以Core和Beans为基础，集成Beans模块功能并添加资源绑定、数据验证、国际化<strong>、</strong>Java EE支持、容器生命周期、事件传播等；核心接口是ApplicationContext。</p><p><strong><strong><strong>（4）</strong></strong>EL</strong><strong>模块：</strong>提供强大的表达式语言支持，支持访问和修改属性值，方法调用，支持访问及修改数组、容器和索引器，命名变量，支持算数和逻辑运算，</p><p>                         支持从Spring 容器获取Bean，它也支持列表投影、选择和一般的列表聚合等。</p><h3 id="2、AOP、Aspects模块"><a href="#2、AOP、Aspects模块" class="headerlink" title="2、AOP、Aspects模块"></a><strong>2、AOP、Aspects模块</strong></h3><p><strong>（1）AOP模块：</strong></p><p>Spring AOP模块提供了符合 AOP Alliance规范的面向方面的编程（aspect-oriented programming）实现，提供比如日志记录、权限控制、</p><p>性能统计等通用功能和业务逻辑分离的技术，并且能动态的把这些功能添加到需要的代码中；这样各专其职，降低业务逻辑和通用功能的耦合。</p><p>（2）Aspects模块：提供了对AspectJ的集成，AspectJ提供了比Spring ASP更强大的功能。</p><h3 id="3、数据访问-x2F-集成模块"><a href="#3、数据访问-x2F-集成模块" class="headerlink" title="3、数据访问&#x2F;集成模块"></a><strong>3、数据访问&#x2F;集成模块</strong></h3><p>该模块包括了JDBC、ORM、OXM、JMS和事务管理。</p><p>（1）事务模块：该模块用于Spring管理事务，只要是Spring管理对象都能得到Spring管理事务的好处，无需在代码中进行事务控制了，而且支持编程和声明性的事物管理。</p><p>（2）JDBC模块：提供了一个JBDC的样例模板，使用这些模板能消除传统冗长的JDBC编码还有必须的事务控制，而且能享受到Spring管理事务的好处。</p><p>（3）ORM模块：提供与流行的“对象-关系”映射框架的无缝集成，包括Hibernate、JPA、Ibatiss等。而且可以使用Spring事务管理，无需额外控制事务。</p><p>（4）OXM模块：提供了一个对Object&#x2F;XML映射实现，将java对象映射成XML数据，或者将XML数据映射成java对象，Object&#x2F;XML映射实现包括JAXB、Castor、XMLBeans和XStream。</p><p>（6）JMS模块：用于JMS(Java Messaging Service)，提供一套 “消息生产者、消息消费者”模板用于更加简单的使用JMS，JMS用于用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。</p><h3 id="4、Web-x2F-Remoting模块"><a href="#4、Web-x2F-Remoting模块" class="headerlink" title="4、Web&#x2F;Remoting模块"></a><strong>4、Web&#x2F;Remoting模块</strong></h3><p>Web&#x2F;Remoting模块包含了Web、Web-Servlet、Web-Struts、Web-Porlet模块。</p><p>（1）Web模块：提供了基础的web功能。例如多文件上传、集成IoC容器、远程过程访问（RMI、Hessian、Burlap）以及Web Service支持，并提供一个RestTemplate类来提供方便的Restful services访问。</p><p>（2）Web-Servlet模块：提供了一个Spring MVC Web框架实现。</p><p>         Spring MVC框架提供了基于注解的请求资源注入、更简单的数据绑定、数据验证等及一套非常易用的JSP标签，完全无缝与Spring其他技术协作。</p><p>（3）Web-Struts模块：提供了与Struts无缝集成，Struts1.x 和Struts2.x都支持。</p><h3 id="5、Test模块"><a href="#5、Test模块" class="headerlink" title="5、Test模块"></a><strong>5、Test模块</strong></h3><p>Spring支持Junit和TestNG测试框架，而且还额外提供了一些基于Spring的测试功能，比如在测试Web框架时，模拟Http请求的功能。</p><h2 id="六-典型应用场景"><a href="#六-典型应用场景" class="headerlink" title="六.典型应用场景"></a>六.典型应用场景</h2><p>Spring可以应用到许多场景，从最简单的标准Java SE程序到企业级应用程序都能使用Spring来构建。以下介绍几个比较流行的应用场景：</p><h3 id="1、典型Web应用程序应用场景："><a href="#1、典型Web应用程序应用场景：" class="headerlink" title="1、典型Web应用程序应用场景："></a><strong>1、典型Web应用程序应用场景：</strong></h3><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403042121681.png"></p><p>在Web应用程序应用场景中，典型的三层架构：数据模型层实现域对象；数据访问层实现数据访问；逻辑层实现业务逻辑；</p><p>web层提供页面展示；所有这些层组件都由Spring进行管理，享受到Spring事务管理、AOP等好处，</p><p>而且请求唯一入口就是DispachterServlet，它通过把请求映射为相应web层组件来实现相应请求功能。</p><h3 id="2、远程访问应用场景"><a href="#2、远程访问应用场景" class="headerlink" title="2、远程访问应用场景"></a><strong>2、远程访问应用场景</strong></h3><p>Spring能非常方便的提供暴露RMI服务，远程访问服务如Hessian、Burlap等，实现非常简单只需通过在Spring中配置相应的地址及需要暴露的服务即可轻松实现；</p><h3 id="3、EJB应用场景："><a href="#3、EJB应用场景：" class="headerlink" title="3、EJB应用场景："></a><strong>3、EJB应用场景：</strong></h3><p>Spring也可以与EJB轻松集成。</p>]]></content>
    
    
    <categories>
      
      <category>spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于并发编程（下）</title>
    <link href="/posts/a4f048b3/"/>
    <url>/posts/a4f048b3/</url>
    
    <content type="html"><![CDATA[<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402211423293.png"></p><hr><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><h3 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h3><h4 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h4><p>Java 内存模型是 Java Memory Model（JMM），本身是一种<strong>抽象的概念</strong>，实际上并不存在，描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式</p><p>JMM 作用：</p><ul><li><p>屏蔽各种硬件和操作系统的内存访问差异，实现让 Java 程序在各种平台下都能达到一致的内存访问效果</p></li><li><p>规定了线程和内存之间的一些关系</p></li></ul><p>根据 JMM 的设计，系统存在一个主内存（Main Memory），Java 中所有变量都存储在主存中，对于所有线程都是共享的；每条线程都有自己的工作内存（Working Memory），工作内存中保存的是主存中某些<strong>变量的拷贝</strong>，线程对所有变量的操作都是先对变量进行拷贝，然后在工作内存中进行，不能直接操作主内存中的变量；线程之间无法相互直接访问，线程间的通信（传递）必须通过主内存来完成</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041651883.png"></p><p>主内存和工作内存：</p><ul><li><p>主内存：计算机的内存，也就是经常提到的 8G 内存，16G 内存，存储所有共享变量的值</p></li><li><p>工作内存：存储该线程使用到的共享变量在主内存的的值的副本拷贝</p></li></ul><p><strong>JVM 和 JMM 之间的关系</strong>：JMM 中的主内存、工作内存与 JVM 中的 Java 堆、栈、方法区等并不是同一个层次的内存划分，这两者基本上是没有关系的，如果两者一定要勉强对应起来：</p><ul><li><p>主内存主要对应于 Java 堆中的对象实例数据部分，而工作内存则对应于虚拟机栈中的部分区域</p></li><li><p>从更低层次上说，主内存直接对应于物理硬件的内存，工作内存对应寄存器和高速缓存</p></li></ul><hr><h4 id="内存交互"><a href="#内存交互" class="headerlink" title="内存交互"></a>内存交互</h4><p>Java 内存模型定义了 8 个操作来完成主内存和工作内存的交互操作，每个操作都是<strong>原子</strong>的</p><p>非原子协定：没有被 volatile 修饰的 long、double 外，默认按照两次 32 位的操作</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041652749.png"></p><ul><li><p>lock：作用于主内存，将一个变量标识为被一个线程独占状态（对应 monitorenter）</p></li><li><p>unclock：作用于主内存，将一个变量从独占状态释放出来，释放后的变量才可以被其他线程锁定（对应 monitorexit）</p></li><li><p>read：作用于主内存，把一个变量的值从主内存传输到工作内存中</p></li><li><p>load：作用于工作内存，在 read 之后执行，把 read 得到的值放入工作内存的变量副本中</p></li><li><p>use：作用于工作内存，把工作内存中一个变量的值传递给<strong>执行引擎</strong>，每当遇到一个使用到变量的操作时都要使用该指令</p></li><li><p>assign：作用于工作内存，把从执行引擎接收到的一个值赋给工作内存的变量</p></li><li><p>store：作用于工作内存，把工作内存的一个变量的值传送到主内存中</p></li><li><p>write：作用于主内存，在 store 之后执行，把 store 得到的值放入主内存的变量中</p></li></ul><hr><h4 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h4><h5 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h5><p>可见性：是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值</p><p>存在不可见问题的根本原因是由于缓存的存在，线程持有的是共享变量的副本，无法感知其他线程对于共享变量的更改，导致读取的值不是最新的。但是 final 修饰的变量是<strong>不可变</strong>的，就算有缓存，也不会存在不可见的问题</p><p>main 线程对 run 变量的修改对于 t 线程不可见，导致了 t 线程无法停止：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">run</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">//添加volatile  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;  <br>        <span class="hljs-keyword">while</span>(run)&#123;  <br>        <span class="hljs-comment">// ....  </span><br>        &#125;  <br>&#125;);  <br>    t.start();  <br>    sleep(<span class="hljs-number">1</span>);  <br>    run = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 线程t不会如预想的停下来  </span><br>&#125;<br></code></pre></td></tr></table></figure><p>原因：</p><ul><li><p>初始状态， t 线程刚开始从主内存读取了 run 的值到工作内存</p></li><li><p>因为 t 线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值缓存至自己工作内存中的高速缓存中，减少对主存中 run 的访问，提高效率</p></li><li><p>1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量的值，结果永远是旧值</p></li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041653387.png"></p><hr><h5 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h5><p>原子性：不可分割，完整性，也就是说某个线程正在做某个具体业务时，中间不可以被分割，需要具体完成，要么同时成功，要么同时失败，保证指令不会受到线程上下文切换的影响</p><p>定义原子操作的使用规则：</p><ol><li><p>不允许 read 和 load、store 和 write 操作之一单独出现，必须顺序执行，但是不要求连续</p></li><li><p>不允许一个线程丢弃 assign 操作，必须同步回主存</p></li><li><p>不允许一个线程无原因地（没有发生过任何 assign 操作）把数据从工作内存同步会主内存中</p></li><li><p>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（assign 或者 load）的变量，即对一个变量实施 use 和 store 操作之前，必须先自行 assign 和 load 操作</p></li><li><p>一个变量在同一时刻只允许一条线程对其进行 lock 操作，但 lock 操作可以被同一线程重复执行多次，多次执行 lock 后，只有<strong>执行相同次数的 unlock</strong> 操作，变量才会被解锁，<strong>lock 和 unlock 必须成对出现</strong></p></li><li><p>如果对一个变量执行 lock 操作，将会<strong>清空工作内存中此变量的值</strong>，在执行引擎使用这个变量之前需要重新从主存加载</p></li><li><p>如果一个变量事先没有被 lock 操作锁定，则不允许执行 unlock 操作，也不允许去 unlock 一个被其他线程锁定的变量</p></li><li><p>对一个变量执行 unlock 操作之前，必须<strong>先把此变量同步到主内存</strong>中（执行 store 和 write 操作）</p></li></ol><hr><h5 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h5><p>有序性：在本线程内观察，所有操作都是有序的；在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序</p><p>CPU 的基本工作是执行存储的指令序列，即程序，程序的执行过程实际上是不断地取出指令、分析指令、执行指令的过程，为了提高性能，编译器和处理器会对指令重排，一般分为以下三种：</p><p>源代码 -&gt; 编译器优化的重排 -&gt; 指令并行的重排 -&gt; 内存系统的重排 -&gt; 最终执行指令</p><p>现代 CPU 支持多级指令流水线，几乎所有的冯•诺伊曼型计算机的 CPU，其工作都可以分为 5 个阶段：取指令、指令译码、执行指令、访存取数和结果写回，可以称之为<strong>五级指令流水线</strong>。CPU 可以在一个时钟周期内，同时运行五条指令的<strong>不同阶段</strong>（每个线程不同的阶段），本质上流水线技术并不能缩短单条指令的执行时间，但变相地提高了指令地吞吐率</p><p>处理器在进行重排序时，必须要考虑<strong>指令之间的数据依赖性</strong></p><ul><li><p>单线程环境也存在指令重排，由于存在依赖性，最终执行结果和代码顺序的结果一致</p></li><li><p>多线程环境中线程交替执行，由于编译器优化重排，会获取其他线程处在不同阶段的指令同时执行</p></li></ul><p>补充知识：</p><ul><li><p>指令周期是取出一条指令并执行这条指令的时间，一般由若干个机器周期组成</p></li><li><p>机器周期也称为 CPU 周期，一条指令的执行过程划分为若干个阶段（如取指、译码、执行等），每一阶段完成一个基本操作，完成一个基本操作所需要的时间称为机器周期</p></li><li><p>振荡周期指周期性信号作周期性重复变化的时间间隔</p></li></ul><hr><h3 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h3><h4 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h4><h5 id="缓存结构"><a href="#缓存结构" class="headerlink" title="缓存结构"></a>缓存结构</h5><p>在计算机系统中，CPU 高速缓存（CPU Cache，简称缓存）是用于减少处理器访问内存所需平均时间的部件；在存储体系中位于自顶向下的第二层，仅次于 CPU 寄存器；其容量远小于内存，但速度却可以接近处理器的频率</p><p>CPU 处理器速度远远大于在主内存中的，为了解决速度差异，在它们之间架设了多级缓存，如 L1、L2、L3 级别的缓存，这些缓存离 CPU 越近就越快，将频繁操作的数据缓存到这里，加快访问速度</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041653288.png"></p><table><thead><tr><th>从 CPU 到</th><th>大约需要的时钟周期</th></tr></thead><tbody><tr><td>寄存器</td><td>1 cycle (4GHz 的 CPU 约为 0.25ns)</td></tr><tr><td>L1</td><td>3~4 cycle</td></tr><tr><td>L2</td><td>10~20 cycle</td></tr><tr><td>L3</td><td>40~45 cycle</td></tr><tr><td>内存</td><td>120~240 cycle</td></tr></tbody></table><h5 id="缓存使用"><a href="#缓存使用" class="headerlink" title="缓存使用"></a>缓存使用</h5><p>当处理器发出内存访问请求时，会先查看缓存内是否有请求数据，如果存在（命中），则不用访问内存直接返回该数据；如果不存在（失效），则要先把内存中的相应数据载入缓存，再将其返回处理器</p><p>缓存之所以有效，主要因为程序运行时对内存的访问呈现局部性（Locality）特征。既包括空间局部性（Spatial Locality），也包括时间局部性（Temporal Locality），有效利用这种局部性，缓存可以达到极高的命中率</p><hr><h4 id="伪共享"><a href="#伪共享" class="headerlink" title="伪共享"></a>伪共享</h4><p><strong>缓存以缓存行 cache line 为单位</strong>，每个缓存行对应着一块内存，一般是 64 byte（8 个 long），在 CPU 从主存获取数据时，以 cache line 为单位加载，于是相邻的数据会一并加载到缓存中</p><p>缓存会造成数据副本的产生，即同一份数据会缓存在不同核心的缓存行中，CPU 要保证数据的一致性，需要做到某个 CPU 核心更改了数据，其它 CPU 核心对应的<strong>整个缓存行必须失效</strong>，这就是伪共享</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041653250.png"></p><p>解决方法：</p><ul><li><p>padding：通过填充，让数据落在不同的 cache line 中</p></li><li><p>@Contended：原理参考 无锁 → Adder → 优化机制 → 伪共享</p></li></ul><p>Linux 查看 CPU 缓存行：</p><ul><li><p>命令：<code>cat /sys/devices/system/cpu/cpu0/cache/index0/coherency_line_size64</code></p></li><li><p>内存地址格式： [ 高位组标记 ] [ 低位索引 ] [ 偏移量 ]</p></li></ul><hr><h4 id="缓存一致"><a href="#缓存一致" class="headerlink" title="缓存一致"></a>缓存一致</h4><p>缓存一致性：当多个处理器运算任务都涉及到同一块主内存区域的时候，将可能导致各自的缓存数据不一样</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041655075.png"></p><p>MESI（Modified Exclusive Shared Or Invalid）是一种广泛使用的<strong>支持写回策略的缓存一致性协议</strong>，CPU 中每个缓存行（caceh line）使用 4 种状态进行标记（使用额外的两位 bit 表示)：</p><ul><li><p>M：被修改（Modified）</p><p>  该缓存行只被缓存在该 CPU 的缓存中，并且是被修改过的，与主存中的数据不一致 (dirty)，该缓存行中的内存需要写回 (write back) 主存。该状态的数据再次被修改不会发送广播，因为其他核心的数据已经在第一次修改时失效一次</p><p>  当被写回主存之后，该缓存行的状态会变成独享 (exclusive) 状态</p></li><li><p>E：独享的（Exclusive）</p><p>  该缓存行只被缓存在该 CPU 的缓存中，是未被修改过的 (clear)，与主存中数据一致，修改数据不需要通知其他 CPU 核心，该状态可以在任何时刻有其它 CPU 读取该内存时变成共享状态 (shared)</p><p>  当 CPU 修改该缓存行中内容时，该状态可以变成 Modified 状态</p></li><li><p>S：共享的（Shared）</p><p>  该状态意味着该缓存行可能被多个 CPU 缓存，并且各个缓存中的数据与主存数据一致，当 CPU 修改该缓存行中，会向其它 CPU 核心广播一个请求，使该缓存行变成无效状态 (Invalid)，然后再更新当前 Cache 里的数据</p></li><li><p>I：无效的（Invalid）</p><p>  该缓存是无效的，可能有其它 CPU 修改了该缓存行</p></li></ul><p>解决方法：各个处理器访问缓存时都遵循一些协议，在读写时要根据协议进行操作，协议主要有 MSI、MESI 等</p><hr><h4 id="处理机制"><a href="#处理机制" class="headerlink" title="处理机制"></a>处理机制</h4><p>单核 CPU 处理器会自动保证基本内存操作的原子性</p><p>多核 CPU 处理器，每个 CPU 处理器内维护了一块内存，每个内核内部维护着一块缓存，当多线程并发读写时，就会出现缓存数据不一致的情况。处理器提供：</p><ul><li><p>总线锁定：当处理器要操作共享变量时，在 BUS 总线上发出一个 LOCK 信号，其他处理器就无法操作这个共享变量，该操作会导致大量阻塞，从而增加系统的性能开销（<strong>平台级别的加锁</strong>）</p></li><li><p>缓存锁定：当处理器对缓存中的共享变量进行了操作，其他处理器有嗅探机制，将各自缓存中的该共享变量的失效，读取时会重新从主内存中读取最新的数据，基于 MESI 缓存一致性协议来实现</p></li></ul><p>有如下两种情况处理器不会使用缓存锁定：</p><ul><li><p>当操作的数据跨多个缓存行，或没被缓存在处理器内部，则处理器会使用总线锁定</p></li><li><p>有些处理器不支持缓存锁定，比如：Intel 486 和 Pentium 处理器也会调用总线锁定</p></li></ul><p>总线机制：</p><ul><li><p>总线嗅探：每个处理器通过嗅探在总线上传播的数据来检查自己缓存值是否过期了，当处理器发现自己的缓存对应的内存地址的数据被修改，就<strong>将当前处理器的缓存行设置为无效状态</strong>，当处理器对这个数据进行操作时，会重新从内存中把数据读取到处理器缓存中</p></li><li><p>总线风暴：当某个 CPU 核心更新了 Cache 中的数据，要把该事件广播通知到其他核心（<strong>写传播</strong>），CPU 需要每时每刻监听总线上的一切活动，但是不管别的核心的 Cache 是否缓存相同的数据，都需要发出一个广播事件，不断的从主内存嗅探和 CAS 循环，无效的交互会导致总线带宽达到峰值；因此不要大量使用 volatile 关键字，使用 volatile、syschonized 都需要根据实际场景</p></li></ul><hr><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><h4 id="同步机制"><a href="#同步机制" class="headerlink" title="同步机制"></a>同步机制</h4><p>volatile 是 Java 虚拟机提供的<strong>轻量级</strong>的同步机制（三大特性）</p><ul><li><p>保证可见性</p></li><li><p>不保证原子性</p></li><li><p>保证有序性（禁止指令重排）</p></li></ul><p>性能：volatile 修饰的变量进行读操作与普通变量几乎没什么差别，但是写操作相对慢一些，因为需要在本地代码中插入很多内存屏障来保证指令不会发生乱序执行，但是开销比锁要小</p><p>synchronized 无法禁止指令重排和处理器优化，为什么可以保证有序性可见性</p><ul><li><p>加了锁之后，只能有一个线程获得到了锁，获得不到锁的线程就要阻塞，所以同一时间只有一个线程执行，相当于单线程，由于数据依赖性的存在，单线程的指令重排是没有问题的</p></li><li><p>线程加锁前，将<strong>清空工作内存</strong>中共享变量的值，使用共享变量时需要从主内存中重新读取最新的值；线程解锁前，必须把共享变量的最新值<strong>刷新到主内存</strong>中（JMM 内存交互章节有讲）</p></li></ul><hr><h4 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h4><p>volatile 修饰的变量，可以禁用指令重排</p><p>指令重排实例：</p><ul><li><p>example 1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mySort</span><span class="hljs-params">()</span> &#123;  <br><span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">11</span>;<span class="hljs-comment">//语句1  </span><br><span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> <span class="hljs-number">12</span>;<span class="hljs-comment">//语句2  谁先执行效果一样  </span><br>x = x + <span class="hljs-number">5</span>;<span class="hljs-comment">//语句3  </span><br>y = x * x;<span class="hljs-comment">//语句4  </span><br>&#125;<br>    <br>执行顺序是：<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>、<span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>、<span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span><br><br>指令重排也有限制不会出现：<span class="hljs-number">4321</span>，语句 <span class="hljs-number">4</span> 需要依赖于 y 以及 x 的申明，因为存在数据依赖，无法首先执行<br></code></pre></td></tr></table></figure></li><li><p>example 2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br><span class="hljs-type">boolean</span> <span class="hljs-variable">ready</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;  <br><span class="hljs-comment">// 线程1 执行此方法  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor1</span><span class="hljs-params">(I_Result r)</span> &#123;  <br><span class="hljs-keyword">if</span>(ready) &#123;  <br>r.r1 = num + num;  <br>&#125; <span class="hljs-keyword">else</span> &#123;  <br>r.r1 = <span class="hljs-number">1</span>;  <br>&#125;  <br>&#125;  <br><span class="hljs-comment">// 线程2 执行此方法  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor2</span><span class="hljs-params">(I_Result r)</span> &#123;  <br>num = <span class="hljs-number">2</span>;  <br>ready = <span class="hljs-literal">true</span>;  <br>&#125;<br><br>情况一：线程 <span class="hljs-number">1</span> 先执行，ready = <span class="hljs-literal">false</span>，结果为 r.r1 = <span class="hljs-number">1</span><br><br>情况二：线程 <span class="hljs-number">2</span> 先执行 num = <span class="hljs-number">2</span>，但还没执行 ready = <span class="hljs-literal">true</span>，线程 <span class="hljs-number">1</span> 执行，结果为 r.r1 = <span class="hljs-number">1</span><br><br>情况三：线程 <span class="hljs-number">2</span> 先执行 ready = <span class="hljs-literal">true</span>，线程 <span class="hljs-number">1</span> 执行，进入 <span class="hljs-keyword">if</span> 分支结果为 r.r1 = <span class="hljs-number">4</span><br><br>情况四：线程 <span class="hljs-number">2</span> 执行 ready = <span class="hljs-literal">true</span>，切换到线程 <span class="hljs-number">1</span>，进入 <span class="hljs-keyword">if</span> 分支为 r.r1 = <span class="hljs-number">0</span>，再切回线程 <span class="hljs-number">2</span> 执行 num = <span class="hljs-number">2</span>，发生指令重排<br></code></pre></td></tr></table></figure></li></ul><hr><h4 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h4><h5 id="缓存一致-1"><a href="#缓存一致-1" class="headerlink" title="缓存一致"></a>缓存一致</h5><p>使用 volatile 修饰的共享变量，底层通过汇编 lock 前缀指令进行缓存锁定，在线程修改完共享变量后写回主存，其他的 CPU 核心上运行的线程通过 CPU 总线嗅探机制会修改其共享变量为失效状态，读取时会重新从主内存中读取最新的数据</p><p>lock 前缀指令就相当于内存屏障，Memory Barrier（Memory Fence）</p><ul><li><p>对 volatile 变量的写指令后会加入写屏障</p></li><li><p>对 volatile 变量的读指令前会加入读屏障</p></li></ul><p>内存屏障有三个作用：</p><ul><li><p>确保对内存的读-改-写操作原子执行</p></li><li><p>阻止屏障两侧的指令重排序</p></li><li><p>强制把缓存中的脏数据写回主内存，让缓存行中相应的数据失效</p></li></ul><hr><h5 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h5><p>保证<strong>可见性</strong>：</p><ul><li><p>写屏障（sfence，Store Barrier）保证在该屏障之前的，对共享变量的改动，都同步到主存当中</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor2</span><span class="hljs-params">(I_Result r)</span> &#123;  <br>num = <span class="hljs-number">2</span>;  <br>ready = <span class="hljs-literal">true</span>; <span class="hljs-comment">// ready 是 volatile 赋值带写屏障  </span><br><span class="hljs-comment">// 写屏障  </span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>读屏障（lfence，Load Barrier）保证在该屏障之后的，对共享变量的读取，从主存刷新变量值，加载的是主存中最新数据</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor1</span><span class="hljs-params">(I_Result r)</span> &#123;  <br><span class="hljs-comment">// 读屏障  </span><br><span class="hljs-comment">// ready 是 volatile 读取值带读屏障  </span><br><span class="hljs-keyword">if</span>(ready) &#123;  <br>r.r1 = num + num;  <br>&#125; <span class="hljs-keyword">else</span> &#123;  <br>r.r1 = <span class="hljs-number">1</span>;  <br>&#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041658375.png"></p></li><li><p>全能屏障：mfence（modify&#x2F;mix Barrier），兼具 sfence 和 lfence 的功能</p></li></ul><p>保证<strong>有序性</strong>：</p><ul><li><p>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</p></li><li><p>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</p></li></ul><p>不能解决指令交错：</p><ul><li><p>写屏障仅仅是保证之后的读能够读到最新的结果，但不能保证其他线程的读跑到写屏障之前</p></li><li><p>有序性的保证也只是保证了本线程内相关代码不被重排序</p><p>  volatile i &#x3D; 0;<br>  new Thread(() -&gt; {i++});<br>  new Thread(() -&gt; {i–});</p><p>  i++ 反编译后的指令：</p><p>  0: iconst_1&#x2F;&#x2F; 当int取值 -1~5 时，JVM采用iconst指令将常量压入栈中<br>  1: istore_1&#x2F;&#x2F; 将操作数栈顶数据弹出，存入局部变量表的 slot 1<br>  2: iinc1, 1</p><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041659289.png"></p></li></ul><hr><h5 id="交互规则"><a href="#交互规则" class="headerlink" title="交互规则"></a>交互规则</h5><p>对于 volatile 修饰的变量：</p><ul><li><p>线程对变量的 use 与 load、read 操作是相关联的，所以变量使用前必须先从主存加载</p></li><li><p>线程对变量的 assign 与 store、write 操作是相关联的，所以变量使用后必须同步至主存</p></li><li><p>线程 1 和线程 2 谁先对变量执行 read 操作，就会先进行 write 操作，防止指令重排</p></li></ul><hr><h4 id="双端检锁"><a href="#双端检锁" class="headerlink" title="双端检锁"></a>双端检锁</h4><h5 id="检锁机制"><a href="#检锁机制" class="headerlink" title="检锁机制"></a>检锁机制</h5><p>Double-Checked Locking：双端检锁机制</p><p>DCL（双端检锁）机制不一定是线程安全的，原因是有指令重排的存在，加入 volatile 可以禁止指令重排</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123; &#125;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;  <br>      <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">if</span>(INSTANCE == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// t2，这里的判断不是线程安全的  </span><br>            <span class="hljs-comment">// 首次访问会同步，而之后的使用没有 synchronized  </span><br>            <span class="hljs-keyword">synchronized</span>(Singleton.class) &#123;  <br>                <span class="hljs-comment">// 这里是线程安全的判断，防止其他线程在当前线程等待锁的期间完成了初始化  </span><br>                <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-literal">null</span>) &#123;   <br>                    INSTANCE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();  <br>                &#125;  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> INSTANCE;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>不锁 INSTANCE 的原因：</p><ul><li><p>INSTANCE 要重新赋值</p></li><li><p>INSTANCE 是 null，线程加锁之前需要获取对象的引用，设置对象头，null 没有引用</p></li></ul><p>实现特点：</p><ul><li><p>懒惰初始化</p></li><li><p>首次使用 getInstance() 才使用 synchronized 加锁，后续使用时无需加锁</p></li><li><p>第一个 if 使用了 INSTANCE 变量，是在同步块之外，但在多线程环境下会产生问题</p></li></ul><hr><h5 id="DCL问题"><a href="#DCL问题" class="headerlink" title="DCL问题"></a>DCL问题</h5><p>getInstance 方法对应的字节码为：</p><figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs ldif"><br><span class="hljs-attribute">0</span>: getstatic <span class="hljs-comment">#2 // Field INSTANCE:Ltest/Singleton;  </span><br><span class="hljs-attribute">3</span>: ifnonnull 37  <br><span class="hljs-attribute">6</span>: ldc <span class="hljs-comment">#3 // class test/Singleton  </span><br><span class="hljs-attribute">8</span>: dup  <br><span class="hljs-attribute">9</span>: astore_0  <br><span class="hljs-attribute">10</span>: monitorenter  <br><span class="hljs-attribute">11</span>: getstatic <span class="hljs-comment">#2 // Field INSTANCE:Ltest/Singleton;  </span><br><span class="hljs-attribute">14</span>: ifnonnull 27  <br><span class="hljs-attribute">17</span>: new <span class="hljs-comment">#3 // class test/Singleton  </span><br><span class="hljs-attribute">20</span>: dup  <br><span class="hljs-attribute">21</span>: invokespecial <span class="hljs-comment">#4 // Method &quot;&lt;init&gt;&quot;:()V  </span><br><span class="hljs-attribute">24</span>: putstatic <span class="hljs-comment">#2 // Field INSTANCE:Ltest/Singleton;  </span><br><span class="hljs-attribute">27</span>: aload_0  <br><span class="hljs-attribute">28</span>: monitorexit  <br><span class="hljs-attribute">29</span>: goto 37  <br><span class="hljs-attribute">32</span>: astore_1  <br><span class="hljs-attribute">33</span>: aload_0  <br><span class="hljs-attribute">34</span>: monitorexit  <br><span class="hljs-attribute">35</span>: aload_1  <br><span class="hljs-attribute">36</span>: athrow  <br><span class="hljs-attribute">37</span>: getstatic <span class="hljs-comment">#2 // Field INSTANCE:Ltest/Singleton;  </span><br><span class="hljs-attribute">40</span>: areturn<br></code></pre></td></tr></table></figure><ul><li><p>17 表示创建对象，将对象引用入栈</p></li><li><p>20 表示复制一份对象引用，引用地址</p></li><li><p>21 表示利用一个对象引用，调用构造方法初始化对象</p></li><li><p>24 表示利用一个对象引用，赋值给 static INSTANCE</p></li></ul><p><strong>步骤 21 和 24 之间不存在数据依赖关系</strong>，而且无论重排前后，程序的执行结果在单线程中并没有改变，因此这种重排优化是允许的</p><ul><li><p>关键在于 0:getstatic 这行代码在 monitor 控制之外，可以越过 monitor 读取 INSTANCE 变量的值</p></li><li><p>当其他线程访问 INSTANCE 不为 null 时，由于 INSTANCE 实例未必已初始化，那么 t2 拿到的是将是一个未初始化完毕的单例返回，这就造成了线程安全的问题</p></li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041700443.png"></p><hr><h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><p>指令重排只会保证串行语义的执行一致性（单线程），但并不会关系多线程间的语义一致性</p><p>引入 volatile，来保证出现指令重排的问题，从而保证单例模式的线程安全性：</p><p><code>private static volatile SingletonDemo INSTANCE = null;</code></p><hr><h3 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h3><p>happens-before 先行发生</p><p>Java 内存模型具备一些先天的“有序性”，即不需要通过任何同步手段（volatile、synchronized 等）就能够得到保证的安全，这个通常也称为 happens-before 原则，它是可见性与有序性的一套规则总结</p><p>不符合 happens-before 规则，JMM 并不能保证一个线程的可见性和有序性</p><ol><li><p>程序次序规则 (Program Order Rule)：一个线程内，逻辑上书写在前面的操作先行发生于书写在后面的操作 ，因为多个操作之间有先后依赖关系，则不允许对这些操作进行重排序</p></li><li><p>锁定规则 (Monitor Lock Rule)：一个 unlock 操作先行发生于后面（时间的先后）对同一个锁的 lock 操作，所以线程解锁 m 之前对变量的写（解锁前会刷新到主内存中），对于接下来对 m 加锁的其它线程对该变量的读可见</p></li><li><p><strong>volatile 变量规则</strong> (Volatile Variable Rule)：对 volatile 变量的写操作先行发生于后面对这个变量的读</p></li><li><p>传递规则 (Transitivity)：具有传递性，如果操作 A 先行发生于操作 B，而操作 B 又先行发生于操作 C，则可以得出操作 A 先行发生于操作 C</p></li><li><p>线程启动规则 (Thread Start Rule)：Thread 对象的 start()方 法先行发生于此线程中的每一个操作</p><p> static int x &#x3D; 10;&#x2F;&#x2F;线程 start 前对变量的写，对该线程开始后对该变量的读可见<br> new Thread(()-&gt;{System.out.println(x);},”t1”).start();</p></li><li><p>线程中断规则 (Thread Interruption Rule)：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生</p></li><li><p>线程终止规则 (Thread Termination Rule)：线程中所有的操作都先行发生于线程的终止检测，可以通过 Thread.join() 方法结束、Thread.isAlive() 的返回值手段检测到线程已经终止执行</p></li><li><p>对象终结规则（Finaizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始</p></li></ol><hr><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><h4 id="终止模式"><a href="#终止模式" class="headerlink" title="终止模式"></a>终止模式</h4><p>终止模式之两阶段终止模式：停止标记用 volatile 是为了保证该变量在多个线程之间的可见性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TwoPhaseTermination</span> &#123;  <br>    <span class="hljs-comment">// 监控线程  </span><br>    <span class="hljs-keyword">private</span> Thread monitor;  <br>    <span class="hljs-comment">// 停止标记  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">stop</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;;  <br>  <br>    <span class="hljs-comment">// 启动监控线程  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;  <br>        monitor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;  <br>                <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> Thread.currentThread();  <br>                <span class="hljs-keyword">if</span> (stop) &#123;  <br>                    System.out.println(<span class="hljs-string">&quot;后置处理&quot;</span>);  <br>                    <span class="hljs-keyword">break</span>;  <br>                &#125;  <br>                <span class="hljs-keyword">try</span> &#123;  <br>                    Thread.sleep(<span class="hljs-number">1000</span>);<span class="hljs-comment">// 睡眠  </span><br>                    System.out.println(thread.getName() + <span class="hljs-string">&quot;执行监控记录&quot;</span>);  <br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>                   System.out.println(<span class="hljs-string">&quot;被打断，退出睡眠&quot;</span>);  <br>                &#125;  <br>            &#125;  <br>        &#125;);  <br>        monitor.start();  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 停止监控线程  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">()</span> &#123;  <br>        stop = <span class="hljs-literal">true</span>;  <br>        monitor.interrupt();<span class="hljs-comment">// 让线程尽快退出Timed Waiting  </span><br>    &#125;  <br>&#125;  <br><span class="hljs-comment">// 测试  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>    <span class="hljs-type">TwoPhaseTermination</span> <span class="hljs-variable">tpt</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TwoPhaseTermination</span>();  <br>    tpt.start();  <br>    Thread.sleep(<span class="hljs-number">3500</span>);  <br>    System.out.println(<span class="hljs-string">&quot;停止监控&quot;</span>);  <br>    tpt.stop();  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="Balking"><a href="#Balking" class="headerlink" title="Balking"></a>Balking</h4><p>Balking （犹豫）模式用在一个线程发现另一个线程或本线程已经做了某一件相同的事，那么本线程就无需再做了，直接结束返回</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MonitorService</span> </span>&#123;  <br>    <span class="hljs-comment">// 用来表示是否已经有线程已经在执行启动了  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> starting = <span class="hljs-keyword">false</span>;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;  <br>        System.out.println(<span class="hljs-string">&quot;尝试启动监控线程...&quot;</span>);  <br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;  <br>            <span class="hljs-keyword">if</span> (starting) &#123;  <br>            <span class="hljs-keyword">return</span>;  <br>            &#125;  <br>            starting = <span class="hljs-keyword">true</span>;  <br>        &#125;  <br>        <span class="hljs-comment">// 真正启动监控线程...  </span><br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>对比保护性暂停模式：保护性暂停模式用在一个线程等待另一个线程的执行结果，当条件不满足时线程等待</p><p>例子：希望 doInit() 方法仅被调用一次，下面的实现出现的问题：</p><ul><li><p>当 t1 线程进入 init() 准备 doInit()，t2 线程进来，initialized 还为f alse，则 t2 就又初始化一次</p></li><li><p>volatile 适合一个线程写，其他线程读的情况，这个代码需要加锁</p></li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TestVolatile</span> &#123;  <br>    <span class="hljs-keyword">volatile</span> boolean initialized = <span class="hljs-literal">false</span>;  <br>      <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span>()</span> &#123;  <br>        <span class="hljs-keyword">if</span> (initialized) &#123;  <br>            <span class="hljs-keyword">return</span>;  <br>        &#125;  <br>    doInit();  <br>    initialized = <span class="hljs-literal">true</span>;  <br>    &#125;  <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doInit</span>()</span> &#123;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h2><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>无锁编程：Lock Free</p><p>CAS 的全称是 Compare-And-Swap，是 <strong>CPU 并发原语</strong></p><ul><li><p>CAS 并发原语体现在 Java 语言中就是 sun.misc.Unsafe 类的各个方法，调用 UnSafe 类中的 CAS 方法，JVM 会实现出 CAS 汇编指令，这是一种完全依赖于硬件的功能，实现了原子操作</p></li><li><p>CAS 是一种系统原语，原语属于操作系统范畴，是由若干条指令组成 ，用于完成某个功能的一个过程，并且原语的执行必须是连续的，执行过程中不允许被中断，所以 CAS 是一条 CPU 的原子指令，不会造成数据不一致的问题，是线程安全的</p></li></ul><p>底层原理：CAS 的底层是 <code>lock cmpxchg</code> 指令（X86 架构），在单核和多核 CPU 下都能够保证比较交换的原子性</p><ul><li><p>程序是在单核处理器上运行，会省略 lock 前缀，单处理器自身会维护处理器内的顺序一致性，不需要 lock 前缀的内存屏障效果</p></li><li><p>程序是在多核处理器上运行，会为 cmpxchg 指令加上 lock 前缀。当某个核执行到带 lock 的指令时，CPU 会执行<strong>总线锁定或缓存锁定</strong>，将修改的变量写入到主存，这个过程不会被线程的调度机制所打断，保证了多个线程对内存操作的原子性</p></li></ul><p>作用：比较当前工作内存中的值和主物理内存中的值，如果相同则执行规定操作，否则继续比较直到主内存和工作内存的值一致为止</p><p>CAS 特点：</p><ul><li><p>CAS 体现的是<strong>无锁并发、无阻塞并发</strong>，线程不会陷入阻塞，线程不需要频繁切换状态（上下文切换，系统调用）</p></li><li><p>CAS 是基于乐观锁的思想</p></li></ul><p>CAS 缺点：</p><ul><li><p>执行的是循环操作，如果比较不成功一直在循环，最差的情况某个线程一直取到的值和预期值都不一样，就会无限循环导致饥饿，<strong>使用 CAS 线程数不要超过 CPU 的核心数</strong>，采用分段 CAS 和自动迁移机制</p></li><li><p>只能保证一个共享变量的原子操作</p><ul><li><p>对于一个共享变量执行操作时，可以通过循环 CAS 的方式来保证原子操作</p></li><li><p>对于多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候<strong>只能用锁来保证原子性</strong></p></li></ul></li><li><p>引出来 ABA 问题</p></li></ul><hr><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>CAS 与 synchronized 总结：</p><ul><li><p>synchronized 是从悲观的角度出发：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程），因此 synchronized 也称之为悲观锁，ReentrantLock 也是一种悲观锁，性能较差</p></li><li><p>CAS 是从乐观的角度出发：总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据。<strong>如果别人修改过，则获取现在最新的值，如果别人没修改过，直接修改共享数据的值</strong>，CAS 这种机制也称之为乐观锁，综合性能较好</p></li></ul><hr><h3 id="Atomic"><a href="#Atomic" class="headerlink" title="Atomic"></a>Atomic</h3><h4 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h4><p>常见原子类：AtomicInteger、AtomicBoolean、AtomicLong</p><p>构造方法：</p><ul><li><p><code>public AtomicInteger()</code>：初始化一个默认值为 0 的原子型 Integer</p></li><li><p><code>public AtomicInteger(int initialValue)</code>：初始化一个指定值的原子型 Integer</p></li></ul><p>常用API：</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>public final int get()</td><td>获取 AtomicInteger 的值</td></tr><tr><td>public final int getAndIncrement()</td><td>以原子方式将当前值加 1，返回的是自增前的值</td></tr><tr><td>public final int incrementAndGet()</td><td>以原子方式将当前值加 1，返回的是自增后的值</td></tr><tr><td>public final int getAndSet(int value)</td><td>以原子方式设置为 newValue 的值，返回旧值</td></tr><tr><td>public final int addAndGet(int data)</td><td>以原子方式将输入的数值与实例中的值相加并返回 实例：AtomicInteger 里的 value</td></tr></tbody></table><hr><h4 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h4><p><strong>AtomicInteger 原理</strong>：自旋锁 + CAS 算法</p><p>CAS 算法：有 3 个操作数（内存值 V， 旧的预期值 A，要修改的值 B）</p><ul><li><p>当旧的预期值 A &#x3D;&#x3D; 内存值 V 此时可以修改，将 V 改为 B</p></li><li><p>当旧的预期值 A !&#x3D; 内存值 V 此时不能修改，并重新获取现在的最新值，重新获取的动作就是自旋</p></li></ul><p>分析 getAndSet 方法：</p><ul><li><p>AtomicInteger：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public final <span class="hljs-built_in">int</span> get<span class="hljs-constructor">AndSet(<span class="hljs-params">int</span> <span class="hljs-params">newValue</span>)</span> &#123;  <br><span class="hljs-comment">/**  </span><br><span class="hljs-comment">* this: 当前对象  </span><br><span class="hljs-comment">* valueOffset:内存偏移量，内存地址  </span><br><span class="hljs-comment">*/</span>  <br>return unsafe.get<span class="hljs-constructor">AndSetInt(<span class="hljs-params">this</span>, <span class="hljs-params">valueOffset</span>, <span class="hljs-params">newValue</span>)</span>;  <br>&#125;<br>valueOffset：偏移量表示该变量值相对于当前对象地址的偏移，Unsafe 就是根据内存偏移地址获取数据<br><br>valueOffset = unsafe.objectFieldOffset  <br>(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AtomicInteger</span>.</span></span><span class="hljs-keyword">class</span>.get<span class="hljs-constructor">DeclaredField(<span class="hljs-string">&quot;value&quot;</span>)</span>);  <br><span class="hljs-comment">//调用本地方法   --&gt;  </span><br>public native long <span class="hljs-keyword">object</span><span class="hljs-constructor">FieldOffset(Field <span class="hljs-params">var1</span>)</span>;<br></code></pre></td></tr></table></figure></li><li><p>unsafe 类：</p></li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// val1: AtomicInteger对象本身，var2: 该对象值得引用地址，var4: 需要变动的数  </span><br>public final <span class="hljs-built_in">int</span> get<span class="hljs-constructor">AndSetInt(Object <span class="hljs-params">var1</span>, <span class="hljs-params">long</span> <span class="hljs-params">var2</span>, <span class="hljs-params">int</span> <span class="hljs-params">var4</span>)</span> &#123;  <br><span class="hljs-built_in">int</span> var5;  <br><span class="hljs-keyword">do</span> &#123;  <br><span class="hljs-comment">// var5: 用 var1 和 var2 找到的内存中的真实值  </span><br>var5 = this.get<span class="hljs-constructor">IntVolatile(<span class="hljs-params">var1</span>, <span class="hljs-params">var2</span>)</span>;  <br>&#125; <span class="hljs-keyword">while</span>(!this.compare<span class="hljs-constructor">AndSwapInt(<span class="hljs-params">var1</span>, <span class="hljs-params">var2</span>, <span class="hljs-params">var5</span>, <span class="hljs-params">var4</span>)</span>);  <br>return var5;  <br>&#125;<br><br><br>var5：从主内存中拷贝到工作内存中的值（每次都要从主内存拿到最新的值到本地内存），然后执行 `compare<span class="hljs-constructor">AndSwapInt()</span>` 再和主内存的值进行比较，假设方法返回 <span class="hljs-literal">false</span>，那么就一直执行 <span class="hljs-keyword">while</span> 方法，直到期望的值和真实值一样，修改数据<br></code></pre></td></tr></table></figure><ul><li><p>变量 value 用 volatile 修饰，保证了多线程之间的内存可见性，避免线程从工作缓存中获取失效的变量</p><p>  private volatile int value</p><p>  <strong>CAS 必须借助 volatile 才能读取到共享变量的最新值来实现比较并交换的效果</strong></p></li></ul><p>分析 getAndUpdate 方法：</p><ul><li><p>getAndUpdate：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndUpdate</span><span class="hljs-params">(IntUnaryOperator updateFunction)</span> &#123;  <br><span class="hljs-type">int</span> prev, next;  <br><span class="hljs-keyword">do</span> &#123;  <br>prev = get();<span class="hljs-comment">//当前值，cas的期望值  </span><br>next = updateFunction.applyAsInt(prev);<span class="hljs-comment">//期望值更新到该值  </span><br>&#125; <span class="hljs-keyword">while</span> (!compareAndSet(prev, next));<span class="hljs-comment">//自旋  </span><br><span class="hljs-keyword">return</span> prev;  <br>&#125;<br>    <br>函数式接口：可以自定义操作逻辑<br><br><span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();  <br>a.getAndUpdate(i -&gt; i + <span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure></li><li><p>compareAndSet：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSet</span><span class="hljs-params">(<span class="hljs-type">int</span> expect, <span class="hljs-type">int</span> update)</span> &#123;  <br><span class="hljs-comment">/**  </span><br><span class="hljs-comment">* this: 当前对象  </span><br><span class="hljs-comment">* valueOffset:内存偏移量，内存地址  </span><br><span class="hljs-comment">* expect:期望的值  </span><br><span class="hljs-comment">* update: 更新的值  </span><br><span class="hljs-comment">*/</span>  <br><span class="hljs-keyword">return</span> unsafe.compareAndSwapInt(<span class="hljs-built_in">this</span>, valueOffset, expect, update);  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h4 id="原子引用"><a href="#原子引用" class="headerlink" title="原子引用"></a>原子引用</h4><p>原子引用：对 Object 进行原子操作，提供一种读和写都是原子性的对象引用变量</p><p>原子引用类：AtomicReference、AtomicStampedReference、AtomicMarkableReference</p><p>AtomicReference 类：</p><ul><li><p>构造方法：<code>AtomicReference&lt;T&gt; atomicReference = new AtomicReference&lt;T&gt;()</code></p></li><li><p>常用 API：</p><ul><li><p><code>public final boolean compareAndSet(V expectedValue, V newValue)</code>：CAS 操作</p></li><li><p><code>public final void set(V newValue)</code>：将值设置为 newValue</p></li><li><p><code>public final V get()</code>：返回当前值</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicReferenceDemo</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-number">33</span>, <span class="hljs-string">&quot;z3&quot;</span>);  <br>          <br>        <span class="hljs-comment">// 创建原子引用包装类  </span><br>        AtomicReference&lt;Student&gt; atomicReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>&lt;&gt;();  <br>        <span class="hljs-comment">// 设置主内存共享变量为s1  </span><br>        atomicReference.set(s1);  <br>  <br>        <span class="hljs-comment">// 比较并交换，如果现在主物理内存的值为 z3，那么交换成 l4  </span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;  <br>            <span class="hljs-type">Student</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-number">44</span>, <span class="hljs-string">&quot;l4&quot;</span>);  <br>            <span class="hljs-keyword">if</span> (atomicReference.compareAndSet(s1, s2)) &#123;  <br>                <span class="hljs-keyword">break</span>;  <br>            &#125;  <br>        &#125;  <br>        System.out.println(atomicReference.get());  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;  <br>    <span class="hljs-keyword">private</span> String name;  <br>    <span class="hljs-comment">//。。。。  </span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="原子数组"><a href="#原子数组" class="headerlink" title="原子数组"></a>原子数组</h4><p>原子数组类：AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray</p><p>AtomicIntegerArray 类方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">/**  </span><br><span class="hljs-comment">*   ithe index  </span><br><span class="hljs-comment">* expect the expected value  </span><br><span class="hljs-comment">* update the new value  </span><br><span class="hljs-comment">*/</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSet</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> expect, <span class="hljs-type">int</span> update)</span> &#123;  <br>    <span class="hljs-keyword">return</span> compareAndSetRaw(checkedByteOffset(i), expect, update);  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="原子更新器"><a href="#原子更新器" class="headerlink" title="原子更新器"></a>原子更新器</h4><p>原子更新器类：AtomicReferenceFieldUpdater、AtomicIntegerFieldUpdater、AtomicLongFieldUpdater</p><p>利用字段更新器，可以针对对象的某个域（Field）进行原子操作，只能配合 volatile 修饰的字段使用，否则会出现异常 <code>IllegalArgumentException: Must be volatile type</code></p><p>常用 API：</p><ul><li><p><code>static &lt;U&gt; AtomicIntegerFieldUpdater&lt;U&gt; newUpdater(Class&lt;U&gt; c, String fieldName)</code>：构造方法</p></li><li><p><code>abstract boolean compareAndSet(T obj, int expect, int update)</code>：CAS</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UpdateDemo</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> field;  <br>      <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">AtomicIntegerFieldUpdater</span> <span class="hljs-variable">fieldUpdater</span> <span class="hljs-operator">=</span> AtomicIntegerFieldUpdater  <br>            .newUpdater(UpdateDemo.class, <span class="hljs-string">&quot;field&quot;</span>);  <br>        <span class="hljs-type">UpdateDemo</span> <span class="hljs-variable">updateDemo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UpdateDemo</span>();  <br>        fieldUpdater.compareAndSet(updateDemo, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>);  <br>        System.out.println(updateDemo.field);<span class="hljs-comment">//10  </span><br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="原子累加器"><a href="#原子累加器" class="headerlink" title="原子累加器"></a>原子累加器</h4><p>原子累加器类：LongAdder、DoubleAdder、LongAccumulator、DoubleAccumulator</p><p>LongAdder 和 LongAccumulator 区别：</p><p>相同点：</p><ul><li><p>LongAddr 与 LongAccumulator 类都是使用非阻塞算法 CAS 实现的</p></li><li><p>LongAddr 类是 LongAccumulator 类的一个特例，只是 LongAccumulator 提供了更强大的功能，可以自定义累加规则，当accumulatorFunction 为 null 时就等价于 LongAddr</p></li></ul><p>不同点：</p><ul><li><p>调用 casBase 时，LongAccumulator 使用 function.applyAsLong(b &#x3D; base, x) 来计算，LongAddr 使用 casBase(b &#x3D; base, b + x)</p></li><li><p>LongAccumulator 类功能更加强大，构造方法参数中</p><ul><li><p>accumulatorFunction 是一个双目运算器接口，可以指定累加规则，比如累加或者相乘，其根据输入的两个参数返回一个计算值，LongAdder 内置累加规则</p></li><li><p>identity 则是 LongAccumulator 累加器的初始值，LongAccumulator 可以为累加器提供非0的初始值，而 LongAdder 只能提供默认的 0</p></li></ul></li></ul><hr><h3 id="Adder"><a href="#Adder" class="headerlink" title="Adder"></a>Adder</h3><h4 id="优化机制"><a href="#优化机制" class="headerlink" title="优化机制"></a>优化机制</h4><p>LongAdder 是 Java8 提供的类，跟 AtomicLong 有相同的效果，但对 CAS 机制进行了优化，尝试使用分段 CAS 以及自动分段迁移的方式来大幅度提升多线程高并发执行 CAS 操作的性能</p><p>CAS 底层实现是在一个循环中不断地尝试修改目标值，直到修改成功。如果竞争不激烈修改成功率很高，否则失败率很高，失败后这些重复的原子性操作会耗费性能（导致大量线程<strong>空循环，自旋转</strong>）</p><p>优化核心思想：数据分离，将 AtomicLong 的<strong>单点的更新压力分担到各个节点，空间换时间</strong>，在低并发的时候直接更新，可以保障和 AtomicLong 的性能基本一致，而在高并发的时候通过分散减少竞争，提高了性能</p><p><strong>分段 CAS 机制</strong>：</p><ul><li><p>在发生竞争时，创建 Cell 数组用于将不同线程的操作离散（通过 hash 等算法映射）到不同的节点上</p></li><li><p>设置多个累加单元（会根据需要扩容，最大为 CPU 核数），Therad-0 累加 Cell[0]，而 Thread-1 累加 Cell[1] 等，最后将结果汇总</p></li><li><p>在累加时操作的不同的 Cell 变量，因此减少了 CAS 重试失败，从而提高性能</p></li></ul><p><strong>自动分段迁移机制</strong>：某个 Cell 的 value 执行 CAS 失败，就会自动寻找另一个 Cell 分段内的 value 值进行 CAS 操作</p><hr><h4 id="伪共享-1"><a href="#伪共享-1" class="headerlink" title="伪共享"></a>伪共享</h4><p>Cell 为累加单元：数组访问索引是通过 Thread 里的 threadLocalRandomProbe 域取模实现的，这个域是 ThreadLocalRandom 更新的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Striped64.Cell  </span><br><span class="hljs-meta">@sun</span>.misc.Contended <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cell</span> &#123;  <br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> value;  <br>    Cell(<span class="hljs-type">long</span> x) &#123; value = x; &#125;  <br>    <span class="hljs-comment">// 用 cas 方式进行累加, prev 表示旧值, next 表示新值  </span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">cas</span><span class="hljs-params">(<span class="hljs-type">long</span> prev, <span class="hljs-type">long</span> next)</span> &#123;  <br>    <span class="hljs-keyword">return</span> UNSAFE.compareAndSwapLong(<span class="hljs-built_in">this</span>, valueOffset, prev, next);  <br>    &#125;  <br>    <span class="hljs-comment">// 省略不重要代码  </span><br>&#125;<br></code></pre></td></tr></table></figure><p>Cell 是数组形式，<strong>在内存中是连续存储的</strong>，64 位系统中，一个 Cell 为 24 字节（16 字节的对象头和 8 字节的 value），每一个 cache line 为 64 字节，因此缓存行可以存下 2 个的 Cell 对象，当 Core-0 要修改 Cell[0]、Core-1 要修改 Cell[1]，无论谁修改成功都会导致当前缓存行失效，从而导致对方的数据失效，需要重新去主存获取，影响效率</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041706137.png"></p><p>@sun.misc.Contended：防止缓存行伪共享，在使用此注解的对象或字段的前后各增加 128 字节大小的 padding，使用 2 倍于大多数硬件缓存行让 CPU 将对象预读至缓存时<strong>占用不同的缓存行</strong>，这样就不会造成对方缓存行的失效</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041706578.png"></p><hr><h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h4><p>Striped64 类成员属性：</p><p>&#x2F;&#x2F; 表示当前计算机CPU数量<br>static final int NCPU &#x3D; Runtime.getRuntime().availableProcessors()<br>&#x2F;&#x2F; 累加单元数组, 懒惰初始化<br>transient volatile Cell[] cells;<br>&#x2F;&#x2F; 基础值, 如果没有竞争, 则用 cas 累加这个域，当 cells 扩容时，也会将数据写到 base 中<br>transient volatile long base;<br>&#x2F;&#x2F; 在 cells 初始化或扩容时只能有一个线程执行, 通过 CAS 更新 cellsBusy 置为 1 来实现一个锁<br>transient volatile int cellsBusy;</p><p>工作流程：</p><ul><li><p>cells 占用内存是相对比较大的，是惰性加载的，在无竞争或者其他线程正在初始化 cells 数组的情况下，直接更新 base 域</p></li><li><p>在第一次发生竞争时（casBase 失败）会创建一个大小为 2 的 cells 数组，将当前累加的值包装为 Cell 对象，放入映射的槽位上</p></li><li><p>分段累加的过程中，如果当前线程对应的 cells 槽位为空，就会新建 Cell 填充，如果出现竞争，就会重新计算线程对应的槽位，继续自旋尝试修改</p></li><li><p>分段迁移后还出现竞争就会扩容 cells 数组长度为原来的两倍，然后 rehash，<strong>数组长度总是 2 的 n 次幂</strong>，默认最大为 CPU 核数，但是可以超过，如果核数是 6 核，数组最长是 8</p></li></ul><p>方法分析：</p><p><strong>LongAdder#add：累加方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">long</span> x)</span> &#123;  <br>    <span class="hljs-comment">// as 为累加单元数组的引用，b 为基础值，v 表示期望值  </span><br>    <span class="hljs-comment">// m 表示 cells 数组的长度 - 1，a 表示当前线程命中的 cell 单元格  </span><br>    Cell[] as; <span class="hljs-type">long</span> b, v; <span class="hljs-type">int</span> m; Cell a;  <br>      <br>    <span class="hljs-comment">// cells 不为空说明 cells 已经被初始化，线程发生了竞争，去更新对应的 cell 槽位  </span><br>    <span class="hljs-comment">// 进入 || 后的逻辑去更新 base 域，更新失败表示发生竞争进入条件  </span><br>    <span class="hljs-keyword">if</span> ((as = cells) != <span class="hljs-literal">null</span> || !casBase(b = base, b + x)) &#123;  <br>        <span class="hljs-comment">// uncontended 为 true 表示 cell 没有竞争  </span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">uncontended</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;  <br>          <br>        <span class="hljs-comment">// 条件一: true 说明 cells 未初始化，多线程写 base 发生竞争需要进行初始化 cells 数组  </span><br>        <span class="hljs-comment">//  fasle 说明 cells 已经初始化，进行下一个条件寻找自己的 cell 去累加  </span><br>        <span class="hljs-comment">// 条件二: getProbe() 获取 hash 值，&amp; m 的逻辑和 HashMap 的逻辑相同，保证散列的均匀性  </span><br>        <span class="hljs-comment">//   true 说明当前线程对应下标的 cell 为空，需要创建 cell  </span><br>        <span class="hljs-comment">//        false 说明当前线程对应的 cell 不为空，进行下一个条件【将 x 值累加到对应的 cell 中】  </span><br>        <span class="hljs-comment">// 条件三: 有取反符号，false 说明 cas 成功，直接返回，true 说明失败，当前线程对应的 cell 有竞争  </span><br>        <span class="hljs-keyword">if</span> (as == <span class="hljs-literal">null</span> || (m = as.length - <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span> ||  <br>            (a = as[getProbe() &amp; m]) == <span class="hljs-literal">null</span> ||  <br>            !(uncontended = a.cas(v = a.value, v + x)))  <br>            longAccumulate(x, <span class="hljs-literal">null</span>, uncontended);  <br>        <span class="hljs-comment">// 【uncontended 在对应的 cell 上累加失败的时候才为 false，其余情况均为 true】  </span><br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Striped64#longAccumulate：cell 数组创建</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// x  null false | true  </span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">longAccumulate</span><span class="hljs-params">(<span class="hljs-type">long</span> x, LongBinaryOperator fn, <span class="hljs-type">boolean</span> wasUncontended)</span> &#123;  <br><span class="hljs-type">int</span> h;  <br><span class="hljs-comment">// 当前线程还没有对应的 cell, 需要随机生成一个 hash 值用来将当前线程绑定到 cell  </span><br><span class="hljs-keyword">if</span> ((h = getProbe()) == <span class="hljs-number">0</span>) &#123;  <br><span class="hljs-comment">// 初始化 probe，获取 hash 值  </span><br>ThreadLocalRandom.current();   <br>h = getProbe();  <br><span class="hljs-comment">// 默认情况下 当前线程肯定是写入到了 cells[0] 位置，不把它当做一次真正的竞争  </span><br>wasUncontended = <span class="hljs-literal">true</span>;  <br>&#125;  <br><span class="hljs-comment">// 表示【扩容意向】，false 一定不会扩容，true 可能会扩容  </span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">collide</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;   <br><span class="hljs-comment">//自旋  </span><br><span class="hljs-keyword">for</span> (;;) &#123;  <br><span class="hljs-comment">// as 表示cells引用，a 表示当前线程命中的 cell，n 表示 cells 数组长度，v 表示 期望值  </span><br>Cell[] as; Cell a; <span class="hljs-type">int</span> n; <span class="hljs-type">long</span> v;  <br><span class="hljs-comment">// 【CASE1】: 表示 cells 已经初始化了，当前线程应该将数据写入到对应的 cell 中  </span><br><span class="hljs-keyword">if</span> ((as = cells) != <span class="hljs-literal">null</span> &amp;&amp; (n = as.length) &gt; <span class="hljs-number">0</span>) &#123;  <br><span class="hljs-comment">// CASE1.1: true 表示当前线程对应的索引下标的 Cell 为 null，需要创建 new Cell  </span><br><span class="hljs-keyword">if</span> ((a = as[(n - <span class="hljs-number">1</span>) &amp; h]) == <span class="hljs-literal">null</span>) &#123;  <br><span class="hljs-comment">// 判断 cellsBusy 是否被锁  </span><br><span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span>) &#123;     <br><span class="hljs-comment">// 创建 cell, 初始累加值为 x  </span><br><span class="hljs-type">Cell</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cell</span>(x);    <br><span class="hljs-comment">// 加锁  </span><br><span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp; casCellsBusy()) &#123;  <br><span class="hljs-comment">// 创建成功标记，进入【创建 cell 逻辑】  </span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">created</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;  <br><span class="hljs-keyword">try</span> &#123;  <br>Cell[] rs; <span class="hljs-type">int</span> m, j;  <br><span class="hljs-comment">// 把当前 cells 数组赋值给 rs，并且不为 null  </span><br><span class="hljs-keyword">if</span> ((rs = cells) != <span class="hljs-literal">null</span> &amp;&amp;  <br>(m = rs.length) &gt; <span class="hljs-number">0</span> &amp;&amp;  <br><span class="hljs-comment">// 再次判断防止其它线程初始化过该位置，当前线程再次初始化该位置会造成数据丢失  </span><br><span class="hljs-comment">// 因为这里是线程安全的判断，进行的逻辑不会被其他线程影响  </span><br>rs[j = (m - <span class="hljs-number">1</span>) &amp; h] == <span class="hljs-literal">null</span>) &#123;  <br><span class="hljs-comment">// 把新创建的 cell 填充至当前位置  </span><br>rs[j] = r;  <br>created = <span class="hljs-literal">true</span>;<span class="hljs-comment">// 表示创建完成  </span><br>&#125;  <br>&#125; <span class="hljs-keyword">finally</span> &#123;  <br>cellsBusy = <span class="hljs-number">0</span>;<span class="hljs-comment">// 解锁  </span><br>&#125;  <br><span class="hljs-keyword">if</span> (created)<span class="hljs-comment">// true 表示创建完成，可以推出循环了  </span><br><span class="hljs-keyword">break</span>;  <br><span class="hljs-keyword">continue</span>;  <br>&#125;  <br>&#125;  <br>collide = <span class="hljs-literal">false</span>;  <br>&#125;  <br><span class="hljs-comment">// CASE1.2: 条件成立说明线程对应的 cell 有竞争, 改变线程对应的 cell 来重试 cas  </span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!wasUncontended)  <br>wasUncontended = <span class="hljs-literal">true</span>;  <br><span class="hljs-comment">// CASE 1.3: 当前线程 rehash 过，如果新命中的 cell 不为空，就尝试累加，false 说明新命中也有竞争  </span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a.cas(v = a.value, ((fn == <span class="hljs-literal">null</span>) ? v + x : fn.applyAsLong(v, x))))  <br><span class="hljs-keyword">break</span>;  <br><span class="hljs-comment">// CASE 1.4: cells 长度已经超过了最大长度 CPU 内核的数量或者已经扩容  </span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n &gt;= NCPU || cells != as)  <br>collide = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 扩容意向改为false，【表示不能扩容了】  </span><br><span class="hljs-comment">// CASE 1.5: 更改扩容意向，如果 n &gt;= NCPU，这里就永远不会执行到，case1.4 永远先于 1.5 执行  </span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!collide)  <br>collide = <span class="hljs-literal">true</span>;  <br><span class="hljs-comment">// CASE 1.6: 【扩容逻辑】，进行加锁  </span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp; casCellsBusy()) &#123;  <br><span class="hljs-keyword">try</span> &#123;  <br><span class="hljs-comment">// 线程安全的检查，防止期间被其他线程扩容了  </span><br><span class="hljs-keyword">if</span> (cells == as) &#123;       <br><span class="hljs-comment">// 扩容为以前的 2 倍  </span><br>Cell[] rs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cell</span>[n &lt;&lt; <span class="hljs-number">1</span>];  <br><span class="hljs-comment">// 遍历移动值  </span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)  <br>rs[i] = as[i];  <br><span class="hljs-comment">// 把扩容后的引用给 cells  </span><br>cells = rs;  <br>&#125;  <br>&#125; <span class="hljs-keyword">finally</span> &#123;  <br>cellsBusy = <span class="hljs-number">0</span>;<span class="hljs-comment">// 解锁  </span><br>&#125;  <br>collide = <span class="hljs-literal">false</span>;<span class="hljs-comment">// 扩容意向改为 false，表示不扩容了  </span><br><span class="hljs-keyword">continue</span>;  <br>&#125;  <br><span class="hljs-comment">// 重置当前线程 Hash 值，这就是【分段迁移机制】  </span><br>h = advanceProbe(h);  <br>&#125;  <br>  <br><span class="hljs-comment">// 【CASE2】: 运行到这说明 cells 还未初始化，as 为null  </span><br><span class="hljs-comment">// 判断是否没有加锁，没有加锁就用 CAS 加锁  </span><br><span class="hljs-comment">// 条件二判断是否其它线程在当前线程给 as 赋值之后修改了 cells，这里不是线程安全的判断  </span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;  <br><span class="hljs-comment">// 初始化标志，开始 【初始化 cells 数组】  </span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">init</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;  <br><span class="hljs-keyword">try</span> &#123;   <br><span class="hljs-comment">// 再次判断 cells == as 防止其它线程已经提前初始化了，当前线程再次初始化导致丢失数据  </span><br><span class="hljs-comment">// 因为这里是【线程安全的，重新检查，经典 DCL】  </span><br><span class="hljs-keyword">if</span> (cells == as) &#123;  <br>Cell[] rs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cell</span>[<span class="hljs-number">2</span>];<span class="hljs-comment">// 初始化数组大小为2  </span><br>rs[h &amp; <span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cell</span>(x);<span class="hljs-comment">// 填充线程对应的cell  </span><br>cells = rs;  <br>init = <span class="hljs-literal">true</span>;<span class="hljs-comment">// 初始化成功，标记置为 true  </span><br>&#125;  <br>&#125; <span class="hljs-keyword">finally</span> &#123;  <br>cellsBusy = <span class="hljs-number">0</span>;<span class="hljs-comment">// 解锁啊  </span><br>&#125;  <br><span class="hljs-keyword">if</span> (init)  <br><span class="hljs-keyword">break</span>;<span class="hljs-comment">// 初始化成功直接跳出自旋  </span><br>&#125;  <br><span class="hljs-comment">// 【CASE3】: 运行到这说明其他线程在初始化 cells，当前线程将值累加到 base，累加成功直接结束自旋  </span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (casBase(v = base, ((fn == <span class="hljs-literal">null</span>) ? v + x :  <br>fn.applyAsLong(v, x))))  <br><span class="hljs-keyword">break</span>;   <br>&#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>sum：获取最终结果通过 sum 整合，保证最终一致性，不保证强一致性</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">sum</span><span class="hljs-params">()</span> &#123;  <br>Cell[] as = cells; Cell a;  <br><span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> base;  <br><span class="hljs-keyword">if</span> (as != <span class="hljs-literal">null</span>) &#123;  <br><span class="hljs-comment">// 遍历 累加  </span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; as.length; ++i) &#123;  <br><span class="hljs-keyword">if</span> ((a = as[i]) != <span class="hljs-literal">null</span>)  <br>sum += a.value;  <br>&#125;  <br>&#125;  <br><span class="hljs-keyword">return</span> sum;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="ABA"><a href="#ABA" class="headerlink" title="ABA"></a>ABA</h3><p>ABA 问题：当进行获取主内存值时，该内存值在写入主内存时已经被修改了 N 次，但是最终又改成原来的值</p><p>其他线程先把 A 改成 B 又改回 A，主线程<strong>仅能判断出共享变量的值与最初值 A 是否相同</strong>，不能感知到这种从 A 改为 B 又 改回 A 的情况，这时 CAS 虽然成功，但是过程存在问题</p><ul><li><p>构造方法：</p><ul><li><code>public AtomicStampedReference(V initialRef, int initialStamp)</code>：初始值和初始版本号</li></ul></li><li><p>常用API：</p><ul><li><p><code>public boolean compareAndSet(V expectedReference, V newReference, int expectedStamp, int newStamp)</code>：<strong>期望引用和期望版本号都一致</strong>才进行 CAS 修改数据</p></li><li><p><code>public void set(V newReference, int newStamp)</code>：设置值和版本号</p></li><li><p><code>public V getReference()</code>：返回引用的值</p></li><li><p><code>public int getStamp()</code>：返回当前版本号</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    AtomicStampedReference&lt;Integer&gt; atomicReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicStampedReference</span>&lt;&gt;(<span class="hljs-number">100</span>,<span class="hljs-number">1</span>);  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">startStamp</span> <span class="hljs-operator">=</span> atomicReference.getStamp();  <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt;&#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> atomicReference.getStamp();  <br>        atomicReference.compareAndSet(<span class="hljs-number">100</span>, <span class="hljs-number">101</span>, stamp, stamp + <span class="hljs-number">1</span>);  <br>        stamp = atomicReference.getStamp();  <br>        atomicReference.compareAndSet(<span class="hljs-number">101</span>, <span class="hljs-number">100</span>, stamp, stamp + <span class="hljs-number">1</span>);  <br>    &#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();  <br>  <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt;&#123;  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            Thread.sleep(<span class="hljs-number">1000</span>);  <br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>            e.printStackTrace();  <br>        &#125;  <br>        <span class="hljs-keyword">if</span> (!atomicReference.compareAndSet(<span class="hljs-number">100</span>, <span class="hljs-number">200</span>, startStamp, startStamp + <span class="hljs-number">1</span>)) &#123;  <br>            System.out.println(atomicReference.getReference());<span class="hljs-comment">//100  </span><br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;线程修改失败&quot;</span>);  <br>        &#125;  <br>    &#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();  <br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h3 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h3><p>Unsafe 是 CAS 的核心类，由于 Java 无法直接访问底层系统，需要通过本地（Native）方法来访问</p><p>Unsafe 类存在 sun.misc 包，其中所有方法都是 native 修饰的，都是直接调用<strong>操作系统底层资源</strong>执行相应的任务，基于该类可以直接操作特定的内存数据，其内部方法操作类似 C 的指针</p><p>模拟实现原子整数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    <span class="hljs-type">MyAtomicInteger</span> <span class="hljs-variable">atomicInteger</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyAtomicInteger</span>(<span class="hljs-number">10</span>);  <br>    <span class="hljs-keyword">if</span> (atomicInteger.compareAndSwap(<span class="hljs-number">20</span>)) &#123;  <br>        System.out.println(atomicInteger.getValue());  <br>    &#125;  <br>&#125;  <br>​  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAtomicInteger</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Unsafe UNSAFE;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> VALUE_OFFSET;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> value;  <br>​  <br>    <span class="hljs-keyword">static</span> &#123;  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            <span class="hljs-comment">//Unsafe unsafe = Unsafe.getUnsafe()这样会报错，需要反射获取  </span><br>            <span class="hljs-type">Field</span> <span class="hljs-variable">theUnsafe</span> <span class="hljs-operator">=</span> Unsafe.class.getDeclaredField(<span class="hljs-string">&quot;theUnsafe&quot;</span>);  <br>            theUnsafe.setAccessible(<span class="hljs-literal">true</span>);  <br>            UNSAFE = (Unsafe) theUnsafe.get(<span class="hljs-literal">null</span>);  <br>            <span class="hljs-comment">// 获取 value 属性的内存地址，value 属性指向该地址，直接设置该地址的值可以修改 value 的值  </span><br>            VALUE_OFFSET = UNSAFE.objectFieldOffset(  <br>                           MyAtomicInteger.class.getDeclaredField(<span class="hljs-string">&quot;value&quot;</span>));  <br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;  <br>            e.printStackTrace();  <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>();  <br>        &#125;  <br>    &#125;  <br>​  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyAtomicInteger</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.value = value;  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> value;  <br>    &#125;  <br>​  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSwap</span><span class="hljs-params">(<span class="hljs-type">int</span> update)</span> &#123;  <br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;  <br>            <span class="hljs-type">int</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.value;  <br>            <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> update;  <br>            <span class="hljs-comment">//  当前对象  内存偏移量    期望值 更新值  </span><br>            <span class="hljs-keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="hljs-built_in">this</span>, VALUE_OFFSET, prev, update)) &#123;  <br>                System.out.println(<span class="hljs-string">&quot;CAS成功&quot;</span>);  <br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestFinal</span> &#123;  <br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;  <br>&#125;<br><br>字节码：<br><br><span class="hljs-number">0</span>: aload_0  <br><span class="hljs-number">1</span>: invokespecial #<span class="hljs-number">1</span> <span class="hljs-comment">// Method java/lang/Object.&quot;&lt; init&gt;&quot;:()V  </span><br><span class="hljs-number">4</span>: aload_0  <br><span class="hljs-number">5</span>: bipush <span class="hljs-number">20</span><span class="hljs-comment">// 将值直接放入栈中  </span><br><span class="hljs-number">7</span>: putfield #<span class="hljs-number">2</span> <span class="hljs-comment">// Field a:I  </span><br>&lt;-- 写屏障  <br><span class="hljs-number">10</span>: <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><p>final 变量的赋值通过 putfield 指令来完成，在这条指令之后也会加入写屏障，保证在其它线程读到它的值时不会出现为 0 的情况</p><p>其他线程访问 final 修饰的变量</p><ul><li><p><strong>复制一份放入栈中</strong>直接访问，效率高</p></li><li><p>大于 short 最大值会将其复制到类的常量池，访问时从常量池获取</p></li></ul><hr><h4 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h4><p>不可变：如果一个对象不能够修改其内部状态（属性），那么就是不可变对象</p><p>不可变对象线程安全的，不存在并发修改和可见性问题，是另一种避免竞争的方式</p><p>String 类也是不可变的，该类和类中所有属性都是 final 的</p><ul><li><p>类用 final 修饰保证了该类中的方法不能被覆盖，防止子类无意间破坏不可变性</p></li><li><p>无写入方法（set）确保外部不能对内部属性进行修改</p></li><li><p>属性用 final 修饰保证了该属性是只读的，不能修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span>  <br><span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;  <br><span class="hljs-comment">/** The value is used for character storage. */</span>  <br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span> value[];  <br><span class="hljs-comment">//....  </span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>更改 String 类数据时，会构造新字符串对象，生成新的 char[] value，通过<strong>创建副本对象来避免共享的方式称之为保护性拷贝</strong></p></li></ul><hr><h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p>无状态：成员变量保存的数据也可以称为状态信息，无状态就是没有成员变量</p><p>Servlet 为了保证其线程安全，一般不为 Servlet 设置成员变量，这种没有任何成员变量的类是线程安全的</p><hr><h3 id="Local"><a href="#Local" class="headerlink" title="Local"></a>Local</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>ThreadLocal 类用来提供线程内部的局部变量，这种变量在多线程环境下访问（通过 get 和 set 方法访问）时能保证各个线程的变量相对独立于其他线程内的变量，分配在堆内的 <strong>TLAB</strong> 中</p><p>ThreadLocal 实例通常来说都是 <code>private static</code> 类型的，属于一个线程的本地变量，用于关联线程和线程上下文。每个线程都会在 ThreadLocal 中保存一份该线程独有的数据，所以是线程安全的</p><p>ThreadLocal 作用：</p><ul><li><p>线程并发：应用在多线程并发的场景下</p></li><li><p>传递数据：通过 ThreadLocal 实现在同一线程不同函数或组件中传递公共变量，减少传递复杂度</p></li><li><p>线程隔离：每个线程的变量都是独立的，不会互相影响</p></li></ul><p>对比 synchronized：</p><table><thead><tr><th></th><th>synchronized</th><th>ThreadLocal</th></tr></thead><tbody><tr><td>原理</td><td>同步机制采用<strong>以时间换空间</strong>的方式，只提供了一份变量，让不同的线程排队访问</td><td>ThreadLocal 采用<strong>以空间换时间</strong>的方式，为每个线程都提供了一份变量的副本，从而实现同时访问而相不干扰</td></tr><tr><td>侧重点</td><td>多个线程之间访问资源的同步</td><td>多线程中让每个线程之间的数据相互隔离</td></tr></tbody></table><hr><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><h5 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h5><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>ThreadLocal&lt;&gt;()</td><td>创建 ThreadLocal 对象</td></tr><tr><td>protected T initialValue()</td><td>返回当前线程局部变量的初始值</td></tr><tr><td>public void set( T value)</td><td>设置当前线程绑定的局部变量</td></tr><tr><td>public T get()</td><td>获取当前线程绑定的局部变量</td></tr><tr><td>public void remove()</td><td>移除当前线程绑定的局部变量</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyDemo</span> &#123;  <br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;String&gt; tl = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();  <br>  <br>    <span class="hljs-keyword">private</span> String content;  <br>  <br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getContent</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-comment">// 获取当前线程绑定的变量  </span><br>        <span class="hljs-keyword">return</span> tl.get();  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setContent</span><span class="hljs-params">(String content)</span> &#123;  <br>        <span class="hljs-comment">// 变量content绑定到当前线程  </span><br>        tl.set(content);  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">MyDemo</span> <span class="hljs-variable">demo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyDemo</span>();  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;  <br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;  <br>                <span class="hljs-meta">@Override</span>  <br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>                    <span class="hljs-comment">// 设置数据  </span><br>                    demo.setContent(Thread.currentThread().getName() + <span class="hljs-string">&quot;的数据&quot;</span>);  <br>                    System.out.println(<span class="hljs-string">&quot;-----------------------&quot;</span>);  <br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;---&gt;&quot;</span> + demo.getContent());  <br>                &#125;  <br>            &#125;);  <br>            thread.setName(<span class="hljs-string">&quot;线程&quot;</span> + i);  <br>            thread.start();  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h5><p>ThreadLocal 适用于下面两种场景：</p><ul><li><p>每个线程需要有自己单独的实例</p></li><li><p>实例需要在多个方法中共享，但不希望被多线程共享</p></li></ul><p>ThreadLocal 方案有两个突出的优势：</p><ol><li><p>传递数据：保存每个线程绑定的数据，在需要的地方可以直接获取，避免参数直接传递带来的代码耦合问题</p></li><li><p>线程隔离：各线程之间的数据相互隔离却又具备并发性，避免同步方式带来的性能损失</p></li></ol><p>ThreadLocal 用于数据连接的事务管理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JdbcUtils</span> &#123;  <br>    <span class="hljs-comment">// ThreadLocal对象，将connection绑定在当前线程中  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;Connection&gt; tl = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>();  <br>    <span class="hljs-comment">// c3p0 数据库连接池对象属性  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ComboPooledDataSource</span> <span class="hljs-variable">ds</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ComboPooledDataSource</span>();  <br>    <span class="hljs-comment">// 获取连接  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;  <br>        <span class="hljs-comment">//取出当前线程绑定的connection对象  </span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> tl.get();  <br>        <span class="hljs-keyword">if</span> (conn == <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-comment">//如果没有，则从连接池中取出  </span><br>            conn = ds.getConnection();  <br>            <span class="hljs-comment">//再将connection对象绑定到当前线程中，非常重要的操作  </span><br>            tl.set(conn);  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> conn;  <br>    &#125;  <br><span class="hljs-comment">// ...  </span><br>&#125;<br></code></pre></td></tr></table></figure><p>用 ThreadLocal 使 SimpleDateFormat 从独享变量变成单个线程变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalDateUtil</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;DateFormat&gt; threadLocal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;DateFormat&gt;() &#123;  <br>        <span class="hljs-meta">@Override</span>  <br>        <span class="hljs-keyword">protected</span> DateFormat <span class="hljs-title function_">initialValue</span><span class="hljs-params">()</span> &#123;  <br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);  <br>        &#125;  <br>    &#125;;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Date <span class="hljs-title function_">parse</span><span class="hljs-params">(String dateStr)</span> <span class="hljs-keyword">throws</span> ParseException &#123;  <br>        <span class="hljs-keyword">return</span> threadLocal.get().parse(dateStr);  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">format</span><span class="hljs-params">(Date date)</span> &#123;  <br>        <span class="hljs-keyword">return</span> threadLocal.get().format(date);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><h5 id="底层结构"><a href="#底层结构" class="headerlink" title="底层结构"></a>底层结构</h5><p>JDK8 以前：每个 ThreadLocal 都创建一个 Map，然后用线程作为 Map 的 key，要存储的局部变量作为 Map 的 value，达到各个线程的局部变量隔离的效果。这种结构会造成 Map 结构过大和内存泄露，因为 Thread 停止后无法通过 key 删除对应的数据</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041721661.png"></p><p>JDK8 以后：每个 Thread 维护一个 ThreadLocalMap，这个 Map 的 key 是 ThreadLocal 实例本身，value 是真正要存储的值</p><ul><li><p><strong>每个 Thread 线程内部都有一个 Map (ThreadLocalMap)</strong></p></li><li><p>Map 里面存储 ThreadLocal 对象（key）和线程的私有变量（value）</p></li><li><p>Thread 内部的 Map 是由 ThreadLocal 维护的，由 ThreadLocal 负责向 map 获取和设置线程的变量值</p></li><li><p>对于不同的线程，每次获取副本值时，别的线程并不能获取到当前线程的副本值，形成副本的隔离，互不干扰</p></li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041722540.png"></p><p>JDK8 前后对比：</p><ul><li><p>每个 Map 存储的 Entry 数量会变少，因为之前的存储数量由 Thread 的数量决定，现在由 ThreadLocal 的数量决定，在实际编程当中，往往 ThreadLocal 的数量要少于 Thread 的数量</p></li><li><p>当 Thread 销毁之后，对应的 ThreadLocalMap 也会随之销毁，能减少内存的使用，<strong>防止内存泄露</strong></p></li></ul><hr><h5 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h5><ul><li><p>Thread 类的相关属性：<strong>每一个线程持有一个 ThreadLocalMap 对象</strong>，存放由 ThreadLocal 和数据组成的 Entry 键值对</p><p>  ThreadLocal.ThreadLocalMap threadLocals &#x3D; null</p></li><li><p>计算 ThreadLocal 对象的哈希值：</p><p>  private final int threadLocalHashCode &#x3D; nextHashCode()</p><p>  使用 <code>threadLocalHashCode &amp; (table.length - 1)</code> 计算当前 entry 需要存放的位置</p></li><li><p>每创建一个 ThreadLocal 对象就会使用 nextHashCode 分配一个 hash 值给这个对象：</p><p>  private static AtomicInteger nextHashCode &#x3D; new AtomicInteger()</p></li><li><p>斐波那契数也叫黄金分割数，hash 的<strong>增量</strong>就是这个数字，带来的好处是 hash 分布非常均匀：</p><p>  private static final int HASH_INCREMENT &#x3D; 0x61c88647</p></li></ul><hr><h5 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h5><p>方法都是线程安全的，因为 ThreadLocal 属于一个线程的，ThreadLocal 中的方法，逻辑都是获取当前线程维护的 ThreadLocalMap 对象，然后进行数据的增删改查，没有指定初始值的 threadlcoal 对象默认赋值为 null</p><ul><li><p>initialValue()：返回该线程局部变量的初始值</p><ul><li><p>延迟调用的方法，在执行 get 方法时才执行</p></li><li><p>该方法缺省（默认）实现直接返回一个 null</p></li><li><p>如果想要一个初始值，可以重写此方法， 该方法是一个 <code>protected</code> 的方法，为了让子类覆盖而设计的</p></li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> T <span class="hljs-title function_">initialValue</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>nextHashCode()：计算哈希值，ThreadLocal 的散列方式称之为<strong>斐波那契散列</strong>，每次获取哈希值都会加上 HASH_INCREMENT，这样做可以尽量避免 hash 冲突，让哈希值能均匀的分布在 2 的 n 次方的数组中</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nextHashCode</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">// 哈希值自增一个 HASH_INCREMENT 数值  </span><br>    <span class="hljs-keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>set()：修改当前线程与当前 threadlocal 对象相关联的线程局部变量</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;  <br>    <span class="hljs-comment">// 获取当前线程对象  </span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();  <br>    <span class="hljs-comment">// 获取此线程对象中维护的 ThreadLocalMap 对象  </span><br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);  <br>    <span class="hljs-comment">// 判断 map 是否存在  </span><br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>)  <br>        <span class="hljs-comment">// 调用 threadLocalMap.set 方法进行重写或者添加  </span><br>        map.set(<span class="hljs-built_in">this</span>, value);  <br>    <span class="hljs-keyword">else</span>  <br>        <span class="hljs-comment">// map 为空，调用 createMap 进行 ThreadLocalMap 对象的初始化。参数1是当前线程，参数2是局部变量  </span><br>        createMap(t, value);  <br>&#125;<br><br><span class="hljs-comment">// 获取当前线程 Thread 对应维护的 ThreadLocalMap   </span><br>ThreadLocalMap <span class="hljs-title function_">getMap</span><span class="hljs-params">(Thread t)</span> &#123;  <br>    <span class="hljs-keyword">return</span> t.threadLocals;  <br>&#125;  <br><span class="hljs-comment">// 创建当前线程Thread对应维护的ThreadLocalMap   </span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> &#123;  <br>    <span class="hljs-comment">// 【这里的 this 是调用此方法的 threadLocal】，创建一个新的 Map 并设置第一个数据  </span><br>    t.threadLocals = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalMap</span>(<span class="hljs-built_in">this</span>, firstValue);  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>get()：获取当前线程与当前 ThreadLocal 对象相关联的线程局部变量</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();  <br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);  <br>    <span class="hljs-comment">// 如果此map存在  </span><br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;  <br>        <span class="hljs-comment">// 以当前的 ThreadLocal 为 key，调用 getEntry 获取对应的存储实体 e  </span><br>        ThreadLocalMap.<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> map.getEntry(<span class="hljs-built_in">this</span>);  <br>        <span class="hljs-comment">// 对 e 进行判空   </span><br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-comment">// 获取存储实体 e 对应的 value值  </span><br>            <span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (T)e.value;  <br>            <span class="hljs-keyword">return</span> result;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-comment">/*有两种情况有执行当前代码  </span><br><span class="hljs-comment">      第一种情况: map 不存在，表示此线程没有维护的 ThreadLocalMap 对象  </span><br><span class="hljs-comment">      第二种情况: map 存在, 但是【没有与当前 ThreadLocal 关联的 entry】，就会设置为默认值 */</span>  <br>    <span class="hljs-comment">// 初始化当前线程与当前 threadLocal 对象相关联的 value  </span><br>    <span class="hljs-keyword">return</span> setInitialValue();  <br>&#125;<br><br><span class="hljs-keyword">private</span> T <span class="hljs-title function_">setInitialValue</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">// 调用initialValue获取初始化的值，此方法可以被子类重写, 如果不重写默认返回 null  </span><br>    <span class="hljs-type">T</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> initialValue();  <br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();  <br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);  <br>    <span class="hljs-comment">// 判断 map 是否初始化过  </span><br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>)  <br>        <span class="hljs-comment">// 存在则调用 map.set 设置此实体 entry，value 是默认的值  </span><br>        map.set(<span class="hljs-built_in">this</span>, value);  <br>    <span class="hljs-keyword">else</span>  <br>        <span class="hljs-comment">// 调用 createMap 进行 ThreadLocalMap 对象的初始化中  </span><br>        createMap(t, value);  <br>    <span class="hljs-comment">// 返回线程与当前 threadLocal 关联的局部变量  </span><br>    <span class="hljs-keyword">return</span> value;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>remove()：移除当前线程与当前 threadLocal 对象相关联的线程局部变量</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">// 获取当前线程对象中维护的 ThreadLocalMap 对象  </span><br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> getMap(Thread.currentThread());  <br>    <span class="hljs-keyword">if</span> (m != <span class="hljs-literal">null</span>)  <br>        <span class="hljs-comment">// map 存在则调用 map.remove，this时当前ThreadLocal，以this为key删除对应的实体  </span><br>        m.remove(<span class="hljs-built_in">this</span>);  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h4 id="LocalMap"><a href="#LocalMap" class="headerlink" title="LocalMap"></a>LocalMap</h4><h5 id="成员属性"><a href="#成员属性" class="headerlink" title="成员属性"></a>成员属性</h5><p>ThreadLocalMap 是 ThreadLocal 的内部类，没有实现 Map 接口，用独立的方式实现了 Map 的功能，其内部 Entry 也是独立实现</p><p>&#x2F;&#x2F; 初始化当前 map 内部散列表数组的初始长度 16<br>private static final int INITIAL_CAPACITY &#x3D; 16;  </p><p>&#x2F;&#x2F; 存放数据的table，数组长度必须是2的整次幂。<br>private Entry[] table;  </p><p>&#x2F;&#x2F; 数组里面 entrys 的个数，可以用于判断 table 当前使用量是否超过阈值<br>private int size &#x3D; 0;  </p><p>&#x2F;&#x2F; 进行扩容的阈值，表使用量大于它的时候进行扩容。<br>private int threshold;</p><p>存储结构 Entry：</p><ul><li><p>Entry 继承 WeakReference，key 是弱引用，目的是将 ThreadLocal 对象的生命周期和线程生命周期解绑</p></li><li><p>Entry 限制只能用 ThreadLocal 作为 key，key 为 null (entry.get() &#x3D;&#x3D; null) 意味着 key 不再被引用，entry 也可以从 table 中清除</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;  <br>    Object value;  <br>    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;  <br>        <span class="hljs-comment">// this.referent = referent = key;  </span><br>        <span class="hljs-built_in">super</span>(k);  <br>        value = v;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>构造方法：延迟初始化的，线程第一次存储 threadLocal - value 时才会创建 threadLocalMap 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;  <br>    <span class="hljs-comment">// 初始化table，创建一个长度为16的Entry数组  </span><br>    table = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[INITIAL_CAPACITY];  <br>    <span class="hljs-comment">// 【寻址算法】计算索引  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="hljs-number">1</span>);  <br>    <span class="hljs-comment">// 创建 entry 对象，存放到指定位置的 slot 中  </span><br>    table[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(firstKey, firstValue);  <br>    <span class="hljs-comment">// 数据总量是 1  </span><br>    size = <span class="hljs-number">1</span>;  <br>    <span class="hljs-comment">// 将阈值设置为 （当前数组长度 * 2）/ 3。  </span><br>    setThreshold(INITIAL_CAPACITY);  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="成员方法-1"><a href="#成员方法-1" class="headerlink" title="成员方法"></a>成员方法</h5><ul><li><p>set()：添加数据，ThreadLocalMap 使用<strong>线性探测法来解决哈希冲突</strong></p><ul><li><p>该方法会一直探测下一个地址，直到有空的地址后插入，若插入后 Map 数量超过阈值，数组会扩容为原来的 2 倍</p><p>  假设当前 table 长度为16，计算出来 key 的 hash 值为 14，如果 table[14] 上已经有值，并且其 key 与当前 key 不一致，那么就发生了 hash 冲突，这个时候将 14 加 1 得到 15，取 table[15] 进行判断，如果还是冲突会回到 0，取 table[0]，以此类推，直到可以插入，可以把 Entry[] table 看成一个<strong>环形数组</strong></p></li><li><p>线性探测法会出现<strong>堆积问题</strong>，可以采取平方探测法解决</p></li><li><p>在探测过程中 ThreadLocal 会复用 key 为 null 的脏 Entry 对象，并进行垃圾清理，防止出现内存泄漏</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;  <br>    <span class="hljs-comment">// 获取散列表  </span><br>    ThreadLocal.ThreadLocalMap.Entry[] tab = table;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;  <br>    <span class="hljs-comment">// 哈希寻址  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (len-<span class="hljs-number">1</span>);  <br>    <span class="hljs-comment">// 使用线性探测法向后查找元素，碰到 entry 为空时停止探测  </span><br>    <span class="hljs-keyword">for</span> (ThreadLocal.ThreadLocalMap.<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[i]; e != <span class="hljs-literal">null</span>; e = tab[i = nextIndex(i, len)]) &#123;  <br>        <span class="hljs-comment">// 获取当前元素 key  </span><br>        ThreadLocal&lt;?&gt; k = e.get();  <br>        <span class="hljs-comment">// ThreadLocal 对应的 key 存在，【直接覆盖之前的值】  </span><br>        <span class="hljs-keyword">if</span> (k == key) &#123;  <br>            e.value = value;  <br>            <span class="hljs-keyword">return</span>;  <br>        &#125;  <br>        <span class="hljs-comment">// 【这两个条件谁先成立不一定，所以 replaceStaleEntry 中还需要判断 k == key 的情况】  </span><br>          <br>        <span class="hljs-comment">// key 为 null，但是值不为 null，说明之前的 ThreadLocal 对象已经被回收了，当前是【过期数据】  </span><br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-comment">// 【碰到一个过期的 slot，当前数据复用该槽位，替换过期数据】  </span><br>            <span class="hljs-comment">// 这个方法还进行了垃圾清理动作，防止内存泄漏  </span><br>            replaceStaleEntry(key, value, i);  <br>            <span class="hljs-keyword">return</span>;  <br>        &#125;  <br>    &#125;  <br><span class="hljs-comment">// 逻辑到这说明碰到 slot == null 的位置，则在空元素的位置创建一个新的 Entry  </span><br>    tab[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(key, value);  <br>    <span class="hljs-comment">// 数量 + 1  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">sz</span> <span class="hljs-operator">=</span> ++size;  <br>      <br>    <span class="hljs-comment">// 【做一次启发式清理】，如果没有清除任何 entry 并且【当前使用量达到了负载因子所定义，那么进行 rehash  </span><br>    <span class="hljs-keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)  <br>        <span class="hljs-comment">// 扩容  </span><br>        rehash();  <br>&#125;<br><br><span class="hljs-comment">// 获取【环形数组】的下一个索引  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nextIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> len)</span> &#123;  <br>    <span class="hljs-comment">// 索引越界后从 0 开始继续获取  </span><br>    <span class="hljs-keyword">return</span> ((i + <span class="hljs-number">1</span> &lt; len) ? i + <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);  <br>&#125;<br><br><span class="hljs-comment">// 在指定位置插入指定的数据  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">replaceStaleEntry</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, Object value, <span class="hljs-type">int</span> staleSlot)</span> &#123;  <br>    <span class="hljs-comment">// 获取散列表  </span><br>    Entry[] tab = table;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;  <br>    Entry e;  <br><span class="hljs-comment">// 探测式清理的开始下标，默认从当前 staleSlot 开始  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">slotToExpunge</span> <span class="hljs-operator">=</span> staleSlot;  <br>    <span class="hljs-comment">// 以当前 staleSlot 开始【向前迭代查找】，找到索引靠前过期数据，找到以后替换 slotToExpunge 值  </span><br>    <span class="hljs-comment">// 【保证在一个区间段内，从最前面的过期数据开始清理】  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> prevIndex(staleSlot, len); (e = tab[i]) != <span class="hljs-literal">null</span>; i = prevIndex(i, len))  <br>        <span class="hljs-keyword">if</span> (e.get() == <span class="hljs-literal">null</span>)  <br>            slotToExpunge = i;  <br>  <br><span class="hljs-comment">// 以 staleSlot 【向后去查找】，直到碰到 null 为止，还是线性探测  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> nextIndex(staleSlot, len); (e = tab[i]) != <span class="hljs-literal">null</span>; i = nextIndex(i, len)) &#123;  <br>        <span class="hljs-comment">// 获取当前节点的 key  </span><br>        ThreadLocal&lt;?&gt; k = e.get();  <br><span class="hljs-comment">// 条件成立说明是【替换逻辑】  </span><br>        <span class="hljs-keyword">if</span> (k == key) &#123;  <br>            e.value = value;  <br>            <span class="hljs-comment">// 因为本来要在 staleSlot 索引处插入该数据，现在找到了i索引处的key与数据一致  </span><br>            <span class="hljs-comment">// 但是 i 位置距离正确的位置更远，因为是向后查找，所以还是要在 staleSlot 位置插入当前 entry  </span><br>            <span class="hljs-comment">// 然后将 table[staleSlot] 这个过期数据放到当前循环到的 table[i] 这个位置，  </span><br>            tab[i] = tab[staleSlot];  <br>            tab[staleSlot] = e;  <br>  <br>            <span class="hljs-comment">// 条件成立说明向前查找过期数据并未找到过期的 entry，但 staleSlot 位置已经不是过期数据了，i 位置才是  </span><br>            <span class="hljs-keyword">if</span> (slotToExpunge == staleSlot)  <br>                slotToExpunge = i;  <br>              <br>            <span class="hljs-comment">// 【清理过期数据，expungeStaleEntry 探测式清理，cleanSomeSlots 启发式清理】  </span><br>            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);  <br>            <span class="hljs-keyword">return</span>;  <br>        &#125;  <br><span class="hljs-comment">// 条件成立说明当前遍历的 entry 是一个过期数据，并且该位置前面也没有过期数据  </span><br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span> &amp;&amp; slotToExpunge == staleSlot)  <br>            <span class="hljs-comment">// 探测式清理过期数据的开始下标修改为当前循环的 index，因为 staleSlot 会放入要添加的数据  </span><br>            slotToExpunge = i;  <br>    &#125;  <br><span class="hljs-comment">// 向后查找过程中并未发现 k == key 的 entry，说明当前是一个【取代过期数据逻辑】  </span><br>    <span class="hljs-comment">// 删除原有的数据引用，防止内存泄露  </span><br>    tab[staleSlot].value = <span class="hljs-literal">null</span>;  <br>    <span class="hljs-comment">// staleSlot 位置添加数据，【上面的所有逻辑都不会更改 staleSlot 的值】  </span><br>    tab[staleSlot] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(key, value);  <br>  <br>    <span class="hljs-comment">// 条件成立说明除了 staleSlot 以外，还发现其它的过期 slot，所以要【开启清理数据的逻辑】  </span><br>    <span class="hljs-keyword">if</span> (slotToExpunge != staleSlot)  <br>        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);  <br>&#125;<br><br></code></pre></td></tr></table></figure><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041727787.png"></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">prevIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> len)</span> &#123;  <br>    <span class="hljs-comment">// 形成一个环绕式的访问，头索引越界后置为尾索引  </span><br>    <span class="hljs-keyword">return</span> ((i - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>) ? i - <span class="hljs-number">1</span> : len - <span class="hljs-number">1</span>);  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>getEntry()：ThreadLocal 的 get 方法以当前的 ThreadLocal 为 key，调用 getEntry 获取对应的存储实体 e</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> Entry <span class="hljs-title function_">getEntry</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key)</span> &#123;  <br>    <span class="hljs-comment">// 哈希寻址  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (table.length - <span class="hljs-number">1</span>);  <br>    <span class="hljs-comment">// 访问散列表中指定指定位置的 slot   </span><br>    <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> table[i];  <br>    <span class="hljs-comment">// 条件成立，说明 slot 有值并且 key 就是要寻找的 key，直接返回  </span><br>    <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span> &amp;&amp; e.get() == key)  <br>        <span class="hljs-keyword">return</span> e;  <br>    <span class="hljs-keyword">else</span>  <br>        <span class="hljs-comment">// 进行线性探测  </span><br>        <span class="hljs-keyword">return</span> getEntryAfterMiss(key, i, e);  <br>&#125;  <br><span class="hljs-comment">// 线性探测寻址  </span><br><span class="hljs-keyword">private</span> Entry <span class="hljs-title function_">getEntryAfterMiss</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, <span class="hljs-type">int</span> i, Entry e)</span> &#123;  <br>    <span class="hljs-comment">// 获取散列表  </span><br>    Entry[] tab = table;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;  <br>  <br>    <span class="hljs-comment">// 开始遍历，碰到 slot == null 的情况，搜索结束  </span><br>    <span class="hljs-keyword">while</span> (e != <span class="hljs-literal">null</span>) &#123;  <br><span class="hljs-comment">// 获取当前 slot 中 entry 对象的 key  </span><br>        ThreadLocal&lt;?&gt; k = e.get();  <br>        <span class="hljs-comment">// 条件成立说明找到了，直接返回  </span><br>        <span class="hljs-keyword">if</span> (k == key)  <br>            <span class="hljs-keyword">return</span> e;  <br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>)  <br>             <span class="hljs-comment">// 过期数据，【探测式过期数据回收】  </span><br>            expungeStaleEntry(i);  <br>        <span class="hljs-keyword">else</span>  <br>            <span class="hljs-comment">// 更新 index 继续向后走  </span><br>            i = nextIndex(i, len);  <br>        <span class="hljs-comment">// 获取下一个槽位中的 entry  </span><br>        e = tab[i];  <br>    &#125;  <br>    <span class="hljs-comment">// 说明当前区段没有找到相应数据  </span><br>    <span class="hljs-comment">// 【因为存放数据是线性的向后寻找槽位，都是紧挨着的，不可能越过一个 空槽位 在后面放】，可以减少遍历的次数  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>rehash()：触发一次全量清理，如果数组长度大于等于长度的 <code>2/3 * 3/4 = 1/2</code>，则进行 resize</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rehash</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">// 清楚当前散列表内的【所有】过期的数据  </span><br>    expungeStaleEntries();  <br>      <br>    <span class="hljs-comment">// threshold = len * 2 / 3，就是 2/3 * (1 - 1/4)  </span><br>    <span class="hljs-keyword">if</span> (size &gt;= threshold - threshold / <span class="hljs-number">4</span>)  <br>        resize();  <br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">expungeStaleEntries</span><span class="hljs-params">()</span> &#123;  <br>    Entry[] tab = table;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;  <br>    <span class="hljs-comment">// 【遍历所有的槽位，清理过期数据】  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; len; j++) &#123;  <br>        <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[j];  <br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span> &amp;&amp; e.get() == <span class="hljs-literal">null</span>)  <br>            expungeStaleEntry(j);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>  Entry <strong>数组为扩容为原来的 2 倍</strong> ，重新计算 key 的散列值，如果遇到 key 为 null 的情况，会将其 value 也置为 null，帮助 GC</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">resize</span><span class="hljs-params">()</span> &#123;  <br>    Entry[] oldTab = table;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldLen</span> <span class="hljs-operator">=</span> oldTab.length;  <br>    <span class="hljs-comment">// 新数组的长度是老数组的二倍  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">newLen</span> <span class="hljs-operator">=</span> oldLen * <span class="hljs-number">2</span>;  <br>    Entry[] newTab = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[newLen];  <br>    <span class="hljs-comment">// 统计新table中的entry数量  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br><span class="hljs-comment">// 遍历老表，进行【数据迁移】  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; oldLen; ++j) &#123;  <br>        <span class="hljs-comment">// 访问老表的指定位置的 entry  </span><br>        <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> oldTab[j];  <br>        <span class="hljs-comment">// 条件成立说明老表中该位置有数据，可能是过期数据也可能不是  </span><br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;  <br>            ThreadLocal&lt;?&gt; k = e.get();  <br>            <span class="hljs-comment">// 过期数据  </span><br>            <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>) &#123;  <br>                e.value = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Help the GC  </span><br>            &#125; <span class="hljs-keyword">else</span> &#123;  <br>                <span class="hljs-comment">// 非过期数据，在新表中进行哈希寻址  </span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> k.threadLocalHashCode &amp; (newLen - <span class="hljs-number">1</span>);  <br>                <span class="hljs-comment">// 【线程探测】  </span><br>                <span class="hljs-keyword">while</span> (newTab[h] != <span class="hljs-literal">null</span>)  <br>                    h = nextIndex(h, newLen);  <br>                <span class="hljs-comment">// 将数据存放到新表合适的 slot 中  </span><br>                newTab[h] = e;  <br>                count++;  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br><span class="hljs-comment">// 设置下一次触发扩容的指标：threshold = len * 2 / 3;  </span><br>    setThreshold(newLen);  <br>    size = count;  <br>    <span class="hljs-comment">// 将扩容后的新表赋值给 threadLocalMap 内部散列表数组引用  </span><br>    table = newTab;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>remove()：删除 Entry</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key)</span> &#123;  <br>    Entry[] tab = table;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;  <br>    <span class="hljs-comment">// 哈希寻址  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (len-<span class="hljs-number">1</span>);  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[i]; e != <span class="hljs-literal">null</span>; e = tab[i = nextIndex(i, len)]) &#123;  <br>        <span class="hljs-comment">// 找到了对应的 key  </span><br>        <span class="hljs-keyword">if</span> (e.get() == key) &#123;  <br>            <span class="hljs-comment">// 设置 key 为 null  </span><br>            e.clear();  <br>            <span class="hljs-comment">// 探测式清理  </span><br>            expungeStaleEntry(i);  <br>            <span class="hljs-keyword">return</span>;  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h5 id="清理方法"><a href="#清理方法" class="headerlink" title="清理方法"></a>清理方法</h5><ul><li><p>探测式清理：沿着开始位置向后探测清理过期数据，沿途中碰到未过期数据则将此数据 rehash 在 table 数组中的定位，重定位后的元素理论上更接近 <code>i = entry.key &amp; (table.length - 1)</code>，让<strong>数据的排列更紧凑</strong>，会优化整个散列表查询性能</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// table[staleSlot] 是一个过期数据，以这个位置开始继续向后查找过期数据  </span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">expungeStaleEntry</span><span class="hljs-params">(<span class="hljs-type">int</span> staleSlot)</span> &#123;  <br>    <span class="hljs-comment">// 获取散列表和数组长度  </span><br>    Entry[] tab = table;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;  <br>  <br>    <span class="hljs-comment">// help gc，先把当前过期的 entry 置空，在取消对 entry 的引用  </span><br>    tab[staleSlot].value = <span class="hljs-literal">null</span>;  <br>    tab[staleSlot] = <span class="hljs-literal">null</span>;  <br>    <span class="hljs-comment">// 数量-1  </span><br>    size--;  <br>  <br>    Entry e;  <br>    <span class="hljs-type">int</span> i;  <br>    <span class="hljs-comment">// 从 staleSlot 开始向后遍历，直到碰到 slot == null 结束，【区间内清理过期数据】  </span><br>    <span class="hljs-keyword">for</span> (i = nextIndex(staleSlot, len); (e = tab[i]) != <span class="hljs-literal">null</span>; i = nextIndex(i, len)) &#123;  <br>        ThreadLocal&lt;?&gt; k = e.get();  <br>        <span class="hljs-comment">// 当前 entry 是过期数据  </span><br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-comment">// help gc  </span><br>            e.value = <span class="hljs-literal">null</span>;  <br>            tab[i] = <span class="hljs-literal">null</span>;  <br>            size--;  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            <span class="hljs-comment">// 当前 entry 不是过期数据的逻辑，【rehash】  </span><br>            <span class="hljs-comment">// 重新计算当前 entry 对应的 index  </span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> k.threadLocalHashCode &amp; (len - <span class="hljs-number">1</span>);  <br>            <span class="hljs-comment">// 条件成立说明当前 entry 存储时发生过 hash 冲突，向后偏移过了  </span><br>            <span class="hljs-keyword">if</span> (h != i) &#123;  <br>                <span class="hljs-comment">// 当前位置置空  </span><br>                tab[i] = <span class="hljs-literal">null</span>;  <br>                <span class="hljs-comment">// 以正确位置 h 开始，向后查找第一个可以存放 entry 的位置  </span><br>                <span class="hljs-keyword">while</span> (tab[h] != <span class="hljs-literal">null</span>)  <br>                    h = nextIndex(h, len);  <br>                <span class="hljs-comment">// 将当前元素放入到【距离正确位置更近的位置，有可能就是正确位置】  </span><br>                tab[h] = e;  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-comment">// 返回 slot = null 的槽位索引，图例是 7，这个索引代表【索引前面的区间已经清理完成垃圾了】  </span><br>    <span class="hljs-keyword">return</span> i;  <br>&#125;<br></code></pre></td></tr></table></figure><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041729624.png"></p><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041729128.png"></p></li><li><p>启发式清理：向后循环扫描过期数据，发现过期数据调用探测式清理方法，如果连续几次的循环都没有发现过期数据，就停止扫描</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">//  i 表示启发式清理工作开始位置，一般是空 slot，n 一般传递的是 table.length   </span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">cleanSomeSlots</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> n)</span> &#123;  <br>    <span class="hljs-comment">// 表示启发式清理工作是否清除了过期数据  </span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">removed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;  <br>    <span class="hljs-comment">// 获取当前 map 的散列表引用  </span><br>    Entry[] tab = table;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;  <br>    <span class="hljs-keyword">do</span> &#123;  <br>        <span class="hljs-comment">// 获取下一个索引，因为探测式返回的 slot 为 null  </span><br>        i = nextIndex(i, len);  <br>        <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[i];  <br>        <span class="hljs-comment">// 条件成立说明是过期的数据，key 被 gc 了  </span><br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span> &amp;&amp; e.get() == <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-comment">// 【发现过期数据重置 n 为数组的长度】  </span><br>            n = len;  <br>            <span class="hljs-comment">// 表示清理过过期数据  </span><br>            removed = <span class="hljs-literal">true</span>;  <br>            <span class="hljs-comment">// 以当前过期的 slot 为开始节点 做一次探测式清理工作  </span><br>            i = expungeStaleEntry(i);  <br>        &#125;  <br>        <span class="hljs-comment">// 假设 table 长度为 16  </span><br>        <span class="hljs-comment">// 16 &gt;&gt;&gt; 1 ==&gt; 8，8 &gt;&gt;&gt; 1 ==&gt; 4，4 &gt;&gt;&gt; 1 ==&gt; 2，2 &gt;&gt;&gt; 1 ==&gt; 1，1 &gt;&gt;&gt; 1 ==&gt; 0  </span><br>        <span class="hljs-comment">// 连续经过这么多次循环【没有扫描到过期数据】，就停止循环，扫描到空 slot 不算，因为不是过期数据  </span><br>    &#125; <span class="hljs-keyword">while</span> ((n &gt;&gt;&gt;= <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>);  <br>      <br>    <span class="hljs-comment">// 返回清除标记  </span><br>    <span class="hljs-keyword">return</span> removed;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h4><p>Memory leak：内存泄漏是指程序中动态分配的堆内存由于某种原因未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果，内存泄漏的堆积终将导致内存溢出</p><ul><li><p>如果 key 使用强引用：使用完 ThreadLocal ，threadLocal Ref 被回收，但是 threadLocalMap 的 Entry 强引用了 threadLocal，造成 threadLocal 无法被回收，无法完全避免内存泄漏</p><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041730276.png"></p></li><li><p>如果 key 使用弱引用：使用完 ThreadLocal ，threadLocal Ref 被回收，ThreadLocalMap 只持有 ThreadLocal 的弱引用，所以threadlocal 也可以被回收，此时 Entry 中的 key &#x3D; null。但没有手动删除这个 Entry 或者 CurrentThread 依然运行，依然存在强引用链，value 不会被回收，而这块 value 永远不会被访问到，也会导致 value 内存泄漏</p><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041730339.png"></p></li><li><p>两个主要原因：</p><ul><li><p>没有手动删除这个 Entry</p></li><li><p>CurrentThread 依然运行</p></li></ul></li></ul><p>根本原因：ThreadLocalMap 是 Thread的一个属性，<strong>生命周期跟 Thread 一样长</strong>，如果没有手动删除对应 Entry 就会导致内存泄漏</p><p>解决方法：使用完 ThreadLocal 中存储的内容后将它 remove 掉就可以</p><p>ThreadLocal 内部解决方法：在 ThreadLocalMap 中的 set&#x2F;getEntry 方法中，通过线性探测法对 key 进行判断，如果 key 为 null（ThreadLocal 为 null）会对 Entry 进行垃圾回收。所以<strong>使用弱引用比强引用多一层保障</strong>，就算不调用 remove，也有机会进行 GC</p><hr><h4 id="变量传递"><a href="#变量传递" class="headerlink" title="变量传递"></a>变量传递</h4><h5 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h5><p>父子线程：创建子线程的线程是父线程，比如实例中的 main 线程就是父线程</p><p>ThreadLocal 中存储的是线程的局部变量，如果想<strong>实现线程间局部变量传递</strong>可以使用 InheritableThreadLocal 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    ThreadLocal&lt;String&gt; threadLocal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InheritableThreadLocal</span>&lt;&gt;();  <br>    threadLocal.set(<span class="hljs-string">&quot;父线程设置的值&quot;</span>);  <br>  <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; System.out.println(<span class="hljs-string">&quot;子线程输出：&quot;</span> + threadLocal.get())).start();  <br>&#125;  <br><span class="hljs-comment">// 子线程输出：父线程设置的值</span><br></code></pre></td></tr></table></figure><hr><h5 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h5><p>InheritableThreadLocal 源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InheritableThreadLocal</span>&lt;T&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ThreadLocal</span>&lt;T&gt; &#123;  <br>    <span class="hljs-keyword">protected</span> T <span class="hljs-title function_">childValue</span><span class="hljs-params">(T parentValue)</span> &#123;  <br>        <span class="hljs-keyword">return</span> parentValue;  <br>    &#125;  <br>    ThreadLocalMap <span class="hljs-title function_">getMap</span><span class="hljs-params">(Thread t)</span> &#123;  <br>       <span class="hljs-keyword">return</span> t.inheritableThreadLocals;  <br>    &#125;  <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> &#123;  <br>        t.inheritableThreadLocals = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalMap</span>(<span class="hljs-built_in">this</span>, firstValue);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>实现父子线程间的局部变量共享需要追溯到 Thread 对象的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(ThreadGroup g, Runnable target, String name, <span class="hljs-type">long</span> stackSize, AccessControlContext acc,  </span><br><span class="hljs-params">                  // 该参数默认是 <span class="hljs-literal">true</span>  </span><br><span class="hljs-params">                  <span class="hljs-type">boolean</span> inheritThreadLocals)</span> &#123;  <br>  <span class="hljs-comment">// ...  </span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> currentThread();  <br>  <br>    <span class="hljs-comment">// 判断父线程（创建子线程的线程）的 inheritableThreadLocals 属性不为 null  </span><br>    <span class="hljs-keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="hljs-literal">null</span>) &#123;  <br>        <span class="hljs-comment">// 复制父线程的 inheritableThreadLocals 属性，实现父子线程局部变量共享  </span><br>        <span class="hljs-built_in">this</span>.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);   <br>    &#125;  <br>    <span class="hljs-comment">// ..  </span><br>&#125;  <br><span class="hljs-comment">// 【本质上还是创建 ThreadLocalMap，只是把父类中的可继承数据设置进去了】  </span><br><span class="hljs-keyword">static</span> ThreadLocalMap <span class="hljs-title function_">createInheritedMap</span><span class="hljs-params">(ThreadLocalMap parentMap)</span> &#123;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalMap</span>(parentMap);  <br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-title function_">ThreadLocalMap</span><span class="hljs-params">(ThreadLocalMap parentMap)</span> &#123;  <br>    <span class="hljs-comment">// 获取父线程的哈希表  </span><br>    Entry[] parentTable = parentMap.table;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> parentTable.length;  <br>    setThreshold(len);  <br>    table = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[len];  <br><span class="hljs-comment">// 【逐个复制父线程 ThreadLocalMap 中的数据】  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; len; j++) &#123;  <br>        <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> parentTable[j];  <br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;  <br>            ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();  <br>            <span class="hljs-keyword">if</span> (key != <span class="hljs-literal">null</span>) &#123;  <br>                <span class="hljs-comment">// 调用的是 InheritableThreadLocal#childValue(T parentValue)  </span><br>                <span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> key.childValue(e.value);  <br>                <span class="hljs-type">Entry</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(key, value);  <br>                <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (len - <span class="hljs-number">1</span>);  <br>                <span class="hljs-comment">// 线性探测  </span><br>                <span class="hljs-keyword">while</span> (table[h] != <span class="hljs-literal">null</span>)  <br>                    h = nextIndex(h, len);  <br>                table[h] = c;  <br>                size++;  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h3><p>线程池：一个容纳多个线程的容器，容器中的线程可以重复使用，省去了频繁创建和销毁线程对象的操作</p><p>线程池作用：</p><ol><li><p>降低资源消耗，减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务</p></li><li><p>提高响应速度，当任务到达时，如果有线程可以直接用，不会出现系统僵死</p></li><li><p>提高线程的可管理性，如果无限制的创建线程，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控</p></li></ol><p>线程池的核心思想：<strong>线程复用</strong>，同一个线程可以被重复使用，来处理多个任务</p><p>池化技术 (Pool) ：一种编程技巧，核心思想是资源复用，在请求量大时能优化应用性能，降低系统频繁建连的资源开销</p><hr><h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><h4 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>有界队列和无界队列：</p><ul><li><p>有界队列：有固定大小的队列，比如设定了固定大小的 LinkedBlockingQueue，又或者大小为 0</p></li><li><p>无界队列：没有设置固定大小的队列，这些队列可以直接入队，直到溢出（超过 Integer.MAX_VALUE），所以相当于无界</p></li></ul><p>java.util.concurrent.BlockingQueue 接口有以下阻塞队列的实现：<strong>FIFO 队列</strong></p><ul><li><p>ArrayBlockQueue：由数组结构组成的有界阻塞队列</p></li><li><p>LinkedBlockingQueue：由链表结构组成的无界（默认大小 Integer.MAX_VALUE）的阻塞队列</p></li><li><p>PriorityBlockQueue：支持优先级排序的无界阻塞队列</p></li><li><p>DelayedWorkQueue：使用优先级队列实现的延迟无界阻塞队列</p></li><li><p>SynchronousQueue：不存储元素的阻塞队列，每一个生产线程会阻塞到有一个 put 的线程放入元素为止</p></li><li><p>LinkedTransferQueue：由链表结构组成的无界阻塞队列</p></li><li><p>LinkedBlockingDeque：由链表结构组成的<strong>双向</strong>阻塞队列</p></li></ul><p>与普通队列（LinkedList、ArrayList等）的不同点在于阻塞队列中阻塞添加和阻塞删除方法，以及线程安全：</p><ul><li><p>阻塞添加 put()：当阻塞队列元素已满时，添加队列元素的线程会被阻塞，直到队列元素不满时才重新唤醒线程执行</p></li><li><p>阻塞删除 take()：在队列元素为空时，删除队列元素的线程将被阻塞，直到队列不为空再执行删除操作（一般会返回被删除的元素)</p></li></ul><hr><h4 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h4><table><thead><tr><th>方法类型</th><th>抛出异常</th><th>特殊值</th><th>阻塞</th><th>超时</th></tr></thead><tbody><tr><td>插入（尾）</td><td>add(e)</td><td>offer(e)</td><td>put(e)</td><td>offer(e,time,unit)</td></tr><tr><td>移除（头）</td><td>remove()</td><td>poll()</td><td>take()</td><td>poll(time,unit)</td></tr><tr><td>检查（队首元素）</td><td>element()</td><td>peek()</td><td>不可用</td><td>不可用</td></tr></tbody></table><ul><li><p>抛出异常组：</p><ul><li><p>当阻塞队列满时：在往队列中 add 插入元素会抛出 IIIegalStateException: Queue full</p></li><li><p>当阻塞队列空时：再往队列中 remove 移除元素，会抛出 NoSuchException</p></li></ul></li><li><p>特殊值组：</p><ul><li><p>插入方法：成功 true，失败 false</p></li><li><p>移除方法：成功返回出队列元素，队列没有就返回 null</p></li></ul></li><li><p>阻塞组：</p><ul><li><p>当阻塞队列满时，生产者继续往队列里 put 元素，队列会一直阻塞生产线程直到队列有空间 put 数据或响应中断退出</p></li><li><p>当阻塞队列空时，消费者线程试图从队列里 take 元素，队列会一直阻塞消费者线程直到队列中有可用元素</p></li></ul></li><li><p>超时退出：当阻塞队列满时，队里会阻塞生产者线程一定时间，超过限时后生产者线程会退出</p></li></ul><hr><h4 id="链表队列"><a href="#链表队列" class="headerlink" title="链表队列"></a>链表队列</h4><h5 id="入队出队"><a href="#入队出队" class="headerlink" title="入队出队"></a>入队出队</h5><p>LinkedBlockingQueue 源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueue</span>&lt;E&gt;  <br><span class="hljs-keyword">implements</span> <span class="hljs-title class_">BlockingQueue</span>&lt;E&gt;, java.io.Serializable &#123;  <br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;E&gt; &#123;  <br>        E item;  <br>        <span class="hljs-comment">/**  </span><br><span class="hljs-comment">        * 下列三种情况之一  </span><br><span class="hljs-comment">        * - 真正的后继节点  </span><br><span class="hljs-comment">        * - 自己, 发生在出队时  </span><br><span class="hljs-comment">        * - null, 表示是没有后继节点, 是尾节点了  </span><br><span class="hljs-comment">        */</span>  <br>        Node&lt;E&gt; next;  <br>  <br>        Node(E x) &#123; item = x; &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>入队：<strong>尾插法</strong></p><ul><li><p>初始化链表 <code>last = head = new Node&lt;E&gt;(null)</code>，<strong>Dummy 节点用来占位</strong>，item 为 null</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedBlockingQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;  <br>    <span class="hljs-comment">// 默认是 Integer.MAX_VALUE  </span><br>    <span class="hljs-keyword">if</span> (capacity &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();  <br>    <span class="hljs-built_in">this</span>.capacity = capacity;  <br>    last = head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;E&gt;(<span class="hljs-literal">null</span>);  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>当一个节点入队：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">enqueue</span><span class="hljs-params">(Node&lt;E&gt; node)</span> &#123;  <br>    <span class="hljs-comment">// 从右向左计算  </span><br>    last = last.next = node;  <br>&#125;<br></code></pre></td></tr></table></figure><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041733155.png"></p></li><li><p>再来一个节点入队 <code>last = last.next = node</code></p></li></ul><p>出队：<strong>出队头节点</strong>，FIFO</p><ul><li><p>出队源码：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> E <span class="hljs-title function_">dequeue</span><span class="hljs-params">()</span> &#123;  <br>    Node&lt;E&gt; h = head;  <br>    <span class="hljs-comment">// 获取临头节点  </span><br>    Node&lt;E&gt; first = h.next;  <br>    <span class="hljs-comment">// 自己指向自己，help GC  </span><br>    h.next = h;  <br>    head = first;  <br>    <span class="hljs-comment">// 出队的元素  </span><br>    <span class="hljs-type">E</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> first.item;  <br>    <span class="hljs-comment">// 【当前节点置为 Dummy 节点】  </span><br>    first.item = <span class="hljs-literal">null</span>;  <br>    <span class="hljs-keyword">return</span> x;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>h = head</code> → <code>first = h.next</code></p><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041734054.png"></p></li><li><p><code>h.next = h</code> → <code>head = first</code></p><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041734203.png"></p><ul><li><code>first.item = null</code>：当前节点置为 Dummy 节点</li></ul></li></ul><hr><h5 id="加锁分析"><a href="#加锁分析" class="headerlink" title="加锁分析"></a>加锁分析</h5><p>用了两把锁和 dummy 节点：</p><ul><li><p>用一把锁，同一时刻，最多只允许有一个线程（生产者或消费者，二选一）执行</p></li><li><p>用两把锁，同一时刻，可以允许两个线程同时（一个生产者与一个消费者）执行</p><ul><li><p>消费者与消费者线程仍然串行</p></li><li><p>生产者与生产者线程仍然串行</p></li></ul></li></ul><p>线程安全分析：</p><ul><li><p>当节点总数大于 2 时（包括 dummy 节点），<strong>putLock 保证的是 last 节点的线程安全，takeLock 保证的是 head 节点的线程安全</strong>，两把锁保证了入队和出队没有竞争</p></li><li><p>当节点总数等于 2 时（即一个 dummy 节点，一个正常节点）这时候，仍然是两把锁锁两个对象，不会竞争</p></li><li><p>当节点总数等于 1 时（就一个 dummy 节点）这时 take 线程会被 notEmpty 条件阻塞，有竞争，会阻塞</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// 用于 put(阻塞) offer(非阻塞)  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">putLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();  <br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">notFull</span> <span class="hljs-operator">=</span> putLock.newCondition();<span class="hljs-comment">// 阻塞等待不满，说明已经满了  </span><br>  <br><span class="hljs-comment">// 用于 take(阻塞) poll(非阻塞)  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">takeLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();  <br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">notEmpty</span> <span class="hljs-operator">=</span> takeLock.newCondition();<span class="hljs-comment">// 阻塞等待不空，说明已经是空的</span><br></code></pre></td></tr></table></figure></li></ul><p>入队出队：</p><ul><li><p>put 操作：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(E e)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>    <span class="hljs-comment">// 空指针异常  </span><br>    <span class="hljs-keyword">if</span> (e == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;  <br>    <span class="hljs-comment">// 把待添加的元素封装为 node 节点  </span><br>    Node&lt;E&gt; node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;E&gt;(e);  <br>    <span class="hljs-comment">// 获取全局生产锁  </span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">putLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.putLock;  <br>    <span class="hljs-comment">// count 用来维护元素计数  </span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.count;  <br>    <span class="hljs-comment">// 获取可打断锁，会抛出异常  </span><br>    putLock.lockInterruptibly();  <br>    <span class="hljs-keyword">try</span> &#123;  <br>    <span class="hljs-comment">// 队列满了等待  </span><br>        <span class="hljs-keyword">while</span> (count.get() == capacity) &#123;  <br>            <span class="hljs-comment">// 【等待队列不满时，就可以生产数据】，线程处于 Waiting  </span><br>            notFull.await();  <br>        &#125;  <br>        <span class="hljs-comment">// 有空位, 入队且计数加一，尾插法  </span><br>        enqueue(node);  <br>        <span class="hljs-comment">// 返回自增前的数字  </span><br>        c = count.getAndIncrement();  <br>        <span class="hljs-comment">// put 完队列还有空位, 唤醒其他生产 put 线程，唤醒一个减少竞争  </span><br>        <span class="hljs-keyword">if</span> (c + <span class="hljs-number">1</span> &lt; capacity)  <br>            notFull.signal();  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        <span class="hljs-comment">// 解锁  </span><br>        putLock.unlock();  <br>    &#125;  <br>    <span class="hljs-comment">// c自增前是0，说明生产了一个元素，唤醒一个 take 线程  </span><br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>)  <br>        signalNotEmpty();  <br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">signalNotEmpty</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">takeLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.takeLock;  <br>    takeLock.lock();  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-comment">// 调用 notEmpty.signal()，而不是 notEmpty.signalAll() 是为了减少竞争，因为只剩下一个元素  </span><br>        notEmpty.signal();  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        takeLock.unlock();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>take 操作：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>    E x;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;  <br>    <span class="hljs-comment">// 元素个数  </span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.count;  <br>    <span class="hljs-comment">// 获取全局消费锁  </span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">takeLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.takeLock;  <br>    <span class="hljs-comment">// 可打断锁  </span><br>    takeLock.lockInterruptibly();  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-comment">// 没有元素可以出队  </span><br>        <span class="hljs-keyword">while</span> (count.get() == <span class="hljs-number">0</span>) &#123;  <br>            <span class="hljs-comment">// 【阻塞等待队列不空，就可以消费数据】，线程处于 Waiting  </span><br>            notEmpty.await();  <br>        &#125;  <br>        <span class="hljs-comment">// 出队，计数减一，FIFO，出队头节点  </span><br>        x = dequeue();  <br>        <span class="hljs-comment">// 返回自减前的数字  </span><br>        c = count.getAndDecrement();  <br>        <span class="hljs-comment">// 队列还有元素  </span><br>        <span class="hljs-keyword">if</span> (c &gt; <span class="hljs-number">1</span>)  <br>            <span class="hljs-comment">// 唤醒一个消费take线程  </span><br>            notEmpty.signal();  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        takeLock.unlock();  <br>    &#125;  <br>    <span class="hljs-comment">// c 是消费前的数据，消费前满了，消费一个后还剩一个空位，唤醒生产线程  </span><br>    <span class="hljs-keyword">if</span> (c == capacity)  <br>        <span class="hljs-comment">// 调用的是 notFull.signal() 而不是 notFull.signalAll() 是为了减少竞争  </span><br>        signalNotFull();  <br>    <span class="hljs-keyword">return</span> x;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h5 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h5><p>主要列举 LinkedBlockingQueue 与 ArrayBlockingQueue 的性能比较：</p><ul><li><p>Linked 支持有界，Array 强制有界</p></li><li><p>Linked 实现是链表，Array 实现是数组</p></li><li><p>Linked 是懒惰的，而 Array 需要提前初始化 Node 数组</p></li><li><p>Linked 每次入队会生成新 Node，而 Array 的 Node 是提前创建好的</p></li><li><p>Linked 两把锁，Array 一把锁</p></li></ul><hr><h4 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h4><h5 id="成员属性-1"><a href="#成员属性-1" class="headerlink" title="成员属性"></a>成员属性</h5><p>SynchronousQueue 是一个不存储元素的 BlockingQueue，<strong>每一个生产者必须阻塞匹配到一个消费者</strong></p><p>成员变量：</p><ul><li><p>运行当前程序的平台拥有 CPU 的数量：</p><p>  <code>static final int NCPUS = Runtime.getRuntime().availableProcessors()</code></p></li><li><p>指定超时时间后，当前线程最大自旋次数：</p><p>  &#x2F;&#x2F; 只有一个 CPU 时自旋次数为 0，所有程序都是串行执行，多核 CPU 时自旋 32 次是一个经验值<br>  <code>static final int maxTimedSpins = (NCPUS &lt; 2) ? 0 : 32;</code></p><p>  自旋的原因：线程挂起唤醒需要进行上下文切换，涉及到用户态和内核态的转变，是非常消耗资源的。自旋期间线程会一直检查自己的状态是否被匹配到，如果自旋期间被匹配到，那么直接就返回了，如果自旋次数达到某个指标后，还是会将当前线程挂起</p></li><li><p>未指定超时时间，当前线程最大自旋次数：</p><p>  <code>static final int maxUntimedSpins = maxTimedSpins * 16;// maxTimedSpins 的 16 倍</code></p></li><li><p>指定超时限制的阈值，小于该值的线程不会被挂起：</p><p>  <code>static final long spinForTimeoutThreshold = 1000L;// 纳秒</code></p><p>  超时时间设置的小于该值，就会被禁止挂起，阻塞再唤醒的成本太高，不如选择自旋空转</p></li><li><p>转换器：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Transferer&lt;E&gt; transferer;  <br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Transferer</span>&lt;E&gt; &#123;  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">    * 参数一：可以为 null，null 时表示这个请求是一个 REQUEST 类型的请求，反之是一个 DATA 类型的请求  </span><br><span class="hljs-comment">    * 参数二：如果为 true 表示指定了超时时间，如果为 false 表示不支持超时，会一直阻塞到匹配或者被打断  </span><br><span class="hljs-comment">    * 参数三：超时时间限制，单位是纳秒  </span><br><span class="hljs-comment">      </span><br><span class="hljs-comment">    * 返回值：返回值如果不为 null 表示匹配成功，DATA 类型的请求返回当前线程 put 的数据  </span><br><span class="hljs-comment">    *      如果返回 null，表示请求超时或被中断  </span><br><span class="hljs-comment">    */</span>  <br>    <span class="hljs-keyword">abstract</span> E <span class="hljs-title function_">transfer</span><span class="hljs-params">(E e, <span class="hljs-type">boolean</span> timed, <span class="hljs-type">long</span> nanos)</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>构造方法：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">SynchronousQueue</span><span class="hljs-params">(<span class="hljs-type">boolean</span> fair)</span> &#123;  <br>    <span class="hljs-comment">// fair 默认 false  </span><br>    <span class="hljs-comment">// 非公平模式实现的数据结构是栈，公平模式的数据结构是队列  </span><br>    transferer = fair ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransferQueue</span>&lt;E&gt;() : <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransferStack</span>&lt;E&gt;();  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>成员方法：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e)</span> &#123;  <br>    <span class="hljs-keyword">if</span> (e == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();  <br>    <span class="hljs-keyword">return</span> transferer.transfer(e, <span class="hljs-literal">true</span>, <span class="hljs-number">0</span>) != <span class="hljs-literal">null</span>;  <br>&#125;  <br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">return</span> transferer.transfer(<span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>, <span class="hljs-number">0</span>);  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h5 id="非公实现"><a href="#非公实现" class="headerlink" title="非公实现"></a>非公实现</h5><p>TransferStack 是非公平的同步队列，因为所有的请求都被压入栈中，栈顶的元素会最先得到匹配，造成栈底的等待线程饥饿</p><p>TransferStack 类成员变量：</p><ul><li><p>请求类型：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// 表示 Node 类型为请求类型  </span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">REQUEST</span>    <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br><span class="hljs-comment">// 表示 Node类 型为数据类型  </span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DATA</span>       <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;  <br><span class="hljs-comment">// 表示 Node 类型为匹配中类型  </span><br><span class="hljs-comment">// 假设栈顶元素为 REQUEST-NODE，当前请求类型为 DATA，入栈会修改类型为 FULFILLING 【栈顶 &amp; 栈顶之下的一个node】  </span><br><span class="hljs-comment">// 假设栈顶元素为 DATA-NODE，当前请求类型为 REQUEST，入栈会修改类型为 FULFILLING 【栈顶 &amp; 栈顶之下的一个node】  </span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">FULFILLING</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure></li><li><p>栈顶元素：</p><p>  <code>volatile SNode head;</code></p></li></ul><p>内部类 SNode：</p><ul><li><p>成员变量：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SNode</span> &#123;  <br>    <span class="hljs-comment">// 指向下一个栈帧  </span><br>    <span class="hljs-keyword">volatile</span> SNode next;   <br>    <span class="hljs-comment">// 与当前 node 匹配的节点  </span><br>    <span class="hljs-keyword">volatile</span> SNode match;  <br>    <span class="hljs-comment">// 假设当前node对应的线程自旋期间未被匹配成功，那么node对应的线程需要挂起，  </span><br>    <span class="hljs-comment">// 挂起前 waiter 保存对应的线程引用，方便匹配成功后，被唤醒。  </span><br>    <span class="hljs-keyword">volatile</span> Thread waiter;  <br>      <br>    <span class="hljs-comment">// 数据域，不为空表示当前 Node 对应的请求类型为 DATA 类型，反之则表示 Node 为 REQUEST 类型  </span><br>    Object item;   <br>    <span class="hljs-comment">// 表示当前Node的模式 【DATA/REQUEST/FULFILLING】  </span><br>    <span class="hljs-type">int</span> mode;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>构造方法：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><br>SNode(Object item) &#123;  <br>    <span class="hljs-built_in">this</span>.item = item;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>设置方法：设置 Node 对象的 next 字段，此处<strong>对 CAS 进行了优化</strong>，提升了 CAS 的效率</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">casNext</span><span class="hljs-params">(SNode cmp, SNode val)</span> &#123;  <br>    <span class="hljs-comment">//【优化：cmp == next】，可以提升一部分性能。 cmp == next 不相等，就没必要走 cas指令。  </span><br>    <span class="hljs-keyword">return</span> cmp == next &amp;&amp; UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, nextOffset, cmp, val);  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>匹配方法：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">tryMatch</span><span class="hljs-params">(SNode s)</span> &#123;  <br>    <span class="hljs-comment">// 当前 node 尚未与任何节点发生过匹配，CAS 设置 match 字段为 s 节点，表示当前 node 已经被匹配  </span><br>    <span class="hljs-keyword">if</span> (match == <span class="hljs-literal">null</span> &amp;&amp; UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, matchOffset, <span class="hljs-literal">null</span>, s)) &#123;  <br>        <span class="hljs-comment">// 当前 node 如果自旋结束，会 park 阻塞，阻塞前将 node 对应的 Thread 保留到 waiter 字段  </span><br>        <span class="hljs-comment">// 获取当前 node 对应的阻塞线程  </span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> waiter;  <br>        <span class="hljs-comment">// 条件成立说明 node 对应的 Thread 正在阻塞  </span><br>        <span class="hljs-keyword">if</span> (w != <span class="hljs-literal">null</span>) &#123;  <br>            waiter = <span class="hljs-literal">null</span>;  <br>            <span class="hljs-comment">// 使用 unpark 方式唤醒线程  </span><br>            LockSupport.unpark(w);  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    &#125;  <br>    <span class="hljs-comment">// 匹配成功返回 true  </span><br>    <span class="hljs-keyword">return</span> match == s;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>取消方法：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// 取消节点的方法  </span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">tryCancel</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">// match 字段指向自己，表示这个 node 是取消状态，取消状态的 node，最终会被强制移除出栈  </span><br>    UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, matchOffset, <span class="hljs-literal">null</span>, <span class="hljs-built_in">this</span>);  <br>&#125;  <br>  <br><span class="hljs-type">boolean</span> <span class="hljs-title function_">isCancelled</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">return</span> match == <span class="hljs-built_in">this</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>TransferStack 类成员方法：</p><ul><li><p>snode()：填充节点方法</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">static</span> SNode <span class="hljs-title function_">snode</span><span class="hljs-params">(SNode s, Object e, SNode next, <span class="hljs-type">int</span> mode)</span> &#123;  <br>    <span class="hljs-comment">// 引用指向空时，snode 方法会创建一个 SNode 对象   </span><br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span>) s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SNode</span>(e);  <br>    <span class="hljs-comment">// 填充数据  </span><br>    s.mode = mode;  <br>    s.next = next;  <br>    <span class="hljs-keyword">return</span> s;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>transfer()：核心方法，请求匹配出栈，不匹配阻塞</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs java"><br>E <span class="hljs-title function_">transfer</span><span class="hljs-params">(E e, <span class="hljs-type">boolean</span> timed, <span class="hljs-type">long</span> nanos)</span> &#123;  <br><span class="hljs-comment">// 包装当前线程的 node  </span><br>    <span class="hljs-type">SNode</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;  <br>    <span class="hljs-comment">// 根据元素判断当前的请求类型  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">mode</span> <span class="hljs-operator">=</span> (e == <span class="hljs-literal">null</span>) ? REQUEST : DATA;  <br><span class="hljs-comment">// 自旋  </span><br>    <span class="hljs-keyword">for</span> (;;) &#123;  <br>        <span class="hljs-comment">// 获取栈顶指针  </span><br>        <span class="hljs-type">SNode</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;  <br>       <span class="hljs-comment">// 【CASE1】：当前栈为空或者栈顶 node 模式与当前请求模式一致无法匹配，做入栈操作  </span><br>        <span class="hljs-keyword">if</span> (h == <span class="hljs-literal">null</span> || h.mode == mode) &#123;  <br>            <span class="hljs-comment">// 当前请求是支持超时的，但是 nanos &lt;= 0 说明这个请求不支持 “阻塞等待”  </span><br>            <span class="hljs-keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="hljs-number">0</span>) &#123;   <br>                <span class="hljs-comment">// 栈顶元素是取消状态  </span><br>                <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h.isCancelled())  <br>                    <span class="hljs-comment">// 栈顶出栈，设置新的栈顶  </span><br>                    casHead(h, h.next);  <br>                <span class="hljs-keyword">else</span>  <br>                    <span class="hljs-comment">// 表示【匹配失败】  </span><br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>            <span class="hljs-comment">// 入栈  </span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (casHead(h, s = snode(s, e, h, mode))) &#123;  <br>                <span class="hljs-comment">// 等待被匹配的逻辑，正常情况返回匹配的节点；取消情况返回当前节点，就是 s  </span><br>                <span class="hljs-type">SNode</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> awaitFulfill(s, timed, nanos);  <br>                <span class="hljs-comment">// 说明当前 node 是【取消状态】  </span><br>                <span class="hljs-keyword">if</span> (m == s) &#123;   <br>                    <span class="hljs-comment">// 将取消节点出栈  </span><br>                    clean(s);  <br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>                &#125;  <br>                <span class="hljs-comment">// 执行到这说明【匹配成功】了  </span><br>                <span class="hljs-comment">// 栈顶有节点并且 匹配节点还未出栈，需要协助出栈  </span><br>                <span class="hljs-keyword">if</span> ((h = head) != <span class="hljs-literal">null</span> &amp;&amp; h.next == s)  <br>                    casHead(h, s.next);  <br>                <span class="hljs-comment">// 当前 node 模式为 REQUEST 类型，返回匹配节点的 m.item 数据域  </span><br>                <span class="hljs-comment">// 当前 node 模式为 DATA 类型：返回 node.item 数据域，当前请求提交的数据 e  </span><br>                <span class="hljs-keyword">return</span> (E) ((mode == REQUEST) ? m.item : s.item);  <br>            &#125;  <br>        <span class="hljs-comment">// 【CASE2】：逻辑到这说明请求模式不一致，如果栈顶不是 FULFILLING 说明没被其他节点匹配，【当前可以匹配】  </span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!isFulfilling(h.mode)) &#123;  <br>            <span class="hljs-comment">// 头节点是取消节点，match 指向自己，协助出栈  </span><br>            <span class="hljs-keyword">if</span> (h.isCancelled())  <br>                casHead(h, h.next);  <br>            <span class="hljs-comment">// 入栈当前请求的节点  </span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (casHead(h, s=snode(s, e, h, FULFILLING|mode))) &#123;  <br>                <span class="hljs-keyword">for</span> (;;) &#123;   <br>                    <span class="hljs-comment">// m 是 s 的匹配的节点  </span><br>                    <span class="hljs-type">SNode</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> s.next;  <br>                    <span class="hljs-comment">// m 节点在 awaitFulfill 方法中被中断，clean 了自己  </span><br>                    <span class="hljs-keyword">if</span> (m == <span class="hljs-literal">null</span>) &#123;  <br>                        <span class="hljs-comment">// 清空栈  </span><br>                        casHead(s, <span class="hljs-literal">null</span>);  <br>                        s = <span class="hljs-literal">null</span>;  <br>                        <span class="hljs-comment">// 返回到外层自旋中  </span><br>                        <span class="hljs-keyword">break</span>;  <br>                    &#125;  <br>                    <span class="hljs-comment">// 获取匹配节点的下一个节点  </span><br>                    <span class="hljs-type">SNode</span> <span class="hljs-variable">mn</span> <span class="hljs-operator">=</span> m.next;  <br>                    <span class="hljs-comment">// 尝试匹配，【匹配成功】，则将 fulfilling 和 m 一起出栈，并且唤醒被匹配的节点的线程  </span><br>                    <span class="hljs-keyword">if</span> (m.tryMatch(s)) &#123;  <br>                        casHead(s, mn);  <br>                        <span class="hljs-keyword">return</span> (E) ((mode == REQUEST) ? m.item : s.item);  <br>                    &#125; <span class="hljs-keyword">else</span>  <br>                        <span class="hljs-comment">// 匹配失败，出栈 m  </span><br>                        s.casNext(m, mn);  <br>                &#125;  <br>            &#125;  <br>        <span class="hljs-comment">// 【CASE3】：栈顶模式为 FULFILLING 模式，表示【栈顶和栈顶下面的节点正在发生匹配】，当前请求需要做协助工作  </span><br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            <span class="hljs-comment">// h 表示的是 fulfilling 节点，m 表示 fulfilling 匹配的节点  </span><br>            <span class="hljs-type">SNode</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> h.next;  <br>            <span class="hljs-keyword">if</span> (m == <span class="hljs-literal">null</span>)  <br>                <span class="hljs-comment">// 清空栈  </span><br>                casHead(h, <span class="hljs-literal">null</span>);  <br>            <span class="hljs-keyword">else</span> &#123;  <br>                <span class="hljs-type">SNode</span> <span class="hljs-variable">mn</span> <span class="hljs-operator">=</span> m.next;  <br>                <span class="hljs-comment">// m 和 h 匹配，唤醒 m 中的线程  </span><br>                <span class="hljs-keyword">if</span> (m.tryMatch(h))  <br>                    casHead(h, mn);  <br>                <span class="hljs-keyword">else</span>  <br>                    h.casNext(m, mn);  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>awaitFulfill()：阻塞当前线程等待被匹配，返回匹配的节点，或者被取消的节点</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><br>SNode <span class="hljs-title function_">awaitFulfill</span><span class="hljs-params">(SNode s, <span class="hljs-type">boolean</span> timed, <span class="hljs-type">long</span> nanos)</span> &#123;  <br>    <span class="hljs-comment">// 等待的截止时间  </span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> timed ? System.nanoTime() + nanos : <span class="hljs-number">0L</span>;  <br>    <span class="hljs-comment">// 当前线程  </span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> Thread.currentThread();  <br>    <span class="hljs-comment">// 表示当前请求线程在下面的 for(;;) 自旋检查的次数  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">spins</span> <span class="hljs-operator">=</span> (shouldSpin(s) ? (timed ? maxTimedSpins : maxUntimedSpins) : <span class="hljs-number">0</span>);  <br>    <span class="hljs-comment">// 自旋检查逻辑：是否匹配、是否超时、是否被中断  </span><br>    <span class="hljs-keyword">for</span> (;;) &#123;  <br>        <span class="hljs-comment">// 当前线程收到中断信号，需要设置 node 状态为取消状态  </span><br>        <span class="hljs-keyword">if</span> (w.isInterrupted())  <br>            s.tryCancel();  <br>        <span class="hljs-comment">// 获取与当前 s 匹配的节点  </span><br>        <span class="hljs-type">SNode</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> s.match;  <br>        <span class="hljs-keyword">if</span> (m != <span class="hljs-literal">null</span>)  <br>            <span class="hljs-comment">// 可能是正常的匹配的，也可能是取消的  </span><br>            <span class="hljs-keyword">return</span> m;  <br>        <span class="hljs-comment">// 执行了超时限制就判断是否超时  </span><br>        <span class="hljs-keyword">if</span> (timed) &#123;  <br>            nanos = deadline - System.nanoTime();  <br>            <span class="hljs-comment">// 【超时了，取消节点】  </span><br>            <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0L</span>) &#123;  <br>                s.tryCancel();  <br>                <span class="hljs-keyword">continue</span>;  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-comment">// 说明当前线程还可以进行自旋检查  </span><br>        <span class="hljs-keyword">if</span> (spins &gt; <span class="hljs-number">0</span>)  <br>            <span class="hljs-comment">// 自旋一次 递减 1  </span><br>            spins = shouldSpin(s) ? (spins - <span class="hljs-number">1</span>) : <span class="hljs-number">0</span>;  <br>        <span class="hljs-comment">// 说明没有自旋次数了  </span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.waiter == <span class="hljs-literal">null</span>)  <br>            <span class="hljs-comment">//【把当前 node 对应的 Thread 保存到 node.waiter 字段中，要阻塞了】  </span><br>            s.waiter = w;  <br>        <span class="hljs-comment">// 没有超时限制直接阻塞  </span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!timed)  <br>            LockSupport.park(<span class="hljs-built_in">this</span>);  <br>        <span class="hljs-comment">// nanos &gt; 1000 纳秒的情况下，才允许挂起当前线程  </span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nanos &gt; spinForTimeoutThreshold)  <br>            LockSupport.parkNanos(<span class="hljs-built_in">this</span>, nanos);  <br>    &#125;  <br>&#125;<br><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">shouldSpin</span><span class="hljs-params">(SNode s)</span> &#123;  <br>    <span class="hljs-comment">// 获取栈顶  </span><br>    <span class="hljs-type">SNode</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;  <br>    <span class="hljs-comment">// 条件一成立说明当前 s 就是栈顶，允许自旋检查  </span><br>    <span class="hljs-comment">// 条件二成立说明当前 s 节点自旋检查期间，又来了一个与当前 s 节点匹配的请求，双双出栈后条件会成立  </span><br>    <span class="hljs-comment">// 条件三成立前提当前 s 不是栈顶元素，并且当前栈顶正在匹配中，这种状态栈顶下面的元素，都允许自旋检查  </span><br>    <span class="hljs-keyword">return</span> (h == s || h == <span class="hljs-literal">null</span> || isFulfilling(h.mode));  <br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>clear()：指定节点出栈</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">clean</span><span class="hljs-params">(SNode s)</span> &#123;  <br>    <span class="hljs-comment">// 清空数据域和关联线程  </span><br>    s.item = <span class="hljs-literal">null</span>;  <br>    s.waiter = <span class="hljs-literal">null</span>;  <br>      <br><span class="hljs-comment">// 获取取消节点的下一个节点  </span><br>    <span class="hljs-type">SNode</span> <span class="hljs-variable">past</span> <span class="hljs-operator">=</span> s.next;  <br>    <span class="hljs-comment">// 判断后继节点是不是取消节点，是就更新 past  </span><br>    <span class="hljs-keyword">if</span> (past != <span class="hljs-literal">null</span> &amp;&amp; past.isCancelled())  <br>        past = past.next;  <br>  <br>    SNode p;  <br>    <span class="hljs-comment">// 从栈顶开始向下检查，【将栈顶开始向下的 取消状态 的节点全部清理出去】，直到碰到 past 或者不是取消状态为止  </span><br>    <span class="hljs-keyword">while</span> ((p = head) != <span class="hljs-literal">null</span> &amp;&amp; p != past &amp;&amp; p.isCancelled())  <br>        <span class="hljs-comment">// 修改的是内存地址对应的值，p 指向该内存地址所以数据一直在变化  </span><br>        casHead(p, p.next);  <br><span class="hljs-comment">// 说明中间遇到了不是取消状态的节点，继续迭代下去  </span><br>    <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span> &amp;&amp; p != past) &#123;  <br>        <span class="hljs-type">SNode</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> p.next;  <br>        <span class="hljs-keyword">if</span> (n != <span class="hljs-literal">null</span> &amp;&amp; n.isCancelled())  <br>            p.casNext(n, n.next);  <br>        <span class="hljs-keyword">else</span>  <br>            p = n;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h5 id="公平实现"><a href="#公平实现" class="headerlink" title="公平实现"></a>公平实现</h5><p>TransferQueue 是公平的同步队列，采用 FIFO 的队列实现，请求节点与队尾模式不同，需要与队头发生匹配</p><p>TransferQueue 类成员变量：</p><ul><li><p>指向队列的 dummy 节点：</p><p>  <code>transient volatile QNode head;</code></p></li><li><p>指向队列的尾节点：</p><p>  <code>transient volatile QNode tail;</code></p></li><li><p>被清理节点的前驱节点：</p><p>  <code>transient volatile QNode cleanMe;</code></p><p>  入队操作是两步完成的，第一步是 t.next &#x3D; newNode，第二步是 tail &#x3D; newNode，所以队尾节点出队，是一种非常特殊的情况</p></li></ul><p>TransferQueue 内部类：</p><ul><li>QNode：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">QNode</span> &#123;  <br>    <span class="hljs-comment">// 指向当前节点的下一个节点  </span><br>    <span class="hljs-keyword">volatile</span> QNode next;  <br>    <span class="hljs-comment">// 数据域，Node 代表的是 DATA 类型 item 表示数据，否则 Node 代表的 REQUEST 类型，item == null  </span><br>    <span class="hljs-keyword">volatile</span> Object item;  <br>    <span class="hljs-comment">// 假设当前 node 对应的线程自旋期间未被匹配成功，那么 node 对应的线程需要挂起，  </span><br>    <span class="hljs-comment">// 挂起前 waiter 保存对应的线程引用，方便匹配成功后被唤醒。  </span><br>    <span class="hljs-keyword">volatile</span> Thread waiter;  <br>    <span class="hljs-comment">// true 当前 Node 是一个 DATA 类型，false 表示当前 Node 是一个 REQUEST 类型  </span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> isData;  <br>  <br><span class="hljs-comment">// 构建方法  </span><br>    QNode(Object item, <span class="hljs-type">boolean</span> isData) &#123;  <br>        <span class="hljs-built_in">this</span>.item = item;  <br>        <span class="hljs-built_in">this</span>.isData = isData;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 尝试取消当前 node，取消状态的 node 的 item 域指向自己  </span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">tryCancel</span><span class="hljs-params">(Object cmp)</span> &#123;  <br>        UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, itemOffset, cmp, <span class="hljs-built_in">this</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 判断当前 node 是否为取消状态  </span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isCancelled</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> item == <span class="hljs-built_in">this</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 判断当前节点是否 “不在” 队列内，当 next 指向自己时，说明节点已经出队。  </span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isOffList</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> next == <span class="hljs-built_in">this</span>;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>TransferQueue 类成员方法：</p><ul><li><p>设置头尾节点：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">advanceHead</span><span class="hljs-params">(QNode h, QNode nh)</span> &#123;  <br>    <span class="hljs-comment">// 设置头指针指向新的节点，  </span><br>    <span class="hljs-keyword">if</span> (h == head &amp;&amp; UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, headOffset, h, nh))  <br>        <span class="hljs-comment">// 老的头节点出队  </span><br>        h.next = h;  <br>&#125;  <br><span class="hljs-keyword">void</span> <span class="hljs-title function_">advanceTail</span><span class="hljs-params">(QNode t, QNode nt)</span> &#123;  <br>    <span class="hljs-keyword">if</span> (tail == t)  <br>        <span class="hljs-comment">// 更新队尾节点为新的队尾  </span><br>        UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, tailOffset, t, nt);  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>transfer()：核心方法</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java"><br>E <span class="hljs-title function_">transfer</span><span class="hljs-params">(E e, <span class="hljs-type">boolean</span> timed, <span class="hljs-type">long</span> nanos)</span> &#123;  <br>    <span class="hljs-comment">// s 指向当前请求对应的 node  </span><br>    <span class="hljs-type">QNode</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;  <br>    <span class="hljs-comment">// 是否是 DATA 类型的请求  </span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">isData</span> <span class="hljs-operator">=</span> (e != <span class="hljs-literal">null</span>);  <br><span class="hljs-comment">// 自旋  </span><br>    <span class="hljs-keyword">for</span> (;;) &#123;  <br>        <span class="hljs-type">QNode</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail;  <br>        <span class="hljs-type">QNode</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;  <br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span> || h == <span class="hljs-literal">null</span>)  <br>            <span class="hljs-keyword">continue</span>;  <br><span class="hljs-comment">// head 和 tail 同时指向 dummy 节点，说明是空队列  </span><br>        <span class="hljs-comment">// 队尾节点与当前请求类型是一致的情况，说明阻塞队列中都无法匹配，  </span><br>        <span class="hljs-keyword">if</span> (h == t || t.isData == isData) &#123;  <br>            <span class="hljs-comment">// 获取队尾 t 的 next 节点  </span><br>            <span class="hljs-type">QNode</span> <span class="hljs-variable">tn</span> <span class="hljs-operator">=</span> t.next;  <br>            <span class="hljs-comment">// 多线程环境中其他线程可能修改尾节点  </span><br>            <span class="hljs-keyword">if</span> (t != tail)  <br>                <span class="hljs-keyword">continue</span>;  <br>            <span class="hljs-comment">// 已经有线程入队了，更新 tail  </span><br>            <span class="hljs-keyword">if</span> (tn != <span class="hljs-literal">null</span>) &#123;  <br>                advanceTail(t, tn);  <br>                <span class="hljs-keyword">continue</span>;  <br>            &#125;  <br>            <span class="hljs-comment">// 允许超时，超时时间小于 0，这种方法不支持阻塞等待  </span><br>            <span class="hljs-keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="hljs-number">0</span>)  <br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>            <span class="hljs-comment">// 创建 node 的逻辑  </span><br>            <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span>)  <br>                s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QNode</span>(e, isData);  <br>            <span class="hljs-comment">// 将 node 添加到队尾  </span><br>            <span class="hljs-keyword">if</span> (!t.casNext(<span class="hljs-literal">null</span>, s))  <br>                <span class="hljs-keyword">continue</span>;  <br><span class="hljs-comment">// 更新队尾指针  </span><br>            advanceTail(t, s);  <br>              <br>            <span class="hljs-comment">// 当前节点 等待匹配....  </span><br>            <span class="hljs-type">Object</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> awaitFulfill(s, e, timed, nanos);  <br>              <br>            <span class="hljs-comment">// 说明【当前 node 状态为 取消状态】，需要做出队逻辑  </span><br>            <span class="hljs-keyword">if</span> (x == s) &#123;  <br>                clean(t, s);  <br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>            &#125;  <br><span class="hljs-comment">// 说明当前 node 仍然在队列内，匹配成功，需要做出队逻辑  </span><br>            <span class="hljs-keyword">if</span> (!s.isOffList()) &#123;  <br>                <span class="hljs-comment">// t 是当前 s 节点的前驱节点，判断 t 是不是头节点，是就更新 dummy 节点为 s 节点  </span><br>                advanceHead(t, s);  <br>                <span class="hljs-comment">// s 节点已经出队，所以需要把它的 item 域设置为它自己，表示它是个取消状态  </span><br>                <span class="hljs-keyword">if</span> (x != <span class="hljs-literal">null</span>)  <br>                    s.item = s;  <br>                s.waiter = <span class="hljs-literal">null</span>;  <br>            &#125;  <br>            <span class="hljs-keyword">return</span> (x != <span class="hljs-literal">null</span>) ? (E)x : e;  <br><span class="hljs-comment">// 队尾节点与当前请求节点【互补匹配】  </span><br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            <span class="hljs-comment">// h.next 节点，【请求节点与队尾模式不同，需要与队头发生匹配】，TransferQueue 是一个【公平模式】  </span><br>            <span class="hljs-type">QNode</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> h.next;  <br>            <span class="hljs-comment">// 并发导致其他线程修改了队尾节点，或者已经把 head.next 匹配走了  </span><br>            <span class="hljs-keyword">if</span> (t != tail || m == <span class="hljs-literal">null</span> || h != head)  <br>                <span class="hljs-keyword">continue</span>;  <br><span class="hljs-comment">// 获取匹配节点的数据域保存到 x  </span><br>            <span class="hljs-type">Object</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> m.item;  <br>            <span class="hljs-comment">// 判断是否匹配成功  </span><br>            <span class="hljs-keyword">if</span> (isData == (x != <span class="hljs-literal">null</span>) ||  <br>                x == m ||  <br>                !m.casItem(x, e)) &#123;  <br>                advanceHead(h, m);  <br>                <span class="hljs-keyword">continue</span>;  <br>            &#125;  <br><span class="hljs-comment">// 【匹配完成】，将头节点出队，让这个新的头结点成为 dummy 节点  </span><br>            advanceHead(h, m);  <br>            <span class="hljs-comment">// 唤醒该匹配节点的线程  </span><br>            LockSupport.unpark(m.waiter);  <br>            <span class="hljs-keyword">return</span> (x != <span class="hljs-literal">null</span>) ? (E)x : e;  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>awaitFulfill()：阻塞当前线程等待被匹配</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><br>Object <span class="hljs-title function_">awaitFulfill</span><span class="hljs-params">(QNode s, E e, <span class="hljs-type">boolean</span> timed, <span class="hljs-type">long</span> nanos)</span> &#123;  <br>    <span class="hljs-comment">// 表示等待截止时间  </span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> timed ? System.nanoTime() + nanos : <span class="hljs-number">0L</span>;  <br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> Thread.currentThread();  <br>    <span class="hljs-comment">// 自选检查的次数  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">spins</span> <span class="hljs-operator">=</span> ((head.next == s) ? (timed ? maxTimedSpins : maxUntimedSpins) : <span class="hljs-number">0</span>);  <br>    <span class="hljs-keyword">for</span> (;;) &#123;  <br>        <span class="hljs-comment">// 被打断就取消节点  </span><br>        <span class="hljs-keyword">if</span> (w.isInterrupted())  <br>            s.tryCancel(e);  <br>        <span class="hljs-comment">// 获取当前 Node 数据域  </span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> s.item;  <br>          <br>        <span class="hljs-comment">// 当前请求为 DATA 模式时：e 请求带来的数据  </span><br>        <span class="hljs-comment">// s.item 修改为 this，说明当前 QNode 对应的线程 取消状态  </span><br>        <span class="hljs-comment">// s.item 修改为 null 表示已经有匹配节点了，并且匹配节点拿走了 item 数据  </span><br>  <br>        <span class="hljs-comment">// 当前请求为 REQUEST 模式时：e == null  </span><br>        <span class="hljs-comment">// s.item 修改为 this，说明当前 QNode 对应的线程 取消状态  </span><br>        <span class="hljs-comment">// s.item != null 且 item != this  表示当前 REQUEST 类型的 Node 已经匹配到 DATA 了   </span><br>        <span class="hljs-keyword">if</span> (x != e)  <br>            <span class="hljs-keyword">return</span> x;  <br>        <span class="hljs-comment">// 超时检查  </span><br>        <span class="hljs-keyword">if</span> (timed) &#123;  <br>            nanos = deadline - System.nanoTime();  <br>            <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0L</span>) &#123;  <br>                s.tryCancel(e);  <br>                <span class="hljs-keyword">continue</span>;  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-comment">// 自旋次数减一  </span><br>        <span class="hljs-keyword">if</span> (spins &gt; <span class="hljs-number">0</span>)  <br>            --spins;  <br>        <span class="hljs-comment">// 没有自旋次数了，把当前线程封装进去 waiter  </span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.waiter == <span class="hljs-literal">null</span>)  <br>            s.waiter = w;  <br>        <span class="hljs-comment">// 阻塞  </span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!timed)  <br>            LockSupport.park(<span class="hljs-built_in">this</span>);  <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nanos &gt; spinForTimeoutThreshold)  <br>            LockSupport.parkNanos(<span class="hljs-built_in">this</span>, nanos);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><p>TODO HERE</p><h3 id="操作Pool"><a href="#操作Pool" class="headerlink" title="操作Pool"></a>操作Pool</h3><h4 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h4><h5 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h5><p>存放线程的容器：</p><p><code>private final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;();</code></p><p>构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,  </span><br><span class="hljs-params">                          <span class="hljs-type">int</span> maximumPoolSize,  </span><br><span class="hljs-params">                          <span class="hljs-type">long</span> keepAliveTime,  </span><br><span class="hljs-params">                          TimeUnit unit,  </span><br><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue,  </span><br><span class="hljs-params">                          ThreadFactory threadFactory,  </span><br><span class="hljs-params">                          RejectedExecutionHandler handler)</span><br></code></pre></td></tr></table></figure><p>参数介绍：</p><ul><li><p>corePoolSize：核心线程数，定义了最小可以同时运行的线程数量</p></li><li><p>maximumPoolSize：最大线程数，当队列中存放的任务达到队列容量时，当前可以同时运行的数量变为最大线程数，创建线程并立即执行最新的任务，与核心线程数之间的差值又叫救急线程数</p></li><li><p>keepAliveTime：救急线程最大存活时间，当线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等到 <code>keepAliveTime</code> 时间超过销毁</p></li><li><p>unit：<code>keepAliveTime</code> 参数的时间单位</p></li><li><p>workQueue：阻塞队列，存放被提交但尚未被执行的任务</p></li><li><p>threadFactory：线程工厂，创建新线程时用到，可以为线程创建时起名字</p></li><li><p>handler：拒绝策略，线程到达最大线程数仍有新任务时会执行拒绝策略</p><p>  RejectedExecutionHandler 下有 4 个实现类：</p><ul><li><p>AbortPolicy：让调用者抛出 RejectedExecutionException 异常，<strong>默认策略</strong></p></li><li><p>CallerRunsPolicy：让调用者运行的调节机制，将某些任务回退到调用者，从而降低新任务的流量</p></li><li><p>DiscardPolicy：直接丢弃任务，不予任何处理也不抛出异常</p></li><li><p>DiscardOldestPolicy：放弃队列中最早的任务，把当前任务加入队列中尝试再次提交当前任务</p></li></ul><p>  补充：其他框架拒绝策略</p><ul><li><p>Dubbo：在抛出 RejectedExecutionException 异常前记录日志，并 dump 线程栈信息，方便定位问题</p></li><li><p>Netty：创建一个新线程来执行任务</p></li><li><p>ActiveMQ：带超时等待（60s）尝试放入队列</p></li><li><p>PinPoint：它使用了一个拒绝策略链，会逐一尝试策略链中每种拒绝策略</p></li></ul></li></ul><p>工作原理：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041808994.png"></p><ol><li><p>创建线程池，这时没有创建线程（<strong>懒惰</strong>），等待提交过来的任务请求，调用 execute 方法才会创建线程</p></li><li><p>当调用 execute() 方法添加一个请求任务时，线程池会做如下判断：</p><ul><li><p>如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务</p></li><li><p>如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列</p></li><li><p>如果这时队列满了且正在运行的线程数量还小于 maximumPoolSize，那么会创建非核心线程<strong>立刻运行这个任务</strong>，对于阻塞队列中的任务不公平。这是因为创建每个 Worker（线程）对象会绑定一个初始任务，启动 Worker 时会优先执行</p></li><li><p>如果队列满了且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会启动饱和<strong>拒绝策略</strong>来执行</p></li></ul></li><li><p>当一个线程完成任务时，会从队列中取下一个任务来执行</p></li><li><p>当一个线程空闲超过一定的时间（keepAliveTime）时，线程池会判断：如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉，所以线程池的所有任务完成后最终会收缩到 corePoolSize 大小</p></li></ol><hr><h5 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h5><p>Executors 提供了四种线程池的创建：newCachedThreadPool、newFixedThreadPool、newSingleThreadExecutor、newScheduledThreadPool</p><ul><li><p>newFixedThreadPool：创建一个拥有 n 个线程的线程池</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> nThreads)</span> &#123;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(nThreads, nThreads, <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,  <br>                                  <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>核心线程数 &#x3D;&#x3D; 最大线程数（没有救急线程被创建），因此也无需超时时间</p></li><li><p>LinkedBlockingQueue 是一个单向链表实现的阻塞队列，默认大小为 <code>Integer.MAX_VALUE</code>，也就是无界队列，可以放任意数量的任务，在任务比较多的时候会导致 OOM（内存溢出）</p></li><li><p>适用于任务量已知，相对耗时的长期任务</p></li></ul></li><li><p>newCachedThreadPool：创建一个可扩容的线程池</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newCachedThreadPool</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">0</span>, Integer.MAX_VALUE, <span class="hljs-number">60L</span>, TimeUnit.SECONDS,  <br>                                  <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;Runnable&gt;());  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>核心线程数是 0， 最大线程数是 29 个 1，全部都是救急线程（60s 后可以回收），可能会创建大量线程，从而导致 <strong>OOM</strong></p></li><li><p>SynchronousQueue 作为阻塞队列，没有容量，对于每一个 take 的线程会阻塞直到有一个 put 的线程放入元素为止（类似一手交钱、一手交货）</p></li><li><p>适合任务数比较密集，但每个任务执行时间较短的情况</p></li></ul></li><li><p>newSingleThreadExecutor：创建一个只有 1 个线程的单线程池</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newSingleThreadExecutor</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FinalizableDelegatedExecutorService</span>  <br>        (<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,  <br>                                <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>保证所有任务按照<strong>指定顺序执行</strong>，线程数固定为 1，任务数多于 1 时会放入无界队列排队，任务执行完毕，这唯一的线程也不会被释放</li></ul></li></ul><p>对比：</p><ul><li><p>创建一个单线程串行执行任务，如果任务执行失败而终止那么没有任何补救措施，线程池会新建一个线程，保证池的正常工作</p></li><li><p>Executors.newSingleThreadExecutor() 线程个数始终为 1，不能修改。FinalizableDelegatedExecutorService 应用的是装饰器模式，只对外暴露了 ExecutorService 接口，因此不能调用 ThreadPoolExecutor 中特有的方法</p><p>  原因：父类不能直接调用子类中的方法，需要反射或者创建对象的方式，可以调用子类静态方法</p></li><li><p>Executors.newFixedThreadPool(1) 初始时为 1，可以修改。对外暴露的是 ThreadPoolExecutor 对象，可以强转后调用 setCorePoolSize 等方法进行修改</p></li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041812233.png"></p><hr><h5 id="开发要求"><a href="#开发要求" class="headerlink" title="开发要求"></a>开发要求</h5><p>阿里巴巴 Java 开发手册要求：</p><ul><li><p><strong>线程资源必须通过线程池提供，不允许在应用中自行显式创建线程</strong></p><ul><li><p>使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源的开销，解决资源不足的问题</p></li><li><p>如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者过度切换的问题</p></li></ul></li><li><p>线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式更加明确线程池的运行规则，规避资源耗尽的风险</p><p>  Executors 返回的线程池对象弊端如下：</p><ul><li><p>FixedThreadPool 和 SingleThreadPool：请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM</p></li><li><p>CacheThreadPool 和 ScheduledThreadPool：允许创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，导致 OOM</p></li></ul></li></ul><p>创建多大容量的线程池合适？</p><ul><li><p>一般来说池中<strong>总线程数是核心池线程数量两倍</strong>，确保当核心池有线程停止时，核心池外有线程进入核心池</p></li><li><p>过小会导致程序不能充分地利用系统资源、容易导致饥饿</p></li><li><p>过大会导致更多的线程上下文切换，占用更多内存</p><p>  上下文切换：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态，任务从保存到再加载的过程就是一次上下文切换</p></li></ul><p>核心线程数常用公式：</p><ul><li><p><strong>CPU 密集型任务 (N+1)：</strong> 这种任务消耗的是 CPU 资源，可以将核心线程数设置为 N (CPU 核心数) + 1，比 CPU 核心数多出来的一个线程是为了防止线程发生缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 某个核心就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间</p><p>  CPU 密集型简单理解就是利用 CPU 计算能力的任务比如在内存中对大量数据进行分析</p></li><li><p><strong>I&#x2F;O 密集型任务：</strong> 这种系统 CPU 处于阻塞状态，用大部分的时间来处理 I&#x2F;O 交互，而线程在处理 I&#x2F;O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用，因此在 I&#x2F;O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N 或 CPU 核数&#x2F; (1-阻塞系数)，阻塞系数在 0.8~0.9 之间</p><p>  IO 密集型就是涉及到网络读取，文件读取此类任务 ，特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上</p></li></ul><hr><h4 id="提交方法"><a href="#提交方法" class="headerlink" title="提交方法"></a>提交方法</h4><p>ExecutorService 类 API：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//执行任务（Executor 类 API）</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> <br><br><span class="hljs-comment">//提交任务 task()</span><br>Future&lt; ?&gt; submit(Runnable task) <br><br><span class="hljs-comment">//提交任务 task，用返回值 Future 获得任务执行结果</span><br>Future <span class="hljs-title function_">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span> <br><br><span class="hljs-comment">//提交 tasks 中所有任务</span><br>List&lt;Future&lt;T&gt;&gt; <span class="hljs-title function_">invokeAll</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span> <br><br><span class="hljs-comment">//提交 tasks 中所有任务，超时时间针对所有task，超时会取消没有执行完的任务，并抛出超时异常</span><br>List&lt;Future&lt;T&gt;&gt; <span class="hljs-title function_">invokeAll</span><span class="hljs-params">(Collection&lt; ? extends Callable&lt;T&gt;&gt; tasks, <span class="hljs-type">long</span> timeout, TimeUnit unit)</span> <br><br><span class="hljs-comment">//提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消</span><br>T <span class="hljs-title function_">invokeAny</span><span class="hljs-params">(Collection&lt; ? extends Callable&lt;T&gt;&gt; tasks)</span> <br></code></pre></td></tr></table></figure><p>execute 和 submit 都属于线程池的方法，对比：</p><ul><li><p>execute 只能执行 Runnable 类型的任务，没有返回值； submit 既能提交 Runnable 类型任务也能提交 Callable 类型任务，底层是<strong>封装成 FutureTask，然后调用 execute 执行</strong></p></li><li><p>execute 会直接抛出任务执行时的异常，submit 会吞掉异常，可通过 Future 的 get 方法将任务执行时的异常重新抛出</p></li></ul><hr><h4 id="关闭方法"><a href="#关闭方法" class="headerlink" title="关闭方法"></a>关闭方法</h4><p>ExecutorService 类 API：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">//线程池状态变为 SHUTDOWN，等待任务执行完后关闭线程池，不会接收新任务，但已提交任务会执行完，而且也可以添加线程（不绑定任务）</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">()</span><br><br><span class="hljs-comment">//线程池状态变为 STOP，用 interrupt 中断正在执行的任务，直接关闭线程池，不会接收新任务，会将队列中的任务返回</span><br>List&lt;Runnable&gt; <span class="hljs-title function_">shutdownNow</span><span class="hljs-params">()</span><br><br><span class="hljs-comment">//不在 RUNNING 状态的线程池，此执行者已被关闭，方法返回 true</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">isShutdown</span><span class="hljs-params">()</span><br><br><span class="hljs-comment">//线程池状态是否是 TERMINATED，如果所有任务在关闭后完成，返回 true</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">isTerminated</span><span class="hljs-params">()</span><br><br><span class="hljs-comment">//调用 shutdown 后，由于调用线程不会等待所有任务运行结束，如果它想在线程池 TERMINATED 后做些事情，可以利用此方法等待</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">awaitTermination</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br><br></code></pre></td></tr></table></figure><hr><h4 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h4><p>execute 会直接抛出任务执行时的异常，submit 会吞掉异常，有两种处理方法</p><p>方法 1：主动捉异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">1</span>);  <br>pool.submit(() -&gt; &#123;  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;task1&quot;</span>);  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> / <span class="hljs-number">0</span>;  <br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;  <br>        e.printStackTrace();  <br>    &#125;  <br>&#125;);<br></code></pre></td></tr></table></figure><p>方法 2：使用 Future 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">1</span>);  <br>Future&lt;?&gt; future = pool.submit(() -&gt; &#123;  <br>    System.out.println(<span class="hljs-string">&quot;task1&quot;</span>);  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> / <span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>&#125;);  <br>System.out.println(future.get());<br></code></pre></td></tr></table></figure><hr><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><h4 id="状态信息"><a href="#状态信息" class="headerlink" title="状态信息"></a>状态信息</h4><p>ThreadPoolExecutor 使用 int 的<strong>高 3 位来表示线程池状态，低 29 位表示线程数量</strong>。这些信息存储在一个原子变量 ctl 中，目的是将线程池状态与线程个数合二为一，这样就可以用一次 CAS 原子操作进行赋值</p><ul><li><p>状态表示：</p><p>  &#x2F;&#x2F; 高3位：表示当前线程池运行状态，除去高3位之后的低位：表示当前线程池中所拥有的线程数量<br>  <code>private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));  </code><br>  &#x2F;&#x2F; 表示在 ctl 中，低 COUNT_BITS 位，是用于存放当前线程数量的位<br>  <code>private static final int COUNT_BITS = Integer.SIZE - 3;  </code><br>  &#x2F;&#x2F; 低 COUNT_BITS 位所能表达的最大数值，000 11111111111111111111 &#x3D;&gt; 5亿多<br>  <code>private static final int CAPACITY   = (1 &lt;&lt; COUNT_BITS) - 1;</code></p><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041822556.png"></p></li><li><p>四种状态：</p><p>  &#x2F;&#x2F; 111 000000000000000000，转换成整数后其实就是一个【负数】<br>  private static final int RUNNING    &#x3D; -1 &lt;&lt; COUNT_BITS;<br>  &#x2F;&#x2F; 000 000000000000000000<br>  private static final int SHUTDOWN   &#x3D;  0 &lt;&lt; COUNT_BITS;<br>  &#x2F;&#x2F; 001 000000000000000000<br>  private static final int STOP       &#x3D;  1 &lt;&lt; COUNT_BITS;<br>  &#x2F;&#x2F; 010 000000000000000000<br>  private static final int TIDYING    &#x3D;  2 &lt;&lt; COUNT_BITS;<br>  &#x2F;&#x2F; 011 000000000000000000<br>  private static final int TERMINATED &#x3D;  3 &lt;&lt; COUNT_BITS;</p><table><thead><tr><th>状态</th><th>高3位</th><th>接收新任务</th><th>处理阻塞任务队列</th><th>说明</th></tr></thead><tbody><tr><td>RUNNING</td><td>111</td><td>Y</td><td>Y</td><td></td></tr><tr><td>SHUTDOWN</td><td>000</td><td>N</td><td>Y</td><td>不接收新任务，但处理阻塞队列剩余任务</td></tr><tr><td>STOP</td><td>001</td><td>N</td><td>N</td><td>中断正在执行的任务，并抛弃阻塞队列任务</td></tr><tr><td>TIDYING</td><td>010</td><td>-</td><td>-</td><td>任务全执行完毕，活动线程为 0 即将进入终结</td></tr><tr><td>TERMINATED</td><td>011</td><td>-</td><td>-</td><td>终止状态</td></tr></tbody></table></li><li><p>获取当前线程池运行状态：</p><p>  &#x2F;&#x2F; ~CAPACITY &#x3D; ~000 11111111111111111111 &#x3D; 111 000000000000000000000（取反）<br>  &#x2F;&#x2F; c &#x3D;&#x3D; ctl &#x3D; 111 000000000000000000111<br>  &#x2F;&#x2F; 111 000000000000000000111<br>  &#x2F;&#x2F; 111 000000000000000000000<br>  &#x2F;&#x2F; 111 000000000000000000000获取到了运行状态<br>  <code>private static int runStateOf(int c)     &#123; return c &amp; ~CAPACITY; &#125;</code></p></li><li><p>获取当前线程池线程数量：</p><p>  &#x2F;&#x2F;        c &#x3D; 111 000000000000000000111<br>  &#x2F;&#x2F; CAPACITY &#x3D; 000 111111111111111111111<br>  &#x2F;&#x2F;            000 000000000000000000111 &#x3D;&gt; 7<br>  <code>private static int workerCountOf(int c)  &#123; return c &amp; CAPACITY; &#125;</code></p></li><li><p>重置当前线程池状态 ctl：</p><p>  &#x2F;&#x2F; rs 表示线程池状态，wc 表示当前线程池中 worker（线程）数量，相与以后就是合并后的状态<br>  <code>private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125;</code></p></li><li><p>比较当前线程池 ctl 所表示的状态：</p><p>  &#x2F;&#x2F; 比较当前线程池 ctl 所表示的状态，是否小于某个状态 s<br>  &#x2F;&#x2F; 状态对比：RUNNING &lt; SHUTDOWN &lt; STOP &lt; TIDYING &lt; TERMINATED<br>  <code>private static boolean runStateLessThan(int c, int s) &#123; return c &lt; s; &#125;  </code><br>  &#x2F;&#x2F; 比较当前线程池 ctl 所表示的状态，是否大于等于某个状态s<br>  <code>private static boolean runStateAtLeast(int c, int s) &#123; return c &gt;= s; &#125;  </code><br>  &#x2F;&#x2F; 小于 SHUTDOWN 的一定是 RUNNING，SHUTDOWN &#x3D;&#x3D; 0<br>  <code>private static boolean isRunning(int c) &#123; return c &lt; SHUTDOWN; &#125;</code></p></li><li><p>设置线程池 ctl：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用 CAS 方式 让 ctl 值 +1 ，成功返回 true, 失败返回 false  </span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndIncrementWorkerCount</span><span class="hljs-params">(<span class="hljs-type">int</span> expect)</span> &#123;  <br>    <span class="hljs-keyword">return</span> ctl.compareAndSet(expect, expect + <span class="hljs-number">1</span>);  <br>&#125;  <br><span class="hljs-comment">// 使用 CAS 方式 让 ctl 值 -1 ，成功返回 true, 失败返回 false  </span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndDecrementWorkerCount</span><span class="hljs-params">(<span class="hljs-type">int</span> expect)</span> &#123;  <br>    <span class="hljs-keyword">return</span> ctl.compareAndSet(expect, expect - <span class="hljs-number">1</span>);  <br>&#125;  <br><span class="hljs-comment">// 将 ctl 值减一，do while 循环会一直重试，直到成功为止  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decrementWorkerCount</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">do</span> &#123;&#125; <span class="hljs-keyword">while</span> (!compareAndDecrementWorkerCount(ctl.get()));  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h4 id="成员属性-2"><a href="#成员属性-2" class="headerlink" title="成员属性"></a>成员属性</h4><p>成员变量</p><ul><li><p><strong>线程池中存放 Worker 的容器</strong>：线程池没有初始化，直接往池中加线程即可</p><p>  <code>private final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;();</code></p></li><li><p>线程全局锁：</p><p>  &#x2F;&#x2F; 增加减少 worker 或者时修改线程池运行状态需要持有 mainLock<br>  <code>private final ReentrantLock mainLock = new ReentrantLock();</code></p></li><li><p>可重入锁的条件变量：</p><p>  &#x2F;&#x2F; 当外部线程调用 awaitTermination() 方法时，会等待当前线程池状态为 Termination 为止<br>  <code>private final Condition termination = mainLock.newCondition()</code></p></li><li><p>线程池相关参数：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> corePoolSize;<span class="hljs-comment">// 核心线程数量  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> maximumPoolSize;<span class="hljs-comment">// 线程池最大线程数量  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> keepAliveTime;<span class="hljs-comment">// 空闲线程存活时间  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> ThreadFactory threadFactory;<span class="hljs-comment">// 创建线程时使用的线程工厂，默认是 DefaultThreadFactory  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;<span class="hljs-comment">// 【超过核心线程提交任务就放入 阻塞队列】</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> RejectedExecutionHandler handler;<span class="hljs-comment">// 拒绝策略，juc包提供了4中方式  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">RejectedExecutionHandler</span> <span class="hljs-variable">defaultHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbortPolicy</span>();<span class="hljs-comment">// 默认策略</span><br></code></pre></td></tr></table></figure></li><li><p>记录线程池相关属性的数值：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> largestPoolSize;<span class="hljs-comment">// 记录线程池生命周期内线程数最大值  </span><br><span class="hljs-keyword">private</span> <span class="hljs-type">long</span> completedTaskCount;<span class="hljs-comment">// 记录线程池所完成任务总数，当某个 worker 退出时将完成的任务累加到该属性</span><br></code></pre></td></tr></table></figure></li><li><p>控制<strong>核心线程数量内的线程是否可以被回收</strong>：</p><p>  &#x2F;&#x2F; false（默认）代表不可以，为 true 时核心线程空闲超过 keepAliveTime 也会被回收<br>  &#x2F;&#x2F; allowCoreThreadTimeOut(boolean value) 方法可以设置该值<br>  <code>private volatile boolean allowCoreThreadTimeOut;</code></p></li></ul><p>内部类：</p><ul><li><p>Worker 类：<strong>每个 Worker 对象会绑定一个初始任务</strong>，启动 Worker 时优先执行，这也是造成线程池不公平的原因。Worker 继承自 AQS，本身具有锁的特性，采用独占锁模式，state &#x3D; 0 表示未被占用，&gt; 0 表示被占用，&lt; 0 表示初始状态不能被抢锁</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;  <br><span class="hljs-keyword">final</span> Thread thread;<span class="hljs-comment">// worker 内部封装的工作线程  </span><br>    Runnable firstTask;<span class="hljs-comment">// worker 第一个执行的任务，普通的 Runnable 实现类或者是 FutureTask  </span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> completedTasks;<span class="hljs-comment">// 记录当前 worker 所完成任务数量  </span><br>      <br>    <span class="hljs-comment">// 构造方法  </span><br>    Worker(Runnable firstTask) &#123;  <br>        <span class="hljs-comment">// 设置AQS独占模式为初始化中状态，这个状态不能被抢占锁  </span><br>       setState(-<span class="hljs-number">1</span>);  <br>        <span class="hljs-comment">// firstTask不为空时，当worker启动后，内部线程会优先执行firstTask，执行完后会到queue中去获取下个任务  </span><br>        <span class="hljs-built_in">this</span>.firstTask = firstTask;  <br>        <span class="hljs-comment">// 使用线程工厂创建一个线程，并且【将当前worker指定为Runnable】，所以thread启动时会调用 worker.run()  </span><br>        <span class="hljs-built_in">this</span>.thread = getThreadFactory().newThread(<span class="hljs-built_in">this</span>);  <br>    &#125;  <br>    <span class="hljs-comment">// 【不可重入锁】  </span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> unused)</span> &#123;  <br>        <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;  <br>            setExclusiveOwnerThread(Thread.currentThread());  <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>    &#125;  <br>&#125;<br><br><span class="hljs-keyword">public</span> Thread <span class="hljs-title function_">newThread</span><span class="hljs-params">(Runnable r)</span> &#123;  <br>    <span class="hljs-comment">// 将当前 worker 指定为 thread 的执行方法，线程调用 start 会调用 r.run()  </span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(group, r, namePrefix + threadNumber.getAndIncrement(), <span class="hljs-number">0</span>);  <br>    <span class="hljs-keyword">if</span> (t.isDaemon())  <br>        t.setDaemon(<span class="hljs-literal">false</span>);  <br>    <span class="hljs-keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)  <br>        t.setPriority(Thread.NORM_PRIORITY);  <br>    <span class="hljs-keyword">return</span> t;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>拒绝策略相关的内部类</p></li></ul><hr><h4 id="成员方法-2"><a href="#成员方法-2" class="headerlink" title="成员方法"></a>成员方法</h4><h5 id="提交方法-1"><a href="#提交方法-1" class="headerlink" title="提交方法"></a>提交方法</h5><ul><li><p>AbstractExecutorService#submit()：提交任务，<strong>把 Runnable 或 Callable 任务封装成 FutureTask 执行</strong>，可以通过方法返回的任务对象，调用 get 阻塞获取任务执行的结果或者异常，源码分析在笔记的 Future 部分</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;  <br>    <span class="hljs-comment">// 空指针异常  </span><br>    <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();  <br>    <span class="hljs-comment">// 把 Runnable 封装成未来任务对象，执行结果就是 null，也可以通过参数指定 FutureTask#get 返回数据  </span><br>    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="hljs-literal">null</span>);  <br>    <span class="hljs-comment">// 执行方法  </span><br>    execute(ftask);  <br>    <span class="hljs-keyword">return</span> ftask;  <br>&#125;  <br><span class="hljs-keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span> &#123;  <br>    <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();  <br>    <span class="hljs-comment">// 把 Callable 封装成未来任务对象  </span><br>    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);  <br>    <span class="hljs-comment">// 执行方法  </span><br>    execute(ftask);  <br>    <span class="hljs-comment">// 返回未来任务对象，用来获取返回值  </span><br>    <span class="hljs-keyword">return</span> ftask;  <br>&#125;<br><br><span class="hljs-keyword">protected</span> &lt;T&gt; RunnableFuture&lt;T&gt; <span class="hljs-title function_">newTaskFor</span><span class="hljs-params">(Runnable runnable, T value)</span> &#123;  <br>    <span class="hljs-comment">// Runnable 封装成 FutureTask，【指定返回值】  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;T&gt;(runnable, value);  <br>&#125;  <br><span class="hljs-keyword">protected</span> &lt;T&gt; RunnableFuture&lt;T&gt; <span class="hljs-title function_">newTaskFor</span><span class="hljs-params">(Callable&lt;T&gt; callable)</span> &#123;  <br>    <span class="hljs-comment">// Callable 直接封装成 FutureTask  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;T&gt;(callable);  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>execute()：执行任务，<strong>但是没有返回值，没办法获取任务执行结果</strong>，出现异常会直接抛出任务执行时的异常。根据线程池中的线程数，选择添加任务时的处理方式</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// command 可以是普通的 Runnable 实现类，也可以是 FutureTask，不能是 Callable  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> &#123;  <br>    <span class="hljs-comment">// 非空判断  </span><br>    <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span>)  <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();  <br>  <span class="hljs-comment">// 获取 ctl 最新值赋值给 c，ctl 高 3 位表示线程池状态，低位表示当前线程池线程数量。  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();  <br>    <span class="hljs-comment">// 【1】当前线程数量小于核心线程数，此次提交任务直接创建一个新的 worker，线程池中多了一个新的线程  </span><br>    <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;  <br>        <span class="hljs-comment">// addWorker 为创建线程的过程，会创建 worker 对象并且将 command 作为 firstTask，优先执行  </span><br>        <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-literal">true</span>))  <br>            <span class="hljs-keyword">return</span>;  <br>          <br>        <span class="hljs-comment">// 执行到这条语句，说明 addWorker 一定是失败的，存在并发现象或者线程池状态被改变，重新获取状态  </span><br>        <span class="hljs-comment">// SHUTDOWN 状态下也有可能创建成功，前提 firstTask == null 而且当前 queue 不为空（特殊情况）  </span><br>        c = ctl.get();  <br>    &#125;  <br>    <span class="hljs-comment">// 【2】执行到这说明当前线程数量已经达到核心线程数量 或者 addWorker 失败  </span><br>    <span class="hljs-comment">// 判断当前线程池是否处于running状态，成立就尝试将 task 放入到 workQueue 中  </span><br>    <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">recheck</span> <span class="hljs-operator">=</span> ctl.get();  <br>        <span class="hljs-comment">// 条件一成立说明线程池状态被外部线程给修改了，可能是执行了 shutdown() 方法，该状态不能接收新提交的任务  </span><br>        <span class="hljs-comment">// 所以要把刚提交的任务删除，删除成功说明提交之后线程池中的线程还未消费（处理）该任务  </span><br>        <span class="hljs-keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))  <br>            <span class="hljs-comment">// 任务出队成功，走拒绝策略  </span><br>            reject(command);  <br>        <span class="hljs-comment">// 执行到这说明线程池是 running 状态，获取线程池中的线程数量，判断是否是 0  </span><br>        <span class="hljs-comment">// 【担保机制】，保证线程池在 running 状态下，最起码得有一个线程在工作  </span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)  <br>            addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);  <br>    &#125;  <br>    <span class="hljs-comment">// 【3】offer失败说明queue满了  </span><br>    <span class="hljs-comment">// 如果线程数量尚未达到 maximumPoolSize，会创建非核心 worker 线程直接执行 command，【这也是不公平的原因】  </span><br>    <span class="hljs-comment">// 如果当前线程数量达到 maximumPoolSiz，这里 addWorker 也会失败，走拒绝策略  </span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-literal">false</span>))  <br>        reject(command);  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h5 id="添加线程"><a href="#添加线程" class="headerlink" title="添加线程"></a>添加线程</h5><ul><li><p>prestartAllCoreThreads()：<strong>提前预热</strong>，创建所有的核心线程</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">prestartAllCoreThreads</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">while</span> (addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>))  <br>        ++n;  <br>    <span class="hljs-keyword">return</span> n;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>addWorker()：<strong>添加线程到线程池</strong>，返回 true 表示创建 Worker 成功，且线程启动。首先判断线程池是否允许添加线程，允许就让线程数量 + 1，然后去创建 Worker 加入线程池</p><p>  注意：SHUTDOWN 状态也能添加线程，但是要求新加的 Woker 没有 firstTask，而且当前 queue 不为空，所以创建一个线程来帮助线程池执行队列中的任务</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// core == true 表示采用核心线程数量限制，false 表示采用 maximumPoolSize  </span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addWorker</span><span class="hljs-params">(Runnable firstTask, <span class="hljs-type">boolean</span> core)</span> &#123;  <br>    <span class="hljs-comment">// 自旋【判断当前线程池状态是否允许创建线程】，允许就设置线程数量 + 1  </span><br>    retry:  <br>    <span class="hljs-keyword">for</span> (;;) &#123;  <br>        <span class="hljs-comment">// 获取 ctl 的值  </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();  <br>        <span class="hljs-comment">// 获取当前线程池运行状态  </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(c);  <br>          <br>        <span class="hljs-comment">// 判断当前线程池状态【是否允许添加线程】  </span><br>          <br>        <span class="hljs-comment">// 当前线程池是 SHUTDOWN 状态，但是队列里面还有任务尚未处理完，需要处理完 queue 中的任务  </span><br>        <span class="hljs-comment">// 【不允许再提交新的 task，所以 firstTask 为空，但是可以继续添加 worker】  </span><br>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; !(rs == SHUTDOWN &amp;&amp; firstTask == <span class="hljs-literal">null</span> &amp;&amp; !workQueue.isEmpty()))  <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>        <span class="hljs-keyword">for</span> (;;) &#123;  <br>            <span class="hljs-comment">// 获取线程池中线程数量  </span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">wc</span> <span class="hljs-operator">=</span> workerCountOf(c);  <br>            <span class="hljs-comment">// 条件一一般不成立，CAPACITY是5亿多，根据 core 判断使用哪个大小限制线程数量，超过了返回 false  </span><br>            <span class="hljs-keyword">if</span> (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize))  <br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>            <span class="hljs-comment">// 记录线程数量已经加 1，类比于申请到了一块令牌，条件失败说明其他线程修改了数量  </span><br>            <span class="hljs-keyword">if</span> (compareAndIncrementWorkerCount(c))  <br>                <span class="hljs-comment">// 申请成功，跳出了 retry 这个 for 自旋  </span><br>                <span class="hljs-keyword">break</span> retry;  <br>            <span class="hljs-comment">// CAS 失败，没有成功的申请到令牌  </span><br>            c = ctl.get();  <br>            <span class="hljs-comment">// 判断当前线程池状态是否发生过变化，被其他线程修改了，可能其他线程调用了 shutdown() 方法  </span><br>            <span class="hljs-keyword">if</span> (runStateOf(c) != rs)  <br>                <span class="hljs-comment">// 返回外层循环检查是否能创建线程，在 if 语句中返回 false  </span><br>                <span class="hljs-keyword">continue</span> retry;  <br>             <br>        &#125;  <br>    &#125;  <br>      <br>    <span class="hljs-comment">//【令牌申请成功，开始创建线程】  </span><br>      <br><span class="hljs-comment">// 运行标记，表示创建的 worker 是否已经启动，false未启动  true启动  </span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">workerStarted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;  <br>    <span class="hljs-comment">// 添加标记，表示创建的 worker 是否添加到池子中了，默认false未添加，true是添加。  </span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">workerAdded</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;  <br>    <span class="hljs-type">Worker</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-comment">// 【创建 Worker，底层通过线程工厂 newThread 方法创建执行线程，指定了首先执行的任务】  </span><br>        w = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(firstTask);  <br>        <span class="hljs-comment">// 将新创建的 worker 节点中的线程赋值给 t  </span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> w.thread;  <br>        <span class="hljs-comment">// 这里的判断为了防止 程序员自定义的 ThreadFactory 实现类有 bug，创造不出线程  </span><br>        <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;  <br>            <span class="hljs-comment">// 加互斥锁，要添加 worker 了  </span><br>            mainLock.lock();  <br>            <span class="hljs-keyword">try</span> &#123;  <br>                <span class="hljs-comment">// 获取最新线程池运行状态保存到 rs  </span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(ctl.get());  <br><span class="hljs-comment">// 判断线程池是否为RUNNING状态，不是再【判断当前是否为SHUTDOWN状态且firstTask为空，特殊情况】  </span><br>                <span class="hljs-keyword">if</span> (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == <span class="hljs-literal">null</span>)) &#123;  <br>                    <span class="hljs-comment">// 当线程start后，线程isAlive会返回true，这里还没开始启动线程，如果被启动了就需要报错  </span><br>                    <span class="hljs-keyword">if</span> (t.isAlive())  <br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalThreadStateException</span>();  <br>                      <br>                    <span class="hljs-comment">//【将新建的 Worker 添加到线程池中】  </span><br>                    workers.add(w);  <br>                    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> workers.size();  <br><span class="hljs-comment">// 当前池中的线程数量是一个新高，更新 largestPoolSize  </span><br>                    <span class="hljs-keyword">if</span> (s &gt; largestPoolSize)  <br>                        largestPoolSize = s;  <br>                    <span class="hljs-comment">// 添加标记置为 true  </span><br>                    workerAdded = <span class="hljs-literal">true</span>;  <br>                &#125;  <br>            &#125; <span class="hljs-keyword">finally</span> &#123;  <br>                <span class="hljs-comment">// 解锁啊  </span><br>                mainLock.unlock();  <br>            &#125;  <br>            <span class="hljs-comment">// 添加成功就【启动线程执行任务】  </span><br>            <span class="hljs-keyword">if</span> (workerAdded) &#123;  <br>                <span class="hljs-comment">// Thread 类中持有 Runnable 任务对象，调用的是 Runnable 的 run ，也就是 FutureTask  </span><br>                t.start();  <br>                <span class="hljs-comment">// 运行标记置为 true  </span><br>                workerStarted = <span class="hljs-literal">true</span>;  <br>            &#125;  <br>        &#125;  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        <span class="hljs-comment">// 如果启动线程失败，做清理工作  </span><br>        <span class="hljs-keyword">if</span> (! workerStarted)  <br>            addWorkerFailed(w);  <br>    &#125;  <br>    <span class="hljs-comment">// 返回新创建的线程是否启动  </span><br>    <span class="hljs-keyword">return</span> workerStarted;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>addWorkerFailed()：清理任务</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addWorkerFailed</span><span class="hljs-params">(Worker w)</span> &#123;  <br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;  <br>    <span class="hljs-comment">// 持有线程池全局锁，因为操作的是线程池相关的东西  </span><br>    mainLock.lock();  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-comment">//条件成立需要将 worker 在 workers 中清理出去。  </span><br>        <span class="hljs-keyword">if</span> (w != <span class="hljs-literal">null</span>)  <br>            workers.remove(w);  <br>        <span class="hljs-comment">// 将线程池计数 -1，相当于归还令牌。  </span><br>        decrementWorkerCount();  <br>        <span class="hljs-comment">// 尝试停止线程池  </span><br>        tryTerminate();  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        <span class="hljs-comment">//释放线程池全局锁。  </span><br>        mainLock.unlock();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h5 id="运行方法"><a href="#运行方法" class="headerlink" title="运行方法"></a>运行方法</h5><ul><li><p>Worker#run：Worker 实现了 Runnable 接口，当线程启动时，会调用 Worker 的 run() 方法</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">// ThreadPoolExecutor#runWorker()  </span><br>    runWorker(<span class="hljs-built_in">this</span>);  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>runWorker()：线程启动就要<strong>执行任务</strong>，会一直 while 循环获取任务并执行</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">runWorker</span><span class="hljs-params">(Worker w)</span> &#123;  <br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">wt</span> <span class="hljs-operator">=</span> Thread.currentThread();  <br>    <span class="hljs-comment">// 获取 worker 的 firstTask  </span><br>    <span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> w.firstTask;  <br>    <span class="hljs-comment">// 引用置空，【防止复用该线程时重复执行该任务】  </span><br>    w.firstTask = <span class="hljs-literal">null</span>;  <br>    <span class="hljs-comment">// 初始化 worker 时设置 state = -1，表示不允许抢占锁  </span><br>    <span class="hljs-comment">// 这里需要设置 state = 0 和 exclusiveOwnerThread = null，开始独占模式抢锁  </span><br>    w.unlock();  <br>    <span class="hljs-comment">// true 表示发生异常退出，false 表示正常退出。  </span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">completedAbruptly</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-comment">// firstTask 不是 null 就直接运行，否则去 queue 中获取任务  </span><br>        <span class="hljs-comment">// 【getTask 如果是阻塞获取任务，会一直阻塞在take方法，直到获取任务，不会走返回null的逻辑】  </span><br>        <span class="hljs-keyword">while</span> (task != <span class="hljs-literal">null</span> || (task = getTask()) != <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-comment">// worker 加锁，shutdown 时会判断当前 worker 状态，【根据独占锁状态判断是否空闲】  </span><br>            w.lock();  <br>              <br><span class="hljs-comment">// 说明线程池状态大于 STOP，目前处于 STOP/TIDYING/TERMINATION，此时给线程一个中断信号  </span><br>            <span class="hljs-keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||  <br>                 <span class="hljs-comment">// 说明线程处于 RUNNING 或者 SHUTDOWN 状态，清除打断标记  </span><br>                 (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted())  <br>                <span class="hljs-comment">// 中断线程，设置线程的中断标志位为 true  </span><br>                wt.interrupt();  <br>            <span class="hljs-keyword">try</span> &#123;  <br>                <span class="hljs-comment">// 钩子方法，【任务执行的前置处理】  </span><br>                beforeExecute(wt, task);  <br>                <span class="hljs-type">Throwable</span> <span class="hljs-variable">thrown</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;  <br>                <span class="hljs-keyword">try</span> &#123;  <br>                    <span class="hljs-comment">// 【执行任务】  </span><br>                    task.run();  <br>                &#125; <span class="hljs-keyword">catch</span> (Exception x) &#123;  <br>                 <span class="hljs-comment">//.....  </span><br>                &#125; <span class="hljs-keyword">finally</span> &#123;  <br>                    <span class="hljs-comment">// 钩子方法，【任务执行的后置处理】  </span><br>                    afterExecute(task, thrown);  <br>                &#125;  <br>            &#125; <span class="hljs-keyword">finally</span> &#123;  <br>                task = <span class="hljs-literal">null</span>;<span class="hljs-comment">// 将局部变量task置为null，代表任务执行完成  </span><br>                w.completedTasks++;<span class="hljs-comment">// 更新worker完成任务数量  </span><br>                w.unlock();<span class="hljs-comment">// 解锁  </span><br>            &#125;  <br>        &#125;  <br>        <span class="hljs-comment">// getTask()方法返回null时会走到这里，表示queue为空并且线程空闲超过保活时间，【当前线程执行退出逻辑】  </span><br>        completedAbruptly = <span class="hljs-literal">false</span>;  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        <span class="hljs-comment">// 正常退出 completedAbruptly = false  </span><br>       <span class="hljs-comment">// 异常退出 completedAbruptly = true，【从 task.run() 内部抛出异常】时，跳到这一行  </span><br>        processWorkerExit(w, completedAbruptly);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>unlock()：重置锁</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123; release(<span class="hljs-number">1</span>); &#125;  <br><span class="hljs-comment">// 外部不会直接调用这个方法 这个方法是 AQS 内调用的，外部调用 unlock 时触发此方法  </span><br><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> unused)</span> &#123;  <br>    setExclusiveOwnerThread(<span class="hljs-literal">null</span>);<span class="hljs-comment">// 设置持有者为 null  </span><br>    setState(<span class="hljs-number">0</span>);<span class="hljs-comment">// 设置 state = 0  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>getTask()：获取任务，线程空闲时间超过 keepAliveTime 就会被回收，判断的依据是<strong>当前线程阻塞获取任务超过保活时间</strong>，方法返回 null 就代表当前线程要被回收了，返回到 runWorker 执行线程退出逻辑。线程池具有担保机制，对于 RUNNING 状态下的超时回收，要保证线程池中最少有一个线程运行，或者任务阻塞队列已经是空</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> Runnable <span class="hljs-title function_">getTask</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">// 超时标记，表示当前线程获取任务是否超时，true 表示已超时  </span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">timedOut</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;   <br>    <span class="hljs-keyword">for</span> (;;) &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();  <br>        <span class="hljs-comment">// 获取线程池当前运行状态  </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(c);  <br>  <br>        <span class="hljs-comment">// 【tryTerminate】打断线程后执行到这，此时线程池状态为STOP或者线程池状态为SHUTDOWN并且队列已经是空  </span><br>        <span class="hljs-comment">// 所以下面的 if 条件一定是成立的，可以直接返回 null，线程就应该退出了  </span><br>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;  <br>            <span class="hljs-comment">// 使用 CAS 自旋的方式让 ctl 值 -1  </span><br>            decrementWorkerCount();  <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>        &#125;  <br>          <br><span class="hljs-comment">// 获取线程池中的线程数量  </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">wc</span> <span class="hljs-operator">=</span> workerCountOf(c);  <br>  <br>        <span class="hljs-comment">// 线程没有明确的区分谁是核心或者非核心线程，是根据当前池中的线程数量判断  </span><br>          <br>        <span class="hljs-comment">// timed = false 表示当前这个线程 获取task时不支持超时机制的，当前线程会使用 queue.take() 阻塞获取  </span><br>        <span class="hljs-comment">// timed = true 表示当前这个线程 获取task时支持超时机制，使用 queue.poll(xxx,xxx) 超时获取  </span><br>        <span class="hljs-comment">// 条件一代表允许回收核心线程，那就无所谓了，全部线程都执行超时回收  </span><br>        <span class="hljs-comment">// 条件二成立说明线程数量大于核心线程数，当前线程认为是非核心线程，有保活时间，去超时获取任务  </span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">timed</span> <span class="hljs-operator">=</span> allowCoreThreadTimeOut || wc &gt; corePoolSize;  <br>          <br><span class="hljs-comment">// 如果线程数量是否超过最大线程数，直接回收  </span><br>        <span class="hljs-comment">// 如果当前线程【允许超时回收并且已经超时了】，就应该被回收了，由于【担保机制】还要做判断：  </span><br>        <span class="hljs-comment">//   wc &gt; 1 说明线程池还用其他线程，当前线程可以直接回收  </span><br>        <span class="hljs-comment">//    workQueue.isEmpty() 前置条件是 wc = 1，【如果当前任务队列也是空了，最后一个线程就可以退出】  </span><br>        <span class="hljs-keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) &amp;&amp; (wc &gt; <span class="hljs-number">1</span> || workQueue.isEmpty())) &#123;  <br>            <span class="hljs-comment">// 使用 CAS 机制将 ctl 值 -1 ,减 1 成功的线程，返回 null，代表可以退出  </span><br>            <span class="hljs-keyword">if</span> (compareAndDecrementWorkerCount(c))  <br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>            <span class="hljs-keyword">continue</span>;  <br>        &#125;  <br>  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            <span class="hljs-comment">// 根据当前线程是否需要超时回收，【选择从队列获取任务的方法】是超时获取或者阻塞获取  </span><br>            <span class="hljs-type">Runnable</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> timed ?  <br>                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take();  <br>            <span class="hljs-comment">// 获取到任务返回任务，【阻塞获取会阻塞到获取任务为止】，不会返回 null  </span><br>            <span class="hljs-keyword">if</span> (r != <span class="hljs-literal">null</span>)  <br>                <span class="hljs-keyword">return</span> r;  <br>            <span class="hljs-comment">// 获取任务为 null 说明超时了，将超时标记设置为 true，下次自旋时返 null  </span><br>            timedOut = <span class="hljs-literal">true</span>;  <br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException retry) &#123;  <br>            <span class="hljs-comment">// 阻塞线程被打断后超时标记置为 false，【说明被打断不算超时】，要继续获取，直到超时或者获取到任务  </span><br>            <span class="hljs-comment">// 如果线程池 SHUTDOWN 状态下的打断，会在循环获取任务前判断，返回 null  </span><br>            timedOut = <span class="hljs-literal">false</span>;  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>processWorkerExit()：<strong>线程退出线程池</strong>，也有担保机制，保证队列中的任务被执行</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// 正常退出 completedAbruptly = false，异常退出为 true  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processWorkerExit</span><span class="hljs-params">(Worker w, <span class="hljs-type">boolean</span> completedAbruptly)</span> &#123;  <br>    <span class="hljs-comment">// 条件成立代表当前 worker 是发生异常退出的，task 任务执行过程中向上抛出异常了  </span><br>    <span class="hljs-keyword">if</span> (completedAbruptly)   <br>        <span class="hljs-comment">// 从异常时到这里 ctl 一直没有 -1，需要在这里 -1  </span><br>        decrementWorkerCount();  <br>  <br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;  <br>    <span class="hljs-comment">// 加锁  </span><br>    mainLock.lock();  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-comment">// 将当前 worker 完成的 task 数量，汇总到线程池的 completedTaskCount  </span><br>        completedTaskCount += w.completedTasks;  <br><span class="hljs-comment">// 将 worker 从线程池中移除  </span><br>        workers.remove(w);  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        mainLock.unlock();<span class="hljs-comment">// 解锁  </span><br>    &#125;  <br><span class="hljs-comment">// 尝试停止线程池，唤醒下一个线程  </span><br>    tryTerminate();  <br>  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();  <br>    <span class="hljs-comment">// 线程池不是停止状态就应该有线程运行【担保机制】  </span><br>    <span class="hljs-keyword">if</span> (runStateLessThan(c, STOP)) &#123;  <br>        <span class="hljs-comment">// 正常退出的逻辑，是对空闲线程回收，不是执行出错  </span><br>        <span class="hljs-keyword">if</span> (!completedAbruptly) &#123;  <br>            <span class="hljs-comment">// 根据是否回收核心线程确定【线程池中的线程数量最小值】  </span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> allowCoreThreadTimeOut ? <span class="hljs-number">0</span> : corePoolSize;  <br>            <span class="hljs-comment">// 最小值为 0，但是线程队列不为空，需要一个线程来完成任务担保机制  </span><br>            <span class="hljs-keyword">if</span> (min == <span class="hljs-number">0</span> &amp;&amp; !workQueue.isEmpty())  <br>                min = <span class="hljs-number">1</span>;  <br>            <span class="hljs-comment">// 线程池中的线程数量大于最小值可以直接返回  </span><br>            <span class="hljs-keyword">if</span> (workerCountOf(c) &gt;= min)  <br>                <span class="hljs-keyword">return</span>;  <br>        &#125;  <br>        <span class="hljs-comment">// 执行 task 时发生异常，有个线程因为异常终止了，需要添加  </span><br>        <span class="hljs-comment">// 或者线程池中的数量小于最小值，这里要创建一个新 worker 加进线程池  </span><br>        addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h5 id="停止方法"><a href="#停止方法" class="headerlink" title="停止方法"></a>停止方法</h5><ul><li><p>shutdown()：停止线程池</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;  <br>    <span class="hljs-comment">// 获取线程池全局锁  </span><br>    mainLock.lock();  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        checkShutdownAccess();  <br>        <span class="hljs-comment">// 设置线程池状态为 SHUTDOWN，如果线程池状态大于 SHUTDOWN，就不会设置直接返回  </span><br>        advanceRunState(SHUTDOWN);  <br>        <span class="hljs-comment">// 中断空闲线程  </span><br>        interruptIdleWorkers();  <br>        <span class="hljs-comment">// 空方法，子类可以扩展  </span><br>        onShutdown();   <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        <span class="hljs-comment">// 释放线程池全局锁  </span><br>        mainLock.unlock();  <br>    &#125;  <br>    tryTerminate();  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>interruptIdleWorkers()：shutdown 方法会<strong>中断所有空闲线程</strong>，根据是否可以获取 AQS 独占锁判断是否处于工作状态。线程之所以空闲是因为阻塞队列没有任务，不会中断正在运行的线程，所以 shutdown 方法会让所有的任务执行完毕</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// onlyOne == true 说明只中断一个线程 ，false 则中断所有线程  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">interruptIdleWorkers</span><span class="hljs-params">(<span class="hljs-type">boolean</span> onlyOne)</span> &#123;  <br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;  <br>    / /持有全局锁  <br>    mainLock.lock();  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-comment">// 遍历所有 worker  </span><br>        <span class="hljs-keyword">for</span> (Worker w : workers) &#123;  <br>            <span class="hljs-comment">// 获取当前 worker 的线程  </span><br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> w.thread;  <br>            <span class="hljs-comment">// 条件一成立：说明当前迭代的这个线程尚未中断  </span><br>            <span class="hljs-comment">// 条件二成立：说明【当前worker处于空闲状态】，阻塞在poll或者take，因为worker执行task时是要加锁的  </span><br>            <span class="hljs-comment">//           每个worker有一个独占锁，w.tryLock()尝试加锁，加锁成功返回 true  </span><br>            <span class="hljs-keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;  <br>                <span class="hljs-keyword">try</span> &#123;  <br>                    <span class="hljs-comment">// 中断线程，处于 queue 阻塞的线程会被唤醒，进入下一次自旋，返回 null，执行退出相逻辑  </span><br>                    t.interrupt();  <br>                &#125; <span class="hljs-keyword">catch</span> (SecurityException ignore) &#123;  <br>                &#125; <span class="hljs-keyword">finally</span> &#123;  <br>                    <span class="hljs-comment">// 释放worker的独占锁  </span><br>                    w.unlock();  <br>                &#125;  <br>            &#125;  <br>            <span class="hljs-comment">// false，代表中断所有的线程  </span><br>            <span class="hljs-keyword">if</span> (onlyOne)  <br>                <span class="hljs-keyword">break</span>;  <br>        &#125;  <br>  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        <span class="hljs-comment">// 释放全局锁  </span><br>        mainLock.unlock();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>shutdownNow()：直接关闭线程池，不会等待任务执行完成</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> List&lt;Runnable&gt; <span class="hljs-title function_">shutdownNow</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">// 返回值引用  </span><br>    List&lt;Runnable&gt; tasks;  <br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;  <br>    <span class="hljs-comment">// 获取线程池全局锁  </span><br>    mainLock.lock();  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        checkShutdownAccess();  <br>        <span class="hljs-comment">// 设置线程池状态为STOP  </span><br>        advanceRunState(STOP);  <br>        <span class="hljs-comment">// 中断线程池中【所有线程】  </span><br>        interruptWorkers();  <br>        <span class="hljs-comment">// 从阻塞队列中导出未处理的task  </span><br>        tasks = drainQueue();  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        mainLock.unlock();  <br>    &#125;  <br>  <br>    tryTerminate();  <br>    <span class="hljs-comment">// 返回当前任务队列中 未处理的任务。  </span><br>    <span class="hljs-keyword">return</span> tasks;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>tryTerminate()：设置为 TERMINATED 状态 if either (SHUTDOWN and pool and queue empty) or (STOP and pool empty)</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tryTerminate</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">for</span> (;;) &#123;  <br>        <span class="hljs-comment">// 获取 ctl 的值  </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();  <br>        <span class="hljs-comment">// 线程池正常，或者有其他线程执行了状态转换的方法，当前线程直接返回  </span><br>        <span class="hljs-keyword">if</span> (isRunning(c) || runStateAtLeast(c, TIDYING) ||  <br>            <span class="hljs-comment">// 线程池是 SHUTDOWN 并且任务队列不是空，需要去处理队列中的任务  </span><br>            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))  <br>            <span class="hljs-keyword">return</span>;  <br>          <br>        <span class="hljs-comment">// 执行到这里说明线程池状态为 STOP 或者线程池状态为 SHUTDOWN 并且队列已经是空  </span><br>        <span class="hljs-comment">// 判断线程池中线程的数量  </span><br>        <span class="hljs-keyword">if</span> (workerCountOf(c) != <span class="hljs-number">0</span>) &#123;  <br>            <span class="hljs-comment">// 【中断一个空闲线程】，在 queue.take() | queue.poll() 阻塞空闲  </span><br>            <span class="hljs-comment">// 唤醒后的线程会在getTask()方法返回null，  </span><br>            <span class="hljs-comment">// 执行 processWorkerExit 退出逻辑时会再次调用 tryTerminate() 唤醒下一个空闲线程  </span><br>            interruptIdleWorkers(ONLY_ONE);  <br>            <span class="hljs-keyword">return</span>;  <br>        &#125;  <br><span class="hljs-comment">// 池中的线程数量为 0 来到这里  </span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;  <br>        <span class="hljs-comment">// 加全局锁  </span><br>        mainLock.lock();  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            <span class="hljs-comment">// 设置线程池状态为 TIDYING 状态，线程数量为 0  </span><br>            <span class="hljs-keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="hljs-number">0</span>))) &#123;  <br>                <span class="hljs-keyword">try</span> &#123;  <br>                    <span class="hljs-comment">// 结束线程池  </span><br>                    terminated();  <br>                &#125; <span class="hljs-keyword">finally</span> &#123;  <br>                    <span class="hljs-comment">// 设置线程池状态为TERMINATED状态。  </span><br>                    ctl.set(ctlOf(TERMINATED, <span class="hljs-number">0</span>));  <br>                    <span class="hljs-comment">// 【唤醒所有调用 awaitTermination() 方法的线程】  </span><br>                    termination.signalAll();  <br>                &#125;  <br>                <span class="hljs-keyword">return</span>;  <br>            &#125;  <br>        &#125; <span class="hljs-keyword">finally</span> &#123;  <br><span class="hljs-comment">// 释放线程池全局锁  </span><br>            mainLock.unlock();  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h4 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h4><h5 id="线程使用"><a href="#线程使用" class="headerlink" title="线程使用"></a>线程使用</h5><p>FutureTask 未来任务对象，继承 Runnable、Future 接口，用于包装 Callable 对象，实现任务的提交</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;  <br>    FutureTask&lt;String&gt; task = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Callable</span>&lt;String&gt;() &#123;  <br>        <span class="hljs-meta">@Override</span>  <br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;  <br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello World&quot;</span>;  <br>        &#125;  <br>    &#125;);  <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task).start();<span class="hljs-comment">//启动线程  </span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> task.get();<span class="hljs-comment">//获取返回任务数据  </span><br>    System.out.println(msg);  <br>&#125;<br></code></pre></td></tr></table></figure><p>构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">FutureTask</span><span class="hljs-params">(Callable&lt;V&gt; callable)</span>&#123;  <br><span class="hljs-built_in">this</span>.callable = callable;<span class="hljs-comment">// 属性注入  </span><br>    <span class="hljs-built_in">this</span>.state = NEW; <span class="hljs-comment">// 任务状态设置为 new  </span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">FutureTask</span><span class="hljs-params">(Runnable runnable, V result)</span> &#123;  <br>    <span class="hljs-comment">// 适配器模式  </span><br>    <span class="hljs-built_in">this</span>.callable = Executors.callable(runnable, result);  <br>    <span class="hljs-built_in">this</span>.state = NEW;         <br>&#125;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Callable&lt;T&gt; <span class="hljs-title function_">callable</span><span class="hljs-params">(Runnable task, T result)</span> &#123;  <br>    <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();  <br>    <span class="hljs-comment">// 使用装饰者模式将 runnable 转换成 callable 接口，外部线程通过 get 获取  </span><br>    <span class="hljs-comment">// 当前任务执行结果时，结果可能为 null 也可能为传进来的值，【传进来什么返回什么】  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RunnableAdapter</span>&lt;T&gt;(task, result);  <br>&#125;  <br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RunnableAdapter</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;T&gt; &#123;  <br>    <span class="hljs-keyword">final</span> Runnable task;  <br>    <span class="hljs-keyword">final</span> T result;  <br>    <span class="hljs-comment">// 构造方法  </span><br>    RunnableAdapter(Runnable task, T result) &#123;  <br>        <span class="hljs-built_in">this</span>.task = task;  <br>        <span class="hljs-built_in">this</span>.result = result;  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">call</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-comment">// 实则调用 Runnable#run 方法  </span><br>        task.run();  <br>        <span class="hljs-comment">// 返回值为构造 FutureTask 对象时传入的返回值或者是 null  </span><br>        <span class="hljs-keyword">return</span> result;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="成员属性-3"><a href="#成员属性-3" class="headerlink" title="成员属性"></a>成员属性</h5><p>FutureTask 类的成员属性：</p><ul><li><p>任务状态：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// 表示当前task状态  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> state;  <br><span class="hljs-comment">// 当前任务尚未执行  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NEW</span>          <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br><span class="hljs-comment">// 当前任务正在结束，尚未完全结束，一种临界状态  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">COMPLETING</span>   <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;  <br><span class="hljs-comment">// 当前任务正常结束  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NORMAL</span>       <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;  <br><span class="hljs-comment">// 当前任务执行过程中发生了异常，内部封装的 callable.run() 向上抛出异常了  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">EXCEPTIONAL</span>  <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;  <br><span class="hljs-comment">// 当前任务被取消  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CANCELLED</span>    <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;  <br><span class="hljs-comment">// 当前任务中断中  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INTERRUPTING</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;  <br><span class="hljs-comment">// 当前任务已中断  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INTERRUPTED</span>  <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;<br></code></pre></td></tr></table></figure></li><li><p>任务对象：</p><p>  <code>private Callable&lt;V&gt; callable;// Runnable 使用装饰者模式伪装成 Callable</code></p></li><li><p><strong>存储任务执行的结果</strong>，这是 run 方法返回值是 void 也可以获取到执行结果的原因：</p><p>  &#x2F;&#x2F; 正常情况下：任务正常执行结束，outcome 保存执行结果，callable 返回值<br>  &#x2F;&#x2F; 非正常情况：callable 向上抛出异常，outcome 保存异常<br>  <code>private Object outcome; </code></p></li><li><p>执行当前任务的线程对象：</p><p>  <code>private volatile Thread runner;// 当前任务被线程执行期间，保存当前执行任务的线程对象引用</code></p></li><li><p><strong>线程阻塞队列的头节点</strong>：</p><p>  &#x2F;&#x2F; 会有很多线程去 get 当前任务的结果，这里使用了一种数据结构头插头取（类似栈）的一个队列来保存所有的 get 线程<br>  <code>private volatile WaitNode waiters;</code></p></li><li><p>内部类：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WaitNode</span> &#123;  <br>    <span class="hljs-comment">// 单向链表  </span><br>    <span class="hljs-keyword">volatile</span> Thread thread;  <br>    <span class="hljs-keyword">volatile</span> WaitNode next;  <br>    WaitNode() &#123; thread = Thread.currentThread(); &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h5 id="成员方法-3"><a href="#成员方法-3" class="headerlink" title="成员方法"></a>成员方法</h5><p>FutureTask 类的成员方法：</p><ul><li><p><strong>FutureTask#run</strong>：任务执行入口</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">//条件一：成立说明当前 task 已经被执行过了或者被 cancel 了，非 NEW 状态的任务，线程就不需要处理了  </span><br>    <span class="hljs-comment">//条件二：线程是 NEW 状态，尝试设置当前任务对象的线程是当前线程，设置失败说明其他线程抢占了该任务，直接返回  </span><br>    <span class="hljs-keyword">if</span> (state != NEW ||  <br>        !UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, runnerOffset, <span class="hljs-literal">null</span>, Thread.currentThread()))  <br>        <span class="hljs-keyword">return</span>;  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-comment">// 执行到这里，当前 task 一定是 NEW 状态，而且【当前线程也抢占 task 成功】  </span><br>        Callable&lt;V&gt; c = callable;  <br>        <span class="hljs-comment">// 判断任务是否为空，防止空指针异常；判断 state 状态，防止外部线程在此期间 cancel 掉当前任务  </span><br>        <span class="hljs-comment">// 【因为 task 的执行者已经设置为当前线程，所以这里是线程安全的】  </span><br>        <span class="hljs-keyword">if</span> (c != <span class="hljs-literal">null</span> &amp;&amp; state == NEW) &#123;  <br>            V result;  <br>            <span class="hljs-comment">// true 表示 callable.run 代码块执行成功 未抛出异常  </span><br>            <span class="hljs-comment">// false 表示 callable.run 代码块执行失败 抛出异常  </span><br>            <span class="hljs-type">boolean</span> ran;  <br>            <span class="hljs-keyword">try</span> &#123;  <br><span class="hljs-comment">// 【调用自定义的方法，执行结果赋值给 result】  </span><br>                result = c.call();  <br>                <span class="hljs-comment">// 没有出现异常  </span><br>                ran = <span class="hljs-literal">true</span>;  <br>            &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;  <br>                <span class="hljs-comment">// 出现异常，返回值置空，ran 置为 false  </span><br>                result = <span class="hljs-literal">null</span>;  <br>                ran = <span class="hljs-literal">false</span>;  <br>                <span class="hljs-comment">// 设置返回的异常  </span><br>                setException(ex);  <br>            &#125;  <br>            <span class="hljs-comment">// 代码块执行正常  </span><br>            <span class="hljs-keyword">if</span> (ran)  <br>                <span class="hljs-comment">// 设置返回的结果  </span><br>                set(result);  <br>        &#125;  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        <span class="hljs-comment">// 任务执行完成，取消线程的引用，help GC  </span><br>        runner = <span class="hljs-literal">null</span>;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;  <br>        <span class="hljs-comment">// 判断任务是不是被中断  </span><br>        <span class="hljs-keyword">if</span> (s &gt;= INTERRUPTING)  <br>            <span class="hljs-comment">// 执行中断处理方法  </span><br>            handlePossibleCancellationInterrupt(s);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>  FutureTask#set：设置正常返回值，首先将任务状态设置为 COMPLETING 状态代表完成中，逻辑执行完设置为 NORMAL 状态代表任务正常执行完成，最后唤醒 get() 阻塞线程</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(V v)</span> &#123;  <br>    <span class="hljs-comment">// CAS 方式设置当前任务状态为完成中，设置失败说明其他线程取消了该任务  </span><br>    <span class="hljs-keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="hljs-built_in">this</span>, stateOffset, NEW, COMPLETING)) &#123;  <br>        <span class="hljs-comment">// 【将结果赋值给 outcome】  </span><br>        outcome = v;  <br>        <span class="hljs-comment">// 将当前任务状态修改为 NORMAL 正常结束状态。  </span><br>        UNSAFE.putOrderedInt(<span class="hljs-built_in">this</span>, stateOffset, NORMAL);  <br>        finishCompletion();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>  FutureTask#setException：设置异常返回值</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setException</span><span class="hljs-params">(Throwable t)</span> &#123;  <br>    <span class="hljs-keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="hljs-built_in">this</span>, stateOffset, NEW, COMPLETING)) &#123;  <br>        <span class="hljs-comment">// 赋值给返回结果，用来向上层抛出来的异常  </span><br>        outcome = t;  <br>        <span class="hljs-comment">// 将当前任务的状态 修改为 EXCEPTIONAL  </span><br>        UNSAFE.putOrderedInt(<span class="hljs-built_in">this</span>, stateOffset, EXCEPTIONAL);  <br>        finishCompletion();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>  FutureTask#finishCompletion：<strong>唤醒 get() 阻塞线程</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finishCompletion</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">// 遍历所有的等待的节点，q 指向头节点  </span><br>    <span class="hljs-keyword">for</span> (WaitNode q; (q = waiters) != <span class="hljs-literal">null</span>;) &#123;  <br>        <span class="hljs-comment">// 使用cas设置 waiters 为 null，防止外部线程使用cancel取消当前任务，触发finishCompletion方法重复执行  </span><br>        <span class="hljs-keyword">if</span> (UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, waitersOffset, q, <span class="hljs-literal">null</span>)) &#123;  <br>            <span class="hljs-comment">// 自旋  </span><br>            <span class="hljs-keyword">for</span> (;;) &#123;  <br>                <span class="hljs-comment">// 获取当前 WaitNode 节点封装的 thread  </span><br>                <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> q.thread;  <br>                <span class="hljs-comment">// 当前线程不为 null，唤醒当前 get() 等待获取数据的线程  </span><br>                <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>) &#123;  <br>                    q.thread = <span class="hljs-literal">null</span>;  <br>                    LockSupport.unpark(t);  <br>                &#125;  <br>                <span class="hljs-comment">// 获取当前节点的下一个节点  </span><br>                <span class="hljs-type">WaitNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> q.next;  <br>                <span class="hljs-comment">// 当前节点是最后一个节点了  </span><br>                <span class="hljs-keyword">if</span> (next == <span class="hljs-literal">null</span>)  <br>                    <span class="hljs-keyword">break</span>;  <br>                <span class="hljs-comment">// 断开链表  </span><br>                q.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help gc  </span><br>                q = next;  <br>            &#125;  <br>            <span class="hljs-keyword">break</span>;  <br>        &#125;  <br>    &#125;  <br>    done();  <br>    callable = <span class="hljs-literal">null</span>;<span class="hljs-comment">// help GC  </span><br>&#125;<br></code></pre></td></tr></table></figure><p>  FutureTask#handlePossibleCancellationInterrupt：任务中断处理</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handlePossibleCancellationInterrupt</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> &#123;  <br>    <span class="hljs-keyword">if</span> (s == INTERRUPTING)  <br>        <span class="hljs-comment">// 中断状态中  </span><br>        <span class="hljs-keyword">while</span> (state == INTERRUPTING)  <br>            <span class="hljs-comment">// 等待中断完成  </span><br>            Thread.yield();  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>FutureTask#get</strong>：获取任务执行的返回值，执行 run 和 get 的不是同一个线程，一般有多个线程 get，只有一个线程 run</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException &#123;  <br>    <span class="hljs-comment">// 获取当前任务状态  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;  <br>    <span class="hljs-comment">// 条件成立说明任务还没执行完成  </span><br>    <span class="hljs-keyword">if</span> (s &lt;= COMPLETING)  <br>        <span class="hljs-comment">// 返回 task 当前状态，可能当前线程在里面已经睡了一会  </span><br>        s = awaitDone(<span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);  <br>    <span class="hljs-keyword">return</span> report(s);  <br>&#125;<br></code></pre></td></tr></table></figure><p>  FutureTask#awaitDone：<strong>get 线程封装成 WaitNode 对象进入阻塞队列阻塞等待</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">awaitDone</span><span class="hljs-params">(<span class="hljs-type">boolean</span> timed, <span class="hljs-type">long</span> nanos)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>    <span class="hljs-comment">// 0 不带超时  </span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> timed ? System.nanoTime() + nanos : <span class="hljs-number">0L</span>;  <br>    <span class="hljs-comment">// 引用当前线程，封装成 WaitNode 对象  </span><br>    <span class="hljs-type">WaitNode</span> <span class="hljs-variable">q</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;  <br>    <span class="hljs-comment">// 表示当前线程 waitNode 对象，是否进入阻塞队列  </span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">queued</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;  <br>    <span class="hljs-comment">// 【三次自旋开始休眠】  </span><br>    <span class="hljs-keyword">for</span> (;;) &#123;  <br>        <span class="hljs-comment">// 判断当前 get() 线程是否被打断，打断返回 true，清除打断标记  </span><br>        <span class="hljs-keyword">if</span> (Thread.interrupted()) &#123;  <br>            <span class="hljs-comment">// 当前线程对应的等待 node 出队，  </span><br>            removeWaiter(q);  <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();  <br>        &#125;  <br><span class="hljs-comment">// 获取任务状态  </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;  <br>        <span class="hljs-comment">// 条件成立说明当前任务执行完成已经有结果了  </span><br>        <span class="hljs-keyword">if</span> (s &gt; COMPLETING) &#123;  <br>            <span class="hljs-comment">// 条件成立说明已经为当前线程创建了 WaitNode，置空 help GC  </span><br>            <span class="hljs-keyword">if</span> (q != <span class="hljs-literal">null</span>)  <br>                q.thread = <span class="hljs-literal">null</span>;  <br>            <span class="hljs-comment">// 返回当前的状态  </span><br>            <span class="hljs-keyword">return</span> s;  <br>        &#125;  <br>        <span class="hljs-comment">// 条件成立说明当前任务接近完成状态，这里让当前线程释放一下 cpu ，等待进行下一次抢占 cpu  </span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s == COMPLETING)   <br>            Thread.yield();  <br>        <span class="hljs-comment">// 【第一次自旋】，当前线程还未创建 WaitNode 对象，此时为当前线程创建 WaitNode对象  </span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (q == <span class="hljs-literal">null</span>)  <br>            q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WaitNode</span>();  <br>        <span class="hljs-comment">// 【第二次自旋】，当前线程已经创建 WaitNode 对象了，但是node对象还未入队  </span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!queued)  <br>            <span class="hljs-comment">// waiters 指向队首，让当前 WaitNode 成为新的队首，【头插法】，失败说明其他线程修改了新的队首  </span><br>            queued = UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, waitersOffset, q.next = waiters, q);  <br>        <span class="hljs-comment">// 【第三次自旋】，会到这里，或者 else 内  </span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (timed) &#123;  <br>            nanos = deadline - System.nanoTime();  <br>            <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0L</span>) &#123;  <br>                removeWaiter(q);  <br>                <span class="hljs-keyword">return</span> state;  <br>            &#125;  <br>            <span class="hljs-comment">// 阻塞指定的时间  </span><br>            LockSupport.parkNanos(<span class="hljs-built_in">this</span>, nanos);  <br>        &#125;  <br>        <span class="hljs-comment">// 条件成立：说明需要阻塞  </span><br>        <span class="hljs-keyword">else</span>  <br>            <span class="hljs-comment">// 【当前 get 操作的线程被 park 阻塞】，除非有其它线程将唤醒或者将当前线程中断  </span><br>            LockSupport.park(<span class="hljs-built_in">this</span>);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>  FutureTask#report：封装运行结果，可以获取 run() 方法中设置的成员变量 outcome，<strong>这是 run 方法的返回值是 void 也可以获取到任务执行的结果的原因</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> V <span class="hljs-title function_">report</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> <span class="hljs-keyword">throws</span> ExecutionException &#123;  <br>    <span class="hljs-comment">// 获取执行结果，是在一个 futuretask 对象中的属性，可以直接获取  </span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> outcome;  <br>    <span class="hljs-comment">// 当前任务状态正常结束  </span><br>    <span class="hljs-keyword">if</span> (s == NORMAL)  <br>        <span class="hljs-keyword">return</span> (V)x;<span class="hljs-comment">// 直接返回 callable 的逻辑结果  </span><br>    <span class="hljs-comment">// 当前任务被取消或者中断  </span><br>    <span class="hljs-keyword">if</span> (s &gt;= CANCELLED)  <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CancellationException</span>();<span class="hljs-comment">// 抛出异常  </span><br>    <span class="hljs-comment">// 执行到这里说明自定义的 callable 中的方法有异常，使用 outcome 上层抛出异常  </span><br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExecutionException</span>((Throwable)x);  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>FutureTask#cancel：任务取消，打断正在执行该任务的线程</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">cancel</span><span class="hljs-params">(<span class="hljs-type">boolean</span> mayInterruptIfRunning)</span> &#123;  <br>    <span class="hljs-comment">// 条件一：表示当前任务处于运行中或者处于线程池任务队列中  </span><br>    <span class="hljs-comment">// 条件二：表示修改状态，成功可以去执行下面逻辑，否则返回 false 表示 cancel 失败  </span><br>    <span class="hljs-keyword">if</span> (!(state == NEW &amp;&amp;  <br>          UNSAFE.compareAndSwapInt(<span class="hljs-built_in">this</span>, stateOffset, NEW,  <br>                                   mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-comment">// 如果任务已经被执行，是否允许打断  </span><br>        <span class="hljs-keyword">if</span> (mayInterruptIfRunning) &#123;  <br>            <span class="hljs-keyword">try</span> &#123;  <br>                <span class="hljs-comment">// 获取执行当前 FutureTask 的线程  </span><br>                <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> runner;  <br>                <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>)  <br>                    <span class="hljs-comment">// 打断执行的线程  </span><br>                    t.interrupt();  <br>            &#125; <span class="hljs-keyword">finally</span> &#123;  <br>                <span class="hljs-comment">// 设置任务状态为【中断完成】  </span><br>                UNSAFE.putOrderedInt(<span class="hljs-built_in">this</span>, stateOffset, INTERRUPTED);  <br>            &#125;  <br>        &#125;  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        <span class="hljs-comment">// 唤醒所有 get() 阻塞的线程  </span><br>        finishCompletion();  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h3><h4 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h4><p>Timer 实现定时功能，Timer 的优点在于简单易用，但由于所有任务都是由同一个线程来调度，因此所有任务都是串行执行的，同一时间只能有一个任务在执行，前一个任务的延迟或异常都将会影响到之后的任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-type">Timer</span> <span class="hljs-variable">timer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Timer</span>();  <br>    <span class="hljs-type">TimerTask</span> <span class="hljs-variable">task1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerTask</span>() &#123;  <br>        <span class="hljs-meta">@Override</span>  <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>            System.out.println(<span class="hljs-string">&quot;task 1&quot;</span>);  <br>            <span class="hljs-comment">//int i = 1 / 0;//任务一的出错会导致任务二无法执行  </span><br>            Thread.sleep(<span class="hljs-number">2000</span>);  <br>        &#125;  <br>    &#125;;  <br>    <span class="hljs-type">TimerTask</span> <span class="hljs-variable">task2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerTask</span>() &#123;  <br>        <span class="hljs-meta">@Override</span>  <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>            System.out.println(<span class="hljs-string">&quot;task 2&quot;</span>);  <br>        &#125;  <br>    &#125;;  <br>    <span class="hljs-comment">// 使用 timer 添加两个任务，希望它们都在 1s 后执行  </span><br><span class="hljs-comment">// 但由于 timer 内只有一个线程来顺序执行队列中的任务，因此任务1的延时，影响了任务2的执行  </span><br>    timer.schedule(task1, <span class="hljs-number">1000</span>);<span class="hljs-comment">//17:45:56 c.ThreadPool [Timer-0] - task 1  </span><br>    timer.schedule(task2, <span class="hljs-number">1000</span>);<span class="hljs-comment">//17:45:58 c.ThreadPool [Timer-0] - task 2  </span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="Scheduled"><a href="#Scheduled" class="headerlink" title="Scheduled"></a>Scheduled</h4><p>任务调度线程池 ScheduledThreadPoolExecutor 继承 ThreadPoolExecutor：</p><ul><li><p>使用内部类 ScheduledFutureTask 封装任务</p></li><li><p>使用内部类 DelayedWorkQueue 作为线程池队列</p></li><li><p>重写 onShutdown 方法去处理 shutdown 后的任务</p></li><li><p>提供 decorateTask 方法作为 ScheduledFutureTask 的修饰方法，以便开发者进行扩展</p></li></ul><p>构造方法：<code>Executors.newScheduledThreadPool(int corePoolSize)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize)</span> &#123;  <br>    <span class="hljs-comment">// 最大线程数固定为 Integer.MAX_VALUE，保活时间 keepAliveTime 固定为 0  </span><br>    <span class="hljs-built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="hljs-number">0</span>, NANOSECONDS,  <br>          <span class="hljs-comment">// 阻塞队列是 DelayedWorkQueue  </span><br>          <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayedWorkQueue</span>());  <br>&#125;<br><br></code></pre></td></tr></table></figure><p>常用 API：</p><ul><li><p><code>ScheduledFuture&lt;?&gt; schedule(Runnable/Callable&lt;V&gt;, long delay, TimeUnit u)</code>：延迟执行任务</p></li><li><p><code>ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable/Callable&lt;V&gt;, long initialDelay, long period, TimeUnit unit)</code>：定时执行周期任务，不考虑执行的耗时，参数为初始延迟时间、间隔时间、单位</p></li><li><p><code>ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable/Callable&lt;V&gt;, long initialDelay, long delay, TimeUnit unit)</code>：定时执行周期任务，考虑执行的耗时，参数为初始延迟时间、间隔时间、单位</p></li></ul><p>基本使用：</p><ul><li><p>延迟任务，但是出现异常并不会在控制台打印，也不会影响其他线程的执行</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;  <br>    <span class="hljs-comment">// 线程池大小为1时也是串行执行  </span><br>    <span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newScheduledThreadPool(<span class="hljs-number">2</span>);  <br>    <span class="hljs-comment">// 添加两个任务，都在 1s 后同时执行  </span><br>    executor.schedule(() -&gt; &#123;  <br>    System.out.println(<span class="hljs-string">&quot;任务1，执行时间：&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());  <br>        <span class="hljs-comment">//int i = 1 / 0;  </span><br>    <span class="hljs-keyword">try</span> &#123; Thread.sleep(<span class="hljs-number">2000</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; &#125;  <br>    &#125;, <span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS);  <br>      <br>    executor.schedule(() -&gt; &#123;  <br>    System.out.println(<span class="hljs-string">&quot;任务2，执行时间：&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());  <br>    &#125;, <span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS);  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>定时任务 scheduleAtFixedRate：<strong>一次任务的启动到下一次任务的启动</strong>之间只要大于等于间隔时间，抢占到 CPU 就会立即执行</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    <span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> Executors.newScheduledThreadPool(<span class="hljs-number">1</span>);  <br>    System.out.println(<span class="hljs-string">&quot;start...&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());  <br>      <br>    pool.scheduleAtFixedRate(() -&gt; &#123;  <br>        System.out.println(<span class="hljs-string">&quot;running...&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());  <br>        Thread.sleep(<span class="hljs-number">2000</span>);  <br>    &#125;, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);  <br>&#125;  <br>  <br><span class="hljs-comment">/*start...Sat Apr 24 18:08:12 CST 2021  </span><br><span class="hljs-comment">running...Sat Apr 24 18:08:13 CST 2021  </span><br><span class="hljs-comment">running...Sat Apr 24 18:08:15 CST 2021  </span><br><span class="hljs-comment">running...Sat Apr 24 18:08:17 CST 2021*/</span><br></code></pre></td></tr></table></figure></li><li><p>定时任务 scheduleWithFixedDelay：<strong>一次任务的结束到下一次任务的启动之间</strong>等于间隔时间，抢占到 CPU 就会立即执行，这个方法才是真正的设置两个任务之间的间隔</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;  <br>    <span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> Executors.newScheduledThreadPool(<span class="hljs-number">3</span>);  <br>    System.out.println(<span class="hljs-string">&quot;start...&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());  <br>      <br>    pool.scheduleWithFixedDelay(() -&gt; &#123;  <br>        System.out.println(<span class="hljs-string">&quot;running...&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());  <br>        Thread.sleep(<span class="hljs-number">2000</span>);  <br>    &#125;, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);  <br>&#125;  <br><span class="hljs-comment">/*start...Sat Apr 24 18:11:41 CST 2021  </span><br><span class="hljs-comment">running...Sat Apr 24 18:11:42 CST 2021  </span><br><span class="hljs-comment">running...Sat Apr 24 18:11:45 CST 2021  </span><br><span class="hljs-comment">running...Sat Apr 24 18:11:48 CST 2021*/</span><br></code></pre></td></tr></table></figure></li></ul><hr><h4 id="成员属性-4"><a href="#成员属性-4" class="headerlink" title="成员属性"></a>成员属性</h4><h5 id="成员变量-1"><a href="#成员变量-1" class="headerlink" title="成员变量"></a>成员变量</h5><ul><li><p>shutdown 后是否继续执行周期任务：</p><p>  <code>private volatile boolean continueExistingPeriodicTasksAfterShutdown;</code></p></li><li><p>shutdown 后是否继续执行延迟任务：</p><p>  <code>private volatile boolean executeExistingDelayedTasksAfterShutdown = true;</code></p></li><li><p>取消方法是否将该任务从队列中移除：</p><p>  &#x2F;&#x2F; 默认 false，不移除，等到线程拿到任务之后抛弃<br>  <code>private volatile boolean removeOnCancel = false;</code></p></li><li><p>任务的序列号，可以用来比较优先级：</p><p>  <code>private static final AtomicLong sequencer = new AtomicLong();</code></p></li></ul><hr><h5 id="延迟任务"><a href="#延迟任务" class="headerlink" title="延迟任务"></a>延迟任务</h5><p>ScheduledFutureTask 继承 FutureTask，实现 RunnableScheduledFuture 接口，具有延迟执行的特点，覆盖 FutureTask 的 run 方法来实现对<strong>延时执行、周期执行</strong>的支持。对于延时任务调用 FutureTask#run，而对于周期性任务则调用 FutureTask#runAndReset 并且在成功之后根据 fixed-delay&#x2F;fixed-rate 模式来设置下次执行时间并重新将任务塞到工作队列</p><p>在调度线程池中无论是 runnable 还是 callable，无论是否需要延迟和定时，所有的任务都会被封装成 ScheduledFutureTask</p><p>成员变量：</p><ul><li><p>任务序列号：</p><p>  <code>private final long sequenceNumber;</code></p></li><li><p>执行时间：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">long</span> time;<span class="hljs-comment">// 任务可以被执行的时间，交付时间，以纳秒表示  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> period;<span class="hljs-comment">// 0 表示非周期任务，正数表示 fixed-rate 模式的周期，负数表示 fixed-delay 模式</span><br><br>fixed-rate：两次开始启动的间隔，fixed-delay：一次执行结束到下一次开始启动<br></code></pre></td></tr></table></figure></li><li><p>实际的任务对象：</p><p>  <code>RunnableScheduledFuture&lt;V&gt; outerTask = this;</code></p></li><li><p>任务在队列数组中的索引下标：</p><p>  &#x2F;&#x2F; DelayedWorkQueue 底层使用的数据结构是最小堆，记录当前任务在堆中的索引，-1 代表删除<br>  <code>int heapIndex;</code></p></li></ul><p>成员方法：</p><ul><li><p>构造方法：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">ScheduledFutureTask(Runnable r, V result, <span class="hljs-type">long</span> ns, <span class="hljs-type">long</span> period) &#123;  <br>    <span class="hljs-built_in">super</span>(r, result);  <br>    <span class="hljs-comment">// 任务的触发时间  </span><br>    <span class="hljs-built_in">this</span>.time = ns;  <br>    <span class="hljs-comment">// 任务的周期，多长时间执行一次  </span><br>    <span class="hljs-built_in">this</span>.period = period;  <br>    <span class="hljs-comment">// 任务的序号  </span><br>    <span class="hljs-built_in">this</span>.sequenceNumber = sequencer.getAndIncrement();  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>compareTo()：ScheduledFutureTask 根据执行时间 time 正序排列，如果执行时间相同，在按照序列号 sequenceNumber 正序排列，任务需要放入 DelayedWorkQueue，延迟队列中使用该方法按照从小到大进行排序</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Delayed other)</span> &#123;  <br>    <span class="hljs-keyword">if</span> (other == <span class="hljs-built_in">this</span>) <span class="hljs-comment">// compare zero if same object  </span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">if</span> (other <span class="hljs-keyword">instanceof</span> ScheduledFutureTask) &#123;  <br>        <span class="hljs-comment">// 类型强转  </span><br>        ScheduledFutureTask&lt;?&gt; x = (ScheduledFutureTask&lt;?&gt;)other;  <br>        <span class="hljs-comment">// 比较者 - 被比较者的执行时间  </span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">diff</span> <span class="hljs-operator">=</span> time - x.time;  <br>        <span class="hljs-comment">// 比较者先执行  </span><br>        <span class="hljs-keyword">if</span> (diff &lt; <span class="hljs-number">0</span>)  <br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;  <br>        <span class="hljs-comment">// 被比较者先执行  </span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (diff &gt; <span class="hljs-number">0</span>)  <br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <br>        <span class="hljs-comment">// 比较者的序列号小  </span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sequenceNumber &lt; x.sequenceNumber)  <br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;  <br>        <span class="hljs-keyword">else</span>  <br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <br>    &#125;  <br>    <span class="hljs-comment">// 不是 ScheduledFutureTask 类型时，根据延迟时间排序  </span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">diff</span> <span class="hljs-operator">=</span> getDelay(NANOSECONDS) - other.getDelay(NANOSECONDS);  <br>    <span class="hljs-keyword">return</span> (diff &lt; <span class="hljs-number">0</span>) ? -<span class="hljs-number">1</span> : (diff &gt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>run()：执行任务，非周期任务直接完成直接结束，<strong>周期任务执行完后会设置下一次的执行时间，重新放入线程池的阻塞队列</strong>，如果线程池中的线程数量少于核心线程，就会添加 Worker 开启新线程</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">// 是否周期性，就是判断 period 是否为 0  </span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">periodic</span> <span class="hljs-operator">=</span> isPeriodic();  <br>    <span class="hljs-comment">// 根据是否是周期任务检查当前状态能否执行任务，不能执行就取消任务  </span><br>    <span class="hljs-keyword">if</span> (!canRunInCurrentRunState(periodic))  <br>        cancel(<span class="hljs-literal">false</span>);  <br>    <span class="hljs-comment">// 非周期任务，直接调用 FutureTask#run 执行  </span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!periodic)  <br>        ScheduledFutureTask.<span class="hljs-built_in">super</span>.run();  <br>    <span class="hljs-comment">// 周期任务的执行，返回 true 表示执行成功  </span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ScheduledFutureTask.<span class="hljs-built_in">super</span>.runAndReset()) &#123;  <br>        <span class="hljs-comment">// 设置周期任务的下一次执行时间  </span><br>        setNextRunTime();  <br>        <span class="hljs-comment">// 任务的下一次执行安排，如果当前线程池状态可以执行周期任务，加入队列，并开启新线程  </span><br>        reExecutePeriodic(outerTask);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>  周期任务正常完成后<strong>任务的状态不会变化</strong>，依旧是 NEW，不会设置 outcome 属性。但是如果本次任务执行出现异常，会进入 setException 方法将任务状态置为异常，把异常保存在 outcome 中，方法返回 false，后续的该任务将不会再周期的执行</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">runAndReset</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">// 任务不是新建的状态了，或者被别的线程执行了，直接返回 false  </span><br>    <span class="hljs-keyword">if</span> (state != NEW ||  <br>        !UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, runnerOffset, <span class="hljs-literal">null</span>, Thread.currentThread()))  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">ran</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        Callable&lt;V&gt; c = callable;  <br>        <span class="hljs-keyword">if</span> (c != <span class="hljs-literal">null</span> &amp;&amp; s == NEW) &#123;  <br>            <span class="hljs-keyword">try</span> &#123;  <br>                <span class="hljs-comment">// 执行方法，没有返回值  </span><br>                c.call();  <br>                ran = <span class="hljs-literal">true</span>;  <br>            &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;  <br>                <span class="hljs-comment">// 出现异常，把任务设置为异常状态，唤醒所有的 get 阻塞线程  </span><br>                setException(ex);  <br>            &#125;  <br>        &#125;  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br><span class="hljs-comment">// 执行完成把执行线程引用置为 null  </span><br>        runner = <span class="hljs-literal">null</span>;  <br>        s = state;  <br>        <span class="hljs-comment">// 如果线程被中断进行中断处理  </span><br>        <span class="hljs-keyword">if</span> (s &gt;= INTERRUPTING)  <br>            handlePossibleCancellationInterrupt(s);  <br>    &#125;  <br>    <span class="hljs-comment">// 如果正常执行，返回 true，并且任务状态没有被取消  </span><br>    <span class="hljs-keyword">return</span> ran &amp;&amp; s == NEW;  <br>&#125;<br><br><span class="hljs-comment">// 任务下一次的触发时间  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNextRunTime</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-type">long</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> period;  <br>    <span class="hljs-keyword">if</span> (p &gt; <span class="hljs-number">0</span>)  <br>        <span class="hljs-comment">// fixed-rate 模式，【时间设置为上一次执行任务的时间 + p】，两次任务执行的时间差  </span><br>        time += p;  <br>    <span class="hljs-keyword">else</span>  <br>        <span class="hljs-comment">// fixed-delay 模式，下一次执行时间是【当前这次任务结束的时间（就是现在） + delay 值】  </span><br>        time = triggerTime(-p);  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>reExecutePeriodic()<strong>：准备任务的下一次执行，重新放入阻塞任务队列</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// ScheduledThreadPoolExecutor#reExecutePeriodic  </span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">reExecutePeriodic</span><span class="hljs-params">(RunnableScheduledFuture&lt;?&gt; task)</span> &#123;  <br>    <span class="hljs-keyword">if</span> (canRunInCurrentRunState(<span class="hljs-literal">true</span>)) &#123;  <br>        <span class="hljs-comment">// 【放入任务队列】  </span><br>        <span class="hljs-built_in">super</span>.getQueue().add(task);  <br>        <span class="hljs-comment">// 如果提交完任务之后，线程池状态变为了 shutdown 状态，需要再次检查是否可以执行，  </span><br>        <span class="hljs-comment">// 如果不能执行且任务还在队列中未被取走，则取消任务  </span><br>        <span class="hljs-keyword">if</span> (!canRunInCurrentRunState(<span class="hljs-literal">true</span>) &amp;&amp; remove(task))  <br>            task.cancel(<span class="hljs-literal">false</span>);  <br>        <span class="hljs-keyword">else</span>  <br>            <span class="hljs-comment">// 当前线程池状态可以执行周期任务，加入队列，并【根据线程数量是否大于核心线程数确定是否开启新线程】  </span><br>            ensurePrestart();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>cancel()：取消任务</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">cancel</span><span class="hljs-params">(<span class="hljs-type">boolean</span> mayInterruptIfRunning)</span> &#123;  <br>    <span class="hljs-comment">// 调用父类 FutureTask#cancel 来取消任务  </span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">cancelled</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">super</span>.cancel(mayInterruptIfRunning);  <br>    <span class="hljs-comment">// removeOnCancel 用于控制任务取消后是否应该从阻塞队列中移除  </span><br>    <span class="hljs-keyword">if</span> (cancelled &amp;&amp; removeOnCancel &amp;&amp; heapIndex &gt;= <span class="hljs-number">0</span>)  <br>        <span class="hljs-comment">// 从等待队列中删除该任务，并调用 tryTerminate() 判断是否需要停止线程池  </span><br>        remove(<span class="hljs-built_in">this</span>);  <br>    <span class="hljs-keyword">return</span> cancelled;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h5 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h5><p>DelayedWorkQueue 是支持延时获取元素的阻塞队列，内部采用优先队列 PriorityQueue（小根堆、满二叉树）存储元素</p><p>其他阻塞队列存储节点的数据结构大都是链表，<strong>延迟队列是数组</strong>，所以延迟队列出队头元素后需要<strong>让其他元素（尾）替换到头节点</strong>，防止空指针异常</p><p>成员变量：</p><ul><li><p>容量：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;<span class="hljs-comment">// 初始容量  </span><br>   <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">// 节点数量  </span><br>   <br>   <span class="hljs-keyword">private</span> RunnableScheduledFuture&lt;?&gt;[] queue =   <br>       <span class="hljs-keyword">new</span> <span class="hljs-title class_">RunnableScheduledFuture</span>&lt;?&gt;[INITIAL_CAPACITY];<span class="hljs-comment">// 存放节点</span><br></code></pre></td></tr></table></figure></li><li><p>锁：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<span class="hljs-comment">// 控制并发  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">available</span> <span class="hljs-operator">=</span> lock.newCondition();<span class="hljs-comment">// 条件队列</span><br></code></pre></td></tr></table></figure></li><li><p>阻塞等待头节点的线程：线程池内的某个线程去 take() 获取任务时，如果延迟队列顶层节点不为 null（队列内有任务），但是节点任务还不到触发时间，线程就去检查<strong>队列的 leader字段</strong>是否被占用</p><ul><li><p>如果未被占用，则当前线程占用该字段，然后当前线程到 available 条件队列指定超时时间 <code>堆顶任务.time - now()</code> 挂起</p></li><li><p>如果被占用，当前线程直接到 available 条件队列不指定超时时间的挂起</p></li></ul><p>  &#x2F;&#x2F; leader 在 available 条件队列内是首元素，它超时之后会醒过来，然后再次将堆顶元素获取走，获取走之后，take()结束之前，会调用是 available.signal() 唤醒下一个条件队列内的等待者，然后释放 lock，下一个等待者被唤醒后去到 AQS 队列，做 acquireQueue(node) 逻辑<br>  <code>private Thread leader = null;</code></p></li></ul><p>成员方法</p><ul><li><p>offer()：插入节点</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(Runnable x)</span> &#123;  <br>    <span class="hljs-comment">// 判空  </span><br>    <span class="hljs-keyword">if</span> (x == <span class="hljs-literal">null</span>)  <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();  <br>    RunnableScheduledFuture&lt;?&gt; e = (RunnableScheduledFuture&lt;?&gt;)x;  <br>    <span class="hljs-comment">// 队列锁，增加删除数据时都要加锁  </span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;  <br>    lock.lock();  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> size;  <br>        <span class="hljs-comment">// 队列数量大于存放节点的数组长度，需要扩容  </span><br>        <span class="hljs-keyword">if</span> (i &gt;= queue.length)  <br>            <span class="hljs-comment">// 扩容为原来长度的 1.5 倍  </span><br>            grow();  <br>        size = i + <span class="hljs-number">1</span>;  <br>        <span class="hljs-comment">// 当前是第一个要插入的节点  </span><br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;  <br>            queue[<span class="hljs-number">0</span>] = e;  <br>            <span class="hljs-comment">// 修改 ScheduledFutureTask 的 heapIndex 属性，表示该对象在队列里的下标  </span><br>            setIndex(e, <span class="hljs-number">0</span>);  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            <span class="hljs-comment">// 向上调整元素的位置，并更新 heapIndex   </span><br>            siftUp(i, e);  <br>        &#125;  <br>        <span class="hljs-comment">// 情况1：当前任务是第一个加入到 queue 内的任务，所以在当前任务加入到 queue 之前，take() 线程会直接  </span><br>        <span class="hljs-comment">//到 available 队列不设置超时的挂起，并不会去占用 leader 字段，这时需会唤醒一个线程 让它去消费  </span><br>       <span class="hljs-comment">// 情况2：当前任务【优先级最高】，原堆顶任务可能还未到触发时间，leader 线程设置超时的在 available 挂起  </span><br>        <span class="hljs-comment">//原先的 leader 等待的是原先的头节点，所以 leader 已经无效，需要将 leader 线程唤醒，  </span><br>        <span class="hljs-comment">//唤醒之后它会检查堆顶，如果堆顶任务可以被消费，则直接获取走，否则继续成为 leader 等待新堆顶任务  </span><br>        <span class="hljs-keyword">if</span> (queue[<span class="hljs-number">0</span>] == e) &#123;  <br>            <span class="hljs-comment">// 将 leader 设置为 null  </span><br>            leader = <span class="hljs-literal">null</span>;  <br>            <span class="hljs-comment">// 直接随便唤醒等待头结点的阻塞线程  </span><br>            available.signal();  <br>        &#125;  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        lock.unlock();  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>  &#x2F;&#x2F; 插入新节点后对堆进行调整，进行节点上移，保持其特性【节点的值小于子节点的值】，小顶堆  </p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">siftUp</span><span class="hljs-params">(<span class="hljs-type">int</span> k, RunnableScheduledFuture&lt;?&gt; key)</span> &#123;  <br>    <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">0</span>) &#123;  <br>        <span class="hljs-comment">// 父节点，就是堆排序  </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> (k - <span class="hljs-number">1</span>) &gt;&gt;&gt; <span class="hljs-number">1</span>;  <br>        RunnableScheduledFuture&lt;?&gt; e = queue[parent];  <br>        <span class="hljs-comment">// key 和父节点比，如果大于父节点可以直接返回，否则就继续上浮  </span><br>        <span class="hljs-keyword">if</span> (key.compareTo(e) &gt;= <span class="hljs-number">0</span>)  <br>            <span class="hljs-keyword">break</span>;  <br>        queue[k] = e;  <br>        setIndex(e, k);  <br>        k = parent;  <br>    &#125;  <br>    queue[k] = key;  <br>    setIndex(key, k);  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>poll()：非阻塞获取头结点，<strong>获取执行时间最近并且可以执行的</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// 非阻塞获取  </span><br><span class="hljs-keyword">public</span> RunnableScheduledFuture&lt;?&gt; poll() &#123;  <br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;  <br>    lock.lock();  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-comment">// 获取队头节点，因为是小顶堆  </span><br>        RunnableScheduledFuture&lt;?&gt; first = queue[<span class="hljs-number">0</span>];  <br>        <span class="hljs-comment">// 头结点为空或者的延迟时间没到返回 null  </span><br>        <span class="hljs-keyword">if</span> (first == <span class="hljs-literal">null</span> || first.getDelay(NANOSECONDS) &gt; <span class="hljs-number">0</span>)  <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>        <span class="hljs-keyword">else</span>  <br>            <span class="hljs-comment">// 头结点达到延迟时间，【尾节点成为替代节点下移调整堆结构】，返回头结点  </span><br>            <span class="hljs-keyword">return</span> finishPoll(first);  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        lock.unlock();  <br>    &#125;  <br>&#125;<br><br><span class="hljs-keyword">private</span> RunnableScheduledFuture&lt;?&gt; finishPoll(RunnableScheduledFuture&lt;?&gt; f) &#123;  <br>    <span class="hljs-comment">// 获取尾索引  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> --size;  <br>    <span class="hljs-comment">// 获取尾节点  </span><br>    RunnableScheduledFuture&lt;?&gt; x = queue[s];  <br>    <span class="hljs-comment">// 将堆结构最后一个节点占用的 slot 设置为 null，因为该节点要尝试升级成堆顶，会根据特性下调  </span><br>    queue[s] = <span class="hljs-literal">null</span>;  <br>    <span class="hljs-comment">// s == 0 说明 当前堆结构只有堆顶一个节点，此时不需要做任何的事情  </span><br>    <span class="hljs-keyword">if</span> (s != <span class="hljs-number">0</span>)  <br>        <span class="hljs-comment">// 从索引处 0 开始向下调整  </span><br>        siftDown(<span class="hljs-number">0</span>, x);  <br>    <span class="hljs-comment">// 出队的元素索引设置为 -1  </span><br>    setIndex(f, -<span class="hljs-number">1</span>);  <br>    <span class="hljs-keyword">return</span> f;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>take()：阻塞获取头节点，读取当前堆中最小的也就是触发时间最近的任务</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> RunnableScheduledFuture&lt;?&gt; take() <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;  <br>    <span class="hljs-comment">// 保证线程安全  </span><br>    lock.lockInterruptibly();  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-keyword">for</span> (;;) &#123;  <br>            <span class="hljs-comment">// 头节点  </span><br>            RunnableScheduledFuture&lt;?&gt; first = queue[<span class="hljs-number">0</span>];  <br>            <span class="hljs-keyword">if</span> (first == <span class="hljs-literal">null</span>)  <br>                <span class="hljs-comment">// 等待队列不空，直至有任务通过 offer 入队并唤醒  </span><br>                available.await();  <br>            <span class="hljs-keyword">else</span> &#123;  <br>                <span class="hljs-comment">// 获取头节点的延迟时间是否到时  </span><br>                <span class="hljs-type">long</span> <span class="hljs-variable">delay</span> <span class="hljs-operator">=</span> first.getDelay(NANOSECONDS);  <br>                <span class="hljs-keyword">if</span> (delay &lt;= <span class="hljs-number">0</span>)  <br>                    <span class="hljs-comment">// 到达触发时间，获取头节点并调整堆，重新选择延迟时间最小的节点放入头部  </span><br>                    <span class="hljs-keyword">return</span> finishPoll(first);  <br>                  <br>                <span class="hljs-comment">// 逻辑到这说明头节点的延迟时间还没到  </span><br>                first = <span class="hljs-literal">null</span>;  <br>                <span class="hljs-comment">// 说明有 leader 线程在等待获取头节点，当前线程直接去阻塞等待  </span><br>                <span class="hljs-keyword">if</span> (leader != <span class="hljs-literal">null</span>)  <br>                    available.await();  <br>                <span class="hljs-keyword">else</span> &#123;  <br>                    <span class="hljs-comment">// 没有 leader 线程，【当前线程作为leader线程，并设置头结点的延迟时间作为阻塞时间】  </span><br>                    <span class="hljs-type">Thread</span> <span class="hljs-variable">thisThread</span> <span class="hljs-operator">=</span> Thread.currentThread();  <br>                    leader = thisThread;  <br>                    <span class="hljs-keyword">try</span> &#123;  <br>                        <span class="hljs-comment">// 在条件队列 available 使用带超时的挂起（堆顶任务.time - now() 纳秒值..）  </span><br>                        available.awaitNanos(delay);  <br>                        <span class="hljs-comment">// 到达阻塞时间时，当前线程会从这里醒来来  </span><br>                    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>                        <span class="hljs-comment">// t堆顶更新，leader 置为 null，offer 方法释放锁后，  </span><br>                        <span class="hljs-comment">// 有其它线程通过 take/poll 拿到锁,读到 leader == null，然后将自身更新为leader。  </span><br>                        <span class="hljs-keyword">if</span> (leader == thisThread)  <br>                            <span class="hljs-comment">// leader 置为 null 用以接下来判断是否需要唤醒后继线程  </span><br>                            leader = <span class="hljs-literal">null</span>;  <br>                    &#125;  <br>                &#125;  <br>            &#125;  <br>        &#125;  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        <span class="hljs-comment">// 没有 leader 线程，头结点不为 null，唤醒阻塞获取头节点的线程，  </span><br>        <span class="hljs-comment">// 【如果没有这一步，就会出现有了需要执行的任务，但是没有线程去执行】  </span><br>        <span class="hljs-keyword">if</span> (leader == <span class="hljs-literal">null</span> &amp;&amp; queue[<span class="hljs-number">0</span>] != <span class="hljs-literal">null</span>)  <br>            available.signal();  <br>        lock.unlock();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>remove()：删除节点，堆移除一个元素的时间复杂度是 O(log n)，<strong>延迟任务维护了 heapIndex</strong>，直接访问的时间复杂度是 O(1)，从而可以更快的移除元素，任务在队列中被取消后会进入该逻辑</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object x)</span> &#123;  <br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;  <br>    lock.lock();  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-comment">// 查找对象在队列数组中的下标  </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> indexOf(x);  <br>        <span class="hljs-comment">// 节点不存在，返回 false  </span><br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>)  <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br><span class="hljs-comment">// 修改元素的 heapIndex，-1 代表删除  </span><br>        setIndex(queue[i], -<span class="hljs-number">1</span>);  <br>        <span class="hljs-comment">// 尾索引是长度-1  </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> --size;  <br>        <span class="hljs-comment">// 尾节点作为替代节点  </span><br>        RunnableScheduledFuture&lt;?&gt; replacement = queue[s];  <br>        queue[s] = <span class="hljs-literal">null</span>;  <br>        <span class="hljs-comment">// s == i 说明头节点就是尾节点，队列空了  </span><br>        <span class="hljs-keyword">if</span> (s != i) &#123;  <br>            <span class="hljs-comment">// 向下调整  </span><br>            siftDown(i, replacement);  <br>            <span class="hljs-comment">// 说明没发生调整  </span><br>            <span class="hljs-keyword">if</span> (queue[i] == replacement)  <br>                <span class="hljs-comment">// 上移和下移不可能同时发生，替代节点大于子节点时下移，否则上移  </span><br>                siftUp(i, replacement);  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        lock.unlock();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h4 id="成员方法-4"><a href="#成员方法-4" class="headerlink" title="成员方法"></a>成员方法</h4><h5 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a>提交任务</h5><ul><li><p>schedule()：延迟执行方法，并指定执行的时间，默认是当前时间</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> &#123;  <br>    <span class="hljs-comment">// 以零延时任务的形式实现  </span><br>    schedule(command, <span class="hljs-number">0</span>, NANOSECONDS);  <br>&#125;<br><br><span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command, <span class="hljs-type">long</span> delay, TimeUnit unit) &#123;  <br>    <span class="hljs-comment">// 判空  </span><br>    <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span> || unit == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();  <br>    <span class="hljs-comment">// 没有做任何操作，直接将 task 返回，该方法主要目的是用于子类扩展，并且【根据延迟时间设置任务触发的时间点】  </span><br>    RunnableScheduledFuture&lt;?&gt; t = decorateTask(command, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledFutureTask</span>&lt;Void&gt;(  <br>        command, <span class="hljs-literal">null</span>, triggerTime(delay, unit)));  <br>    <span class="hljs-comment">// 延迟执行  </span><br>    delayedExecute(t);  <br>    <span class="hljs-keyword">return</span> t;  <br>&#125;<br><br><span class="hljs-comment">// 返回【当前时间 + 延迟时间】，就是触发当前任务执行的时间  </span><br><span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-title function_">triggerTime</span><span class="hljs-params">(<span class="hljs-type">long</span> delay, TimeUnit unit)</span> &#123;  <br>    <span class="hljs-comment">// 设置触发的时间  </span><br>    <span class="hljs-keyword">return</span> triggerTime(unit.toNanos((delay &lt; <span class="hljs-number">0</span>) ? <span class="hljs-number">0</span> : delay));  <br>&#125;  <br><span class="hljs-type">long</span> <span class="hljs-title function_">triggerTime</span><span class="hljs-params">(<span class="hljs-type">long</span> delay)</span> &#123;  <br>    <span class="hljs-comment">// 如果 delay &lt; Long.Max_VALUE/2，则下次执行时间为当前时间 +delay  </span><br>    <span class="hljs-comment">// 否则为了避免队列中出现由于溢出导致的排序紊乱,需要调用overflowFree来修正一下delay  </span><br>    <span class="hljs-keyword">return</span> now() + ((delay &lt; (Long.MAX_VALUE &gt;&gt; <span class="hljs-number">1</span>)) ? delay : overflowFree(delay));  <br>&#125;<br></code></pre></td></tr></table></figure><p>  overflowFree 的原因：如果某个任务的 delay 为负数，说明当前可以执行（其实早该执行了）。阻塞队列中维护任务顺序是基于 compareTo 比较的，比较两个任务的顺序会用 time 相减。那么可能出现一个 delay 为正数减去另一个为负数的 delay，结果上溢为负数，则会导致 compareTo 产生错误的结果</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-title function_">overflowFree</span><span class="hljs-params">(<span class="hljs-type">long</span> delay)</span> &#123;  <br>    <span class="hljs-type">Delayed</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> (Delayed) <span class="hljs-built_in">super</span>.getQueue().peek();  <br>    <span class="hljs-keyword">if</span> (head != <span class="hljs-literal">null</span>) &#123;  <br>        <span class="hljs-type">long</span> <span class="hljs-variable">headDelay</span> <span class="hljs-operator">=</span> head.getDelay(NANOSECONDS);  <br>        <span class="hljs-comment">// 判断一下队首的delay是不是负数，如果是正数就不用管，怎么减都不会溢出  </span><br>        <span class="hljs-comment">// 否则拿当前 delay 减去队首的 delay 来比较看，如果不出现上溢，排序不会乱  </span><br><span class="hljs-comment">// 不然就把当前 delay 值给调整为 Long.MAX_VALUE + 队首 delay  </span><br>        <span class="hljs-keyword">if</span> (headDelay &lt; <span class="hljs-number">0</span> &amp;&amp; (delay - headDelay &lt; <span class="hljs-number">0</span>))  <br>            delay = Long.MAX_VALUE + headDelay;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> delay;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>scheduleAtFixedRate()：定时执行，一次任务的启动到下一次任务的启动的间隔</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, <span class="hljs-type">long</span> initialDelay, <span class="hljs-type">long</span> period,  <br>                                              TimeUnit unit) &#123;  <br>    <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span> || unit == <span class="hljs-literal">null</span>)  <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();  <br>    <span class="hljs-keyword">if</span> (period &lt;= <span class="hljs-number">0</span>)  <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();  <br>    <span class="hljs-comment">// 任务封装，【指定初始的延迟时间和周期时间】  </span><br>    ScheduledFutureTask&lt;Void&gt; sft =<span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledFutureTask</span>&lt;Void&gt;(command, <span class="hljs-literal">null</span>,  <br>                                      triggerTime(initialDelay, unit), unit.toNanos(period));  <br>    <span class="hljs-comment">// 默认返回本身  </span><br>    RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command, sft);  <br>    sft.outerTask = t;  <br>    <span class="hljs-comment">// 开始执行这个任务  </span><br>    delayedExecute(t);  <br>    <span class="hljs-keyword">return</span> t;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>scheduleWithFixedDelay()：定时执行，一次任务的结束到下一次任务的启动的间隔</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, <span class="hljs-type">long</span> initialDelay, <span class="hljs-type">long</span> delay,  <br>                                                 TimeUnit unit) &#123;  <br>    <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span> || unit == <span class="hljs-literal">null</span>)   <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();  <br>    <span class="hljs-keyword">if</span> (delay &lt;= <span class="hljs-number">0</span>)  <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();  <br>    <span class="hljs-comment">// 任务封装，【指定初始的延迟时间和周期时间】，周期时间为 - 表示是 fixed-delay 模式  </span><br>    ScheduledFutureTask&lt;Void&gt; sft = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledFutureTask</span>&lt;Void&gt;(command, <span class="hljs-literal">null</span>,  <br>                                      triggerTime(initialDelay, unit), unit.toNanos(-delay));  <br>    RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command, sft);  <br>    sft.outerTask = t;  <br>    delayedExecute(t);  <br>    <span class="hljs-keyword">return</span> t;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h5 id="运行任务"><a href="#运行任务" class="headerlink" title="运行任务"></a>运行任务</h5><ul><li><p>delayedExecute()：<strong>校验线程池状态</strong>，延迟或周期性任务的主要执行方法</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delayedExecute</span><span class="hljs-params">(RunnableScheduledFuture&lt;?&gt; task)</span> &#123;  <br>    <span class="hljs-comment">// 线程池是 SHUTDOWN 状态，需要执行拒绝策略  </span><br>    <span class="hljs-keyword">if</span> (isShutdown())  <br>        reject(task);  <br>    <span class="hljs-keyword">else</span> &#123;  <br>        <span class="hljs-comment">// 把当前任务放入阻塞队列，因为需要【获取执行时间最近的】，当前任务需要比较  </span><br>        <span class="hljs-built_in">super</span>.getQueue().add(task);  <br>        <span class="hljs-comment">// 线程池状态为 SHUTDOWN 并且不允许执行任务了，就从队列删除该任务，并设置任务的状态为取消状态  </span><br>        <span class="hljs-keyword">if</span> (isShutdown() &amp;&amp; !canRunInCurrentRunState(task.isPeriodic()) &amp;&amp; remove(task))  <br>            task.cancel(<span class="hljs-literal">false</span>);  <br>        <span class="hljs-keyword">else</span>  <br>            <span class="hljs-comment">// 可以执行  </span><br>            ensurePrestart();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>ensurePrestart()：<strong>开启线程执行任务</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// ThreadPoolExecutor#ensurePrestart  </span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">ensurePrestart</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">wc</span> <span class="hljs-operator">=</span> workerCountOf(ctl.get());  <br>    <span class="hljs-comment">// worker数目小于corePoolSize，则添加一个worker。  </span><br>    <span class="hljs-keyword">if</span> (wc &lt; corePoolSize)  <br>        <span class="hljs-comment">// 第二个参数 true 表示采用核心线程数量限制，false 表示采用 maximumPoolSize  </span><br>        addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>);  <br>    <span class="hljs-comment">// corePoolSize = 0的情况，至少开启一个线程，【担保机制】  </span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (wc == <span class="hljs-number">0</span>)  <br>        addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>canRunInCurrentRunState()：任务运行时都会被调用以校验当前状态是否可以运行任务</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">canRunInCurrentRunState</span><span class="hljs-params">(<span class="hljs-type">boolean</span> periodic)</span> &#123;  <br>    <span class="hljs-comment">// 根据是否是周期任务判断，在线程池 shutdown 后是否继续执行该任务，默认非周期任务是继续执行的  </span><br>    <span class="hljs-keyword">return</span> isRunningOrShutdown(periodic ? continueExistingPeriodicTasksAfterShutdown :  <br>                               executeExistingDelayedTasksAfterShutdown);  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>onShutdown()：删除并取消工作队列中的不需要再执行的任务</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">onShutdown</span><span class="hljs-params">()</span> &#123;  <br>    BlockingQueue&lt;Runnable&gt; q = <span class="hljs-built_in">super</span>.getQueue();  <br>    <span class="hljs-comment">// shutdown 后是否仍然执行延时任务  </span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">keepDelayed</span> <span class="hljs-operator">=</span> getExecuteExistingDelayedTasksAfterShutdownPolicy();  <br>    <span class="hljs-comment">// shutdown 后是否仍然执行周期任务  </span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">keepPeriodic</span> <span class="hljs-operator">=</span> getContinueExistingPeriodicTasksAfterShutdownPolicy();  <br>    <span class="hljs-comment">// 如果两者皆不可，则对队列中【所有任务】调用 cancel 取消并清空队列  </span><br>    <span class="hljs-keyword">if</span> (!keepDelayed &amp;&amp; !keepPeriodic) &#123;  <br>        <span class="hljs-keyword">for</span> (Object e : q.toArray())  <br>            <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> RunnableScheduledFuture&lt;?&gt;)  <br>                ((RunnableScheduledFuture&lt;?&gt;) e).cancel(<span class="hljs-literal">false</span>);  <br>        q.clear();  <br>    &#125;  <br>    <span class="hljs-keyword">else</span> &#123;  <br>        <span class="hljs-keyword">for</span> (Object e : q.toArray()) &#123;  <br>            <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> RunnableScheduledFuture) &#123;  <br>                RunnableScheduledFuture&lt;?&gt; t = (RunnableScheduledFuture&lt;?&gt;)e;  <br>                <span class="hljs-comment">// 不需要执行的任务删除并取消，已经取消的任务也需要从队列中删除  </span><br>                <span class="hljs-keyword">if</span> ((t.isPeriodic() ? !keepPeriodic : !keepDelayed) ||  <br>                    t.isCancelled()) &#123;  <br>                    <span class="hljs-keyword">if</span> (q.remove(t))  <br>                        t.cancel(<span class="hljs-literal">false</span>);  <br>                &#125;  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-comment">// 因为任务被从队列中清理掉，所以需要调用 tryTerminate 尝试【改变线程池的状态】  </span><br>    tryTerminate();  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="ForkJoin"><a href="#ForkJoin" class="headerlink" title="ForkJoin"></a>ForkJoin</h3><p>Fork&#x2F;Join：线程池的实现，体现是分治思想，适用于能够进行任务拆分的 CPU 密集型运算，用于<strong>并行计算</strong></p><p>任务拆分：将一个大任务拆分为算法上相同的小任务，直至不能拆分可以直接求解。跟递归相关的一些计算，如归并排序、斐波那契数列都可以用分治思想进行求解</p><ul><li><p>Fork&#x2F;Join 在<strong>分治的基础上加入了多线程</strong>，把每个任务的分解和合并交给不同的线程来完成，提升了运算效率</p></li><li><p>ForkJoin 使用 ForkJoinPool 来启动，是一个特殊的线程池，默认会创建与 CPU 核心数大小相同的线程池</p></li><li><p>任务有返回值继承 RecursiveTask，没有返回值继承 RecursiveAction</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    <span class="hljs-type">ForkJoinPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>(<span class="hljs-number">4</span>);  <br>    System.out.println(pool.invoke(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyTask</span>(<span class="hljs-number">5</span>)));  <br>    <span class="hljs-comment">//拆分  5 + MyTask(4) --&gt; 4 + MyTask(3) --&gt;  </span><br>&#125;  <br>  <br><span class="hljs-comment">// 1~ n 之间整数的和  </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RecursiveTask</span>&lt;Integer&gt; &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> n;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyTask</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.n = n;  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;MyTask&#123;&quot;</span> + <span class="hljs-string">&quot;n=&quot;</span> + n + <span class="hljs-string">&#x27;&#125;&#x27;</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">protected</span> Integer <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-comment">// 如果 n 已经为 1，可以求得结果了  </span><br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;  <br>            <span class="hljs-keyword">return</span> n;  <br>        &#125;  <br>        <span class="hljs-comment">// 将任务进行拆分(fork)  </span><br>        <span class="hljs-type">MyTask</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyTask</span>(n - <span class="hljs-number">1</span>);  <br>        t1.fork();  <br>        <span class="hljs-comment">// 合并(join)结果  </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> n + t1.join();  <br>        <span class="hljs-keyword">return</span> result;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>继续拆分优化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RecursiveTask</span>&lt;Integer&gt; &#123;  <br>    <span class="hljs-type">int</span> begin;  <br>    <span class="hljs-type">int</span> end;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AddTask</span><span class="hljs-params">(<span class="hljs-type">int</span> begin, <span class="hljs-type">int</span> end)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.begin = begin;  <br>        <span class="hljs-built_in">this</span>.end = end;  <br>    &#125;  <br>      <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&quot;</span> + begin + <span class="hljs-string">&quot;,&quot;</span> + end + <span class="hljs-string">&#x27;&#125;&#x27;</span>;  <br>    &#125;  <br>      <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">protected</span> Integer <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-comment">// 5, 5  </span><br>        <span class="hljs-keyword">if</span> (begin == end) &#123;  <br>            <span class="hljs-keyword">return</span> begin;  <br>        &#125;  <br>        <span class="hljs-comment">// 4, 5  防止多余的拆分  提高效率  </span><br>        <span class="hljs-keyword">if</span> (end - begin == <span class="hljs-number">1</span>) &#123;  <br>            <span class="hljs-keyword">return</span> end + begin;  <br>        &#125;  <br>        <span class="hljs-comment">// 1 5  </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (end + begin) / <span class="hljs-number">2</span>; <span class="hljs-comment">// 3  </span><br>        <span class="hljs-type">AddTask</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AddTask</span>(begin, mid); <span class="hljs-comment">// 1,3  </span><br>        t1.fork();  <br>        <span class="hljs-type">AddTask</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AddTask</span>(mid + <span class="hljs-number">1</span>, end); <span class="hljs-comment">// 4,5  </span><br>        t2.fork();  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> t1.join() + t2.join();  <br>        <span class="hljs-keyword">return</span> result;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>ForkJoinPool 实现了<strong>工作窃取算法</strong>来提高 CPU 的利用率：</p><ul><li><p>每个线程都维护了一个<strong>双端队列</strong>，用来存储需要执行的任务</p></li><li><p>工作窃取算法允许空闲的线程从其它线程的双端队列中窃取一个任务来执行</p></li><li><p>窃取的必须是<strong>最晚的任务</strong>，避免和队列所属线程发生竞争，但是队列中只有一个任务时还是会发生竞争</p></li></ul><hr><h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><p>享元模式（Flyweight pattern）： 用于减少创建对象的数量，以减少内存占用和提高性能，这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式</p><p>异步模式：让有限的工作线程（Worker Thread）来轮流异步处理无限多的任务，也可将其归类为分工模式，典型实现就是线程池</p><p>工作机制：享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象</p><p>自定义连接池：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    <span class="hljs-type">Pool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pool</span>(<span class="hljs-number">2</span>);  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;  <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>            <span class="hljs-type">Connection</span> <span class="hljs-variable">con</span> <span class="hljs-operator">=</span> pool.borrow();  <br>            <span class="hljs-keyword">try</span> &#123;  <br>                Thread.sleep(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">1000</span>));  <br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>                e.printStackTrace();  <br>            &#125;  <br>            pool.free(con);  <br>        &#125;).start();  <br>    &#125;  <br>&#125;  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pool</span> &#123;  <br>    <span class="hljs-comment">//连接池的大小  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> poolSize;  <br>    <span class="hljs-comment">//连接对象的数组  </span><br>    <span class="hljs-keyword">private</span> Connection[] connections;  <br>    <span class="hljs-comment">//连接状态数组 0表示空闲  1表示繁忙  </span><br>    <span class="hljs-keyword">private</span> AtomicIntegerArray states;  <span class="hljs-comment">//int[] -&gt; AtomicIntegerArray  </span><br>  <br>    <span class="hljs-comment">//构造方法  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Pool</span><span class="hljs-params">(<span class="hljs-type">int</span> poolSize)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.poolSize = poolSize;  <br>        <span class="hljs-built_in">this</span>.connections = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Connection</span>[poolSize];  <br>        <span class="hljs-built_in">this</span>.states = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicIntegerArray</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[poolSize]);  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;  <br>            connections[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MockConnection</span>(<span class="hljs-string">&quot;连接&quot;</span> + (i + <span class="hljs-number">1</span>));  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//使用连接  </span><br>    <span class="hljs-keyword">public</span> Connection <span class="hljs-title function_">borrow</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;  <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;  <br>                <span class="hljs-keyword">if</span> (states.get(i) == <span class="hljs-number">0</span>) &#123;  <br>                    <span class="hljs-keyword">if</span> (states.compareAndSet(i, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;  <br>                        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; borrow &quot;</span> +  connections[i]);  <br>                        <span class="hljs-keyword">return</span> connections[i];  <br>                    &#125;  <br>                &#125;  <br>            &#125;  <br>            <span class="hljs-comment">//如果没有空闲连接，当前线程等待  </span><br>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;  <br>                <span class="hljs-keyword">try</span> &#123;  <br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; wait...&quot;</span>);  <br>                    <span class="hljs-built_in">this</span>.wait();  <br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>                    e.printStackTrace();  <br>                &#125;  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//归还连接  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">free</span><span class="hljs-params">(Connection con)</span> &#123;  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;  <br>            <span class="hljs-keyword">if</span> (connections[i] == con) &#123;<span class="hljs-comment">//判断是否是同一个对象  </span><br>                states.set(i, <span class="hljs-number">0</span>);<span class="hljs-comment">//不用cas的原因是只会有一个线程使用该连接  </span><br>                <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;  <br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; free &quot;</span> + con);  <br>                    <span class="hljs-built_in">this</span>.notifyAll();  <br>                &#125;  <br>                <span class="hljs-keyword">break</span>;  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>  <br>&#125;  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MockConnection</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Connection</span> &#123;  <br>    <span class="hljs-keyword">private</span> String name;  <br>    <span class="hljs-comment">//.....  </span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="同步器"><a href="#同步器" class="headerlink" title="同步器"></a>同步器</h2><h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><h4 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h4><p>AQS：AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架，许多同步类实现都依赖于该同步器</p><p>AQS 用状态属性来表示资源的状态（分<strong>独占模式和共享模式</strong>），子类需要定义如何维护这个状态，控制如何获取锁和释放锁</p><ul><li><p>独占模式是只有一个线程能够访问资源，如 ReentrantLock</p></li><li><p>共享模式允许多个线程访问资源，如 Semaphore，ReentrantReadWriteLock 是组合式</p></li></ul><p>AQS 核心思想：</p><ul><li><p>如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置锁定状态</p></li><li><p>请求的共享资源被占用，AQS 用队列实现线程阻塞等待以及被唤醒时锁分配的机制，将暂时获取不到锁的线程加入到队列中</p><p>  CLH 是一种基于单向链表的<strong>高性能、公平的自旋锁</strong>，AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配</p><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041843050.png"></p></li></ul><hr><h4 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h4><p>设计原理：</p><ul><li><p>获取锁：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(state 状态不允许获取) &#123;<span class="hljs-comment">// tryAcquire(arg)  </span><br>       <span class="hljs-keyword">if</span>(队列中还没有此线程) &#123;  <br>           入队并阻塞 park  <br>       &#125;  <br>   &#125;  <br>   当前线程出队<br></code></pre></td></tr></table></figure></li><li><p>释放锁：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">if</span>(state 状态允许了) &#123;<span class="hljs-comment">// tryRelease(arg)  </span><br>恢复阻塞的线程(s) unpark  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>AbstractQueuedSynchronizer 中 state 设计：</p><ul><li><p>state 使用了 32bit int 来维护同步状态，独占模式 0 表示未加锁状态，大于 0 表示已经加锁状态</p><p>  <code>private volatile int state;</code></p></li><li><p>state <strong>使用 volatile 修饰配合 cas</strong> 保证其修改时的原子性</p></li><li><p>state 表示<strong>线程重入的次数（独占模式）或者剩余许可数（共享模式）</strong></p></li><li><p>state API：</p><ul><li><p><code>protected final int getState()</code>：获取 state 状态</p></li><li><p><code>protected final void setState(int newState)</code>：设置 state 状态</p></li><li><p><code>protected final boolean compareAndSetState(int expect,int update)</code>：<strong>CAS</strong> 安全设置 state</p></li></ul></li></ul><p>封装线程的 Node 节点中 waitstate 设计：</p><ul><li><p>使用 <strong>volatile 修饰配合 CAS</strong> 保证其修改时的原子性</p></li><li><p>表示 Node 节点的状态，有以下几种状态：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// 默认为 0  </span><br><span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> waitStatus;  <br><span class="hljs-comment">// 由于超时或中断，此节点被取消，不会再改变状态  </span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CANCELLED</span> <span class="hljs-operator">=</span>  <span class="hljs-number">1</span>;  <br><span class="hljs-comment">// 此节点后面的节点已（或即将）被阻止（通过park），【当前节点在释放或取消时必须唤醒后面的节点】  </span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SIGNAL</span>    <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;  <br><span class="hljs-comment">// 此节点当前在条件队列中  </span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CONDITION</span> <span class="hljs-operator">=</span> -<span class="hljs-number">2</span>;  <br><span class="hljs-comment">// 将releaseShared传播到其他节点  </span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PROPAGATE</span> <span class="hljs-operator">=</span> -<span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure></li></ul><p>阻塞恢复设计：</p><ul><li><p>使用 park &amp; unpark 来实现线程的暂停和恢复，因为命令的先后顺序不影响结果</p></li><li><p>park &amp; unpark 是针对线程的，而不是针对同步器的，因此控制粒度更为精细</p></li><li><p>park 线程可以通过 interrupt 打断</p></li></ul><p>队列设计：</p><ul><li><p>使用了 FIFO 先入先出队列，并不支持优先级队列，<strong>同步队列是双向链表，便于出队入队</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// 头结点，指向哑元节点  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node head;  <br><span class="hljs-comment">// 阻塞队列的尾节点，阻塞队列不包含头结点，从 head.next → tail 认为是阻塞队列  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node tail;  <br>  <br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;  <br>    <span class="hljs-comment">// 枚举：共享模式  </span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">SHARED</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();  <br>    <span class="hljs-comment">// 枚举：独占模式  </span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">EXCLUSIVE</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;  <br>    <span class="hljs-comment">// node 需要构建成 FIFO 队列，prev 指向前继节点  </span><br>    <span class="hljs-keyword">volatile</span> Node prev;  <br>    <span class="hljs-comment">// next 指向后继节点  </span><br>    <span class="hljs-keyword">volatile</span> Node next;  <br>    <span class="hljs-comment">// 当前 node 封装的线程  </span><br>    <span class="hljs-keyword">volatile</span> Thread thread;  <br>    <span class="hljs-comment">// 条件队列是单向链表，只有后继指针，条件队列使用该属性  </span><br>    Node nextWaiter;  <br>&#125;<br></code></pre></td></tr></table></figure><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041846265.png"></p></li><li><p>条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet，<strong>条件队列是单向链表</strong></p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConditionObject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Condition</span>, java.io.Serializable &#123;  <br>    <span class="hljs-comment">// 指向条件队列的第一个 node 节点  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node firstWaiter;  <br>    <span class="hljs-comment">// 指向条件队列的最后一个 node 节点  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node lastWaiter;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h4 id="模板对象"><a href="#模板对象" class="headerlink" title="模板对象"></a>模板对象</h4><p>同步器的设计是基于模板方法模式，该模式是基于继承的，主要是为了在不改变模板结构的前提下在子类中重新定义模板中的内容以实现复用代码</p><ul><li><p>使用者继承 <code>AbstractQueuedSynchronizer</code> 并重写指定的方法</p></li><li><p>将 AQS 组合在自定义同步组件的实现中，并调用其模板方法，这些模板方法会调用使用者重写的方法</p></li></ul><p>AQS 使用了模板方法模式，自定义同步器时需要重写下面几个 AQS 提供的模板方法：</p><p>isHeldExclusively()&#x2F;&#x2F;该线程是否正在独占资源。只有用到condition才需要去实现它<br>tryAcquire(int)&#x2F;&#x2F;独占方式。尝试获取资源，成功则返回true，失败则返回false<br>tryRelease(int)&#x2F;&#x2F;独占方式。尝试释放资源，成功则返回true，失败则返回false<br>tryAcquireShared(int)&#x2F;&#x2F;共享方式。尝试获取资源。负数表示失败；0表示成功但没有剩余可用资源；正数表示成功且有剩余资源<br>tryReleaseShared(int)&#x2F;&#x2F;共享方式。尝试释放资源，成功则返回true，失败则返回false</p><ul><li><p>默认情况下，每个方法都抛出 <code>UnsupportedOperationException</code></p></li><li><p>这些方法的实现必须是内部线程安全的</p></li><li><p>AQS 类中的其他方法都是 final ，所以无法被其他类使用，只有这几个方法可以被其他类使用</p></li></ul><hr><h4 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h4><p>自定义一个不可重入锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Lock</span> &#123;  <br>    <span class="hljs-comment">//独占锁 不可重入  </span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">MySync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;  <br>        <span class="hljs-meta">@Override</span>  <br>        <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;  <br>            <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;  <br>                <span class="hljs-comment">// 加上锁 设置 owner 为当前线程  </span><br>                setExclusiveOwnerThread(Thread.currentThread());  <br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>            &#125;  <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>        &#125;  <br>        <span class="hljs-meta">@Override</span>   <span class="hljs-comment">//解锁  </span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;  <br>            setExclusiveOwnerThread(<span class="hljs-literal">null</span>);  <br>            setState(<span class="hljs-number">0</span>);<span class="hljs-comment">//volatile 修饰的变量放在后面，防止指令重排  </span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>        &#125;  <br>        <span class="hljs-meta">@Override</span>   <span class="hljs-comment">//是否持有独占锁  </span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHeldExclusively</span><span class="hljs-params">()</span> &#123;  <br>            <span class="hljs-keyword">return</span> getState() == <span class="hljs-number">1</span>;  <br>        &#125;  <br>        <span class="hljs-keyword">public</span> Condition <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span> &#123;  <br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConditionObject</span>();  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">MySync</span> <span class="hljs-variable">sync</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MySync</span>();  <br>  <br>    <span class="hljs-meta">@Override</span>   <span class="hljs-comment">//加锁（不成功进入等待队列等待）  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;  <br>        sync.acquire(<span class="hljs-number">1</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>   <span class="hljs-comment">//加锁 可打断  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>        sync.acquireInterruptibly(<span class="hljs-number">1</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>   <span class="hljs-comment">//尝试加锁，尝试一次  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> sync.tryAcquire(<span class="hljs-number">1</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>   <span class="hljs-comment">//尝试加锁，带超时  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>        <span class="hljs-keyword">return</span> sync.tryAcquireNanos(<span class="hljs-number">1</span>, unit.toNanos(time));  <br>    &#125;  <br>      <br>    <span class="hljs-meta">@Override</span>   <span class="hljs-comment">//解锁  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;  <br>        sync.release(<span class="hljs-number">1</span>);  <br>    &#125;  <br>      <br>    <span class="hljs-meta">@Override</span>   <span class="hljs-comment">//条件变量  </span><br>    <span class="hljs-keyword">public</span> Condition <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> sync.newCondition();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><h4 id="锁对比"><a href="#锁对比" class="headerlink" title="锁对比"></a>锁对比</h4><p>ReentrantLock 相对于 synchronized 具备如下特点：</p><ol><li><p>锁的实现：synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的</p></li><li><p>性能：新版本 Java 对 synchronized 进行了很多优化，synchronized 与 ReentrantLock 大致相同</p></li><li><p>使用：ReentrantLock 需要手动解锁，synchronized 执行完代码块自动解锁</p></li><li><p><strong>可中断</strong>：ReentrantLock 可中断，而 synchronized 不行</p></li><li><p><strong>公平锁</strong>：公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁</p><ul><li><p>ReentrantLock 可以设置公平锁，synchronized 中的锁是非公平的</p></li><li><p>不公平锁的含义是阻塞队列内公平，队列外非公平</p></li></ul></li><li><p>锁超时：尝试获取锁，超时获取不到直接放弃，不进入阻塞队列</p><ul><li>ReentrantLock 可以设置超时时间，synchronized 会一直等待</li></ul></li><li><p>锁绑定多个条件：一个 ReentrantLock 可以同时绑定多个 Condition 对象，更细粒度的唤醒线程</p></li><li><p>两者都是可重入锁</p></li></ol><hr><h4 id="使用锁"><a href="#使用锁" class="headerlink" title="使用锁"></a>使用锁</h4><p>构造方法：<code>ReentrantLock lock = new ReentrantLock();</code></p><p>ReentrantLock 类 API：</p><ul><li><p><code>public void lock()</code>：获得锁</p><ul><li><p>如果锁没有被另一个线程占用，则将锁定计数设置为 1</p></li><li><p>如果当前线程已经保持锁定，则保持计数增加 1</p></li><li><p>如果锁被另一个线程保持，则当前线程被禁用线程调度，并且在锁定已被获取之前处于休眠状态</p></li></ul></li><li><p><code>public void unlock()</code>：尝试释放锁</p><ul><li><p>如果当前线程是该锁的持有者，则保持计数递减</p></li><li><p>如果保持计数现在为零，则锁定被释放</p></li><li><p>如果当前线程不是该锁的持有者，则抛出异常</p></li></ul></li></ul><p>基本语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取锁  </span><br>reentrantLock.lock();  <br><span class="hljs-keyword">try</span> &#123;  <br>    <span class="hljs-comment">// 临界区  </span><br>&#125; <span class="hljs-keyword">finally</span> &#123;  <br><span class="hljs-comment">// 释放锁  </span><br>reentrantLock.unlock();  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><h5 id="基本使用-2"><a href="#基本使用-2" class="headerlink" title="基本使用"></a>基本使用</h5><p>构造方法：<code>ReentrantLock lock = new ReentrantLock(true)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">(<span class="hljs-type">boolean</span> fair)</span> &#123;  <br>    sync = fair ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">FairSync</span>() : <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();  <br>&#125;<br><br><span class="hljs-comment">//ReentrantLock 默认是不公平的：</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">()</span> &#123;  <br>    sync = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();  <br>&#125;<br><br><span class="hljs-comment">//说明：公平锁一般没有必要，会降低并发度</span><br></code></pre></td></tr></table></figure><hr><h5 id="非公原理"><a href="#非公原理" class="headerlink" title="非公原理"></a>非公原理</h5><h6 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h6><p>NonfairSync 继承自 AQS</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;  <br>    sync.lock();  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>没有竞争：ExclusiveOwnerThread 属于 Thread-0，state 设置为 1</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// ReentrantLock.NonfairSync#lock  </span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">// 用 cas 尝试（仅尝试一次）将 state 从 0 改为 1, 如果成功表示【获得了独占锁】  </span><br>    <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))  <br>        <span class="hljs-comment">// 设置当前线程为独占线程  </span><br>        setExclusiveOwnerThread(Thread.currentThread());  <br>    <span class="hljs-keyword">else</span>  <br>        acquire(<span class="hljs-number">1</span>);<span class="hljs-comment">//失败进入  </span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>第一个竞争出现：Thread-1 执行，CAS 尝试将 state 由 0 改为 1，结果失败（第一次），进入 acquire 逻辑</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// AbstractQueuedSynchronizer#acquire  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;  <br>    <span class="hljs-comment">// tryAcquire 尝试获取锁失败时, 会调用 addWaiter 将当前线程封装成node入队，acquireQueued 阻塞当前线程，  </span><br>    <span class="hljs-comment">// acquireQueued 返回 true 表示挂起过程中线程被中断唤醒过，false 表示未被中断过  </span><br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))  <br>        <span class="hljs-comment">// 如果线程被中断了逻辑来到这，完成一次真正的打断效果  </span><br>        selfInterrupt();  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041851334.png"></p><ul><li><p>进入 tryAcquire 尝试获取锁逻辑，这时 state 已经是1，结果仍然失败（第二次），加锁成功有两种情况：</p><ul><li><p>当前 AQS 处于无锁状态</p></li><li><p>加锁线程就是当前线程，说明发生了锁重入</p></li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// ReentrantLock.NonfairSync#tryAcquire  </span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;  <br>    <span class="hljs-keyword">return</span> nonfairTryAcquire(acquires);  <br>&#125;  <br><span class="hljs-comment">// 抢占成功返回 true，抢占失败返回 false  </span><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">nonfairTryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;  <br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();  <br>    <span class="hljs-comment">// state 值  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();  <br>    <span class="hljs-comment">// 条件成立说明当前处于【无锁状态】  </span><br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;  <br>        <span class="hljs-comment">//如果还没有获得锁，尝试用cas获得，这里体现非公平性: 不去检查 AQS 队列是否有阻塞线程直接获取锁          </span><br>    <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;  <br>            <span class="hljs-comment">// 获取锁成功设置当前线程为独占锁线程。  </span><br>            setExclusiveOwnerThread(current);  <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>         &#125;      <br>&#125;      <br>   <span class="hljs-comment">// 如果已经有线程获得了锁, 独占锁线程还是当前线程, 表示【发生了锁重入】  </span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;  <br>        <span class="hljs-comment">// 更新锁重入的值  </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c + acquires;  <br>        <span class="hljs-comment">// 越界判断，当重入的深度很深时，会导致 nextc &lt; 0，int值达到最大之后再 + 1 变负数  </span><br>        <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow  </span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);  <br>        <span class="hljs-comment">// 更新 state 的值，这里不使用 cas 是因为当前线程正在持有锁，所以这里的操作相当于在一个管程内  </span><br>        setState(nextc);  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    &#125;  <br>    <span class="hljs-comment">// 获取失败  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>接下来进入 addWaiter 逻辑，构造 Node 队列（不是阻塞队列），前置条件是当前线程获取锁失败，说明有线程占用了锁</p><ul><li><p>图中黄色三角表示该 Node 的 waitStatus 状态，其中 0 为默认<strong>正常状态</strong></p></li><li><p>Node 的创建是懒惰的，其中第一个 Node 称为 <strong>Dummy（哑元）或哨兵</strong>，用来占位，并不关联线程</p></li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// AbstractQueuedSynchronizer#addWaiter，返回当前线程的 node 节点  </span><br><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">addWaiter</span><span class="hljs-params">(Node mode)</span> &#123;  <br>    <span class="hljs-comment">// 将当前线程关联到一个 Node 对象上, 模式为独占模式     </span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Thread.currentThread(), mode);  <br>    <span class="hljs-type">Node</span> <span class="hljs-variable">pred</span> <span class="hljs-operator">=</span> tail;  <br>    <span class="hljs-comment">// 快速入队，如果 tail 不为 null，说明存在队列  </span><br>    <span class="hljs-keyword">if</span> (pred != <span class="hljs-literal">null</span>) &#123;  <br>        <span class="hljs-comment">// 将当前节点的前驱节点指向 尾节点  </span><br>        node.prev = pred;  <br>        <span class="hljs-comment">// 通过 cas 将 Node 对象加入 AQS 队列，成为尾节点，【尾插法】  </span><br>        <span class="hljs-keyword">if</span> (compareAndSetTail(pred, node)) &#123;  <br>            pred.next = node;<span class="hljs-comment">// 双向链表  </span><br>            <span class="hljs-keyword">return</span> node;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-comment">// 初始时队列为空，或者 CAS 失败进入这里  </span><br>    enq(node);  <br>    <span class="hljs-keyword">return</span> node;  <br>&#125;<br><br><span class="hljs-comment">// AbstractQueuedSynchronizer#enq  </span><br><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">enq</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node)</span> &#123;  <br>    <span class="hljs-comment">// 自旋入队，必须入队成功才结束循环  </span><br>    <span class="hljs-keyword">for</span> (;;) &#123;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail;  <br>        <span class="hljs-comment">// 说明当前锁被占用，且当前线程可能是【第一个获取锁失败】的线程，【还没有建立队列】  </span><br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-comment">// 设置一个【哑元节点】，头尾指针都指向该节点  </span><br>            <span class="hljs-keyword">if</span> (compareAndSetHead(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>()))  <br>                tail = head;  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            <span class="hljs-comment">// 自旋到这，普通入队方式，首先赋值尾节点的前驱节点【尾插法】  </span><br>            node.prev = t;  <br>            <span class="hljs-comment">// 【在设置完尾节点后，才更新的原始尾节点的后继节点，所以此时从前往后遍历会丢失尾节点】  </span><br>            <span class="hljs-keyword">if</span> (compareAndSetTail(t, node)) &#123;  <br>                <span class="hljs-comment">//【此时 t.next  = null，并且这里已经 CAS 结束，线程并不是安全的】  </span><br>                t.next = node;  <br>                <span class="hljs-keyword">return</span> t;<span class="hljs-comment">// 返回当前 node 的前驱节点  </span><br>            &#125;  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041853324.png">  </p></li><li><p>线程节点加入队列成功，进入 AbstractQueuedSynchronizer#acquireQueued 逻辑阻塞线程</p><ul><li><p>acquireQueued 会在一个自旋中不断尝试获得锁，失败后进入 park 阻塞</p></li><li><p>如果当前线程是在 head 节点后，会再次 tryAcquire 尝试获取锁，state 仍为 1 则失败（第三次）</p></li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-type">int</span> arg)</span> &#123;  <br>    <span class="hljs-comment">// true 表示当前线程抢占锁失败，false 表示成功  </span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-comment">// 中断标记，表示当前线程是否被中断  </span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;  <br>        <span class="hljs-keyword">for</span> (;;) &#123;  <br>            <span class="hljs-comment">// 获得当前线程节点的前驱节点  </span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();  <br>            <span class="hljs-comment">// 前驱节点是 head, FIFO 队列的特性表示轮到当前线程可以去获取锁  </span><br>            <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;  <br>                <span class="hljs-comment">// 获取成功, 设置当前线程自己的 node 为 head  </span><br>                setHead(node);  <br>                p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC  </span><br>                <span class="hljs-comment">// 表示抢占锁成功  </span><br>                failed = <span class="hljs-literal">false</span>;  <br>                <span class="hljs-comment">// 返回当前线程是否被中断  </span><br>                <span class="hljs-keyword">return</span> interrupted;  <br>            &#125;  <br>            <span class="hljs-comment">// 判断是否应当 park，返回 false 后需要新一轮的循环，返回 true 进入条件二阻塞线程  </span><br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())  <br>                <span class="hljs-comment">// 条件二返回结果是当前线程是否被打断，没有被打断返回 false 不进入这里的逻辑  </span><br>                <span class="hljs-comment">// 【就算被打断了，也会继续循环，并不会返回】  </span><br>                interrupted = <span class="hljs-literal">true</span>;  <br>        &#125;  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        <span class="hljs-comment">// 【可打断模式下才会进入该逻辑】  </span><br>        <span class="hljs-keyword">if</span> (failed)  <br>            cancelAcquire(node);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>进入 shouldParkAfterFailedAcquire 逻辑，<strong>将前驱 node 的 waitStatus 改为 -1</strong>，返回 false；waitStatus 为 -1 的节点用来唤醒下一个节点</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">shouldParkAfterFailedAcquire</span><span class="hljs-params">(Node pred, Node node)</span> &#123;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> pred.waitStatus;  <br>    <span class="hljs-comment">// 表示前置节点是个可以唤醒当前节点的节点，返回 true  </span><br>    <span class="hljs-keyword">if</span> (ws == Node.SIGNAL)  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    <span class="hljs-comment">// 前置节点的状态处于取消状态，需要【删除前面所有取消的节点】, 返回到外层循环重试  </span><br>    <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span>) &#123;  <br>        <span class="hljs-keyword">do</span> &#123;  <br>            node.prev = pred = pred.prev;  <br>        &#125; <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>);  <br>        <span class="hljs-comment">// 获取到非取消的节点，连接上当前节点  </span><br>        pred.next = node;  <br>    <span class="hljs-comment">// 默认情况下 node 的 waitStatus 是 0，进入这里的逻辑  </span><br>    &#125; <span class="hljs-keyword">else</span> &#123;  <br>        <span class="hljs-comment">// 【设置上一个节点状态为 Node.SIGNAL】，返回外层循环重试  </span><br>        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);  <br>    &#125;  <br>    <span class="hljs-comment">// 返回不应该 park，再次尝试一次  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>shouldParkAfterFailedAcquire 执行完毕回到 acquireQueued ，再次 tryAcquire 尝试获取锁，这时 state 仍为 1 获取失败（第四次）</p></li><li><p>当再次进入 shouldParkAfterFailedAcquire 时，这时其前驱 node 的 waitStatus 已经是 -1 了，返回 true</p></li><li><p>进入 parkAndCheckInterrupt， Thread-1 park（灰色表示）</p></li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">parkAndCheckInterrupt</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">// 阻塞当前线程，如果打断标记已经是 true, 则 park 会失效  </span><br>    LockSupport.park(<span class="hljs-built_in">this</span>);  <br>    <span class="hljs-comment">// 判断当前线程是否被打断，清除打断标记  </span><br>    <span class="hljs-keyword">return</span> Thread.interrupted();  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>再有多个线程经历竞争失败后：</p><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041853649.png"></p></li></ul><hr><h6 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h6><p>ReentrantLock#unlock：释放锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;  <br>    sync.release(<span class="hljs-number">1</span>);  <br>&#125;<br></code></pre></td></tr></table></figure><p>Thread-0 释放锁，进入 release 流程</p><ul><li><p>进入 tryRelease，设置 exclusiveOwnerThread 为 null，state &#x3D; 0</p></li><li><p>当前队列不为 null，并且 head 的 waitStatus &#x3D; -1，进入 unparkSuccessor</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// AbstractQueuedSynchronizer#release  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;  <br>    <span class="hljs-comment">// 尝试释放锁，tryRelease 返回 true 表示当前线程已经【完全释放锁，重入的释放了】  </span><br>    <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;  <br>        <span class="hljs-comment">// 队列头节点  </span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;  <br>        <span class="hljs-comment">// 头节点什么时候是空？没有发生锁竞争，没有竞争线程创建哑元节点  </span><br>        <span class="hljs-comment">// 条件成立说明阻塞队列有等待线程，需要唤醒 head 节点后面的线程  </span><br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)  <br>            unparkSuccessor(h);  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    &#125;      <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>  &#x2F;&#x2F; ReentrantLock.Sync#tryRelease  </p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;  <br>    <span class="hljs-comment">// 减去释放的值，可能重入  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState() - releases;  <br>    <span class="hljs-comment">// 如果当前线程不是持有锁的线程直接报错  </span><br>    <span class="hljs-keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())  <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();  <br>    <span class="hljs-comment">// 是否已经完全释放锁  </span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">free</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;  <br>    <span class="hljs-comment">// 支持锁重入, 只有 state 减为 0, 才完全释放锁成功  </span><br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;  <br>        free = <span class="hljs-literal">true</span>;  <br>        setExclusiveOwnerThread(<span class="hljs-literal">null</span>);  <br>    &#125;  <br>    <span class="hljs-comment">// 当前线程就是持有锁线程，所以可以直接更新锁，不需要使用 CAS  </span><br>    setState(c);  <br>    <span class="hljs-keyword">return</span> free;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>进入 AbstractQueuedSynchronizer#unparkSuccessor 方法，唤醒当前节点的后继节点</p><ul><li><p>找到队列中距离 head 最近的一个没取消的 Node，unpark 恢复其运行，本例中即为 Thread-1</p></li><li><p>回到 Thread-1 的 acquireQueued 流程</p></li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unparkSuccessor</span><span class="hljs-params">(Node node)</span> &#123;  <br>    <span class="hljs-comment">// 当前节点的状态  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> node.waitStatus;      <br>    <span class="hljs-keyword">if</span> (ws &lt; <span class="hljs-number">0</span>)          <br>        <span class="hljs-comment">// 【尝试重置状态为 0】，因为当前节点要完成对后续节点的唤醒任务了，不需要 -1 了  </span><br>        compareAndSetWaitStatus(node, ws, <span class="hljs-number">0</span>);      <br>    <span class="hljs-comment">// 找到需要 unpark 的节点，当前节点的下一个      </span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;      <br>    <span class="hljs-comment">// 已取消的节点不能唤醒，需要找到距离头节点最近的非取消的节点  </span><br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.waitStatus &gt; <span class="hljs-number">0</span>) &#123;  <br>        s = <span class="hljs-literal">null</span>;  <br>        <span class="hljs-comment">// AQS 队列【从后至前】找需要 unpark 的节点，直到 t == 当前的 node 为止，找不到就不唤醒了  </span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail; t != <span class="hljs-literal">null</span> &amp;&amp; t != node; t = t.prev)  <br>            <span class="hljs-comment">// 说明当前线程状态需要被唤醒  </span><br>            <span class="hljs-keyword">if</span> (t.waitStatus &lt;= <span class="hljs-number">0</span>)  <br>                <span class="hljs-comment">// 置换引用  </span><br>                s = t;  <br>    &#125;  <br>    <span class="hljs-comment">// 【找到合适的可以被唤醒的 node，则唤醒线程】  </span><br>    <span class="hljs-keyword">if</span> (s != <span class="hljs-literal">null</span>)  <br>        LockSupport.unpark(s.thread);  <br>&#125;<br></code></pre></td></tr></table></figure><p>  <strong>从后向前的唤醒的原因</strong>：enq 方法中，节点是尾插法，首先赋值的是尾节点的前驱节点，此时前驱节点的 next 并没有指向尾节点，从前遍历会丢失尾节点  </p></li><li><p>唤醒的线程会从 park 位置开始执行，如果加锁成功（没有竞争），会设置</p><ul><li><p>exclusiveOwnerThread 为 Thread-1，state &#x3D; 1</p></li><li><p>head 指向刚刚 Thread-1 所在的 Node，该 Node 会清空 Thread</p></li><li><p>原本的 head 因为从链表断开，而可被垃圾回收（图中有错误，原来的头节点的 waitStatus 被改为 0 了）</p></li></ul><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041855500.png">  </p></li><li><p>如果这时有其它线程来竞争<strong>（非公平）</strong>，例如这时有 Thread-4 来了并抢占了锁</p><ul><li><p>Thread-4 被设置为 exclusiveOwnerThread，state &#x3D; 1</p></li><li><p>Thread-1 再次进入 acquireQueued 流程，获取锁失败，重新进入 park 阻塞</p></li></ul><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041856156.png"></p></li></ul><hr><h5 id="公平原理"><a href="#公平原理" class="headerlink" title="公平原理"></a>公平原理</h5><p>与非公平锁主要区别在于 tryAcquire 方法：先检查 AQS 队列中是否有前驱节点，没有才去 CAS 竞争</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> -<span class="hljs-number">3000897897090466540L</span>;  <br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;  <br>        acquire(<span class="hljs-number">1</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;  <br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();  <br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;  <br>            <span class="hljs-comment">// 先检查 AQS 队列中是否有前驱节点, 没有(false)才去竞争  </span><br>            <span class="hljs-keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;  <br>                compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;  <br>                setExclusiveOwnerThread(current);  <br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-comment">// 锁重入  </span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>    &#125;  <br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasQueuedPredecessors</span><span class="hljs-params">()</span> &#123;      <br>    <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail;  <br>    <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;  <br>    Node s;      <br>    <span class="hljs-comment">// 头尾指向一个节点，链表为空，返回false  </span><br>    <span class="hljs-keyword">return</span> h != t &amp;&amp;  <br>        <span class="hljs-comment">// 头尾之间有节点，判断头节点的下一个是不是空  </span><br>        <span class="hljs-comment">// 不是空进入最后的判断，第二个节点的线程是否是本线程，不是返回 true，表示当前节点有前驱节点  </span><br>        ((s = h.next) == <span class="hljs-literal">null</span> || s.thread != Thread.currentThread());  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h4><p>可重入是指同一个线程如果首次获得了这把锁，那么它是这把锁的拥有者，因此有权利再次获取这把锁，如果不可重入锁，那么第二次获得锁时，自己也会被锁挡住，直接造成死锁</p><p>源码解析参考：<code>nonfairTryAcquire(int acquires))</code> 和 <code>tryRelease(int releases)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">static</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    method1();  <br>&#125;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span> &#123;  <br>    lock.lock();  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; execute method1&quot;</span>);  <br>        method2();  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        lock.unlock();  <br>    &#125;  <br>&#125;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span> &#123;  <br>    lock.lock();  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; execute method2&quot;</span>);  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        lock.unlock();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>在 Lock 方法加两把锁会是什么情况呢？</p><ul><li><p>加锁两次解锁两次：正常执行</p></li><li><p>加锁两次解锁一次：程序直接卡死，线程不能出来，也就说明<strong>申请几把锁，最后需要解除几把锁</strong></p></li><li><p>加锁一次解锁两次：运行程序会直接报错</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getLock</span><span class="hljs-params">()</span> &#123;  <br>    lock.lock();  <br>    lock.lock();  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t get Lock&quot;</span>);  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        lock.unlock();  <br>        <span class="hljs-comment">//lock.unlock();  </span><br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="可打断"><a href="#可打断" class="headerlink" title="可打断"></a>可打断</h4><h5 id="基本使用-3"><a href="#基本使用-3" class="headerlink" title="基本使用"></a>基本使用</h5><p><code>public void lockInterruptibly()</code>：获得可打断的锁</p><ul><li><p>如果没有竞争此方法就会获取 lock 对象锁</p></li><li><p>如果有竞争就进入阻塞队列，可以被其他线程用 interrupt 打断</p></li></ul><p>注意：如果是不可中断模式，那么即使使用了 interrupt 也不会让等待状态中的线程中断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;      <br>    <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();      <br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;          <br>        <span class="hljs-keyword">try</span> &#123;              <br>            System.out.println(<span class="hljs-string">&quot;尝试获取锁&quot;</span>);              <br>            lock.lockInterruptibly();          <br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;              <br>            System.out.println(<span class="hljs-string">&quot;没有获取到锁，被打断，直接返回&quot;</span>);              <br>            <span class="hljs-keyword">return</span>;          <br>        &#125;          <br>        <span class="hljs-keyword">try</span> &#123;              <br>            System.out.println(<span class="hljs-string">&quot;获取到锁&quot;</span>);          <br>        &#125; <span class="hljs-keyword">finally</span> &#123;              <br>            lock.unlock();          <br>        &#125;      <br>    &#125;, <span class="hljs-string">&quot;t1&quot;</span>);      <br>    lock.lock();      <br>    t1.start();      <br>    Thread.sleep(<span class="hljs-number">2000</span>);      <br>    System.out.println(<span class="hljs-string">&quot;主线程进行打断锁&quot;</span>);      <br>    t1.interrupt();  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="实现原理-2"><a href="#实现原理-2" class="headerlink" title="实现原理"></a>实现原理</h5><ul><li><p>不可打断模式：即使它被打断，仍会驻留在 AQS 阻塞队列中，一直要<strong>等到获得锁后才能得知自己被打断</strong>了</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;      <br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<span class="hljs-comment">//阻塞等待          </span><br>        <span class="hljs-comment">// 如果acquireQueued返回true，打断状态 interrupted = true          </span><br>        selfInterrupt();  <br>&#125;  <br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">selfInterrupt</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">// 知道自己被打断了，需要重新产生一次中断完成中断效果  </span><br>    Thread.currentThread().interrupt();  <br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-type">int</span> arg)</span> &#123;      <br>    <span class="hljs-keyword">try</span> &#123;          <br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;          <br>        <span class="hljs-keyword">for</span> (;;) &#123;              <br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();              <br>            <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;                  <br>                setHead(node);                  <br>                p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC                  </span><br>                failed = <span class="hljs-literal">false</span>;                  <br>                <span class="hljs-comment">// 还是需要获得锁后, 才能返回打断状态  </span><br>                <span class="hljs-keyword">return</span> interrupted;              <br>            &#125;              <br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())&#123;  <br>                <span class="hljs-comment">// 条件二中判断当前线程是否被打断，被打断返回true，设置中断标记为 true，【获取锁后返回】  </span><br>                interrupted = <span class="hljs-literal">true</span>;    <br>            &#125;                    <br>        &#125;   <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        <span class="hljs-keyword">if</span> (failed)  <br>            cancelAcquire(node);  <br>    &#125;  <br>&#125;  <br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">parkAndCheckInterrupt</span><span class="hljs-params">()</span> &#123;      <br>     <span class="hljs-comment">// 阻塞当前线程，如果打断标记已经是 true, 则 park 会失效  </span><br>     LockSupport.park(<span class="hljs-built_in">this</span>);      <br>     <span class="hljs-comment">// 判断当前线程是否被打断，清除打断标记，被打断返回true  </span><br>     <span class="hljs-keyword">return</span> Thread.interrupted();  <br> &#125;<br></code></pre></td></tr></table></figure></li><li><p>可打断模式：AbstractQueuedSynchronizer#acquireInterruptibly，<strong>被打断后会直接抛出异常</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;      <br>    sync.acquireInterruptibly(<span class="hljs-number">1</span>);  <br>&#125;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireInterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;  <br>    <span class="hljs-comment">// 被其他线程打断了直接返回 false  </span><br>    <span class="hljs-keyword">if</span> (Thread.interrupted())  <br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();  <br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg))  <br>        <span class="hljs-comment">// 没获取到锁，进入这里  </span><br>        doAcquireInterruptibly(arg);  <br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAcquireInterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>    <span class="hljs-comment">// 返回封装当前线程的节点  </span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addWaiter(Node.EXCLUSIVE);  <br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-keyword">for</span> (;;) &#123;  <br>            <span class="hljs-comment">//...  </span><br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())  <br>                <span class="hljs-comment">// 【在 park 过程中如果被 interrupt 会抛出异常】, 而不会再次进入循环获取锁后才完成打断效果  </span><br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();  <br>        &#125;      <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        <span class="hljs-comment">// 抛出异常前会进入这里  </span><br>        <span class="hljs-keyword">if</span> (failed)  <br>            <span class="hljs-comment">// 取消当前线程的节点  </span><br>            cancelAcquire(node);  <br>    &#125;  <br>&#125;<br><br><span class="hljs-comment">// 取消节点出队的逻辑  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cancelAcquire</span><span class="hljs-params">(Node node)</span> &#123;  <br>    <span class="hljs-comment">// 判空  </span><br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>)  <br>        <span class="hljs-keyword">return</span>;  <br><span class="hljs-comment">// 把当前节点封装的 Thread 置为空  </span><br>    node.thread = <span class="hljs-literal">null</span>;  <br><span class="hljs-comment">// 获取当前取消的 node 的前驱节点  </span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">pred</span> <span class="hljs-operator">=</span> node.prev;  <br>    <span class="hljs-comment">// 前驱节点也被取消了，循环找到前面最近的没被取消的节点  </span><br>    <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>)  <br>        node.prev = pred = pred.prev;  <br>      <br><span class="hljs-comment">// 获取前驱节点的后继节点，可能是当前 node，也可能是 waitStatus &gt; 0 的节点  </span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">predNext</span> <span class="hljs-operator">=</span> pred.next;  <br>      <br><span class="hljs-comment">// 把当前节点的状态设置为 【取消状态 1】  </span><br>    node.waitStatus = Node.CANCELLED;  <br>      <br><span class="hljs-comment">// 条件成立说明当前节点是尾节点，把当前节点的前驱节点设置为尾节点  </span><br>    <span class="hljs-keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;  <br>        <span class="hljs-comment">// 把前驱节点的后继节点置空，这里直接把所有的取消节点出队  </span><br>        compareAndSetNext(pred, predNext, <span class="hljs-literal">null</span>);  <br>    &#125; <span class="hljs-keyword">else</span> &#123;  <br>        <span class="hljs-comment">// 说明当前节点不是 tail 节点  </span><br>        <span class="hljs-type">int</span> ws;  <br>        <span class="hljs-comment">// 条件一成立说明当前节点不是 head.next 节点  </span><br>        <span class="hljs-keyword">if</span> (pred != head &amp;&amp;  <br>            <span class="hljs-comment">// 判断前驱节点的状态是不是 -1，不成立说明前驱状态可能是 0 或者刚被其他线程取消排队了  </span><br>            ((ws = pred.waitStatus) == Node.SIGNAL ||  <br>             <span class="hljs-comment">// 如果状态不是 -1，设置前驱节点的状态为 -1  </span><br>             (ws &lt;= <span class="hljs-number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;  <br>            <span class="hljs-comment">// 前驱节点的线程不为null  </span><br>            pred.thread != <span class="hljs-literal">null</span>) &#123;  <br>              <br>            <span class="hljs-type">Node</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> node.next;  <br>            <span class="hljs-comment">// 当前节点的后继节点是正常节点  </span><br>            <span class="hljs-keyword">if</span> (next != <span class="hljs-literal">null</span> &amp;&amp; next.waitStatus &lt;= <span class="hljs-number">0</span>)  <br>                <span class="hljs-comment">// 把 前驱节点的后继节点 设置为 当前节点的后继节点，【从队列中删除了当前节点】  </span><br>                compareAndSetNext(pred, predNext, next);  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            <span class="hljs-comment">// 当前节点是 head.next 节点，唤醒当前节点的后继节点  </span><br>            unparkSuccessor(node);  <br>        &#125;  <br>        node.next = node; <span class="hljs-comment">// help GC  </span><br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h4 id="锁超时"><a href="#锁超时" class="headerlink" title="锁超时"></a>锁超时</h4><h5 id="基本使用-4"><a href="#基本使用-4" class="headerlink" title="基本使用"></a>基本使用</h5><p><code>public boolean tryLock()</code>：尝试获取锁，获取到返回 true，获取不到直接放弃，不进入阻塞队列</p><p><code>public boolean tryLock(long timeout, TimeUnit unit)</code>：在给定时间内获取锁，获取不到就退出</p><p>注意：tryLock 期间也可以被打断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();  <br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            <span class="hljs-keyword">if</span> (!lock.tryLock(<span class="hljs-number">2</span>, TimeUnit.SECONDS)) &#123;  <br>                System.out.println(<span class="hljs-string">&quot;获取不到锁&quot;</span>);  <br>                <span class="hljs-keyword">return</span>;  <br>            &#125;  <br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>            System.out.println(<span class="hljs-string">&quot;被打断，获取不到锁&quot;</span>);  <br>            <span class="hljs-keyword">return</span>;  <br>        &#125;  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            log.debug(<span class="hljs-string">&quot;获取到锁&quot;</span>);  <br>        &#125; <span class="hljs-keyword">finally</span> &#123;  <br>            lock.unlock();  <br>        &#125;  <br>    &#125;, <span class="hljs-string">&quot;t1&quot;</span>);  <br>    lock.lock();  <br>    System.out.println(<span class="hljs-string">&quot;主线程获取到锁&quot;</span>);  <br>    t1.start();  <br>      <br>    Thread.sleep(<span class="hljs-number">1000</span>);  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;主线程释放了锁&quot;</span>);  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        lock.unlock();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="实现原理-3"><a href="#实现原理-3" class="headerlink" title="实现原理"></a>实现原理</h5><ul><li><p>成员变量：指定超时限制的阈值，小于该值的线程不会被挂起</p><p>  <code>static final long spinForTimeoutThreshold = 1000L;</code></p><p>  超时时间设置的小于该值，就会被禁止挂起，因为阻塞在唤醒的成本太高，不如选择自旋空转</p></li><li><p>tryLock()</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span> &#123;     <br>    <span class="hljs-comment">// 只尝试一次  </span><br>    <span class="hljs-keyword">return</span> sync.nonfairTryAcquire(<span class="hljs-number">1</span>);  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>tryLock(long timeout, TimeUnit unit)</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquireNanos</span><span class="hljs-params">(<span class="hljs-type">int</span> arg, <span class="hljs-type">long</span> nanosTimeout)</span> &#123;  <br>    <span class="hljs-keyword">if</span> (Thread.interrupted())          <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();      <br>    <span class="hljs-comment">// tryAcquire 尝试一次  </span><br>    <span class="hljs-keyword">return</span> tryAcquire(arg) || doAcquireNanos(arg, nanosTimeout);  <br>&#125;  <br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;      <br>    <span class="hljs-keyword">return</span> nonfairTryAcquire(acquires);  <br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">doAcquireNanos</span><span class="hljs-params">(<span class="hljs-type">int</span> arg, <span class="hljs-type">long</span> nanosTimeout)</span> &#123;      <br>    <span class="hljs-keyword">if</span> (nanosTimeout &lt;= <span class="hljs-number">0L</span>)  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>    <span class="hljs-comment">// 获取最后期限的时间戳  </span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> System.nanoTime() + nanosTimeout;  <br>    <span class="hljs-comment">//...  </span><br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-keyword">for</span> (;;) &#123;  <br>            <span class="hljs-comment">//...  </span><br>            <span class="hljs-comment">// 计算还需等待的时间  </span><br>            nanosTimeout = deadline - System.nanoTime();  <br>            <span class="hljs-keyword">if</span> (nanosTimeout &lt;= <span class="hljs-number">0L</span>)<span class="hljs-comment">//时间已到       </span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;  <br>                <span class="hljs-comment">// 如果 nanosTimeout 大于该值，才有阻塞的意义，否则直接自旋会好点  </span><br>                nanosTimeout &gt; spinForTimeoutThreshold)  <br>                LockSupport.parkNanos(<span class="hljs-built_in">this</span>, nanosTimeout);  <br>            <span class="hljs-comment">// 【被打断会报异常】  </span><br>            <span class="hljs-keyword">if</span> (Thread.interrupted())  <br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();  <br>        &#125;      <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h5 id="哲学家就餐"><a href="#哲学家就餐" class="headerlink" title="哲学家就餐"></a>哲学家就餐</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-string">&quot;1&quot;</span>);<span class="hljs-comment">//...  </span><br>    <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-string">&quot;5&quot;</span>);  <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;苏格拉底&quot;</span>, c1, c2).start();  <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;柏拉图&quot;</span>, c2, c3).start();  <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;亚里士多德&quot;</span>, c3, c4).start();  <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;赫拉克利特&quot;</span>, c4, c5).start();      <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;阿基米德&quot;</span>, c5, c1).start();  <br>&#125;  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Philosopher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;  <br>    Chopstick left;  <br>    Chopstick right;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;  <br>            <span class="hljs-comment">// 尝试获得左手筷子  </span><br>            <span class="hljs-keyword">if</span> (left.tryLock()) &#123;  <br>                <span class="hljs-keyword">try</span> &#123;  <br>                    <span class="hljs-comment">// 尝试获得右手筷子  </span><br>                    <span class="hljs-keyword">if</span> (right.tryLock()) &#123;  <br>                        <span class="hljs-keyword">try</span> &#123;  <br>                            System.out.println(<span class="hljs-string">&quot;eating...&quot;</span>);  <br>                            Thread.sleep(<span class="hljs-number">1000</span>);  <br>                        &#125; <span class="hljs-keyword">finally</span> &#123;  <br>                            right.unlock();  <br>                        &#125;  <br>                    &#125;  <br>                &#125; <span class="hljs-keyword">finally</span> &#123;  <br>                    left.unlock();  <br>                &#125;  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>&#125;  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Chopstick</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ReentrantLock</span> &#123;  <br>    String name;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Chopstick</span><span class="hljs-params">(String name)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.name = name;  <br>    &#125;  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;筷子&#123;&quot;</span> + name + <span class="hljs-string">&#x27;&#125;&#x27;</span>;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><h5 id="基本使用-5"><a href="#基本使用-5" class="headerlink" title="基本使用"></a>基本使用</h5><p>synchronized 的条件变量，是当条件不满足时进入 WaitSet 等待；ReentrantLock 的条件变量比 synchronized 强大之处在于支持多个条件变量</p><p>ReentrantLock 类获取 Condition 对象：<code>public Condition newCondition()</code></p><p>Condition 类 API：</p><ul><li><p><code>void await()</code>：当前线程从运行状态进入等待状态，释放锁</p></li><li><p><code>void signal()</code>：唤醒一个等待在 Condition 上的线程，但是必须获得与该 Condition 相关的锁</p></li></ul><p>使用流程：</p><ul><li><p><strong>await &#x2F; signal 前需要获得锁</strong></p></li><li><p>await 执行后，会释放锁进入 ConditionObject 等待</p></li><li><p>await 的线程被唤醒去重新竞争 lock 锁</p></li><li><p><strong>线程在条件队列被打断会抛出中断异常</strong></p></li><li><p>竞争 lock 锁成功后，从 await 后继续执行</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;      <br>    <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();  <br>    <span class="hljs-comment">//创建一个新的条件变量  </span><br>    <span class="hljs-type">Condition</span> <span class="hljs-variable">condition1</span> <span class="hljs-operator">=</span> lock.newCondition();  <br>    <span class="hljs-type">Condition</span> <span class="hljs-variable">condition2</span> <span class="hljs-operator">=</span> lock.newCondition();  <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            lock.lock();  <br>            System.out.println(<span class="hljs-string">&quot;进入等待&quot;</span>);  <br>            <span class="hljs-comment">//进入休息室等待  </span><br>            condition1.await();  <br>            System.out.println(<span class="hljs-string">&quot;被唤醒了&quot;</span>);  <br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>            e.printStackTrace();  <br>        &#125; <span class="hljs-keyword">finally</span> &#123;  <br>            lock.unlock();  <br>        &#125;      <br>    &#125;).start();  <br>    Thread.sleep(<span class="hljs-number">1000</span>);  <br>    <span class="hljs-comment">//叫醒  </span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>        <span class="hljs-keyword">try</span> &#123;              <br>            lock.lock();  <br>            <span class="hljs-comment">//唤醒  </span><br>            condition2.signal();  <br>        &#125; <span class="hljs-keyword">finally</span> &#123;  <br>            lock.unlock();  <br>        &#125;  <br>    &#125;).start();  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="实现原理-4"><a href="#实现原理-4" class="headerlink" title="实现原理"></a>实现原理</h5><h6 id="await"><a href="#await" class="headerlink" title="await"></a>await</h6><p>总体流程是将 await 线程包装成 node 节点放入 ConditionObject 的条件队列，如果被唤醒就将 node 转移到 AQS 的执行阻塞队列，等待获取锁，<strong>每个 Condition 对象都包含一个等待队列</strong></p><ul><li><p>开始 Thread-0 持有锁，调用 await，线程进入 ConditionObject 等待，直到被唤醒或打断，调用 await 方法的线程都是持锁状态的，所以说逻辑里<strong>不存在并发</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>     <span class="hljs-comment">// 判断当前线程是否是中断状态，是就直接给个中断异常  </span><br>    <span class="hljs-keyword">if</span> (Thread.interrupted())  <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();  <br>    <span class="hljs-comment">// 将调用 await 的线程包装成 Node，添加到条件队列并返回  </span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addConditionWaiter();  <br>    <span class="hljs-comment">// 完全释放节点持有的锁，因为其他线程唤醒当前线程的前提是【持有锁】  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> fullyRelease(node);  <br>      <br>    <span class="hljs-comment">// 设置打断模式为没有被打断，状态码为 0  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">interruptMode</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br>      <br>    <span class="hljs-comment">// 如果该节点还没有转移至 AQS 阻塞队列, park 阻塞，等待进入阻塞队列  </span><br>    <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;  <br>        LockSupport.park(<span class="hljs-built_in">this</span>);  <br>        <span class="hljs-comment">// 如果被打断，退出等待队列，对应的 node 【也会被迁移到阻塞队列】尾部，状态设置为 0  </span><br>        <span class="hljs-keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number">0</span>)  <br>            <span class="hljs-keyword">break</span>;  <br>    &#125;  <br>    <span class="hljs-comment">// 逻辑到这说明当前线程退出等待队列，进入【阻塞队列】  </span><br>      <br>    <span class="hljs-comment">// 尝试枪锁，释放了多少锁就【重新获取多少锁】，获取锁成功判断打断模式  </span><br>    <span class="hljs-keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)  <br>        interruptMode = REINTERRUPT;  <br>      <br>    <span class="hljs-comment">// node 在条件队列时 如果被外部线程中断唤醒，会加入到阻塞队列，但是并未设 nextWaiter = null  </span><br>    <span class="hljs-keyword">if</span> (node.nextWaiter != <span class="hljs-literal">null</span>)  <br>        <span class="hljs-comment">// 清理条件队列内所有已取消的 Node  </span><br>        unlinkCancelledWaiters();  <br>    <span class="hljs-comment">// 条件成立说明挂起期间发生过中断  </span><br>    <span class="hljs-keyword">if</span> (interruptMode != <span class="hljs-number">0</span>)  <br>        <span class="hljs-comment">// 应用打断模式  </span><br>        reportInterruptAfterWait(interruptMode);  <br>&#125;<br><br><span class="hljs-comment">// 打断模式 - 在退出等待时重新设置打断状态  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">REINTERRUPT</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;  <br><span class="hljs-comment">// 打断模式 - 在退出等待时抛出异常  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">THROW_IE</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041900663.png"></p></li><li><p><strong>创建新的 Node 状态为 -2（Node.CONDITION）</strong>，关联 Thread-0，加入等待队列尾部</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">addConditionWaiter</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">// 获取当前条件队列的尾节点的引用，保存到局部变量 t 中  </span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> lastWaiter;  <br>    <span class="hljs-comment">// 当前队列中不是空，并且节点的状态不是 CONDITION（-2），说明当前节点发生了中断  </span><br>    <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;  <br>        <span class="hljs-comment">// 清理条件队列内所有已取消的 Node  </span><br>        unlinkCancelledWaiters();  <br>        <span class="hljs-comment">// 清理完成重新获取 尾节点 的引用  </span><br>        t = lastWaiter;  <br>    &#125;  <br>    <span class="hljs-comment">// 创建一个关联当前线程的新 node, 设置状态为 CONDITION(-2)，添加至队列尾部  </span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Thread.currentThread(), Node.CONDITION);  <br>    <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>)  <br>        firstWaiter = node;<span class="hljs-comment">// 空队列直接放在队首【不用CAS因为执行线程是持锁线程，并发安全】  </span><br>    <span class="hljs-keyword">else</span>  <br>        t.nextWaiter = node;<span class="hljs-comment">// 非空队列队尾追加  </span><br>    lastWaiter = node;<span class="hljs-comment">// 更新队尾的引用  </span><br>    <span class="hljs-keyword">return</span> node;  <br>&#125;<br><br><span class="hljs-comment">// 清理条件队列内所有已取消（不是CONDITION）的 node，【链表删除的逻辑】  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlinkCancelledWaiters</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">// 从头节点开始遍历【FIFO】  </span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> firstWaiter;  <br>    <span class="hljs-comment">// 指向正常的 CONDITION 节点  </span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">trail</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;  <br>    <span class="hljs-comment">// 等待队列不空  </span><br>    <span class="hljs-keyword">while</span> (t != <span class="hljs-literal">null</span>) &#123;  <br>        <span class="hljs-comment">// 获取当前节点的后继节点  </span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> t.nextWaiter;  <br>        <span class="hljs-comment">// 判断 t 节点是不是 CONDITION 节点，条件队列内不是 CONDITION 就不是正常的  </span><br>        <span class="hljs-keyword">if</span> (t.waitStatus != Node.CONDITION) &#123;   <br>            <span class="hljs-comment">// 不是正常节点，需要 t 与下一个节点断开  </span><br>            t.nextWaiter = <span class="hljs-literal">null</span>;  <br>            <span class="hljs-comment">// 条件成立说明遍历到的节点还未碰到过正常节点  </span><br>            <span class="hljs-keyword">if</span> (trail == <span class="hljs-literal">null</span>)  <br>                <span class="hljs-comment">// 更新 firstWaiter 指针为下个节点  </span><br>                firstWaiter = next;  <br>            <span class="hljs-keyword">else</span>  <br>                <span class="hljs-comment">// 让上一个正常节点指向 当前取消节点的 下一个节点，【删除非正常的节点】  </span><br>                trail.nextWaiter = next;  <br>            <span class="hljs-comment">// t 是尾节点了，更新 lastWaiter 指向最后一个正常节点  </span><br>            <span class="hljs-keyword">if</span> (next == <span class="hljs-literal">null</span>)  <br>                lastWaiter = trail;  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            <span class="hljs-comment">// trail 指向的是正常节点   </span><br>            trail = t;  <br>        &#125;  <br>        <span class="hljs-comment">// 把 t.next 赋值给 t，循环遍历  </span><br>        t = next;   <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>接下来 Thread-0 进入 AQS 的 fullyRelease 流程，释放同步器上的锁</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// 线程可能重入，需要将 state 全部释放  </span><br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fullyRelease</span><span class="hljs-params">(Node node)</span> &#123;  <br>    <span class="hljs-comment">// 完全释放锁是否成功，false 代表成功  </span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-comment">// 获取当前线程所持有的 state 值总数  </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> getState();  <br>        <span class="hljs-comment">// release -&gt; tryRelease 解锁重入锁  </span><br>        <span class="hljs-keyword">if</span> (release(savedState)) &#123;  <br>            <span class="hljs-comment">// 释放成功  </span><br>            failed = <span class="hljs-literal">false</span>;  <br>            <span class="hljs-comment">// 返回解锁的深度  </span><br>            <span class="hljs-keyword">return</span> savedState;  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            <span class="hljs-comment">// 解锁失败抛出异常  </span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();  <br>        &#125;  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        <span class="hljs-comment">// 没有释放成功，将当前 node 设置为取消状态  </span><br>        <span class="hljs-keyword">if</span> (failed)  <br>            node.waitStatus = Node.CANCELLED;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>fullyRelease 中会 unpark AQS 队列中的下一个节点竞争锁，假设 Thread-1 竞争成功</p><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041901643.png"></p></li><li><p>Thread-0 进入 isOnSyncQueue 逻辑判断节点<strong>是否移动到阻塞队列</strong>，没有就 park 阻塞 Thread-0</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isOnSyncQueue</span><span class="hljs-params">(Node node)</span> &#123;  <br>    <span class="hljs-comment">// node 的状态是 CONDITION，signal 方法是先修改状态再迁移，所以前驱节点为空证明还【没有完成迁移】  </span><br>    <span class="hljs-keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="hljs-literal">null</span>)  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>    <span class="hljs-comment">// 说明当前节点已经成功入队到阻塞队列，且当前节点后面已经有其它 node，因为条件队列的 next 指针为 null  </span><br>    <span class="hljs-keyword">if</span> (node.next != <span class="hljs-literal">null</span>)  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br><span class="hljs-comment">// 说明【可能在阻塞队列，但是是尾节点】  </span><br>    <span class="hljs-comment">// 从阻塞队列的尾节点开始向前【遍历查找 node】，如果查找到返回 true，查找不到返回 false  </span><br>    <span class="hljs-keyword">return</span> findNodeFromTail(node);  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>await 线程 park 后如果被 unpark 或者被打断，都会进入 checkInterruptWhileWaiting 判断线程是否被打断：<strong>在条件队列被打断的线程需要抛出异常</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">checkInterruptWhileWaiting</span><span class="hljs-params">(Node node)</span> &#123;  <br>    <span class="hljs-comment">// Thread.interrupted() 返回当前线程中断标记位，并且重置当前标记位 为 false  </span><br>    <span class="hljs-comment">// 如果被中断了，根据是否在条件队列被中断的，设置中断状态码  </span><br>    <span class="hljs-keyword">return</span> Thread.interrupted() ?(transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) : <span class="hljs-number">0</span>;  <br>&#125;<br><br><span class="hljs-comment">// 这个方法只有在线程是被打断唤醒时才会调用  </span><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">transferAfterCancelledWait</span><span class="hljs-params">(Node node)</span> &#123;  <br>    <span class="hljs-comment">// 条件成立说明当前node一定是在条件队列内，因为 signal 迁移节点到阻塞队列时，会将节点的状态修改为 0  </span><br>    <span class="hljs-keyword">if</span> (compareAndSetWaitStatus(node, Node.CONDITION, <span class="hljs-number">0</span>)) &#123;  <br>        <span class="hljs-comment">// 把【中断唤醒的 node 加入到阻塞队列中】  </span><br>        enq(node);  <br>        <span class="hljs-comment">// 表示是在条件队列内被中断了，设置为 THROW_IE 为 -1  </span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//执行到这里的情况：  </span><br>    <span class="hljs-comment">//1.当前node已经被外部线程调用 signal 方法将其迁移到 阻塞队列 内了  </span><br>    <span class="hljs-comment">//2.当前node正在被外部线程调用 signal 方法将其迁移至 阻塞队列 进行中状态  </span><br>      <br>    <span class="hljs-comment">// 如果当前线程还没到阻塞队列，一直释放 CPU  </span><br>    <span class="hljs-keyword">while</span> (!isOnSyncQueue(node))  <br>        Thread.yield();  <br>  <br>    <span class="hljs-comment">// 表示当前节点被中断唤醒时不在条件队列了，设置为 REINTERRUPT 为 1  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>最后开始处理中断状态：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reportInterruptAfterWait</span><span class="hljs-params">(<span class="hljs-type">int</span> interruptMode)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>    <span class="hljs-comment">// 条件成立说明【在条件队列内发生过中断，此时 await 方法抛出中断异常】  </span><br>    <span class="hljs-keyword">if</span> (interruptMode == THROW_IE)  <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();  <br>  <br>    <span class="hljs-comment">// 条件成立说明【在条件队列外发生的中断，此时设置当前线程的中断标记位为 true】  </span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (interruptMode == REINTERRUPT)  <br>        <span class="hljs-comment">// 进行一次自己打断，产生中断的效果  </span><br>        selfInterrupt();  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h6 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h6><ul><li><p>假设 Thread-1 要来唤醒 Thread-0，进入 ConditionObject 的 doSignal 流程，<strong>取得等待队列中第一个 Node</strong>，即 Thread-0 所在 Node，必须持有锁才能唤醒, 因此 doSignal 内线程安全</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">signal</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">// 判断调用 signal 方法的线程是否是独占锁持有线程  </span><br>    <span class="hljs-keyword">if</span> (!isHeldExclusively())  <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();  <br>    <span class="hljs-comment">// 获取条件队列中第一个 Node  </span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> firstWaiter;  <br>    <span class="hljs-comment">// 不为空就将第该节点【迁移到阻塞队列】  </span><br>    <span class="hljs-keyword">if</span> (first != <span class="hljs-literal">null</span>)  <br>        doSignal(first);  <br>&#125;<br><br><span class="hljs-comment">// 唤醒 - 【将没取消的第一个节点转移至 AQS 队列尾部】  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSignal</span><span class="hljs-params">(Node first)</span> &#123;  <br>    <span class="hljs-keyword">do</span> &#123;  <br>        <span class="hljs-comment">// 成立说明当前节点的下一个节点是 null，当前节点是尾节点了，队列中只有当前一个节点了  </span><br>        <span class="hljs-keyword">if</span> ((firstWaiter = first.nextWaiter) == <span class="hljs-literal">null</span>)  <br>            lastWaiter = <span class="hljs-literal">null</span>;  <br>        first.nextWaiter = <span class="hljs-literal">null</span>;  <br>    <span class="hljs-comment">// 将等待队列中的 Node 转移至 AQS 队列，不成功且还有节点则继续循环  </span><br>    &#125; <span class="hljs-keyword">while</span> (!transferForSignal(first) &amp;&amp; (first = firstWaiter) != <span class="hljs-literal">null</span>);  <br>&#125;  <br>  <br><span class="hljs-comment">// signalAll() 会调用这个函数，唤醒所有的节点  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSignalAll</span><span class="hljs-params">(Node first)</span> &#123;  <br>    lastWaiter = firstWaiter = <span class="hljs-literal">null</span>;  <br>    <span class="hljs-keyword">do</span> &#123;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> first.nextWaiter;  <br>        first.nextWaiter = <span class="hljs-literal">null</span>;  <br>        transferForSignal(first);  <br>        first = next;  <br>    <span class="hljs-comment">// 唤醒所有的节点，都放到阻塞队列中  </span><br>    &#125; <span class="hljs-keyword">while</span> (first != <span class="hljs-literal">null</span>);  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>执行 transferForSignal，<strong>先将节点的 waitStatus 改为 0，然后加入 AQS 阻塞队列尾部</strong>，将 Thread-3 的 waitStatus 改为 -1</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// 如果节点状态是取消, 返回 false 表示转移失败, 否则转移成功  </span><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">transferForSignal</span><span class="hljs-params">(Node node)</span> &#123;  <br>    <span class="hljs-comment">// CAS 修改当前节点的状态，修改为 0，因为当前节点马上要迁移到阻塞队列了  </span><br>    <span class="hljs-comment">// 如果状态已经不是 CONDITION, 说明线程被取消（await 释放全部锁失败）或者被中断（可打断 cancelAcquire）  </span><br>    <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="hljs-number">0</span>))  <br>        <span class="hljs-comment">// 返回函数调用处继续寻找下一个节点  </span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>      <br>    <span class="hljs-comment">// 【先改状态，再进行迁移】  </span><br>    <span class="hljs-comment">// 将当前 node 入阻塞队列，p 是当前节点在阻塞队列的【前驱节点】  </span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> enq(node);  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> p.waitStatus;  <br>      <br>    <span class="hljs-comment">// 如果前驱节点被取消或者不能设置状态为 Node.SIGNAL，就 unpark 取消当前节点线程的阻塞状态,   </span><br>    <span class="hljs-comment">// 让 thread-0 线程竞争锁，重新同步状态  </span><br>    <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))  <br>        LockSupport.unpark(node.thread);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041902380.png"></p></li><li><p>Thread-1 释放锁，进入 unlock 流程</p></li></ul><hr><h3 id="ReadWrite"><a href="#ReadWrite" class="headerlink" title="ReadWrite"></a>ReadWrite</h3><h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><p>独占锁：指该锁一次只能被一个线程所持有，对 ReentrantLock 和 Synchronized 而言都是独占锁</p><p>共享锁：指该锁可以被多个线程锁持有</p><p>ReentrantReadWriteLock 其<strong>读锁是共享锁，写锁是独占锁</strong></p><p>作用：多个线程同时读一个资源类没有任何问题，为了满足并发量，读取共享资源应该同时进行，但是如果一个线程想去写共享资源，就不应该再有其它线程可以对该资源进行读或写</p><p>使用规则：</p><ul><li><p>加锁解锁格式：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">r.lock();  <br><span class="hljs-keyword">try</span> &#123;  <br>    <span class="hljs-comment">// 临界区  </span><br>&#125; <span class="hljs-keyword">finally</span> &#123;  <br>r.unlock();  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>读-读能共存、读-写不能共存、写-写不能共存</p></li><li><p>读锁不支持条件变量</p></li><li><p><strong>重入时升级不支持</strong>：持有读锁的情况下去获取写锁会导致获取写锁永久等待，需要先释放读，再去获得写</p></li><li><p><strong>重入时降级支持</strong>：持有写锁的情况下去获取读锁，造成只有当前线程会持有读锁，因为写锁会互斥其他的锁</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><br>w.lock();  <br><span class="hljs-keyword">try</span> &#123;  <br>    r.lock();<span class="hljs-comment">// 降级为读锁, 释放写锁, 这样能够让其它线程读取缓存  </span><br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-comment">// ...  </span><br>    &#125; <span class="hljs-keyword">finally</span>&#123;  <br>    w.unlock();<span class="hljs-comment">// 要在写锁释放之前获取读锁  </span><br>    &#125;  <br>&#125; <span class="hljs-keyword">finally</span>&#123;  <br>r.unlock();  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>构造方法：</p><ul><li><p><code>public ReentrantReadWriteLock()</code>：默认构造方法，非公平锁</p></li><li><p><code>public ReentrantReadWriteLock(boolean fair)</code>：true 为公平锁</p></li></ul><p>常用API：</p><ul><li><p><code>public ReentrantReadWriteLock.ReadLock readLock()</code>：返回读锁</p></li><li><p><code>public ReentrantReadWriteLock.WriteLock writeLock()</code>：返回写锁</p></li><li><p><code>public void lock()</code>：加锁</p></li><li><p><code>public void unlock()</code>：解锁</p></li><li><p><code>public boolean tryLock()</code>：尝试获取锁</p></li></ul><p>读读并发：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    <span class="hljs-type">ReentrantReadWriteLock</span> <span class="hljs-variable">rw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantReadWriteLock</span>();  <br>    ReentrantReadWriteLock.<span class="hljs-type">ReadLock</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> rw.readLock();  <br>    ReentrantReadWriteLock.<span class="hljs-type">WriteLock</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> rw.writeLock();  <br>  <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>        r.lock();  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            Thread.sleep(<span class="hljs-number">2000</span>);  <br>            System.out.println(<span class="hljs-string">&quot;Thread 1 running &quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());  <br>        &#125; <span class="hljs-keyword">finally</span> &#123;  <br>            r.unlock();  <br>        &#125;  <br>    &#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();  <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>        r.lock();  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            Thread.sleep(<span class="hljs-number">2000</span>);  <br>            System.out.println(<span class="hljs-string">&quot;Thread 2 running &quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());  <br>        &#125; <span class="hljs-keyword">finally</span> &#123;  <br>            r.unlock();  <br>        &#125;  <br>    &#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="缓存应用"><a href="#缓存应用" class="headerlink" title="缓存应用"></a>缓存应用</h4><p>缓存更新时，是先清缓存还是先更新数据库</p><ul><li><p>先清缓存：可能造成刚清理缓存还没有更新数据库，线程直接查询了数据库更新过期数据到缓存</p></li><li><p>先更新据库：可能造成刚更新数据库，还没清空缓存就有线程从缓存拿到了旧数据</p></li><li><p>补充情况：查询线程 A 查询数据时恰好缓存数据由于时间到期失效，或是第一次查询</p><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041905401.png"></p></li></ul><p>可以使用读写锁进行操作</p><hr><h4 id="实现原理-5"><a href="#实现原理-5" class="headerlink" title="实现原理"></a>实现原理</h4><h5 id="成员属性-5"><a href="#成员属性-5" class="headerlink" title="成员属性"></a>成员属性</h5><p>读写锁用的是同一个 Sycn 同步器，因此等待队列、state 等也是同一个，原理与 ReentrantLock 加锁相比没有特殊之处，不同是<strong>写锁状态占了 state 的低 16 位，而读锁使用的是 state 的高 16 位</strong></p><ul><li><p>读写锁：</p><p>  <code>private final ReentrantReadWriteLock.ReadLock readerLock;</code><br>  <code>private final ReentrantReadWriteLock.WriteLock writerLock;</code></p></li><li><p>构造方法：默认是非公平锁，可以指定参数创建公平锁</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantReadWriteLock</span><span class="hljs-params">(<span class="hljs-type">boolean</span> fair)</span> &#123;  <br>    <span class="hljs-comment">// true 为公平锁  </span><br>    sync = fair ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">FairSync</span>() : <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();  <br>    <span class="hljs-comment">// 这两个 lock 共享同一个 sync 实例，都是由 ReentrantReadWriteLock 的 sync 提供同步实现  </span><br>    readerLock = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReadLock</span>(<span class="hljs-built_in">this</span>);  <br>    writerLock = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WriteLock</span>(<span class="hljs-built_in">this</span>);  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>Sync 类的属性：</p><ul><li><p>统计变量：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// 用来移位  </span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SHARED_SHIFT</span>   <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;  <br><span class="hljs-comment">// 高16位的1  </span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SHARED_UNIT</span>    <span class="hljs-operator">=</span> (<span class="hljs-number">1</span> &lt;&lt; SHARED_SHIFT);  <br><span class="hljs-comment">// 65535，16个1，代表写锁的最大重入次数  </span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_COUNT</span>      <span class="hljs-operator">=</span> (<span class="hljs-number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="hljs-number">1</span>;  <br><span class="hljs-comment">// 低16位掩码：0b 1111 1111 1111 1111，用来获取写锁重入的次数  </span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">EXCLUSIVE_MASK</span> <span class="hljs-operator">=</span> (<span class="hljs-number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure></li><li><p>获取读写锁的次数：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// 获取读写锁的读锁分配的总次数  </span><br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sharedCount</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>    &#123; <span class="hljs-keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;  <br><span class="hljs-comment">// 写锁（独占）锁的重入次数  </span><br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">exclusiveCount</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span> &#123; <span class="hljs-keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;<br></code></pre></td></tr></table></figure></li><li><p>内部类：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// 记录读锁线程自己的持有读锁的数量（重入次数），因为 state 高16位记录的是全局范围内所有的读线程获取读锁的总量  </span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HoldCounter</span> &#123;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br>    <span class="hljs-comment">// Use id, not reference, to avoid garbage retention  </span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">tid</span> <span class="hljs-operator">=</span> getThreadId(Thread.currentThread());  <br>&#125;  <br><span class="hljs-comment">// 线程安全的存放线程各自的 HoldCounter 对象  </span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalHoldCounter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ThreadLocal</span>&lt;HoldCounter&gt; &#123;  <br>    <span class="hljs-keyword">public</span> HoldCounter <span class="hljs-title function_">initialValue</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HoldCounter</span>();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>内部类实例：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// 当前线程持有的可重入读锁的数量，计数为 0 时删除  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> ThreadLocalHoldCounter readHolds;  <br><span class="hljs-comment">// 记录最后一个获取【读锁】线程的 HoldCounter 对象  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> HoldCounter cachedHoldCounter;<br></code></pre></td></tr></table></figure></li><li><p>首次获取锁：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// 第一个获取读锁的线程  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">firstReader</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;  <br><span class="hljs-comment">// 记录该线程持有的读锁次数（读锁重入次数）  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> firstReaderHoldCount;<br></code></pre></td></tr></table></figure></li><li><p>Sync 构造方法：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><br>Sync() &#123;  <br>    readHolds = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalHoldCounter</span>();  <br>    <span class="hljs-comment">// 确保其他线程的数据可见性，state 是 volatile 修饰的变量，重写该值会将线程本地缓存数据【同步至主存】  </span><br>    setState(getState());   <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h5 id="加锁原理"><a href="#加锁原理" class="headerlink" title="加锁原理"></a>加锁原理</h5><ul><li><p>t1 线程：w.lock（<strong>写锁</strong>），成功上锁 state &#x3D; 0_1</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// lock()  -&gt; sync.acquire(1);  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;  <br>    sync.acquire(<span class="hljs-number">1</span>);  <br>&#125;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;  <br>    <span class="hljs-comment">// 尝试获得写锁，获得写锁失败，将当前线程关联到一个 Node 对象上, 模式为独占模式   </span><br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))  <br>        selfInterrupt();  <br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;  <br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();  <br>    <span class="hljs-comment">// 获得低 16 位, 代表写锁的 state 计数  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> exclusiveCount(c);  <br>    <span class="hljs-comment">// 说明有读锁或者写锁  </span><br>    <span class="hljs-keyword">if</span> (c != <span class="hljs-number">0</span>) &#123;  <br>        <span class="hljs-comment">// c != 0 and w == 0 表示有读锁，【读锁不能升级】，直接返回 false  </span><br>        <span class="hljs-comment">// w != 0 说明有写锁，写锁的拥有者不是自己，获取失败  </span><br>        <span class="hljs-keyword">if</span> (w == <span class="hljs-number">0</span> || current != getExclusiveOwnerThread())  <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>          <br>        <span class="hljs-comment">// 执行到这里只有一种情况：【写锁重入】，所以下面几行代码不存在并发  </span><br>        <span class="hljs-keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)  <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);  <br>        <span class="hljs-comment">// 写锁重入, 获得锁成功，没有并发，所以不使用 CAS  </span><br>        setState(c + acquires);  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    &#125;  <br>      <br>    <span class="hljs-comment">// c == 0，说明没有任何锁，判断写锁是否该阻塞，是 false 就尝试获取锁，失败返回 false  </span><br>    <span class="hljs-keyword">if</span> (writerShouldBlock() || !compareAndSetState(c, c + acquires))  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>    <span class="hljs-comment">// 获得锁成功，设置锁的持有线程为当前线程  </span><br>    setExclusiveOwnerThread(current);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>&#125;  <br><span class="hljs-comment">// 非公平锁 writerShouldBlock 总是返回 false, 无需阻塞  </span><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">writerShouldBlock</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;   <br>&#125;  <br><span class="hljs-comment">// 公平锁会检查 AQS 队列中是否有前驱节点, 没有(false)才去竞争  </span><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">writerShouldBlock</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">return</span> hasQueuedPredecessors();  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>t2 r.lock（<strong>读锁</strong>），进入 tryAcquireShared 流程：</p><ul><li><p>返回 -1 表示失败</p></li><li><p>如果返回 0 表示成功</p></li><li><p>返回正数表示还有多少后继节点支持共享模式，读写锁返回 1</p></li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;  <br>    sync.acquireShared(<span class="hljs-number">1</span>);  <br>&#125;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;  <br>    <span class="hljs-comment">// tryAcquireShared 返回负数, 表示获取读锁失败  </span><br>    <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)  <br>        doAcquireShared(arg);  <br>&#125;<br><br><span class="hljs-comment">// 尝试以共享模式获取  </span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> unused)</span> &#123;  <br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();  <br>    <span class="hljs-comment">// exclusiveCount(c) 代表低 16 位, 写锁的 state，成立说明有线程持有写锁  </span><br>    <span class="hljs-comment">// 写锁的持有者不是当前线程，则获取读锁失败，【写锁允许降级】  </span><br>    <span class="hljs-keyword">if</span> (exclusiveCount(c) != <span class="hljs-number">0</span> &amp;&amp; getExclusiveOwnerThread() != current)  <br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;  <br>      <br>    <span class="hljs-comment">// 高 16 位，代表读锁的 state，共享锁分配出去的总次数  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> sharedCount(c);  <br>    <span class="hljs-comment">// 读锁是否应该阻塞  </span><br>    <span class="hljs-keyword">if</span> (!readerShouldBlock() &amp;&amp;r &lt; MAX_COUNT &amp;&amp;  <br>        compareAndSetState(c, c + SHARED_UNIT)) &#123;<span class="hljs-comment">// 尝试增加读锁计数  </span><br>        <span class="hljs-comment">// 加锁成功  </span><br>        <span class="hljs-comment">// 加锁之前读锁为 0，说明当前线程是第一个读锁线程  </span><br>        <span class="hljs-keyword">if</span> (r == <span class="hljs-number">0</span>) &#123;  <br>            firstReader = current;  <br>            firstReaderHoldCount = <span class="hljs-number">1</span>;  <br>        <span class="hljs-comment">// 第一个读锁线程是自己就发生了读锁重入  </span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (firstReader == current) &#123;  <br>            firstReaderHoldCount++;  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            <span class="hljs-comment">// cachedHoldCounter 设置为当前线程的 holdCounter 对象，即最后一个获取读锁的线程  </span><br>            <span class="hljs-type">HoldCounter</span> <span class="hljs-variable">rh</span> <span class="hljs-operator">=</span> cachedHoldCounter;  <br>            <span class="hljs-comment">// 说明还没设置 rh  </span><br>            <span class="hljs-keyword">if</span> (rh == <span class="hljs-literal">null</span> || rh.tid != getThreadId(current))  <br>                <span class="hljs-comment">// 获取当前线程的锁重入的对象，赋值给 cachedHoldCounter  </span><br>                cachedHoldCounter = rh = readHolds.get();  <br>            <span class="hljs-comment">// 还没重入  </span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rh.count == <span class="hljs-number">0</span>)  <br>                readHolds.set(rh);  <br>            <span class="hljs-comment">// 重入 + 1  </span><br>            rh.count++;  <br>        &#125;  <br>        <span class="hljs-comment">// 读锁加锁成功  </span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <br>    &#125;  <br>    <span class="hljs-comment">// 逻辑到这 应该阻塞，或者 cas 加锁失败  </span><br>    <span class="hljs-comment">// 会不断尝试 for (;;) 获取读锁, 执行过程中无阻塞  </span><br>    <span class="hljs-keyword">return</span> fullTryAcquireShared(current);  <br>&#125;  <br><span class="hljs-comment">// 非公平锁 readerShouldBlock 偏向写锁一些，看 AQS 阻塞队列中第一个节点是否是写锁，是则阻塞，反之不阻塞  </span><br><span class="hljs-comment">// 防止一直有读锁线程，导致写锁线程饥饿  </span><br><span class="hljs-comment">// true 则该阻塞, false 则不阻塞  </span><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">readerShouldBlock</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">return</span> apparentlyFirstQueuedIsExclusive();  <br>&#125;  <br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">readerShouldBlock</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">return</span> hasQueuedPredecessors();  <br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fullTryAcquireShared</span><span class="hljs-params">(Thread current)</span> &#123;  <br>    <span class="hljs-comment">// 当前读锁线程持有的读锁次数对象  </span><br>    <span class="hljs-type">HoldCounter</span> <span class="hljs-variable">rh</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;  <br>    <span class="hljs-keyword">for</span> (;;) &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();  <br>        <span class="hljs-comment">// 说明有线程持有写锁  </span><br>        <span class="hljs-keyword">if</span> (exclusiveCount(c) != <span class="hljs-number">0</span>) &#123;  <br>            <span class="hljs-comment">// 写锁不是自己则获取锁失败  </span><br>            <span class="hljs-keyword">if</span> (getExclusiveOwnerThread() != current)  <br>                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;  <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (readerShouldBlock()) &#123;  <br>            <span class="hljs-comment">// 条件成立说明当前线程是 firstReader，当前锁是读忙碌状态，而且当前线程也是读锁重入  </span><br>            <span class="hljs-keyword">if</span> (firstReader == current) &#123;  <br>                <span class="hljs-comment">// assert firstReaderHoldCount &gt; 0;  </span><br>            &#125; <span class="hljs-keyword">else</span> &#123;  <br>                <span class="hljs-keyword">if</span> (rh == <span class="hljs-literal">null</span>) &#123;  <br>                    <span class="hljs-comment">// 最后一个读锁的 HoldCounter  </span><br>                    rh = cachedHoldCounter;  <br>                    <span class="hljs-comment">// 说明当前线程也不是最后一个读锁  </span><br>                    <span class="hljs-keyword">if</span> (rh == <span class="hljs-literal">null</span> || rh.tid != getThreadId(current)) &#123;  <br>                        <span class="hljs-comment">// 获取当前线程的 HoldCounter  </span><br>                        rh = readHolds.get();  <br>                        <span class="hljs-comment">// 条件成立说明 HoldCounter 对象是上一步代码新建的  </span><br>                        <span class="hljs-comment">// 当前线程不是锁重入，在 readerShouldBlock() 返回 true 时需要去排队  </span><br>                        <span class="hljs-keyword">if</span> (rh.count == <span class="hljs-number">0</span>)  <br>                            <span class="hljs-comment">// 防止内存泄漏  </span><br>                            readHolds.remove();  <br>                    &#125;  <br>                &#125;  <br>                <span class="hljs-keyword">if</span> (rh.count == <span class="hljs-number">0</span>)  <br>                    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-comment">// 越界判断  </span><br>        <span class="hljs-keyword">if</span> (sharedCount(c) == MAX_COUNT)  <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);  <br>        <span class="hljs-comment">// 读锁加锁，条件内的逻辑与 tryAcquireShared 相同  </span><br>        <span class="hljs-keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;  <br>            <span class="hljs-keyword">if</span> (sharedCount(c) == <span class="hljs-number">0</span>) &#123;  <br>                firstReader = current;  <br>                firstReaderHoldCount = <span class="hljs-number">1</span>;  <br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (firstReader == current) &#123;  <br>                firstReaderHoldCount++;  <br>            &#125; <span class="hljs-keyword">else</span> &#123;  <br>                <span class="hljs-keyword">if</span> (rh == <span class="hljs-literal">null</span>)  <br>                    rh = cachedHoldCounter;  <br>                <span class="hljs-keyword">if</span> (rh == <span class="hljs-literal">null</span> || rh.tid != getThreadId(current))  <br>                    rh = readHolds.get();  <br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rh.count == <span class="hljs-number">0</span>)  <br>                    readHolds.set(rh);  <br>                rh.count++;  <br>                cachedHoldCounter = rh; <span class="hljs-comment">// cache for release  </span><br>            &#125;  <br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>获取读锁失败，进入 sync.doAcquireShared(1) 流程开始阻塞，首先也是调用 addWaiter 添加节点，不同之处在于节点被设置为 Node.SHARED 模式而非 Node.EXCLUSIVE 模式，注意此时 t2 仍处于活跃状态</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;  <br>    <span class="hljs-comment">// 将当前线程关联到一个 Node 对象上, 模式为共享模式  </span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addWaiter(Node.SHARED);  <br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;  <br>        <span class="hljs-keyword">for</span> (;;) &#123;  <br>            <span class="hljs-comment">// 获取前驱节点  </span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();  <br>            <span class="hljs-comment">// 如果前驱节点就头节点就去尝试获取锁  </span><br>            <span class="hljs-keyword">if</span> (p == head) &#123;  <br>                <span class="hljs-comment">// 再一次尝试获取读锁  </span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> tryAcquireShared(arg);  <br>                <span class="hljs-comment">// r &gt;= 0 表示获取成功  </span><br>                <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;  <br>                    <span class="hljs-comment">//【这里会设置自己为头节点，唤醒相连的后序的共享节点】  </span><br>                    setHeadAndPropagate(node, r);  <br>                    p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC  </span><br>                    <span class="hljs-keyword">if</span> (interrupted)  <br>                        selfInterrupt();  <br>                    failed = <span class="hljs-literal">false</span>;  <br>                    <span class="hljs-keyword">return</span>;  <br>                &#125;  <br>            &#125;  <br>            <span class="hljs-comment">// 是否在获取读锁失败时阻塞       park 当前线程  </span><br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())  <br>                interrupted = <span class="hljs-literal">true</span>;  <br>        &#125;  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        <span class="hljs-keyword">if</span> (failed)  <br>            cancelAcquire(node);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>  如果没有成功，在 doAcquireShared 内 for (;;) 循环一次，shouldParkAfterFailedAcquire 内把前驱节点的 waitStatus 改为 -1，再 for (;;) 循环一次尝试 tryAcquireShared，不成功在 parkAndCheckInterrupt() 处 park</p><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041907782.png"></p></li><li><p>这种状态下，假设又有 t3 r.lock，t4 w.lock，这期间 t1 仍然持有锁，就变成了下面的样子</p><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041907677.png"></p></li></ul><hr><h5 id="解锁原理"><a href="#解锁原理" class="headerlink" title="解锁原理"></a>解锁原理</h5><ul><li><p>t1 w.unlock， 写锁解锁</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">// 释放锁  </span><br>    sync.release(<span class="hljs-number">1</span>);  <br>&#125;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;  <br>    <span class="hljs-comment">// 尝试释放锁  </span><br>    <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;  <br>        <span class="hljs-comment">// 头节点不为空并且不是等待状态不是 0，唤醒后继的非取消节点  </span><br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)  <br>            unparkSuccessor(h);  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>&#125;  <br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;  <br>    <span class="hljs-keyword">if</span> (!isHeldExclusively())  <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> getState() - releases;  <br>    <span class="hljs-comment">// 因为可重入的原因, 写锁计数为 0, 才算释放成功  </span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">free</span> <span class="hljs-operator">=</span> exclusiveCount(nextc) == <span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">if</span> (free)  <br>        setExclusiveOwnerThread(<span class="hljs-literal">null</span>);  <br>    setState(nextc);  <br>    <span class="hljs-keyword">return</span> free;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>唤醒流程 sync.unparkSuccessor，这时 t2 在 doAcquireShared 的 parkAndCheckInterrupt() 处恢复运行，继续循环，执行 tryAcquireShared 成功则让读锁计数加一</p></li><li><p>接下来 t2 调用 setHeadAndPropagate(node, 1)，它原本所在节点被置为头节点；还会检查下一个节点是否是 shared，如果是则调用 doReleaseShared() 将 head 的状态从 -1 改为 0 并唤醒下一个节点，这时 t3 在 doAcquireShared 内 parkAndCheckInterrupt() 处恢复运行，<strong>唤醒连续的所有的共享节点</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setHeadAndPropagate</span><span class="hljs-params">(Node node, <span class="hljs-type">int</span> propagate)</span> &#123;  <br>    <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;   <br>    <span class="hljs-comment">// 设置自己为 head 节点  </span><br>    setHead(node);  <br>    <span class="hljs-comment">// propagate 表示有共享资源（例如共享读锁或信号量），为 0 就没有资源  </span><br>    <span class="hljs-keyword">if</span> (propagate &gt; <span class="hljs-number">0</span> || h == <span class="hljs-literal">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span> ||  <br>        (h = head) == <span class="hljs-literal">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span>) &#123;  <br>        <span class="hljs-comment">// 获取下一个节点  </span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;  <br>        <span class="hljs-comment">// 如果当前是最后一个节点，或者下一个节点是【等待共享读锁的节点】  </span><br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.isShared())  <br>            <span class="hljs-comment">// 唤醒后继节点  </span><br>            doReleaseShared();  <br>    &#125;  <br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doReleaseShared</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">// 如果 head.waitStatus == Node.SIGNAL ==&gt; 0 成功, 下一个节点 unpark  </span><br><span class="hljs-comment">// 如果 head.waitStatus == 0 ==&gt; Node.PROPAGATE  </span><br>    <span class="hljs-keyword">for</span> (;;) &#123;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;  <br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h != tail) &#123;  <br>            <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> h.waitStatus;  <br>            <span class="hljs-comment">// SIGNAL 唤醒后继  </span><br>            <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;  <br>                <span class="hljs-comment">// 因为读锁共享，如果其它线程也在释放读锁，那么需要将 waitStatus 先改为 0  </span><br>            <span class="hljs-comment">// 防止 unparkSuccessor 被多次执行  </span><br>                <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>))  <br>                    <span class="hljs-keyword">continue</span>;    <br>                <span class="hljs-comment">// 唤醒后继节点  </span><br>                unparkSuccessor(h);  <br>            &#125;  <br>            <span class="hljs-comment">// 如果已经是 0 了，改为 -3，用来解决传播性  </span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp; !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))  <br>                <span class="hljs-keyword">continue</span>;                  <br>        &#125;  <br>        <span class="hljs-comment">// 条件不成立说明被唤醒的节点非常积极，直接将自己设置为了新的 head，  </span><br>        <span class="hljs-comment">// 此时唤醒它的节点（前驱）执行 h == head 不成立，所以不会跳出循环，会继续唤醒新的 head 节点的后继节点  </span><br>        <span class="hljs-keyword">if</span> (h == head)                     <br>            <span class="hljs-keyword">break</span>;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041908507.png"></p></li><li><p>下一个节点不是 shared 了，因此不会继续唤醒 t4 所在节点</p></li><li><p>t2 读锁解锁，进入 sync.releaseShared(1) 中，调用 tryReleaseShared(1) 让计数减一，但计数还不为零，t3 同样让计数减一，计数为零，进入doReleaseShared() 将头节点从 -1 改为 0 并唤醒下一个节点</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;  <br>    sync.releaseShared(<span class="hljs-number">1</span>);  <br>&#125;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">releaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;  <br>    <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;  <br>        doReleaseShared();  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> unused)</span> &#123;  <br>  <br>    <span class="hljs-keyword">for</span> (;;) &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c - SHARED_UNIT;  <br>        <span class="hljs-comment">// 读锁的计数不会影响其它获取读锁线程, 但会影响其它获取写锁线程，计数为 0 才是真正释放  </span><br>        <span class="hljs-keyword">if</span> (compareAndSetState(c, nextc))  <br>            <span class="hljs-comment">// 返回是否已经完全释放了   </span><br>            <span class="hljs-keyword">return</span> nextc == <span class="hljs-number">0</span>;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>t4 在 acquireQueued 中 parkAndCheckInterrupt 处恢复运行，再次 for (;;) 这次自己是头节点的临节点，并且没有其他节点竞争，tryAcquire(1) 成功，修改头结点，流程结束</p><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041909290.png"></p></li></ul><hr><h4 id="Stamped"><a href="#Stamped" class="headerlink" title="Stamped"></a>Stamped</h4><p>StampedLock：读写锁，该类自 JDK 8 加入，是为了进一步优化读性能</p><p>特点：</p><ul><li><p>在使用读锁、写锁时都必须配合戳使用</p></li><li><p>StampedLock 不支持条件变量</p></li><li><p>StampedLock <strong>不支持重入</strong></p></li></ul><p>基本用法</p><ul><li><p>加解读锁：</p><p>  long stamp &#x3D; lock.readLock();<br>  lock.unlockRead(stamp);&#x2F;&#x2F; 类似于 unpark，解指定的锁</p></li><li><p>加解写锁：</p><p>  long stamp &#x3D; lock.writeLock();<br>  lock.unlockWrite(stamp);</p></li><li><p>乐观读，StampedLock 支持 <code>tryOptimisticRead()</code> 方法，读取完毕后做一次<strong>戳校验</strong>，如果校验通过，表示这期间没有其他线程的写操作，数据可以安全使用，如果校验没通过，需要重新获取读锁，保证数据一致性</p><p>  long stamp &#x3D; lock.tryOptimisticRead();<br>  &#x2F;&#x2F; 验戳<br>  if(!lock.validate(stamp)){<br>  &#x2F;&#x2F; 锁升级<br>  }</p></li></ul><p>提供一个数据容器类内部分别使用读锁保护数据的 read() 方法，写锁保护数据的 write() 方法：</p><ul><li><p>读-读可以优化</p></li><li><p>读-写优化读，补加读锁</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>    <span class="hljs-type">DataContainerStamped</span> <span class="hljs-variable">dataContainer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataContainerStamped</span>(<span class="hljs-number">1</span>);  <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>    dataContainer.read(<span class="hljs-number">1000</span>);  <br>    &#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();  <br>    Thread.sleep(<span class="hljs-number">500</span>);  <br>      <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>        dataContainer.write(<span class="hljs-number">1000</span>);  <br>    &#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();  <br>&#125;  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DataContainerStamped</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> data;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">StampedLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StampedLock</span>();  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">int</span> readTime)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>        <span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> lock.tryOptimisticRead();  <br>        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>() + <span class="hljs-string">&quot; optimistic read locking&quot;</span> + stamp);  <br>        Thread.sleep(readTime);  <br>        <span class="hljs-comment">// 戳有效，直接返回数据  </span><br>        <span class="hljs-keyword">if</span> (lock.validate(stamp)) &#123;  <br>            Sout(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>() + <span class="hljs-string">&quot; optimistic read finish...&quot;</span> + stamp);  <br>            <span class="hljs-keyword">return</span> data;  <br>        &#125;  <br>  <br>        <span class="hljs-comment">// 说明其他线程更改了戳，需要锁升级了，从乐观读升级到读锁  </span><br>        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>() + <span class="hljs-string">&quot; updating to read lock&quot;</span> + stamp);  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            stamp = lock.readLock();  <br>            System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>() + <span class="hljs-string">&quot; read lock&quot;</span> + stamp);  <br>            Thread.sleep(readTime);  <br>            System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>() + <span class="hljs-string">&quot; read finish...&quot;</span> + stamp);  <br>            <span class="hljs-keyword">return</span> data;  <br>        &#125; <span class="hljs-keyword">finally</span> &#123;  <br>            System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>() + <span class="hljs-string">&quot; read unlock &quot;</span> +  stamp);  <br>            lock.unlockRead(stamp);  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">int</span> newData)</span> &#123;  <br>        <span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> lock.writeLock();  <br>        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>() + <span class="hljs-string">&quot; write lock &quot;</span> + stamp);  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            Thread.sleep(<span class="hljs-number">2000</span>);  <br>            <span class="hljs-built_in">this</span>.data = newData;  <br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>            e.printStackTrace();  <br>        &#125; <span class="hljs-keyword">finally</span> &#123;  <br>            System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>() + <span class="hljs-string">&quot; write unlock &quot;</span> + stamp);  <br>            lock.unlockWrite(stamp);  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="CountDown"><a href="#CountDown" class="headerlink" title="CountDown"></a>CountDown</h3><h4 id="基本使用-6"><a href="#基本使用-6" class="headerlink" title="基本使用"></a>基本使用</h4><p>CountDownLatch：计数器，用来进行线程同步协作，<strong>等待所有线程完成</strong></p><p>构造器：</p><ul><li><code>public CountDownLatch(int count)</code>：初始化唤醒需要的 down 几步</li></ul><p>常用API：</p><ul><li><p><code>public void await()</code>：让当前线程等待，必须 down 完初始化的数字才可以被唤醒，否则进入无限等待</p></li><li><p><code>public void countDown()</code>：计数器进行减 1（down 1）</p></li></ul><p>应用：同步等待多个 Rest 远程调用结束</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// LOL 10人进入游戏倒计时  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>    <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">latch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">10</span>);  <br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);  <br>    String[] all = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">10</span>];  <br>    <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();  <br>  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++) &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">finalJ</span> <span class="hljs-operator">=</span> j;<span class="hljs-comment">//常量  </span><br>        service.submit(() -&gt; &#123;  <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100</span>; i++) &#123;  <br>                Thread.sleep(random.nextInt(<span class="hljs-number">100</span>));<span class="hljs-comment">//随机休眠  </span><br>                all[finalJ] = i + <span class="hljs-string">&quot;%&quot;</span>;  <br>                System.out.print(<span class="hljs-string">&quot;\r&quot;</span> + Arrays.toString(all));<span class="hljs-comment">// \r代表覆盖  </span><br>            &#125;  <br>            latch.countDown();  <br>        &#125;);  <br>    &#125;  <br>    latch.await();  <br>    System.out.println(<span class="hljs-string">&quot;\n游戏开始&quot;</span>);  <br>    service.shutdown();  <br>&#125;  <br><span class="hljs-comment">/*  </span><br><span class="hljs-comment">[100%, 100%, 100%, 100%, 100%, 100%, 100%, 100%, 100%, 100%]  </span><br><span class="hljs-comment">游戏开始*/</span><br></code></pre></td></tr></table></figure><hr><h4 id="实现原理-6"><a href="#实现原理-6" class="headerlink" title="实现原理"></a>实现原理</h4><p>阻塞等待：</p><ul><li><p>线程调用 await() 等待其他线程完成任务：支持打断</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>    sync.acquireSharedInterruptibly(<span class="hljs-number">1</span>);  <br>&#125;  <br><span class="hljs-comment">// AbstractQueuedSynchronizer#acquireSharedInterruptibly  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireSharedInterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>    <span class="hljs-comment">// 判断线程是否被打断，抛出打断异常  </span><br>    <span class="hljs-keyword">if</span> (Thread.interrupted())  <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();  <br>    <span class="hljs-comment">// 尝试获取共享锁，条件成立说明 state &gt; 0，此时线程入队阻塞等待，等待其他线程获取共享资源  </span><br>    <span class="hljs-comment">// 条件不成立说明 state = 0，此时不需要阻塞线程，直接结束函数调用  </span><br>    <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)  <br>        doAcquireSharedInterruptibly(arg);  <br>&#125;  <br><span class="hljs-comment">// CountDownLatch.Sync#tryAcquireShared  </span><br><span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;  <br>    <span class="hljs-keyword">return</span> (getState() == <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>线程进入 AbstractQueuedSynchronizer#doAcquireSharedInterruptibly 函数阻塞挂起，等待 latch 变为 0：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAcquireSharedInterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>    <span class="hljs-comment">// 将调用latch.await()方法的线程 包装成 SHARED 类型的 node 加入到 AQS 的阻塞队列中  </span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addWaiter(Node.SHARED);  <br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-keyword">for</span> (;;) &#123;  <br>            <span class="hljs-comment">// 获取当前节点的前驱节点  </span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();  <br>            <span class="hljs-comment">// 前驱节点时头节点就可以尝试获取锁  </span><br>            <span class="hljs-keyword">if</span> (p == head) &#123;  <br>                <span class="hljs-comment">// 再次尝试获取锁，获取成功返回 1  </span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> tryAcquireShared(arg);  <br>                <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;  <br>                    <span class="hljs-comment">// 获取锁成功，设置当前节点为 head 节点，并且向后传播  </span><br>                    setHeadAndPropagate(node, r);  <br>                    p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC  </span><br>                    failed = <span class="hljs-literal">false</span>;  <br>                    <span class="hljs-keyword">return</span>;  <br>                &#125;  <br>            &#125;  <br>            <span class="hljs-comment">// 阻塞在这里  </span><br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())  <br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();  <br>        &#125;  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        <span class="hljs-comment">// 阻塞线程被中断后抛出异常，进入取消节点的逻辑  </span><br>        <span class="hljs-keyword">if</span> (failed)  <br>            cancelAcquire(node);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>获取共享锁成功，进入唤醒阻塞队列中与头节点相连的 SHARED 模式的节点：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setHeadAndPropagate</span><span class="hljs-params">(Node node, <span class="hljs-type">int</span> propagate)</span> &#123;  <br>    <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;  <br>    <span class="hljs-comment">// 将当前节点设置为新的 head 节点，前驱节点和持有线程置为 null  </span><br>    setHead(node);  <br><span class="hljs-comment">// propagate = 1，条件一成立  </span><br>    <span class="hljs-keyword">if</span> (propagate &gt; <span class="hljs-number">0</span> || h == <span class="hljs-literal">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span> || (h = head) == <span class="hljs-literal">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span>) &#123;  <br>        <span class="hljs-comment">// 获取当前节点的后继节点  </span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;  <br>        <span class="hljs-comment">// 当前节点是尾节点时 next 为 null，或者后继节点是 SHARED 共享模式  </span><br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.isShared())  <br>            <span class="hljs-comment">// 唤醒所有的等待共享锁的节点  </span><br>            doReleaseShared();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>计数减一：</p><ul><li><p>线程进入 countDown() 完成计数器减一（释放锁）的操作</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">countDown</span><span class="hljs-params">()</span> &#123;  <br>    sync.releaseShared(<span class="hljs-number">1</span>);  <br>&#125;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">releaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;  <br>    <span class="hljs-comment">// 尝试释放共享锁  </span><br>    <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;  <br>        <span class="hljs-comment">// 释放锁成功开始唤醒阻塞节点  </span><br>        doReleaseShared();  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>更新 state 值，每调用一次，state 值减一，当 state -1 正好为 0 时，返回 true</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;  <br>    <span class="hljs-keyword">for</span> (;;) &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();  <br>        <span class="hljs-comment">// 条件成立说明前面【已经有线程触发唤醒操作】了，这里返回 false  </span><br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>)  <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>        <span class="hljs-comment">// 计数器减一  </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c-<span class="hljs-number">1</span>;  <br>        <span class="hljs-keyword">if</span> (compareAndSetState(c, nextc))  <br>            <span class="hljs-comment">// 计数器为 0 时返回 true  </span><br>            <span class="hljs-keyword">return</span> nextc == <span class="hljs-number">0</span>;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>state &#x3D; 0 时，当前线程需要执行<strong>唤醒阻塞节点的任务</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doReleaseShared</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">for</span> (;;) &#123;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;  <br>        <span class="hljs-comment">// 判断队列是否是空队列  </span><br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h != tail) &#123;  <br>            <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> h.waitStatus;  <br>            <span class="hljs-comment">// 头节点的状态为 signal，说明后继节点没有被唤醒过  </span><br>            <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;  <br>                <span class="hljs-comment">// cas 设置头节点的状态为 0，设置失败继续自旋  </span><br>                <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>))  <br>                    <span class="hljs-keyword">continue</span>;  <br>                <span class="hljs-comment">// 唤醒后继节点  </span><br>                unparkSuccessor(h);  <br>            &#125;  <br>            <span class="hljs-comment">// 如果有其他线程已经设置了头节点的状态，重新设置为 PROPAGATE 传播属性  </span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp; !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))  <br>                <span class="hljs-keyword">continue</span>;  <br>        &#125;  <br>        <span class="hljs-comment">// 条件不成立说明被唤醒的节点非常积极，直接将自己设置为了新的head，  </span><br>        <span class="hljs-comment">// 此时唤醒它的节点（前驱）执行 h == head 不成立，所以不会跳出循环，会继续唤醒新的 head 节点的后继节点  </span><br>        <span class="hljs-keyword">if</span> (h == head)  <br>            <span class="hljs-keyword">break</span>;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><h4 id="基本使用-7"><a href="#基本使用-7" class="headerlink" title="基本使用"></a>基本使用</h4><p>CyclicBarrier：循环屏障，用来进行线程协作，等待线程满足某个计数，才能触发自己执行</p><p>常用方法：</p><ul><li><p><code>public CyclicBarrier(int parties, Runnable barrierAction)</code>：用于在线程到达屏障 parties 时，执行 barrierAction</p><ul><li><p>parties：代表多少个线程到达屏障开始触发线程任务</p></li><li><p>barrierAction：线程任务</p></li></ul></li><li><p><code>public int await()</code>：线程调用 await 方法通知 CyclicBarrier 本线程已经到达屏障</p></li></ul><p>与 CountDownLatch 的区别：CyclicBarrier 是可以重用的</p><p>应用：可以实现多线程中，某个任务在等待其他线程执行完毕以后触发</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">2</span>);  <br>    <span class="hljs-type">CyclicBarrier</span> <span class="hljs-variable">barrier</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CyclicBarrier</span>(<span class="hljs-number">2</span>, () -&gt; &#123;  <br>        System.out.println(<span class="hljs-string">&quot;task1 task2 finish...&quot;</span>);  <br>    &#125;);  <br>  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123; <span class="hljs-comment">// 循环重用  </span><br>        service.submit(() -&gt; &#123;  <br>            System.out.println(<span class="hljs-string">&quot;task1 begin...&quot;</span>);  <br>            <span class="hljs-keyword">try</span> &#123;  <br>                Thread.sleep(<span class="hljs-number">1000</span>);  <br>                barrier.await();    <span class="hljs-comment">// 2 - 1 = 1  </span><br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;  <br>                e.printStackTrace();  <br>            &#125;  <br>        &#125;);  <br>  <br>        service.submit(() -&gt; &#123;  <br>            System.out.println(<span class="hljs-string">&quot;task2 begin...&quot;</span>);  <br>            <span class="hljs-keyword">try</span> &#123;  <br>                Thread.sleep(<span class="hljs-number">2000</span>);  <br>                barrier.await();    <span class="hljs-comment">// 1 - 1 = 0  </span><br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;  <br>                e.printStackTrace();  <br>            &#125;  <br>        &#125;);  <br>    &#125;  <br>    service.shutdown();  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="实现原理-7"><a href="#实现原理-7" class="headerlink" title="实现原理"></a>实现原理</h4><h5 id="成员属性-6"><a href="#成员属性-6" class="headerlink" title="成员属性"></a>成员属性</h5><ul><li><p>全局锁：利用可重入锁实现的工具类</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// barrier 实现是依赖于Condition条件队列，condition 条件队列必须依赖lock才能使用  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();  <br><span class="hljs-comment">// 线程挂起实现使用的 condition 队列，当前代所有线程到位，这个条件队列内的线程才会被唤醒  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">trip</span> <span class="hljs-operator">=</span> lock.newCondition();<br></code></pre></td></tr></table></figure></li><li><p>线程数量：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> parties;<span class="hljs-comment">// 代表多少个线程到达屏障开始触发线程任务  </span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> count;<span class="hljs-comment">// 表示当前“代”还有多少个线程未到位，初始值为 parties</span><br></code></pre></td></tr></table></figure></li><li><p>当前代中最后一个线程到位后要执行的事件：</p><p>  <code>private final Runnable barrierCommand;</code></p></li><li><p>代：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// 表示 barrier 对象当前 代  </span><br><span class="hljs-keyword">private</span> <span class="hljs-type">Generation</span> <span class="hljs-variable">generation</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Generation</span>();  <br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Generation</span> &#123;  <br>    <span class="hljs-comment">// 表示当前“代”是否被打破，如果被打破再来到这一代的线程 就会直接抛出 BrokenException 异常  </span><br>    <span class="hljs-comment">// 且在这一代挂起的线程都会被唤醒，然后抛出 BrokerException 异常。  </span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">broken</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>构造方法：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">CyclicBarrie</span><span class="hljs-params">(<span class="hljs-type">int</span> parties, Runnable barrierAction)</span> &#123;  <br>    <span class="hljs-comment">// 因为小于等于 0 的 barrier 没有任何意义  </span><br>    <span class="hljs-keyword">if</span> (parties &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();  <br>  <br>    <span class="hljs-built_in">this</span>.parties = parties;  <br>    <span class="hljs-built_in">this</span>.count = parties;  <br>    <span class="hljs-comment">// 可以为 null  </span><br>    <span class="hljs-built_in">this</span>.barrierCommand = barrierAction;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041913080.png"></p><hr><h5 id="成员方法-5"><a href="#成员方法-5" class="headerlink" title="成员方法"></a>成员方法</h5><ul><li><p>await()：阻塞等待所有线程到位</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, BrokenBarrierException &#123;  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-keyword">return</span> dowait(<span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);  <br>    &#125; <span class="hljs-keyword">catch</span> (TimeoutException toe) &#123;  <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(toe); <span class="hljs-comment">// cannot happen  </span><br>    &#125;  <br>&#125;<br><br><span class="hljs-comment">// timed：表示当前调用await方法的线程是否指定了超时时长，如果 true 表示线程是响应超时的  </span><br><span class="hljs-comment">// nanos：线程等待超时时长，单位是纳秒  </span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dowait</span><span class="hljs-params">(<span class="hljs-type">boolean</span> timed, <span class="hljs-type">long</span> nanos)</span> &#123;  <br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;  <br>    <span class="hljs-comment">// 加锁  </span><br>    lock.lock();  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-comment">// 获取当前代  </span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Generation</span> <span class="hljs-variable">g</span> <span class="hljs-operator">=</span> generation;  <br>​  <br>        <span class="hljs-comment">// 【如果当前代是已经被打破状态，则当前调用await方法的线程，直接抛出Broken异常】  </span><br>        <span class="hljs-keyword">if</span> (g.broken)  <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BrokenBarrierException</span>();  <br>        <span class="hljs-comment">// 如果当前线程被中断了，则打破当前代，然后当前线程抛出中断异常  </span><br>        <span class="hljs-keyword">if</span> (Thread.interrupted()) &#123;  <br>            <span class="hljs-comment">// 设置当前代的状态为 broken 状态，唤醒在 trip 条件队列内的线程  </span><br>            breakBarrier();  <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();  <br>        &#125;  <br>​  <br>        <span class="hljs-comment">// 逻辑到这说明，当前线程中断状态是 false， 当前代的 broken 为 false（未打破状态）  </span><br>          <br>        <span class="hljs-comment">// 假设 parties 给的是 5，那么index对应的值为 4,3,2,1,0  </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> --count;  <br>        <span class="hljs-comment">// 条件成立说明当前线程是最后一个到达 barrier 的线程，【需要开启新代，唤醒阻塞线程】  </span><br>        <span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span>) &#123;  <br>            <span class="hljs-comment">// 栅栏任务启动标记  </span><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">ranAction</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;  <br>            <span class="hljs-keyword">try</span> &#123;  <br>                <span class="hljs-keyword">final</span> <span class="hljs-type">Runnable</span> <span class="hljs-variable">command</span> <span class="hljs-operator">=</span> barrierCommand;  <br>                <span class="hljs-keyword">if</span> (command != <span class="hljs-literal">null</span>)  <br>                    <span class="hljs-comment">// 启动触发的任务  </span><br>                    command.run();  <br>                <span class="hljs-comment">// run()未抛出异常的话，启动标记设置为 true  </span><br>                ranAction = <span class="hljs-literal">true</span>;  <br>                <span class="hljs-comment">// 开启新的一代，这里会【唤醒所有的阻塞队列】  </span><br>                nextGeneration();  <br>                <span class="hljs-comment">// 返回 0 因为当前线程是此代最后一个到达的线程，index == 0  </span><br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>            &#125; <span class="hljs-keyword">finally</span> &#123;  <br>                <span class="hljs-comment">// 如果 command.run() 执行抛出异常的话，会进入到这里  </span><br>                <span class="hljs-keyword">if</span> (!ranAction)  <br>                    breakBarrier();  <br>            &#125;  <br>        &#125;  <br>​  <br>        <span class="hljs-comment">// 自旋，一直到条件满足、当前代被打破、线程被中断，等待超时  </span><br>        <span class="hljs-keyword">for</span> (;;) &#123;  <br>            <span class="hljs-keyword">try</span> &#123;  <br>                <span class="hljs-comment">// 根据是否需要超时等待选择阻塞方法  </span><br>                <span class="hljs-keyword">if</span> (!timed)  <br>                    <span class="hljs-comment">// 当前线程释放掉 lock，【进入到 trip 条件队列的尾部挂起自己】，等待被唤醒  </span><br>                    trip.await();  <br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nanos &gt; <span class="hljs-number">0L</span>)  <br>                    nanos = trip.awaitNanos(nanos);  <br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException ie) &#123;  <br>                <span class="hljs-comment">// 被中断后来到这里的逻辑  </span><br>                  <br>                <span class="hljs-comment">// 当前代没有变化并且没有被打破  </span><br>                <span class="hljs-keyword">if</span> (g == generation &amp;&amp; !g.broken) &#123;  <br>                    <span class="hljs-comment">// 打破屏障  </span><br>                    breakBarrier();  <br>                    <span class="hljs-comment">// node 节点在【条件队列】内收到中断信号时 会抛出中断异常  </span><br>                    <span class="hljs-keyword">throw</span> ie;  <br>                &#125; <span class="hljs-keyword">else</span> &#123;  <br>                    <span class="hljs-comment">// 等待过程中代变化了，完成一次自我打断  </span><br>                    Thread.currentThread().interrupt();  <br>                &#125;  <br>            &#125;  <br>            <span class="hljs-comment">// 唤醒后的线程，【判断当前代已经被打破，线程唤醒后依次抛出 BrokenBarrier 异常】  </span><br>            <span class="hljs-keyword">if</span> (g.broken)  <br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BrokenBarrierException</span>();  <br>​  <br>            <span class="hljs-comment">// 当前线程挂起期间，最后一个线程到位了，然后触发了开启新的一代的逻辑  </span><br>            <span class="hljs-keyword">if</span> (g != generation)  <br>                <span class="hljs-keyword">return</span> index;  <br>            <span class="hljs-comment">// 当前线程 trip 中等待超时，然后主动转移到阻塞队列  </span><br>            <span class="hljs-keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="hljs-number">0L</span>) &#123;  <br>                breakBarrier();  <br>                <span class="hljs-comment">// 抛出超时异常  </span><br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimeoutException</span>();  <br>            &#125;  <br>        &#125;  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        <span class="hljs-comment">// 解锁  </span><br>        lock.unlock();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>breakBarrier()：打破 Barrier 屏障</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">breakBarrier</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">// 将代中的 broken 设置为 true，表示这一代是被打破了，再来到这一代的线程，直接抛出异常  </span><br>    generation.broken = <span class="hljs-literal">true</span>;  <br>    <span class="hljs-comment">// 重置 count 为 parties  </span><br>    count = parties;  <br>    <span class="hljs-comment">// 将在trip条件队列内挂起的线程全部唤醒，唤醒后的线程会检查当前是否是打破的，然后抛出异常  </span><br>    trip.signalAll();  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>nextGeneration()：开启新的下一代</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">nextGeneration</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">// 将在 trip 条件队列内挂起的线程全部唤醒  </span><br>    trip.signalAll();  <br>    <span class="hljs-comment">// 重置 count 为 parties  </span><br>    count = parties;  <br>  <br>    <span class="hljs-comment">// 开启新的一代，使用一个新的generation对象，表示新的一代，新的一代和上一代【没有任何关系】  </span><br>    generation = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Generation</span>();  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><h4 id="基本使用-8"><a href="#基本使用-8" class="headerlink" title="基本使用"></a>基本使用</h4><p>synchronized 可以起到锁的作用，但某个时间段内，只能有一个线程允许执行</p><p>Semaphore（信号量）用来限制能同时访问共享资源的线程上限，非重入锁</p><p>构造方法：</p><ul><li><p><code>public Semaphore(int permits)</code>：permits 表示许可线程的数量（state）</p></li><li><p><code>public Semaphore(int permits, boolean fair)</code>：fair 表示公平性，如果设为 true，下次执行的线程会是等待最久的线程</p></li></ul><p>常用API：</p><ul><li><p><code>public void acquire()</code>：表示获取许可</p></li><li><p><code>public void release()</code>：表示释放许可，acquire() 和 release() 方法之间的代码为同步代码</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    <span class="hljs-comment">// 1.创建Semaphore对象  </span><br>    <span class="hljs-type">Semaphore</span> <span class="hljs-variable">semaphore</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">3</span>);  <br>  <br>    <span class="hljs-comment">// 2. 10个线程同时运行  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;  <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>            <span class="hljs-keyword">try</span> &#123;  <br>                <span class="hljs-comment">// 3. 获取许可  </span><br>                semaphore.acquire();  <br>                sout(Thread.currentThread().getName() + <span class="hljs-string">&quot; running...&quot;</span>);  <br>                Thread.sleep(<span class="hljs-number">1000</span>);  <br>                sout(Thread.currentThread().getName() + <span class="hljs-string">&quot; end...&quot;</span>);  <br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>                e.printStackTrace();  <br>            &#125; <span class="hljs-keyword">finally</span> &#123;  <br>                <span class="hljs-comment">// 4. 释放许可  </span><br>                semaphore.release();  <br>            &#125;  <br>        &#125;).start();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="实现原理-8"><a href="#实现原理-8" class="headerlink" title="实现原理"></a>实现原理</h4><p>加锁流程：</p><ul><li><p>Semaphore 的 permits（state）为 3，这时 5 个线程来获取资源</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Sync(<span class="hljs-type">int</span> permits) &#123;  <br>    setState(permits);  <br>&#125;<br></code></pre></td></tr></table></figure><p>  假设其中 Thread-1，Thread-2，Thread-4 CAS 竞争成功，permits 变为 0，而 Thread-0 和 Thread-3 竞争失败，进入 AQS 队列park 阻塞</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// acquire() -&gt; sync.acquireSharedInterruptibly(1)，可中断  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireSharedInterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;  <br>    <span class="hljs-keyword">if</span> (Thread.interrupted())  <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();  <br>    <span class="hljs-comment">// 尝试获取通行证，获取成功返回 &gt;= 0的值  </span><br>    <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)  <br>        <span class="hljs-comment">// 获取许可证失败，进入阻塞  </span><br>        doAcquireSharedInterruptibly(arg);  <br>&#125;  <br>  <br><span class="hljs-comment">// tryAcquireShared() -&gt; nonfairTryAcquireShared()  </span><br><span class="hljs-comment">// 非公平，公平锁会在循环内 hasQueuedPredecessors()方法判断阻塞队列是否有临头节点(第二个节点)  </span><br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nonfairTryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;  <br>    <span class="hljs-keyword">for</span> (;;) &#123;  <br>        <span class="hljs-comment">// 获取 state ，state 这里【表示通行证】  </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">available</span> <span class="hljs-operator">=</span> getState();  <br>        <span class="hljs-comment">// 计算当前线程获取通行证完成之后，通行证还剩余数量  </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">remaining</span> <span class="hljs-operator">=</span> available - acquires;  <br>        <span class="hljs-comment">// 如果许可已经用完, 返回负数, 表示获取失败,  </span><br>        <span class="hljs-keyword">if</span> (remaining &lt; <span class="hljs-number">0</span> ||  <br>            <span class="hljs-comment">// 许可证足够分配的，如果 cas 重试成功, 返回正数, 表示获取成功  </span><br>            compareAndSetState(available, remaining))  <br>            <span class="hljs-keyword">return</span> remaining;  <br>    &#125;  <br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAcquireSharedInterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;  <br>    <span class="hljs-comment">// 将调用 Semaphore.aquire 方法的线程，包装成 node 加入到 AQS 的阻塞队列中  </span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addWaiter(Node.SHARED);  <br>    <span class="hljs-comment">// 获取标记  </span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-keyword">for</span> (;;) &#123;  <br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();  <br>            <span class="hljs-comment">// 前驱节点是头节点可以再次获取许可  </span><br>            <span class="hljs-keyword">if</span> (p == head) &#123;  <br>                <span class="hljs-comment">// 再次尝试获取许可，【返回剩余的许可证数量】  </span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> tryAcquireShared(arg);  <br>                <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;  <br>                    <span class="hljs-comment">// 成功后本线程出队（AQS）, 所在 Node设置为 head  </span><br>                    <span class="hljs-comment">// r 表示【可用资源数】, 为 0 则不会继续传播  </span><br>                    setHeadAndPropagate(node, r);   <br>                    p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC  </span><br>                    failed = <span class="hljs-literal">false</span>;  <br>                    <span class="hljs-keyword">return</span>;  <br>                &#125;  <br>            &#125;  <br>            <span class="hljs-comment">// 不成功, 设置上一个节点 waitStatus = Node.SIGNAL, 下轮进入 park 阻塞  </span><br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())  <br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();  <br>        &#125;  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        <span class="hljs-comment">// 被打断后进入该逻辑  </span><br>        <span class="hljs-keyword">if</span> (failed)  <br>            cancelAcquire(node);  <br>    &#125;  <br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setHeadAndPropagate</span><span class="hljs-params">(Node node, <span class="hljs-type">int</span> propagate)</span> &#123;      <br>    <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;  <br>    <span class="hljs-comment">// 设置自己为 head 节点  </span><br>    setHead(node);  <br>    <span class="hljs-comment">// propagate 表示有【共享资源】（例如共享读锁或信号量）  </span><br>    <span class="hljs-comment">// head waitStatus == Node.SIGNAL 或 Node.PROPAGATE，doReleaseShared 函数中设置的  </span><br>    <span class="hljs-keyword">if</span> (propagate &gt; <span class="hljs-number">0</span> || h == <span class="hljs-literal">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span> ||  <br>        (h = head) == <span class="hljs-literal">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span>) &#123;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;  <br>        <span class="hljs-comment">// 如果是最后一个节点或者是等待共享读锁的节点，做一次唤醒  </span><br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.isShared())  <br>            doReleaseShared();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041916624.png"></p></li><li><p>这时 Thread-4 释放了 permits，状态如下</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// release() -&gt; releaseShared()  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">releaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;  <br>    <span class="hljs-comment">// 尝试释放锁  </span><br>    <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;  <br>        doReleaseShared();  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    &#125;      <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>&#125;  <br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;      <br>    <span class="hljs-keyword">for</span> (;;) &#123;  <br>        <span class="hljs-comment">// 获取当前锁资源的可用许可证数量  </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> getState();  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> current + releases;  <br>        <span class="hljs-comment">// 索引越界判断  </span><br>        <span class="hljs-keyword">if</span> (next &lt; current)              <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum permit count exceeded&quot;</span>);          <br>        <span class="hljs-comment">// 释放锁  </span><br>        <span class="hljs-keyword">if</span> (compareAndSetState(current, next))              <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;      <br>    &#125;  <br>&#125;  <br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doReleaseShared</span><span class="hljs-params">()</span> &#123;      <br>    <span class="hljs-comment">// PROPAGATE 详解      </span><br>    <span class="hljs-comment">// 如果 head.waitStatus == Node.SIGNAL ==&gt; 0 成功, 下一个节点 unpark  </span><br>    <span class="hljs-comment">// 如果 head.waitStatus == 0 ==&gt; Node.PROPAGATE  </span><br>&#125;<br></code></pre></td></tr></table></figure><p>  <img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041917776.png"></p></li><li><p>接下来 Thread-0 竞争成功，permits 再次设置为 0，设置自己为 head 节点，并且 unpark 接下来的共享状态的 Thread-3 节点，但由于 permits 是 0，因此 Thread-3 在尝试不成功后再次进入 park 状态</p></li></ul><hr><h4 id="PROPAGATE"><a href="#PROPAGATE" class="headerlink" title="PROPAGATE"></a>PROPAGATE</h4><p>假设存在某次循环中队列里排队的结点情况为 <code>head(-1) → t1(-1) → t2(0)</code>，存在将要释放信号量的 T3 和 T4，释放顺序为先 T3 后 T4</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// 老版本代码  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setHeadAndPropagate</span><span class="hljs-params">(Node node, <span class="hljs-type">int</span> propagate)</span> &#123;      <br>    setHead(node);      <br>    <span class="hljs-comment">// 有空闲资源      </span><br>    <span class="hljs-keyword">if</span> (propagate &gt; <span class="hljs-number">0</span> &amp;&amp; node.waitStatus != <span class="hljs-number">0</span>) &#123;      <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;          <br>        <span class="hljs-comment">// 下一个          </span><br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.isShared())              <br>            unparkSuccessor(node);          <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>正常流程：</p><ul><li><p>T3 调用 releaseShared(1)，直接调用了 unparkSuccessor(head)，head.waitStatus 从 -1 变为 0</p></li><li><p>T1 由于 T3 释放信号量被唤醒，然后 T4 释放，唤醒 T2</p></li></ul><p>BUG 流程：</p><ul><li><p>T3 调用 releaseShared(1)，直接调用了 unparkSuccessor(head)，head.waitStatus 从 -1 变为 0</p></li><li><p>T1 由于 T3 释放信号量被唤醒，调用 tryAcquireShared，返回值为 0（获取锁成功，但没有剩余资源量）</p></li><li><p>T1 还没调用 setHeadAndPropagate 方法，T4 调用 releaseShared(1)，此时 head.waitStatus 为 0（此时读到的 head 和 1 中为同一个 head），不满足条件，因此不调用 unparkSuccessor(head)</p></li><li><p>T1 获取信号量成功，调用 setHeadAndPropagate(t1.node, 0) 时，因为不满足 propagate &gt; 0（剩余资源量 &#x3D;&#x3D; 0），从而不会唤醒后继结点， <strong>T2 线程得不到唤醒</strong></p></li></ul><p>更新后流程：</p><ul><li><p>T3 调用 releaseShared(1)，直接调用了 unparkSuccessor(head)，head.waitStatus 从 -1 变为 0</p></li><li><p>T1 由于 T3 释放信号量被唤醒，调用 tryAcquireShared，返回值为 0（获取锁成功，但没有剩余资源量）</p></li><li><p>T1 还没调用 setHeadAndPropagate 方法，T4 调用 releaseShared()，此时 head.waitStatus 为 0（此时读到的 head 和 1 中为同一个 head），调用 doReleaseShared() 将等待状态置为 <strong>PROPAGATE（-3）</strong></p></li><li><p>T1 获取信号量成功，调用 setHeadAndPropagate 时，读到 h.waitStatus &lt; 0，从而调用 doReleaseShared() 唤醒 T2</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setHeadAndPropagate</span><span class="hljs-params">(Node node, <span class="hljs-type">int</span> propagate)</span> &#123;      <br>    <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;  <br>    <span class="hljs-comment">// 设置自己为 head 节点  </span><br>    setHead(node);  <br>    <span class="hljs-comment">// propagate 表示有共享资源（例如共享读锁或信号量）  </span><br>    <span class="hljs-comment">// head waitStatus == Node.SIGNAL 或 Node.PROPAGATE  </span><br>    <span class="hljs-keyword">if</span> (propagate &gt; <span class="hljs-number">0</span> || h == <span class="hljs-literal">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span> ||  <br>        (h = head) == <span class="hljs-literal">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span>) &#123;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;  <br>        <span class="hljs-comment">// 如果是最后一个节点或者是等待共享读锁的节点，做一次唤醒  </span><br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.isShared())  <br>            doReleaseShared();  <br>    &#125;  <br>&#125;<br><br><span class="hljs-comment">// 唤醒  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doReleaseShared</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">// 如果 head.waitStatus == Node.SIGNAL ==&gt; 0 成功, 下一个节点 unpark  </span><br>    <span class="hljs-comment">// 如果 head.waitStatus == 0 ==&gt; Node.PROPAGATE      </span><br>    <span class="hljs-keyword">for</span> (;;) &#123;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;  <br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h != tail) &#123;  <br>            <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> h.waitStatus;  <br>            <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;  <br>                <span class="hljs-comment">// 防止 unparkSuccessor 被多次执行  </span><br>                <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>))  <br>                    <span class="hljs-keyword">continue</span>;  <br>                <span class="hljs-comment">// 唤醒后继节点  </span><br>                unparkSuccessor(h);  <br>            &#125;  <br>            <span class="hljs-comment">// 如果已经是 0 了，改为 -3，用来解决传播性  </span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp; !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))  <br>                <span class="hljs-keyword">continue</span>;  <br>        &#125;  <br>        <span class="hljs-keyword">if</span> (h == head)  <br>            <span class="hljs-keyword">break</span>;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h3><p>Exchanger：交换器，是一个用于线程间协作的工具类，用于进行线程间的数据交换</p><p>工作流程：两个线程通过 exchange 方法交换数据，如果第一个线程先执行 exchange() 方法，它会一直等待第二个线程也执行 exchange 方法，当两个线程都到达同步点时，这两个线程就可以交换数据</p><p>常用方法：</p><ul><li><p><code>public Exchanger()</code>：创建一个新的交换器</p></li><li><p><code>public V exchange(V x)</code>：等待另一个线程到达此交换点</p></li><li><p><code>public V exchange(V x, long timeout, TimeUnit unit)</code>：等待一定的时间</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExchangerDemo</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-comment">// 创建交换对象（信使）  </span><br>        Exchanger&lt;String&gt; exchanger = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exchanger</span>&lt;&gt;();  <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadA</span>(exchanger).start();  <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadB</span>(exchanger).start();  <br>    &#125;   <br>&#125;  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;  <br>    <span class="hljs-keyword">private</span> Exchanger&lt;String&gt; <span class="hljs-title function_">exchanger</span><span class="hljs-params">()</span>;  <br>      <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadA</span><span class="hljs-params">(Exchanger&lt;String&gt; exchanger)</span>&#123;  <br>        <span class="hljs-built_in">this</span>.exchanger = exchanger;  <br>    &#125;  <br>      <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">try</span>&#123;  <br>            sout(<span class="hljs-string">&quot;线程A，做好了礼物A，等待线程B送来的礼物B&quot;</span>);  <br>            <span class="hljs-comment">//如果等待了5s还没有交换就死亡（抛出异常）！  </span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> exchanger.exchange(<span class="hljs-string">&quot;礼物A&quot;</span>,<span class="hljs-number">5</span>,TimeUnit.SECONDS);  <br>            sout(<span class="hljs-string">&quot;线程A收到线程B的礼物：&quot;</span> + s);  <br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;  <br>            System.out.println(<span class="hljs-string">&quot;线程A等待了5s，没有收到礼物,最终就执行结束了!&quot;</span>);  <br>        &#125;  <br>    &#125;  <br>&#125;  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;  <br>    <span class="hljs-keyword">private</span> Exchanger&lt;String&gt; exchanger;  <br>      <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadB</span><span class="hljs-params">(Exchanger&lt;String&gt; exchanger)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.exchanger = exchanger;  <br>    &#125;  <br>      <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            sout(<span class="hljs-string">&quot;线程B,做好了礼物B,等待线程A送来的礼物A.....&quot;</span>);  <br>            <span class="hljs-comment">// 开始交换礼物。参数是送给其他线程的礼物!  </span><br>            sout(<span class="hljs-string">&quot;线程B收到线程A的礼物：&quot;</span> + exchanger.exchange(<span class="hljs-string">&quot;礼物B&quot;</span>));  <br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;  <br>            e.printStackTrace();  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并发</tag>
      
      <tag>JVM</tag>
      
      <tag>内存模型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于并发编程（上）</title>
    <link href="/posts/6aabc494/"/>
    <url>/posts/6aabc494/</url>
    
    <content type="html"><![CDATA[<p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402211423293.png"></p><hr><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>进程：程序是静止的，进程实体的运行过程就是进程，是系统进行<strong>资源分配的基本单位</strong></p><p>进程的特征：并发性、异步性、动态性、独立性、结构性</p><p><strong>线程</strong>：线程是属于进程的，是一个基本的 CPU 执行单元，是程序执行流的最小单元。线程是进程中的一个实体，是系统<strong>独立调度的基本单位</strong>，线程本身不拥有系统资源，只拥有一点在运行中必不可少的资源，与同属一个进程的其他线程共享进程所拥有的全部资源</p><p>关系：一个进程可以包含多个线程，这就是多线程，比如看视频是进程，图画、声音、广告等就是多个线程</p><p>线程的作用：使多道程序更好的并发执行，提高资源利用率和系统吞吐量，增强操作系统的并发性能</p><p>并发并行：</p><ul><li><p>并行：在同一时刻，有多个指令在多个 CPU 上同时执行</p></li><li><p>并发：在同一时刻，有多个指令在单个 CPU 上交替执行</p></li></ul><p>同步异步：</p><ul><li><p>需要等待结果返回，才能继续运行就是同步</p></li><li><p>不需要等待结果返回，就能继续运行就是异步</p></li></ul><hr><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>线程进程对比：</p><ul><li><p>进程基本上相互独立的，而线程存在于进程内，是进程的一个子集</p></li><li><p>进程拥有共享的资源，如内存空间等，供其<strong>内部的线程共享</strong></p></li><li><p>进程间通信较为复杂</p><p>  同一台计算机的进程通信称为 IPC（Inter-process communication）</p><ul><li><p>信号量：信号量是一个计数器，用于多进程对共享数据的访问，解决同步相关的问题并避免竞争条件</p></li><li><p>共享存储：多个进程可以访问同一块内存空间，需要使用信号量用来同步对共享存储的访问</p></li><li><p>管道通信：管道是用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件 pipe 文件，该文件同一时间只允许一个进程访问，所以只支持<strong>半双工通信</strong></p><ul><li><p>匿名管道（Pipes）：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信</p></li><li><p>命名管道（Names Pipes）：以磁盘文件的方式存在，可以实现本机任意两个进程通信，遵循 FIFO</p></li></ul></li><li><p>消息队列：内核中存储消息的链表，由消息队列标识符标识，能在不同进程之间提供<strong>全双工通信</strong>，对比管道：</p><ul><li><p>匿名管道存在于内存中的文件；命名管道存在于实际的磁盘介质或者文件系统；消息队列存放在内核中，只有在内核重启（操作系统重启）或者显示地删除一个消息队列时，该消息队列才被真正删除</p></li><li><p>读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收</p></li></ul></li></ul><p>  不同计算机之间的<strong>进程通信</strong>，需要通过网络，并遵守共同的协议，例如 HTTP</p><ul><li>套接字：与其它通信机制不同的是，可用于不同机器间的互相通信</li></ul></li><li><p>线程通信相对简单，因为线程之间共享进程内的内存，一个例子是多个线程可以访问同一个共享变量</p><p>  <strong>Java 中的通信机制</strong>：volatile、等待&#x2F;通知机制、join 方式、InheritableThreadLocal、MappedByteBuffer</p></li><li><p>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低</p></li></ul><hr><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><h4 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h4><p>Thread 创建线程方式：创建线程类，匿名内部类方式</p><ul><li><p><strong>start() 方法底层其实是给 CPU 注册当前线程，并且触发 run() 方法执行</strong></p></li><li><p>线程的启动必须调用 start() 方法，如果线程直接调用 run() 方法，相当于变成了普通类的执行，此时主线程将只有执行该线程</p></li><li><p>建议线程先创建子线程，主线程的任务放在之后，否则主线程（main）永远是先执行完</p></li></ul><p>Thread 构造器：</p><ul><li><p><code>public Thread()</code></p></li><li><p><code>public Thread(String name)</code></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadDemo</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();  <br>        t.start();  <br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">100</span> ; i++ )&#123;  <br>            System.out.println(<span class="hljs-string">&quot;main线程&quot;</span> + i)  <br>        &#125;  <br>        <span class="hljs-comment">// main线程输出放在上面 就变成有先后顺序了，因为是 main 线程驱动的子线程运行  </span><br>    &#125;  <br>&#125;  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">100</span> ; i++ ) &#123;  <br>            System.out.println(<span class="hljs-string">&quot;子线程输出：&quot;</span>+i)  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>继承 Thread 类的优缺点：</p><ul><li><p>优点：编码简单</p></li><li><p>缺点：线程类已经继承了 Thread 类无法继承其他类了，功能不能通过继承拓展（单继承的局限性）</p></li></ul><hr><h4 id="Runnable"><a href="#Runnable" class="headerlink" title="Runnable"></a>Runnable</h4><p>Runnable 创建线程方式：创建线程类，匿名内部类方式</p><p>Thread 的构造器：</p><ul><li><p><code>public Thread(Runnable target)</code></p></li><li><p><code>public Thread(Runnable target, String name)</code></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadDemo</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>();  <br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(target,<span class="hljs-string">&quot;1号线程&quot;</span>);  <br>t1.start();  <br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(target);<span class="hljs-comment">//Thread-0  </span><br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">10</span> ; i++ )&#123;  <br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;-&gt;&quot;</span> + i);  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Thread 类本身也是实现了 Runnable 接口</strong>，Thread 类中持有 Runnable 的属性，执行线程 run 方法底层是调用 Runnable run：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;  <br>    <span class="hljs-keyword">private</span> Runnable target;  <br>      <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">if</span> (target != <span class="hljs-literal">null</span>) &#123;  <br>          <span class="hljs-comment">// 底层调用的是 Runnable 的 run 方法  </span><br>            target.run();  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>Runnable 方式的优缺点：</p><ul><li><p>缺点：代码复杂一点。</p></li><li><p>优点：</p><ol><li><p>线程任务类只是实现了 Runnable 接口，可以继续继承其他类，避免了单继承的局限性</p></li><li><p>同一个线程任务对象可以被包装成多个线程对象</p></li><li><p>适合多个多个线程去共享同一个资源</p></li><li><p>实现解耦操作，线程任务代码可以被多个线程共享，线程任务代码和线程独立</p></li><li><p>线程池可以放入实现 Runnable 或 Callable 线程任务对象</p></li></ol></li></ul><hr><h4 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h4><p>实现 Callable 接口：</p><ol><li><p>定义一个线程任务类实现 Callable 接口，申明线程执行的结果类型</p></li><li><p>重写线程任务类的 call 方法，这个方法可以直接返回执行的结果</p></li><li><p>创建一个 Callable 的线程任务对象</p></li><li><p>把 Callable 的线程任务对象<strong>包装成一个未来任务对象</strong></p></li><li><p>把未来任务对象包装成线程对象</p></li><li><p>调用线程的 start() 方法启动线程</p></li></ol><p><code>public FutureTask(Callable&lt;V&gt; callable)</code>：未来任务对象，在线程执行完后得到线程的执行结果</p><ul><li><p>FutureTask 就是 Runnable 对象，因为 <strong>Thread 类只能执行 Runnable 实例的任务对象</strong>，所以把 Callable 包装成未来任务对象</p></li><li><p>线程池部分详解了 FutureTask 的源码</p></li></ul><p><code>public V get()</code>：同步等待 task 执行完毕的结果，如果在线程中获取另一个线程执行结果，会阻塞等待，用于线程同步</p><ul><li><p>get() 线程会阻塞等待任务执行完成</p></li><li><p>run() 执行完后会把结果设置到 FutureTask 的一个成员变量，get() 线程可以获取到该变量的值</p></li></ul><p>优缺点：</p><ul><li><p>优点：同 Runnable，并且能得到线程执行的结果</p></li><li><p>缺点：编码复杂</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadDemo</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">Callable</span> <span class="hljs-variable">call</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>();  <br>        FutureTask&lt;String&gt; task = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(call);  <br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task);  <br>        t.start();  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> task.get(); <span class="hljs-comment">// 获取call方法返回的结果（正常/异常结果）  </span><br>            System.out.println(s);  <br>        &#125;  <span class="hljs-keyword">catch</span> (Exception e) &#123;  <br>            e.printStackTrace();  <br>        &#125;  <br>    &#125;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;String&gt; &#123;  <br>    <span class="hljs-meta">@Override</span><span class="hljs-comment">//重写线程任务类方法  </span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;  <br>        <span class="hljs-keyword">return</span> Thread.currentThread().getName() + <span class="hljs-string">&quot;-&gt;&quot;</span> + <span class="hljs-string">&quot;Hello World&quot;</span>;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="线程方法"><a href="#线程方法" class="headerlink" title="线程方法"></a>线程方法</h3><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><p>Thread 类 API：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public void start()</td><td>启动一个新线程，Java虚拟机调用此线程的 run 方法</td></tr><tr><td>public void run()</td><td>线程启动后调用该方法</td></tr><tr><td>public void setName(String name)</td><td>给当前线程取名字</td></tr><tr><td>public void getName()</td><td>获取当前线程的名字 线程存在默认名称：子线程是 Thread-索引，主线程是 main</td></tr><tr><td>public static Thread currentThread()</td><td>获取当前线程对象，代码在哪个线程中执行</td></tr><tr><td>public static void sleep(long time)</td><td>让当前线程休眠多少毫秒再继续执行 <strong>Thread.sleep(0)</strong> : 让操作系统立刻重新进行一次 CPU 竞争</td></tr><tr><td>public static native void yield()</td><td>提示线程调度器让出当前线程对 CPU 的使用</td></tr><tr><td>public final int getPriority()</td><td>返回此线程的优先级</td></tr><tr><td>public final void setPriority(int priority)</td><td>更改此线程的优先级，常用 1 5 10</td></tr><tr><td>public void interrupt()</td><td>中断这个线程，异常处理机制</td></tr><tr><td>public static boolean interrupted()</td><td>判断当前线程是否被打断，清除打断标记</td></tr><tr><td>public boolean isInterrupted()</td><td>判断当前线程是否被打断，不清除打断标记</td></tr><tr><td>public final void join()</td><td>等待这个线程结束</td></tr><tr><td>public final void join(long millis)</td><td>等待这个线程死亡 millis 毫秒，0 意味着永远等待</td></tr><tr><td>public final native boolean isAlive()</td><td>线程是否存活（还没有运行完毕）</td></tr><tr><td>public final void setDaemon(boolean on)</td><td>将此线程标记为守护线程或用户线程</td></tr></tbody></table><hr><h4 id="run-start"><a href="#run-start" class="headerlink" title="run start"></a>run start</h4><p>run：称为线程体，包含了要执行的这个线程的内容，方法运行结束，此线程随即终止。直接调用 run 是在主线程中执行了 run，没有启动新的线程，需要顺序执行</p><p>start：使用 start 是启动新的线程，此线程处于就绪（可运行）状态，通过新的线程间接执行 run 中的代码</p><p>说明：<strong>线程控制资源类</strong></p><p>run() 方法中的异常不能抛出，只能 try&#x2F;catch</p><ul><li><p>因为父类中没有抛出任何异常，子类不能比父类抛出更多的异常</p></li><li><p><strong>异常不能跨线程传播回 main() 中</strong>，因此必须在本地进行处理</p></li></ul><hr><h4 id="sleep-yield"><a href="#sleep-yield" class="headerlink" title="sleep yield"></a>sleep yield</h4><p>sleep：</p><ul><li><p>调用 sleep 会让当前线程从 <code>Running</code> 进入 <code>Timed Waiting</code> 状态（阻塞）</p></li><li><p>sleep() 方法的过程中，<strong>线程不会释放对象锁</strong></p></li><li><p>其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException</p></li><li><p>睡眠结束后的线程未必会立刻得到执行，需要抢占 CPU</p></li><li><p>建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性</p></li></ul><p>yield：</p><ul><li><p>调用 yield 会让提示线程调度器让出当前线程对 CPU 的使用</p></li><li><p>具体的实现依赖于操作系统的任务调度器</p></li><li><p><strong>会放弃 CPU 资源，锁资源不会释放</strong></p></li></ul><hr><h4 id="join"><a href="#join" class="headerlink" title="join"></a>join</h4><p>public final void join()：等待这个线程结束</p><p>原理：调用者轮询检查线程 alive 状态，t1.join() 等价于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">join</span><span class="hljs-params">(<span class="hljs-type">long</span> millis)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>    <span class="hljs-comment">// 调用者线程进入 thread 的 waitSet 等待, 直到当前线程运行结束  </span><br>    <span class="hljs-keyword">while</span> (isAlive()) &#123;  <br>        wait(<span class="hljs-number">0</span>);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>join 方法是被 synchronized 修饰的，本质上是一个对象锁，其内部的 wait 方法调用也是释放锁的，但是<strong>释放的是当前的线程对象锁，而不是外面的锁</strong></p></li><li><p>当调用某个线程（t1）的 join 方法后，该线程（t1）抢占到 CPU 资源，就不再释放，直到线程执行完毕</p></li></ul><p>线程同步：</p><ul><li><p>join 实现线程同步，因为会阻塞等待另一个线程的结束，才能继续向下运行</p><ul><li><p>需要外部共享变量，不符合面向对象封装的思想</p></li><li><p>必须等待线程结束，不能配合线程池使用</p></li></ul></li><li><p>Future 实现（同步）：get() 方法阻塞等待执行结果</p><ul><li><p>main 线程接收结果</p></li><li><p>get 方法是让调用线程同步等待</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;  <br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>        test1();  <br>    &#125;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>            <span class="hljs-keyword">try</span> &#123;  <br>                Thread.sleep(<span class="hljs-number">1000</span>);  <br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>                e.printStackTrace();  <br>            &#125;  <br>            r = <span class="hljs-number">10</span>;  <br>        &#125;);  <br>        t1.start();  <br>        t1.join();<span class="hljs-comment">//不等待线程执行结束，输出的10  </span><br>        System.out.println(r);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h4><h5 id="打断线程"><a href="#打断线程" class="headerlink" title="打断线程"></a>打断线程</h5><p><code>public void interrupt()</code>：打断这个线程，异常处理机制</p><p><code>public static boolean interrupted()</code>：判断当前线程是否被打断，打断返回 true，<strong>清除打断标记</strong>，连续调用两次一定返回 false</p><p><code>public boolean isInterrupted()</code>：判断当前线程是否被打断，不清除打断标记</p><p>打断的线程会发生上下文切换，操作系统会保存线程信息，抢占到 CPU 后会从中断的地方接着运行（打断不是停止）</p><ul><li>sleep、wait、join 方法都会让线程进入阻塞状态，打断线程<strong>会清空打断状态</strong>（false）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            Thread.sleep(<span class="hljs-number">1000</span>);  <br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>            e.printStackTrace();  <br>        &#125;  <br>    &#125;, <span class="hljs-string">&quot;t1&quot;</span>);  <br>    t1.start();  <br>    Thread.sleep(<span class="hljs-number">500</span>);  <br>    t1.interrupt();  <br>    System.out.println(<span class="hljs-string">&quot; 打断状态: &#123;&#125;&quot;</span> + t1.isInterrupted());<span class="hljs-comment">// 打断状态: &#123;&#125;false  </span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>打断正常运行的线程：不会清空打断状态（true）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;  <br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;  <br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;  <br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();  <br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> current.isInterrupted();  <br>            <span class="hljs-keyword">if</span>(interrupted) &#123;  <br>                System.out.println(<span class="hljs-string">&quot; 打断状态: &#123;&#125;&quot;</span> + interrupted);<span class="hljs-comment">//打断状态: &#123;&#125;true  </span><br>                <span class="hljs-keyword">break</span>;  <br>            &#125;  <br>        &#125;  <br>    &#125;, <span class="hljs-string">&quot;t2&quot;</span>);  <br>    t2.start();  <br>    Thread.sleep(<span class="hljs-number">500</span>);  <br>    t2.interrupt();  <br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h5 id="打断-park"><a href="#打断-park" class="headerlink" title="打断 park"></a>打断 park</h5><p>park 作用类似 sleep，打断 park 线程，不会清空打断状态（true）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;  <br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>        System.out.println(<span class="hljs-string">&quot;park...&quot;</span>);  <br>        LockSupport.park();  <br>        System.out.println(<span class="hljs-string">&quot;unpark...&quot;</span>);  <br>        System.out.println(<span class="hljs-string">&quot;打断状态：&quot;</span> + Thread.currentThread().isInterrupted());<span class="hljs-comment">//打断状态：true  </span><br>    &#125;, <span class="hljs-string">&quot;t1&quot;</span>);  <br>    t1.start();  <br>    Thread.sleep(<span class="hljs-number">2000</span>);  <br>    t1.interrupt();  <br>&#125;<br></code></pre></td></tr></table></figure><p>如果打断标记已经是 true, 则 park 会失效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">LockSupport.park();  <br>System.out.println(<span class="hljs-string">&quot;unpark...&quot;</span>);  <br>LockSupport.park();<span class="hljs-comment">//失效，不会阻塞  </span><br>System.out.println(<span class="hljs-string">&quot;unpark...&quot;</span>);<span class="hljs-comment">//和上一个unpark同时执行</span><br></code></pre></td></tr></table></figure><p>可以修改获取打断状态方法，使用 <code>Thread.interrupted()</code>，清除打断标记</p><p>LockSupport 类在 同步 → park-un 详解</p><hr><h5 id="终止模式"><a href="#终止模式" class="headerlink" title="终止模式"></a>终止模式</h5><p>终止模式之两阶段终止模式：Two Phase Termination</p><p>目标：在一个线程 T1 中如何优雅终止线程 T2？优雅指的是给 T2 一个后置处理器</p><p>错误思想：</p><ul><li><p>使用线程对象的 stop() 方法停止线程：stop 方法会真正杀死线程，如果这时线程锁住了共享资源，当它被杀死后就再也没有机会释放锁，其它线程将永远无法获取锁</p></li><li><p>使用 System.exit(int) 方法停止线程：目的仅是停止一个线程，但这种做法会让整个程序都停止</p></li></ul><p>两阶段终止模式图示：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041617846.png"></p><p>打断线程可能在任何时间，所以需要考虑在任何时刻被打断的处理方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>        <span class="hljs-type">TwoPhaseTermination</span> <span class="hljs-variable">tpt</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TwoPhaseTermination</span>();  <br>        tpt.start();  <br>        Thread.sleep(<span class="hljs-number">3500</span>);  <br>        tpt.stop();  <br>    &#125;  <br>&#125;  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TwoPhaseTermination</span> &#123;  <br>    <span class="hljs-keyword">private</span> Thread monitor;  <br>    <span class="hljs-comment">// 启动监控线程  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;  <br>        monitor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;  <br>            <span class="hljs-meta">@Override</span>  <br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;  <br>                    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> Thread.currentThread();  <br>                    <span class="hljs-keyword">if</span> (thread.isInterrupted()) &#123;  <br>                        System.out.println(<span class="hljs-string">&quot;后置处理&quot;</span>);  <br>                        <span class="hljs-keyword">break</span>;  <br>                    &#125;  <br>                    <span class="hljs-keyword">try</span> &#123;  <br>                        Thread.sleep(<span class="hljs-number">1000</span>);<span class="hljs-comment">// 睡眠  </span><br>                        System.out.println(<span class="hljs-string">&quot;执行监控记录&quot;</span>);<span class="hljs-comment">// 在此被打断不会异常  </span><br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<span class="hljs-comment">// 在睡眠期间被打断，进入异常处理的逻辑  </span><br>                        e.printStackTrace();  <br>                        <span class="hljs-comment">// 重新设置打断标记，打断 sleep 会清除打断状态  </span><br>                        thread.interrupt();  <br>                    &#125;  <br>                &#125;  <br>            &#125;  <br>        &#125;);  <br>        monitor.start();  <br>    &#125;  <br>    <span class="hljs-comment">// 停止监控线程  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">()</span> &#123;  <br>        monitor.interrupt();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="daemon"><a href="#daemon" class="headerlink" title="daemon"></a>daemon</h4><p><code>public final void setDaemon(boolean on)</code>：如果是 true ，将此线程标记为守护线程</p><p>线程<strong>启动前</strong>调用此方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>() &#123;  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;running&quot;</span>);  <br>    &#125;  <br>&#125;;  <br><span class="hljs-comment">// 设置该线程为守护线程  </span><br>t.setDaemon(<span class="hljs-literal">true</span>);  <br>t.start();<br></code></pre></td></tr></table></figure><p>用户线程：平常创建的普通线程</p><p>守护线程：服务于用户线程，只要其它非守护线程运行结束了，即使守护线程代码没有执行完，也会强制结束。守护进程是<strong>脱离于终端并且在后台运行的进程</strong>，脱离终端是为了避免在执行的过程中的信息在终端上显示</p><p>说明：当运行的线程都是守护线程，Java 虚拟机将退出，因为普通线程执行完后，JVM 是守护线程，不会继续运行下去</p><p>常见的守护线程：</p><ul><li><p>垃圾回收器线程就是一种守护线程</p></li><li><p>Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等待它们处理完当前请求</p></li></ul><hr><h4 id="不推荐"><a href="#不推荐" class="headerlink" title="不推荐"></a>不推荐</h4><p>不推荐使用的方法，这些方法已过时，容易破坏同步代码块，造成线程死锁：</p><ul><li><p><code>public final void stop()</code>：停止线程运行</p><p>  废弃原因：方法粗暴，除非可能执行 finally 代码块以及释放 synchronized 外，线程将直接被终止，如果线程持有 JUC 的互斥锁可能导致锁来不及释放，造成其他线程永远等待的局面</p></li><li><p><code>public final void suspend()</code>：<strong>挂起（暂停）线程运行</strong></p><p>  废弃原因：如果目标线程在暂停时对系统资源持有锁，则在目标线程恢复之前没有线程可以访问该资源，如果<strong>恢复目标线程的线程</strong>在调用 resume 之前会尝试访问此共享资源，则会导致死锁</p></li><li><p><code>public final void resume()</code>：恢复线程运行</p></li></ul><hr><h3 id="线程原理"><a href="#线程原理" class="headerlink" title="线程原理"></a>线程原理</h3><h4 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h4><p>Java Virtual Machine Stacks（Java 虚拟机栈）：每个线程启动后，虚拟机就会为其分配一块栈内存</p><ul><li><p>每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存</p></li><li><p>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</p></li></ul><p>线程上下文切换（Thread Context Switch）：一些原因导致 CPU 不再执行当前线程，转而执行另一个线程</p><ul><li><p>线程的 CPU 时间片用完</p></li><li><p>垃圾回收</p></li><li><p>有更高优先级的线程需要运行</p></li><li><p>线程自己调用了 sleep、yield、wait、join、park 等方法</p></li></ul><p>程序计数器（Program Counter Register）：记住下一条 JVM 指令的执行地址，是线程私有的</p><p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态（PCB 中），并恢复另一个线程的状态，包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等</p><p>JVM 规范并没有限定线程模型，以 HotSopot 为例：</p><ul><li><p>Java 的线程是内核级线程（1:1 线程模型），每个 Java 线程都映射到一个操作系统原生线程，需要消耗一定的内核资源（堆栈）</p></li><li><p><strong>线程的调度是在内核态运行的，而线程中的代码是在用户态运行</strong>，所以线程切换（状态改变）会导致用户与内核态转换进行系统调用，这是非常消耗性能</p></li></ul><p>Java 中 main 方法启动的是一个进程也是一个主线程，main 方法里面的其他线程均为子线程，main 线程是这些线程的父线程</p><hr><h4 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h4><p>线程调度指系统为线程分配处理器使用权的过程，方式有两种：协同式线程调度、抢占式线程调度（Java 选择）</p><p>协同式线程调度：线程的执行时间由线程本身控制</p><ul><li><p>优点：线程做完任务才通知系统切换到其他线程，相当于所有线程串行执行，不会出现线程同步问题</p></li><li><p>缺点：线程执行时间不可控，如果代码编写出现问题，可能导致程序一直阻塞，引起系统的奔溃</p></li></ul><p>抢占式线程调度：线程的执行时间由系统分配</p><ul><li><p>优点：线程执行时间可控，不会因为一个线程的问题而导致整体系统不可用</p></li><li><p>缺点：无法主动为某个线程多分配时间</p></li></ul><p>Java 提供了线程优先级的机制，优先级会提示（hint）调度器优先调度该线程，但这仅仅是一个提示，调度器可以忽略它。在线程的就绪状态时，如果 CPU 比较忙，那么优先级高的线程会获得更多的时间片，但 CPU 闲时，优先级几乎没作用</p><p>说明：并不能通过优先级来判断线程执行的先后顺序</p><hr><h4 id="未来优化"><a href="#未来优化" class="headerlink" title="未来优化"></a>未来优化</h4><p>内核级线程调度的成本较大，所以引入了更轻量级的协程。用户线程的调度由用户自己实现（多对一的线程模型，多<strong>个用户线程映射到一个内核级线程</strong>），被设计为协同式调度，所以叫协程</p><ul><li><p>有栈协程：协程会完整的做调用栈的保护、恢复工作，所以叫有栈协程</p></li><li><p>无栈协程：本质上是一种有限状态机，状态保存在闭包里，比有栈协程更轻量，但是功能有限</p></li></ul><p>有栈协程中有一种特例叫纤程，在新并发模型中，一段纤程的代码被分为两部分，执行过程和调度器：</p><ul><li><p>执行过程：用于维护执行现场，保护、恢复上下文状态</p></li><li><p>调度器：负责编排所有要执行的代码顺序</p></li></ul><hr><h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><p>进程的状态参考操作系统：创建态、就绪态、运行态、阻塞态、终止态</p><p>线程由生到死的完整过程（生命周期）：当线程被创建并启动以后，既不是一启动就进入了执行状态，也不是一直处于执行状态，在 API 中 <code>java.lang.Thread.State</code> 这个枚举中给出了六种线程状态：</p><table><thead><tr><th>线程状态</th><th>导致状态发生条件</th></tr></thead><tbody><tr><td>NEW（新建）</td><td>线程刚被创建，但是并未启动，还没调用 start 方法，只有线程对象，没有线程特征</td></tr><tr><td>Runnable（可运行）</td><td>线程可以在 Java 虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操作系统处理器，调用了 t.start() 方法：就绪（经典叫法）</td></tr><tr><td>Blocked（阻塞）</td><td>当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入 Blocked 状态；当该线程持有锁时，该线程将变成 Runnable 状态</td></tr><tr><td>Waiting（无限等待）</td><td>一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入 Waiting 状态，进入这个状态后不能自动唤醒，必须等待另一个线程调用 notify 或者 notifyAll 方法才能唤醒</td></tr><tr><td>Timed Waiting （限期等待）</td><td>有几个方法有超时参数，调用将进入 Timed Waiting 状态，这一状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有 Thread.sleep 、Object.wait</td></tr><tr><td>Teminated（结束）</td><td>run 方法正常退出而死亡，或者因为没有捕获的异常终止了 run 方法而死亡</td></tr></tbody></table><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041618351.png"></p><ul><li><p>NEW → RUNNABLE：当调用 t.start() 方法时，由 NEW → RUNNABLE</p></li><li><p>RUNNABLE &lt;–&gt; WAITING：</p><ul><li><p>调用 obj.wait() 方法时</p><p>  调用 obj.notify()、obj.notifyAll()、t.interrupt()：</p><ul><li><p>竞争锁成功，t 线程从 WAITING → RUNNABLE</p></li><li><p>竞争锁失败，t 线程从 WAITING → BLOCKED</p></li></ul></li><li><p>当前线程调用 t.join() 方法，注意是当前线程在 t 线程对象的监视器上等待</p></li><li><p>当前线程调用 LockSupport.park() 方法</p></li></ul></li><li><p>RUNNABLE &lt;–&gt; TIMED_WAITING：调用 obj.wait(long n) 方法、当前线程调用 t.join(long n) 方法、当前线程调用 Thread.sleep(long n)</p></li><li><p>RUNNABLE &lt;–&gt; BLOCKED：t 线程用 synchronized(obj) 获取了对象锁时竞争失败</p></li></ul><hr><h3 id="查看线程"><a href="#查看线程" class="headerlink" title="查看线程"></a>查看线程</h3><p>Windows：</p><ul><li><p>任务管理器可以查看进程和线程数，也可以用来杀死进程</p></li><li><p>tasklist 查看进程</p></li><li><p>taskkill 杀死进程</p></li></ul><p>Linux：</p><ul><li><p>ps -ef 查看所有进程</p></li><li><p>ps -fT -p &lt; PID&gt; 查看某个进程（PID）的所有线程</p></li><li><p>kill 杀死进程</p></li><li><p>top 按大写 H 切换是否显示线程</p></li><li><p>top -H -p &lt; PID&gt; 查看某个进程（PID）的所有线程</p></li></ul><p>Java：</p><ul><li><p>jps 命令查看所有 Java 进程</p></li><li><p>jstack &lt; PID&gt; 查看某个 Java 进程（PID）的所有线程状态</p></li><li><p>jconsole 来查看某个 Java 进程中线程的运行情况（图形界面）</p></li></ul><hr><h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><p>临界资源：一次仅允许一个进程使用的资源成为临界资源</p><p>临界区：访问临界资源的代码块</p><p>竞态条件：多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了竞态条件</p><p>一个程序运行多个线程是没有问题，多个线程读共享资源也没有问题，在多个线程对共享资源读写操作时发生指令交错，就会出现问题</p><p>为了避免临界区的竞态条件发生（解决线程安全问题）：</p><ul><li><p>阻塞式的解决方案：synchronized，lock</p></li><li><p>非阻塞式的解决方案：原子变量</p></li></ul><p>管程（monitor）：由局部于自己的若干公共变量和所有访问这些公共变量的过程所组成的软件模块，保证同一时刻只有一个进程在管程内活动，即管程内定义的操作在同一时刻只被一个进程调用（由编译器实现）</p><p><strong>synchronized：对象锁，保证了临界区内代码的原子性</strong>，采用互斥的方式让同一时刻至多只有一个线程能持有对象锁，其它线程获取这个对象锁时会阻塞，保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换</p><p>互斥和同步都可以采用 synchronized 关键字来完成，区别：</p><ul><li><p>互斥是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区代码</p></li><li><p>同步是由于线程执行的先后、顺序不同、需要一个线程等待其它线程运行到某个点</p></li></ul><p>性能：</p><ul><li><p>线程安全，性能差</p></li><li><p>线程不安全性能好，假如开发中不会存在多线程安全问题，建议使用线程不安全的设计类</p></li></ul><hr><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><h4 id="使用锁"><a href="#使用锁" class="headerlink" title="使用锁"></a>使用锁</h4><h5 id="同步块"><a href="#同步块" class="headerlink" title="同步块"></a>同步块</h5><p>锁对象：理论上可以是<strong>任意的唯一对象</strong></p><p>synchronized 是可重入、不公平的重量级锁</p><p>原则上：</p><ul><li><p>锁对象建议使用共享资源</p></li><li><p>在实例方法中使用 this 作为锁对象，锁住的 this 正好是共享资源</p></li><li><p>在静态方法中使用类名 .class 字节码作为锁对象，因为静态成员属于类，被所有实例对象共享，所以需要锁住类</p></li></ul><p>同步代码块格式：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">synchronized</span><span class="hljs-params">(锁对象)</span></span>&#123;  <br><span class="hljs-comment">// 访问共享资源的核心代码  </span><br>&#125;<br></code></pre></td></tr></table></figure><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">demo</span> &#123;  <br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br>    <span class="hljs-comment">//static修饰，则元素是属于类本身的，不属于对象  ，与类一起加载一次，只有一个  </span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">room</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;  <br>                <span class="hljs-keyword">synchronized</span> (room) &#123;  <br>                    counter++;  <br>                &#125;  <br>            &#125;  <br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);  <br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;  <br>                <span class="hljs-keyword">synchronized</span> (room) &#123;  <br>                    counter--;  <br>                &#125;  <br>            &#125;  <br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>);  <br>        t1.start();  <br>        t2.start();  <br>        t1.join();  <br>        t2.join();  <br>        System.out.println(counter);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h5><p>把出现线程安全问题的核心方法锁起来，每次只能一个线程进入访问</p><p>synchronized 修饰的方法的不具备继承性，所以子类是线程不安全的，如果子类的方法也被 synchronized 修饰，两个锁对象其实是一把锁，而且是<strong>子类对象作为锁</strong></p><p>用法：直接给方法加上一个修饰符 synchronized</p><p>&#x2F;&#x2F;同步方法  </p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada">修饰符 <span class="hljs-keyword">synchronized</span> 返回值类型 方法名(方法参数) &#123;   <br>方法体；  <br>&#125;  <br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F;同步静态方法  </p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino">修饰符 <span class="hljs-type">static</span> <span class="hljs-keyword">synchronized</span> 返回值类型 方法名(方法参数) &#123;   <br>方法体；  <br>&#125;<br></code></pre></td></tr></table></figure><p>同步方法底层也是有锁对象的：</p><ul><li>如果方法是实例方法：同步方法默认用 this 作为的锁对象</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> synchronized <span class="hljs-built_in">void</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;&#125; <span class="hljs-comment">//等价于  </span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;  <br><span class="hljs-title function_">synchronized</span>(<span class="hljs-params"><span class="hljs-variable language_">this</span></span>) &#123;&#125;  <br> &#125;<br></code></pre></td></tr></table></figure><ul><li>如果方法是静态方法：同步方法默认用类名 .class 作为的锁对象</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;  <br><span class="hljs-keyword">public</span> synchronized <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;&#125;  <br>&#125;  <br><span class="hljs-comment">//等价于  </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;  <br>        <span class="hljs-title function_">synchronized</span>(<span class="hljs-params">Test.<span class="hljs-keyword">class</span></span>) &#123;&#125;  <br>&#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="线程八锁"><a href="#线程八锁" class="headerlink" title="线程八锁"></a>线程八锁</h5><p>线程八锁就是考察 synchronized 锁住的是哪个对象，直接百度搜索相关的实例</p><p>说明：主要关注锁住的对象是不是同一个</p><ul><li><p>锁住类对象，所有类的实例的方法都是安全的，类的所有实例都相当于同一把锁</p></li><li><p>锁住 this 对象，只有在当前实例对象的线程内是安全的，如果有多个实例就不安全</p></li></ul><p>线程不安全：因为锁住的不是同一个对象，线程 1 调用 a 方法锁住的n1对象，线程 2 调用 b 方法锁住的 n2 对象，不是同一个对象</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Number</span>&#123;  <br>    public <span class="hljs-keyword">static</span> synchronized <span class="hljs-literal">void</span> a()&#123;  <br>        Thread.sleep(<span class="hljs-number">1000</span>);  <br>        System.out.println(<span class="hljs-string">&quot;1&quot;</span>);  <br>    &#125;  <br>    public synchronized <span class="hljs-literal">void</span> b() &#123;  <br>        System.out.println(<span class="hljs-string">&quot;2&quot;</span>);  <br>    &#125;  <br>&#125;  <br>public <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> main(<span class="hljs-built_in">String</span>[] args) &#123;  <br>    <span class="hljs-built_in">Number</span> n1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>();  <br>    <span class="hljs-built_in">Number</span> n2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>();  <br>    <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(()-&gt;&#123; n1.a(); &#125;)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;  </span><br><span class="hljs-function">    <span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(()-&gt;&#123; n2.b(); &#125;)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;  </span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><p>线程安全：因为 n1 调用 a() 方法，锁住的是类对象，n2 调用 b() 方法，锁住的也是类对象，所以线程安全</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Number</span>&#123;  <br>    public <span class="hljs-keyword">static</span> synchronized <span class="hljs-literal">void</span> a()&#123;  <br>        Thread.sleep(<span class="hljs-number">1000</span>);  <br>        System.out.println(<span class="hljs-string">&quot;1&quot;</span>);  <br>    &#125;  <br>    public <span class="hljs-keyword">static</span> synchronized <span class="hljs-literal">void</span> b() &#123;  <br>        System.out.println(<span class="hljs-string">&quot;2&quot;</span>);  <br>    &#125;  <br>&#125;  <br>public <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> main(<span class="hljs-built_in">String</span>[] args) &#123;  <br>    <span class="hljs-built_in">Number</span> n1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>();  <br>    <span class="hljs-built_in">Number</span> n2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>();  <br>    <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(()-&gt;&#123; n1.a(); &#125;)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;  </span><br><span class="hljs-function">    <span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(()-&gt;&#123; n2.b(); &#125;)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;  </span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><hr><h4 id="锁原理"><a href="#锁原理" class="headerlink" title="锁原理"></a>锁原理</h4><h5 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h5><p>Monitor 被翻译为监视器或管程</p><p>每个 Java 对象都可以关联一个 Monitor 对象，Monitor 也是 class，其<strong>实例存储在堆中</strong>，如果使用 synchronized 给对象上锁（重量级）之后，该对象头的 Mark Word 中就被设置指向 Monitor 对象的指针，这就是重量级锁</p><ul><li>Mark Word 结构：最后两位是<strong>锁标志位</strong></li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041620782.png"></p><ul><li>64 位虚拟机 Mark Word：</li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041620048.png"></p><p>工作流程：</p><ul><li><p>开始时 Monitor 中 Owner 为 null</p></li><li><p>当 Thread-2 执行 synchronized(obj) 就会将 Monitor 的所有者 Owner 置为 Thread-2，Monitor 中只能有一个 Owner，<strong>obj 对象的 Mark Word 指向 Monitor</strong>，把<strong>对象原有的 MarkWord 存入线程栈中的锁记录</strong>中（轻量级锁部分详解）<br><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041621477.png">    </p></li><li><p>在 Thread-2 上锁的过程，Thread-3、Thread-4、Thread-5 也执行 synchronized(obj)，就会进入 EntryList BLOCKED（双向链表）</p></li><li><p>Thread-2 执行完同步代码块的内容，根据 obj 对象头中 Monitor 地址寻找，设置 Owner 为空，把线程栈的锁记录中的对象头的值设置回 MarkWord</p></li><li><p>唤醒 EntryList 中等待的线程来竞争锁，竞争是<strong>非公平的</strong>，如果这时有新的线程想要获取锁，可能直接就抢占到了，阻塞队列的线程就会继续阻塞</p></li><li><p>WaitSet 中的 Thread-0，是以前获得过锁，但条件不满足进入 WAITING 状态的线程（wait-notify 机制）</p></li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041621372.png"></p><p>注意：</p><ul><li><p>synchronized 必须是进入同一个对象的 Monitor 才有上述的效果</p></li><li><p>不加 synchronized 的对象不会关联监视器，不遵从以上规则</p></li></ul><hr><h5 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h5><p>代码：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) &#123;  <br>    Object lock = <span class="hljs-keyword">new</span> Object();  <br>    <span class="hljs-keyword">synchronized</span> (lock) &#123;  <br>        System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;ok&quot;</span>);  <br>    &#125;  <br>&#125;<br><br><span class="hljs-number">0</span>: <span class="hljs-keyword">new</span>#<span class="hljs-number">2</span><span class="hljs-comment">// new Object  </span><br><span class="hljs-number">3</span>: dup  <br><span class="hljs-number">4</span>: invokespecial #<span class="hljs-number">1</span> <span class="hljs-comment">// invokespecial &lt;init&gt;:()V，非虚方法  </span><br><span class="hljs-number">7</span>: astore_1 <span class="hljs-comment">// lock引用 -&gt; lock  </span><br><span class="hljs-number">8</span>: aload_1<span class="hljs-comment">// lock （synchronized开始）  </span><br><span class="hljs-number">9</span>: dup<span class="hljs-comment">// 一份用来初始化，一份用来引用  </span><br><span class="hljs-number">10</span>: astore_2 <span class="hljs-comment">// lock引用 -&gt; slot 2  </span><br><span class="hljs-number">11</span>: monitorenter <span class="hljs-comment">// 【将 lock对象 MarkWord 置为 Monitor 指针】  </span><br><span class="hljs-number">12</span>: getstatic #<span class="hljs-number">3</span><span class="hljs-comment">// System.out  </span><br><span class="hljs-number">15</span>: ldc #<span class="hljs-number">4</span><span class="hljs-comment">// &quot;ok&quot;  </span><br><span class="hljs-number">17</span>: invokevirtual #<span class="hljs-number">5</span> <span class="hljs-comment">// invokevirtual println:(Ljava/lang/String;)V  </span><br><span class="hljs-number">20</span>: aload_2 <span class="hljs-comment">// slot 2(lock引用)  </span><br><span class="hljs-number">21</span>: monitorexit <span class="hljs-comment">// 【将 lock对象 MarkWord 重置, 唤醒 EntryList】  </span><br><span class="hljs-number">22</span>: goto <span class="hljs-number">30</span>  <br><span class="hljs-number">25</span>: astore_3 <span class="hljs-comment">// any -&gt; slot 3  </span><br><span class="hljs-number">26</span>: aload_2 <span class="hljs-comment">// slot 2(lock引用)  </span><br><span class="hljs-number">27</span>: monitorexit <span class="hljs-comment">// 【将 lock对象 MarkWord 重置, 唤醒 EntryList】  </span><br><span class="hljs-number">28</span>: aload_3  <br><span class="hljs-number">29</span>: athrow  <br><span class="hljs-number">30</span>: <span class="hljs-keyword">return</span>  <br>Exception table:  <br>    <span class="hljs-keyword">from</span> to target type  <br>      <span class="hljs-number">12</span> <span class="hljs-number">22</span> <span class="hljs-number">25</span> <span class="hljs-keyword">any</span>  <br>      <span class="hljs-number">25</span> <span class="hljs-number">28</span> <span class="hljs-number">25</span> <span class="hljs-keyword">any</span>  <br>LineNumberTable: ...  <br>LocalVariableTable:  <br>    Start Length Slot Name Signature  <br>    <span class="hljs-number">0</span> <span class="hljs-number">31</span> <span class="hljs-number">0</span> args [Ljava<span class="hljs-regexp">/lang/</span>String;  <br>    <span class="hljs-number">8</span> <span class="hljs-number">23</span> <span class="hljs-number">1</span> lock Ljava<span class="hljs-regexp">/lang/</span>Object;<br><br></code></pre></td></tr></table></figure><p>说明：</p><ul><li><p>通过异常 <strong>try-catch 机制</strong>，确保一定会被解锁</p></li><li><p>方法级别的 synchronized 不会在字节码指令中有所体现</p></li></ul><hr><h4 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h4><h5 id="升级过程"><a href="#升级过程" class="headerlink" title="升级过程"></a>升级过程</h5><p><strong>synchronized 是可重入、不公平的重量级锁</strong>，所以可以对其进行优化</p><p>无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁&#x2F;&#x2F; 随着竞争的增加，只能锁升级，不能降级</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041622328.png"></p><hr><h5 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h5><p>偏向锁的思想是偏向于让第一个获取锁对象的线程，这个线程之后重新获取该锁不再需要同步操作：</p><ul><li><p>当锁对象第一次被线程获得的时候进入偏向状态，标记为 101，同时<strong>使用 CAS 操作将线程 ID 记录到 Mark Word</strong>。如果 CAS 操作成功，这个线程以后进入这个锁相关的同步块，查看这个线程 ID 是自己的就表示没有竞争，就不需要再进行任何同步操作</p></li><li><p>当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向（Revoke Bias）后恢复到未锁定或轻量级锁状态</p></li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041622764.png"></p><p>一个对象创建时：</p><ul><li><p>如果开启了偏向锁（默认开启），那么对象创建后，MarkWord 值为 0x05 即最后 3 位为 101，thread、epoch、age 都为 0</p></li><li><p>偏向锁是默认是延迟的，不会在程序启动时立即生效，如果想避免延迟，可以加 VM 参数 <code>-XX:BiasedLockingStartupDelay=0</code> 来禁用延迟。JDK 8 延迟 4s 开启偏向锁原因：在刚开始执行代码时，会有好多线程来抢锁，如果开偏向锁效率反而降低</p></li><li><p>当一个对象已经计算过 hashCode，就再也无法进入偏向状态了</p></li><li><p>添加 VM 参数 <code>-XX:-UseBiasedLocking</code> 禁用偏向锁</p></li></ul><p>撤销偏向锁的状态：</p><ul><li><p>调用对象的 hashCode：偏向锁的对象 MarkWord 中存储的是线程 id，调用 hashCode 导致偏向锁被撤销</p></li><li><p>当有其它线程使用偏向锁对象时，会将偏向锁升级为轻量级锁</p></li><li><p>调用 wait&#x2F;notify，需要申请 Monitor，进入 WaitSet</p></li></ul><p><strong>批量撤销</strong>：如果对象被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，重偏向会重置对象的 Thread ID</p><ul><li><p>批量重偏向：当撤销偏向锁阈值超过 20 次后，JVM 会觉得是不是偏向错了，于是在给这些对象加锁时重新偏向至加锁线程</p></li><li><p>批量撤销：当撤销偏向锁阈值超过 40 次后，JVM 会觉得自己确实偏向错了，根本就不该偏向，于是整个类的所有对象都会变为不可偏向的，新建的对象也是不可偏向的</p></li></ul><hr><h5 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h5><p>一个对象有多个线程要加锁，但加锁的时间是错开的（没有竞争），可以使用轻量级锁来优化，轻量级锁对使用者是透明的（不可见）</p><p>可重入锁：线程可以进入任何一个它已经拥有的锁所同步着的代码块，可重入锁最大的作用是<strong>避免死锁</strong></p><p>轻量级锁在没有竞争时（锁重入时），每次重入仍然需要执行 CAS 操作，Java 6 才引入的偏向锁来优化</p><p>锁重入实例：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">static</span> final <span class="hljs-title class_">Object</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">method1</span>(<span class="hljs-params"></span>) &#123;  <br>    <span class="hljs-title function_">synchronized</span>(<span class="hljs-params"> obj </span>) &#123;  <br>        <span class="hljs-comment">// 同步块 A  </span><br>        <span class="hljs-title function_">method2</span>();  <br>    &#125;  <br>&#125;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">method2</span>(<span class="hljs-params"></span>) &#123;  <br>    <span class="hljs-title function_">synchronized</span>(<span class="hljs-params"> obj </span>) &#123;  <br>    <span class="hljs-comment">// 同步块 B  </span><br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>创建锁记录（Lock Record）对象，每个线程的<strong>栈帧</strong>都会包含一个锁记录的结构，存储锁定对象的 Mark Word</li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041622396.png"></p><ul><li><p>让锁记录中 Object reference 指向锁住的对象，并尝试用 CAS 替换 Object 的 Mark Word，将 Mark Word 的值存入锁记录</p></li><li><p>如果 CAS 替换成功，对象头中存储了锁记录地址和状态 00（轻量级锁） ，表示由该线程给对象加锁<br><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041623035.png"></p></li><li><p>如果 CAS 失败，有两种情况：</p><ul><li><p>如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入锁膨胀过程</p></li><li><p>如果是线程自己执行了 synchronized 锁重入，就添加一条 Lock Record 作为重入的计数</p></li></ul></li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041623988.png"></p><ul><li><p>当退出 synchronized 代码块（解锁时）</p><ul><li><p>如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减 1</p></li><li><p>如果锁记录的值不为 null，这时使用 CAS <strong>将 Mark Word 的值恢复给对象头</strong></p><ul><li><p>成功，则解锁成功</p></li><li><p>失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</p></li></ul></li></ul></li></ul><hr><h5 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h5><p>在尝试加轻量级锁的过程中，CAS 操作无法成功，可能是其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为<strong>重量级锁</strong></p><ul><li>当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁</li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041623875.png"></p><ul><li>Thread-1 加轻量级锁失败，进入锁膨胀流程：为 Object 对象申请 Monitor 锁，<strong>通过 Object 对象头获取到持锁线程</strong>，将 Monitor 的 Owner 置为 Thread-0，将 Object 的对象头指向重量级锁地址，然后自己进入 Monitor 的 EntryList BLOCKED</li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041624894.png"></p><ul><li>当 Thread-0 退出同步块解锁时，使用 CAS 将 Mark Word 的值恢复给对象头失败，这时进入重量级解锁流程，即按照 Monitor 地址找到 Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中 BLOCKED 线程</li></ul><hr><h4 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h4><h5 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h5><p>重量级锁竞争时，尝试获取锁的线程不会立即阻塞，可以使用<strong>自旋</strong>（默认 10 次）来进行优化，采用循环的方式去尝试获取锁</p><p>注意：</p><ul><li><p>自旋占用 CPU 时间，单核 CPU 自旋就是浪费时间，因为同一时刻只能运行一个线程，多核 CPU 自旋才能发挥优势</p></li><li><p>自旋失败的线程会进入阻塞状态</p></li></ul><p>优点：不会进入阻塞状态，<strong>减少线程上下文切换的消耗</strong></p><p>缺点：当自旋的线程越来越多时，会不断的消耗 CPU 资源</p><p>自旋锁情况：</p><ul><li><p>自旋成功的情况：<br><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041624183.png"></p></li><li><p>自旋失败的情况：</p></li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041625916.png"></p><p>自旋锁说明：</p><ul><li><p>在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，比较智能</p></li><li><p>Java 7 之后不能控制是否开启自旋功能，由 JVM 控制</p></li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><br><span class="hljs-comment">//手写自旋锁  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SpinLock</span> &#123;  <br>    <span class="hljs-comment">// 泛型装的是Thread，原子引用线程  </span><br>    AtomicReference&lt;Thread&gt; atomicReference = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;();  <br>  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span>()</span> &#123;  <br>        Thread thread = Thread.currentThread();  <br>        System.<span class="hljs-keyword">out</span>.println(thread.getName() + <span class="hljs-string">&quot; come in&quot;</span>);  <br>  <br>        <span class="hljs-comment">//开始自旋，期望值为null，更新值是当前线程  </span><br>        <span class="hljs-keyword">while</span> (!atomicReference.compareAndSet(<span class="hljs-literal">null</span>, thread)) &#123;  <br>            Thread.sleep(<span class="hljs-number">1000</span>);  <br>            System.<span class="hljs-keyword">out</span>.println(thread.getName() + <span class="hljs-string">&quot; 正在自旋&quot;</span>);  <br>        &#125;  <br>        System.<span class="hljs-keyword">out</span>.println(thread.getName() + <span class="hljs-string">&quot; 自旋成功&quot;</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span>()</span> &#123;  <br>        Thread thread = Thread.currentThread();  <br>  <br>        <span class="hljs-comment">//线程使用完锁把引用变为null  </span><br>atomicReference.compareAndSet(thread, <span class="hljs-literal">null</span>);  <br>        System.<span class="hljs-keyword">out</span>.println(thread.getName() + <span class="hljs-string">&quot; invoke unlock&quot;</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>) throws InterruptedException</span> &#123;  <br>        SpinLock <span class="hljs-keyword">lock</span> = <span class="hljs-keyword">new</span> SpinLock();  <br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;  <br>            <span class="hljs-comment">//占有锁  </span><br>            <span class="hljs-keyword">lock</span>.<span class="hljs-keyword">lock</span>();  <br>            Thread.sleep(<span class="hljs-number">10000</span>);   <br>  <br>            <span class="hljs-comment">//释放锁  </span><br>            <span class="hljs-keyword">lock</span>.unlock();  <br>        &#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();  <br>  <br>        <span class="hljs-comment">// 让main线程暂停1秒，使得t1线程，先执行  </span><br>        Thread.sleep(<span class="hljs-number">1000</span>);  <br>  <br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;  <br>            <span class="hljs-keyword">lock</span>.<span class="hljs-keyword">lock</span>();  <br>            <span class="hljs-keyword">lock</span>.unlock();  <br>        &#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h5><p>锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除，这是 JVM <strong>即时编译器的优化</strong></p><p>锁消除主要是通过<strong>逃逸分析</strong>来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除（同步消除：JVM 逃逸分析）</p><hr><h5 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h5><p>对相同对象多次加锁，导致线程发生多次重入，频繁的加锁操作就会导致性能损耗，可以使用锁粗化方式优化</p><p>如果虚拟机探测到一串的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部</p><ul><li><p>一些看起来没有加锁的代码，其实隐式的加了很多锁：</p><p>  public static String concatString(String s1, String s2, String s3) {<br>  return s1 + s2 + s3;<br>  }</p></li><li><p>String 是一个不可变的类，编译器会对 String 的拼接自动优化。在 JDK 1.5 之前，转化为 StringBuffer 对象的连续 append() 操作，每个 append() 方法中都有一个同步块</p><p>  public static String concatString(String s1, String s2, String s3) {<br>  StringBuffer sb &#x3D; new StringBuffer();<br>  sb.append(s1);<br>  sb.append(s2);<br>  sb.append(s3);<br>  return sb.toString();<br>  }</p></li></ul><p>扩展到第一个 append() 操作之前直至最后一个 append() 操作之后，只需要加锁一次就可以</p><hr><h4 id="多把锁"><a href="#多把锁" class="headerlink" title="多把锁"></a>多把锁</h4><p>多把不相干的锁：一间大屋子有两个功能睡觉、学习，互不相干。现在一人要学习，一人要睡觉，如果只用一间屋子（一个对象锁）的话，那么并发度很低</p><p>将锁的粒度细分：</p><ul><li><p>好处，是可以增强并发度</p></li><li><p>坏处，如果一个线程需要同时获得多把锁，就容易发生死锁</p></li></ul><p>解决方法：准备多个对象锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    <span class="hljs-type">BigRoom</span> <span class="hljs-variable">bigRoom</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigRoom</span>();  <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123; bigRoom.study(); &#125;).start();  <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123; bigRoom.sleep(); &#125;).start();  <br>&#125;  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BigRoom</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">studyRoom</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">sleepRoom</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>        <span class="hljs-keyword">synchronized</span> (sleepRoom) &#123;  <br>            System.out.println(<span class="hljs-string">&quot;sleeping 2 小时&quot;</span>);  <br>            Thread.sleep(<span class="hljs-number">2000</span>);  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>        <span class="hljs-keyword">synchronized</span> (studyRoom) &#123;  <br>            System.out.println(<span class="hljs-string">&quot;study 1 小时&quot;</span>);  <br>            Thread.sleep(<span class="hljs-number">1000</span>);  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="活跃性"><a href="#活跃性" class="headerlink" title="活跃性"></a>活跃性</h4><h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><h6 id="形成"><a href="#形成" class="headerlink" title="形成"></a>形成</h6><p>死锁：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放，由于线程被无限期地阻塞，因此程序不可能正常终止</p><p>Java 死锁产生的四个必要条件：</p><ol><li><p>互斥条件，即当资源被一个线程使用（占有）时，别的线程不能使用</p></li><li><p>不可剥夺条件，资源请求者不能强制从资源占有者手中夺取资源，资源只能由资源占有者主动释放</p></li><li><p>请求和保持条件，即当资源请求者在请求其他的资源的同时保持对原有资源的占有</p></li><li><p>循环等待条件，即存在一个等待循环队列：p1 要 p2 的资源，p2 要 p1 的资源，形成了一个等待环路</p></li></ol><p>四个条件都成立的时候，便形成死锁。死锁情况下打破上述任何一个条件，便可让死锁消失</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dead</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">resources1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">resources2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>            <span class="hljs-comment">// 线程1：占用资源1 ，请求资源2  </span><br>            <span class="hljs-keyword">synchronized</span>(resources1)&#123;  <br>                System.out.println(<span class="hljs-string">&quot;线程1已经占用了资源1，开始请求资源2&quot;</span>);  <br>                Thread.sleep(<span class="hljs-number">2000</span>);<span class="hljs-comment">//休息两秒，防止线程1直接运行完成。  </span><br>                <span class="hljs-comment">//2秒内线程2肯定可以锁住资源2  </span><br>                <span class="hljs-keyword">synchronized</span> (resources2)&#123;  <br>                    System.out.println(<span class="hljs-string">&quot;线程1已经占用了资源2&quot;</span>);  <br>                &#125;  <br>        &#125;).start();  <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>            <span class="hljs-comment">// 线程2：占用资源2 ，请求资源1  </span><br>            <span class="hljs-keyword">synchronized</span>(resources2)&#123;  <br>                System.out.println(<span class="hljs-string">&quot;线程2已经占用了资源2，开始请求资源1&quot;</span>);  <br>                Thread.sleep(<span class="hljs-number">2000</span>);  <br>                <span class="hljs-keyword">synchronized</span> (resources1)&#123;  <br>                    System.out.println(<span class="hljs-string">&quot;线程2已经占用了资源1&quot;</span>);  <br>                &#125;  <br>            &#125;&#125;  <br>        &#125;).start();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h6 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h6><p>定位死锁的方法：</p><ul><li><p>使用 jps 定位进程 id，再用 <code>jstack id</code> 定位死锁，找到死锁的线程去查看源码，解决优化</p><p>  “Thread-1” #12 prio&#x3D;5 os_prio&#x3D;0 tid&#x3D;0x000000001eb69000 nid&#x3D;0xd40 waiting formonitor entry [0x000000001f54f000]<br>  java.lang.Thread.State: BLOCKED (on object monitor)<br>  #省略<br>  “Thread-1” #12 prio&#x3D;5 os_prio&#x3D;0 tid&#x3D;0x000000001eb69000 nid&#x3D;0xd40 waiting for monitor entry [0x000000001f54f000]<br>  java.lang.Thread.State: BLOCKED (on object monitor)<br>  #省略<br>  Found one Java-level deadlock:<br>  “Thread-1”:<br>  waiting to lock monitor 0x000000000361d378 (object 0x000000076b5bf1c0, a java.lang.Object),<br>  which is held by “Thread-0”<br>  “Thread-0”:<br>  waiting to lock monitor 0x000000000361e768 (object 0x000000076b5bf1d0, a java.lang.Object),<br>  which is held by “Thread-1”<br><br>  Java stack information for the threads listed above:<br>  “Thread-1”:<br>  at thread.TestDeadLock.lambda$main$1(TestDeadLock.java:28)<br>  - waiting to lock &lt;0x000000076b5bf1c0&gt; (a java.lang.Object)<br>  - locked &lt;0x000000076b5bf1d0&gt; (a java.lang.Object)<br>  at thread.TestDeadLock$$Lambda$2&#x2F;883049899.run(Unknown Source)<br>  at java.lang.Thread.run(Thread.java:745)<br>  “Thread-0”:<br>  at thread.TestDeadLock.lambda$main$0(TestDeadLock.java:15)<br>  - waiting to lock &lt;0x000000076b5bf1d0&gt; (a java.lang.Object)<br>  - locked &lt;0x000000076b5bf1c0&gt; (a java.lang.Object)<br>  at thread.TestDeadLock$$Lambda$1&#x2F;495053715</p></li><li><p>Linux 下可以通过 top 先定位到 CPU 占用高的 Java 进程，再利用 <code>top -Hp 进程id</code> 来定位是哪个线程，最后再用 jstack &lt; pid&gt;的输出来看各个线程栈</p></li><li><p>避免死锁：避免死锁要注意加锁顺序</p></li><li><p>可以使用 jconsole 工具，在 <code>jdk\bin</code> 目录下</p></li></ul><hr><h5 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h5><p>活锁：指的是任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试—失败—尝试—失败的过程</p><p>两个线程互相改变对方的结束条件，最后谁也无法结束：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestLiveLock</span> &#123;  <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;  <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>            <span class="hljs-comment">// 期望减到 0 退出循环  </span><br>            <span class="hljs-keyword">while</span> (count &gt; <span class="hljs-number">0</span>) &#123;  <br>                Thread.sleep(<span class="hljs-number">200</span>);  <br>                count--;  <br>                System.out.println(<span class="hljs-string">&quot;线程一count:&quot;</span> + count);  <br>            &#125;  <br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();  <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>            <span class="hljs-comment">// 期望超过 20 退出循环  </span><br>            <span class="hljs-keyword">while</span> (count &lt; <span class="hljs-number">20</span>) &#123;  <br>                Thread.sleep(<span class="hljs-number">200</span>);  <br>                count++;  <br>                System.out.println(<span class="hljs-string">&quot;线程二count:&quot;</span>+ count);  <br>            &#125;  <br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h5><p>饥饿：一个线程由于优先级太低，始终得不到 CPU 调度执行，也不能够结束</p><hr><h3 id="wait-ify"><a href="#wait-ify" class="headerlink" title="wait-ify"></a>wait-ify</h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>需要获取对象锁后才可以调用 <code>锁对象.wait()</code>，notify 随机唤醒一个线程，notifyAll 唤醒所有线程去竞争 CPU</p><p>Object 类 API：</p><p>public final void notify():唤醒正在等待对象监视器的单个线程。<br>public final void notifyAll():唤醒正在等待对象监视器的所有线程。<br>public final void wait():导致当前线程等待，直到另一个线程调用该对象的 notify() 方法或 notifyAll()方法。<br>public final native void wait(long timeout):有时限的等待, 到n毫秒后结束等待，或是被唤醒</p><p>说明：<strong>wait 是挂起线程，需要唤醒的都是挂起操作</strong>，阻塞线程可以自己去争抢锁，挂起的线程需要唤醒后去争抢锁</p><p>对比 sleep()：</p><ul><li><p>原理不同：sleep() 方法是属于 Thread 类，是线程用来控制自身流程的，使此线程暂停执行一段时间而把执行机会让给其他线程；wait() 方法属于 Object 类，用于线程间通信</p></li><li><p>对<strong>锁的处理机制</strong>不同：调用 sleep() 方法的过程中，线程不会释放对象锁，当调用 wait() 方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池（不释放锁其他线程怎么抢占到锁执行唤醒操作），但是都会释放 CPU</p></li><li><p>使用区域不同：wait() 方法必须放在<strong>同步控制方法和同步代码块（先获取锁）</strong>中使用，sleep() 方法则可以放在任何地方使用</p></li></ul><p>底层原理：</p><ul><li><p>Owner 线程发现条件不满足，调用 wait 方法，即可进入 WaitSet 变为 WAITING 状态</p></li><li><p>BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片</p></li><li><p>BLOCKED 线程会在 Owner 线程释放锁时唤醒</p></li><li><p>WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，唤醒后并不意味者立刻获得锁，<strong>需要进入 EntryList 重新竞争</strong></p></li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041625177.png"></p><hr><h4 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h4><p>虚假唤醒：notify 只能随机唤醒一个 WaitSet 中的线程，这时如果有其它线程也在等待，那么就可能唤醒不了正确的线程</p><p>解决方法：采用 notifyAll</p><p>notifyAll 仅解决某个线程的唤醒问题，使用 if + wait 判断仅有一次机会，一旦条件不成立，无法重新判断</p><p>解决方法：用 while + wait，当条件不成立，再次 wait</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@Slf4j(topic = &quot;c.demo&quot;)</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">demo</span> &#123;  <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">room</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();  <br>    <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">hasCigarette</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;    <span class="hljs-comment">//有没有烟  </span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">hasTakeout</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>            <span class="hljs-keyword">synchronized</span> (room) &#123;  <br>                log.debug(<span class="hljs-string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);  <br>                <span class="hljs-keyword">while</span> (!hasCigarette) &#123;<span class="hljs-comment">//while防止虚假唤醒  </span><br>                    log.debug(<span class="hljs-string">&quot;没烟，先歇会！&quot;</span>);  <br>                    <span class="hljs-keyword">try</span> &#123;  <br>                        room.wait();  <br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>                        e.printStackTrace();  <br>                    &#125;  <br>                &#125;  <br>                log.debug(<span class="hljs-string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);  <br>                <span class="hljs-keyword">if</span> (hasCigarette) &#123;  <br>                    log.debug(<span class="hljs-string">&quot;可以开始干活了&quot;</span>);  <br>                &#125; <span class="hljs-keyword">else</span> &#123;  <br>                    log.debug(<span class="hljs-string">&quot;没干成活...&quot;</span>);  <br>                &#125;  <br>            &#125;  <br>        &#125;, <span class="hljs-string">&quot;小南&quot;</span>).start();  <br>  <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>            <span class="hljs-keyword">synchronized</span> (room) &#123;  <br>                <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> Thread.currentThread();  <br>                log.debug(<span class="hljs-string">&quot;外卖送到没？[&#123;&#125;]&quot;</span>, hasTakeout);  <br>                <span class="hljs-keyword">if</span> (!hasTakeout) &#123;  <br>                    log.debug(<span class="hljs-string">&quot;没外卖，先歇会！&quot;</span>);  <br>                    <span class="hljs-keyword">try</span> &#123;  <br>                        room.wait();  <br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>                        e.printStackTrace();  <br>                    &#125;  <br>                &#125;  <br>                log.debug(<span class="hljs-string">&quot;外卖送到没？[&#123;&#125;]&quot;</span>, hasTakeout);  <br>                <span class="hljs-keyword">if</span> (hasTakeout) &#123;  <br>                    log.debug(<span class="hljs-string">&quot;可以开始干活了&quot;</span>);  <br>                &#125; <span class="hljs-keyword">else</span> &#123;  <br>                    log.debug(<span class="hljs-string">&quot;没干成活...&quot;</span>);  <br>                &#125;  <br>            &#125;  <br>        &#125;, <span class="hljs-string">&quot;小女&quot;</span>).start();  <br>  <br>  <br>        Thread.sleep(<span class="hljs-number">1000</span>);  <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>        <span class="hljs-comment">// 这里能不能加 synchronized (room)？  </span><br>            <span class="hljs-keyword">synchronized</span> (room) &#123;  <br>                hasTakeout = <span class="hljs-literal">true</span>;  <br><span class="hljs-comment">//log.debug(&quot;烟到了噢！&quot;);  </span><br>                log.debug(<span class="hljs-string">&quot;外卖到了噢！&quot;</span>);  <br>                room.notifyAll();  <br>            &#125;  <br>        &#125;, <span class="hljs-string">&quot;送外卖的&quot;</span>).start();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="park-un"><a href="#park-un" class="headerlink" title="park-un"></a>park-un</h3><p>LockSupport 是用来创建锁和其他同步类的<strong>线程原语</strong></p><p>LockSupport 类方法：</p><ul><li><p><code>LockSupport.park()</code>：暂停当前线程，挂起原语</p></li><li><p><code>LockSupport.unpark(暂停的线程对象)</code>：恢复某个线程的运行</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>        System.out.println(<span class="hljs-string">&quot;start...&quot;</span>);<span class="hljs-comment">//1  </span><br>Thread.sleep(<span class="hljs-number">1000</span>);<span class="hljs-comment">// Thread.sleep(3000)  </span><br>        <span class="hljs-comment">// 先 park 再 unpark 和先 unpark 再 park 效果一样，都会直接恢复线程的运行  </span><br>        System.out.println(<span class="hljs-string">&quot;park...&quot;</span>);<span class="hljs-comment">//2  </span><br>        LockSupport.park();  <br>        System.out.println(<span class="hljs-string">&quot;resume...&quot;</span>);<span class="hljs-comment">//4  </span><br>    &#125;,<span class="hljs-string">&quot;t1&quot;</span>);  <br>    t1.start();  <br>   Thread.sleep(<span class="hljs-number">2000</span>);  <br>    System.out.println(<span class="hljs-string">&quot;unpark...&quot;</span>);<span class="hljs-comment">//3  </span><br>    LockSupport.unpark(t1);  <br>&#125;<br></code></pre></td></tr></table></figure><p>LockSupport 出现就是为了增强 wait &amp; notify 的功能：</p><ul><li><p>wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park、unpark 不需要</p></li><li><p>park &amp; unpark <strong>以线程为单位</strong>来阻塞和唤醒线程，而 notify 只能随机唤醒一个等待线程，notifyAll 是唤醒所有等待线程</p></li><li><p>park &amp; unpark 可以先 unpark，而 wait &amp; notify 不能先 notify。类比生产消费，先消费发现有产品就消费，没有就等待；先生产就直接产生商品，然后线程直接消费</p></li><li><p>wait 会释放锁资源进入等待队列，<strong>park 不会释放锁资源</strong>，只负责阻塞当前线程，会释放 CPU</p></li></ul><p>原理：类似生产者消费者</p><ul><li><p>先 park：</p><ol><li><p>当前线程调用 Unsafe.park() 方法</p></li><li><p>检查 _counter ，本情况为 0，这时获得 _mutex 互斥锁</p></li><li><p>线程进入 _cond 条件变量挂起</p></li><li><p>调用 Unsafe.unpark(Thread_0) 方法，设置 _counter 为 1</p></li><li><p>唤醒 _cond 条件变量中的 Thread_0，Thread_0 恢复运行，设置 _counter 为 0</p></li></ol></li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041626876.png"></p><ul><li><p>先 unpark：</p><ol><li><p>调用 Unsafe.unpark(Thread_0) 方法，设置 _counter 为 1</p></li><li><p>当前线程调用 Unsafe.park() 方法</p></li><li><p>检查 _counter ，本情况为 1，这时线程无需挂起，继续运行，设置 _counter 为 0</p></li></ol></li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041626568.png"></p><hr><h3 id="安全分析"><a href="#安全分析" class="headerlink" title="安全分析"></a>安全分析</h3><p>成员变量和静态变量：</p><ul><li><p>如果它们没有共享，则线程安全</p></li><li><p>如果它们被共享了，根据它们的状态是否能够改变，分两种情况：</p><ul><li><p>如果只有读操作，则线程安全</p></li><li><p>如果有读写操作，则这段代码是临界区，需要考虑线程安全问题</p></li></ul></li></ul><p>局部变量：</p><ul><li><p>局部变量是线程安全的</p></li><li><p>局部变量引用的对象不一定线程安全（逃逸分析）：</p><ul><li><p>如果该对象没有逃离方法的作用访问，它是线程安全的（每一个方法有一个栈帧）</p></li><li><p>如果该对象逃离方法的作用范围，需要考虑线程安全问题（暴露引用）</p></li></ul></li></ul><p>常见线程安全类：String、Integer、StringBuffer、Random、Vector、Hashtable、java.util.concurrent 包</p><ul><li><p>线程安全的是指，多个线程调用它们同一个实例的某个方法时，是线程安全的</p></li><li><p><strong>每个方法是原子的，但多个方法的组合不是原子的</strong>，只能保证调用的方法内部安全：</p><p>  Hashtable table &#x3D; new Hashtable();<br>  &#x2F;&#x2F; 线程1，线程2<br>  if(table.get(“key”) &#x3D;&#x3D; null) {<br>  table.put(“key”, value);<br>  }</p></li></ul><p>无状态类线程安全，就是没有成员变量的类</p><p>不可变类线程安全：String、Integer 等都是不可变类，<strong>内部的状态不可以改变</strong>，所以方法是线程安全</p><ul><li><p>replace 等方法底层是新建一个对象，复制过去</p><p>  Map&lt;String,Object&gt; map &#x3D; new HashMap&lt;&gt;();&#x2F;&#x2F; 线程不安全<br>  String S1 &#x3D; “…”;&#x2F;&#x2F; 线程安全<br>  final String S2 &#x3D; “…”;&#x2F;&#x2F; 线程安全<br>  Date D1 &#x3D; new Date();&#x2F;&#x2F; 线程不安全<br>  final Date D2 &#x3D; new Date();&#x2F;&#x2F; 线程不安全，final让D2引用的对象不能变，但对象的内容可以变</p></li></ul><p>抽象方法如果有参数，被重写后行为不确定可能造成线程不安全，被称之为外星方法：<code>public abstract foo(Student s);</code></p><hr><h3 id="同步模式"><a href="#同步模式" class="headerlink" title="同步模式"></a>同步模式</h3><h4 id="保护性暂停"><a href="#保护性暂停" class="headerlink" title="保护性暂停"></a>保护性暂停</h4><h5 id="单任务版"><a href="#单任务版" class="headerlink" title="单任务版"></a>单任务版</h5><p>Guarded Suspension，用在一个线程等待另一个线程的执行结果</p><ul><li><p>有一个结果需要从一个线程传递到另一个线程，让它们关联同一个 GuardedObject</p></li><li><p>如果有结果不断从一个线程到另一个线程那么可以使用消息队列（见生产者&#x2F;消费者）</p></li><li><p>JDK 中，join 的实现、Future 的实现，采用的就是此模式</p></li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041627568.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    <span class="hljs-type">GuardedObject</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GuardedObjectV2</span>();  <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>        sleep(<span class="hljs-number">1</span>);  <br>        object.complete(Arrays.asList(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>));  <br>    &#125;).start();  <br>      <br>    <span class="hljs-type">Object</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> object.get(<span class="hljs-number">2500</span>);  <br>    <span class="hljs-keyword">if</span> (response != <span class="hljs-literal">null</span>) &#123;  <br>        log.debug(<span class="hljs-string">&quot;get response: [&#123;&#125;] lines&quot;</span>, ((List&lt;String&gt;) response).size());  <br>    &#125; <span class="hljs-keyword">else</span> &#123;  <br>        log.debug(<span class="hljs-string">&quot;can&#x27;t get response&quot;</span>);  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GuardedObject</span> &#123;  <br>    <span class="hljs-keyword">private</span> Object response;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();  <br>  <br>    <span class="hljs-comment">//获取结果  </span><br>    <span class="hljs-comment">//timeout :最大等待时间  </span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> millis)</span> &#123;  <br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;  <br>            <span class="hljs-comment">// 1) 记录最初时间  </span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> System.currentTimeMillis();  <br>            <span class="hljs-comment">// 2) 已经经历的时间  </span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">timePassed</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br>            <span class="hljs-keyword">while</span> (response == <span class="hljs-literal">null</span>) &#123;  <br>                <span class="hljs-comment">// 4) 假设 millis 是 1000，结果在 400 时唤醒了，那么还有 600 要等  </span><br>                <span class="hljs-type">long</span> <span class="hljs-variable">waitTime</span> <span class="hljs-operator">=</span> millis - timePassed;  <br>                log.debug(<span class="hljs-string">&quot;waitTime: &#123;&#125;&quot;</span>, waitTime);  <br>                <span class="hljs-comment">//经历时间超过最大等待时间退出循环  </span><br>                <span class="hljs-keyword">if</span> (waitTime &lt;= <span class="hljs-number">0</span>) &#123;  <br>                    log.debug(<span class="hljs-string">&quot;break...&quot;</span>);  <br>                    <span class="hljs-keyword">break</span>;  <br>                &#125;  <br>                <span class="hljs-keyword">try</span> &#123;  <br>                    lock.wait(waitTime);  <br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>                    e.printStackTrace();  <br>                &#125;  <br>                <span class="hljs-comment">// 3) 如果提前被唤醒，这时已经经历的时间假设为 400  </span><br>                timePassed = System.currentTimeMillis() - begin;  <br>                log.debug(<span class="hljs-string">&quot;timePassed: &#123;&#125;, object is null &#123;&#125;&quot;</span>,  <br>                        timePassed, response == <span class="hljs-literal">null</span>);  <br>            &#125;  <br>            <span class="hljs-keyword">return</span> response;  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//产生结果  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">complete</span><span class="hljs-params">(Object response)</span> &#123;  <br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;  <br>            <span class="hljs-comment">// 条件满足，通知等待线程  </span><br>            <span class="hljs-built_in">this</span>.response = response;  <br>            log.debug(<span class="hljs-string">&quot;notify...&quot;</span>);  <br>            lock.notifyAll();  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="多任务版"><a href="#多任务版" class="headerlink" title="多任务版"></a>多任务版</h5><p>多任务版保护性暂停：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041627603.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;  <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">People</span>().start();  <br>    &#125;  <br>    Thread.sleep(<span class="hljs-number">1000</span>);  <br>    <span class="hljs-keyword">for</span> (Integer id : Mailboxes.getIds()) &#123;  <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Postman</span>(id, id + <span class="hljs-string">&quot;号快递到了&quot;</span>).start();  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-meta">@Slf4j(topic = &quot;c.People&quot;)</span>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-comment">// 收信  </span><br>        <span class="hljs-type">GuardedObject</span> <span class="hljs-variable">guardedObject</span> <span class="hljs-operator">=</span> Mailboxes.createGuardedObject();  <br>        log.debug(<span class="hljs-string">&quot;开始收信i d:&#123;&#125;&quot;</span>, guardedObject.getId());  <br>        <span class="hljs-type">Object</span> <span class="hljs-variable">mail</span> <span class="hljs-operator">=</span> guardedObject.get(<span class="hljs-number">5000</span>);  <br>        log.debug(<span class="hljs-string">&quot;收到信id:&#123;&#125;，内容:&#123;&#125;&quot;</span>, guardedObject.getId(),mail);  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Postman</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;  <br>    <span class="hljs-keyword">private</span> String mail;  <br>    <span class="hljs-comment">//构造方法  </span><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-type">GuardedObject</span> <span class="hljs-variable">guardedObject</span> <span class="hljs-operator">=</span> Mailboxes.getGuardedObject(id);  <br>        log.debug(<span class="hljs-string">&quot;开始送信i d:&#123;&#125;，内容:&#123;&#125;&quot;</span>, guardedObject.getId(),mail);  <br>        guardedObject.complete(mail);  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-keyword">class</span>  <span class="hljs-title class_">Mailboxes</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;Integer, GuardedObject&gt; boxes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hashtable</span>&lt;&gt;();  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;  <br>  <br>    <span class="hljs-comment">//产生唯一的id  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">int</span> <span class="hljs-title function_">generateId</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> id++;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GuardedObject <span class="hljs-title function_">getGuardedObject</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;  <br>        <span class="hljs-keyword">return</span> boxes.remove(id);  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GuardedObject <span class="hljs-title function_">createGuardedObject</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-type">GuardedObject</span> <span class="hljs-variable">go</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GuardedObject</span>(generateId());  <br>        boxes.put(go.getId(), go);  <br>        <span class="hljs-keyword">return</span> go;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Set&lt;Integer&gt; <span class="hljs-title function_">getIds</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> boxes.keySet();  <br>    &#125;  <br>&#125;  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GuardedObject</span> &#123;  <br>    <span class="hljs-comment">//标识，Guarded Object  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<span class="hljs-comment">//添加get set方法  </span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="顺序输出"><a href="#顺序输出" class="headerlink" title="顺序输出"></a>顺序输出</h4><p>顺序输出 2 1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;  <br>            <span class="hljs-comment">//try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; &#125;  </span><br>            <span class="hljs-comment">// 当没有许可时，当前线程暂停运行；有许可时，用掉这个许可，当前线程恢复运行  </span><br>            LockSupport.park();  <br>            System.out.println(<span class="hljs-string">&quot;1&quot;</span>);  <br>        &#125;  <br>    &#125;);  <br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;  <br>            System.out.println(<span class="hljs-string">&quot;2&quot;</span>);  <br>            <span class="hljs-comment">// 给线程 t1 发放『许可』（多次连续调用 unpark 只会发放一个『许可』）  </span><br>            LockSupport.unpark(t1);  <br>            <span class="hljs-keyword">try</span> &#123; Thread.sleep(<span class="hljs-number">500</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; &#125;  <br>        &#125;  <br>    &#125;);  <br>    t1.start();  <br>    t2.start();  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="交替输出"><a href="#交替输出" class="headerlink" title="交替输出"></a>交替输出</h4><p>连续输出 5 次 abc</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">day2_14</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>        <span class="hljs-type">AwaitSignal</span> <span class="hljs-variable">awaitSignal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AwaitSignal</span>(<span class="hljs-number">5</span>);  <br>        <span class="hljs-type">Condition</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> awaitSignal.newCondition();  <br>        <span class="hljs-type">Condition</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> awaitSignal.newCondition();  <br>        <span class="hljs-type">Condition</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> awaitSignal.newCondition();  <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>            awaitSignal.print(<span class="hljs-string">&quot;a&quot;</span>, a, b);  <br>        &#125;).start();  <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>            awaitSignal.print(<span class="hljs-string">&quot;b&quot;</span>, b, c);  <br>        &#125;).start();  <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>            awaitSignal.print(<span class="hljs-string">&quot;c&quot;</span>, c, a);  <br>        &#125;).start();  <br>  <br>        Thread.sleep(<span class="hljs-number">1000</span>);  <br>        awaitSignal.lock();  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            a.signal();  <br>        &#125; <span class="hljs-keyword">finally</span> &#123;  <br>            awaitSignal.unlock();  <br>        &#125;  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AwaitSignal</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ReentrantLock</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> loopNumber;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AwaitSignal</span><span class="hljs-params">(<span class="hljs-type">int</span> loopNumber)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.loopNumber = loopNumber;  <br>    &#125;  <br>    <span class="hljs-comment">//参数1：打印内容  参数二：条件变量  参数二：唤醒下一个  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(String str, Condition condition, Condition next)</span> &#123;  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;  <br>            lock();  <br>            <span class="hljs-keyword">try</span> &#123;  <br>                condition.await();  <br>                System.out.print(str);  <br>                next.signal();  <br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>                e.printStackTrace();  <br>            &#125; <span class="hljs-keyword">finally</span> &#123;  <br>                unlock();  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="异步模式"><a href="#异步模式" class="headerlink" title="异步模式"></a>异步模式</h3><h4 id="传统版"><a href="#传统版" class="headerlink" title="传统版"></a>传统版</h4><p>异步模式之生产者&#x2F;消费者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ShareData</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">condition</span> <span class="hljs-operator">=</span> lock.newCondition();  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;  <br>        <span class="hljs-comment">// 同步代码块，加锁  </span><br>        lock.lock();  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            <span class="hljs-comment">// 判断  防止虚假唤醒  </span><br>            <span class="hljs-keyword">while</span>(number != <span class="hljs-number">0</span>) &#123;  <br>                <span class="hljs-comment">// 等待不能生产  </span><br>                condition.await();  <br>            &#125;  <br>            <span class="hljs-comment">// 干活  </span><br>            number++;  <br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t &quot;</span> + number);  <br>            <span class="hljs-comment">// 通知 唤醒  </span><br>            condition.signalAll();  <br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;  <br>            e.printStackTrace();  <br>        &#125; <span class="hljs-keyword">finally</span> &#123;  <br>            lock.unlock();  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decrement</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;  <br>        <span class="hljs-comment">// 同步代码块，加锁  </span><br>        lock.lock();  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            <span class="hljs-comment">// 判断 防止虚假唤醒  </span><br>            <span class="hljs-keyword">while</span>(number == <span class="hljs-number">0</span>) &#123;  <br>                <span class="hljs-comment">// 等待不能消费  </span><br>                condition.await();  <br>            &#125;  <br>            <span class="hljs-comment">// 干活  </span><br>            number--;  <br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t &quot;</span> + number);  <br>            <span class="hljs-comment">// 通知 唤醒  </span><br>            condition.signalAll();  <br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;  <br>            e.printStackTrace();  <br>        &#125; <span class="hljs-keyword">finally</span> &#123;  <br>            lock.unlock();  <br>        &#125;  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TraditionalProducerConsumer</span> &#123;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">ShareData</span> <span class="hljs-variable">shareData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ShareData</span>();  <br>        <span class="hljs-comment">// t1线程，生产  </span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;  <br>            shareData.increment();  <br>            &#125;  <br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();  <br>  <br>        <span class="hljs-comment">// t2线程，消费  </span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;  <br>shareData.decrement();  <br>            &#125;  <br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();   <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="改进版"><a href="#改进版" class="headerlink" title="改进版"></a>改进版</h4><p>异步模式之生产者&#x2F;消费者：</p><ul><li><p>消费队列可以用来平衡生产和消费的线程资源，不需要产生结果和消费结果的线程一一对应</p></li><li><p>生产者仅负责产生结果数据，不关心数据该如何处理，而消费者专心处理结果数据</p></li><li><p>消息队列是有容量限制的，满时不会再加入数据，空时不会再消耗数据</p></li><li><p>JDK 中各种阻塞队列，采用的就是这种模式</p></li></ul><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202403041627710.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">demo</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">MessageQueue</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageQueue</span>(<span class="hljs-number">2</span>);  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;  <br>            <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> i;  <br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>                queue.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(id,<span class="hljs-string">&quot;值&quot;</span>+id));  <br>            &#125;, <span class="hljs-string">&quot;生产者&quot;</span> + i).start();  <br>        &#125;  <br>          <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;  <br>                <span class="hljs-keyword">try</span> &#123;  <br>                    Thread.sleep(<span class="hljs-number">1000</span>);  <br>                    <span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> queue.take();  <br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>                    e.printStackTrace();  <br>                &#125;  <br>            &#125;  <br>        &#125;,<span class="hljs-string">&quot;消费者&quot;</span>).start();  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-comment">//消息队列类，Java间线程之间通信  </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageQueue</span> &#123;  <br>    <span class="hljs-keyword">private</span> LinkedList&lt;Message&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<span class="hljs-comment">//消息的队列集合  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capacity;<span class="hljs-comment">//队列容量  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MessageQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.capacity = capacity;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//获取消息  </span><br>    <span class="hljs-keyword">public</span> Message <span class="hljs-title function_">take</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-comment">//检查队列是否为空  </span><br>        <span class="hljs-keyword">synchronized</span> (list) &#123;  <br>            <span class="hljs-keyword">while</span> (list.isEmpty()) &#123;  <br>                <span class="hljs-keyword">try</span> &#123;  <br>                    sout(Thread.currentThread().getName() + <span class="hljs-string">&quot;:队列为空，消费者线程等待&quot;</span>);  <br>                    list.wait();  <br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>                    e.printStackTrace();  <br>                &#125;  <br>            &#125;  <br>            <span class="hljs-comment">//从队列的头部获取消息返回  </span><br>            <span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> list.removeFirst();  <br>            sout(Thread.currentThread().getName() + <span class="hljs-string">&quot;：已消费消息--&quot;</span> + message);  <br>            list.notifyAll();  <br>            <span class="hljs-keyword">return</span> message;  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//存入消息  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(Message message)</span> &#123;  <br>        <span class="hljs-keyword">synchronized</span> (list) &#123;  <br>            <span class="hljs-comment">//检查队列是否满  </span><br>            <span class="hljs-keyword">while</span> (list.size() == capacity) &#123;  <br>                <span class="hljs-keyword">try</span> &#123;  <br>                    sout(Thread.currentThread().getName()+<span class="hljs-string">&quot;:队列为已满，生产者线程等待&quot;</span>);  <br>                    list.wait();  <br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>                    e.printStackTrace();  <br>                &#125;  <br>            &#125;  <br>            <span class="hljs-comment">//将消息加入队列尾部  </span><br>            list.addLast(message);  <br>            sout(Thread.currentThread().getName() + <span class="hljs-string">&quot;:已生产消息--&quot;</span> + message);  <br>            list.notifyAll();  <br>        &#125;  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Message</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;  <br>    <span class="hljs-keyword">private</span> Object value;  <br><span class="hljs-comment">//get set  </span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">1</span>);  <br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">producer</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">1</span>);  <br>    BlockingQueue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;&gt;();  <br>    producer.submit(() -&gt; &#123;  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            System.out.println(<span class="hljs-string">&quot;生产...&quot;</span>);  <br>            Thread.sleep(<span class="hljs-number">1000</span>);  <br>            queue.put(<span class="hljs-number">10</span>);  <br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>            e.printStackTrace();  <br>        &#125;  <br>    &#125;);  <br>    consumer.submit(() -&gt; &#123;  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            System.out.println(<span class="hljs-string">&quot;等待消费...&quot;</span>);  <br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> queue.take();  <br>            System.out.println(<span class="hljs-string">&quot;结果为:&quot;</span> + result);  <br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>            e.printStackTrace();  <br>        &#125;  <br>    &#125;);  <br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并发</tag>
      
      <tag>并行</tag>
      
      <tag>同步</tag>
      
      <tag>异步</tag>
      
      <tag>互斥</tag>
      
      <tag>线程安全</tag>
      
      <tag>悲观锁</tag>
      
      <tag>乐观锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重拾设计模式（三）</title>
    <link href="/posts/bd826a18/"/>
    <url>/posts/bd826a18/</url>
    
    <content type="html"><![CDATA[<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><blockquote><p>实现一个商场收银软件，营业员根据客户购买的商品单价和数量收费。</p></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201056028.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201057372.png"></p><blockquote><p>如果要去商场对商品搞活动，所有商品打八折呢。<br>那不就是totalPrices后面乘以0.8么？<br>那难道商场活动结束了，再改造一次代码么？然后再用改后的程序把所有机器全部安装一次么？还有可能周年庆，打五折的情况，如何处理？<br>那再加一个下拉框，选择商品活动呢？</p></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201100218.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201059095.png"></p><blockquote><p>这比刚才灵活性上是好多了，不过重复代码很多，像Convert.ToDouble()，你这里就写了8遍，而且4个分支要执行的语句除了打折多少以外几乎没什么不同，应该考虑重构一下。不过这还不是最主要的，现在我的需求又来了，商场的活动加大，需要有满300返100的促销算法，怎么办？</p></blockquote><h3 id="简单工厂实现"><a href="#简单工厂实现" class="headerlink" title="简单工厂实现"></a>简单工厂实现</h3><blockquote><p>面向对象的编程，并不是类越多越好，类的划分是为了封装，但分类的基础是抽象，具有相同属性和功能的对象的抽象集合才是类。打一折和打九折只是形式的不同，抽象分析出来，所有的打折算法都是一样的，所以打折算法应该是一个类。好了，空话已说了太多，写出来才是真的懂。</p></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201104978.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201105121.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201105619.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201105338.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201105903.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201106421.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201106166.png"></p><blockquote><p>简单工厂模式虽然也能解决这个问题，但这个模式只是解决对象的创建问题，而且由于工厂本身包括了所有的收费方式，商场是可能经常性地更改打折额度和返利额度，每次维护或扩展收费方式都要改动这个工厂，以致代码需重新编译部署，这真的是很糟糕的处理方式，所以用它不是最好的办法。面对算法的时常变动，应该有更好的办法。</p></blockquote><h3 id="策略模式实现"><a href="#策略模式实现" class="headerlink" title="策略模式实现"></a>策略模式实现</h3><blockquote><p>策略模式（Strategy）：它定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。</p></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201114498.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201115485.png"><br><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201115807.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201115497.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201116484.png"></p><blockquote><p>写的CashSuper就是抽象策略，而正常收费CashNormal、打折收费CashRebate和返利收费CashReturn就是三个具体策略，也就是策略模式中说的具体算法。</p><p>模仿策略模式的基本代码，改写一下你的程序。<br>其实不麻烦，原来写的CashSuper、CashNormal、CashRebate和CashReturn都不用更改了，只要加一个CashContext类，并改写一下客户端就行了。</p></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201118128.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201119104.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201119863.png"></p><blockquote><p>代码是模仿着写出来了。但我感觉这样子做不又回到了原来的老路了吗，在客户端去判断用哪一个算法？<br>有没有什么好办法，把这个判断的过程从客户端程序转移走呢？<br>难道简单工厂就一定要是一个单独的类吗？难道不可以与策略模式的Context结合？</p></blockquote><h3 id="策略与简单工厂结合"><a href="#策略与简单工厂结合" class="headerlink" title="策略与简单工厂结合"></a>策略与简单工厂结合</h3><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201121336.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201122776.png"></p><blockquote><p>原来简单工厂模式并非只有建一个工厂类的做法，还可以这样子做。此时比刚才的模仿策略模式的写法要清楚多了，客户端代码简单明了。</p></blockquote><blockquote><p>观察一下，找出它们的不同之处。<br><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201123227.png"></p></blockquote><blockquote><p>简单工厂模式我需要让客户端认识两个类， CashSuper和CashFactory，而策略模式与简单工厂结合的用法，客户端就只需要认识一个类CashContext就可以了。耦合更加降低。</p><p>在客户端实例化的是CashContext的对象，调用的是CashContext的方法GetResult，这使得具体的收费算法彻底地与客户端分离。连算法的父类CashSuper都不让客户端认识了。</p></blockquote><hr><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p class="note note-primary">观察者模式是一种行为设计模式，用于定义对象之间的一对多依赖关系，当一个对象的状态发生变化时，其所有依赖对象都会自动收到通知并进行相应的更新。</p><p>一个软件系统里面包含了各种对象，就像一片欣欣向荣的森林充满了各种生物一样。在一片森林中，各种生物彼此依赖和约束，形成一个个生物链。一种生物的状态变化会造成其他一些生物的相应行动，每一个生物都处于别的生物的互动之中。</p><p>同样，一个软件系统常常要求在某一个对象的状态发生变化的时候，某些其他的对象做出相应的改变。做到这一点的设计方案有很多，但是为了使系统能够易于复用，应该选择低耦合度的设计方案。减少对象之间的耦合有利于系统的复用，但是同时设计师需要使这些低耦合度的对象之间能够维持行动的协调一致，保证高度的协作。观察者模式是满足这一要求的各种设计方案中最重要的一种。</p><p>下面以一个简单的示意性实现为例，讨论观察者模式的结构。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402211139342.png"></p><p>观察者模式所涉及的角色有：</p><p>●　　<strong>抽象主题(Subject)角色：</strong> 抽象主题角色把所有对观察者对象的引用保存在一个聚集（比如ArrayList对象）里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象，抽象主题角色又叫做抽象被观察者(Observable)角色。</p><p>●　　<strong>具体主题(ConcreteSubject)角色：</strong> 将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。具体主题角色又叫做具体被观察者(Concrete Observable)角色。</p><p>●　　<strong>抽象观察者(Observer)角色：</strong> 为所有的具体观察者定义一个接口，在得到主题的通知时更新自己，这个接口叫做更新接口。</p><p>●　　<strong>具体观察者(ConcreteObserver)角色：</strong> 存储与主题的状态自恰的状态。具体观察者角色实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态 像协调。如果需要，具体观察者角色可以保持一个指向具体主题对象的引用。</p><p><strong>抽象主题角色类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Subject</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用来保存注册的观察者对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> List&lt;Observer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Observer&gt;();<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 注册观察者对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> observer    观察者对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attach</span><span class="hljs-params">(Observer observer)</span>&#123;<br>        <br>        list.add(observer);<br>        System.out.println(<span class="hljs-string">&quot;Attached an observer&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除观察者对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> observer    观察者对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">detach</span><span class="hljs-params">(Observer observer)</span>&#123;<br>        <br>        list.remove(observer);<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 通知所有注册的观察者对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyObservers</span><span class="hljs-params">(String newState)</span>&#123;<br>        <br>        <span class="hljs-keyword">for</span>(Observer observer : list)&#123;<br>            observer.update(newState);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>具体主题角色类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteSubject</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Subject</span>&#123;<br>    <br>    <span class="hljs-keyword">private</span> String state;<br>    <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getState</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> state;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">change</span><span class="hljs-params">(String newState)</span>&#123;<br>        state = newState;<br>        System.out.println(<span class="hljs-string">&quot;主题状态为：&quot;</span> + state);<br>        <span class="hljs-comment">//状态发生改变，通知各个观察者</span><br>        <span class="hljs-built_in">this</span>.nodifyObservers(state);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>抽象观察者角色类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Observer</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 更新接口</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> state    更新的状态</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(String state)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>具体观察者角色类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteObserver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Observer</span> &#123;<br>    <span class="hljs-comment">//观察者的状态</span><br>    <span class="hljs-keyword">private</span> String observerState;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(String state)</span> &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 更新观察者的状态，使其与目标的状态保持一致</span><br><span class="hljs-comment">         */</span><br>        observerState = state;<br>        System.out.println(<span class="hljs-string">&quot;状态为：&quot;</span>+observerState);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>客户端类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建主题对象</span><br>        <span class="hljs-type">ConcreteSubject</span> <span class="hljs-variable">subject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteSubject</span>();<br>        <span class="hljs-comment">//创建观察者对象</span><br>        <span class="hljs-type">Observer</span> <span class="hljs-variable">observer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteObserver</span>();<br>        <span class="hljs-comment">//将观察者对象登记到主题对象上</span><br>        subject.attach(observer);<br>        <span class="hljs-comment">//改变主题对象的状态</span><br>        subject.change(<span class="hljs-string">&quot;new state&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出结果</strong>：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402211146366.png"></p><p>在运行时，这个客户端首先创建了具体主题类的实例，以及一个观察者对象。然后，它调用主题对象的attach()方法，将这个观察者对象向主题对象登记，也就是将它加入到主题对象的聚集中去。</p><p>这时，客户端调用主题的change()方法，改变了主题对象的内部状态。主题对象在状态发生变化时，调用超类的notifyObservers()方法，通知所有登记过的观察者对象。</p><h3 id="推模型和拉模型"><a href="#推模型和拉模型" class="headerlink" title="推模型和拉模型"></a>推模型和拉模型</h3><p>在观察者模式中，又分为推模型和拉模型两种方式。<br>●　　<strong>推模型</strong><br>主题对象向观察者推送主题的详细信息，不管观察者是否需要，推送的信息通常是主题对象的全部或部分数据。<br>●　　<strong>拉模型</strong><br>主题对象在通知观察者的时候，只传递少量信息。如果观察者需要更具体的信息，由观察者主动到主题对象中获取，相当于是观察者从主题对象中拉数据。一般这种模型的实现中，会把主题对象自身通过update()方法传递给观察者，这样在观察者需要获取数据的时候，就可以通过这个引用来获取了。</p><p>根据上面的描述，发现前面的例子就是典型的推模型，下面给出一个拉模型的实例。</p><p><strong>拉模型的抽象观察者类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Observer</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 更新接口</span><br><span class="hljs-comment">     * 拉模型通常都是把主题对象当做参数传递。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> subject 传入主题对象，方面获取相应的主题对象的状态</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Subject subject)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>拉模型的具体观察者类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteObserver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Observer</span> &#123;<br>    <span class="hljs-comment">//观察者的状态</span><br>    <span class="hljs-keyword">private</span> String observerState;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Subject subject)</span> &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 更新观察者的状态，使其与目标的状态保持一致</span><br><span class="hljs-comment">         */</span><br>        observerState = ((ConcreteSubject)subject).getState();<br>        System.out.println(<span class="hljs-string">&quot;观察者状态为：&quot;</span>+observerState);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>拉模型的抽象主题类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">　　拉模型的抽象主题类主要的改变是nodifyObservers()方法。在循环通知观察者的时候，也就是循环调用观察者的update()方法的时候，传入的参数不同了。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Subject</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用来保存注册的观察者对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span>    List&lt;Observer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Observer&gt;();<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 注册观察者对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> observer    观察者对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attach</span><span class="hljs-params">(Observer observer)</span>&#123;<br>        <br>        list.add(observer);<br>        System.out.println(<span class="hljs-string">&quot;Attached an observer&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除观察者对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> observer    观察者对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">detach</span><span class="hljs-params">(Observer observer)</span>&#123;<br>        <br>        list.remove(observer);<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 通知所有注册的观察者对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">nodifyObservers</span><span class="hljs-params">()</span>&#123;<br>        <br>        <span class="hljs-keyword">for</span>(Observer observer : list)&#123;<br>            observer.update(<span class="hljs-built_in">this</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>拉模型的具体主题类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">　　跟推模型相比，有一点变化，就是调用通知观察者的方法的时候，不需要传入参数了。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteSubject</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Subject</span>&#123;<br>    <br>    <span class="hljs-keyword">private</span> String state;<br>    <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getState</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> state;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">change</span><span class="hljs-params">(String newState)</span>&#123;<br>        state = newState;<br>        System.out.println(<span class="hljs-string">&quot;主题状态为：&quot;</span> + state);<br>        <span class="hljs-comment">//状态发生改变，通知各个观察者</span><br>        <span class="hljs-built_in">this</span>.nodifyObservers();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="两种模式的比较"><a href="#两种模式的比较" class="headerlink" title="两种模式的比较"></a>两种模式的比较</h3><p>■　　推模型是假定主题对象知道观察者需要的数据；而拉模型是主题对象不知道观察者具体需要什么数据，没有办法的情况下，干脆把自身传递给观察者，让观察者自己去按需要取值。</p><p>■　　推模型可能会使得观察者对象难以复用，因为观察者的update()方法是按需要定义的参数，可能无法兼顾没有考虑到的使用情况。这就意味着出现新情况的时候，就可能提供新的update()方法，或者是干脆重新实现观察者；而拉模型就不会造成这样的情况，因为拉模型下，update()方法的参数是主题对象本身，这基本上是主题对象能传递的最大数据集合了，基本上可以适应各种情况的需要。</p><hr><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p class="note note-primary">命令模式是一种行为设计模式，它允许您将请求封装成对象，使得请求的发送者和接收者彻底解耦。在命令模式中，请求被封装成一个命令对象，这个命令对象可以被传递和存储，从而允许对请求进行参数化和延迟执行。</p><p>命令模式包含以下关键角色：</p><ul><li><strong>Command（命令）</strong>：定义了执行请求的接口。</li><li><strong>ConcreteCommand（具体命令）</strong>：实现了 Command 接口，并封装了请求的接收者。</li><li><strong>Receiver（接收者）</strong>：执行实际操作的对象。</li><li><strong>Invoker（调用者）</strong>：负责调用命令对象执行请求。</li><li><strong>Client（客户端）</strong>：创建命令对象并设置其接收者。</li></ul><p>下面是一个简单的 Java 代码示例，演示了如何使用命令模式来实现一个简单的遥控器控制灯泡的场景：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Command 接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Command</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">// ConcreteCommand 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LightOnCommand</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Command</span> &#123;<br>    <span class="hljs-keyword">private</span> Light light;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LightOnCommand</span><span class="hljs-params">(Light light)</span> &#123;<br>        <span class="hljs-built_in">this</span>.light = light;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span> &#123;<br>        light.turnOn();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Receiver 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Light</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">turnOn</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Light is on&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">turnOff</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Light is off&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Invoker 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RemoteControl</span> &#123;<br>    <span class="hljs-keyword">private</span> Command command;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCommand</span><span class="hljs-params">(Command command)</span> &#123;<br>        <span class="hljs-built_in">this</span>.command = command;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pressButton</span><span class="hljs-params">()</span> &#123;<br>        command.execute();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Client 类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建接收者对象</span><br>        <span class="hljs-type">Light</span> <span class="hljs-variable">light</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Light</span>();<br><br>        <span class="hljs-comment">// 创建命令对象并设置其接收者</span><br>        <span class="hljs-type">Command</span> <span class="hljs-variable">lightOnCommand</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LightOnCommand</span>(light);<br><br>        <span class="hljs-comment">// 创建调用者对象并设置命令对象</span><br>        <span class="hljs-type">RemoteControl</span> <span class="hljs-variable">remoteControl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RemoteControl</span>();<br>        remoteControl.setCommand(lightOnCommand);<br><br>        <span class="hljs-comment">// 模拟按下按钮，执行命令</span><br>        remoteControl.pressButton(); <span class="hljs-comment">// 输出：Light is on</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>在这个示例中，我们创建了一个遥控器（Invoker），并设置了一个命令（Command）来控制灯泡（Receiver）。当我们按下按钮时，调用者会执行命令，命令又会调用接收者执行相应的操作。</p><p>命令模式是一种非常有用的设计模式，它可以将请求封装成对象，从而允许您以参数化的方式进行方法调用、队列请求、日志记录和撤销操作等。</p><p>命令模式非常灵活，允许您轻松地扩展和修改功能。例如，您可以添加新的具体命令类来实现不同的操作，而不需要修改现有的代码。这种可扩展性使得命令模式在面对变化需求时非常有用。</p></blockquote><hr><h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><p class="note note-primary">模板方法模式是一种行为设计模式，它在一个方法中定义了一个算法的骨架，而将一些步骤的具体实现延迟到子类中。这样，可以在不改变算法结构的情况下，重新定义算法的某些步骤。模板方法模式提供了一种代码复用的方式，同时允许更容易地对算法进行定制。</p><p>模板方法模式包含以下关键角色：</p><ul><li><strong>AbstractClass（抽象类）</strong>：定义了一个模板方法，其中包含算法的骨架和一些步骤的具体实现。</li><li><strong>ConcreteClass（具体类）</strong>：实现了抽象类中的某些步骤，完成算法的具体实现。</li></ul><p>下面是一个简单的示例，演示了如何使用模板方法模式来制作咖啡和茶：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 抽象类：饮料</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Beverage</span> &#123;<br>    <span class="hljs-comment">// 模板方法，定义了制作饮料的步骤</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">prepareBeverage</span><span class="hljs-params">()</span> &#123;<br>        boilWater();<br>        brew();<br>        pourInCup();<br>        <span class="hljs-keyword">if</span> (customerWantsCondiments()) &#123;<br>            addCondiments();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 抽象方法，由子类实现</span><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">brew</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addCondiments</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">// 具体方法，共享实现</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">boilWater</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Boiling water&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">pourInCup</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Pouring into cup&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 钩子方法，子类可以选择性地覆盖</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">customerWantsCondiments</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 具体类：咖啡</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Coffee</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Beverage</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">brew</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Dripping Coffee through filter&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">addCondiments</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Adding Sugar and Milk&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 具体类：茶</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tea</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Beverage</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">brew</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Steeping the tea&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">addCondiments</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Adding Lemon&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">customerWantsCondiments</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 茶不加调料</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 客户端代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Beverage</span> <span class="hljs-variable">coffee</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Coffee</span>();<br>        System.out.println(<span class="hljs-string">&quot;Making coffee...&quot;</span>);<br>        coffee.prepareBeverage();<br><br>        System.out.println();<br><br>        <span class="hljs-type">Beverage</span> <span class="hljs-variable">tea</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Tea</span>();<br>        System.out.println(<span class="hljs-string">&quot;Making tea...&quot;</span>);<br>        tea.prepareBeverage();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在这个示例中，<code>Beverage</code> 是抽象类，定义了制作饮料的模板方法 <code>prepareBeverage()</code>，以及一些共享的具体方法。<code>Coffee</code> 和 <code>Tea</code> 是具体类，分别实现了 <code>brew()</code> 和 <code>addCondiments()</code> 方法，以完成制作咖啡和茶的过程。</p><p><strong>JDK 中的应用</strong></p><p>在 JDK 中，模板方法模式被广泛应用。其中一个典型的例子就是在 <code>java.util.AbstractList</code> 类中。这个类实现了 <code>java.util.List</code> 接口，提供了 <code>equals()</code> 和 <code>hashCode()</code> 方法的默认实现，这些方法都是模板方法。以下是 <code>AbstractList</code> 类中的部分核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// java.util.AbstractList 类中的部分代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractList</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractCollection</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">List</span>&lt;E&gt; &#123;<br>    <span class="hljs-comment">// 省略其他方法</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!(o <span class="hljs-keyword">instanceof</span> List)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        Iterator&lt;E&gt; e1 = iterator();<br>        ListIterator&lt;?&gt; e2 = ((List&lt;?&gt;) o).listIterator();<br>        <span class="hljs-keyword">while</span> (e1.hasNext() &amp;&amp; e2.hasNext()) &#123;<br>            <span class="hljs-type">E</span> <span class="hljs-variable">o1</span> <span class="hljs-operator">=</span> e1.next();<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">o2</span> <span class="hljs-operator">=</span> e2.next();<br>            <span class="hljs-keyword">if</span> (!(o1==<span class="hljs-literal">null</span> ? o2==<span class="hljs-literal">null</span> : o1.equals(o2))) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> !(e1.hasNext() || e2.hasNext());<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">hashCode</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (E e : <span class="hljs-built_in">this</span>) &#123;<br>            hashCode = <span class="hljs-number">31</span> * hashCode + (e == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : e.hashCode());<br>        &#125;<br>        <span class="hljs-keyword">return</span> hashCode;<br>    &#125;<br><br>    <span class="hljs-comment">// 省略其他方法</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>equals()</code> 和 <code>hashCode()</code> 方法就是模板方法，它们定义了算法的骨架，具体的比较和哈希计算操作由子类实现。</p><p>模板方法模式是一种非常有用的设计模式，它提供了一种代码复用的方式，并允许在不改变算法结构的情况下，重新定义算法的某些步骤。在 JDK 中，模板方法模式被广泛应用于各种类库和框架中，如集合框架、IO 操作等。</p><hr><h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><p class="note note-primary">状态模式（State Pattern）是一种行为设计模式，它允许对象在其内部状态改变时改变其行为。这种模式的关键是将对象的状态封装成不同的类，并将行为委托给当前状态对象。状态模式可以使得对象的状态转换更加清晰、简单，并且避免了使用大量的条件语句。</p><p><strong>角色介绍</strong></p><ul><li><strong>Context（上下文）</strong>：定义客户端感兴趣的接口，维护一个当前状态对象。</li><li><strong>State（状态）</strong>：定义一个接口，用于封装与 Context 相关的行为。</li><li><strong>ConcreteState（具体状态）</strong>：实现 State 接口的具体状态类，负责处理与状态相关的操作。</li></ul><p><strong>应用示例</strong></p><p>下面是一个简单的示例，演示了如何使用状态模式来实现一个电梯控制器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 上下文类：电梯</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Elevator</span> &#123;<br>    <span class="hljs-keyword">private</span> State state;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Elevator</span><span class="hljs-params">()</span> &#123;<br>        state = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClosedState</span>(); <span class="hljs-comment">// 初始化为关闭状态</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setState</span><span class="hljs-params">(State state)</span> &#123;<br>        <span class="hljs-built_in">this</span>.state = state;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">open</span><span class="hljs-params">()</span> &#123;<br>        state.open(<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> &#123;<br>        state.close(<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">()</span> &#123;<br>        state.move(<span class="hljs-built_in">this</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 状态接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">State</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">open</span><span class="hljs-params">(Elevator elevator)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">(Elevator elevator)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">(Elevator elevator)</span>;<br>&#125;<br><br><span class="hljs-comment">// 具体状态类：关闭状态</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClosedState</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">State</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">open</span><span class="hljs-params">(Elevator elevator)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Opening the door...&quot;</span>);<br>        elevator.setState(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OpenState</span>());<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">(Elevator elevator)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;The door is already closed.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">(Elevator elevator)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Moving the elevator...&quot;</span>);<br>        elevator.setState(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MovingState</span>());<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 具体状态类：打开状态</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">OpenState</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">State</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">open</span><span class="hljs-params">(Elevator elevator)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;The door is already open.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">(Elevator elevator)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Closing the door...&quot;</span>);<br>        elevator.setState(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClosedState</span>());<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">(Elevator elevator)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Cannot move while the door is open.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 具体状态类：运行状态</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MovingState</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">State</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">open</span><span class="hljs-params">(Elevator elevator)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Cannot open the door while the elevator is moving.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">(Elevator elevator)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Cannot close the door while the elevator is moving.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">(Elevator elevator)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;The elevator is already moving.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 客户端代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Elevator</span> <span class="hljs-variable">elevator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Elevator</span>();<br><br>        elevator.open();<br>        elevator.close();<br>        elevator.move();<br>        elevator.open();<br>        elevator.move();<br>        elevator.close();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在这个示例中，<code>Elevator</code> 类是上下文类，负责维护当前状态，并将状态相关的操作委托给当前状态对象。<code>State</code> 接口定义了状态的行为，具体状态类实现了该接口，并负责处理与状态相关的操作。</p><p><strong>JDK 中的应用</strong></p><p>在 JDK 中，状态模式被广泛应用。其中一个典型的例子就是在 <code>java.awt.Component</code> 类中。这个类表示可视化组件，其中的 <code>setVisible()</code> 方法就是使用了状态模式。以下是 <code>Component</code> 类中的部分核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// java.awt.Component 类中的部分代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Component</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> visible;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setVisible</span><span class="hljs-params">(<span class="hljs-type">boolean</span> visible)</span> &#123;<br>        <span class="hljs-built_in">this</span>.visible = visible;<br>        <span class="hljs-keyword">if</span> (visible) &#123;<br>            <span class="hljs-comment">// 显示组件的相关操作</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 隐藏组件的相关操作</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 其他方法</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>Component</code> 类维护了一个 <code>visible</code> 属性，用于表示组件的可见状态。根据这个状态的改变，<code>setVisible()</code> 方法会执行不同的操作，从而改变组件的行为。</p><p>状态模式是一种非常有用的设计模式，它可以使得对象在其内部状态改变时改变其行为。通过将状态封装成不同的类，并委托给当前状态对象处理相关操作，状态模式使得代码更加清晰、简单，并且避免了使用大量的条件语句。</p><hr><h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><p class="note note-primary">责任链模式（Chain of Responsibility Pattern）是一种行为设计模式，它允许多个对象都有机会处理请求，从而避免了请求的发送者和接收者之间的耦合关系。在责任链模式中，请求沿着一个链条传递，直到有一个对象处理它为止。</p><p><strong>角色介绍</strong></p><ul><li><strong>Handler（处理器）</strong>：定义了处理请求的接口，并维护了一个指向下一个处理器的引用。</li><li><strong>ConcreteHandler（具体处理器）</strong>：实现了处理器接口的具体处理器类，负责处理它所能处理的请求，并在不能处理时将请求传递给下一个处理器</li></ul><p><strong>应用示例</strong></p><p>考虑一个简单的购买审批系统，其中包含三个级别的审批人：经理、副总裁和总裁。如果购买金额小于等于1000元，经理可以直接批准；如果金额在1000到5000元之间，需要副总裁审批；如果金额超过5000元，需要总裁审批。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 处理器接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Approver</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">processRequest</span><span class="hljs-params">(PurchaseRequest request)</span>;<br>&#125;<br><br><span class="hljs-comment">// 具体处理器类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Manager</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Approver</span> &#123;<br>    <span class="hljs-keyword">private</span> Approver nextApprover;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processRequest</span><span class="hljs-params">(PurchaseRequest request)</span> &#123;<br>        <span class="hljs-keyword">if</span> (request.getAmount() &lt;= <span class="hljs-number">1000</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Manager approves purchase request #&quot;</span> + request.getId());<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nextApprover != <span class="hljs-literal">null</span>) &#123;<br>            nextApprover.processRequest(request);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;No one can handle the purchase request #&quot;</span> + request.getId());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNextApprover</span><span class="hljs-params">(Approver nextApprover)</span> &#123;<br>        <span class="hljs-built_in">this</span>.nextApprover = nextApprover;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">VicePresident</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Approver</span> &#123;<br>    <span class="hljs-keyword">private</span> Approver nextApprover;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processRequest</span><span class="hljs-params">(PurchaseRequest request)</span> &#123;<br>        <span class="hljs-keyword">if</span> (request.getAmount() &lt;= <span class="hljs-number">5000</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Vice President approves purchase request #&quot;</span> + request.getId());<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nextApprover != <span class="hljs-literal">null</span>) &#123;<br>            nextApprover.processRequest(request);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;No one can handle the purchase request #&quot;</span> + request.getId());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNextApprover</span><span class="hljs-params">(Approver nextApprover)</span> &#123;<br>        <span class="hljs-built_in">this</span>.nextApprover = nextApprover;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">President</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Approver</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processRequest</span><span class="hljs-params">(PurchaseRequest request)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;President approves purchase request #&quot;</span> + request.getId());<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 请求类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PurchaseRequest</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> amount;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PurchaseRequest</span><span class="hljs-params">(<span class="hljs-type">int</span> id, <span class="hljs-type">double</span> amount)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.amount = amount;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getAmount</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> amount;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 客户端代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 构建责任链</span><br>        <span class="hljs-type">Approver</span> <span class="hljs-variable">manager</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Manager</span>();<br>        <span class="hljs-type">Approver</span> <span class="hljs-variable">vicePresident</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VicePresident</span>();<br>        <span class="hljs-type">Approver</span> <span class="hljs-variable">president</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">President</span>();<br><br>        manager.setNextApprover(vicePresident);<br>        vicePresident.setNextApprover(president);<br><br>        <span class="hljs-comment">// 创建购买请求</span><br>        <span class="hljs-type">PurchaseRequest</span> <span class="hljs-variable">request1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PurchaseRequest</span>(<span class="hljs-number">1</span>, <span class="hljs-number">800</span>);<br>        <span class="hljs-type">PurchaseRequest</span> <span class="hljs-variable">request2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PurchaseRequest</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3500</span>);<br>        <span class="hljs-type">PurchaseRequest</span> <span class="hljs-variable">request3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PurchaseRequest</span>(<span class="hljs-number">3</span>, <span class="hljs-number">7000</span>);<br><br>        <span class="hljs-comment">// 处理购买请求</span><br>        manager.processRequest(request1);<br>        manager.processRequest(request2);<br>        manager.processRequest(request3);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>JDK 中的应用</strong></p><p>在 JDK 中，责任链模式被广泛应用。其中一个典型的例子是 Servlet 中的过滤器链。Servlet 过滤器链是一系列过滤器按照顺序链接在一起，每个过滤器负责处理请求或者将请求传递给下一个过滤器。以下是 Servlet 过滤器链的核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Filter</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">FilterChain</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response)</span> <span class="hljs-keyword">throws</span> IOException, ServletException;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>Filter</code> 接口代表一个过滤器，其中的 <code>doFilter()</code> 方法负责处理请求或者将请求传递给下一个过滤器。而 <code>FilterChain</code> 接口表示一个过滤器链，其中的 <code>doFilter()</code> 方法将请求传递给下一个过滤器。</p><hr><h2 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h2><p class="note note-primary">解释器模式（Interpreter Pattern）是一种行为设计模式，用于定义一个语言的文法，并且提供解释器来解释该语言中的语句。这种模式将语言中的语句表示为抽象语法树，并提供一种方式来递归地解释该树中的节点。</p><p><strong>角色介绍</strong></p><ul><li><strong>AbstractExpression（抽象表达式）</strong>：声明了一个抽象的解释方法 <code>interpret()</code>，所有的具体表达式都继承自该抽象类。</li><li><strong>TerminalExpression（终结符表达式）</strong>：实现了抽象表达式接口，表示语言中的终结符，即不可再分解的最小单元。</li><li><strong>NonterminalExpression（非终结符表达式）</strong>：实现了抽象表达式接口，表示语言中的非终结符，即可再分解的复合单元。</li><li><strong>Context（上下文）</strong>：包含解释器需要的一些全局信息或状态。</li></ul><p><strong>应用示例</strong></p><p>假设我们需要实现一个简单的表达式解析器，可以解析简单的四则运算表达式，例如 <code>1 + 2 - 3 * 4</code>。我们可以使用解释器模式来实现这个功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 抽象表达式接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Expression</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">interpret</span><span class="hljs-params">(Context context)</span>;<br>&#125;<br><br><span class="hljs-comment">// 终结符表达式：数字</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumberExpression</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Expression</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> number;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NumberExpression</span><span class="hljs-params">(<span class="hljs-type">int</span> number)</span> &#123;<br>        <span class="hljs-built_in">this</span>.number = number;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">interpret</span><span class="hljs-params">(Context context)</span> &#123;<br>        <span class="hljs-keyword">return</span> number;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 非终结符表达式：加法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddExpression</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Expression</span> &#123;<br>    <span class="hljs-keyword">private</span> Expression left;<br>    <span class="hljs-keyword">private</span> Expression right;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AddExpression</span><span class="hljs-params">(Expression left, Expression right)</span> &#123;<br>        <span class="hljs-built_in">this</span>.left = left;<br>        <span class="hljs-built_in">this</span>.right = right;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">interpret</span><span class="hljs-params">(Context context)</span> &#123;<br>        <span class="hljs-keyword">return</span> left.interpret(context) + right.interpret(context);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 非终结符表达式：减法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubstractExpression</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Expression</span> &#123;<br>    <span class="hljs-keyword">private</span> Expression left;<br>    <span class="hljs-keyword">private</span> Expression right;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SubstractExpression</span><span class="hljs-params">(Expression left, Expression right)</span> &#123;<br>        <span class="hljs-built_in">this</span>.left = left;<br>        <span class="hljs-built_in">this</span>.right = right;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">interpret</span><span class="hljs-params">(Context context)</span> &#123;<br>        <span class="hljs-keyword">return</span> left.interpret(context) - right.interpret(context);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 非终结符表达式：乘法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MultiplyExpression</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Expression</span> &#123;<br>    <span class="hljs-keyword">private</span> Expression left;<br>    <span class="hljs-keyword">private</span> Expression right;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MultiplyExpression</span><span class="hljs-params">(Expression left, Expression right)</span> &#123;<br>        <span class="hljs-built_in">this</span>.left = left;<br>        <span class="hljs-built_in">this</span>.right = right;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">interpret</span><span class="hljs-params">(Context context)</span> &#123;<br>        <span class="hljs-keyword">return</span> left.interpret(context) * right.interpret(context);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">// 上下文类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Context</span> &#123;<br>    <span class="hljs-comment">// 如果需要的话，可以在这里添加一些上下文信息</span><br>&#125;<br><br><span class="hljs-comment">// 客户端代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 构建解释器表达式树：1 + 2 - 3 * 4</span><br>        <span class="hljs-type">Expression</span> <span class="hljs-variable">expression</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubstractExpression</span>(<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">AddExpression</span>( <br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">NumberExpression</span>(<span class="hljs-number">1</span>), <br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">NumberExpression</span>(<span class="hljs-number">2</span>) <br>            ), <br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">MultiplyExpression</span>( <br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">NumberExpression</span>(<span class="hljs-number">3</span>), <br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">NumberExpression</span>(<span class="hljs-number">4</span>) <br>            )<br>        );<br><br>        <span class="hljs-comment">// 创建上下文对象</span><br>        <span class="hljs-type">Context</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Context</span>();<br><br>        <span class="hljs-comment">// 解释表达式并输出结果</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> expression.interpret(context);<br>        System.out.println(<span class="hljs-string">&quot;Result: &quot;</span> + result); <span class="hljs-comment">// 输出：-9</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>解释器模式是一种在特定场景下非常有用的设计模式，它可以帮助我们构建简单的语言解释器，实现对特定语言的解析和执行。通过将语言表示为抽象语法树，并提供一种递归的解释方式，解释器模式使得对复杂语言的处理变得简单、清晰。</p><hr><h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><p class="note note-primary">中介者模式（Mediator Pattern）是一种行为设计模式，它允许对象之间通过一个中介对象进行通信，而不直接相互引用。这种模式可以减少对象之间的耦合，使系统更易于维护和扩展。</p><p><strong>角色介绍</strong></p><ul><li><strong>Mediator（中介者）</strong>：定义了一个接口用于与各个同事对象通信。</li><li><strong>ConcreteMediator（具体中介者）</strong>：实现了中介者接口，负责协调各个同事对象之间的交互。</li><li><strong>Colleague（同事）</strong>：定义了一个接口用于与中介者进行通信。</li><li><strong>ConcreteColleague（具体同事）</strong>：实现了同事接口，每个具体同事对象都知道中介者对象，并通过中介者对象来与其他同事对象通信。</li></ul><p><strong>应用示例</strong></p><p>考虑一个简单的聊天室系统，其中有多个用户可以在聊天室中发送消息。我们可以使用中介者模式来实现该聊天室系统。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 中介者接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ChatMediator</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMessage</span><span class="hljs-params">(String message, User user)</span>;<br>&#125;<br><br><span class="hljs-comment">// 具体中介者类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ChatRoom</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ChatMediator</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMessage</span><span class="hljs-params">(String message, User user)</span> &#123;<br>        System.out.println(user.getName() + <span class="hljs-string">&quot; sends message: &quot;</span> + message);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 同事接口</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">protected</span> ChatMediator mediator;<br>    <span class="hljs-keyword">protected</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(ChatMediator mediator, String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.mediator = mediator;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMessage</span><span class="hljs-params">(String message)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiveMessage</span><span class="hljs-params">(String message)</span>;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 具体同事类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BasicUser</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BasicUser</span><span class="hljs-params">(ChatMediator mediator, String name)</span> &#123;<br>        <span class="hljs-built_in">super</span>(mediator, name);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMessage</span><span class="hljs-params">(String message)</span> &#123;<br>        mediator.sendMessage(message, <span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiveMessage</span><span class="hljs-params">(String message)</span> &#123;<br>        System.out.println(name + <span class="hljs-string">&quot; receives message: &quot;</span> + message);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 客户端代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ChatMediator</span> <span class="hljs-variable">mediator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChatRoom</span>();<br><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BasicUser</span>(mediator, <span class="hljs-string">&quot;Alice&quot;</span>);<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BasicUser</span>(mediator, <span class="hljs-string">&quot;Bob&quot;</span>);<br><br>        mediator.sendMessage(<span class="hljs-string">&quot;Hello, everyone!&quot;</span>, user1);<br>        user2.sendMessage(<span class="hljs-string">&quot;Hi, Alice!&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>中介者模式是一种非常有用的设计模式，它可以帮助我们降低系统中对象之间的耦合度，提高代码的可维护性和可扩展性。通过引入一个中介者对象来管理对象之间的通信，中介者模式使得系统更易于理解和修改。</p><hr><h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><p class="note note-primary">访问者模式（Visitor Pattern）是一种行为设计模式，用于在不修改现有代码的情况下，向对象结构中添加新操作。该模式将操作封装到访问者对象中，并在对象结构中的每个元素上应用访问者，从而实现新的操作。</p><p><strong>角色介绍</strong></p><ul><li><strong>Visitor（访问者）</strong>：定义了一个访问方法，用于接受不同类型元素的访问。</li><li><strong>ConcreteVisitor（具体访问者）</strong>：实现了访问者接口，提供了对元素的具体访问逻辑。</li><li><strong>Element（元素）</strong>：定义了一个接受访问者的方法，用于接受访问者的访问。</li><li><strong>ConcreteElement（具体元素）</strong>：实现了元素接口，提供了对访问者的具体接受方法。</li><li><strong>ObjectStructure（对象结构）</strong>：维护了一个元素的集合，并提供了一个接受访问者的方法。</li></ul><p><strong>应用示例</strong></p><p>假设我们有一个简单的图形界面系统，其中包含不同类型的图形元素，如圆形、矩形等。我们希望对这些图形元素进行不同的操作，比如计算面积、绘制等。我们可以使用访问者模式来实现这个功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 访问者接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ShapeVisitor</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(Circle circle)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(Rectangle rectangle)</span>;<br>&#125;<br><br><span class="hljs-comment">// 具体访问者类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AreaVisitor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ShapeVisitor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(Circle circle)</span> &#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">area</span> <span class="hljs-operator">=</span> Math.PI * Math.pow(circle.getRadius(), <span class="hljs-number">2</span>);<br>        System.out.println(<span class="hljs-string">&quot;Area of circle: &quot;</span> + area);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(Rectangle rectangle)</span> &#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">area</span> <span class="hljs-operator">=</span> rectangle.getWidth() * rectangle.getHeight();<br>        System.out.println(<span class="hljs-string">&quot;Area of rectangle: &quot;</span> + area);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 元素接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(ShapeVisitor visitor)</span>;<br>&#125;<br><br><span class="hljs-comment">// 具体元素类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> radius;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Circle</span><span class="hljs-params">(<span class="hljs-type">double</span> radius)</span> &#123;<br>        <span class="hljs-built_in">this</span>.radius = radius;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getRadius</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> radius;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(ShapeVisitor visitor)</span> &#123;<br>        visitor.visit(<span class="hljs-built_in">this</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> width;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> height;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Rectangle</span><span class="hljs-params">(<span class="hljs-type">double</span> width, <span class="hljs-type">double</span> height)</span> &#123;<br>        <span class="hljs-built_in">this</span>.width = width;<br>        <span class="hljs-built_in">this</span>.height = height;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getWidth</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> width;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getHeight</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> height;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(ShapeVisitor visitor)</span> &#123;<br>        visitor.visit(<span class="hljs-built_in">this</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 对象结构类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ShapeCollection</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;Shape&gt; shapes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addShape</span><span class="hljs-params">(Shape shape)</span> &#123;<br>        shapes.add(shape);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(ShapeVisitor visitor)</span> &#123;<br>        <span class="hljs-keyword">for</span> (Shape shape : shapes) &#123;<br>            shape.accept(visitor);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 客户端代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ShapeCollection</span> <span class="hljs-variable">collection</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ShapeCollection</span>();<br>        collection.addShape(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Circle</span>(<span class="hljs-number">5</span>));<br>        collection.addShape(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Rectangle</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>));<br><br>        <span class="hljs-type">ShapeVisitor</span> <span class="hljs-variable">areaVisitor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AreaVisitor</span>();<br>        collection.accept(areaVisitor);<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>访问者模式是一种非常有用的设计模式，它可以帮助我们在不修改现有代码的情况下，向对象结构中添加新的操作。通过将操作封装到访问者对象中，并在对象结构中的每个元素上应用访问者，访问者模式使得代码更加灵活和易于扩展。</p><hr><h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><p class="note note-primary">备忘录模式（Memento Pattern）是一种行为设计模式，用于捕获对象的内部状态，并在不破坏对象封装性的情况下将其保存在外部，并在需要时恢复对象状态。这种模式有助于实现撤销操作和历史记录功能。</p><p><strong>角色介绍</strong></p><ul><li><strong>Originator（发起人）</strong>：负责创建备忘录对象，并可以使用备忘录对象恢复自身状态。</li><li><strong>Memento（备忘录）</strong>：负责存储发起人对象的内部状态。</li><li><strong>Caretaker（管理者）</strong>：负责保存备忘录对象，并在需要时将其返回给发起人对象。</li></ul><p><strong>应用示例</strong></p><p>假设我们有一个简单的文本编辑器，用户可以在其中输入文本，并且可以通过撤销功能回到之前的状态。我们可以使用备忘录模式来实现这个功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 备忘录类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TextMemento</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String text;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TextMemento</span><span class="hljs-params">(String text)</span> &#123;<br>        <span class="hljs-built_in">this</span>.text = text;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getText</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> text;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 发起人类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TextEditor</span> &#123;<br>    <span class="hljs-keyword">private</span> String text;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setText</span><span class="hljs-params">(String text)</span> &#123;<br>        <span class="hljs-built_in">this</span>.text = text;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getText</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> text;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> TextMemento <span class="hljs-title function_">save</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextMemento</span>(text);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">restore</span><span class="hljs-params">(TextMemento memento)</span> &#123;<br>        <span class="hljs-built_in">this</span>.text = memento.getText();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 管理者类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">History</span> &#123;<br>    <span class="hljs-keyword">private</span> Stack&lt;TextMemento&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(TextMemento memento)</span> &#123;<br>        stack.push(memento);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> TextMemento <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> stack.pop();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 客户端代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">TextEditor</span> <span class="hljs-variable">editor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextEditor</span>();<br>        <span class="hljs-type">History</span> <span class="hljs-variable">history</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">History</span>();<br><br>        editor.setText(<span class="hljs-string">&quot;Hello, world!&quot;</span>);<br>        history.push(editor.save());<br>        System.out.println(<span class="hljs-string">&quot;Current text: &quot;</span> + editor.getText());<br><br>        editor.setText(<span class="hljs-string">&quot;Java Design Patterns&quot;</span>);<br>        history.push(editor.save());<br>        System.out.println(<span class="hljs-string">&quot;Current text: &quot;</span> + editor.getText());<br><br>        <span class="hljs-comment">// 撤销一次</span><br>        editor.restore(history.pop());<br>        System.out.println(<span class="hljs-string">&quot;Current text after undo: &quot;</span> + editor.getText());<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>在这个示例中，<code>TextEditor</code> 类充当了发起人角色，负责创建备忘录对象并保存和恢复状态。</li><li><code>TextMemento</code> 类充当了备忘录角色，负责存储发起人对象的内部状态。</li><li><code>History</code> 类充当了管理者角色，负责保存备忘录对象，并在需要时将其返回给发起人对象。</li></ul><p>备忘录模式是一种非常有用的设计模式，它可以帮助我们实现撤销操作和历史记录功能，而不破坏对象的封装性。通过将对象的状态保存在外部，并在需要时恢复状态，备忘录模式使得程序更加灵活和易于维护。</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>行为型模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重拾设计模式（二）</title>
    <link href="/posts/509408b0/"/>
    <url>/posts/509408b0/</url>
    
    <content type="html"><![CDATA[<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p class="note note-primary">适配器模式（Adapter Pattern）将一个类的接口转换成客户端所希望的另一个接口，适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p><blockquote><p>用电器做例子，笔记本电脑的插头一般都是三相的，即除了阳极、阴极外，还有一个地极。而有些地方的电源插座却只有两极，没有地极。电源插座与笔记本电脑的电源插头不匹配使得笔记本电脑无法使用。这时候一个三相到两相的转换器（适配器）就能解决此问题，而这正像是本模式所做的事情。</p></blockquote><p>适配器模式有<strong>类的适配器模式</strong>和<strong>对象的适配器模式</strong>两种不同的形式。</p><h3 id="类的适配器模式"><a href="#类的适配器模式" class="headerlink" title="类的适配器模式"></a>类的适配器模式</h3><p class="note note-primary">类的适配器模式把适配的类的API转换成为目标类的API。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201630926.png"></p><p>在上图中可以看出，Adaptee类并没有sampleOperation2()方法，而客户端则期待这个方法。为使客户端能够使用Adaptee类，提供一个中间环节，即类Adapter，把Adaptee的API与Target类的API衔接起来。Adapter与Adaptee是继承关系，这决定了这个适配器模式是类的。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201631845.png"></p><p><strong>Target</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Target</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 这是源类Adaptee也有的方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sampleOperation1</span><span class="hljs-params">()</span>; <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 这是源类Adapteee没有的方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sampleOperation2</span><span class="hljs-params">()</span>; <br>&#125;<br></code></pre></td></tr></table></figure><p>上面给出的是目标角色的源代码，这个角色是以一个JAVA接口的形式实现的。可以看出，这个接口声明了两个方法：sampleOperation1()和sampleOperation2()。而源角色Adaptee是一个具体类，它有一个sampleOperation1()方法，但是没有sampleOperation2()方法。</p><p><strong>Adaptee</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Adaptee</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sampleOperation1</span><span class="hljs-params">()</span>&#123;&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>适配器角色Adapter扩展了Adaptee,同时又实现了目标(Target)接口。由于Adaptee没有提供sampleOperation2()方法，而目标接口又要求这个方法，因此适配器角色Adapter实现了这个方法。</p><p><strong>Adapter</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Adapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Adaptee</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Target</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 由于源类Adaptee没有方法sampleOperation2()</span><br><span class="hljs-comment">     * 因此适配器补充上这个方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sampleOperation2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//写相关的代码</span><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="对象的适配器模式"><a href="#对象的适配器模式" class="headerlink" title="对象的适配器模式"></a>对象的适配器模式</h3><p class="note note-primary">与类的适配器模式一样，对象的适配器模式把被适配的类的API转换成为目标类的API，与类的适配器模式不同的是，对象的适配器模式不是使用继承关系连接到Adaptee类，而是使用委派关系连接到Adaptee类</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201634934.png"></p><p>从上图可以看出，Adaptee类并没有sampleOperation2()方法，而客户端则期待这个方法。为使客户端能够使用Adaptee类，需要提供一个包装(Wrapper)类Adapter。这个包装类包装了一个Adaptee的实例，从而此包装类能够把Adaptee的API与Target类的API衔接起来。Adapter与Adaptee是委派关系，这决定了适配器模式是对象的。</p><p><strong>Target</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Target</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 这是源类Adaptee也有的方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sampleOperation1</span><span class="hljs-params">()</span>; <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 这是源类Adapteee没有的方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sampleOperation2</span><span class="hljs-params">()</span>; <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Adaptee</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Adaptee</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sampleOperation1</span><span class="hljs-params">()</span>&#123;&#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Adapter</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Adapter</span> &#123;<br>    <span class="hljs-keyword">private</span> Adaptee adaptee;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Adapter</span><span class="hljs-params">(Adaptee adaptee)</span>&#123;<br>        <span class="hljs-built_in">this</span>.adaptee = adaptee;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 源类Adaptee有方法sampleOperation1</span><br><span class="hljs-comment">     * 因此适配器类直接委派即可</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sampleOperation1</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-built_in">this</span>.adaptee.sampleOperation1();<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 源类Adaptee没有方法sampleOperation2</span><br><span class="hljs-comment">     * 因此由适配器类需要补充此方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sampleOperation2</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//写相关的代码</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="类适配器和对象适配器"><a href="#类适配器和对象适配器" class="headerlink" title="类适配器和对象适配器"></a>类适配器和对象适配器</h3><p>●<strong>类适配器</strong>使用对象继承的方式，是静态的定义方式；而<strong>对象适配器</strong>使用对象组合的方式，是动态组合的方式。</p><p>●<strong>对于类适配器</strong>，由于适配器直接继承了Adaptee，使得适配器不能和Adaptee的子类一起工作，因为继承是静态的关系，当适配器继承了Adaptee后，就不可能再去处理  Adaptee的子类了。</p><p> <strong>对于对象适配器</strong>，一个适配器可以把多种不同的源适配到同一个目标。换言之，同一个适配器可以把源类和它的子类都适配到目标接口。因为对象适配器采用的是对象组合的关系，只要对象类型正确，是不是子类都无所谓。</p><p>●<strong>对于类适配器</strong>，适配器可以重定义Adaptee的部分行为，相当于子类覆盖父类的部分实现方法。</p><p> <strong>对于对象适配器</strong>，要重定义Adaptee的行为比较困难，这种情况下，需要定义Adaptee的子类来实现重定义，然后让适配器组合子类。虽然重定义Adaptee的行为比较困难，但是想要增加一些新的行为则方便的很，而且新增加的行为可同时适用于所有的源。</p><p>●<strong>对于类适配器</strong>，仅仅引入了一个对象，并不需要额外的引用来间接得到Adaptee。</p><p> <strong>对于对象适配器</strong>，需要额外的引用来间接得到Adaptee。</p><p><strong>建议尽量使用对象适配器的实现方式</strong>，多用合成&#x2F;聚合、少用继承。当然，具体问题具体分析，根据需要来选用实现方式，最适合的才是最好的。</p><h3 id="缺省适配模式"><a href="#缺省适配模式" class="headerlink" title="缺省适配模式"></a>缺省适配模式</h3><p class="note note-primary">缺省适配(Default Adapter)模式为一个接口提供缺省实现，这样子类型可以从这个缺省实现进行扩展，而不必从原有接口进行扩展。作为适配器模式的一个特例，缺省是适配模式在JAVA语言中有着特殊的应用。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201706389.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">AbstractService</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serviceOperation1</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">serviceOperation2</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">serviceOperation3</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AbstractService</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serviceOperation1</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">serviceOperation2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">serviceOperation3</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>可以看到，接口AbstractService要求定义三个方法，分别是serviceOperation1()、serviceOperation2()、serviceOperation3()；而抽象适配器类ServiceAdapter则为这三种方法都提供了平庸的实现。因此，任何继承自抽象类ServiceAdapter的具体类都可以选择它所需要的方法实现，而不必理会其他的不需要的方法。</p><p><strong>适配器模式的用意</strong>是要改变源的接口，以便于目标接口相容。<strong>缺省适配的用意稍有不同</strong>，它是为了方便建立一个不平庸的适配器类而提供的一种平庸实现。</p><p>在任何时候，如果不准备实现一个接口的所有方法时，就可以使用“缺省适配模式”制造一个抽象类，给出所有方法的平庸的具体实现。这样，从这个抽象类再继承下去的子类就不必实现所有的方法了。</p></blockquote><hr><h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><p class="note note-primary">桥接模式的本质是把抽象(Abstraction)与行为实现(Implementation)分离开来，从而可以保持各部分的独立性以及应对他们的功能扩展，基于类的最小设计原则，通过使用封装、聚合及继承等行为让不同的类承担不同的职责。</p><p><strong>示例</strong></p><p>一个咖啡店卖咖啡，卖出的咖啡可以从几个角度来看：</p><ol><li><p>口味：摩卡、拿铁、美式等；</p></li><li><p>容量：大杯、中杯、小杯等；</p></li><li><p>添加物：牛奶、糖、蜂蜜等；</p></li><li><p>温度：热、常温、冷等；</p></li></ol><p>如果需要设计一个点餐系统，来生成咖啡订单，如何在系统中将上面说到的拥有4个属性的咖啡生成呢？</p><p><strong>第一种方法</strong></p><p>为每种咖啡组合编写不同的类，如下</p><ol><li><p>大杯热牛奶摩卡类；</p></li><li><p>中杯热牛奶摩卡类；</p></li><li><p>小杯热牛奶摩卡类；</p></li><li><p>大杯热蜂蜜摩卡类； ……</p></li></ol><p>试想一下，需要多少各类？假设4个维度分别可选的值是a、b、c、d，那么需要定义的类就是a x b x c x d种。而且每种属性都是固化到特定的类，没法复用，按照这个方法要定义3x3x3x3&#x3D;81个类。</p><p><strong>第二种方法</strong></p><p>针对第一种方法，我们能不能单独定义每种属性，并让每种属性能够复用，然后将他们组合&#x2F;聚合起来形成一杯咖啡呢？这样就减少每个属性的重复定义了。 例如： 1. 口味：摩卡、拿铁、美式等分别定义一个类；3个类 2. 容量：大杯、中杯、小杯等分别定义一个类；3个类 3. 添加物：牛奶、糖、蜂蜜等分别定义一个类；3个类 4. 温度：热、常温、冷等分别定义一个类；3个类</p><p>如果能够找到一种方法把这4个维度组合起来，是不是总的类数就变成a+b+c+d&#x3D;3+3+3+3&#x3D;12个类？类的数量锐减。</p><p>那么如何将这个4个维度组合起来实现一杯咖啡呢？</p><p><strong>桥接模式的原理</strong></p><p class="note note-primary">桥接模式就是为了实现上面的第二种方法的，先进行抽象，然后通过桥接将属性连接起来。</p><p>看一下下面原理图（初步思路）：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201725509.png"></p><p>再优化一下，进一步思路如下图：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201726170.png"></p><p>想一下，咖啡的最重要的属性就是口味（也可以说是本质的属性），其它的属性相对来说不是最重要的，那么我们就让口味直接通过继承的方式实现属性的集成，其它三个属性为了提升替换性&#x2F;重用性，可以也进行一个抽象类的定义，然后去具体实现。</p><p>这样设计后，通过组合&#x2F;聚合实现了咖啡多个属性的集成，减少了类的数量。</p><p>图中组合&#x2F;聚合关系就是桥接模式中Bridge的核心要义，通过组合&#x2F;聚合将多个属性连接起来的。</p><p>最后就形成了桥接模式的通用示意图，如下：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201730057.png"></p><p>**桥接模式的角色：</p><ul><li><p> <strong>抽象化(Abstraction)角色</strong>：抽象化给出的定义，并保存一个对实现化对象的引用，就是上面所说的Coffe抽象类。</p></li><li><p><strong>修正抽象化(RefinedAbstraction)角色</strong>：扩展抽象化角色，改变和修正父类对抽象化的定义，就是上面的<strong>口味实现类</strong>。  </p></li><li><p><strong>实现化(Implementor)角色</strong>：这个角色给出实现化角色的接口，但不给出具体的实现。必须指出的是，这个接口不一定和抽象化角色的接口定义相同，实际上，这两个接口可以非常不一样。实现化角色应当只给出底层操作，而抽象化角色应当只给出基于底层操作的更高一层的操作。就是上面的<strong>容量、温度、添加物抽象类</strong>。  </p></li><li><p><strong>具体实现化(ConcreteImplementor)角色</strong>：这个角色给出实现化角色接口的具体实现，就是上面的<strong>容量、温度、添加物实现类</strong>。</p></li></ul><blockquote><ol><li>抽象化(Abstraction)角色：Coffe抽象类-AbstractCoffe类的定义</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractCoffe</span> &#123;<br>    <span class="hljs-comment">// 重点：此处就是连接其它属性的关键，通过成员变量的方式聚合了其它属性</span><br>    ICapacity capacity;<br>    IAdditives additives;<br>    ITemperature temperature;<br><br>    <span class="hljs-comment">// 此处通过有参构造的方式接受客户端想要的咖啡属性</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AbstractCoffe</span><span class="hljs-params">(ICapacity capacity,IAdditives additives,ITemperature temperature)</span>&#123;<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>        <span class="hljs-built_in">this</span>.additives = additives;<br>        <span class="hljs-built_in">this</span>.temperature = temperature;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Order</span><span class="hljs-params">(<span class="hljs-type">int</span> count)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ol start="2"><li>修正抽象化(RefinedAbstraction)角色:口味实现类-MocaCoffe类定义</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MocaCoffe</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractCoffe</span>&#123;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">MocaCoffe</span><span class="hljs-params">(ICapacity capacity,IAdditives additives,ITemperature temperature)</span>&#123;<br>        <span class="hljs-built_in">super</span>(capacity, additives, temperature);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Order</span><span class="hljs-params">(<span class="hljs-type">int</span> count)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;开始制作摩卡咖啡：&quot;</span>);<br>        capacity.SetCupCapacity();<br>        additives.AddAdditives();<br>        temperature.SetTemperature();<br>        System.out.println(count+<span class="hljs-string">&quot; 杯Moca Coffe制作完成！&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//本例中就实现了一种类型，就是摩卡，还可以实现其它的口味类型，代码类似，此处就省略了。</span><br></code></pre></td></tr></table></figure><blockquote><ol start="3"><li>实现化(Implementor)角色:容量、温度、添加物抽象类-ICapacity、ITemperature、IAdditives抽象类定义</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//（1）容量抽象类ICapacity</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ICapacity</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">SetCupCapacity</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//（2）温度抽象类ITemperature</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ITemperature</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">SetTemperature</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//（3）添加物抽象类IAdditives</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IAdditives</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">AddAdditives</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ol start="4"><li>具体实现化(ConcreteImplementor)角色:容量、温度、添加物实现类-Capacity、Temperature、Additives抽象类定义</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">（1）Capacity实现类-3种</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// 大杯</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LargeCapacity</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ICapacity</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">SetCupCapacity</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;制作杯子尺寸：Large&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//中杯</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MiddleCapacity</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ICapacity</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">SetCupCapacity</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;制作杯子尺寸：Middle&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//小杯</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SmallCapacity</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ICapacity</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">SetCupCapacity</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;制作杯子尺寸：Small&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">（2）Temperature实现类-3种</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// 热饮</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HotTemperature</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ITemperature</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">SetTemperature</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;加热温度至：Hot&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 冷饮</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NormalTemperature</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ITemperature</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">SetTemperature</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;加热温度至：Normal&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 常温</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ColdTemperature</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ITemperature</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">SetTemperature</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;加热温度至：Cold&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">（3）Additives实现类-2种</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// 加奶</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MilkAdditives</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IAdditives</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">AddAdditives</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;添加 MILK 成功！&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 加糖</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SugarAdditives</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IAdditives</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">AddAdditives</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;添加 SUGAR 成功！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ol start="5"><li>客户端类定义</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 客户端传入想要的咖啡各个属性的具体对象</span><br>        <span class="hljs-type">AbstractCoffe</span> <span class="hljs-variable">mocaCoffe</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MocaCoffe</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MiddleCapacity</span>(),<span class="hljs-keyword">new</span> <span class="hljs-title class_">SugarAdditives</span>(),<span class="hljs-keyword">new</span> <span class="hljs-title class_">ColdTemperature</span>());<br>        mocaCoffe.Order(<span class="hljs-number">4</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li><p>抽象与实现分离，扩展能力强，符合开闭原则。  </p></li><li><p>实现细节对客户透明。  </p></li><li><p>减少了因为继承带来的类爆炸。</p></li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li><p>抽象难度大；  </p></li><li><p>类之间的关系变得复杂。</p></li></ul><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li><p>某个类有多个的维度的变化，如果用继承就会使项目变的臃肿，会产生许多的子类。  </p></li><li><p>抽象的部分和实现的部分都应该可以扩展。</p></li></ul><hr><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p class="note note-primary">组合模式（Composite Pattern）是一种结构型设计模式，允许你将对象组合成树形结构以表示“整体-部分”关系。组合模式使得客户端对单个对象和组合对象的使用具有一致性，从而可以将复杂的对象结构简化为一组简单的递归关系。<br/>在组合模式中，对象被组织成树形结构，其中包括复合对象（组合）和叶子对象。复合对象可以包含多个叶子对象和其他复合对象，而叶子对象不能包含任何其他对象。这些对象具有相同的接口，客户端可以通过相同的方式使用它们。</p><p>组合模式通过以下几个组件实现：</p><ol><li>抽象组件（Component）：定义了组合对象和叶子对象的公共接口。</li><li>叶子组件（Leaf Component）：表示组合中的叶子对象，不能包含任何子对象。</li><li>复合组件（Composite Component）：表示组合中的复合对象，可以包含其他叶子对象和复合对象。</li><li>客户端（Client）：使用组合对象的客户端，通过组件的公共接口与组合对象进行交互。</li></ol><p>组合模式的优点包括：</p><ol><li>简化客户端代码：客户端可以像处理单个对象一样处理组合对象，无需关心其内部结构和类型。</li><li>灵活性：可以动态地添加或删除组合对象，而无需更改现有代码。</li><li>可扩展性：可以通过添加新的叶子和复合对象扩展现有组合对象。</li><li>符合单一职责原则：组合对象只负责管理其子对象，而具体的对象操作则交由叶子对象或复合对象实现。</li></ol><p>一个简单的组合模式示例是一个文件系统，其中目录可以包含其他目录和文件。在这种情况下，文件和目录都可以看作是组合对象，它们具有相同的接口，可以相互组合。这种结构可以通过组合模式实现，并将目录和文件表示为组合对象的复合和叶子。</p><p><strong>在Java中实现的简单demo</strong></p><blockquote><p>1.定义抽象组件（Component）接口，它是组合对象和叶子对象的公共接口。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Component</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>2.定义叶子组件（Leaf Component）类，它表示组合中的叶子对象。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Leaf</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Component</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 叶子对象的具体操作</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>3.定义复合组件（Composite Component）类，它表示组合中的复合对象，可以包含其他叶子对象和复合对象。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Composite</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Component</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;Component&gt; children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 复合对象的具体操作</span><br>        <span class="hljs-keyword">for</span> (Component child : children) &#123;<br>            child.operation();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Component component)</span> &#123;<br>        children.add(component);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Component component)</span> &#123;<br>        children.remove(component);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Component <span class="hljs-title function_">getChild</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">return</span> children.get(index);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>4.定义客户端（Client）类，使用组合对象的客户端，通过组件的公共接口与组合对象进行交互。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Component</span> <span class="hljs-variable">leaf1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Leaf</span>();<br>        <span class="hljs-type">Component</span> <span class="hljs-variable">leaf2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Leaf</span>();<br><br>        <span class="hljs-type">Composite</span> <span class="hljs-variable">composite1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Composite</span>();<br>        composite1.add(leaf1);<br>        composite1.add(leaf2);<br><br>        <span class="hljs-type">Component</span> <span class="hljs-variable">leaf3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Leaf</span>();<br>        <span class="hljs-type">Component</span> <span class="hljs-variable">leaf4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Leaf</span>();<br><br>        <span class="hljs-type">Composite</span> <span class="hljs-variable">composite2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Composite</span>();<br>        composite2.add(leaf3);<br>        composite2.add(leaf4);<br>        composite2.add(composite1);<br><br>        composite2.operation();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>在这个例子中，我们创建了一个复合对象，它包含两个叶子对象和一个嵌套的复合对象。客户端代码可以像处理单个对象一样处理组合对象，而无需关心其内部结构和类型。在这个例子中，我们通过调用 <code>composite2.operation()</code> 方法，递归调用了复合对象和叶子对象的 <code>operation()</code> 方法。</p></blockquote><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol><li>当你需要表示对象的整体-部分层次结构时，可以使用组合模式。例如，文件系统中的目录和文件，GUI中的窗口和控件，组织结构图中的部门和员工等。</li><li>当你希望客户端能够统一处理复合对象和叶子对象时，可以使用组合模式。例如，你<strong>希望像处理单个对象一样处理组合对象，而无需区分它们的内部结构和类型</strong>。</li><li>当你需要以递归方式遍历复合对象中的所有元素时，可以使用组合模式。例如，你希望对文件系统中的目录和文件进行递归遍历，或对组织结构图中的部门和员工进行递归遍历。</li><li>当你需要添加或删除组合对象中的子元素时，可以使用组合模式。例如，你需要在文件系统中添加或删除目录和文件，或在组织结构图中添加或删除部门和员工。</li></ol><p>总之，组合模式适用于需要表示对象的整体-部分层次结构，并希望以统一的方式处理复合对象和叶子对象的场景。它可以使得代码更加灵活、易于扩展，并且符合面向对象设计的开闭原则。</p><hr><h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><p class="note note-primary">装饰器模式（Decorator Pattern）属于设计模式中的结构型模式，它是作为现有的类的一个包装。实现方式一般是创建一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。在想要增强某个对象的功能但是又不想改变该对象的代码时，可以引入装饰器模式。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201753494.png"></p><p>抽象组件（Component）：定义了原始对象和装饰器对象的共同接口，可以是抽象类或接口。<br>具体组件（ConcreteComponent）：实现了抽象组件接口，是需要被装饰的原始对象。<br>抽象装饰器（Decorator）：继承了抽象组件，持有一个抽象组件对象的引用，并定义了与抽象组件相同的接口。<br>具体装饰器（ConcreteDecorator）：继承了抽象装饰器，通过对抽象组件进行装饰，添加额外的功能。</p><p><strong>Component</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Coffee</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">drink</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>ConcreteComponent</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cappuccino</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Coffee</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drink</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;上一杯卡布奇诺！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Decorator</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Decorator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Coffee</span> &#123;<br>    Coffee coffee;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Decorator</span><span class="hljs-params">(Coffee coffee)</span> &#123;<br>        <span class="hljs-built_in">this</span>.coffee = coffee;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drink</span><span class="hljs-params">()</span> &#123;<br>        coffee.drink();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>ConcreteDecorator</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteDecorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Decorator</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcreteDecorator</span><span class="hljs-params">(Coffee coffee)</span> &#123;<br>        <span class="hljs-built_in">super</span>(coffee);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drink</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;上一杯加糖后的卡布奇诺！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">//原对象</span><br>    <span class="hljs-type">Coffee</span> <span class="hljs-variable">cappuccino</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cappuccino</span>();<br>    cappuccino.drink();<br>    <span class="hljs-comment">//装饰对象</span><br>    <span class="hljs-type">Coffee</span> <span class="hljs-variable">decorator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteDecorator</span>(cappuccino);<br>    decorator.drink();<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><p class="note note-primary">为子系统的接口提供一组统一的入口。外观模式定义了一个高层接口，这个接口使得子系统的更加容易使用。</p><p>在外观模式中，一个子系统的外部与其内部通信通过一个统一的外观类进行，外观类将客户类与子系统的内部复杂性分隔，使得客户类只需要与外观角色打交道，而不需要与子系统内部的很多其他对象交互。</p><p>外观模式是<strong>迪米特法则</strong>的一种具体实现，通过引入一个外观角色降低原有系统的复杂度，同时降低客户类与子系统的耦合度。</p><blockquote><p><strong>迪米特法则：</strong> 每一个软件单元对其他单元都只有最少的信息，而且局限于那些与本单元密切相关的软件单元。迪米特法则要求一个软件实体应该尽可能少地与其他实体发生相互作用。</p></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402202050224.png"></p><p>一个典型的用户与一个系统（汽车）中的多个子系统（动力系统，离合器，变速器，油门）进行交互的情形，用户需要和所有的子系统交互，才能完成自己想要实现的功能，这其实是极不合理的，也极容易出错。</p><p>首先来看看各个子系统的定义，包括：动力系统、离合器、加速器、变速器四个子系统。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 动力系统</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PowerSystem</span> &#123;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 汽车发动</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startUp</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;汽车发动。。。。&quot;</span>);<br>&#125;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 汽车熄火</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">closeDown</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;汽车熄火。。。。&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 离合器</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClutchSystem</span> &#123;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 踩下离合</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">press</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;踩下离合。。。。&quot;</span>);<br>&#125;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 松开离合</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">release</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;松开离合。。。。&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 变速器</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TransmissionSystem</span> &#123;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 挂挡操作</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> gear 所挂档位</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shift</span><span class="hljs-params">(<span class="hljs-type">int</span> gear)</span> &#123;<br><span class="hljs-keyword">switch</span> (gear) &#123;<br><span class="hljs-keyword">case</span> -<span class="hljs-number">1</span>:<br>System.out.println(<span class="hljs-string">&quot;挂倒档。。。。&quot;</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>System.out.println(<span class="hljs-string">&quot;挂空档。。。。&quot;</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>System.out.println(<span class="hljs-string">&quot;挂一档。。。。&quot;</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>System.out.println(<span class="hljs-string">&quot;挂二档。。。。&quot;</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>System.out.println(<span class="hljs-string">&quot;挂三档。。。。&quot;</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>System.out.println(<span class="hljs-string">&quot;挂四档。。。。&quot;</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>System.out.println(<span class="hljs-string">&quot;挂五档。。。。&quot;</span>);<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 加速器，即油门</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AcceleratorSystem</span> &#123;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 踩下油门</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">press</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;踩下油门。。。。&quot;</span>);<br>&#125;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 松开油门</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">release</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;松开油门。。。。&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来该看看外观的定义了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 外观类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Facade</span> &#123;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 示意方法，停车起步</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parkingStart</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">// 创建需要转调的子系统对象实例</span><br><span class="hljs-type">ClutchSystem</span> <span class="hljs-variable">clutchSystem</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClutchSystem</span>();<br><span class="hljs-type">TransmissionSystem</span> <span class="hljs-variable">transmissionSystem</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransmissionSystem</span>();<br><span class="hljs-type">AcceleratorSystem</span> <span class="hljs-variable">acceleratorSystem</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AcceleratorSystem</span>();<br><span class="hljs-comment">// 转调子系统的功能</span><br>clutchSystem.press();<br>transmissionSystem.shift(<span class="hljs-number">1</span>);<br>clutchSystem.release();<br>acceleratorSystem.press();<br>System.out.println(<span class="hljs-string">&quot;汽车开始动了。。。。&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建一个客户端类测试一下，示例代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br> <br><span class="hljs-type">PowerSystem</span> <span class="hljs-variable">powerSystem</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PowerSystem</span>();<br><span class="hljs-comment">// 发动汽车</span><br><span class="hljs-comment">// 此处作为示意，用户可以跳过外观，直接与子系统进行交互</span><br>powerSystem.startUp();<br><span class="hljs-comment">// 创建外观实例</span><br><span class="hljs-type">Facade</span> <span class="hljs-variable">facade</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Facade</span>();<br><span class="hljs-comment">// 停车起步</span><br>facade.parkingStart();<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">并未把“发动汽车”这个步骤一并加入的Facade对象中，主要是为了作一个示意：根据实际需要，用户是可以越过Facade层，直接与子系统进行交互的。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">汽车发动。。。。<br>踩下离合。。。。<br>挂一档。。。。<br>松开离合。。。。<br>踩下油门。。。。<br>汽车开始动了。。。。<br></code></pre></td></tr></table></figure><h3 id="抽象外观类"><a href="#抽象外观类" class="headerlink" title="抽象外观类"></a>抽象外观类</h3><p class="note note-primary">在上述外观模式中，如果需要增加或删除与外观类交互的子系统类，必须修改原有代码，**违背开闭原则**，因此可以通过引入**抽象外观类**对系统进行改进。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402202056641.png"></p><p>引入抽象外观类之后，客户端可以针对抽象层编程，对于新的业务需求，不需要修改原有的外观类，直接增加一个新的具体外观类即可，符合开闭原则。</p><hr><h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p class="note note-primary">享元模式（Flyweight Pattern）是一种结构型设计模式，它旨在通过共享对象来最大限度地减少内存使用和提高性能。</p>>享元模式的核心思想是将对象的状态（内部数据）分为内部状态（Intrinsic State）和外部状态（Extrinsic State）。内部状态是对象可以共享的状态，它独立于对象的场景，可以被多个对象共享。外部状态是对象特定于场景的状态，它不可共享，每个对象需要自己管理。>>享元模式的关键是引入一个享元工厂（Flyweight Factory），它负责创建和管理享元对象。当客户端需要对象时，它首先向享元工厂请求对象。如果对象已存在，享元工厂直接返回现有对象；如果对象不存在，享元工厂创建一个新的对象，并在需要时进行共享。<p>以下是享元模式的组成部分：</p><ol><li>享元接口（Flyweight）：定义共享对象的接口，包括操作共享状态的方法。</li><li>具体享元（Concrete Flyweight）：实现享元接口，并存储内部状态。</li><li>享元工厂（Flyweight Factory）：负责创建和管理享元对象，确保对象的共享和复用。</li></ol><p>下面是一个简单的 Java 代码示例，演示了如何使用享元模式来共享数字对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-comment">// Flyweight 接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Number</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">printNumber</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">// ConcreteFlyweight 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteNumber</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Number</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> value;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcreteNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-built_in">this</span>.value = value;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printNumber</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Printing number: &quot;</span> + value);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// FlyweightFactory 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumberFactory</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;Integer, Number&gt; numberMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Number <span class="hljs-title function_">getNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!numberMap.containsKey(value)) &#123;<br>            numberMap.put(value, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteNumber</span>(value));<br>        &#125;<br>        <span class="hljs-keyword">return</span> numberMap.get(value);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 客户端代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 获取共享的数字对象</span><br>        <span class="hljs-type">Number</span> <span class="hljs-variable">number1</span> <span class="hljs-operator">=</span> NumberFactory.getNumber(<span class="hljs-number">5</span>);<br>        <span class="hljs-type">Number</span> <span class="hljs-variable">number2</span> <span class="hljs-operator">=</span> NumberFactory.getNumber(<span class="hljs-number">10</span>);<br><br>        <span class="hljs-comment">// 输出结果</span><br>        number1.printNumber(); <span class="hljs-comment">// 输出：Printing number: 5</span><br>        number2.printNumber(); <span class="hljs-comment">// 输出：Printing number: 10</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在这个示例中，<code>NumberFactory</code> 充当享元工厂的角色，负责创建和管理数字对象。当客户端请求一个数字时，工厂首先检查对象是否已存在，如果存在则返回已有的对象，如果不存在则创建一个新的对象并添加到工厂中。这样就实现了数字对象的共享，避免了重复创建，节省了内存资源。</p><p>享元模式是一种非常有用的设计模式，可以在系统中存在大量相似对象时节省内存资源。通过共享对象的状态，可以显著减少对象的数量，提高系统的性能和效率。在实际开发中，我们可以根据具体的需求来应用享元模式，从而优化系统的设计和实现。</p><hr><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p class="note note-primary">代理模式是一种结构型设计模式，其主要目的是为其他对象提供一种代理以控制对这个对象的访问。代理对象通常充当客户端和实际对象之间的中介，它可以在访问实际对象之前或之后执行一些额外的操作，例如权限控制、延迟加载、缓存等。</p><p>代理模式包含以下关键角色：</p><ul><li><strong>Subject（抽象主题）</strong>：定义了代理对象和真实对象的公共接口，客户端通过这个接口访问真实对象和代理对象。</li><li><strong>RealSubject（真实主题）</strong>：定义了真实对象，是代理对象所代表的真实内容。</li><li><strong>Proxy（代理）</strong>：保存了一个引用，使得代理可以访问实际主题，同时提供了与主题相同的接口，客户端通过代理访问真实主题。</li></ul><p>下面是一个简单的 Java 代码示例，演示了如何使用代理模式来控制对实际对象的访问，并在访问前后执行额外的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Subject 接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Image</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">// RealSubject 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RealImage</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Image</span> &#123;<br>    <span class="hljs-keyword">private</span> String filename;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RealImage</span><span class="hljs-params">(String filename)</span> &#123;<br>        <span class="hljs-built_in">this</span>.filename = filename;<br>        loadFromDisk(filename);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Displaying &quot;</span> + filename);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadFromDisk</span><span class="hljs-params">(String filename)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Loading &quot;</span> + filename + <span class="hljs-string">&quot; from disk&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Proxy 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyImage</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Image</span> &#123;<br>    <span class="hljs-keyword">private</span> RealImage realImage;<br>    <span class="hljs-keyword">private</span> String filename;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ProxyImage</span><span class="hljs-params">(String filename)</span> &#123;<br>        <span class="hljs-built_in">this</span>.filename = filename;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//延迟加载</span><br>        <span class="hljs-keyword">if</span> (realImage == <span class="hljs-literal">null</span>) &#123;<br>            realImage = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RealImage</span>(filename);<br>        &#125;<br>        realImage.display();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 客户端代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Image</span> <span class="hljs-variable">image</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProxyImage</span>(<span class="hljs-string">&quot;test.jpg&quot;</span>);<br><br>        <span class="hljs-comment">// 图像将从磁盘加载</span><br>        image.display();<br>        System.out.println();<br><br>        <span class="hljs-comment">// 图像将不会从磁盘加载</span><br>        image.display();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在这个示例中，<code>Image</code> 接口定义了图片展示的公共方法 <code>display()</code>。<code>RealImage</code> 类表示真实的图片对象，而 <code>ProxyImage</code> 类充当了代理，负责控制对真实图片对象的访问。当客户端首次调用 <code>display()</code> 方法时，<code>ProxyImage</code> 会创建一个真实图片对象，并调用其 <code>display()</code> 方法展示图片。之后再次调用 <code>display()</code> 方法时，由于已经创建了真实图片对象，代理将直接调用真实图片对象的 <code>display()</code> 方法展示图片。</p><p>再来看一个关于缓存的示例，<strong>缓存</strong>是指将经常使用的数据存储在临时存储区域中，以加快数据访问速度。通过代理模式，我们可以在代理类中添加缓存逻辑，然后在访问真实对象之前先检查缓存是否存在。下面是一个简单的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-comment">// 接口：数据访问</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">DataAccessor</span> &#123;<br>    String <span class="hljs-title function_">getData</span><span class="hljs-params">(String key)</span>;<br>&#125;<br><br><span class="hljs-comment">// 具体实现类：真实数据访问</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RealDataAccessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DataAccessor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getData</span><span class="hljs-params">(String key)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Fetching data from database for key: &quot;</span> + key);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Data for &quot;</span> + key;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 代理类：缓存代理</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CachingProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DataAccessor</span> &#123;<br>    <span class="hljs-keyword">private</span> DataAccessor realDataAccessor;<br>    <span class="hljs-keyword">private</span> Map&lt;String, String&gt; cache;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CachingProxy</span><span class="hljs-params">()</span> &#123;<br>        realDataAccessor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RealDataAccessor</span>();<br>        cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getData</span><span class="hljs-params">(String key)</span> &#123;<br>        <span class="hljs-keyword">if</span> (cache.containsKey(key)) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Retrieving data from cache for key: &quot;</span> + key);<br>            <span class="hljs-keyword">return</span> cache.get(key);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> realDataAccessor.getData(key);<br>            cache.put(key, data);<br>            <span class="hljs-keyword">return</span> data;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 客户端代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建缓存代理</span><br>        <span class="hljs-type">DataAccessor</span> <span class="hljs-variable">dataAccessor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CachingProxy</span>();<br><br>        <span class="hljs-comment">// 第一次访问时从数据库获取数据，并缓存起来</span><br>        System.out.println(dataAccessor.getData(<span class="hljs-string">&quot;key1&quot;</span>));<br><br>        <span class="hljs-comment">// 第二次访问时直接从缓存获取数据</span><br>        System.out.println(dataAccessor.getData(<span class="hljs-string">&quot;key1&quot;</span>));<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在这个示例中，<code>CachingProxy</code> 是缓存代理类，它在访问真实对象之前先检查缓存是否存在数据。</p><p>通过代理模式，我们可以很容易地实现延迟加载、权限控制、缓存等功能，并且不需要修改原始对象的代码，从而增强了代码的可维护性和灵活性。</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>结构性模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重拾设计模式（一）</title>
    <link href="/posts/b138f59e/"/>
    <url>/posts/b138f59e/</url>
    
    <content type="html"><![CDATA[<h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><blockquote><p>请用C++、Java、C#或VB.NET任意一种面向对象语言实现一个计算器控制台程序，要求输入两个数和运算符号，得到结果。</p></blockquote><p>可以直接写，如下所示：<br><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041828241.png"></p><p>“且先不说出题人的意思，单就你现在的代码，就有很多不足的地方需要改进。”</p><ul><li>A、B、C、D命名不规范；</li><li>判断分支全用if，意味着每个条件都要判断；</li><li>除数为0会产生错误；</li><li>等等；</li></ul><p>最重要一点是，<strong>没有体现出面向对象</strong>的意思。</p><p><strong>考虑通过封装、继承、多态把程序的耦合度降低；<br>考虑用设计模式使得程序更加的灵活，容易修改，并且易于复用；</strong></p><p>试着以面向对象的形式改写例子：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402042113078.png"><br><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402042113911.png"></p><p>首先是一个运算类，它有两个Number属性，主要用于计算器的前后数，然后有一个虚方法GetResult()，用于得到结果，然后我把加减乘除都写成了运算类的子类，继承它后，重写了GetResult()方法，这样如果要修改任何一个算法，就不需要提供其他算法的代码了。但问题来了，<strong>我如何让计算器知道我是希望用哪一个算法呢</strong>？</p><p>现在的问题其实就是如何去实例化对象的问题，教你一招‘简单工厂模式’，也就是说，到底要实例化谁，将来会不会增加实例化的对象，比如增加开根运算，这是很容易变化的地方，应该考虑用一个单独的类来做这个创造实例的过程，这就是工厂，来，我们看看这个类如何写。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402042117297.png"></p><p>只需要输入特定的符号，工厂就实例化出合适的对象，通过多态，返回父类的方式实现计算器的结果：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402042118942.png"></p><p>Q：如果有一天我们需要更改加法运算，我们只需要改哪里；</p><p>A：改OperationAdd就可以了。</p><p>Q：那么我们需要增加各种复杂运算，比如平方根，立方根，自然对数，正弦余弦等，如何做？</p><p>A：只要增加相应的运算子类，并且还需要去修改运算类工厂，在switch中增加分支。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402042121776.png"></p><hr><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>再来看看工厂方法模式，与简单工厂模式还是有些差异。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402042125151.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402042126986.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402042126723.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402042126384.png"></p><p><strong>简单工厂VS工厂方法</strong></p><blockquote><p>如果我现在需要增加其他运算，比如求M数的N次方，或者求M数的N次方根，这些功能的增加，在简单工厂里，我是先去加‘求M数的N次方’功能类，然后去更改工厂方法，当中加‘Case’语句来做判断，现在用了工厂方法，加功能类没问题，再加相关的工厂类，这也没问题，但要我再去更改客户端，这不等于不但没有减化难度，反而增加了很多类和方法，把复杂性增加了吗？为什么要这样？</p></blockquote><p>这其实就是工厂方法模式和简单工厂的区别所在。<strong>简单工厂模式的最大优点在于工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，对于客户端来说，去除了与具体产品的依赖。</strong></p><p>但问题也就在这里，如你所说，如果要加一个‘求M数的N次方’的功能，我们是一定需要给运算工厂类的方法里加‘Case’的分支条件的，修改原有的类？这可不是好办法，这就等于说，我们不但对扩展开放了，对修改也开放了，<strong>违背了开闭原则</strong>。</p><p>而<strong>工厂方法模式实现时，客户端需要决定实例化哪一个工厂来实现运算类，选择判断的问题还是存在的，也就是说，工厂方法把简单工厂的内部逻辑判断移到了客户端代码来进行。你想要加功<br>能，本来是改工厂类的，而现在是修改客户端</strong>！</p><p><strong>工厂方法克服了简单工厂违背开放-封闭原则的缺点，又保持了封装对象创建过程的优点。</strong></p><hr><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><blockquote><p>通常我们可以让一个全局变量使得一个对象被访问，但它不能防止你实例化多个对象。一个最好的办法就是，让类自身负责保存它的唯一实例。这个类可以保证没有其他实例可以被创建，并且它可以提供一个访问该实例的方法。</p></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201501805.png"></p><blockquote><p>Singleton类，定义一个GetInstance操作，允许客户访问它的唯一实例。GetInstance是一个静态方法，主要负责创建自己的唯一实例。</p></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201502791.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201502277.png"></p><h4 id="多线程时的单例"><a href="#多线程时的单例" class="headerlink" title="多线程时的单例"></a>多线程时的单例</h4><p class="note note-warning">多线程的程序中，多个线程同时，注意是同时访问Singleton类，调用GetInstance()方法，会有可能造成创建多个实例的。</p><blockquote><p>可以给进程一把锁来处理。这里需要解释一下lock语句的涵义，lock是确保当一个线程位于代码的临界区时，另一个线程不进入临界区。如果其他线程试图进入锁定的代码，则它将一直等待（即被阻止），直到该对象被释放。</p></blockquote><blockquote><p>线程安全的单例实现方式有很多，这里记录四种常见的。</p></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201511950.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201511780.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201515253.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201512884.png"></p><h4 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h4><blockquote><p>虽然静态内部类方式实现单例模式通常被认为是线程安全的，但是有一种情况可能会导致它不安全，即在反序列化时。</p><p>在 Java 中，如果一个类可序列化（即实现了 <code>Serializable</code> 接口），那么它的实例可以被序列化为字节流，并在需要时反序列化成对象。但是，在反序列化过程中，会通过调用类的无参构造函数来创建对象，而不会调用类的任何其他构造函数。这就意味着，如果我们不小心让一个静态内部类单例模式的外部类可序列化，然后尝试对其进行反序列化，就会产生一个新的实例。</p><p>以静态内部类方式举例，要解决这个问题，可以通过增加一个特殊的方法 <code>readResolve()</code> 来解决。<code>readResolve()</code> 方法会在反序列化后调用，它允许我们返回原始的单例实例，而不是新创建的实例。</p></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201518754.png"></p><hr><h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><blockquote><p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示的意图时，我们需要应用于一个设计模式，‘建造者（Builder）模式’，又叫生成器模式。主要解决在软件系统中，有时候面临着”一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。</p></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201520989.png"></p><blockquote><p>比如创建一个手机，需要cpu，主板、内存、屏幕等，通过一个代码示例可以很清晰的得知建造者模式的用途：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.pattern.builder3;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Phone</span> &#123;<br>    <span class="hljs-keyword">private</span> String cpu;<br>    <span class="hljs-keyword">private</span> String screen;<br>    <span class="hljs-keyword">private</span> String memory;<br>    <span class="hljs-keyword">private</span> String mainboard;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Phone&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;cpu=&#x27;&quot;</span> + cpu + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, screen=&#x27;&quot;</span> + screen + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, memory=&#x27;&quot;</span> + memory + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, mainboard=&#x27;&quot;</span> + mainboard + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//私有构造</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Phone</span><span class="hljs-params">(Builder builder)</span> &#123;<br>        <span class="hljs-built_in">this</span>.cpu = builder.cpu;<br>        <span class="hljs-built_in">this</span>.screen = builder.screen;<br>        <span class="hljs-built_in">this</span>.memory = builder.memory;<br>        <span class="hljs-built_in">this</span>.mainboard = builder.mainboard;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Builder</span> &#123;<br>        <span class="hljs-keyword">private</span> String cpu;<br>        <span class="hljs-keyword">private</span> String screen;<br>        <span class="hljs-keyword">private</span> String memory;<br>        <span class="hljs-keyword">private</span> String mainboard;<br><br>        <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">cpu</span><span class="hljs-params">(String cpu)</span> &#123;<br>            <span class="hljs-built_in">this</span>.cpu = cpu;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">screen</span><span class="hljs-params">(String screen)</span> &#123;<br>            <span class="hljs-built_in">this</span>.screen = screen;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">memory</span><span class="hljs-params">(String memory)</span> &#123;<br>            <span class="hljs-built_in">this</span>.memory = memory;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">mainboard</span><span class="hljs-params">(String mainboard)</span> &#123;<br>            <span class="hljs-built_in">this</span>.mainboard = mainboard;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> Phone <span class="hljs-title function_">build</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone</span>(<span class="hljs-built_in">this</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.pattern.builder3;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Phone</span> <span class="hljs-variable">phone</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone</span>.Builder()<br>                .cpu(<span class="hljs-string">&quot;intel&quot;</span>)<br>                .mainboard(<span class="hljs-string">&quot;华硕&quot;</span>)<br>                .memory(<span class="hljs-string">&quot;金士顿&quot;</span>)<br>                .screen(<span class="hljs-string">&quot;三星&quot;</span>).build();<br>        System.out.println(phone);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><blockquote><p>用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型对象相同的新对象<br>1.如果你需要复制一些对象， 同时又希望代码独立于这些对象所属的具体类， 可以使用原型模式。<br>2.如果子类的区别仅在于其对象的初始化方式， 那么你可以使用该模式来减少子类的数量。 别人创建这些子类的目的可能是为了创建特定类型的对象。<br>3.Spring中原型bean的创建，就是原型模式的应用</p></blockquote><blockquote><p>原型模式的克隆分为浅克隆和深克隆。<br>浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原  有属性所指向的对象的内存地址。<br>深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。</p></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201536440.png"></p><h4 id="古老方法"><a href="#古老方法" class="headerlink" title="古老方法"></a>古老方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 羊 实体类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sheep</span> &#123;<br> <br>    <span class="hljs-comment">// 名称</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-comment">// 产地</span><br>    <span class="hljs-keyword">public</span> SheepAddress sheepAddress;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Sheep</span><span class="hljs-params">()</span>&#123;&#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Sheep</span><span class="hljs-params">(String name, SheepAddress sheepAddress)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.sheepAddress = sheepAddress;<br>    &#125;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Sheep&#123;name=&#x27;&quot;</span> + name + <span class="hljs-string">&quot;, sheepAddress=&quot;</span> + sheepAddress +<span class="hljs-string">&quot;&#125;&quot;</span>;<br>    &#125;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Objects.hash(name, sheepAddress);<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> SheepAddress <span class="hljs-title function_">getSheepAddress</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sheepAddress;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSheepAddress</span><span class="hljs-params">(SheepAddress sheepAddress)</span> &#123;<br>        <span class="hljs-built_in">this</span>.sheepAddress = sheepAddress;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 羊产地</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SheepAddress</span> &#123;<br> <br>    <span class="hljs-comment">//省</span><br>    <span class="hljs-keyword">private</span> String province;<br>    <span class="hljs-comment">//市</span><br>    <span class="hljs-keyword">private</span> String city;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SheepAddress</span><span class="hljs-params">()</span>&#123;&#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SheepAddress</span><span class="hljs-params">(String province, String city)</span> &#123;<br>        <span class="hljs-built_in">this</span>.province = province;<br>        <span class="hljs-built_in">this</span>.city = city;<br>    &#125;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;SheepAddress&#123;province=&quot;</span> + province + <span class="hljs-string">&quot;, city=&#x27;&quot;</span> + city + <span class="hljs-string">&quot;&#125;&quot;</span>;<br>    &#125;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Objects.hash(province, city);<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getProvince</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> province;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setProvince</span><span class="hljs-params">(String province)</span> &#123;<br>        <span class="hljs-built_in">this</span>.province = province;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getCity</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> city;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCity</span><span class="hljs-params">(String city)</span> &#123;<br>        <span class="hljs-built_in">this</span>.city = city;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProtTest</span> &#123;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Sheep</span> <span class="hljs-variable">sheep</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sheep</span>(<span class="hljs-string">&quot;多莉&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">SheepAddress</span>(<span class="hljs-string">&quot;内蒙古&quot;</span>, <span class="hljs-string">&quot;呼和浩特市&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;sheep对象的hashcode:&quot;</span> + sheep.hashCode() + <span class="hljs-string">&quot; sheepAddress对象的hashcode:&quot;</span> + sheep.sheepAddress.hashCode() + <span class="hljs-string">&quot; 属性值：&quot;</span> + sheep);<br> <br>        <span class="hljs-type">Sheep</span> <span class="hljs-variable">sheep1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sheep</span>(<span class="hljs-string">&quot;多莉1&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">SheepAddress</span>(<span class="hljs-string">&quot;内蒙古1&quot;</span>, <span class="hljs-string">&quot;呼和浩特市1&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;sheep对象的hashcode:&quot;</span> + sheep1.hashCode() + <span class="hljs-string">&quot; sheepAddress对象的hashcode:&quot;</span> + sheep1.sheepAddress.hashCode() + <span class="hljs-string">&quot; 属性值：&quot;</span> + sheep1);<br> <br>        <span class="hljs-type">Sheep</span> <span class="hljs-variable">sheep2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sheep</span>(<span class="hljs-string">&quot;多莉2&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">SheepAddress</span>(<span class="hljs-string">&quot;内蒙古2&quot;</span>, <span class="hljs-string">&quot;呼和浩特市2&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;sheep对象的hashcode:&quot;</span> + sheep2.hashCode() + <span class="hljs-string">&quot; sheepAddress对象的hashcode:&quot;</span> + sheep2.sheepAddress.hashCode() + <span class="hljs-string">&quot; 属性值：&quot;</span> + sheep2);<br> <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs log">sheep对象的hashcode:-150317243 sheepAddress对象的hashcode:-173282477 属性值：Sheep&#123;name=&#x27;多莉, sheepAddress=SheepAddress&#123;province=内蒙古, city=&#x27;呼和浩特市&#125;&#125;<br>sheep对象的hashcode:-364921810 sheepAddress对象的hashcode:-1076816753 属性值：Sheep&#123;name=&#x27;多莉1, sheepAddress=SheepAddress&#123;province=内蒙古1, city=&#x27;呼和浩特市1&#125;&#125;<br>sheep对象的hashcode:-364921747 sheepAddress对象的hashcode:-1076816721 属性值：Sheep&#123;name=&#x27;多莉2, sheepAddress=SheepAddress&#123;province=内蒙古2, city=&#x27;呼和浩特市2&#125;&#125;<br></code></pre></td></tr></table></figure><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 原型设计模式：浅拷贝，创建一只多莉羊并实现其Cloneable接口</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SheepClone06</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span>&#123;<br> <br>    <span class="hljs-comment">// 名称</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-comment">// 产地</span><br>    <span class="hljs-keyword">public</span> SheepAddress06 sheepAddress;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SheepClone06</span><span class="hljs-params">()</span>&#123;&#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SheepClone06</span><span class="hljs-params">(String name, SheepAddress06 sheepAddress)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.sheepAddress = sheepAddress;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printSheep</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(name + <span class="hljs-string">&quot;:&quot;</span> + <span class="hljs-string">&quot;是一只克隆羊！&quot;</span>);<br>    &#125;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Objects.hash(name, sheepAddress);<br>    &#125;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;SheepClone06&#123;name=&#x27;&quot;</span> + name + <span class="hljs-string">&quot;, sheepAddress=&quot;</span> + sheepAddress + <span class="hljs-string">&quot;&#125;&quot;</span>;<br>    &#125;<br> <br>    <span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.clone();<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> SheepAddress06 <span class="hljs-title function_">getSheepAddress</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sheepAddress;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSheepAddress</span><span class="hljs-params">(SheepAddress06 sheepAddress)</span> &#123;<br>        <span class="hljs-built_in">this</span>.sheepAddress = sheepAddress;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 羊的产区</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SheepAddress06</span> &#123;<br> <br>    <span class="hljs-comment">//省</span><br>    <span class="hljs-keyword">private</span> String province;<br>    <span class="hljs-comment">//市</span><br>    <span class="hljs-keyword">private</span> String city;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SheepAddress06</span><span class="hljs-params">()</span>&#123;&#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SheepAddress06</span><span class="hljs-params">(String province, String city)</span> &#123;<br>        <span class="hljs-built_in">this</span>.province = province;<br>        <span class="hljs-built_in">this</span>.city = city;<br>    &#125;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;SheepAddress06&#123;province=&#x27;&quot;</span> + province + <span class="hljs-string">&quot;&#x27;, city=&#x27;&quot;</span> + city + <span class="hljs-string">&quot;&#125;&quot;</span>;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getProvince</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> province;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setProvince</span><span class="hljs-params">(String province)</span> &#123;<br>        <span class="hljs-built_in">this</span>.province = province;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getCity</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> city;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCity</span><span class="hljs-params">(String city)</span> &#123;<br>        <span class="hljs-built_in">this</span>.city = city;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 原型设计模式是一种创建型设计模式，允许一个对象再创建另一个可定制的对象，无需知道如何创建对象的细节，</span><br><span class="hljs-comment"> * springmvc框架中的单例（singleton）与多例（prototype）正是基于该设计模式而设计的。</span><br><span class="hljs-comment"> * 原型设计模式分为俩种，一种是浅拷贝，另一种是深拷贝。浅拷贝指的是对于基本数据类型和引用类型的变量通过值传递和引用传递，</span><br><span class="hljs-comment"> * 通俗易懂的说法就是，原对象的任何更改都会影响到克隆对象。而深拷贝是通过完整的克隆，重新创建一个新的对象，</span><br><span class="hljs-comment"> * 原对象的更改不会影响到克隆对象。浅拷贝通过实现Cloneable接口，重写clone方法实现。</span><br><span class="hljs-comment"> * 深拷贝可以通过重写clone方法或者实现Serializable序列化接口，通过序列化实现对象深拷贝。</span><br><span class="hljs-comment"> * 多用于复杂对象的创建，简化对象创建过程。本节我们以克隆多莉羊为例，实现原型模式的一个案例。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 原型设计模式：浅拷贝，创建一只多莉羊并实现其Cloneable接口</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProtTest06</span> &#123;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>        <span class="hljs-type">SheepClone06</span> <span class="hljs-variable">sheep</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SheepClone06</span>(<span class="hljs-string">&quot;多莉&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">SheepAddress06</span>(<span class="hljs-string">&quot;内蒙古&quot;</span>, <span class="hljs-string">&quot;呼和浩特市&quot;</span>));<br>        sheep.printSheep();<br>        System.out.println(<span class="hljs-string">&quot;sheep对象--&gt;hashcode值:&quot;</span> + sheep.hashCode() + <span class="hljs-string">&quot; sheepAddress对象的hashcode值:&quot;</span> + sheep.sheepAddress.hashCode() + <span class="hljs-string">&quot; 属性值：&quot;</span> + sheep);<br>        <span class="hljs-comment">//调用克隆方法克隆一只多莉羊</span><br>        System.out.println();<br>        System.out.println(<span class="hljs-string">&quot;开始浅拷贝SheepClone对象...&quot;</span>);<br>        <span class="hljs-type">SheepClone06</span> <span class="hljs-variable">cloneSheep</span> <span class="hljs-operator">=</span> (SheepClone06) sheep.clone();<br>        cloneSheep.printSheep();<br>        <span class="hljs-comment">//更改多莉羊的产地</span><br>        sheep.getSheepAddress().setProvince(<span class="hljs-string">&quot;新疆&quot;</span>);<br>        sheep.getSheepAddress().setCity(<span class="hljs-string">&quot;乌鲁木齐&quot;</span>);<br>        <span class="hljs-comment">//克隆的多莉羊属性</span><br>        System.out.println(<span class="hljs-string">&quot;克隆sheep对象--&gt;hashcode值:&quot;</span> + cloneSheep.hashCode() + <span class="hljs-string">&quot; sheepAddress对象的hashcode值:&quot;</span> + cloneSheep.sheepAddress.hashCode() + <span class="hljs-string">&quot; 属性值: &quot;</span> + cloneSheep);<br> <br>        System.out.println();<br>        System.out.println(<span class="hljs-string">&quot;两个对象值分别为 sheep=&quot;</span> + sheep +<span class="hljs-string">&quot; cloneSheep=&quot;</span>+cloneSheep);<br>    &#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：<br><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201540459.png"></p><blockquote><p> 从上面的案例可以看出，修改复制的新对象属性内容，会影响之前的对象属性值。<br> 1) 对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将 该属性值复制一份给新的对象。<br> 2) 对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数组、某个类 的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用值（内存地址）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成 员变量值<br> 3) 前面我们克隆羊就是浅拷贝<br> 4) 浅拷贝是使用默认的 clone()方法来实现 sheep &#x3D; (Sheep) super.clone(); </p></blockquote><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs java"> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SheepClone07</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span>, Serializable &#123;<br> <br>    <span class="hljs-comment">// 名称</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-comment">// 产地</span><br>    <span class="hljs-keyword">public</span> SheepAddress07 sheepAddress;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SheepClone07</span><span class="hljs-params">()</span>&#123;&#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SheepClone07</span><span class="hljs-params">(String name, SheepAddress07 sheepAddress)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.sheepAddress = sheepAddress;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printSheep</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(name + <span class="hljs-string">&quot;:&quot;</span> + <span class="hljs-string">&quot;是一只克隆羊！&quot;</span>);<br>    &#125;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Objects.hash(name, sheepAddress);<br>    &#125;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;SheepClone07&#123;name=&#x27;&quot;</span> + name + <span class="hljs-string">&quot;, sheepAddress=&quot;</span> + sheepAddress + <span class="hljs-string">&quot;&#125;&quot;</span>;<br>    &#125;<br> <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 方式一： 通过重写clone方法实现深拷贝</span><br><span class="hljs-comment">     **/</span><br>    <span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>        <span class="hljs-comment">//完成对属性为基本数据类型和String的克隆</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">deep</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">super</span>.clone();<br>        <span class="hljs-type">SheepClone07</span> <span class="hljs-variable">sheepClone</span> <span class="hljs-operator">=</span> (SheepClone07) deep;<br>        sheepClone.sheepAddress = (SheepAddress07) sheepAddress.clone();<br>        <span class="hljs-keyword">return</span> sheepClone;<br>    &#125;<br> <br> <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 方式二： 通过序列化反序列化实现深拷贝(推荐使用)</span><br><span class="hljs-comment">     **/</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">deepClone</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//创建流对象</span><br>        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ByteArrayInputStream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//序列化</span><br>            bos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>            oos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(bos);<br>            oos.writeObject(<span class="hljs-built_in">this</span>);<br>            <span class="hljs-comment">//反序列化</span><br>            bis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(bos.toByteArray());<br>            ois = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(bis);<br>            <span class="hljs-type">SheepClone07</span> <span class="hljs-variable">sheepClone</span> <span class="hljs-operator">=</span> (SheepClone07) ois.readObject();<br>            <span class="hljs-keyword">return</span> sheepClone;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">//关闭流</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                bos.close();<br>                oos.close();<br>                bis.close();<br>                ois.close();<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>                System.out.println(e2.getMessage());<br>            &#125;<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> SheepAddress07 <span class="hljs-title function_">getSheepAddress</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sheepAddress;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSheepAddress</span><span class="hljs-params">(SheepAddress07 sheepAddress)</span> &#123;<br>        <span class="hljs-built_in">this</span>.sheepAddress = sheepAddress;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SheepAddress07</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span>, Serializable &#123;<br> <br>    <span class="hljs-comment">//省</span><br>    <span class="hljs-keyword">private</span> String province;<br>    <span class="hljs-comment">//市</span><br>    <span class="hljs-keyword">private</span> String city;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SheepAddress07</span><span class="hljs-params">()</span>&#123;&#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SheepAddress07</span><span class="hljs-params">(String province, String city)</span> &#123;<br>        <span class="hljs-built_in">this</span>.province = province;<br>        <span class="hljs-built_in">this</span>.city = city;<br>    &#125;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.clone();<br>    &#125;<br> <br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;SheepAddress07&#123;province=&#x27;&quot;</span> + province + <span class="hljs-string">&quot;&#x27;, city=&#x27;&quot;</span> + city + <span class="hljs-string">&quot;&#125;&quot;</span>;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getProvince</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> province;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setProvince</span><span class="hljs-params">(String province)</span> &#123;<br>        <span class="hljs-built_in">this</span>.province = province;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getCity</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> city;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCity</span><span class="hljs-params">(String city)</span> &#123;<br>        <span class="hljs-built_in">this</span>.city = city;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProtTest07</span> &#123;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>        <span class="hljs-type">SheepClone07</span> <span class="hljs-variable">sheep</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SheepClone07</span>(<span class="hljs-string">&quot;多莉&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">SheepAddress07</span>(<span class="hljs-string">&quot;内蒙古&quot;</span>, <span class="hljs-string">&quot;呼和浩特市&quot;</span>));<br>        sheep.printSheep();<br>        System.out.println(<span class="hljs-string">&quot;sheep对象--&gt;hashcode值:&quot;</span> + sheep.hashCode() + <span class="hljs-string">&quot; sheepAddress对象的hashcode值:&quot;</span> + sheep.sheepAddress.hashCode() + <span class="hljs-string">&quot; 属性值：&quot;</span> + sheep);<br> <br>        System.out.println();<br>        System.out.println(<span class="hljs-string">&quot;开始深拷贝方式一SheepClone对象(通过重写clone方法实现深拷贝)...&quot;</span>);<br>        <span class="hljs-type">SheepClone07</span> <span class="hljs-variable">cloneSheepOne</span> <span class="hljs-operator">=</span> (SheepClone07) sheep.clone();<br>        cloneSheepOne.setName(<span class="hljs-string">&quot;绵羊&quot;</span>);<br>        cloneSheepOne.printSheep();<br>        System.out.println(<span class="hljs-string">&quot;克隆sheep对象--&gt;hashcode值:&quot;</span> + cloneSheepOne.hashCode() + <span class="hljs-string">&quot; sheepAddress对象的hashcode值:&quot;</span> + cloneSheepOne.sheepAddress.hashCode() + <span class="hljs-string">&quot; 属性值: &quot;</span> + cloneSheepOne);<br> <br>        System.out.println();<br>        System.out.println(<span class="hljs-string">&quot;开始深拷贝方式二序列化SheepClone对象(通过序列化反序列化实现深拷贝)...&quot;</span>);<br>        <span class="hljs-type">SheepClone07</span> <span class="hljs-variable">cloneSheepTwo</span> <span class="hljs-operator">=</span> (SheepClone07) sheep.deepClone();<br>        cloneSheepTwo.printSheep();<br>        System.out.println(<span class="hljs-string">&quot;克隆sheep对象--&gt;hashcode值:&quot;</span> + cloneSheepTwo.hashCode() + <span class="hljs-string">&quot; sheepAddress对象的hashcode值:&quot;</span> + cloneSheepTwo.sheepAddress.hashCode() + <span class="hljs-string">&quot; 属性值: &quot;</span> + cloneSheepTwo);<br> <br>        System.out.println();<br>        System.out.println(<span class="hljs-string">&quot;两个对象值分别为 sheep=&quot;</span> + sheep +<span class="hljs-string">&quot; cloneSheepOne=&quot;</span>+cloneSheepOne+<span class="hljs-string">&quot; cloneSheepTwo=&quot;</span>+cloneSheepTwo);<br> <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：<br><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201543458.png"></p><blockquote><p>深拷贝基本介绍</p><ol><li>复制对象的所有基本数据类型的成员变量值</li><li>为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变 量所引用的对象，直到该对象可达的所有对象。也就是说，对象进行深拷贝要对 整个对象进行拷贝</li><li>深拷贝实现方式</li></ol><ul><li>重写clone方法来实现深拷贝</li><li>通过对象序列化实现深拷贝(推荐)</li></ul><p>原型模式的注意事项和细节</p><ol><li>创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提高效率。</li><li>不用重新初始化对象，而是动态地获得对象运行时的状态。</li><li>如果原始对象发生变化(增加或者减少属性)，其它克隆对象的也会发生相应的变化，无需修改代码。</li><li>在实现深克隆的时候可能需要比较复杂的代码。</li><li>缺点：需要为每一个类配备一个克隆方法，这对全新的类来说不是很难，但对已有 的类进行改造时，需要修改其源代码，违背了ocp原则。</li></ol></blockquote><hr><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>抽象工厂模式为一个产品家族提供了统一的创建接口。当需要这个产品家族的某一系列的时候，可以从抽象工厂中选出相对应的系列来创建一个具体的工厂类别。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。</p><p><strong>相关术语：</strong></p><ul><li><p><strong>产品等级结构：</strong>产品的继承结构，与类的继承相似。例如笔记本是一个抽象的类，那么华为笔记本、苹果和联想笔记本就是其子类。</p></li><li><p><strong>产品族：</strong>指同一个工厂生产的，位于不同的产品等级结构的一组产品。例如华为笔记本、手机、路由器等都产自华为，笔记本的等级结构不同，构成一个产品族。</p></li><li><p><strong>抽象工厂：</strong>是一个接口，抽象工厂模式的核心，包含对多个产品等级结构的声明，任何工厂类都必须实现这个接口。</p></li><li><p><strong>具体工厂：</strong>是抽象工厂的实现，负责实例化某个产品族中的产品对象。例如华为工厂生产华为笔记本、手机、路由器等。</p></li></ul><h3 id="产品族和产品等级结构图"><a href="#产品族和产品等级结构图" class="headerlink" title="产品族和产品等级结构图"></a>产品族和产品等级结构图</h3><p>我们以一个品牌为一个产品族，电脑、手机、路由器为产品等级，每一个品牌都有自己的产品族，这就构成一个完整产品群；</p><p>横向代表一族，纵向代表一个等级，横纵交集代表某一个品牌的某一个产品（比如下图中交集的点为电脑），请看下图；</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201602502.png"></p><h3 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h3><p>这个类图其实比较简单，简单说明下：</p><p><strong>产品顶级接口</strong>：主要被产品抽象类实现；</p><p><strong>产品抽象类</strong>：某个具体产品要实现的类；</p><p><strong>具体实现类</strong>：具体产品实现，比如华为路由器实现自抽象类AbstractRouter；</p><p><strong>工厂接口</strong>：工厂接口中定义创建每个产品方法；</p><p><strong>具体华为工厂</strong>：实现工厂接口，创建华为一族产品（路由器、手机、电脑）；</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201604768.png"></p><h3 id="具体代码实现"><a href="#具体代码实现" class="headerlink" title="具体代码实现"></a>具体代码实现</h3><blockquote><p>代码中我们以华为产品为例，分别定义华为电脑、手机、路由器产品，从UML类图中可以看出我们的产品结构层级比较清晰，现在我们先设计我们产品。</p></blockquote><p><strong>产品顶级接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> pattern.abstractfactory.product;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 定义产品接口</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">InterfaceProduct</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>定义计算机抽象类并实现产品InterfaceProduct 接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> pattern.abstractfactory.product;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 定义计算机产品抽象类，并实现产品接口InterfaceProduct</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractComputers</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InterfaceProduct</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>定义手机抽象类并实现产品InterfaceProduct 接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> pattern.abstractfactory.product;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 定义手机抽象类，并实现产品接口InterfaceProduct</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractPhone</span>  <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InterfaceProduct</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>定义路由器抽象类并实现产品InterfaceProduct 接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> pattern.abstractfactory.product;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 定义路由器产品抽象类，并实现InterfaceProduct接口</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractRouter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InterfaceProduct</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>定义华为电脑具体实现类，继承AbstractComputers抽象类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> pattern.abstractfactory.product;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 华为电脑实现类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HuaWeiComputer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractComputers</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;华为笔记本&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>定义华为手机具体实现类，继承AbstractPhone抽象类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> pattern.abstractfactory.product;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  *  华为手机实现类，</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HuaWeiPhone</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractPhone</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;华为手机&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>定义华为路由器具体实现类，继承AbstractRouter抽象类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> pattern.abstractfactory.product;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 华为路由器</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HuaWeiRouter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractRouter</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;华为品牌路由器&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-primary">下面开始定义工厂</p><p><strong>定义工厂接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> pattern.abstractfactory.factory;<br><span class="hljs-keyword">import</span> pattern.abstractfactory.product.InterfaceProduct;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 定义产品工厂接口,</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">InterfactFactory</span> &#123;<br>    <span class="hljs-comment">//手机产品</span><br>    InterfaceProduct <span class="hljs-title function_">createPhone</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">//电脑产品</span><br>    InterfaceProduct <span class="hljs-title function_">createComputer</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">//路由器产品</span><br>    InterfaceProduct <span class="hljs-title function_">createRouter</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>具体工厂实现类，实现 InterfactFactory  接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> pattern.abstractfactory.factory;<br><span class="hljs-keyword">import</span> pattern.abstractfactory.product.HuaWeiComputer;<br><span class="hljs-keyword">import</span> pattern.abstractfactory.product.HuaWeiPhone;<br><span class="hljs-keyword">import</span> pattern.abstractfactory.product.HuaWeiRouter;<br><span class="hljs-keyword">import</span> pattern.abstractfactory.product.InterfaceProduct;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * **华为工厂**</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HuaWeiFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InterfactFactory</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建电脑对象并返回</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> InterfaceProduct <span class="hljs-title function_">createComputer</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HuaWeiComputer</span>();<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建手机对象并返回</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> InterfaceProduct <span class="hljs-title function_">createPhone</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HuaWeiPhone</span>();<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建路由器对象并返回</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> InterfaceProduct <span class="hljs-title function_">createRouter</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HuaWeiRouter</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>客户端类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> pattern.abstractfactory;<br><span class="hljs-keyword">import</span> pattern.abstractfactory.factory.HuaWeiFactory;<br><span class="hljs-keyword">import</span> pattern.abstractfactory.factory.InterfactFactory;<br><span class="hljs-keyword">import</span> pattern.abstractfactory.product.InterfaceProduct;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 抽象工厂模式测试类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建华为品牌工厂</span><br>        <span class="hljs-type">InterfactFactory</span> <span class="hljs-variable">huawei</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HuaWeiFactory</span>();<br>        <span class="hljs-comment">//通过华为工厂获取华为电脑对象</span><br>        <span class="hljs-type">InterfaceProduct</span> <span class="hljs-variable">computer</span> <span class="hljs-operator">=</span> huawei.createComputer();<br>        computer.get();<br>        <span class="hljs-comment">//通过华为工厂获取华为手机对象</span><br>        <span class="hljs-type">InterfaceProduct</span> <span class="hljs-variable">phone</span> <span class="hljs-operator">=</span> huawei.createPhone();<br>        phone.get();<br>        <span class="hljs-comment">//通过华为工厂获取华为路由器对象</span><br>        <span class="hljs-type">InterfaceProduct</span> <span class="hljs-variable">router</span> <span class="hljs-operator">=</span> huawei.createRouter();<br>        router.get();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201611533.png"></p><h3 id="扩展展品族"><a href="#扩展展品族" class="headerlink" title="扩展展品族"></a>扩展展品族</h3><blockquote><p>抽象工厂模式<strong>对于横向扩展方便，对于纵向扩展非常困难</strong>，也就是说：假如我们要扩展一个新的品牌，比如扩展一个小米品牌，小米产品有电脑、手机、路由器，扩展新品牌就是横向扩展，非常方便，但是我们要给小米添加一个电饭煲产品却非常困难，这就是纵向扩展，所以在使用抽象工厂模式时一定要选择合适的场景，也就是在不同场景中使用最适合的模式才是设计模式的精髓。</p></blockquote><p><strong>小米电脑</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> pattern.abstractfactory.product;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 小米电脑，继承自 AbstractComputers 抽象类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MiComputer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractComputers</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;小米电脑&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>小米手机</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> pattern.abstractfactory.product;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 小米手机，继承自 AbstractPhone 抽象类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MiPhone</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractPhone</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;小米手机&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>小米路由器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> pattern.abstractfactory.product;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 小米路由器，继承自 AbstractRouter 抽象类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MiRouter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractRouter</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;小米路由器&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>添加小米具体工厂类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> pattern.abstractfactory.factory;<br><span class="hljs-keyword">import</span> pattern.abstractfactory.product.InterfaceProduct;<br><span class="hljs-keyword">import</span> pattern.abstractfactory.product.MiComputer;<br><span class="hljs-keyword">import</span> pattern.abstractfactory.product.MiPhone;<br><span class="hljs-keyword">import</span> pattern.abstractfactory.product.MiRouter;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 小米工厂，实现 InterfactFactory 接口</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MiFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InterfactFactory</span>&#123;<br>    <span class="hljs-comment">//小米手机</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> InterfaceProduct <span class="hljs-title function_">createPhone</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MiPhone</span>();<br>    &#125;<br>    <span class="hljs-comment">//小米电脑</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> InterfaceProduct <span class="hljs-title function_">createComputer</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MiComputer</span>();<br>    &#125;<br>    <span class="hljs-comment">//小米路由器</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> InterfaceProduct <span class="hljs-title function_">createRouter</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MiRouter</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后编写测试类，<strong>代码中红色字体为新扩展的品牌产品</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> pattern.abstractfactory;<br><span class="hljs-keyword">import</span> pattern.abstractfactory.factory.HuaWeiFactory;<br><span class="hljs-keyword">import</span> pattern.abstractfactory.factory.InterfactFactory;<br><span class="hljs-keyword">import</span> pattern.abstractfactory.factory.MiFactory;<br><span class="hljs-keyword">import</span> pattern.abstractfactory.product.InterfaceProduct;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 抽象工厂模式测试类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建华为品牌工厂</span><br>        <span class="hljs-type">InterfactFactory</span> <span class="hljs-variable">huawei</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HuaWeiFactory</span>();<br>        <span class="hljs-comment">// 通过华为工厂获取华为电脑对象</span><br>        <span class="hljs-type">InterfaceProduct</span> <span class="hljs-variable">computer</span> <span class="hljs-operator">=</span> huawei.createComputer();<br>        computer.get();<br>        <span class="hljs-comment">// 通过华为工厂获取华为手机对象</span><br>        <span class="hljs-type">InterfaceProduct</span> <span class="hljs-variable">phone</span> <span class="hljs-operator">=</span> huawei.createPhone();<br>        phone.get();<br>        <span class="hljs-comment">// 通过华为工厂获取华为路由器对象</span><br>        <span class="hljs-type">InterfaceProduct</span> <span class="hljs-variable">router</span> <span class="hljs-operator">=</span> huawei.createRouter();<br>        router.get();<br><br>        <span class="hljs-comment">// 创建小米品牌工厂</span><br>        <span class="hljs-type">InterfactFactory</span> <span class="hljs-variable">Mifactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MiFactory</span>();<br>        <span class="hljs-comment">// 通过小米工厂获取小米电脑对象</span><br>        <span class="hljs-type">InterfaceProduct</span> <span class="hljs-variable">micomputer</span> <span class="hljs-operator">=</span> Mifactory.createComputer();<br>        micomputer.get();<br>        <span class="hljs-comment">// 通过小米工厂获取小米手机对象</span><br>        <span class="hljs-type">InterfaceProduct</span> <span class="hljs-variable">miphone</span> <span class="hljs-operator">=</span> Mifactory.createPhone();<br>        miphone.get();<br>        <span class="hljs-comment">// 通过小米工厂获取小米路由器对象</span><br>        <span class="hljs-type">InterfaceProduct</span> <span class="hljs-variable">mirouter</span> <span class="hljs-operator">=</span> Mifactory.createRouter();<br>        mirouter.get();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402201615661.png"></p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>创建者模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重拾设计模式（零）- 朝花夕拾</title>
    <link href="/posts/77e3381c/"/>
    <url>/posts/77e3381c/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>设计模式是在软件设计中经常出现的问题的通用解决方案。这些解决方案是经过反复验证和证明的，并且被广泛接受和应用于软件开发中。设计模式提供了一种可重用的思想框架，可以帮助开发人员更有效地解决常见问题，并提高代码的可维护性、可读性和可扩展性。</p><p>编程是一门技术，更加是一门艺术，不能只满足于写完代码运行结果正确就完事，时常考虑如何让代码更加简练，更加容易维护，容易扩展和复用，只有这样才可以真正得到提高。</p><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><p>设计模式的使用应该遵循一些基本的设计原则，这些原则有助于编写更清晰、灵活、可维护和可扩展的代码。以下是一些常见的设计原则：</p><ol><li><p><strong>单一职责原则（Single Responsibility Principle - SRP）：</strong> 一个类应该只有一个修改的理由。每个类都应该专注于一项任务，避免一个类担负过多的职责。</p></li><li><p><strong>开闭原则（Open-Closed Principle - OCP）：</strong> 软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。可以通过接口和抽象类实现。</p></li><li><p><strong>里氏替换原则（Liskov Substitution Principle - LSP）：</strong> 派生类应该能够替换其基类而不影响程序的正确性。即，子类应该能够替代父类并保持程序的行为一致性。</p></li><li><p><strong>依赖倒置原则（Dependency Inversion Principle - DIP）：</strong> 高层模块不应该依赖于底层模块，二者都应该依赖于抽象。抽象不应该依赖于细节，而细节应该依赖于抽象。</p></li><li><p><strong>接口隔离原则（Interface Segregation Principle - ISP）：</strong> 客户端不应该强制依赖于它们不使用的接口。一个类不应该被强制实现它用不到的接口。</p></li><li><p><strong>迪米特法则（Law of Demeter，LoD，又称最少知识原则）：</strong> 一个对象应该对其他对象有最少的了解。避免在一个类中调用过多其他类的方法，减少耦合性。</p></li><li><p><strong>合成复用原则（Composition&#x2F;Aggregation Reuse Principle - CARP）：</strong> 首选使用组合&#x2F;聚合而不是继承来实现复用。通过组合可以更灵活地实现对象间的关系。</p></li><li><p><strong>优先使用对象组合，而不是类继承（Favor Composition Over Inheritance）：</strong> 对象组合通常比类继承更加灵活，能够减少耦合性并支持代码重用。</p></li></ol><p>这些原则通常被认为是良好面向对象设计的基石，它们相互交织，协同工作，帮助设计出符合软件工程最佳实践的系统结构。在实践中，根据具体情况灵活运用这些原则，有助于构建更健壮和可维护的软件系统。</p><h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041803749.png"></p><p>UML（Unified Modeling Language）类图是一种用于描述系统中的类、对象及它们之间关系的图形化建模工具。它是一种强大的面向对象的建模语言，被广泛用于软件开发和系统设计。以下是类图的主要元素和介绍：</p><ol><li><p><strong>类（Class）：</strong> 类是对现实世界中一组相似对象的抽象，它定义了对象的属性和行为。在类图中，类通常用一个矩形框表示，矩形框分为三个部分：类名、属性（字段）和方法。</p></li><li><p><strong>关联（Association）：</strong> 关联表示类之间的关系，描述一个类的实例和另一个类的实例之间的连接。关联可以是单向的或双向的，可以具有方向性，也可以是多重性的，表示一个类中的实例与另一个类中的实例之间的关系。</p></li><li><p><strong>聚合（Aggregation）：</strong> 表示一种弱的拥有关系，整体对象可以包含部分对象，但部分对象并不是整体对象的一部分。聚合用一条带有空心菱形的直线表示。</p></li><li><p><strong>组合（Composition）：</strong> 表示一种强的拥有关系，整体对象包含部分对象，部分对象是整体对象的一部分。组合用一条带有实心菱形的直线表示。</p></li><li><p><strong>泛化（Generalization）：</strong> 表示类之间的继承关系，其中一个类是另一个类的子类。泛化用一条带有空心三角箭头的直线表示。</p></li><li><p><strong>接口（Interface）：</strong> 表示一个类或一组类的契约，它规定了这些类应该实现的一组方法。接口用带有&lt;<interface>&gt;标记的小矩形表示。</p></li><li><p><strong>依赖（Dependency）：</strong> 表示一个类使用了另一个类的服务，但是并不拥有对方的对象。依赖关系用一条带有箭头的虚线表示。</p></li><li><p><strong>多重性（Multiplicity）：</strong> 表示关联、聚合或组合关系中每个端点的实例数目。例如，1..* 表示一个或多个实例。</p></li></ol><p>UML类图是软件开发中非常有用的工具，它能够清晰地展示系统中的类、对象和它们之间的关系，帮助开发人员理解系统结构、设计和实现。通过类图，开发团队能够更好地沟通和协作，确保系统的正确性和可维护性。</p><h2 id="先说结论"><a href="#先说结论" class="headerlink" title="先说结论"></a>先说结论</h2><p><strong>创建型模式</strong></p><ol><li><p><strong>工厂方法模式（Factory Method Pattern）</strong> ：定义一个创建对象的接口，但是让子类决定实例化哪个类。工厂方法使得一个类的实例化延迟到其子类。</p></li><li><p><strong>抽象工厂模式（Abstract Factory Pattern）</strong> ：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p></li><li><p><strong>单例模式（Singleton Pattern）</strong> ：确保一个类只有一个实例，并提供一个全局访问点。</p></li><li><p><strong>建造者模式（Builder Pattern）</strong> ：将一个复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示。</p></li><li><p><strong>原型模式（Prototype Pattern）</strong> ：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p></li></ol><p><strong>结构型模式</strong></p><ol><li><p><strong>适配器模式（Adapter Pattern）</strong> ：将一个类的接口转换成客户希望的另一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的类可以一起工作。</p></li><li><p><strong>桥接模式（Bridge Pattern）</strong> ：将抽象部分与它的实现部分分离，使它们可以独立变化。</p></li><li><p><strong>组合模式（Composite Pattern）</strong> ：将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p></li><li><p><strong>装饰器模式（Decorator Pattern）</strong> ：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。</p></li><li><p><strong>外观模式（Facade Pattern）</strong> ：为子系统中的一组接口提供一个统一的接口。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p></li><li><p><strong>享元模式（Flyweight Pattern）</strong> ：运用共享技术有效地支持大量细粒度的对象。</p></li><li><p><strong>代理模式（Proxy Pattern）</strong> ：为其他对象提供一种代理以控制对这个对象的访问。</p></li></ol><p><strong>行为型模式</strong></p><ol><li><p><strong>责任链模式（Chain of Responsibility Pattern）</strong> ：为请求创建一个接收者对象的链，使得多个对象都有机会处理该请求。在请求发送者和接收者之间解耦。</p></li><li><p><strong>命令模式（Command Pattern）</strong> ：将一个请求封装成一个对象，从而使用户可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。</p></li><li><p><strong>解释器模式（Interpreter Pattern）</strong> ：给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。</p></li><li><p><strong>迭代器模式（Iterator Pattern）</strong> ：提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。</p></li><li><p><strong>中介者模式（Mediator Pattern）</strong> ：用一个中介对象封装一系列对象的交互，中介者使各对象不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p></li><li><p><strong>备忘录模式（Memento Pattern）</strong> ：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。</p></li><li><p><strong>观察者模式（Observer Pattern）</strong> ：定义对象间的一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并自动更新。</p></li><li><p><strong>状态模式（State Pattern）</strong> ：允许对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。</p></li><li><p><strong>策略模式（Strategy Pattern）</strong> ：定义一系列的算法，把它们封装起来，并且使它们可以相互替换。策略模式使得算法可以独立于使用它的客户而变化。</p></li><li><p><strong>模板方法模式（Template Method Pattern）</strong> ：定义一个操作中的算法的框架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p></li><li><p><strong>访问者模式（Visitor Pattern）</strong> ：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式相关</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构和算法之旅（十二）- 其他</title>
    <link href="/posts/98b3bf1e/"/>
    <url>/posts/98b3bf1e/</url>
    
    <content type="html"><![CDATA[<blockquote><p>最近看到一本很有趣的书，《算法图解》。对一些算法描述的非常清晰、直观、有趣。这里简单记录一些读书笔记。</p></blockquote><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>假设你的计算机存储了很多乐曲。对于每个乐队，你都记录了其作品被播放的次数。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041629883.png"></p><p>你要将这个列表按播放次数从多到少的顺序排列，从而将你喜欢的乐队排序。该如何做呢？一种办法是遍历这个列表，找出作品播放次数最多的乐队，并将该乐队添加到一个新列表中。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041630942.png"><br>继续这样做，找出播放次数第二多的乐队。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041631736.png"></p><p>继续这样做，将得到一个有序的列表。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041631559.png"></p><p>接下来，分析一下它时间复杂度。要找出播放次数最多的乐队，必须检查列表中的每个元素。正如你刚才看到的，这需要的时间为O(n)。因此对于这种时间为O(n)的操作，你需要执行n次。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041634338.png"><br>需要的总时间为O(n×n)，即O(n²)。</p><p>排序算法很有用。你现在可以对如下内容进行排序：</p><ul><li>电话薄中的人名</li><li>旅行日期</li><li>电子邮件，从新到旧</li><li>等等</li></ul><p>示例代码</p><p>将数组元素按从小到大的顺序排列。先编写一个用于找出数组中最小元素的函数。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041639433.png"></p><p>现在可以使用这个函数来编写选择排序算法了。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041640898.png"></p><p>选择排序是一种灵巧的算法，但是速度不是很快。快速排序是一种更快的排序算法，其运行时间为O(n log n)。</p><h2 id="分而治之D-amp-C"><a href="#分而治之D-amp-C" class="headerlink" title="分而治之D&amp;C"></a>分而治之D&amp;C</h2><blockquote><p>一种著名的递归式问题解决方法。</p><p>分而治之的原理：<br>1.找出简单的基线条件；<br>2.确定如何缩小问题的规模，使其符合基线条件；<br>D&amp;C并非用于解决问题的算法，而是一种解决问题的思路。</p></blockquote><p>一个简单的例子，给定一个数组，</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041646083.png"><br>需要将这些数字相加，并返回结果。使用循环很容易完成这种任务。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">defsum(arr): <br>total=<span class="hljs-number">0</span> <br>forx <span class="hljs-keyword">in</span> arr: <br>total+= x <br><span class="hljs-keyword">return</span> total <br><span class="hljs-built_in">print</span> <span class="hljs-built_in">sum</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>])<br></code></pre></td></tr></table></figure><p>但如何使用递归函数来完成这种任务呢？</p><p><strong>第一步</strong>：找出基线条件。最简单的数组什么样呢？请想想这个问题，再接着往下读。如果数组不包含任何元素或只包含一个元素，计算总和将非常容易。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041649064.png"><br>因此，这就是基线条件。</p><p><strong>第二步</strong>：每次递归调用都必须离空数组更近一步。如何缩小问题的规模呢？下面是一种办法。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041650285.png"></p><p>这两个版本的结果都为12，但在第二个版本中，给函数sum传递的数组更短。换言之，这缩小了问题的规模！</p><p>函数sum的工作原理类似于下面这样。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041651529.png"></p><p>这个函数的运行过程如下。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041651359.png"></p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><blockquote><p>快速排序是一种常用的排序算法，比选择排序快得多。例如，C语言标准库中的函数qsort实现的就是快速排序。快速排序也使用了D&amp;C。</p></blockquote><p>下面来使用快速排序对数组进行排序。对排序算法来说，最简单的数组什么样呢？还记得前一节的“提示”吗？就是根本不需要排序的数组。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041657372.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">quicksort</span>(<span class="hljs-params">array</span>): <br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(array)&lt;<span class="hljs-number">2</span>: <br><span class="hljs-keyword">return</span> array<br></code></pre></td></tr></table></figure><p>因此，基线条件为数组为空或只包含<strong>一</strong>个元素。在这种情况下，只需原样返回数组——根本就不用排序。</p><p>我们来看看更长的数组。对包含<strong>两</strong>个元素的数组进行排序也很容易。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041659123.png"><br>包含三个元素的数组呢？</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041700889.png"></p><p>别忘了，你要使用D&amp;C，因此需要将数组分解，直到满足基线条件。下面介绍<strong>快速排序的工作原理</strong>。首先，从数组中<strong>选择一个元素</strong>，这个元素被称为<strong>基准值</strong>(pivot)。稍后再介绍如何选择合适的基准值。我们暂时将数组的第一个元素用作基准值。接下来，找出比基准值小的元素以及比基准值大的元素。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041701782.png"><br><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041701748.png"></p><p>这被称为分区(partitioning)。现在你有：</p><ul><li>一个由所有小于基准值的数字组成的子数组；</li><li>基准值；</li><li>一个由所有大于基准值的数组组成的子数组。</li></ul><p>这里只是进行了分区，得到的两个子数组是无序的。但如果这两个数组是有序的，对整个数组进行排序将非常容易。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041702668.png"></p><p>如果子数组是有序的，就可以像下面这样合并得到一个有序的数组：左边的数组+基准值+右边的数组。在这里，就是[10,15]+[33]+[]，结果为有序数组[10,15,33]。</p><p>如何对子数组进行排序呢？对于包含两个元素的数组（左边的子数组）以及空数组（右边的子数组），快速排序知道如何将它们排序，因此只要对这两个子数组进行快速排序，再合并结果，就能得到一个有序数组！</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041704511.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202402041705539.png"></p><p>快速排序的性能高度依赖于你选择的基准值。假设你总是将第一个元素用作基准值，且要处理的数组是有序的。由于快速排序算法不检查输入数组是否有序，因此它依然尝试对其进行排序。最糟糕的情况运行时间是O(n²)。</p>]]></content>
    
    
    <categories>
      
      <category>data&amp;algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构和算法之旅（十一）- 哈希表</title>
    <link href="/posts/3cbe22a9/"/>
    <url>/posts/3cbe22a9/</url>
    
    <content type="html"><![CDATA[<blockquote><p>哈希表是一种功能强大的数据结构，其操作速度快，还能以不同的方式建立数据模型。</p><p>结合散列函数和数组来创建散列表。<br>散列表的查找、插入和删除都非常快。<br>散列表适用于模拟映射关系。<br>负载因子一旦超过0.7，就该调整散列表的长度。<br>散列表可用于缓存数据，例如Web服务器的缓存。<br>散列表非常适合用于防止重复。</p></blockquote><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><blockquote><p>几乎根本不需要自己去实现散列表，因为各种编程语言基本都会提供。不过为了为了掌握，还是敲一边加深印象把。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.datastructure;  <br>  <br><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * 哈希表  </span><br><span class="hljs-comment"> * &lt;p&gt;  </span><br><span class="hljs-comment"> * 给每份数据分配一个编号，放入数组、  </span><br><span class="hljs-comment"> * 建立编号与数组索引的关系，将来可以通过编号快速查找到数据。  </span><br><span class="hljs-comment"> * 存在问题：  </span><br><span class="hljs-comment"> * 1.理想情况下，数组容纳所有数据，但是不现实，因为数组需要连续内存存储的；  </span><br><span class="hljs-comment"> * 2.现实是不能说为了容纳所有数据造一个超大数组，编号也有可能重复的；  </span><br><span class="hljs-comment"> * 解决：  </span><br><span class="hljs-comment"> * 1.有限长度的数组，以【拉链】方式存储数据；  </span><br><span class="hljs-comment"> * 2.允许编号适当重复，通过数据自身进行区分；  </span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashTable</span> &#123;  <br>  <br>    <span class="hljs-comment">//节点类  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> &#123;  <br>        <span class="hljs-type">int</span> hash;<span class="hljs-comment">//哈希码  </span><br>        Object key;<span class="hljs-comment">//键  </span><br>        <span class="hljs-keyword">public</span> Object value;<span class="hljs-comment">//值  </span><br>        <span class="hljs-keyword">public</span> Entry next;<span class="hljs-comment">//下一个节点  </span><br>  <br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Entry</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, Object key, Object value)</span> &#123;  <br>            <span class="hljs-built_in">this</span>.hash = hash;  <br>            <span class="hljs-built_in">this</span>.key = key;  <br>            <span class="hljs-built_in">this</span>.value = value;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> Entry[] table = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[<span class="hljs-number">16</span>];<span class="hljs-comment">//哈希表，数组，每个元素是一个链表的头节点  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//元素个数  </span><br>    <span class="hljs-type">float</span> <span class="hljs-variable">loadFactor</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.75f</span>;<span class="hljs-comment">//负载因子 16*0.75=12  也叫阈值  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">threshold</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (table.length * loadFactor);<span class="hljs-comment">//阈值 用变量记录，后面可以复用  </span><br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * ！！！  </span><br><span class="hljs-comment">     * 求模运算替换为位运算  </span><br><span class="hljs-comment">     *  -前提：数组长度必须是2的n次方  </span><br><span class="hljs-comment">     *  -hash % 数组长度 等价与 hash &amp; (数组长度-1)  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-comment">/**     * 查询  </span><br><span class="hljs-comment">     * 根据hash码获取Value  </span><br><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, Object key)</span> &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> hash &amp; (table.length - <span class="hljs-number">1</span>);  <br>        <span class="hljs-keyword">if</span> (table[idx] == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>        <span class="hljs-type">Entry</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> table[idx];<span class="hljs-comment">//头节点  </span><br>        <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-keyword">if</span> (p.key == key) <span class="hljs-keyword">return</span> p.value;  <br>            p = p.next;  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 向hash表存入新key value，  </span><br><span class="hljs-comment">     * 分三种情况：  </span><br><span class="hljs-comment">     * 找到空位，直接插入  </span><br><span class="hljs-comment">     * 找链表，如果key已存在，替换value  </span><br><span class="hljs-comment">     * 找链表，如果key不存在，插入链表尾部  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, Object key, Object value)</span> &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> hash &amp; (table.length - <span class="hljs-number">1</span>);<span class="hljs-comment">//hash &amp; (数组长度-1)  </span><br>        <span class="hljs-keyword">if</span> (table[idx] == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//1.找到空位 直接插入  </span><br>            table[idx] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(hash, key, value);  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            <span class="hljs-comment">//2.无空位，找链表。如果key已存在，替换value  </span><br>            <span class="hljs-type">Entry</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> table[idx];  <br>            <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span>) &#123;  <br>                <span class="hljs-keyword">if</span> (p.key.equals(key)) &#123;  <br>                    p.value = value;<span class="hljs-comment">//更新  </span><br>                    <span class="hljs-keyword">return</span>;  <br>                &#125;  <br>                <span class="hljs-keyword">if</span> (p.next == <span class="hljs-literal">null</span>) <span class="hljs-keyword">break</span>;  <br>                p = p.next;  <br>            &#125;  <br>            <span class="hljs-comment">//3.找链表，如果key不存在，插入链表尾部  </span><br>            p.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(hash, key, value);  <br>        &#125;  <br>        size++;  <br>        <span class="hljs-keyword">if</span> (size &gt; threshold) &#123;  <br>            resize();  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 根据hash 删除，返回删除的value  </span><br><span class="hljs-comment">     */</span>    Object <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, Object key)</span> &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> hash &amp; (table.length - <span class="hljs-number">1</span>);<span class="hljs-comment">//hash &amp; (数组长度-1)  </span><br>        <span class="hljs-keyword">if</span> (table[idx] == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>        <span class="hljs-type">Entry</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> table[idx];<span class="hljs-comment">//头节点  </span><br>        <span class="hljs-type">Entry</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<span class="hljs-comment">//前一个节点  </span><br>        <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-keyword">if</span> (p.key.equals(key)) &#123;<span class="hljs-comment">//找到了 删除  </span><br>                <span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> p.value;  <br>                <span class="hljs-keyword">if</span> (prev == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//删除的是头节点  </span><br>                    table[idx] = p.next;  <br>                &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//删除的是中间节点  </span><br>                    prev.next = p.next;  <br>                &#125;  <br>                size--;  <br>                <span class="hljs-keyword">return</span> value;  <br>            &#125;  <br>            prev = p;<span class="hljs-comment">//记录前一个节点  </span><br>            p = p.next;  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 扩容  </span><br><span class="hljs-comment">     * &lt;p&gt;  </span><br><span class="hljs-comment">     * 负载因子 = size / table.length  </span><br><span class="hljs-comment">     * 不易过小也不易过大，  </span><br><span class="hljs-comment">     * 过小，浪费，空间利用率低  </span><br><span class="hljs-comment">     * 过大，快满了，效率低  </span><br><span class="hljs-comment">     * &lt;p&gt;  </span><br><span class="hljs-comment">     * 3/4 也是 0.75是经验值 比较合适  </span><br><span class="hljs-comment">     * 扩容之后，会重新计算每个元素的位置  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">resize</span><span class="hljs-params">()</span> &#123;  <br>        Entry[] newTable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[table.length &lt;&lt; <span class="hljs-number">2</span>];<span class="hljs-comment">//新数组 容量是原来的2倍  </span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; table.length; i++) &#123;  <br>            <span class="hljs-type">Entry</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> table[i];<span class="hljs-comment">//头节点  </span><br>            <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">null</span>) &#123;  <br>                <span class="hljs-type">Entry</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;  <br>                <span class="hljs-type">Entry</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;  <br>                <span class="hljs-type">Entry</span> <span class="hljs-variable">aHead</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;  <br>                <span class="hljs-type">Entry</span> <span class="hljs-variable">bHead</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;  <br>                <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span>) &#123;  <br>                    <span class="hljs-comment">//拆分链表 移动到新数组  </span><br>                <span class="hljs-comment">/*  </span><br><span class="hljs-comment">                拆分规律：  </span><br><span class="hljs-comment">                    一个链表最多拆分成两个链表  </span><br><span class="hljs-comment">                    hash&amp;table.length 为0的一组  </span><br><span class="hljs-comment">                    hash&amp;table.length 为1的一组  </span><br><span class="hljs-comment">                 */</span>                    <span class="hljs-keyword">if</span> ((p.hash &amp; table.length) == <span class="hljs-number">0</span>) &#123;  <br>                        <span class="hljs-comment">//a组  </span><br>                        <span class="hljs-keyword">if</span> (a != <span class="hljs-literal">null</span>) &#123;  <br>                            a.next = p;  <br>                        &#125; <span class="hljs-keyword">else</span> &#123;  <br>                            aHead = p;<span class="hljs-comment">//记录头节点  </span><br>                        &#125;  <br>                        a = p;  <br>                    &#125; <span class="hljs-keyword">else</span> &#123;  <br>                        <span class="hljs-comment">//b组  </span><br>                        <span class="hljs-keyword">if</span> (b != <span class="hljs-literal">null</span>) &#123;  <br>                            b.next = p;  <br>                        &#125; <span class="hljs-keyword">else</span> &#123;  <br>                            bHead = p;<span class="hljs-comment">//记录头节点  </span><br>                        &#125;  <br>                        b = p;  <br>                    &#125;  <br>                    p = p.next;  <br>                &#125;  <br>                <span class="hljs-comment">//a、b组，各自的头节点重置规律  </span><br>                <span class="hljs-comment">//a:保持索引位置不变  </span><br>                <span class="hljs-comment">//b:索引位置=原索引位置+原数组长度  </span><br>                <span class="hljs-keyword">if</span> (a != <span class="hljs-literal">null</span>) &#123;  <br>                    a.next = <span class="hljs-literal">null</span>;  <br>                    newTable[i] = aHead;  <br>                &#125;  <br>                <span class="hljs-keyword">if</span> (b != <span class="hljs-literal">null</span>) &#123;  <br>                    b.next = <span class="hljs-literal">null</span>;  <br>                    newTable[i + table.length] = bHead;  <br>                &#125;  <br>            &#125;        &#125;        table = newTable;  <br>        threshold = (<span class="hljs-type">int</span>) (table.length * loadFactor);<span class="hljs-comment">//更新阈值size  </span><br>    &#125;  <br>  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * hash 改造  </span><br><span class="hljs-comment">     * &lt;p&gt;  </span><br><span class="hljs-comment">     * hash码，一种简单的方式，可以直接使用jdk的 object.hashCode()  </span><br><span class="hljs-comment">     * 所以上述 get、put、remove方法都可以加一个重载，去掉hash参数  </span><br><span class="hljs-comment">     */</span>  <br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;  <br>        <span class="hljs-keyword">return</span> key.hashCode();  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">get</span><span class="hljs-params">(Object key)</span> &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> hash(key);  <br>        <span class="hljs-keyword">return</span> get(hash, key);  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(Object key, Object value)</span> &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> hash(key);  <br>        put(hash, key, value);  <br>    &#125;  <br>  <br>    Object <span class="hljs-title function_">remove</span><span class="hljs-params">(Object key)</span> &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> hash(key);  <br>        <span class="hljs-keyword">return</span> remove(hash, key);  <br>    &#125;  <br>  <br>  <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>data&amp;algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构和算法之旅（十）- 红黑树</title>
    <link href="/posts/c47e1f8e/"/>
    <url>/posts/c47e1f8e/</url>
    
    <content type="html"><![CDATA[<blockquote><p>红黑树也是一种自平衡的二叉搜索树，较之AVL，插入和删除旋转次数更少。性能上要稍微高一些。因为判断平衡的依据是不同的，之前AVL树是判断左右子树高度差是不是超过了1，超过1表示不平衡。而红黑树判断平衡是另一种规则。</p></blockquote><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>红黑树特性：</p><ul><li>1.所有节点都有俩种颜色：红与黑</li><li>2.所有null视为黑色</li><li>3.红色节点不能相邻，(判断平衡的主要依据)</li><li>4.根节点时黑色</li><li>5.从根到任意一个叶子节点，路径中的黑色节点数一样(判断平衡的主要依据)</li></ul><p>不满足这些特性的都是不平衡的红黑树。</p></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309220920490.png"></p><h2 id="是否是红黑树？"><a href="#是否是红黑树？" class="headerlink" title="是否是红黑树？"></a>是否是红黑树？</h2><h3 id="树1"><a href="#树1" class="headerlink" title="树1"></a>树1</h3><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309221519546.png"></p><p class="note note-danger">不是红黑树。因为违反了第3条：红色节点不能相邻。</p><h3 id="树2"><a href="#树2" class="headerlink" title="树2"></a>树2</h3><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309221521761.png"></p><p class="note note-danger">不是红黑树。因为违反了第5条：从根到任意一个叶子节点，路径中黑色节点数一样。右边重，左边轻，是不平衡的。</p><h3 id="树3"><a href="#树3" class="headerlink" title="树3"></a>树3</h3><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309221522358.png"></p><p class="note note-success">是红黑树。关键的3,4,5条特性都满足。</p><h3 id="树4"><a href="#树4" class="headerlink" title="树4"></a>树4</h3><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309221524531.png"></p><p class="note note-danger">这个和上一个类似，但是它并不是平衡的。<br>因为没有考虑null值。<br>那什么时候需要考虑null呢，就是当叶子节点没有自己的兄弟的时候，这个时候就需要把null加进来考虑。</p><p>如果加入null值，如下图， 6到2的右孩子只有俩个黑色，而6到1或者8的孩子都是3个黑色，所以是不平衡的。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309221526990.png"></p><p class="note note-warning">那为什么树3是平衡的红黑树呢？可以把null考虑进来，可以看出根到任意叶子节点的黑色数都是3，所以是平衡的。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309221531405.png"></p><p class="note note-primary">判断是否平衡有一点经验总结。<br>如果叶子节点是红色，可以不用不用care。<br>如果叶子节点就一个黑色，没有兄弟节点，那肯定是不平衡的。<br>红色节点无所谓，黑色节点肯定要成对出现的。</p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309221539104.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> redblack;  <br>  <br><span class="hljs-keyword">import</span> com.sun.org.apache.regexp.internal.RE;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedBlackTree</span> &#123;  <br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> &#123;  <br>        RED, BLACK;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">private</span> Node root;  <br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;  <br>        <span class="hljs-type">int</span> key;  <br>        Object value;  <br>        Node left;  <br>        Node right;  <br>        Node parent;<span class="hljs-comment">//父节点 因为红黑树的删除和新增经常用到父节点  </span><br>        <span class="hljs-type">Color</span> <span class="hljs-variable">color</span> <span class="hljs-operator">=</span> Color.RED;<span class="hljs-comment">//默认刚创建出来新节点是为红色  </span><br>  <br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> key, Object value)</span> &#123;  <br>            <span class="hljs-built_in">this</span>.key = key;  <br>            <span class="hljs-built_in">this</span>.value = value;  <br>        &#125;  <br>  <br>        <span class="hljs-comment">//是否是左孩子 常用工具方法  </span><br>        <span class="hljs-type">boolean</span> <span class="hljs-title function_">isLeftChild</span><span class="hljs-params">()</span> &#123;  <br>            <span class="hljs-comment">//如果父节点不为空且父节点的left是自身则是左孩子  </span><br>            <span class="hljs-keyword">return</span> parent != <span class="hljs-literal">null</span> &amp;&amp; parent.left == <span class="hljs-built_in">this</span>;  <br>        &#125;  <br>  <br>        <span class="hljs-comment">//叔叔 常用工具方法  </span><br>        Node <span class="hljs-title function_">uncle</span><span class="hljs-params">()</span> &#123;  <br>            <span class="hljs-keyword">if</span> (parent == <span class="hljs-literal">null</span> || parent.parent == <span class="hljs-literal">null</span>) &#123;  <br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<span class="hljs-comment">//没有爷爷就没有叔叔  </span><br>            &#125;  <br>            <span class="hljs-keyword">if</span> (parent.isLeftChild()) &#123;  <br>                <span class="hljs-keyword">return</span> parent.parent.right;  <br>            &#125; <span class="hljs-keyword">else</span> &#123;  <br>                <span class="hljs-keyword">return</span> parent.parent.left;  <br>            &#125;  <br>        &#125;  <br>  <br>        <span class="hljs-comment">//兄弟 常用工具方法  </span><br>        Node <span class="hljs-title function_">sibling</span><span class="hljs-params">()</span> &#123;  <br>            <span class="hljs-keyword">if</span> (parent == <span class="hljs-literal">null</span>) &#123;  <br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<span class="hljs-comment">//没父亲就没兄弟  </span><br>            &#125;  <br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.isLeftChild()) &#123;  <br>                <span class="hljs-keyword">return</span> parent.right;  <br>            &#125; <span class="hljs-keyword">else</span> &#123;  <br>                <span class="hljs-keyword">return</span> parent.left;  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//判断红、黑  </span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isRed</span><span class="hljs-params">(Node node)</span> &#123;  <br>        <span class="hljs-keyword">return</span> node != <span class="hljs-literal">null</span> &amp;&amp; node.color == Color.RED;  <br>    &#125;  <br>  <br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBlack</span><span class="hljs-params">(Node node)</span> &#123;  <br>        <span class="hljs-keyword">return</span> node == <span class="hljs-literal">null</span> || node.color == Color.BLACK;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//右选 1.parent的处理 2.旋转后新根的父子关系  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rightRotate</span><span class="hljs-params">(Node pink)</span> &#123;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> pink.parent;<span class="hljs-comment">//pink不平衡的节点  </span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">yellow</span> <span class="hljs-operator">=</span> pink.left;<span class="hljs-comment">//yellow新根  </span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">green</span> <span class="hljs-operator">=</span> yellow.right;<span class="hljs-comment">//green要换爹的  </span><br>        <span class="hljs-keyword">if</span> (green != <span class="hljs-literal">null</span>) &#123;  <br>            green.parent = pink;  <br>        &#125;  <br>        yellow.right = pink;<span class="hljs-comment">//顶上去  </span><br>        yellow.parent = parent;  <br>        pink.left = green;  <br>        pink.parent = yellow;  <br>        <span class="hljs-keyword">if</span> (parent == <span class="hljs-literal">null</span>) &#123;  <br>            root = yellow;  <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (parent.left == pink) &#123;  <br>            parent.left = yellow;  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            parent.right = yellow;  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//左旋  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">leftRotate</span><span class="hljs-params">(Node pink)</span> &#123;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> pink.parent;<span class="hljs-comment">//pink不平衡的节点  </span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">yellow</span> <span class="hljs-operator">=</span> pink.right;<span class="hljs-comment">//yellow新根  </span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">green</span> <span class="hljs-operator">=</span> yellow.left;<span class="hljs-comment">//green要换爹的  </span><br>        <span class="hljs-keyword">if</span> (green != <span class="hljs-literal">null</span>) &#123;  <br>            green.parent = pink;  <br>        &#125;  <br>        yellow.left = pink;<span class="hljs-comment">//顶上去  </span><br>        yellow.parent = parent;  <br>        pink.right = green;  <br>        pink.parent = yellow;  <br>        <span class="hljs-keyword">if</span> (parent == <span class="hljs-literal">null</span>) &#123;  <br>            root = yellow;  <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (parent.right == pink) &#123;  <br>            parent.right = yellow;  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            parent.left = yellow;  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 新增或更新  </span><br><span class="hljs-comment">     * 找空位，找到之后根据k-v创建新的节点对象，然后根父节点建立好父子关系，新增操作就算完成了。  </span><br><span class="hljs-comment">     * 如果没有找到空位，就根据key的大小不断的向左找向右找。  </span><br><span class="hljs-comment">     * 如果找相同的key，就是更新。  </span><br><span class="hljs-comment">     * &lt;p&gt;  </span><br><span class="hljs-comment">     * 正常增，遇到红红不平衡进行调整  </span><br><span class="hljs-comment">     * 红红不平衡细分有四种case。  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, Object value)</span> &#123;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> root;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<span class="hljs-comment">//记录新增节点的父节点  </span><br>        <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span>) &#123;  <br>            parent = p;  <br>            <span class="hljs-keyword">if</span> (key &lt; p.key) &#123;  <br>                p = p.left;  <br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p.key &lt; key) &#123;  <br>                p = p.right;  <br>            &#125; <span class="hljs-keyword">else</span> &#123;  <br>                p.value = value;<span class="hljs-comment">//更新  </span><br>                <span class="hljs-keyword">return</span>;  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">inserted</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(key, value);  <br>        <span class="hljs-keyword">if</span> (parent == <span class="hljs-literal">null</span>) root = inserted;  <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &lt; parent.key) &#123;  <br>            parent.left = inserted;  <br>            inserted.parent = parent;<span class="hljs-comment">//1.维护parent属性  </span><br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            parent.right = inserted;  <br>            inserted.parent = parent;<span class="hljs-comment">//1.维护parent属性  </span><br>        &#125;  <br>        fixRedRed(inserted);  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//修复红红  </span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">fixRedRed</span><span class="hljs-params">(Node x)</span> &#123;  <br>        <span class="hljs-comment">//case 1.插入节点是根节点，变黑集合  </span><br>        <span class="hljs-keyword">if</span> (x == root) &#123;  <br>            x.color = Color.BLACK;  <br>            <span class="hljs-keyword">return</span>;  <br>        &#125;  <br>        <span class="hljs-comment">//case 2.插入节点父亲是黑色，无需调整  </span><br>        <span class="hljs-keyword">if</span> (isBlack(x.parent)) &#123;  <br>            <span class="hljs-keyword">return</span>;  <br>        &#125;  <br>        <span class="hljs-comment">/*  </span><br><span class="hljs-comment">        case 3.当红红相邻，叔叔为红色时  </span><br><span class="hljs-comment">        需要将父亲、叔叔变黑、祖父变红，然后对祖父做递归处理  </span><br><span class="hljs-comment">         */</span>        <span class="hljs-type">Node</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> x.parent;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">uncle</span> <span class="hljs-operator">=</span> x.uncle();  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">grandparent</span> <span class="hljs-operator">=</span> parent.parent;  <br>        <span class="hljs-keyword">if</span> (isRed(uncle)) &#123;  <br>            parent.color = Color.BLACK;  <br>            uncle.color = Color.BLACK;  <br>            grandparent.color = Color.RED;  <br>            fixRedRed(grandparent);  <br>        &#125;  <br>  <br>        <span class="hljs-comment">//case 4.  </span><br>        <span class="hljs-keyword">if</span> (parent.isLeftChild() &amp;&amp; x.isLeftChild()) &#123;<span class="hljs-comment">//LL  </span><br>            parent.color = Color.BLACK;  <br>            grandparent.color = Color.RED;  <br>            rightRotate(grandparent);  <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (parent.isLeftChild() &amp;&amp; !x.isLeftChild()) &#123;<span class="hljs-comment">//RL  </span><br>            leftRotate(parent);<span class="hljs-comment">//使之变成LL case  </span><br>            x.color = Color.BLACK;  <br>            grandparent.color = Color.RED;  <br>            rightRotate(grandparent);  <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!parent.isLeftChild() &amp;&amp; !x.isLeftChild()) &#123;<span class="hljs-comment">//RR  </span><br>            parent.color = Color.BLACK;  <br>            grandparent.color = Color.RED;  <br>            leftRotate(grandparent);  <br>        &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//LR  </span><br>            rightRotate(parent);<span class="hljs-comment">////使之变成RR case  </span><br>            x.color = Color.BLACK;  <br>            grandparent.color = Color.RED;  <br>            leftRotate(grandparent);  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 查找删除节点  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">private</span> Node <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> root;  <br>        <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-keyword">if</span> (key &lt; p.key) &#123;  <br>                p = p.left;  <br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p.key &lt; key) &#123;  <br>                p = p.right;  <br>            &#125; <span class="hljs-keyword">else</span> &#123;  <br>                <span class="hljs-keyword">return</span> p;  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 查找剩余节点  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">private</span> Node <span class="hljs-title function_">findReplaced</span><span class="hljs-params">(Node deleted)</span> &#123;  <br>        <span class="hljs-keyword">if</span> (deleted.left == <span class="hljs-literal">null</span> &amp;&amp; deleted.right == <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>        &#125;  <br>        <span class="hljs-keyword">if</span> (deleted.left == <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-keyword">return</span> deleted.right;  <br>        &#125;  <br>        <span class="hljs-keyword">if</span> (deleted.right == <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-keyword">return</span> deleted.left;  <br>        &#125;  <br>        <span class="hljs-comment">//有俩个孩子，要找后继节点(右子树的最左)  </span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> deleted.right;  <br>        <span class="hljs-keyword">while</span> (s.left != <span class="hljs-literal">null</span>) &#123;  <br>            s = s.left;  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> s;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 删除  </span><br><span class="hljs-comment">     * 正常删、会用到李代桃僵的技巧，遇到黑黑不平衡进行调整  </span><br><span class="hljs-comment">     * 黑黑不平衡细分有6种case。  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">deleted</span> <span class="hljs-operator">=</span> find(key);  <br>        <span class="hljs-keyword">if</span> (deleted == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;  <br>        doRemove(deleted);  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doRemove</span><span class="hljs-params">(Node deleted)</span> &#123;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">replaced</span> <span class="hljs-operator">=</span> findReplaced(deleted);  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> deleted.parent;  <br>        <span class="hljs-keyword">if</span> (replaced == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//没有孩子  </span><br>            <span class="hljs-comment">//case 1.删的根节点  </span><br>            <span class="hljs-keyword">if</span> (deleted == root) &#123;  <br>                root = <span class="hljs-literal">null</span>;  <br>            &#125; <span class="hljs-keyword">else</span> &#123;  <br>                <span class="hljs-keyword">if</span> (isBlack(deleted)) &#123;<span class="hljs-comment">//删除到节点时黑，剩余的也是黑，双黑(null也是黑)  </span><br>                    <span class="hljs-comment">//复杂调整  </span><br>                    fixDoubleBlack(deleted);<span class="hljs-comment">//先调整平衡，下面在删除  </span><br>                &#125; <span class="hljs-keyword">else</span> &#123;  <br>                    <span class="hljs-comment">//红色叶子，无需任何处理  </span><br>                &#125;  <br>                <span class="hljs-comment">//case 2.不是根节点 并没有孩子  </span><br>                <span class="hljs-keyword">if</span> (deleted.isLeftChild()) &#123;  <br>                    parent.left = <span class="hljs-literal">null</span>;  <br>                &#125; <span class="hljs-keyword">else</span> &#123;  <br>                    parent.right = <span class="hljs-literal">null</span>;  <br>                &#125;  <br>                deleted.parent = <span class="hljs-literal">null</span>;<span class="hljs-comment">//help GC  </span><br>            &#125;  <br>            <span class="hljs-keyword">return</span>;  <br>        &#125;  <br>        <span class="hljs-keyword">if</span> (deleted.left == <span class="hljs-literal">null</span> || deleted.right == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//有一个孩子  </span><br>            <span class="hljs-keyword">if</span> (deleted == root) &#123;  <br>                <span class="hljs-comment">//case 1.删的根节点  </span><br>                root.key = replaced.key;  <br>                root.value = replaced.value;  <br>                root.left = root.right = <span class="hljs-literal">null</span>;  <br>            &#125; <span class="hljs-keyword">else</span> &#123;  <br>                <span class="hljs-comment">//case 2.不是根节点 并有一个孩子  </span><br>                <span class="hljs-keyword">if</span> (deleted.isLeftChild()) &#123;  <br>                    parent.left = replaced;  <br>                &#125; <span class="hljs-keyword">else</span> &#123;  <br>                    parent.right = replaced;  <br>                &#125;  <br>                replaced.parent = parent;  <br>                deleted.left = deleted.right = deleted.parent = <span class="hljs-literal">null</span>;<span class="hljs-comment">//help GC  </span><br>                <span class="hljs-keyword">if</span> (isBlack(deleted) &amp;&amp; isBlack(replaced)) &#123;<span class="hljs-comment">//删除到节点时黑，剩余的也是黑，双黑  </span><br>                    <span class="hljs-comment">//复杂调整  </span><br>                    fixDoubleBlack(replaced);<span class="hljs-comment">//上面先删除了，再调整  </span><br>                &#125; <span class="hljs-keyword">else</span> &#123;  <br>                    <span class="hljs-comment">//case 2  </span><br>                    replaced.color = Color.BLACK;  <br>                &#125;  <br>            &#125;  <br>            <span class="hljs-keyword">return</span>;  <br>        &#125;  <br>        <span class="hljs-comment">//有俩个孩子，找到后继，替换，删除后继节点  </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> deleted.key;  <br>        deleted.key = replaced.key;  <br>        replaced.key = t;  <br>  <br>        <span class="hljs-type">Object</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> deleted.value;  <br>        deleted.value = replaced.value;  <br>        replaced.value = v;  <br>        doRemove(replaced);  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 处理双黑  </span><br><span class="hljs-comment">     * 删除到节点和剩下的节点都是黑，触发双黑，双黑的意思是，整个路径上少一个黑！需要调整  </span><br><span class="hljs-comment">     * case 3：被调整节点的兄弟为红，此时俩个侄子定为黑（过度情况，需要转换成4或5，通过旋转）  </span><br><span class="hljs-comment">     * case 4：被调整节点的兄弟为黑，俩个侄子都为黑  </span><br><span class="hljs-comment">     * case 5：被调整节点的兄弟为黑，至少一个红侄子  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fixDoubleBlack</span><span class="hljs-params">(Node x)</span> &#123;  <br>        <span class="hljs-keyword">if</span> (x == root) &#123;<span class="hljs-comment">//递归结束条件  </span><br>            <span class="hljs-keyword">return</span>;  <br>        &#125;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> x.parent;<span class="hljs-comment">//父  </span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">sibling</span> <span class="hljs-operator">=</span> x.sibling();<span class="hljs-comment">//兄弟  </span><br>        <span class="hljs-comment">//case 3:兄弟节点是红色  </span><br>        <span class="hljs-keyword">if</span> (isRed(sibling)) &#123;  <br>            <span class="hljs-keyword">if</span> (x.isLeftChild()) &#123;<span class="hljs-comment">//旋转  </span><br>                leftRotate(parent);  <br>            &#125; <span class="hljs-keyword">else</span> &#123;  <br>                rightRotate(parent);  <br>            &#125;  <br>            parent.color = Color.RED;<span class="hljs-comment">//换色  </span><br>            sibling.color = Color.BLACK;  <br>            fixDoubleBlack(x);  <br>            <span class="hljs-keyword">return</span>;  <br>        &#125;  <br>        <span class="hljs-comment">//case 4:兄弟节点是黑色，俩个侄子都是黑  </span><br>        <span class="hljs-keyword">if</span> (sibling != <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-keyword">if</span> (isBlack(sibling.left) &amp;&amp; isBlack(sibling.right)) &#123;  <br>                sibling.color = Color.RED;  <br>                <span class="hljs-keyword">if</span> (isRed(parent)) &#123;  <br>                    parent.color = Color.BLACK;  <br>                &#125; <span class="hljs-keyword">else</span> &#123;  <br>                    fixDoubleBlack(parent);  <br>                &#125;  <br>            &#125; <span class="hljs-keyword">else</span> &#123;  <br>                <span class="hljs-comment">//case 5:兄弟是黑色，但是侄子有红色  </span><br>                <span class="hljs-comment">//LL 兄弟是左孩子，左侄子是红  </span><br>                <span class="hljs-keyword">if</span> (sibling.isLeftChild() &amp;&amp; isRed(sibling.left)) &#123;  <br>                    rightRotate(parent);  <br>                    sibling.left.color = Color.BLACK;  <br>                    sibling.color = parent.color;  <br>                &#125;  <br>                <span class="hljs-comment">//LR 兄弟是左孩子，右侄子是红  </span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sibling.isLeftChild() &amp;&amp; isRed(sibling.right)) &#123;  <br>                    sibling.right.color = parent.color;  <br>                    leftRotate(sibling);  <br>                    rightRotate(parent);  <br>                &#125;  <br>                <span class="hljs-comment">//RR 兄弟是右孩子，右侄子是红  </span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!sibling.isLeftChild() &amp;&amp; isRed(sibling.left)) &#123;  <br>                    sibling.left.color = parent.color;  <br>                    rightRotate(sibling);  <br>                    leftRotate(parent);  <br>                &#125;  <br>                <span class="hljs-comment">//RL 兄弟是右孩子，左侄子是红  </span><br>                <span class="hljs-keyword">else</span> &#123;  <br>                    leftRotate(parent);  <br>                    sibling.right.color = Color.BLACK;  <br>                    sibling.color = parent.color;  <br>                &#125;  <br>                parent.color = Color.BLACK;  <br>            &#125;  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            fixDoubleBlack(parent);  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h3><p><strong>旋转前</strong></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309221548839.png"></p><p><strong>旋转后</strong></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309221550900.png"></p><p>理解旋转，对照图，标记颜色有助于帮助理解，和代码实现。</p><p>📌<em>旋转前</em>：<br>yellow是pink的左孩子；<code>Node yellow = pink.left</code><br>green是yellow的右孩子；<code>Node green = yellow.right</code><br>📌<em>旋转后</em>：<br>yellow要顶上去，成为新根；<br>pink要下去，成为yellow的右孩子；<code>yellow.right = pink</code><br>而且pink的左孩子变成了green； <code>pink.left = green</code></p><p>到这一步，如果是AVL树就完事了，不过红黑树还要维护一个parent，🙃 还需要继续处理，并且要把新根yellow的父子关系直接在旋转这个方法里给搭建好；</p><p>接下来就把pink、yellow、green的parent属性处理好。</p><p>1️⃣ 处理green的parent：<br>旋转前，green的parent是yellow；<br>旋转后，green的parent是pink；<br>所以green的parent要重新赋值，当然green并不一定存在，所以需要一个判断：<br><code>if(green != null) green.parent = pink;</code></p><p>2️⃣ 处理yellow的parent：<br>旋转前，yellow的parent是pink；<br>旋转后，yellow成了pink的parent；<br>该图列不存在5,8的parent，但是可能存在，所以，<br><code>yellow.parent = pink.parent</code> 等价于 <code>yellow.parent = parent</code>，<br>因为这个parent就是通过<code>Node parent = pink.parent</code>拿到的。</p><p>3️⃣ 处理pink的parent：<br>旋转后，pink的parent变成了yellow；<br>所以<code>pink.parent = yellow</code></p><p><strong>还有一件事</strong>，就是处理好新根的父子关系，该图例有些特殊，直接就是根了，看一下下面图例：</p><p><strong>旋转前</strong></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309221605459.png"></p><p><strong>旋转后</strong></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309221606180.png"></p><p>要维护yellow顶上去之后的parent父子关系。<br>旋转前，通过<code>Node parent = pink.parent;</code> 拿到之前的根。<br>旋转后，需要判断之前pink是它的父的左还是右孩子，就可以判断之后，决定yellow是之前根到左还是右，所以：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(parent.left == pink)&#123;<br>parent.left = yellow;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>parent.right = yellow;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后再考虑之前的特殊情况，<br><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309221548839.png"></p><p>pink是之前的根，它的parent是null，那去给它的left、right赋值肯定是有问题的，所以应该排除这种情况，直接把yellow作为root即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(parent == <span class="hljs-literal">null</span>) root = yellow;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(parent.left == pink)&#123;<span class="hljs-comment">//把上面的非根情况逻辑补充上</span><br>parent.left = yellow;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>parent.right = yellow;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h3><p>其实左旋类似右旋，只不过反过来。可以通过着色法搞一下，比对右旋加深理解。</p><h3 id="新增或更新"><a href="#新增或更新" class="headerlink" title="新增或更新"></a>新增或更新</h3><p>新增的时候，跟基本的二叉搜索树一致，只不过多两件事</p><ul><li>1.要维护新增节点的parent属性</li><li>2.要维护红红的不平衡，因为新增的是默认红色</li></ul><p>红红不平衡，细分有四种case：<br>因为插入节点均视为红色🔴</p><ul><li>case 1.插入节点为根节点，将根节点变黑⚫️</li><li>case 2.插入节点的父节点若为黑色⚫️，树的红黑性质不变，无序调整<br>插入节点的父节点为红色🔴，触发红红相邻</li><li>case 3.叔叔为红色🔴<ul><li>1.父亲变为黑色⚫️，为了保证黑色平衡，连带叔叔也变成黑色⚫️</li><li>2.祖父如果是黑色不变，会造成这个子树黑色过多，因此祖父也变为红色🔴</li><li>3.祖父如果变成红色，可能会接着触发红红相邻，因此继续对祖父进行递归调整</li><li>4.直到根节点，如果root变为红色，改为红色就完成了</li></ul></li><li>case 4.叔叔为黑色⚫️<ul><li>1.父亲为左孩子，插入节点也是左孩子，此时即LL不平衡</li><li>2.父亲为左孩子，插入节点是右孩子，此时即LR不平衡</li><li>3.父亲为右孩子，插入节点也是右孩子，此时即RR不平衡</li><li>4.父亲为右孩子，插入节点是左孩子，此时即RL不平衡</li></ul></li></ul><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>删除可能触发双黑的情况，触发双黑，双黑的意思是，整个路径上少一个黑！需要调整也有很多case如下：</p><ul><li>case 0：如果删除节点有俩个孩子，化简成只有一个孩子或没有孩子（替换删除）</li><li>csae 1：删除到是根节点</li><li>case 2：删除的是黑⚫️，剩下的红🔴，剩下这个红节点变黑⚫️</li><li>case 3：被调整节点的兄弟为红🔴，此时俩个侄子定为黑⚫️</li><li>case 4：被调整节点的兄弟是黑⚫️，俩个侄子都为黑⚫️</li><li>case 5：被调整节点的兄弟是黑⚫️，至少一个红🔴侄子<ul><li>如果兄弟是左孩子，左侄子是红🔴，LL不平衡</li><li>如果兄弟是左孩子，右侄子是红🔴，LR不平衡</li><li>如果兄弟是右孩子，右侄子是红🔴，RR不平衡</li><li>如果兄弟是右孩子，左侄子是红🔴，RL不平衡</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>data&amp;algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>红黑树</tag>
      
      <tag>左旋</tag>
      
      <tag>右旋</tag>
      
      <tag>变色</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构和算法之旅（九）- AVL树</title>
    <link href="/posts/cbf454fc/"/>
    <url>/posts/cbf454fc/</url>
    
    <content type="html"><![CDATA[<p class="note note-light">二叉搜索树，如果不平衡，那么查找效率就会从对数级降级成O(n)。<br>可以通过旋转来恢复平衡，而且旋转并不影响二叉搜索树的特性。<br>那么，如何判断是否不平衡呢，是有个结论的：<br>如果一个节点的左右孩子，高度差超过1，则此节点失衡，才需要旋转。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309212107467.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309212109106.png"></p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><ul><li>二叉搜索树在插入和删除时，节点可能失衡。</li><li>如果在插入和删除时通过旋转，始终让二叉搜索树保持平衡，称为自平衡的二叉搜索树。</li><li>AVL是自平衡二叉搜索树的实现之一。</li></ul></blockquote><h2 id="旋转分析"><a href="#旋转分析" class="headerlink" title="旋转分析"></a>旋转分析</h2><p>失衡有四种情况LL、LR、RL、RR，但基本的选择操作有俩种就是左旋或右旋。</p><h3 id="LL"><a href="#LL" class="headerlink" title="LL"></a>LL</h3><blockquote><ul><li>失衡节点（图中5红色）的bf &gt; 1，即左边更高</li><li>失衡节点的左孩子（图中3黄色）的bf &gt;&#x3D; 0，即左孩子也是左边更高或等高</li></ul></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309212134218.png"></p><h3 id="LR"><a href="#LR" class="headerlink" title="LR"></a>LR</h3><blockquote><ul><li>失衡节点（图中6）的bf &gt; 1，即左边高</li><li>失衡节点的左孩子（图中2红色）的bf &lt; 0，即左孩子是右边高</li></ul></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309212135453.png"></p><h3 id="RL"><a href="#RL" class="headerlink" title="RL"></a>RL</h3><blockquote><ul><li>失衡节点（图中2）的bf &lt; -1 ，即右边高</li><li>失衡节点的右孩子（图中6红色）的bf &gt; 0 ，即右孩子的左边更高</li></ul></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309212135743.png"></p><h3 id="RR"><a href="#RR" class="headerlink" title="RR"></a>RR</h3><blockquote><ul><li>失衡节点（图中2红色）的bf &lt; -1 ，即右边更高</li><li>失衡节点（图中6黄色）的bf &lt;&#x3D; 0，即右孩子的右边更高或等高</li></ul></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309212135380.png"></p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> avl;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AVLTree</span> &#123;  <br>  <br>    AVLNode root;  <br>  <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AVLNode</span> &#123;  <br>        <span class="hljs-type">int</span> key;  <br>        Object value;  <br>        AVLNode left;  <br>        AVLNode right;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">height</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//高度  </span><br>  <br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">AVLNode</span><span class="hljs-params">(<span class="hljs-type">int</span> key, Object value)</span> &#123;  <br>            <span class="hljs-built_in">this</span>.key = key;  <br>            <span class="hljs-built_in">this</span>.value = value;  <br>        &#125;  <br>  <br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">AVLNode</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;  <br>            <span class="hljs-built_in">this</span>.key = key;  <br>        &#125;  <br>  <br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">AVLNode</span><span class="hljs-params">(<span class="hljs-type">int</span> key, Object value, AVLNode left, AVLNode right)</span> &#123;  <br>            <span class="hljs-built_in">this</span>.key = key;  <br>            <span class="hljs-built_in">this</span>.value = value;  <br>            <span class="hljs-built_in">this</span>.left = left;  <br>            <span class="hljs-built_in">this</span>.right = right;  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//求节点的高度  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">height</span><span class="hljs-params">(AVLNode node)</span> &#123;  <br>        <span class="hljs-keyword">return</span> node == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : node.height;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//更新节点高度(新增、删除、旋转)  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateHeight</span><span class="hljs-params">(AVLNode node)</span> &#123;  <br>        <span class="hljs-comment">//就是找左或右深度加1  </span><br>        node.height = Integer.max(height(node.left), height(node.right)) + <span class="hljs-number">1</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 平衡因子balance factor = 左子树高度-右子树高度  </span><br><span class="hljs-comment">     * 0 , -1, 1 都是平衡的  </span><br><span class="hljs-comment">     * bf&gt;1，不平衡，表示左边高  </span><br><span class="hljs-comment">     * bf&lt;-1，不平衡，表示右边高  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">bf</span><span class="hljs-params">(AVLNode node)</span> &#123;  <br>        <span class="hljs-keyword">return</span> height(node.left) - height(node.right);  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 右旋，就是把根旋转下去，把左子树旋转上来  </span><br><span class="hljs-comment">     *  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> node 要旋转的节点  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 选装上去的新的根节点  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">private</span> AVLNode <span class="hljs-title function_">rightRotate</span><span class="hljs-params">(AVLNode node)</span> &#123;  <br>        <span class="hljs-type">AVLNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> node.left;<span class="hljs-comment">//找到左子树  </span><br>        left.right = node;<span class="hljs-comment">//顶上去  </span><br>        node.left = left.right;<span class="hljs-comment">//换爹的  </span><br>        updateHeight(node);<span class="hljs-comment">//更新高度  </span><br>        updateHeight(left);<span class="hljs-comment">//更新高度  </span><br>        <span class="hljs-keyword">return</span> left;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 左旋，就是把根旋转下去，把右子树旋转上来  </span><br><span class="hljs-comment">     *  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> node 要旋转的节点  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 选装上去的新的根节点  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">private</span> AVLNode <span class="hljs-title function_">leftRotate</span><span class="hljs-params">(AVLNode node)</span> &#123;  <br>        <span class="hljs-type">AVLNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> node.right;<span class="hljs-comment">//找到右子树  </span><br>        right.left = node;<span class="hljs-comment">//顶上去  </span><br>        node.right = right.left;<span class="hljs-comment">//换爹的  </span><br>        updateHeight(node);<span class="hljs-comment">//更新高度  </span><br>        updateHeight(right);<span class="hljs-comment">//更新高度  </span><br>        <span class="hljs-keyword">return</span> right;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//先左旋左子树，再右旋根节点  </span><br>    <span class="hljs-keyword">private</span> AVLNode <span class="hljs-title function_">leftRightRotate</span><span class="hljs-params">(AVLNode node)</span> &#123;  <br>        node.left = leftRotate(node.left);  <br>        <span class="hljs-keyword">return</span> rightRotate(node);  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//先右旋右子树，在左旋根节点  </span><br>    <span class="hljs-keyword">private</span> AVLNode <span class="hljs-title function_">rightLeftRotate</span><span class="hljs-params">(AVLNode node)</span> &#123;  <br>        node.right = rightRotate(node.right);  <br>        <span class="hljs-keyword">return</span> leftRotate(node);  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 检查节点是否失衡，重新平衡  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">private</span> AVLNode <span class="hljs-title function_">balance</span><span class="hljs-params">(AVLNode node)</span> &#123;  <br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">bf</span> <span class="hljs-operator">=</span> bf(node);  <br>        <span class="hljs-keyword">if</span> (bf &gt; <span class="hljs-number">1</span> &amp;&amp; bf(node.left) &gt;= <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//LL 考虑删除引发的不平衡，加个等号  </span><br>            <span class="hljs-keyword">return</span> leftRotate(node);  <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bf &gt; <span class="hljs-number">1</span> &amp;&amp; bf(node.left) &lt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//LR  </span><br>            <span class="hljs-keyword">return</span> leftRightRotate(node);  <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bf &lt; -<span class="hljs-number">1</span> &amp;&amp; bf(node.right) &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//RL  </span><br>            <span class="hljs-keyword">return</span> rightLeftRotate(node);  <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bf &lt; -<span class="hljs-number">1</span> &amp;&amp; bf(node.right) &lt;= <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//RR 考虑删除引发的不平衡，加个等号  </span><br>            <span class="hljs-keyword">return</span> rightRotate(node);  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> node;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 新增&amp;更新  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, Object value)</span> &#123;  <br>        root = doPut(root, key, value);  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 递归实现put  </span><br><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> AVLNode <span class="hljs-title function_">doPut</span><span class="hljs-params">(AVLNode node, <span class="hljs-type">int</span> key, Object value)</span> &#123;  <br>        <span class="hljs-comment">//1.找到空位，创建新节点  </span><br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AVLNode</span>(key, value);  <br>        &#125;  <br>        <span class="hljs-comment">//2.key已存在，更新  </span><br>        <span class="hljs-keyword">if</span> (key == node.key) &#123;  <br>            node.value = value;  <br>            <span class="hljs-keyword">return</span> node;  <br>        &#125;  <br>        <span class="hljs-comment">//3.继续查找  </span><br>        <span class="hljs-keyword">if</span> (key &lt; node.key) &#123;  <br>            node.left = doPut(node.left, key, value);  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            node.right = doPut(node.right, key, value);  <br>        &#125;  <br>        updateHeight(node);  <br>        <span class="hljs-keyword">return</span> balance(node);  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 删除  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;  <br>        root = doRemove(root, root.key);  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">private</span> AVLNode <span class="hljs-title function_">doRemove</span><span class="hljs-params">(AVLNode node, <span class="hljs-type">int</span> key)</span> &#123;  <br>        <span class="hljs-comment">//1.node==null  </span><br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>        <span class="hljs-comment">//2.没找到key继续递归  </span><br>        <span class="hljs-keyword">if</span> (key &lt; node.key) &#123;  <br>            node.left = doRemove(node.left, key);  <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.key &lt; key) &#123;  <br>            node.right = doRemove(node.right, key);  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            <span class="hljs-comment">//3.找到key  1.没有孩子  2.只有一个孩子  3有俩个孩子  </span><br>            <span class="hljs-keyword">if</span> (node.left == <span class="hljs-literal">null</span> &amp;&amp; node.right == <span class="hljs-literal">null</span>) &#123;  <br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.left == <span class="hljs-literal">null</span>) &#123;  <br>                node = node.right;<span class="hljs-comment">//暂存给node 等待更新高度和平衡  </span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.right == <span class="hljs-literal">null</span>) &#123;  <br>                node = node.left;<span class="hljs-comment">//暂存给node 等待更新高度和平衡  </span><br>            &#125; <span class="hljs-keyword">else</span> &#123;  <br>                <span class="hljs-comment">//找后续：右子树的最左  </span><br>                <span class="hljs-comment">//处理后事  </span><br>                <span class="hljs-comment">//顶替  </span><br>                <span class="hljs-type">AVLNode</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.right;  <br>                <span class="hljs-keyword">while</span> (s.left != <span class="hljs-literal">null</span>) &#123;  <br>                    s = s.left;  <br>                &#125;  <br>                s.right = doRemove(node.right, s.key);  <br>                s.left = node.left;  <br>                node = s;  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-comment">//4.更新高度  </span><br>        updateHeight(node);  <br>        <span class="hljs-comment">//5.balance  </span><br>        <span class="hljs-keyword">return</span> balance(node);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>data&amp;algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AVL树</tag>
      
      <tag>失衡</tag>
      
      <tag>高度</tag>
      
      <tag>旋转</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构和算法之旅（八）- 二叉搜索树</title>
    <link href="/posts/6ed67d4e/"/>
    <url>/posts/6ed67d4e/</url>
    
    <content type="html"><![CDATA[<blockquote><p>之前接触过了很多数据结果，包括动态数组、单向链表、双向链表、环形链表、优先级队列、大顶堆等等，在这些数据结构里查找一个元素效率都不太高，都是线性的时间。如果想实现快速查找，就得引入新的算法或者数据结构了。最早了解的二分查找算法查找效率不错，是logn的。但是排序也是成本比较高的，先排序再查找有些得不偿失。<br>那么有什么新的算法或数据结构呢，答案是有的。<br>接下来就来看一下二叉搜索树，也称为二叉排序树。</p></blockquote><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309211606403.png"></p><p class="note note-primary">二叉搜索树有俩个特点：<br>1.树节点增加key属性，用来比较谁大谁小，key不可重复。<br>2.对于任意一个树节点，它的key比左子树的key都大，同时也比右子树的key都小。</p><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><blockquote><p>查找的性能是对数级别的，但是有些情况比如树不平衡的时候，时间复杂度又回到了O(n)。</p></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309211610963.png"></p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309212009913.png"></p><p class="note note-light">以下是几个提前准备的算法基础。</p><p><strong>前任的算法</strong></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309211951386.png"></p><p><strong>后任的算法</strong>（与前任相反）<br><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309212008791.png"></p><p><strong>删除的算法</strong>（稍微复杂）<br><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309212014389.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> bst;  <br>  <br><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * Binary Search Tree二叉搜索树  </span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BSTTree</span>&lt;K <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;K&gt;, V&gt; &#123;  <br>  <br>    BSTNode&lt;K, V&gt; root;<span class="hljs-comment">//根节点  </span><br>  <br>  <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BSTNode</span>&lt;K, V&gt; &#123;  <br>        K key;  <br>        V value;  <br>        BSTNode&lt;K, V&gt; left;  <br>        BSTNode&lt;K, V&gt; right;  <br>  <br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">BSTNode</span><span class="hljs-params">(K key)</span> &#123;  <br>            <span class="hljs-built_in">this</span>.key = key;  <br>        &#125;  <br>  <br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">BSTNode</span><span class="hljs-params">(K key, V value)</span> &#123;  <br>            <span class="hljs-built_in">this</span>.key = key;  <br>            <span class="hljs-built_in">this</span>.value = value;  <br>        &#125;  <br>  <br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">BSTNode</span><span class="hljs-params">(K key, V value, BSTNode&lt;K, V&gt; left, BSTNode&lt;K, V&gt; right)</span> &#123;  <br>            <span class="hljs-built_in">this</span>.key = key;  <br>            <span class="hljs-built_in">this</span>.value = value;  <br>            <span class="hljs-built_in">this</span>.left = left;  <br>            <span class="hljs-built_in">this</span>.right = right;  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 查找关键字对应的值  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(K key)</span> &#123;  <br>        <span class="hljs-comment">//对外隐藏了BSTNode的参数，不用暴露给外界  </span><br>        <span class="hljs-keyword">return</span> doGet(root, key);  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 递归方式实现get  </span><br><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> V <span class="hljs-title function_">doGet</span><span class="hljs-params">(BSTNode&lt;K, V&gt; p, K key)</span> &#123;  <br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<span class="hljs-comment">//没有节点了，没找到，结束递归  </span><br>        &#125;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> key.compareTo(p.key);  <br>        <span class="hljs-keyword">if</span> (result &lt; <span class="hljs-number">0</span>) &#123;  <br>            <span class="hljs-keyword">return</span> doGet(p.left, key);<span class="hljs-comment">//如果待查找的key小于node，向左找  </span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result &gt; <span class="hljs-number">0</span>) &#123;  <br>            <span class="hljs-keyword">return</span> doGet(p.right, key);<span class="hljs-comment">//向右找  </span><br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            <span class="hljs-keyword">return</span> p.value;<span class="hljs-comment">//找到了就返回value  </span><br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 非递归实现get  </span><br><span class="hljs-comment">     * 尾递归的代码转换成非递归的实现非常简单，这样性能更好一些  </span><br><span class="hljs-comment">     * 比较java不支持尾递归自动优化，不妨都转换成循环的方式。  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">_get</span><span class="hljs-params">(K key)</span> &#123;  <br>        BSTNode&lt;K, V&gt; p = root;  <br>        <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> key.compareTo(p.key);  <br>            <span class="hljs-comment">/*  </span><br><span class="hljs-comment">            compareTo            -1 key &lt; node.key            0 key == node.key            1 key &gt; node.key             */</span>            <span class="hljs-keyword">if</span> (result &lt; <span class="hljs-number">0</span>) &#123;  <br>                p = p.left;  <br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result &gt; <span class="hljs-number">0</span>) &#123;  <br>                p = p.right;  <br>            &#125; <span class="hljs-keyword">else</span> &#123;  <br>                <span class="hljs-keyword">return</span> p.value;  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 查找最小关键字的值  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">min</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> doMin(root);  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 递归实现min  </span><br><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">doMin</span><span class="hljs-params">(BSTNode&lt;K, V&gt; node)</span> &#123;  <br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>        <span class="hljs-keyword">if</span> (node.left == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//最小节点  </span><br>            <span class="hljs-keyword">return</span> node.value;  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> doMin(node.left);  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 非递归实现min  </span><br><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">_doMin1</span><span class="hljs-params">(BSTNode node)</span> &#123;  <br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>        <span class="hljs-keyword">while</span> (node.left != <span class="hljs-literal">null</span>) &#123;  <br>            node = node.left;  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> node.value;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 查找最大关键字对应的值  </span><br><span class="hljs-comment">     * 最最小值类似，换找right即可，此处就省略了  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">max</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> _doMax(root);  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 非递归实现max  </span><br><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">_doMax</span><span class="hljs-params">(BSTNode&lt;K, V&gt; node)</span> &#123;  <br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>        <span class="hljs-keyword">while</span> (node.right != <span class="hljs-literal">null</span>) &#123;  <br>            node = node.right;  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> node.value;  <br>    &#125;  <br>  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 存储关键字和对应值  </span><br><span class="hljs-comment">     * 先比较，再判断是更新还是新增  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;  <br>        <span class="hljs-comment">//1.key存在，更新  </span><br>        <span class="hljs-comment">//2.key不存在，新增  </span><br>  <br>        <span class="hljs-comment">//get的实现拿过来  </span><br>        BSTNode&lt;K, V&gt; p = root;  <br>        BSTNode&lt;K, V&gt; parent = <span class="hljs-literal">null</span>;  <br>  <br>        <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span>) &#123;  <br>            parent = p;  <br>            <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> key.compareTo(p.key);  <br>            <span class="hljs-keyword">if</span> (result &lt; <span class="hljs-number">0</span>) &#123;  <br>                p = p.left;  <br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result &gt; <span class="hljs-number">0</span>) &#123;  <br>                p = p.right;  <br>            &#125; <span class="hljs-keyword">else</span> &#123;  <br>                <span class="hljs-comment">//找到了，更新  </span><br>                p.value = value;  <br>                <span class="hljs-keyword">return</span>;  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-comment">//没找到，新增  </span><br>        <span class="hljs-comment">//父节点就是parent，因为if、else if变成null之后parent就是目标父节点  </span><br>        <span class="hljs-keyword">if</span> (parent == <span class="hljs-literal">null</span>) &#123;  <br>            root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BSTNode</span>&lt;&gt;(key, value);  <br>        &#125;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">compareTo</span> <span class="hljs-operator">=</span> key.compareTo(parent.key);  <br>        <span class="hljs-keyword">if</span> (compareTo &lt; <span class="hljs-number">0</span>) &#123;  <br>            parent.left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BSTNode</span>&lt;&gt;(key, value);  <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (compareTo &gt; <span class="hljs-number">0</span>) &#123;  <br>            parent.right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BSTNode</span>&lt;&gt;(key, value);  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 查找关键字的前驱值（前任，比它小的里面最大的）  </span><br><span class="hljs-comment">     * 对二叉搜索树做一次中序遍历一下即可得到升序的结果，但这样不高效。  </span><br><span class="hljs-comment">     * &lt;p&gt;  </span><br><span class="hljs-comment">     * 而是要通过一下总结下来的规律得出的。  </span><br><span class="hljs-comment">     * 情况1：节点有左子树，此时前任就是左子树的最大值  </span><br><span class="hljs-comment">     * 情况2：节点没有左子树，若离它最近的、自左而来的祖先就是前任  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">predecessor</span><span class="hljs-params">(K key)</span> &#123;  <br>        BSTNode&lt;K, V&gt; p = root;  <br>        BSTNode&lt;K, V&gt; fromLeft = <span class="hljs-literal">null</span>;  <br>  <br>        <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> key.compareTo(p.key);  <br>            <span class="hljs-keyword">if</span> (result &lt; <span class="hljs-number">0</span>) &#123;  <br>                p = p.left;<span class="hljs-comment">//向左走，祖先自右而来  </span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result &gt; <span class="hljs-number">0</span>) &#123;  <br>                p = p.right;<span class="hljs-comment">//向右走，祖先自左而来  </span><br>                fromLeft = p;  <br>            &#125; <span class="hljs-keyword">else</span> &#123;  <br>                <span class="hljs-keyword">break</span>;  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-comment">//没找到节点  </span><br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>        &#125;  <br>        <span class="hljs-comment">//情况1  </span><br>        <span class="hljs-keyword">if</span> (p.left != <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-keyword">return</span> _doMax(p.left);<span class="hljs-comment">//左子树最大值  </span><br>        &#125;  <br>        <span class="hljs-comment">//情况2  </span><br>        <span class="hljs-keyword">return</span> fromLeft != <span class="hljs-literal">null</span> ? fromLeft.value : <span class="hljs-literal">null</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 查找关键字的后驱值（后任，比它大的里面最小的）  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">successor</span><span class="hljs-params">(K key)</span> &#123;  <br>        BSTNode&lt;K, V&gt; p = root;  <br>        BSTNode&lt;K, V&gt; fromRight = <span class="hljs-literal">null</span>;  <br>  <br>        <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> key.compareTo(p.key);  <br>            <span class="hljs-keyword">if</span> (result &lt; <span class="hljs-number">0</span>) &#123;  <br>                p = p.left;<span class="hljs-comment">//向左走，祖先自右而来  </span><br>                fromRight = p;  <br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result &gt; <span class="hljs-number">0</span>) &#123;  <br>                p = p.right;<span class="hljs-comment">//向右走，祖先自左而来  </span><br>            &#125; <span class="hljs-keyword">else</span> &#123;  <br>                <span class="hljs-keyword">break</span>;  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-comment">//没找到节点  </span><br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>        &#125;  <br>        <span class="hljs-comment">//情况1 节点有右子树，此时后任就是右子树的最小值  </span><br>        <span class="hljs-keyword">if</span> (p.right != <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-keyword">return</span> doMin(p.right);<span class="hljs-comment">//右子树最小值  </span><br>        &#125;  <br>        <span class="hljs-comment">//情况2 节点数没有右子树，若离它最近的、自右而来的祖先就是后任  </span><br>        <span class="hljs-keyword">return</span> fromRight != <span class="hljs-literal">null</span> ? fromRight.value : <span class="hljs-literal">null</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 根据关键字删除  </span><br><span class="hljs-comment">     * 核心概念：把被删除的节点的后继节点顶上去  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">delete</span><span class="hljs-params">(K key)</span> &#123;  <br>        BSTNode&lt;K, V&gt; p = root;  <br>        BSTNode&lt;K, V&gt; parent = <span class="hljs-literal">null</span>;  <br>        <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> key.compareTo(p.key);  <br>            <span class="hljs-keyword">if</span> (result &lt; <span class="hljs-number">0</span>) &#123;  <br>                parent = p;  <br>                p = p.left;<span class="hljs-comment">//向左走，祖先自右而来  </span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result &gt; <span class="hljs-number">0</span>) &#123;  <br>                parent = p;  <br>                p = p.right;<span class="hljs-comment">//向右走，祖先自左而来  </span><br>            &#125; <span class="hljs-keyword">else</span> &#123;  <br>                <span class="hljs-keyword">break</span>;  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>        <span class="hljs-comment">//删除操作  </span><br>        <span class="hljs-keyword">if</span> (p.left == <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-comment">//删除情况1(含情况3，走1,2都可以)  </span><br>            shift(parent, p, p.right);  <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p.right == <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-comment">//删除情况2  </span><br>            shift(parent, p, p.left);  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            <span class="hljs-comment">//删除情况4  </span><br>            <span class="hljs-comment">//4.1被删除节点找后继  </span><br>            BSTNode&lt;K, V&gt; s = p.right;  <br>            BSTNode&lt;K, V&gt; sPrent = p;<span class="hljs-comment">//后继父亲  </span><br>            <span class="hljs-keyword">while</span> (s.left != <span class="hljs-literal">null</span>) &#123;  <br>                sPrent = s;  <br>                s = s.left;  <br>            &#125;<span class="hljs-comment">//s就是后继节点  </span><br>            <span class="hljs-comment">//4.2删除节点与后继节点不相邻处理后继的后事  </span><br>            <span class="hljs-keyword">if</span> (sPrent != p) &#123;<span class="hljs-comment">//不相邻  </span><br>                shift(sPrent, s, s.right);<span class="hljs-comment">//不可能有左孩子  </span><br>                s.right = p.right;<span class="hljs-comment">//顶上去的右  </span><br>            &#125;  <br>            <span class="hljs-comment">//4.3后继取代被删除节点  </span><br>            shift(parent, p, s);  <br>            s.left = p.left;<span class="hljs-comment">//顶上去的左  </span><br>        &#125;  <br>        <span class="hljs-keyword">return</span> p.value;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 托孤方法 shift  </span><br><span class="hljs-comment">     *     * <span class="hljs-doctag">@param</span> parent  被删除节点的父节点  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> deleted 被删除到节点  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> child   被顶上去的节点  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shift</span><span class="hljs-params">(BSTNode&lt;K, V&gt; parent, BSTNode&lt;K, V&gt; deleted, BSTNode&lt;K, V&gt; child)</span> &#123;  <br>        <span class="hljs-keyword">if</span> (parent == <span class="hljs-literal">null</span>) &#123;  <br>            root = child;  <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (deleted == parent.left) &#123;  <br>            parent.left = child;  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            parent.right = child;  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>data&amp;algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉搜索树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构和算法之旅（七）- 二叉树</title>
    <link href="/posts/d9d84fdb/"/>
    <url>/posts/d9d84fdb/</url>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p class="note note-light">树中每个节点最多俩个子节点，不同于完全二叉树，不需要每层都满。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309211458897.png"></p><p class="note note-secondary">这种数据结构表示方式有俩种：<br>一种是TreeNode。<br>一种是数组。</p><h3 id="TreeNode"><a href="#TreeNode" class="headerlink" title="TreeNode"></a>TreeNode</h3><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309211459204.png"></p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309211459847.png"></p><h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309211500904.png"></p><p class="note note-secondary">层序遍历即是广度优先遍历，需要配合队列实现。<br>注：<br>以队列来层序遍历时针对TreeNode这种方式表示的二叉树。<br>如果用数组形式实现二叉树，则直接遍历数组即可，自然为层序遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.datastructure.treetraversal;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 递归方式遍历二叉树，前序、中序、后序</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeTraversal</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         *         1</span><br><span class="hljs-comment">         *       /  \</span><br><span class="hljs-comment">         *      2    3</span><br><span class="hljs-comment">         *    /     /\</span><br><span class="hljs-comment">         *   4      5  6</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         */</span><br><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<br>                        <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">4</span>), <span class="hljs-number">2</span>, <span class="hljs-literal">null</span>), <span class="hljs-number">1</span>,<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">5</span>), <span class="hljs-number">3</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">6</span>)<br>                )<br>        );<br><br>        System.out.println(<span class="hljs-string">&quot;前序遍历：&quot;</span>);<br>        preOrder(root);<br>        System.out.println(<span class="hljs-string">&quot;\n中序遍历：&quot;</span>);<br>        inOrder(root);<br>        System.out.println(<span class="hljs-string">&quot;\n后序遍历：&quot;</span>);<br>        postOrder(root);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 前序遍历</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preOrder</span><span class="hljs-params">(TreeNode node)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        System.out.print(node.val + <span class="hljs-string">&quot;\t&quot;</span>);<br>        preOrder(node.left);<br>        preOrder(node.right);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 中序遍历</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inOrder</span><span class="hljs-params">(TreeNode node)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        inOrder(node.left);<br>        System.out.print(node.val + <span class="hljs-string">&quot;\t&quot;</span>);<br>        inOrder(node.right);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 后序遍历</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postOrder</span><span class="hljs-params">(TreeNode node)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        postOrder(node.left);<br>        postOrder(node.right);<br>        System.out.print(node.val + <span class="hljs-string">&quot;\t&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>data&amp;algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
      <tag>广度优先遍历</tag>
      
      <tag>深度优先遍历</tag>
      
      <tag>前序</tag>
      
      <tag>中序</tag>
      
      <tag>后序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构和算法之旅（六）- 堆</title>
    <link href="/posts/88ba86b6/"/>
    <url>/posts/88ba86b6/</url>
    
    <content type="html"><![CDATA[<p class="note note-light">在了解优先级队列中，接触过堆的概念，了解了堆的特性以及如何使用，这里看如何建立一个堆。</p><h2 id="大顶堆"><a href="#大顶堆" class="headerlink" title="大顶堆"></a>大顶堆</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.datastructure;<br><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 大顶堆</span><br><span class="hljs-comment"> * heapify建堆，使用弗洛伊德算符，时间复杂度O(n)</span><br><span class="hljs-comment"> * 1.找到最后一个非叶子节点</span><br><span class="hljs-comment"> * 2.从最后一个非叶子节点开始，依次下沉</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * heapify、down、up这是三个核心方法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MaxHeap</span> &#123;<br>    <span class="hljs-type">int</span>[] array;<br>    <span class="hljs-type">int</span> size;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MaxHeap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array)</span> &#123;<br>        <span class="hljs-built_in">this</span>.array = array;<br>        <span class="hljs-built_in">this</span>.size = array.length;<br>        heapify();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 建堆</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">heapify</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//如何找到最后一个非叶子节点    size/2-1</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> size / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            down(i);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除堆顶元素</span><br><span class="hljs-comment">     * 直接从索引0位置移除效率不高，所以先将它最后一个元素交换，</span><br><span class="hljs-comment">     * 尾部移除，size-1就可以了，但可能导致不满足大顶堆特性，</span><br><span class="hljs-comment">     * 需要做一次下潜</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">poll</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">top</span> <span class="hljs-operator">=</span> array[<span class="hljs-number">0</span>];<br>        swap(<span class="hljs-number">0</span>, size - <span class="hljs-number">1</span>);<br>        size--;<br>        down(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> top;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除指定索引处元素</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">poll</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">deleted</span> <span class="hljs-operator">=</span> array[index];<br>        swap(index, size - <span class="hljs-number">1</span>);<br>        size--;<br>        down(index);<br>        <span class="hljs-keyword">return</span> deleted;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 替换堆顶元素</span><br><span class="hljs-comment">     * 替换后可能不满足大顶堆特性，需要做一次下潜</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">replace</span><span class="hljs-params">(<span class="hljs-type">int</span> replaced)</span> &#123;<br>        array[<span class="hljs-number">0</span>] = replaced;<br>        down(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取堆顶元素</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> array[<span class="hljs-number">0</span>];<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 向堆的尾部添加元素</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(<span class="hljs-type">int</span> offered)</span> &#123;<br>        <span class="hljs-keyword">if</span> (size == array.length) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        up(offered);<br>        size++;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将inserted元素上浮：直至offered小于父元素或到堆顶</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">up</span><span class="hljs-params">(<span class="hljs-type">int</span> offered)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">child</span> <span class="hljs-operator">=</span> size;<br>        <span class="hljs-keyword">while</span> (child &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> (child - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<span class="hljs-comment">//父节点 公式</span><br>            <span class="hljs-keyword">if</span> (array[parent] &gt;= offered)<br>                array[child] = array[parent];<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">break</span>;<br>            child = parent;<br>        &#125;<br>        array[child] = offered;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将parent索引处元素下沉：与俩个孩子较大者交换，直至没孩子或孩子没它大</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">down</span><span class="hljs-params">(<span class="hljs-type">int</span> parent)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> parent * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<span class="hljs-comment">//左孩子 公式</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> left + <span class="hljs-number">1</span>;<span class="hljs-comment">//右孩子 公式</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> parent;<br>        <span class="hljs-keyword">if</span> (left &lt; size &amp;&amp; array[left] &gt; array[max]) max = left;<br>        <span class="hljs-keyword">if</span> (right &lt; size &amp;&amp; array[right] &gt; array[max]) max = right;<br>        <span class="hljs-keyword">if</span> (max != parent) &#123;<span class="hljs-comment">//如果孩子比父亲大，就交换</span><br>            swap(max, parent);<br>            down(max);<span class="hljs-comment">//递归</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 交换俩个索引处元素</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> array[i];<br>        array[i] = array[j];<br>        array[j] = t;<br>    &#125;<br><br><br>    <span class="hljs-comment">//test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] array = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125;;<br>        <span class="hljs-type">MaxHeap</span> <span class="hljs-variable">maxHeap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MaxHeap</span>(array);<br>        System.out.println(Arrays.toString(maxHeap.array));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309211454884.png"></p>]]></content>
    
    
    <categories>
      
      <category>data&amp;algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>堆</tag>
      
      <tag>大顶堆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构和算法之旅（五）- 栈</title>
    <link href="/posts/a110ea6d/"/>
    <url>/posts/a110ea6d/</url>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p class="note note-primary">栈是一种线性数据结构，只能在其一端添加数据和移除数据。习惯来说，这一端称为栈顶，另一端不能操作数据的称为栈底，就如同生活中的一摞书籍。<br>还是老样子，看一下用不同方式实现栈。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*先定义一个Stack接口*/</span><br><span class="hljs-keyword">package</span> org.example.datastructure;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Stack</span>&lt;E&gt; &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 向栈顶压入元素</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 待压入元素</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 压入成功返回true，否则返回false</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">push</span><span class="hljs-params">(E value)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从栈顶弹出元素</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 栈非空返回栈顶元素，否则返回null</span><br><span class="hljs-comment">     */</span><br>    E <span class="hljs-title function_">pop</span><span class="hljs-params">()</span>;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回栈顶元素，但不弹出</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 栈非空返回栈顶元素，否则返回null</span><br><span class="hljs-comment">     */</span><br>    E <span class="hljs-title function_">peek</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断栈是否为空</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 空返回true，否则返回false</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断栈是否已满</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 已满返回true，否则返回false</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="链表实现"><a href="#链表实现" class="headerlink" title="链表实现"></a>链表实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.datastructure;<br><br><span class="hljs-keyword">import</span> java.util.Iterator;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 链表实现栈</span><br><span class="hljs-comment"> * 含哨兵单向链表</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedListStack</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Stack</span>&lt;E&gt;, Iterable&lt;E&gt; &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;E&gt; &#123;<br>        E value;<br>        Node&lt;E&gt; next;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(E value, Node&lt;E&gt; next)</span> &#123;<br>            <span class="hljs-built_in">this</span>.value = value;<br>            <span class="hljs-built_in">this</span>.next = next;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capacity;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 哨兵节点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Node&lt;E&gt; head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedListStack</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * head -&gt; 1 -&gt; null</span><br><span class="hljs-comment">     * head -&gt; 2 -&gt; 1 -&gt; null</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">push</span><span class="hljs-params">(E value)</span> &#123;<br>        <span class="hljs-keyword">if</span> (isFull()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">//        Node&lt;E&gt; added = new Node&lt;&gt;(value, head.next);</span><br><span class="hljs-comment">//        head.next = added;</span><br>        head.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(value, head.next);<br>        size++;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        Node&lt;E&gt; first = head.next;<span class="hljs-comment">//找到第一个节点</span><br>        head.next = first.next;<span class="hljs-comment">//跳过(删除)第一个节点</span><br>        size--;<br>        <span class="hljs-keyword">return</span> first.value;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        Node&lt;E&gt; first = head.next;<span class="hljs-comment">//找到第一个节点</span><br>        <span class="hljs-keyword">return</span> first.value;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//        return head.next == null;</span><br>        <span class="hljs-keyword">return</span> size == <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> size == capacity;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Iterator&lt;E&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt;() &#123;<br>            Node&lt;E&gt; p = head.next;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> p != <span class="hljs-literal">null</span>;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> E <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-type">E</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> p.value;<br>                p = p.next;<br>                <span class="hljs-keyword">return</span> value;<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="数组实现"><a href="#数组实现" class="headerlink" title="数组实现"></a>数组实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.datastructure;<br><br><span class="hljs-keyword">import</span> java.util.Iterator;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayStack</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Stack</span>&lt;E&gt;, Iterable&lt;E&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> E[] array;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> top;<span class="hljs-comment">//栈顶指针</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 底            顶</span><br><span class="hljs-comment">     * 0  1  2  3  4</span><br><span class="hljs-comment">     * 因为右边数组更好操作，与链表是反方向的</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-meta">@SuppressWarnings(&quot;all&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayStack</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.array = (E[]) <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[capacity];<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">push</span><span class="hljs-params">(E value)</span> &#123;<br>        <span class="hljs-keyword">if</span> (isFull()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        array[top++] = value;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> array[--top];<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> array[top - <span class="hljs-number">1</span>];<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> top == <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> top == array.length;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Iterator&lt;E&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt;() &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> top;<span class="hljs-comment">//指向栈顶，从右往左遍历</span><br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> p &gt; <span class="hljs-number">0</span>;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> E <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> array[--p];<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="有效括号"><a href="#有效括号" class="headerlink" title="有效括号"></a>有效括号</h2><p class="note note-secondary">这个很简单：<br>遇到左括号，把要配对的右括号压入栈。<br>遇到右括号，把它与栈顶元素比对。<br>- 若相等，栈顶元素弹出，继续比对下一组。<br>- 若不等，无效括号直接返回false。<br></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309202202374.png"></p><h2 id="逆波兰表达式"><a href="#逆波兰表达式" class="headerlink" title="逆波兰表达式"></a>逆波兰表达式</h2><p class="note note-secondary">1 + 2 ，这是中缀表达式。<br>1 2 +，这是后缀表达式。<br>后缀表达式交给计算机计算非常方便，因为从左向右计算，且不需要考虑优先级，优先级就是从左到右给定的顺序。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309202204129.png"></p><p class="note note-primary">解题思路：<br>遇到数字就放入栈，如果遇到运算符就从栈中取出前俩个元素计算，计算结果再压入栈，栈中剩余的一个元素就是运算结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">evalRPN</span><span class="hljs-params">(String[] tokens)</span> &#123;<br>        LinkedList&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (String t : tokens) &#123;<br>            <span class="hljs-keyword">switch</span> (t) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;+&quot;</span> -&gt; &#123;<br>                    <span class="hljs-type">Integer</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> stack.pop();<br>                    <span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> stack.pop();<br>                    stack.push(a + b);<br>                &#125;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;-&quot;</span> -&gt; &#123;<br>                    <span class="hljs-type">Integer</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> stack.pop();<br>                    <span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> stack.pop();<br>                    stack.push(a - b);<br>                &#125;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;*&quot;</span> -&gt; &#123;<br>                    <span class="hljs-type">Integer</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> stack.pop();<br>                    <span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> stack.pop();<br>                    stack.push(a * b);<br>                &#125;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/&quot;</span> -&gt; &#123;<br>                    <span class="hljs-type">Integer</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> stack.pop();<br>                    <span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> stack.pop();<br>                    stack.push(a / b);<br>                &#125;<br>                <span class="hljs-keyword">default</span> -&gt; &#123;<span class="hljs-comment">//数字</span><br>                    stack.push(Integer.parseInt(t));<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stack.pop();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>data&amp;algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
      <tag>有效括号</tag>
      
      <tag>逆波兰表达式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构和算法之旅（四）- 队列</title>
    <link href="/posts/18ca4eee/"/>
    <url>/posts/18ca4eee/</url>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p class="note note-primary">计算机科学中，queue是以顺序的方式维护一组数据集合，在一端添加数据，从另一个端移除数据。习惯来说，添加的一端称为尾，移除的一端称为头，就如同生活中排队购买商品。</p><h2 id="链表实现队列"><a href="#链表实现队列" class="headerlink" title="链表实现队列"></a>链表实现队列</h2><p class="note note-secondary">下面以单向环形含哨兵链表方式来实现队列。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309202026177.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//首先定义队列的接口</span><br><span class="hljs-keyword">package</span> org.example.datastructure;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 队列</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Queue</span>&lt;E&gt; &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 向队列尾部添加一个元素</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> val 待插入值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 插入成功返回true，否则返回false</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E val)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从队列头部取出一个元素，并移除</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 如果队列非空，返回队列头部元素，否则返回null</span><br><span class="hljs-comment">     */</span><br>    E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从队列头部取出一个元素，但不移除</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 如果队列非空，返回队列头部元素，否则返回null</span><br><span class="hljs-comment">     */</span><br>    E <span class="hljs-title function_">peek</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断队列是否为空</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 空返回true，否则返回false</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span>;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断队列是否已满</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 已满返回true，否则返回false</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.datastructure;<br><br><span class="hljs-keyword">import</span> java.util.Iterator;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 基于单向环形链表实现的队列</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * 队列只需要操作头，尾部不需要操作，所以只需要一个指针即可</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &lt;E&gt;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedListQueue</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Queue</span>&lt;E&gt;, Iterable&lt;E&gt; &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 节点类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;E&gt; &#123;<br>        E value;<br>        Node&lt;E&gt; next;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(E value, Node&lt;E&gt; next)</span> &#123;<br>            <span class="hljs-built_in">this</span>.value = value;<br>            <span class="hljs-built_in">this</span>.next = next;<br>        &#125;<br>    &#125;<br><br>    Node&lt;E&gt; head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>    Node&lt;E&gt; tail = head;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<span class="hljs-comment">// 节点数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">capacity</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<span class="hljs-comment">// 队列容量</span><br><br>    &#123;<br>    <span class="hljs-comment">//构成环</span><br>        tail.next = head;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedListQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedListQueue</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E val)</span> &#123;<br>        <span class="hljs-keyword">if</span> (isFull()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        Node&lt;E&gt; added = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(val, head);<br>        tail.next = added;<br>        tail = added;<span class="hljs-comment">//让新节点作为新的tail</span><br>        size++;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        Node&lt;E&gt; first = head.next;<br>        head.next = first.next;<br>        <span class="hljs-keyword">if</span> (first == tail) tail = head;<br>        size--;<br>        <span class="hljs-keyword">return</span> first.value;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> head.next.value;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> head == tail;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> size == capacity;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Iterator&lt;E&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt;() &#123;<br>            Node&lt;E&gt; p = head.next;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> p != head;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> E <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-type">E</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> p.value;<br>                p = p.next;<br>                <span class="hljs-keyword">return</span> value;<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="环形数组实现队列"><a href="#环形数组实现队列" class="headerlink" title="环形数组实现队列"></a>环形数组实现队列</h2><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309202148425.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309202148648.png"></p><p class="note note-secondary">判断头指针和尾指针是否指向同一个就是判空。<br>当尾指针+1等于头指针就是判断满，(tail+1)%5 == head。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.datastructure;<br><br><span class="hljs-keyword">import</span> java.util.Iterator;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayQueue1</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Queue</span>&lt;E&gt;, Iterable&lt;E&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> E[] array;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> head;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> tail;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capacity;<br><br>    <span class="hljs-meta">@SuppressWarnings(&quot;all&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayQueue1</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        array = (E[]) <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-built_in">this</span>.capacity + <span class="hljs-number">1</span>];<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E val)</span> &#123;<br>        <span class="hljs-keyword">if</span> (isFull()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        array[tail] = val;<br>        tail = (tail + <span class="hljs-number">1</span>) % array.length;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">E</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> array[head];<br>        head = (head + <span class="hljs-number">1</span>) % array.length;<br>        <span class="hljs-keyword">return</span> val;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> array[head];<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> head == tail;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> (tail + <span class="hljs-number">1</span>) % array.length == head;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Iterator&lt;E&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt;() &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> head;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> p != tail;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> E <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-type">E</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> array[p];<br>                p = (p + <span class="hljs-number">1</span>) % array.length;<br>                <span class="hljs-keyword">return</span> e;<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h2><p class="note note-primary">双端队列特点：俩端都可以添加、删除</p><h3 id="基于双向环形链表实现"><a href="#基于双向环形链表实现" class="headerlink" title="基于双向环形链表实现"></a>基于双向环形链表实现</h3><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309210856606.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.datastructure;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 双端队列</span><br><span class="hljs-comment"> * 两端都可以操作添加和删除</span><br><span class="hljs-comment"> * queue 普通队列</span><br><span class="hljs-comment"> * deque 双端队列   double-ended queue</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Deque</span>&lt;E&gt; &#123;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 向头部添加元素</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> e 待添加元素</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 添加成功返回true</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">offerFirst</span><span class="hljs-params">(E e)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 向尾部添加元素</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> e 待添加元素</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 添加成功返回true</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">offerLast</span><span class="hljs-params">(E e)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从队列头部删除元素</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 头部元素</span><br><span class="hljs-comment">     */</span><br>    E <span class="hljs-title function_">pollFirst</span><span class="hljs-params">()</span>;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从尾部获取元素并删除</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 尾部元素</span><br><span class="hljs-comment">     */</span><br>    E <span class="hljs-title function_">pollLast</span><span class="hljs-params">()</span>;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从头部获取元素但不删除</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 头部元素</span><br><span class="hljs-comment">     */</span><br>    E <span class="hljs-title function_">peekFirst</span><span class="hljs-params">()</span>;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从尾部获取元素但不删除</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 尾部元素</span><br><span class="hljs-comment">     */</span><br>    E <span class="hljs-title function_">peekLast</span><span class="hljs-params">()</span>;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 队列是否为空</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 空返回true, 否则返回false</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 队列是否已满</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 满返回true, 否则返回false</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.datastructure;<br><br><span class="hljs-keyword">import</span> java.util.Iterator;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 基于双向环形链表实现的双端队列</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * 注：双向和双端是两个概念，</span><br><span class="hljs-comment"> * 双向是指链表节点有两个指针，一个指向前一个节点，一个指向后一个节点；</span><br><span class="hljs-comment"> * 双端是指队列两端都可以操作添加和删除。</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * 为什么要用双向链表？</span><br><span class="hljs-comment"> * 因为双端队列需要操作尾端，所以需要尾指针，而单向链表只有头指针，所以需要双向链表。</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * 为什么要用环形链表？</span><br><span class="hljs-comment"> * 因为环形链表可以用一个哨兵，即充当头指针又充当尾指针，这样就可以省去一个指针。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedListDeque</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Deque</span>&lt;E&gt;, Iterable&lt;E&gt; &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;E&gt; &#123;<br>        Node&lt;E&gt; prev;<br>        E value;<br>        Node&lt;E&gt; next;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(Node&lt;E&gt; prev, E value, Node&lt;E&gt; next)</span> &#123;<br>            <span class="hljs-built_in">this</span>.prev = prev;<br>            <span class="hljs-built_in">this</span>.value = value;<br>            <span class="hljs-built_in">this</span>.next = next;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">capacity</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>    <span class="hljs-type">int</span> size;<br>    Node&lt;E&gt; sentinel = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<span class="hljs-comment">//哨兵</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedListDeque</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>        <span class="hljs-comment">//初始化哨兵</span><br>        sentinel.prev = sentinel;<br>        sentinel.next = sentinel;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * a added b</span><br><span class="hljs-comment">     * 向头部添加</span><br><span class="hljs-comment">     * a就是哨兵，b就是哨兵的next</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offerFirst</span><span class="hljs-params">(E e)</span> &#123;<br>        <span class="hljs-keyword">if</span> (isFull()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        Node&lt;E&gt; a = sentinel;<br>        Node&lt;E&gt; b = sentinel.next;<br>        Node&lt;E&gt; added = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(a, e, b);<br>        a.next = added;<br>        b.prev = added;<br>        size++;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * a added b</span><br><span class="hljs-comment">     * 向尾部添加</span><br><span class="hljs-comment">     * b就是哨兵，a就是哨兵的prev</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offerLast</span><span class="hljs-params">(E e)</span> &#123;<br>        <span class="hljs-keyword">if</span> (isFull()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        Node&lt;E&gt; a = sentinel.prev;<br>        Node&lt;E&gt; b = sentinel;<br>        Node&lt;E&gt; added = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(a, e, b);<br>        a.next = added;<br>        b.prev = added;<br>        size++;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * a removed b</span><br><span class="hljs-comment">     * 移除头部</span><br><span class="hljs-comment">     * a就是哨兵，b就是哨兵的next</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">pollFirst</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        Node&lt;E&gt; a = sentinel;<br>        Node&lt;E&gt; removed = sentinel.next;<br>        Node&lt;E&gt; b = removed.next;<br>        a.next = b;<br>        b.prev = a;<br>        size--;<br>        <span class="hljs-keyword">return</span> removed.value;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * a removed b</span><br><span class="hljs-comment">     * 移除尾部</span><br><span class="hljs-comment">     * b就是哨兵，a就是哨兵的prev</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">pollLast</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        Node&lt;E&gt; b = sentinel;<br>        Node&lt;E&gt; removed = sentinel.prev;<br>        Node&lt;E&gt; a = removed.prev;<br>        a.next = b;<br>        b.prev = a;<br>        size--;<br>        <span class="hljs-keyword">return</span> removed.value;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">peekFirst</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> sentinel.next.value;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">peekLast</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> sentinel.prev.value;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> size == <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> size == capacity;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Iterator&lt;E&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt;() &#123;<br>            Node&lt;E&gt; p = sentinel.next;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> p != sentinel;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> E <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-type">E</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> p.value;<br>                p = p.next;<br>                <span class="hljs-keyword">return</span> value;<br>            &#125;<br>        &#125;;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="基于数组实现"><a href="#基于数组实现" class="headerlink" title="基于数组实现"></a>基于数组实现</h3><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309210857074.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.datastructure;<br><br><span class="hljs-keyword">import</span> java.util.Iterator;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 基于循环数组实现的双端队列</span><br><span class="hljs-comment"> * 循环数组动的是头尾指针，不动的是数组元素</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * tail 停下来的位置不存储，会浪费一个位置</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * h - head</span><br><span class="hljs-comment"> * tail - tail</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * h</span><br><span class="hljs-comment"> * t</span><br><span class="hljs-comment"> * 0  1  2  3</span><br><span class="hljs-comment"> * a  b     c</span><br><span class="hljs-comment"> * offerLast(a)     先添加元素 tail++</span><br><span class="hljs-comment"> * offerLast(b)</span><br><span class="hljs-comment"> * offerFirst(c)    先head-- 再添加元素</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * pollFirst()      先取元素 head++</span><br><span class="hljs-comment"> * pollLast()       先tail-- 再取元素</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * head==tail 空</span><br><span class="hljs-comment"> * head~tail == 数组长度-1 满</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayDeque1</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Deque</span>&lt;E&gt;, Iterable&lt;E&gt; &#123;<br><br>    E[] array;<br>    <span class="hljs-type">int</span> head;<br>    <span class="hljs-type">int</span> tail;<br><br>    <span class="hljs-meta">@SuppressWarnings(&quot;all&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayDeque1</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        array = (E[]) <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[capacity + <span class="hljs-number">1</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">inc</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> length)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &gt;= length)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dec</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> length)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i - <span class="hljs-number">1</span> &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> i - <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offerFirst</span><span class="hljs-params">(E e)</span> &#123;<br>        <span class="hljs-keyword">if</span> (isFull()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        head = dec(head, array.length);<br>        array[head] = e;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offerLast</span><span class="hljs-params">(E e)</span> &#123;<br>        <span class="hljs-keyword">if</span> (isFull()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        array[tail] = e;<br>        tail = inc(tail, array.length);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">pollFirst</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">E</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> array[head];<br>        array[head] = <span class="hljs-literal">null</span>;<span class="hljs-comment">//help gc</span><br>        head = inc(head, array.length);<br>        <span class="hljs-keyword">return</span> e;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">pollLast</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        tail = dec(tail, array.length);<br>        <span class="hljs-type">E</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> array[tail];<br>        array[tail] = <span class="hljs-literal">null</span>;<span class="hljs-comment">//help gc</span><br>        <span class="hljs-keyword">return</span> e;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">peekFirst</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> array[head];<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">peekLast</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> array[dec(tail, array.length)];<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> head == tail;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (tail &gt; head) &#123;<br>            <span class="hljs-keyword">return</span> tail - head == array.length - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tail &lt; head) &#123;<br>            <span class="hljs-keyword">return</span> head - tail == <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Iterator&lt;E&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt;() &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> head;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> p != tail;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> E <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-type">E</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> array[p];<br>                p = inc(p, array.length);<br>                <span class="hljs-keyword">return</span> e;<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h2><p class="note note-primary">优先级队列特点：一端进，另一端出，但出的时候按照优先级出！</p><h3 id="基于无序数组实现"><a href="#基于无序数组实现" class="headerlink" title="基于无序数组实现"></a>基于无序数组实现</h3><p class="note note-success">无序数组实现的优势：<br>入队就直接加入对尾。<br>出队就遍历找到最大值，并删除，然后把后续的往前顺延。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> priorityqueue;  <br>  <br><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * 队列接口</span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Queue</span>&lt;E&gt; &#123;  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 向队列尾部添加一个元素  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> val 待插入值  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 插入成功返回true，否则返回false  </span><br><span class="hljs-comment">     */</span>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E val)</span>;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 从队列头部取出一个元素，并移除  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 如果队列非空，返回队列头部元素，否则返回null  </span><br><span class="hljs-comment">     */</span>    E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span>;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 从队列头部取出一个元素，但不移除  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 如果队列非空，返回队列头部元素，否则返回null  </span><br><span class="hljs-comment">     */</span>    E <span class="hljs-title function_">peek</span><span class="hljs-params">()</span>;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 判断队列是否为空  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 空返回true，否则返回false  </span><br><span class="hljs-comment">     */</span>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span>;  <br>  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 判断队列是否已满  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 已满返回true，否则返回false  </span><br><span class="hljs-comment">     */</span>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> priorityqueue;  <br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 优先级接口</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Priority</span> &#123;  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 返回对象的优先级，约定数字越大，优先级越高  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-type">int</span> <span class="hljs-title function_">priority</span><span class="hljs-params">()</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> priorityqueue;  <br>  <br><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * 基于无序数组实现  </span><br><span class="hljs-comment"> * 入队：把元素加到数组末尾  </span><br><span class="hljs-comment"> * 出队：找到最大优先级元素，删除，相当于进行了一次选择排序  </span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PriorityQueue</span>&lt;E <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Priority</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Queue</span>&lt;E&gt; &#123;  <br>  <br>    Priority[] array;  <br>    <span class="hljs-type">int</span> size;  <br>  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PriorityQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;  <br>        array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Priority</span>[capacity];  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//O(1)  </span><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e)</span> &#123;  <br>        <span class="hljs-keyword">if</span> (isFull()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>        array[size++] = e;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//返回优先级最高的索引值  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">selectMax</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;  <br>            <span class="hljs-keyword">if</span> (array[i].priority() &gt; array[max].priority()) &#123;  <br>                max = i;  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> max;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;  <br>        <span class="hljs-keyword">if</span> (index &lt; size - <span class="hljs-number">1</span>) &#123;  <br>            <span class="hljs-comment">//移动  </span><br>            System.arraycopy(array, index + <span class="hljs-number">1</span>, array, index, size - <span class="hljs-number">1</span> - index);  <br>        &#125;  <br>        array[--size]=<span class="hljs-literal">null</span>;<span class="hljs-comment">//help GC </span><br>    &#125;  <br>  <br>    <span class="hljs-comment">//O(n)  </span><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">if</span> (isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> selectMax();  <br>        <span class="hljs-type">E</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> (E) array[max];  <br>        remove(max);  <br>        <span class="hljs-keyword">return</span> e;  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">if</span> (isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> selectMax();  <br>        <span class="hljs-keyword">return</span> (E) array[max];  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> size == <span class="hljs-number">0</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> size == array.length;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="基于有序数组实现"><a href="#基于有序数组实现" class="headerlink" title="基于有序数组实现"></a>基于有序数组实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> priorityqueue;  <br>  <br><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * 基于有序数组实现  </span><br><span class="hljs-comment"> * 优先级最高的在队尾，优点是出队操作变的简单，直接size--就行。  </span><br><span class="hljs-comment"> * 缺点是，入队操作需要做一次排序，插入到正确位置。相当于一次插入排序。  </span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PriorityQueue2</span>&lt;E <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Priority</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Queue</span>&lt;E&gt; &#123;  <br>  <br>    Priority[] array;  <br>    <span class="hljs-type">int</span> size;  <br>  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PriorityQueue2</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;  <br>        array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Priority</span>[capacity];  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//O(n)  </span><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e)</span> &#123;  <br>        <span class="hljs-keyword">if</span> (isFull()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br><span class="hljs-comment">//        array[size++] = e;  </span><br>        insert(e);  <br>        size++;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 插入排序  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(E e)</span> &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> size - <span class="hljs-number">1</span>;  <br>        <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; array[i].priority() &gt; e.priority()) &#123;  <br>            array[i + <span class="hljs-number">1</span>] = array[i];  <br>            i--;  <br>        &#125;  <br>        array[i + <span class="hljs-number">1</span>] = e;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//O(1)  </span><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">if</span> (isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br><span class="hljs-comment">//        int max = selectMax();  </span><br><span class="hljs-comment">//        E e = (E) array[max];  </span><br><span class="hljs-comment">//        remove(max);  </span><br>        <span class="hljs-type">E</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> (E) array[size - <span class="hljs-number">1</span>];  <br>        array[--size] = <span class="hljs-literal">null</span>;<span class="hljs-comment">//help GC  </span><br>        <span class="hljs-keyword">return</span> e;  <br>    &#125;  <br><span class="hljs-comment">//O(1)  </span><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">if</span> (isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br><span class="hljs-comment">//        int max = selectMax();  </span><br><span class="hljs-comment">//        return (E) array[max];  </span><br>        <span class="hljs-keyword">return</span> (E) array[size - <span class="hljs-number">1</span>];  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> size == <span class="hljs-number">0</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> size == array.length;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-primary">基于无序和基于有序数组实现俩种的差别在于：<br>无序：入队O(1)，出队O(n)<br>有序：入队O(n)，出队O(1)<br><br>BUT，这俩种都不是最优的实现方式，接下来看看更优解。</p><h3 id="基于堆实现"><a href="#基于堆实现" class="headerlink" title="基于堆实现"></a>基于堆实现</h3><blockquote><p>堆是一种基于树的数据结构，通常用完全二叉树实现。堆的特性如下：</p><ul><li>在大顶堆中，任意节点C与它的父节点P符合P.value &gt;&#x3D; C.value。</li><li>在小顶堆中，任意节点C与它的父节点P符合P.vlaue &lt;&#x3D; C.value。</li><li>最顶层节点(没有父亲)称之为root根节点。</li></ul></blockquote><blockquote><p>二叉树，简单理解就是一个节点最多有俩个子节点。</p></blockquote><blockquote><p>完全二叉树，就是说树的每一层除了最后一层都是填满的（都是俩个子节点）。<br>另外，向完全二叉树加入节点时，必须从左开始添加。</p></blockquote><p class="note note-info">它是非线性的数据结构，但是存储的时候可以使用线性的数组结构存储。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309210937016.png"></p><p class="note note-primary">这种数据结构具备一些特征，前辈总结了一些规律公式，可以在已知父节点的时候快速找到子节点，或者已知子节点的时候快速找到父节点。<br>堆存在数组中有俩种方式，一种是从索引0直接存根，另一种是索引0空着从1开始存根节点。<br>- 如果从索引0开始存储节点数据<br>    1. 节点 i 的父节点为 (i-1)/2，当i>0时。<br>    2. 节点 i 的左子节点为 2i+1 ，右子节点为 2i+2，当然它们得小于size。<br>- 如果从索引1开始存储节点数据<br>    1. 节点i的父节点为 i/2 ，当 i>1 时。<br>    2. 节点 i 的左子节点为 2i ，右子节点为 2i+1 ，同样得小于size。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309210948549.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> priorityqueue;  <br>  <br><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * 基于大顶堆实现  </span><br><span class="hljs-comment"> * &lt;p&gt;  </span><br><span class="hljs-comment"> * 入队  </span><br><span class="hljs-comment"> * 1.入堆新元素，加入到数组末尾  </span><br><span class="hljs-comment"> * 2.不断比较新元素与它父节点优先级  </span><br><span class="hljs-comment"> * （上浮）  </span><br><span class="hljs-comment"> * - 如果父节点优先级低，则向下移动，并找到下一个parent  </span><br><span class="hljs-comment"> * - 直至父节点优先级更高或child==0为止。  </span><br><span class="hljs-comment"> * &lt;p&gt;  </span><br><span class="hljs-comment"> * 出队  </span><br><span class="hljs-comment"> * 1.交换堆顶和尾部元素，让尾部出队  </span><br><span class="hljs-comment"> * 2.（下潜）  </span><br><span class="hljs-comment"> * - 从堆顶开始，将父元素与俩个孩子较大者交换  </span><br><span class="hljs-comment"> * - 直到父元素大于俩个孩子，或者没有孩子为止。  </span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PriorityQueue3</span>&lt;E <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Priority</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Queue</span>&lt;E&gt; &#123;  <br>  <br>    Priority[] array;  <br>    <span class="hljs-type">int</span> size;  <br>  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PriorityQueue3</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;  <br>        array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Priority</span>[capacity];  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//O(logn)  </span><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E offered)</span> &#123;  <br>        <span class="hljs-keyword">if</span> (isFull()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">child</span> <span class="hljs-operator">=</span> size++;<span class="hljs-comment">//确定索引，先不同填充值，可能要调整堆  </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> (child - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<span class="hljs-comment">//找到父节点  </span><br>        <span class="hljs-keyword">while</span> (child &gt; <span class="hljs-number">0</span> &amp;&amp; offered.priority() &gt; array[parent].priority()) &#123;  <br>            array[child] = array[parent];<span class="hljs-comment">//下移  </span><br>            child = parent;  <br>            parent = (child - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;  <br>        &#125;  <br>        <span class="hljs-comment">//循环结束找到目标待插入节点  </span><br>        array[child] = offered;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 交换  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;  <br>        <span class="hljs-type">Priority</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> array[i];  <br>        array[i] = array[j];  <br>        array[j] = t;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * O(logn)     * 下潜  </span><br><span class="hljs-comment">     * 因为可以通过公式，已知父节点可以得到子节点，所以参数一个即可  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">down</span><span class="hljs-params">(<span class="hljs-type">int</span> parent)</span> &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> * parent + <span class="hljs-number">1</span>;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> left + <span class="hljs-number">1</span>;<span class="hljs-comment">//等价于 2*parent+2  </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> parent;<span class="hljs-comment">//假设父元素优先级更高  </span><br>        <span class="hljs-keyword">if</span> (left &lt; size &amp;&amp; array[left].priority() &gt; array[max].priority()) &#123;<span class="hljs-comment">//left&lt;size因为通过公式得到的不一定存在  </span><br>            max = left;  <br>        &#125;  <br>        <span class="hljs-keyword">if</span> (right &lt; size &amp;&amp; array[right].priority() &gt; array[max].priority()) &#123;  <br>            max = right;  <br>        &#125;  <br>        <span class="hljs-keyword">if</span> (max != parent) &#123;  <br>            <span class="hljs-comment">//说明被更新了  </span><br>            swap(max, parent);  <br>            <span class="hljs-comment">//递归调用  </span><br>            down(max);  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">if</span> (isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>        swap(<span class="hljs-number">0</span>, size - <span class="hljs-number">1</span>);<span class="hljs-comment">//交换堆顶和尾元素  </span><br>        size--;<span class="hljs-comment">//移除数组尾部元素,就是把size减1即可  </span><br>        <span class="hljs-type">Priority</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> array[size];  <br>        array[size] = <span class="hljs-literal">null</span>;<span class="hljs-comment">//help GC  </span><br>        <span class="hljs-comment">//下潜  </span><br>        down(<span class="hljs-number">0</span>);  <br>        <span class="hljs-keyword">return</span> (E) e;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//O(1)  </span><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">if</span> (isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>        <span class="hljs-keyword">return</span> (E) array[<span class="hljs-number">0</span>];  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> size == <span class="hljs-number">0</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> size == array.length;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-primary">三种实现区别<br>无序：入队O(1)，出队O(n)<br>有序：入队O(n)，出队O(1)<br>堆：入队O(logn)，出队O(logn)  推荐<br></p><h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><blockquote><p>目前队列存在的问题<br>1.很多场景要求分离生产者、消费者俩个角色，它们由不同的线程来担当，而之前的实现并没有考虑线程安全问题。<br>2.队列为空，那么在之前的实现里会返回null，如果就是硬要拿到一个元素呢？只能不能循环尝试。<br>3.队列为满，那么在之前的实现里会返回false，如果就是硬要塞入一个元素呢？只能不断循环尝试。</p></blockquote><h3 id="单锁实现"><a href="#单锁实现" class="headerlink" title="单锁实现"></a>单锁实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> blockqueue;  <br>  <br><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * 目前队列存在的问题  </span><br><span class="hljs-comment"> * &gt; 1.很多场景要求分离生产者、消费者俩个角色，它们由不同的线程来担当，而之前的实现并没有考虑线程安全问题。  </span><br><span class="hljs-comment"> * &gt; 2.队列为空，那么在之前的实现里会返回null，如果就是硬要拿到一个元素呢？只能不能循环尝试。  </span><br><span class="hljs-comment"> * &gt; 3.队列为满，那么在之前的实现里会返回false，如果就是硬要塞入一个元素呢？只能不断循环尝试。  </span><br><span class="hljs-comment"> * &lt;p&gt;  </span><br><span class="hljs-comment"> * 解决方法：  </span><br><span class="hljs-comment"> * 1.用锁保证线程安全  </span><br><span class="hljs-comment"> * 2.用条件变量让poll或offer线程进入等待状态  </span><br><span class="hljs-comment"> */</span>  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BlockQueue</span>&lt;E&gt; &#123;<span class="hljs-comment">//阻塞队列  </span><br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 入队不再需要返回值，因为会进入阻塞状态  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e)</span> <span class="hljs-keyword">throws</span> InterruptedException;  <br>  <br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e, <span class="hljs-type">long</span> timeout)</span> <span class="hljs-keyword">throws</span> InterruptedException;  <br>  <br>    E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException;  <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> blockqueue;  <br>  <br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;  <br><span class="hljs-keyword">import</span> java.util.concurrent.locks.Condition;  <br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;  <br>  <br><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * 单锁实现  </span><br><span class="hljs-comment"> *  </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &lt;E&gt;  </span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlockQueue1</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BlockQueue</span>&lt;E&gt; &#123;  <br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> E[] array;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> head;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> tail;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;  <br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">headWaits</span> <span class="hljs-operator">=</span> lock.newCondition();<span class="hljs-comment">//配合poll方法使用 因为队列先入先出，出队的时候就用head表示  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">tailWaits</span> <span class="hljs-operator">=</span> lock.newCondition();<span class="hljs-comment">//配合offer方法使用 入队  </span><br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> size == <span class="hljs-number">0</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> size == array.length;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BlockQueue1</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;  <br>        array = (E[]) <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[capacity];  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>        lock.lockInterruptibly();  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            <span class="hljs-keyword">while</span> (isFull()) &#123;  <br>                <span class="hljs-comment">//不能用if，防止虚假唤醒  </span><br>                tailWaits.await();<span class="hljs-comment">//进入阻塞状态  </span><br>            &#125;  <br>            <span class="hljs-comment">//不满，可以添加  </span><br>            array[tail] = e;  <br>            <span class="hljs-keyword">if</span> (++tail == array.length) &#123;  <br>                tail = <span class="hljs-number">0</span>;  <br>            &#125;  <br>            size++;  <br>            <span class="hljs-comment">//此时，poll可能在等待队列非空要取数据，所以要去唤醒  </span><br>            headWaits.signal();  <br>        &#125; <span class="hljs-keyword">finally</span> &#123;  <br>            lock.unlock();  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 可以设置等待时间，上面的offer会一直等  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e, <span class="hljs-type">long</span> timeout)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>        lock.lockInterruptibly();  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            <span class="hljs-type">long</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> TimeUnit.MILLISECONDS.toNanos(timeout);<span class="hljs-comment">//传过来毫秒转换一下  </span><br>            <span class="hljs-keyword">while</span> (isFull()) &#123;  <br>                <span class="hljs-keyword">if</span> (t &lt;= <span class="hljs-number">0</span>) &#123;  <br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>                &#125;  <br>                t = tailWaits.awaitNanos(t);<span class="hljs-comment">//最多等待多少纳秒 1s 4s 返回值代表剩余时间  </span><br>            &#125;  <br>            <span class="hljs-comment">//不满，可以添加  </span><br>            array[tail] = e;  <br>            <span class="hljs-keyword">if</span> (++tail == array.length) &#123;  <br>                tail = <span class="hljs-number">0</span>;  <br>            &#125;  <br>            size++;  <br>            <span class="hljs-comment">//此时，poll可能在等待队列非空要取数据，所以要去唤醒  </span><br>            headWaits.signal();  <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>        &#125; <span class="hljs-keyword">finally</span> &#123;  <br>            lock.unlock();  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>        lock.lockInterruptibly();  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            <span class="hljs-keyword">while</span> (isEmpty()) &#123;  <br>                headWaits.await();  <br>            &#125;  <br>            <span class="hljs-type">E</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> array[head];  <br>            array[head] = <span class="hljs-literal">null</span>;<span class="hljs-comment">//help GC  </span><br>            <span class="hljs-keyword">if</span> (++head == array.length) &#123;  <br>                head = <span class="hljs-number">0</span>;  <br>            &#125;  <br>            size--;  <br>            <span class="hljs-comment">//此时，offer可能在等待队列不满要取数据，所以要去唤醒  </span><br>            tailWaits.signal();  <br>            <span class="hljs-keyword">return</span> e;  <br>        &#125; <span class="hljs-keyword">finally</span> &#123;  <br>            lock.unlock();  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="双锁实现"><a href="#双锁实现" class="headerlink" title="双锁实现"></a>双锁实现</h3><blockquote><p>上面单锁实现加锁是为了多线程下产生指令交错，结果达不到预期，所以加了一一把锁来实现。<br><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309211132224.png"><br>加锁来保证多行代码的原子性，保证左边执行完，右边再执行。这是为什么加锁。</p><p>但是加锁后，会产生新的问题，offer和poll都需要加锁，而且用到同一把锁。<br><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309211134026.png"><br>offer和poll线程是互相影响的，offer在加锁状态下，poll加不上锁会处于阻塞状态，得等offer执行完了解锁，poll才能获得锁。读写不能同时进行！这样是不合理的。一个操作头，一个操作尾，按理来讲应该互不干扰。所以可以用双锁来实现。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> blockqueue;  <br>  <br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;  <br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;  <br><span class="hljs-keyword">import</span> java.util.concurrent.locks.Condition;  <br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;  <br>  <br><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * 双锁实现  </span><br><span class="hljs-comment"> *  </span><br><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlockQueue2</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BlockQueue</span>&lt;E&gt; &#123;  <br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> E[] array;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> head;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> tail;  <br>    <span class="hljs-comment">//    private int size;  </span><br>    <span class="hljs-keyword">private</span> AtomicInteger size;  <br>  <br>    <span class="hljs-comment">//    private ReentrantLock lock = new ReentrantLock();  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">tailLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<span class="hljs-comment">//给offer用  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">tailWaits</span> <span class="hljs-operator">=</span> tailLock.newCondition();  <br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">headLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<span class="hljs-comment">//给poll方法用  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">headWaits</span> <span class="hljs-operator">=</span> headLock.newCondition();  <br>  <br><span class="hljs-comment">//    private Condition headWaits = lock.newCondition();//配合poll方法使用 因为队列先入先出，出队的时候就用head表示  </span><br><span class="hljs-comment">//    private Condition tailWaits = lock.newCondition();//配合offer方法使用 入队  </span><br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> size.get() == <span class="hljs-number">0</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> size.get() == array.length;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BlockQueue2</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;  <br>        array = (E[]) <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[capacity];  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>        <span class="hljs-type">int</span> c;<span class="hljs-comment">//添加前元素个数 c=0的时候进行加锁和唤醒操作  </span><br>        tailLock.lockInterruptibly();  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            <span class="hljs-keyword">while</span> (isFull()) &#123;  <br>                <span class="hljs-comment">//不能用if，防止虚假唤醒  </span><br>                tailWaits.await();<span class="hljs-comment">//进入阻塞状态  </span><br>            &#125;  <br>            <span class="hljs-comment">//不满，可以添加  </span><br>            array[tail] = e;  <br>            <span class="hljs-keyword">if</span> (++tail == array.length) &#123;  <br>                tail = <span class="hljs-number">0</span>;  <br>            &#125;  <br>            <span class="hljs-comment">//修改size  </span><br>            <span class="hljs-comment">/*             * 1.读取成员变量size的值  </span><br><span class="hljs-comment">             * 2.自增  </span><br><span class="hljs-comment">             * 3.结果写会成员变量size  </span><br><span class="hljs-comment">             */</span>            c = size.getAndIncrement();<span class="hljs-comment">//size++ 但能保证原子性  </span><br>            <span class="hljs-keyword">if</span> (c + <span class="hljs-number">1</span> &lt; array.length) &#123;  <br>                tailWaits.signal();  <br>            &#125;  <br>  <br>        &#125; <span class="hljs-keyword">finally</span> &#123;  <br>            tailLock.unlock();  <br>        &#125;  <br>        <span class="hljs-keyword">if</span> (c &gt; <span class="hljs-number">0</span>) &#123;  <br>            <span class="hljs-comment">//解决死锁的方法很简单，不要写成嵌套的方式即可  </span><br>            headLock.lock();  <br>            <span class="hljs-keyword">try</span> &#123;  <br>                headWaits.signal();<span class="hljs-comment">//signal和await必须搭配对应的锁  </span><br>            &#125; <span class="hljs-keyword">finally</span> &#123;  <br>                headLock.unlock();  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 可以设置等待时间，上面的offer会一直等  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e, <span class="hljs-type">long</span> timeout)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>        <span class="hljs-type">int</span> c;<span class="hljs-comment">//添加前元素个数 c=0的时候进行加锁和唤醒操作  </span><br>        tailLock.lockInterruptibly();  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            <span class="hljs-type">long</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> TimeUnit.MILLISECONDS.toNanos(timeout);<span class="hljs-comment">//传过来毫秒转换一下  </span><br>            <span class="hljs-keyword">while</span> (isFull()) &#123;  <br>                <span class="hljs-keyword">if</span> (t &lt;= <span class="hljs-number">0</span>) &#123;  <br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>                &#125;  <br>                t = tailWaits.awaitNanos(t);<span class="hljs-comment">//最多等待多少纳秒 1s 4s 返回值代表剩余时间  </span><br>            &#125;  <br>            <span class="hljs-comment">//不满，可以添加  </span><br>            array[tail] = e;  <br>            <span class="hljs-keyword">if</span> (++tail == array.length) &#123;  <br>                tail = <span class="hljs-number">0</span>;  <br>            &#125;  <br>            <span class="hljs-comment">//修改size  </span><br>            <span class="hljs-comment">/*             * 1.读取成员变量size的值  </span><br><span class="hljs-comment">             * 2.自增  </span><br><span class="hljs-comment">             * 3.结果写会成员变量size  </span><br><span class="hljs-comment">             */</span><span class="hljs-comment">//            size++;  </span><br>            c = size.getAndIncrement();<span class="hljs-comment">//size++ 但能保证原子性  </span><br>            <span class="hljs-comment">//此时，poll可能在等待队列非空要取数据，所以要去唤醒  </span><br><span class="hljs-comment">//            headWaits.signal();  </span><br>            <span class="hljs-keyword">if</span> (c + <span class="hljs-number">1</span> &lt; array.length) &#123;<span class="hljs-comment">//如果不是从满到不满，自己唤醒剩余的  </span><br>                tailWaits.signal();  <br>            &#125;  <br>  <br>        &#125; <span class="hljs-keyword">finally</span> &#123;  <br>            tailLock.unlock();  <br>        &#125;  <br>  <br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;  <br>            <span class="hljs-comment">//唤醒等待的poll线程  </span><br>            headLock.lock();<span class="hljs-comment">// offer_3 offer_3  </span><br>            <span class="hljs-keyword">try</span> &#123;  <br>                headWaits.signal();<span class="hljs-comment">// offer_1 让offer_1唤醒一次，offer_2和3不做唤醒操作，让poll自己内部唤醒，减少锁的使用  </span><br>            &#125; <span class="hljs-keyword">finally</span> &#123;  <br>                headLock.unlock();  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>        E e;  <br>        <span class="hljs-type">int</span> c;<span class="hljs-comment">//取走前的元素个数  </span><br>        headLock.lockInterruptibly();  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            <span class="hljs-keyword">while</span> (isEmpty()) &#123;  <br>                headWaits.await();<span class="hljs-comment">// poll_1 poll_2 poll_3  .   poll_1被唤醒后，自己唤醒poll2和3，这种思想叫做级联通知。  </span><br>            &#125;  <br>            e = array[head];  <br>            array[head] = <span class="hljs-literal">null</span>;<span class="hljs-comment">//help GC  </span><br>            <span class="hljs-keyword">if</span> (++head == array.length) &#123;  <br>                head = <span class="hljs-number">0</span>;  <br>            &#125;  <br>            <span class="hljs-comment">//修改size  </span><br>            <span class="hljs-comment">/*             * 1.读取成员变量size的值  </span><br><span class="hljs-comment">             * 2.自增  </span><br><span class="hljs-comment">             * 3.结果写会成员变量size  </span><br><span class="hljs-comment">             */</span><span class="hljs-comment">//            size--;  </span><br>            c = size.getAndDecrement();  <br>            <span class="hljs-keyword">if</span> (c &gt; <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//如果还有剩余元素，级联通知去唤醒剩下的  </span><br>                headWaits.signal();  <br>            &#125;  <br>        &#125; <span class="hljs-keyword">finally</span> &#123;  <br>            headLock.unlock();  <br>        &#125;  <br>        <span class="hljs-comment">//但是这样写，可能会产生死锁！！offer和poll中tailLock和headLock交叉引用了！  </span><br>        <span class="hljs-comment">//所以要改成平级的，不要嵌套的。  </span><br>        <span class="hljs-comment">//唤醒等待的offer线程  </span><br>        <span class="hljs-keyword">if</span> (c == array.length) &#123;<span class="hljs-comment">//从队列满到不满时，由poll唤醒等待不满offer线程  </span><br>            tailLock.lock();  <br>            <span class="hljs-keyword">try</span> &#123;  <br>                tailWaits.signal();<span class="hljs-comment">//signal和await必须搭配对应的锁  </span><br>            &#125; <span class="hljs-keyword">finally</span> &#123;  <br>                tailLock.unlock();  <br>            &#125;  <br>        &#125;  <br>  <br>        <span class="hljs-keyword">return</span> e;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-primary">其实这也是阻塞队列的源码，我们自己实现之后，就会更加清晰。双锁实现的阻塞队列的设计思想是值得反复去斟酌学习的。</p>]]></content>
    
    
    <categories>
      
      <category>data&amp;algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>队列</tag>
      
      <tag>双端队列</tag>
      
      <tag>优先级队列</tag>
      
      <tag>阻塞队列</tag>
      
      <tag>级联通知</tag>
      
      <tag>可重入锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构和算法之旅（三）- 递归</title>
    <link href="/posts/1bf3c967/"/>
    <url>/posts/1bf3c967/</url>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p class="note note-primary">在计算机科学中，递归是一种解决计算问题的方法，其中解决方案取决于同一类问题的更小子集。<br>比如，单链表递归遍历的例子。<br>void f(Node node){<br>&nbsp;&nbsp;f(node.next);<br>}<br>说明：<br>1.自己调用自己，如果每个函数对应着一种解决方案，自己调用自己意味着解决方案是一样的（有规律的）<br>2.每次调用，函数处理的数据会比上次缩减（子集），而且最后会缩减至无需继续递归。<br>3.内存函数调用（子集处理）完成，外层函数才能算调用完成！</p><h2 id="单链表递归分析"><a href="#单链表递归分析" class="headerlink" title="单链表递归分析"></a>单链表递归分析</h2><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309201838927.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309201839255.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309201839734.png"></p><h2 id="递归思路"><a href="#递归思路" class="headerlink" title="递归思路"></a>递归思路</h2><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309201840039.png"></p><p class="note note-primary">深入到最里面叫做递。<br>从最里面出来叫做归。<br>在递的过程中，外层函数的局部变量以及方法参数并未消失，归的时候还可以使用。</p><h2 id="阶乘"><a href="#阶乘" class="headerlink" title="阶乘"></a>阶乘</h2><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309201841987.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br><span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> n * f(n-<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-secondary">伪代码，分析执行流程如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">f(<span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">3</span> * f(<span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * f(<span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>)&#123;<br><span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="反向打印字符串"><a href="#反向打印字符串" class="headerlink" title="反向打印字符串"></a>反向打印字符串</h2><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309201844478.png"></p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309201845599.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">因为递的时候是正序的，归的时候逆序的，所以把递归调用放在前面，打印放在后面，即可实现</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReversePrintString</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span> n, String str)</span>&#123;<br><span class="hljs-keyword">if</span>(n == str.length()) <span class="hljs-keyword">return</span>;<br>f(n + <span class="hljs-number">1</span>, str);<span class="hljs-comment">//递</span><br>System.out.println(str.charAt(n));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309201848656.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">递归实现二分查找</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RecursionBinarySearch</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br><span class="hljs-type">int</span>[] a = &#123;<span class="hljs-number">7</span>,<span class="hljs-number">13</span>,<span class="hljs-number">21</span>,<span class="hljs-number">30</span>,<span class="hljs-number">38</span>,<span class="hljs-number">44</span>,<span class="hljs-number">52</span>,<span class="hljs-number">53</span>&#125;;<br>System.out.println(search(a, <span class="hljs-number">7</span>)); <span class="hljs-comment">//0</span><br>System.out.println(search(a, <span class="hljs-number">13</span>));<span class="hljs-comment">//1</span><br>System.out.println(search(a, <span class="hljs-number">21</span>));<span class="hljs-comment">//2</span><br>System.out.println(search(a, <span class="hljs-number">53</span>));<span class="hljs-comment">//7</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> target)</span>&#123;<br><span class="hljs-comment">//让调用者少传参数, 隐藏具体实现</span><br><span class="hljs-keyword">return</span> f(a, target, <span class="hljs-number">0</span>, a.length - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* left和right不对外暴露，让调用者使用更简单</span><br><span class="hljs-comment">* 返回目标索引</span><br><span class="hljs-comment">* 找不到返回-1</span><br><span class="hljs-comment">*/</span><br>priavte <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span>&#123;<br><span class="hljs-keyword">if</span>(left &gt; right) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">//递归终止条件</span><br><span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> (left + right) &gt;&gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(target &lt; a[m])&#123;<br><span class="hljs-keyword">return</span> f(a, target, left, m - <span class="hljs-number">1</span>);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[m] &lt; target)&#123;<br><span class="hljs-keyword">return</span> f(a, targetm m + <span class="hljs-number">1</span>, right);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">return</span> m;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="冒泡排序0-n-2"><a href="#冒泡排序0-n-2" class="headerlink" title="冒泡排序0(n^2)"></a>冒泡排序0(n^2)</h2><p>以下是冒泡排序的实现原理步骤：</p><ol><li>从列表的第一个元素开始，比较它与下一个元素的大小。</li><li>如果第一个元素大于第二个元素（逆序），则交换它们的位置。</li><li>移动到下一个元素，重复步骤1和步骤2，直到列表的末尾。</li><li>重复上述步骤，每次内部循环将最大的元素 “冒泡” 到列表的最后一个位置。</li><li>外部循环减小待排序元素的范围，直到没有需要交换的元素为止，表示排序完成。</li></ol><p>冒泡排序的特点是每一轮内部循环都将当前未排序部分中的最大元素移动到了最后。这意味着在每一轮后，最后的元素都会是当前未排序部分的最大值。排序过程中，如果一轮内部循环没有发生任何交换，就可以提前结束排序，因为列表已经是有序的。</p><p class="note note-info">用递归实现冒泡过程分析：<br>1.将数组划分成俩部分 [0..j]，[j+1 .. a.length-1]。<br>2.左边[0..j] 是未排序的部分。<br>3.右边[j+1 .. a.length-1]是已排序部分。<br>4.未排序区间内，相邻俩个元素比较，如果前一个大，则交换位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BubbleSort</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a)</span>&#123;<br>bubble(a, a.length-<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">//j 代表未排序区域的右边界</span><br><span class="hljs-comment">//bubble内部首先是递归结束条件，然后for循环是一次冒泡，然后调用自身</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bubble</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> j)</span>&#123;<br><span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; j; i++)&#123;<br><span class="hljs-keyword">if</span>(a[i] &gt; a[i+<span class="hljs-number">1</span>])&#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> a[i];<br>a[i] = a[i+<span class="hljs-number">1</span>];<br>a[i+<span class="hljs-number">1</span>] = t;<br>&#125;<br>&#125;<br>bubble(a, j-<span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309201908139.png"></p><blockquote><p>这种情况下，未排序区域还很大，但是只需要在冒泡一次，把2和1交换就达到目的了，但是未排序边界 j 还没有到 0 ，会做很多无用功。尝试优化一下。</p></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309201910581.png"></p><blockquote><p>可以搞一个 x ，初始为0，如果当次产生交换，就让所以 i 的索引赋给 x，如果没有产生交换，x 就保持上一次的不变，那么 x 就能当做无序和有序的边界了，下次递归就不用 j 去递减了。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BubbleSort</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a)</span>&#123;<br>bubble(a, a.length-<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">//j 代表未排序区域的右边界</span><br><span class="hljs-comment">//bubble内部首先是递归结束条件，然后for循环是一次冒泡，然后调用自身</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bubble</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> j)</span>&#123;<br><span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; j; i++)&#123;<br><span class="hljs-keyword">if</span>(a[i] &gt; a[i+<span class="hljs-number">1</span>])&#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> a[i];<br>a[i] = a[i+<span class="hljs-number">1</span>];<br>a[i+<span class="hljs-number">1</span>] = t;<br>x = i;<br>&#125;<br>&#125;<br>bubble(a, x);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="插入排序O-n-2"><a href="#插入排序O-n-2" class="headerlink" title="插入排序O(n^2)"></a>插入排序O(n^2)</h2><p>它的工作方式优点像整理一手扑克牌，以下是插入排序的实现原理步骤：</p><ol><li>从第二个元素开始（索引为1），将当前元素视为待插入的元素。</li><li>将待插入的元素与已排序部分的元素逐个比较，直到找到一个比待插入元素小的元素，或者已经遍历完已排序部分。</li><li>将待插入元素插入到找到的位置，使得已排序部分仍然保持有序。</li><li>重复上述步骤，逐个处理未排序部分的元素，直到整个列表都有序。</li></ol><p>插入排序的特点是在每一轮内部循环中，将当前未排序元素插入到已排序部分的合适位置，逐步扩展已排序部分。这使得已排序部分始终保持有序。插入排序适用于小型数据集或基本有序的数据集，因为它的时间复杂度为 O(n^2)，在大型数据集上性能较差。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a)</span>&#123;<br>insertion(a, <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">用递归实现</span><br><span class="hljs-comment">low是未排序的左边界，从1开始</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertion</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> low)</span>&#123;<br><span class="hljs-keyword">if</span>(low == a.length)&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> a[low];<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> low - <span class="hljs-number">1</span>;<span class="hljs-comment">//已排序区域指针</span><br><span class="hljs-keyword">while</span>(i&gt;=<span class="hljs-number">0</span> &amp;&amp; a[i]&gt;t)&#123;<span class="hljs-comment">//没有找到插入位置</span><br>a[i+<span class="hljs-number">1</span>] = a[i];<span class="hljs-comment">//空出插入位置</span><br>i--;<br>&#125;<br><span class="hljs-comment">//找到插入位置</span><br>a[i+<span class="hljs-number">1</span>] = t;<br><br>insertion(a, low+<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="斐波那契数列-多路递归"><a href="#斐波那契数列-多路递归" class="headerlink" title="斐波那契数列(多路递归)"></a>斐波那契数列(多路递归)</h2><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309201931055.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Fibonacci</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br><span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> f(n - <span class="hljs-number">1</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> f(n - <span class="hljs-number">2</span>)；<br><span class="hljs-keyword">return</span> x + y;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-danger">斐波那契是多路递归的典型案例，整个计算过程相当于二叉树了，其中很多重复的步骤，造成时间复杂度很差。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309201934609.png"></p><p class="note note-success">可以看出，上面计算过程有很多重复，可以定义一个数组，存储 f(n) 的解，将来计算到哪一项的时候，如果数组有就直接从数组取，可以大大优化；<br>这种方式称为记忆法，也称为备忘录，其实就是剪枝的过程。<br>改进之后时间复杂度从O(1.68n)优化为O(n)。但因额外产生数组，这就是空间换时间。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309201936305.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fbonacci</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br><span class="hljs-type">int</span>[] cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>Arrays.fill(cache, -<span class="hljs-number">1</span>);<span class="hljs-comment">//都填充-1</span><br>cache[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>cache[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> f(n, cache);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[] cache)</span>&#123;<br><span class="hljs-keyword">if</span>(cache[n] != -<span class="hljs-number">1</span>)&#123;<br><span class="hljs-keyword">return</span> cache[n];<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> f(n-<span class="hljs-number">1</span>, cache);<br><span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> f(n-<span class="hljs-number">2</span>, cache);<br>cache[n] = x + y;<span class="hljs-comment">//存入数组</span><br><span class="hljs-keyword">return</span> cache[n];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="递归求和"><a href="#递归求和" class="headerlink" title="递归求和"></a>递归求和</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sum</span>&#123;<br><span class="hljs-comment">//f(n) = f(n-1) + n;</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">long</span> n)</span>&#123;<br><span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> sum(n-<span class="hljs-number">1</span>) + n;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309201948253.png"></p><p class="note note-danger">递归求和，属于单路递归，很容易就想到了思路，为什么贴上这个呢。可以把n等于15000试一下，就很发现为什么了。因为栈内存溢出了！也就是爆栈了！<br>只有最内层的sum(n = 1)的函数执行完了，才能一层一层往外归。也就是说递的过程必须递到最深处才能归！！！每个方法调用是需要消耗内存的，需要存储方法的相关信息，比如说方法的参数信息，方法内的局部变量，方法的返回地址，这些信息都需要存放在栈内存中，在最内层n = 1没有结束之前，前面14999个方法都需要等着！！它们占用的内存也不能得到释放。所以会导致占内存溢出。</p><h3 id="尾调用-amp-尾递归"><a href="#尾调用-amp-尾递归" class="headerlink" title="尾调用&amp;尾递归"></a>尾调用&amp;尾递归</h3><p class="note note-success">在解决爆栈问题之前，需要掌握几个其他知识。<br>尾调用：如果函数的最后一步是调用一个函数，称为尾调用。<br>尾递归：在函数内部最后调用自己，称为尾递归。<br>能对尾递归优化的语言有c++、scala，它们会把逐级递归的方式改成平级的形式。scala也属于java的近亲，也是编译成class类在JVM上运行，有幸了解过一些。<br>当然，从根本上避免爆栈问题，就是避免使用递归。把递归代码改成循环代码。理论上所有递归都能改写成循环代码。</p><p class="note note-secondary">经典白学，哈哈哈哈</p>]]></content>
    
    
    <categories>
      
      <category>data&amp;algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
      <tag>多路递归</tag>
      
      <tag>尾递归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构和算法之旅（二）- 链表</title>
    <link href="/posts/60be154/"/>
    <url>/posts/60be154/</url>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p class="note note-primary">在计算机科学中，链表是数据元素的线性集合，其每个元素都指向下一个元素，元素存储上并不连续。<br>可分类为：<br>- 单向链表：每个元素只知道其下一个元素<br>- 双向链表：每个元素知道其上一个元素和下一个元素<br>- 循环链表：通常的链表尾节点tail指向null，而循环链表的tail指向的头结点head<br><br>链表内还有一种特殊的节点，称为哨兵(Sentinel)节点，也叫做哑元(Dummy)节点，它不存储数据，通常用作头尾，用来简化边界判断。<br></p><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><h3 id="随机访问"><a href="#随机访问" class="headerlink" title="随机访问"></a>随机访问</h3><p>根据index查找，时间复杂度O(n)，因为需要一个节点next、next找到目标。</p><h3 id="插入或删除"><a href="#插入或删除" class="headerlink" title="插入或删除"></a>插入或删除</h3><ul><li>起始位置：O(1)。</li><li>结束位置：如果已知tail节点则是O(1)，不知道tail节点则是O(n)。</li><li>中间位置：根据index查找时间+O(1)。</li></ul><h2 id="单向链表之无哨兵节点"><a href="#单向链表之无哨兵节点" class="headerlink" title="单向链表之无哨兵节点"></a>单向链表之无哨兵节点</h2><p class="note note-light">talk is cheap, show me the code.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.datastructure;<br><br><span class="hljs-keyword">import</span> java.util.Iterator;<br><span class="hljs-keyword">import</span> java.util.function.Consumer;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 单向链表 基础实现 无哨兵节点</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BasicSingleLinkedList</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterable</span> &#123;<span class="hljs-comment">//整体</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Node</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<span class="hljs-comment">//头节点，默认为null</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 内部类关系，对外隐藏实现细节</span><br><span class="hljs-comment">     * 对外部调用者只需要LinkedList即可</span><br><span class="hljs-comment">     * 内部类一半都加上static</span><br><span class="hljs-comment">     * 节点类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<span class="hljs-comment">//节点</span><br>        <span class="hljs-type">int</span> value;<span class="hljs-comment">//值</span><br>        Node next;<span class="hljs-comment">//下一个节点</span><br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> value, Node next)</span> &#123;<br>            <span class="hljs-built_in">this</span>.value = value;<br>            <span class="hljs-built_in">this</span>.next = next;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 向链表头添加元素</span><br><span class="hljs-comment">     * 多理解！！</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addFirst</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-comment">//链表为空</span><br><span class="hljs-comment">//        head = new Node(value, null);</span><br>        <span class="hljs-comment">//链表非空</span><br>        <span class="hljs-comment">//因为head默认为null，所以不需要判断，链表空不空都能能用</span><br>        head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(value, head);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 向列表尾添加元素</span><br><span class="hljs-comment">     * 先找到尾节点，再添加</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addLast</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> findLast();<br>        <span class="hljs-keyword">if</span> (last == <span class="hljs-literal">null</span>) &#123;<br>            addFirst(value);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        last.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(value, <span class="hljs-literal">null</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 向索引位置插入节点</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> index 索引位置</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 待插入值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span>) &#123;<br>            addFirst(value);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> findNode(index - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (prev == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//找不到前一个节点</span><br>            <span class="hljs-keyword">throw</span> illegalIndex();<br>        &#125;<br>        prev.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(value, prev.next);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除头节点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeFirst</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> illegalIndex();<br>        &#125;<br>        head = head.next;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据索引删除节点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span>) &#123;<br>            removeFirst();<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> findNode(index - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (prev == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//找不到前一个节点</span><br>            <span class="hljs-keyword">throw</span> illegalIndex();<br>        &#125;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">removed</span> <span class="hljs-operator">=</span> prev.next;<br>        <span class="hljs-keyword">if</span> (removed == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> illegalIndex();<br>        &#125;<br>        prev.next = removed.next;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> IllegalArgumentException <span class="hljs-title function_">illegalIndex</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;index illegal&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 找到最后一个节点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Node <span class="hljs-title function_">findLast</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//链表为空，没有最后一个节点</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">//利用for循环特性获取最后一个节点</span><br>        Node p;<br>        <span class="hljs-keyword">for</span> (p = head; p.next != <span class="hljs-literal">null</span>; p = p.next) &#123;<br>        &#125;<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查询指定位置元素</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Node <span class="hljs-title function_">findNode</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//利用for循环特性获取指定index位置节点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> head; p != <span class="hljs-literal">null</span>; p = p.next, i++) &#123;<br>            <span class="hljs-keyword">if</span> (i == index) &#123;<br>                <span class="hljs-keyword">return</span> p;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * get方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> findNode(index);<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> illegalIndex();<br>        &#125;<br>        <span class="hljs-keyword">return</span> node.value;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 循环1 while</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loop1</span><span class="hljs-params">(Consumer&lt;Integer&gt; consumer)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">pointer</span> <span class="hljs-operator">=</span> head;<span class="hljs-comment">//初始值指向头节点</span><br>        <span class="hljs-keyword">while</span> (pointer != <span class="hljs-literal">null</span>) &#123;<br>            consumer.accept(pointer.value);<span class="hljs-comment">//提供给外部的方法</span><br>            pointer = pointer.next;<span class="hljs-comment">//指向下一个节点</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 循环2 for</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loop2</span><span class="hljs-params">(Consumer&lt;Integer&gt; consumer)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">pointer</span> <span class="hljs-operator">=</span> head; pointer != <span class="hljs-literal">null</span>; pointer = pointer.next) &#123;<br>            consumer.accept(pointer.value);<span class="hljs-comment">//提供给外部的方法</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 循环3 iterator</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Iterator <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 匿名内部类 -&gt; 带名字的内部类</span><br><span class="hljs-comment">         * 这个抽取出来的内部类MyIterator，它是不加static的</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * 当内部类用到了外部类的成员变量时候，就不能加static</span><br><span class="hljs-comment">         * 因为static的意思是不依赖外部类实例的存在，而成员变量是依赖外部类的对象的</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * 而Node节点类是可以加static的，因为它不依赖外部类的对象的</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * 内部类能加就加，不能加就不加，建议加static</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyIterator</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">pointer</span> <span class="hljs-operator">=</span> head;<span class="hljs-comment">//初始值指向头节点</span><br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<span class="hljs-comment">//是否有下一个元素</span><br>            <span class="hljs-keyword">return</span> pointer != <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<span class="hljs-comment">//返回当前值，并指向下一个元素</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> pointer.value;<br>            pointer = pointer.next;<br>            <span class="hljs-keyword">return</span> v;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="单向链表之含哨兵节点"><a href="#单向链表之含哨兵节点" class="headerlink" title="单向链表之含哨兵节点"></a>单向链表之含哨兵节点</h2><p class="note note-light">talk is cheap, show me the code.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.datastructure;<br><br><span class="hljs-keyword">import</span> java.util.Iterator;<br><span class="hljs-keyword">import</span> java.util.function.Consumer;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 单向链表 优化实现 含哨兵节点</span><br><span class="hljs-comment"> * 带哨兵节点的单向链表可以减少很多边界判断</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SentinelSinglyLinkedList</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterable</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 头指针指向哨兵节点，哨兵节点值无所谓</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Node</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">111</span>, <span class="hljs-literal">null</span>);<span class="hljs-comment">//头节点</span><br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 内部类关系，对外隐藏实现细节</span><br><span class="hljs-comment">     * 对外部调用者只需要LinkedList即可</span><br><span class="hljs-comment">     * 内部类一般都加上static</span><br><span class="hljs-comment">     * 节点类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<span class="hljs-comment">//节点</span><br>        <span class="hljs-type">int</span> value;<span class="hljs-comment">//值</span><br>        Node next;<span class="hljs-comment">//下一个节点</span><br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> value, Node next)</span> &#123;<br>            <span class="hljs-built_in">this</span>.value = value;<br>            <span class="hljs-built_in">this</span>.next = next;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 加哨兵后修改</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * 向链表头添加元素</span><br><span class="hljs-comment">     * 多理解！！</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addFirst</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-comment">//不需要判断链表是否为空，因为链表一定不为空</span><br><span class="hljs-comment">//        //1.链表为空</span><br><span class="hljs-comment">////        head = new Node(value, null);</span><br><span class="hljs-comment">//        //2.链表非空</span><br><span class="hljs-comment">//        //因为head默认为null，所以不需要判断，链表空不空都能能用</span><br><span class="hljs-comment">//        head = new Node(value, head);</span><br>        insert(<span class="hljs-number">0</span>, value);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 加哨兵后修改</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * 向列表尾添加元素</span><br><span class="hljs-comment">     * 先找到尾节点，再添加</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addLast</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> findLast();<br>        <span class="hljs-comment">//含哨兵节点，不需要判断链表是否为空，因为链表一定不为空</span><br><span class="hljs-comment">//        if (last == null) &#123;</span><br><span class="hljs-comment">//            addFirst(value);</span><br><span class="hljs-comment">//            return;</span><br><span class="hljs-comment">//        &#125;</span><br>        last.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(value, <span class="hljs-literal">null</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 加哨兵后修改</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * 向索引位置插入节点</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> index 索引位置</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 待插入值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> value)</span> &#123;<br><span class="hljs-comment">//        if (index == 0) &#123;</span><br><span class="hljs-comment">//            addFirst(value);</span><br><span class="hljs-comment">//            return;</span><br><span class="hljs-comment">//        &#125;</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> findNode(index - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (prev == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//找不到前一个节点</span><br>            <span class="hljs-keyword">throw</span> illegalIndex();<br>        &#125;<br>        prev.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(value, prev.next);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 加哨兵后修改</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * 删除头节点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeFirst</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//        if (head == null) &#123;</span><br><span class="hljs-comment">//            throw illegalIndex();</span><br><span class="hljs-comment">//        &#125;</span><br><span class="hljs-comment">//        head = head.next;</span><br>        remove(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 加哨兵后修改</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * 根据索引删除节点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br><span class="hljs-comment">//        if (index == 0) &#123;</span><br><span class="hljs-comment">//            removeFirst();</span><br><span class="hljs-comment">//            return;</span><br><span class="hljs-comment">//        &#125;</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> findNode(index - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (prev == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//找不到前一个节点</span><br>            <span class="hljs-keyword">throw</span> illegalIndex();<br>        &#125;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">removed</span> <span class="hljs-operator">=</span> prev.next;<br>        <span class="hljs-keyword">if</span> (removed == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> illegalIndex();<br>        &#125;<br>        prev.next = removed.next;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> IllegalArgumentException <span class="hljs-title function_">illegalIndex</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;index illegal&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 加哨兵后修改</span><br><span class="hljs-comment">     * 找到最后一个节点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Node <span class="hljs-title function_">findLast</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//含哨兵节点，不需要判断链表是否为空，因为链表一定不为空</span><br><span class="hljs-comment">//        if (head == null) &#123;</span><br><span class="hljs-comment">//            //链表为空，没有最后一个节点</span><br><span class="hljs-comment">//            return null;</span><br><span class="hljs-comment">//        &#125;</span><br>        Node p;<br>        <span class="hljs-keyword">for</span> (p = head; p.next != <span class="hljs-literal">null</span>; p = p.next) &#123;<br>        &#125;<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 加哨兵后修改</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * 查询指定位置元素</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Node <span class="hljs-title function_">findNode</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//为什么i=-1？ 因为哨兵节点也占一位。</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> head; p != <span class="hljs-literal">null</span>; p = p.next, i++) &#123;<br>            <span class="hljs-keyword">if</span> (i == index) &#123;<br>                <span class="hljs-keyword">return</span> p;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * get方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> findNode(index);<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> illegalIndex();<br>        &#125;<br>        <span class="hljs-keyword">return</span> node.value;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 加哨兵后修改</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * 循环1 while</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loop1</span><span class="hljs-params">(Consumer&lt;Integer&gt; consumer)</span> &#123;<br>        <span class="hljs-comment">//遍历的起点变了</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">pointer</span> <span class="hljs-operator">=</span> head.next;<span class="hljs-comment">//初始值指向头节点</span><br>        <span class="hljs-keyword">while</span> (pointer != <span class="hljs-literal">null</span>) &#123;<br>            consumer.accept(pointer.value);<span class="hljs-comment">//提供给外部的方法</span><br>            pointer = pointer.next;<span class="hljs-comment">//指向下一个节点</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 加哨兵后修改</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * 循环2 for</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loop2</span><span class="hljs-params">(Consumer&lt;Integer&gt; consumer)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">pointer</span> <span class="hljs-operator">=</span> head.next; pointer != <span class="hljs-literal">null</span>; pointer = pointer.next) &#123;<br>            consumer.accept(pointer.value);<span class="hljs-comment">//提供给外部的方法</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 循环3 iterator</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Iterator <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 匿名内部类 -&gt; 带名字的内部类</span><br><span class="hljs-comment">         * 这个抽取出来的内部类MyIterator，它是不加static的</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * 当内部类用到了外部类的成员变量时候，就不能加static</span><br><span class="hljs-comment">         * 因为static的意思是不依赖外部类实例的存在，而成员变量是依赖外部类的对象的</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * 而Node节点类是可以加static的，因为它不依赖外部类的对象的</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * 内部类能加就加，不能加就不加，建议加static</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyIterator</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">pointer</span> <span class="hljs-operator">=</span> head.next;<span class="hljs-comment">//初始值指向头节点</span><br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<span class="hljs-comment">//是否有下一个元素</span><br>            <span class="hljs-keyword">return</span> pointer != <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<span class="hljs-comment">//返回当前值，并指向下一个元素</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> pointer.value;<br>            pointer = pointer.next;<br>            <span class="hljs-keyword">return</span> v;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="双向链表之含哨兵节点"><a href="#双向链表之含哨兵节点" class="headerlink" title="双向链表之含哨兵节点"></a>双向链表之含哨兵节点</h2><p class="note note-light">talk is cheap, show me the code.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.datastructure;<br><br><span class="hljs-keyword">import</span> java.util.Iterator;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 双向链表 带哨兵节点</span><br><span class="hljs-comment"> * 俩个哨兵节点，一个头哨兵，一个尾哨兵</span><br><span class="hljs-comment"> * 也就是说，链表中至少有俩个节点</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * 双向链表的优点：从尾部直接能获取最后一个节点</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DoublyLinkedListSentinel</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterable</span>&lt;Integer&gt; &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>        Node prev;<span class="hljs-comment">//上一个节点</span><br>        <span class="hljs-type">int</span> value;<span class="hljs-comment">//值</span><br>        Node next;<span class="hljs-comment">//下一个节点</span><br><br>        <span class="hljs-comment">//构造方法 方便初始化</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(Node prev, <span class="hljs-type">int</span> value, Node next)</span> &#123;<br>            <span class="hljs-built_in">this</span>.prev = prev;<br>            <span class="hljs-built_in">this</span>.value = value;<br>            <span class="hljs-built_in">this</span>.next = next;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Node head;<span class="hljs-comment">//头哨兵</span><br>    <span class="hljs-keyword">private</span> Node tail;<span class="hljs-comment">//尾哨兵</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DoublyLinkedListSentinel</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//头尾节点随便给个值就行</span><br>        head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-literal">null</span>, <span class="hljs-number">666</span>, <span class="hljs-literal">null</span>);<br>        tail = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-literal">null</span>, <span class="hljs-number">888</span>, <span class="hljs-literal">null</span>);<br>        head.next = tail;<br>        tail.prev = head;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据索引查找节点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Node <span class="hljs-title function_">findNode</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<span class="hljs-comment">//头哨兵也要参与遍历所以从-1开始</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> head; p != tail; p = p.next, i++) &#123;<br>            <span class="hljs-keyword">if</span> (i == index) &#123;<br>                <span class="hljs-keyword">return</span> p;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addFirst</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        insert(<span class="hljs-number">0</span>, value);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeFirst</span><span class="hljs-params">()</span> &#123;<br>        remove(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 向列表尾添加元素</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addLast</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> tail.prev;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">added</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(last, value, tail);<br>        last.next = added;<br>        tail.prev = added;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除列表尾元素</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeLast</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">removed</span> <span class="hljs-operator">=</span> tail.prev;<br>        <span class="hljs-keyword">if</span> (removed == head) &#123;<br>            <span class="hljs-keyword">throw</span> illegalIndex();<br>        &#125;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> removed.prev;<br>        prev.next = tail;<br>        tail.prev = prev;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 向索引位置插入节点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> findNode(index - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (prev == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> illegalIndex();<br>        &#125;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> prev.next;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">inserted</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(prev, value, next);<span class="hljs-comment">//新节点的上一个节点是prev，下一个节点是next</span><br>        prev.next = inserted;<span class="hljs-comment">//prev的下一个节点是inserted</span><br>        next.prev = inserted;<span class="hljs-comment">//next的上一个节点是inserted</span><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除索引位置的节点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> findNode(index - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (prev == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> illegalIndex();<br>        &#125;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">removed</span> <span class="hljs-operator">=</span> prev.next;<br>        <span class="hljs-keyword">if</span> (removed == tail) &#123;<br>            <span class="hljs-keyword">throw</span> illegalIndex();<br>        &#125;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> removed.next;<br><br>        prev.next = next;<br>        next.prev = prev;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> IllegalArgumentException <span class="hljs-title function_">illegalIndex</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;index illegal&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Iterator&lt;Integer&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Iterator</span>&lt;Integer&gt;() &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> head.next;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> p != tail;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> p.value;<br>                p = p.next;<br>                <span class="hljs-keyword">return</span> v;<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="双向环形含哨兵链表"><a href="#双向环形含哨兵链表" class="headerlink" title="双向环形含哨兵链表"></a>双向环形含哨兵链表</h2><p class="note note-light">talk is cheap, show me the code.<br> 这个有些特殊，此时哨兵即作为头，也作为尾。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309201522659.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.datastructure;<br><br><span class="hljs-keyword">import</span> java.util.Iterator;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 环形双向含哨兵链表</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RingDoublyLinkedListSentinel</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterable</span>&lt;Integer&gt; &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>        Node prev;<br>        <span class="hljs-type">int</span> value;<br>        Node next;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(Node prev, <span class="hljs-type">int</span> value, Node next)</span> &#123;<br>            <span class="hljs-built_in">this</span>.prev = prev;<br>            <span class="hljs-built_in">this</span>.value = value;<br>            <span class="hljs-built_in">this</span>.next = next;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Node</span> <span class="hljs-variable">sentinel</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-literal">null</span>, <span class="hljs-number">666</span>, <span class="hljs-literal">null</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RingDoublyLinkedListSentinel</span><span class="hljs-params">()</span> &#123;<br>        sentinel.next = sentinel;<br>        sentinel.prev = sentinel;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 添加到链表头部</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addFirst</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> sentinel;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> sentinel.next;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">added</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(a, value, b);<br>        a.next = added;<br>        b.prev = added;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 添加到链表尾部</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addLast</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> sentinel.prev;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> sentinel;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">added</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(a, value, b);<br>        a.next = added;<br>        b.prev = added;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除第一个</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeFirst</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">removed</span> <span class="hljs-operator">=</span> sentinel.next;<br>        <span class="hljs-keyword">if</span> (removed == sentinel) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal argument&quot;</span>);<br>        &#125;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> removed.prev;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> removed.next;<br>        a.next = b;<br>        b.prev = a;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除最后一个</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeLast</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">removed</span> <span class="hljs-operator">=</span> sentinel.prev;<br>        <span class="hljs-keyword">if</span> (removed == sentinel) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal argument&quot;</span>);<br>        &#125;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> removed.prev;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> removed.next;<br>        a.next = b;<br>        b.prev = a;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据值删除节点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeByValue</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">removed</span> <span class="hljs-operator">=</span> findByValue(value);<br>        <span class="hljs-keyword">if</span> (removed == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal argument&quot;</span>);<br>        &#125;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> removed.prev;<span class="hljs-comment">//前一个节点</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> removed.next;<span class="hljs-comment">//后一个节点</span><br>        a.next = b;<span class="hljs-comment">//前一个节点的next指向后一个节点</span><br>        b.prev = a;<span class="hljs-comment">//后一个节点的prev指向前一个节点</span><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据值找到节点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Node <span class="hljs-title function_">findByValue</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> sentinel.next;<br>        <span class="hljs-keyword">while</span> (p != sentinel) &#123;<br>            <span class="hljs-keyword">if</span> (p.value == value) &#123;<br>                <span class="hljs-keyword">return</span> p;<br>            &#125;<br>            p = p.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Iterator&lt;Integer&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Iterator</span>&lt;Integer&gt;() &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">pointer</span> <span class="hljs-operator">=</span> sentinel.next;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> pointer != sentinel;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> pointer.value;<br>                pointer = pointer.next;<br>                <span class="hljs-keyword">return</span> v;<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="单向链表的递归遍历"><a href="#单向链表的递归遍历" class="headerlink" title="单向链表的递归遍历"></a>单向链表的递归遍历</h2><p class="note note-light">talk is cheap, show me the code.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><code class="hljs java">  <br><span class="hljs-keyword">import</span> java.util.Iterator;  <br><span class="hljs-keyword">import</span> java.util.function.Consumer;  <br>  <br><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * 单向链表 基础实现  </span><br><span class="hljs-comment"> * &lt;p&gt;  </span><br><span class="hljs-comment"> * ！！！递归遍历！！！  </span><br><span class="hljs-comment"> * 它是链表的一种非常重要的遍历方式  </span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RecursionLinkedList</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterable</span> &#123;<span class="hljs-comment">//整体  </span><br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Node</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<span class="hljs-comment">//头节点，默认为null  </span><br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 内部类关系，对外隐藏实现细节  </span><br><span class="hljs-comment">     * 对外部调用者只需要LinkedList即可  </span><br><span class="hljs-comment">     * 内部类一半都加上static  </span><br><span class="hljs-comment">     * 节点类  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<span class="hljs-comment">//节点  </span><br>        <span class="hljs-type">int</span> value;<span class="hljs-comment">//值  </span><br>        Node next;<span class="hljs-comment">//下一个节点  </span><br>  <br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> value, Node next)</span> &#123;  <br>            <span class="hljs-built_in">this</span>.value = value;  <br>            <span class="hljs-built_in">this</span>.next = next;  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 向链表头添加元素  </span><br><span class="hljs-comment">     * 多理解！！  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addFirst</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;  <br>        <span class="hljs-comment">//1.链表为空  </span><br><span class="hljs-comment">//        head = new Node(value, null);  </span><br>        <span class="hljs-comment">//2.链表非空  </span><br>        <span class="hljs-comment">//因为head默认为null，所以不需要判断，链表空不空都能能用  </span><br>        head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(value, head);  <br>    &#125;  <br>  <br>  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 向列表尾添加元素  </span><br><span class="hljs-comment">     * 先找到尾节点，再添加  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addLast</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> findLast();  <br>        <span class="hljs-keyword">if</span> (last == <span class="hljs-literal">null</span>) &#123;  <br>            addFirst(value);  <br>            <span class="hljs-keyword">return</span>;  <br>        &#125;  <br>        last.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(value, <span class="hljs-literal">null</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 向索引位置插入节点  </span><br><span class="hljs-comment">     *  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> index 索引位置  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 待插入值  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> value)</span> &#123;  <br>        <span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span>) &#123;  <br>            addFirst(value);  <br>            <span class="hljs-keyword">return</span>;  <br>        &#125;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> findNode(index - <span class="hljs-number">1</span>);  <br>        <span class="hljs-keyword">if</span> (prev == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//找不到前一个节点  </span><br>            <span class="hljs-keyword">throw</span> illegalIndex();  <br>        &#125;  <br>        prev.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(value, prev.next);  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 删除头节点  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeFirst</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-keyword">throw</span> illegalIndex();  <br>        &#125;  <br>        head = head.next;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 根据索引删除节点  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;  <br>        <span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span>) &#123;  <br>            removeFirst();  <br>            <span class="hljs-keyword">return</span>;  <br>        &#125;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> findNode(index - <span class="hljs-number">1</span>);  <br>        <span class="hljs-keyword">if</span> (prev == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//找不到前一个节点  </span><br>            <span class="hljs-keyword">throw</span> illegalIndex();  <br>        &#125;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">removed</span> <span class="hljs-operator">=</span> prev.next;  <br>        <span class="hljs-keyword">if</span> (removed == <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-keyword">throw</span> illegalIndex();  <br>        &#125;  <br>        prev.next = removed.next;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> IllegalArgumentException <span class="hljs-title function_">illegalIndex</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;index illegal&quot;</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 找到最后一个节点  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">private</span> Node <span class="hljs-title function_">findLast</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-comment">//链表为空，没有最后一个节点  </span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>        &#125;  <br>        Node p;  <br>        <span class="hljs-keyword">for</span> (p = head; p.next != <span class="hljs-literal">null</span>; p = p.next) &#123;  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> p;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 查询指定位置元素  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">private</span> Node <span class="hljs-title function_">findNode</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> head; p != <span class="hljs-literal">null</span>; p = p.next, i++) &#123;  <br>            <span class="hljs-keyword">if</span> (i == index) &#123;  <br>                <span class="hljs-keyword">return</span> p;  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * get方法  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> findNode(index);  <br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-keyword">throw</span> illegalIndex();  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> node.value;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 循环3 iterator  </span><br><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> Iterator <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-comment">/**  </span><br><span class="hljs-comment">         * 匿名内部类 -&gt; 带名字的内部类  </span><br><span class="hljs-comment">         * 这个抽取出来的内部类MyIterator，它是不加static的  </span><br><span class="hljs-comment">         *  </span><br><span class="hljs-comment">         * 当内部类用到了外部类的成员变量时候，就不能加static  </span><br><span class="hljs-comment">         * 因为static的意思是不依赖外部类实例的存在，而成员变量是依赖外部类的对象的  </span><br><span class="hljs-comment">         *  </span><br><span class="hljs-comment">         * 而Node节点类是可以加static的，因为它不依赖外部类的对象的  </span><br><span class="hljs-comment">         *  </span><br><span class="hljs-comment">         * 内部类能加就加，不能加就不加，建议加static  </span><br><span class="hljs-comment">         */</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyIterator</span>();  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span> &#123;  <br>        <span class="hljs-type">Node</span> <span class="hljs-variable">pointer</span> <span class="hljs-operator">=</span> head;<span class="hljs-comment">//初始值指向头节点  </span><br>  <br>        <span class="hljs-meta">@Override</span>  <br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<span class="hljs-comment">//是否有下一个元素  </span><br>            <span class="hljs-keyword">return</span> pointer != <span class="hljs-literal">null</span>;  <br>        &#125;  <br>  <br>        <span class="hljs-meta">@Override</span>  <br>        <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<span class="hljs-comment">//返回当前值，并指向下一个元素  </span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> pointer.value;  <br>            pointer = pointer.next;  <br>            <span class="hljs-keyword">return</span> v;  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recursion</span><span class="hljs-params">(Node curr, Consumer&lt;String&gt; before, Consumer&lt;String&gt; after)</span>&#123; <br>        <span class="hljs-keyword">if</span> (curr == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//递归需要一个终止条件  </span><br>            <span class="hljs-keyword">return</span>;  <br>        &#125;  <br>        before.accept(<span class="hljs-string">&quot;before: &quot;</span> + curr.value);  <br>        recursion(curr.next, before, after);<span class="hljs-comment">//这样自己调用自己称为递归  </span><br>        after.accept(<span class="hljs-string">&quot;after: &quot;</span> + curr.value);  <br>    &#125;  <br>  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    <span class="hljs-type">RecursionLinkedList</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RecursionLinkedList</span>();  <br>    list.addLast(<span class="hljs-number">55</span>);  <br>    list.addLast(<span class="hljs-number">66</span>);  <br>    list.addLast(<span class="hljs-number">77</span>);  <br>    list.addLast(<span class="hljs-number">88</span>);  <br>    list.recursion(list.findNode(<span class="hljs-number">0</span>),System.out::println, System.out::println);  <br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>通过递归方式遍历打印的时候，发现了有趣的现象，不同情况，打印结果却不同<br>打印在前，递归在后<br>递归在前，递归在后<br>俩种情况的呈现方式相差很大，如下图。</p></blockquote><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309201607691.png"></p><blockquote><p>下一篇，会详细探讨一下递归，来解释为什么有这种现象。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>data&amp;algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
      <tag>链表</tag>
      
      <tag>单向链表</tag>
      
      <tag>双向链表</tag>
      
      <tag>环形链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构和算法之旅（一）- 数组</title>
    <link href="/posts/743df8dd/"/>
    <url>/posts/743df8dd/</url>
    
    <content type="html"><![CDATA[<blockquote><p>在计算机科学中，数组是由一组元素(值或变量)组成的数据结构，每个元素有至少一个索引来标识；因为数组内元素是连续存储的，所以数组中的元素的地址，可以通过其索引计算出来，例如：<img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309201048552.png"></p><p>数组的特点：<strong>随机访问</strong>。即根据索引查找元素，时间复杂度是O(1)。</p></blockquote><h2 id="自定义动态数组"><a href="#自定义动态数组" class="headerlink" title="自定义动态数组"></a>自定义动态数组</h2><p class="note note-info">数组是静态数组，不能够动态调整大小。Java是有提供好的动态数组，其实就是ArrayList，但目前是为了学习数据结构，下面自己来实现一个动态数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.datastructure;<br><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Iterator;<br><span class="hljs-keyword">import</span> java.util.function.Consumer;<br><span class="hljs-keyword">import</span> java.util.stream.IntStream;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 动态数组</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DynamicArray</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterable</span>&lt;Integer&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//逻辑大小</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">capacity</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<span class="hljs-comment">//容量 ,java中arraylist默认是10</span><br><br>    <span class="hljs-comment">//    private int[] array = new int[capacity];//延迟加载</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] array = &#123;&#125;;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 添加元素到数组末尾</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> element 待添加的元素</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addLast</span><span class="hljs-params">(<span class="hljs-type">int</span> element)</span> &#123;<br>        <span class="hljs-comment">//array[size] = element;</span><br>        <span class="hljs-comment">//size++;</span><br>        add(size, element);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 添加元素到指定位置</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> index   索引位置</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> element 待添加的元素</span><br><span class="hljs-comment">     * 时间复杂度</span><br><span class="hljs-comment">     *    头部插入：O(n)</span><br><span class="hljs-comment">     *    中间插入：O(n)</span><br><span class="hljs-comment">     *    尾部插入：O(1)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> element)</span> &#123;<br>        <span class="hljs-comment">//扩容检查</span><br>        checkAndGrow();<br>        <span class="hljs-comment">//检查index是否合法</span><br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt; size) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>(<span class="hljs-string">&quot;index:&quot;</span> + index + <span class="hljs-string">&quot;,size:&quot;</span> + size);<br>        &#125;<br>        <span class="hljs-comment">//拷贝，把目标index后的元素都往后移动一位</span><br>        System.arraycopy(array, index, array, index + <span class="hljs-number">1</span>, size - index);<br>        array[index] = element;<br>        size++;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 扩容检查</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkAndGrow</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>) &#123;<br>            array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[capacity];<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (size == capacity) &#123;<br>            <span class="hljs-comment">//扩容，1.5倍、1.618倍、2倍：建议这些</span><br>            capacity += capacity &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span>[] newArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[capacity];<br>            <span class="hljs-comment">//拷贝</span><br>            System.arraycopy(array, <span class="hljs-number">0</span>, newArray, <span class="hljs-number">0</span>, size);<br>            <span class="hljs-comment">//替换</span><br>            array = newArray;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除指定位置的元素</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> index</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<span class="hljs-comment">//[0..size)</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">removed</span> <span class="hljs-operator">=</span> array[index];<br>        <span class="hljs-keyword">if</span> (index &lt; size - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">//拷贝，把目标index后的元素都往前移动一位</span><br>            System.arraycopy(array, index + <span class="hljs-number">1</span>, array, index, size - index - <span class="hljs-number">1</span>);<br>            size--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> removed;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查询指定位置的元素</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> index 索引</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 时间复杂度：O(1)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<span class="hljs-comment">// [0..size)</span><br>        <span class="hljs-keyword">return</span> array[index];<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 使用函数式接口Consumer,遍历数组，</span><br><span class="hljs-comment">     * 对每个元素执行consumer.accept(array[i])，令调用方执行自定义的操作</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> consumer</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">foreach</span><span class="hljs-params">(Consumer&lt;Integer&gt; consumer)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            <span class="hljs-comment">// 提供array[i]</span><br>            <span class="hljs-comment">// 返回void</span><br>            consumer.accept(array[i]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 迭代器遍历</span><br><span class="hljs-comment">     * 实现Iterable接口，使得DynamicArray可以使用foreach语法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Iterator&lt;Integer&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Iterator</span>&lt;Integer&gt;() &#123;<br>            <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> index &lt; size;<span class="hljs-comment">//index &lt; size表示还有元素</span><br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> array[index++];<br>            &#125;<br>        &#125;;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取流对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> IntStream <span class="hljs-title function_">stream</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> IntStream.of(Arrays.copyOfRange(array, <span class="hljs-number">0</span>, size));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="System-arraycopy"><a href="#System-arraycopy" class="headerlink" title="System.arraycopy"></a>System.arraycopy</h2><p class="note note-warning">注：System.arraycopy(Object src, int srcPos, Object dest, int destPos, int length);</br>- src：源数组，即要复制的数组。</br>- srcPos：源数组的起始位置，从源数组的哪个索引开始复制。</br>- dest：目标数组，即复制到的数组。</br>- destPos：目标数组的起始位置，复制到目标数组的哪个索引位置。</br>- length：要复制的元素数量。</br></br>System.arrayCopy 的主要特点和注意事项：</br>1. **低级别操作：** 这是一种低级别的数组操作，直接在内存中复制数组内容，效率较高。    </br>2. **复制范围控制：** 你可以控制复制的范围，包括源数组的起始位置、目标数组的起始位置和要复制的元素数量。    </br>3. **原地复制：** 它允许在不创建新数组的情况下，将源数组的一部分复制到目标数组中，适用于需要在原地进行数据移动的情况。    </br>4. **数据类型检查：** `System.arrayCopy` 不会进行数据类型检查，因此要确保源和目标数组的数据类型一致，否则可能会导致运行时异常。    </br>5. **不会自动扩展：** 它不会自动扩展目标数组，如果目标数组长度不足以容纳复制的数据，会导致数组越界异常。    </br>6. **效率高：** 由于是底层操作，因此通常情况下比使用迭代或循环来复制数组要更高效</p><h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p class="note note-primary">这个很有趣，推荐平常多使用函数式接口来优化代码，这里总结汇总一下吧。</p><h3 id="Runnable-和-Callable"><a href="#Runnable-和-Callable" class="headerlink" title="Runnable 和 Callable"></a>Runnable 和 Callable</h3><ul><li><code>Runnable</code> 通常用于<strong>多线程编程，用于定义线程要执行的任务</strong>。它没有输入参数，也没有返回值。</li><li><code>Callable</code> 类似于 <code>Runnable</code>，但<strong>允许任务返回结果</strong>。通常与线程池一起使用，可以获得任务执行的结果。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用Runnable创建线程任务</span><br><span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> () -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;Hello from Runnable&quot;</span>);<br>&#125;;<br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable);<br>thread.start();<br><br><span class="hljs-comment">// 使用Callable和ExecutorService获取线程任务的返回值</span><br>Callable&lt;Integer&gt; callable = () -&gt; &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;<br>&#125;;<br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newSingleThreadExecutor();<br>Future&lt;Integer&gt; result = executorService.submit(callable);<br>System.out.println(<span class="hljs-string">&quot;Result from Callable: &quot;</span> + result.get());<br>executorService.shutdown();<br></code></pre></td></tr></table></figure><h3 id="Comparator"><a href="#Comparator" class="headerlink" title="Comparator"></a>Comparator</h3><ul><li><code>Comparator</code> 用于<strong>比较两个对象的顺序</strong>。它通常用于集合的排序操作。</li><li>可以使用 <code>Comparator</code> 的 <code>comparing</code> 方法创建比较器，也可以使用 <code>reversed</code> 方法反转比较器的顺序。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; names = Arrays.asList(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;Charlie&quot;</span>);<br>names.sort((s1, s2) -&gt; s1.compareTo(s2));<br><span class="hljs-comment">// 或者使用Comparator.comparing方法</span><br>names.sort(Comparator.comparing(String::length));<br></code></pre></td></tr></table></figure><h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><ul><li>直译有”消费者”的含义。</li><li><code>Consumer</code> 用于<strong>接受一个参数并执行操作，通常没有返回值</strong>。它常用于集合的遍历和元素处理。</li><li>可以使用 <code>andThen</code> 方法组合多个 <code>Consumer</code>，形成一个连续的操作链。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; numbers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br>Consumer&lt;Integer&gt; printSquare = (num) -&gt; System.out.println(num * num);<br>numbers.forEach(printSquare);<br></code></pre></td></tr></table></figure><h3 id="Supplier"><a href="#Supplier" class="headerlink" title="Supplier"></a>Supplier</h3><ul><li>直译有“供应者”的含义。</li><li><code>Supplier</code> <strong>通常不接受参数，用于生成一个值</strong>。它可以用于延迟加载或惰性计算。</li><li>可以在需要值的地方<strong>调用 <code>get</code> 方法来获取值</strong>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Supplier&lt;Double&gt; randomNumberSupplier = () -&gt; Math.random();<br><span class="hljs-type">double</span> <span class="hljs-variable">randomValue</span> <span class="hljs-operator">=</span> randomNumberSupplier.get();<br>System.out.println(<span class="hljs-string">&quot;Random Value: &quot;</span> + randomValue);<br></code></pre></td></tr></table></figure><h3 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h3><ul><li>直译有”谓语”的含义。</li><li><code>Predicate</code> <strong>接受一个参数并返回布尔值，用于进行条件判断</strong>。它通常用于过滤和筛选数据。</li><li>可以使用 <code>and</code>、<code>or</code> 和 <code>negate</code> 方法来组合多个谓词。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; numbers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br>Predicate&lt;Integer&gt; isEven = (num) -&gt; num % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;<br>List&lt;Integer&gt; evenNumbers = numbers.stream().filter(isEven).collect(Collectors.toList());<br></code></pre></td></tr></table></figure><h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h3><ul><li><code>Function</code> <strong>接受一个参数并返回一个值，用于将输入映射到输出</strong>。它通常用于数据转换和处理。</li><li>可以使用 <code>andThen</code> 和 <code>compose</code> 方法来组合多个函数，形成一个函数链。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Function&lt;Integer, String&gt; intToString = (i) -&gt; String.valueOf(i);<br><span class="hljs-type">String</span> <span class="hljs-variable">stringValue</span> <span class="hljs-operator">=</span> intToString.apply(<span class="hljs-number">42</span>);<br>System.out.println(<span class="hljs-string">&quot;String Value: &quot;</span> + stringValue);<br></code></pre></td></tr></table></figure><h3 id="BiFunction"><a href="#BiFunction" class="headerlink" title="BiFunction"></a>BiFunction</h3><ul><li><code>BiFunction</code> <strong>接受两个参数并返回一个值，用于处理两个输入并产生一个输出</strong>。它通常用于需要两个输入的操作。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">BiFunction&lt;Integer, Integer, Integer&gt; add = (a, b) -&gt; a + b;<br><span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> add.apply(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>);<br>System.out.println(<span class="hljs-string">&quot;Sum: &quot;</span> + sum);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>data&amp;algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>二维数组</tag>
      
      <tag>函数式接口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构和算法之旅（零）- 认识算法</title>
    <link href="/posts/24ec10c/"/>
    <url>/posts/24ec10c/</url>
    
    <content type="html"><![CDATA[<p class="note note-secondary">通过二分查找算法，认识算法。</br>需求：在有序数组A内，查找值target：</br>1.如果找到返回索引；</br>2.如果找不到返回-1；</p><h2 id="二分查找算法"><a href="#二分查找算法" class="headerlink" title="二分查找算法"></a>二分查找算法</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>根据需求，可以直观的想出来的解法如下：</p><ul><li>前提：给定一个内含n个元素的有序数组A，查找指定值target;</li><li>1.设置<code>i = 0</code>为左边界索引，<code>j = n - 1</code>为右边界索引;</li><li>2.如果<code>i &gt; j</code>，结束查找，没找到；</li><li>3.设置<code>m = medium((i+j)/2)</code>，m为中间索引，medium是向下取整的最小整数；</li><li>4.如果<code>target &lt; A[m]</code>，设置 <code>j = m - 1</code>，转第二步；</li><li>5.如果<code>A[m] &lt; target</code>，设置<code>i = m + 1</code>，转第二步；</li><li>6.如果<code>A[m] = target</code>，结束查找，说明找到了；</li></ul><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearchBasic</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> target)</span>&#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = a.length - <span class="hljs-number">1</span>;<span class="hljs-comment">//设置指针和初值</span><br><span class="hljs-keyword">while</span>(i&lt;=j)&#123;<br><span class="hljs-comment">//int m = (i+j)/2;//java除法自动取整，但除法有隐患，当然数值范围不大可以忽略</span><br><span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> (i+j)&gt;&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-comment">//无符号右移，相当于除以2，且能避免隐患</span><br><span class="hljs-keyword">if</span>(target&lt;a[m])&#123;<br><span class="hljs-comment">//如果目标在中间值的左边，设置右边界指针为中间索引-1</span><br>j = m - <span class="hljs-number">1</span>;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[m]&lt;target)&#123;<br><span class="hljs-comment">//如果目标在中间值的右边，设置左边界指针为中间索引+1</span><br>i = m + <span class="hljs-number">1</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">//找到了</span><br><span class="hljs-keyword">return</span> m;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="why"><a href="#why" class="headerlink" title="why"></a>why</h3><p class="note note-danger">Q：为什么是i <= j 意味着区间内有未比较的元素，而不是i < j ？</p><p class="note note-success">A：因为i=j 指向的元素也有可能是要查找的目标，如果没有等号，就会漏掉一次比较；</p><p class="note note-danger">Q：(i+j)/2 有没有问题？为什么使用右移代替？</p><p class="note note-success">A：因为如果数组无限大，j初始是Integer.MAX_VALUE - 1。第一次(i+j)/2没问题，但是如果此时，目标值比中间值大，需要把左侧i边界设置为m+1，那么此时，再进行取中间索引时候，(i+j)/2. 一个是Integer.MAX_VALUE的一半，一个是MAX_VALUE就会超过正整数能表达的范围，就会得到一个负数。负数是补码的形式，符号位不变，数值为取反。所以会得到一个负数；java里面二进制数都是有符号的，最高位是符号位。</p><p class="note note-danger">Q：为什么判断条件都写小于符号？</p><p class="note note-success">A：因为这里数组a是升序排列的，写成小于符号，相当于与数组排列的顺序是一致的。</p><h2 id="二分查找的应用"><a href="#二分查找的应用" class="headerlink" title="二分查找的应用"></a>二分查找的应用</h2><h3 id="重复元素"><a href="#重复元素" class="headerlink" title="重复元素"></a>重复元素</h3><p class="note note-secondary">需求，如果存在重复元素，希望找到最左侧的第一个元素</br>这种形式称为LeftMost，找最右侧的第一个元素，即为RightMost</p><p class="note note-info">首先，还是二分查找的解法，只不过在找到了的分支，追加向左区间继续找或向右区间继续找目标值的逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * 二分查找 - LeftMost  </span><br><span class="hljs-comment"> * 重复元素的数组中，查找最左侧的  </span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearchLeftMost</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> target)</span> &#123;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = a.length - <span class="hljs-number">1</span>;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">candidate</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">//候选  </span><br>    <span class="hljs-keyword">while</span> (i &lt;= j) &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> (i + j) &gt;&gt;&gt; <span class="hljs-number">1</span>;  <br>        <span class="hljs-keyword">if</span> (target &lt; a[m]) &#123;  <br>            j = m - <span class="hljs-number">1</span>;  <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a[m] &lt; target) &#123;  <br>            i = m + <span class="hljs-number">1</span>;  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            <span class="hljs-comment">//只需要修改这里，找到目标需要存为候选，然后继续向左边找  </span><br>            candidate = m;  <br>            <span class="hljs-comment">//继续向左边找，则需要设置右侧指针移至中间索引-1  </span><br>            j = m - <span class="hljs-number">1</span>;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> candidate;  <br>&#125;<br><br><br><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * 二分查找 - RightMost  </span><br><span class="hljs-comment"> * 重复元素的数组中，查找最右侧的  </span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearchRightMost</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> target)</span> &#123;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = a.length - <span class="hljs-number">1</span>;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">candidate</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">//候选  </span><br>    <span class="hljs-keyword">while</span> (i &lt;= j) &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> (i + j) &gt;&gt;&gt; <span class="hljs-number">1</span>;  <br>        <span class="hljs-keyword">if</span> (target &lt; a[m]) &#123;  <br>            j = m - <span class="hljs-number">1</span>;  <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a[m] &lt; target) &#123;  <br>            i = m + <span class="hljs-number">1</span>;  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            <span class="hljs-comment">//只需要修改这里，找到目标需要存为候选，然后继续向右边找  </span><br>            candidate = m;  <br>            <span class="hljs-comment">//继续向右边找，则需要设置左侧指针移至中间索引+1  </span><br>            i = m + <span class="hljs-number">1</span>;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> candidate;  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="求排名"><a href="#求排名" class="headerlink" title="求排名"></a>求排名</h3><p class="note note-secondary">求排名，其实是LeftMost的应用，看一个图就了解了</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309201022852.png"></p><p class="note note-info">所以，求排名的解法就是：LeftMost+1。</p><h3 id="求前任后任"><a href="#求前任后任" class="headerlink" title="求前任后任"></a>求前任后任</h3><p class="note note-secondary">还是这张图，也是最左和最右的应用。</p><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309201022852.png"></p><p class="note note-info">分析可知，</br>求前任解法即：LeftMost-1</br>求后任解法即：RightMost+1</p><h3 id="最近邻居"><a href="#最近邻居" class="headerlink" title="最近邻居"></a>最近邻居</h3><p class="note note-info">比如5的最近邻居是4，因为4和5差1，5和7差2，</br>就是找到前任和后任，然后比对，找到其中最小的。</p><h3 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h3><p class="note note-info">比如想找所有小于4的目标，0 .. LeftMost(4) - 1</br>比如找所有小于等于4的目标， 0 .. RightMost(4)</br>比如找所有大于4的目标， RightMost(4)+1 .. 无穷大</br>比如找所有大于等于4的目标，LeftMost(4) .. 无穷大</br>找 4 <= x <=7 ，LeftMost(4) .. RightMost(7)</br>找 4 < x <=7，RightMost(4)+1 .. LeftMost(7)-1</p><h3 id="leetcode"><a href="#leetcode" class="headerlink" title="leetcode"></a>leetcode</h3><p><img src="https://hexo-img-bucket-1306020160.cos.ap-beijing.myqcloud.com/pic/202309201038568.png"></p><p class="note note-info">抱一丝，仍然是leftMost和rightMost的应用，有了最左和最右就可以得到结果，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">pubic <span class="hljs-type">int</span>[] searchRange(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> target)&#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> leftMost(a, target);<br><span class="hljs-keyword">if</span>(left == -<span class="hljs-number">1</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;left, rightMost(a, traget)&#125;;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>data&amp;algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
